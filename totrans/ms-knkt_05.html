<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Durandal – the Knockout Framework</h1></div></div></div><p class="calibre8">In the previous chapter, we looked at how to use RequireJS and SammyJS with Knockout, to add more standard functionality to our frontend stack with module definitions and client-side routing. Both of these concepts have become very common in the JavaScript world; you might even consider them as a standard for modern web applications. Knockout is a library and not a framework, in that it fills a specific role—data-binding—instead of trying to be the entire development framework for the frontend. This leaves a lot of decisions to be made if you want to create a modern JavaScript client, which can be burdensome, time-consuming, and, if your team is divided, contentious. Durandal is a framework that attempts to make many of these decisions while still keeping Knockout's MVVM philosophy in mind.</p><p class="calibre8">Durandal was created by Blue Spire, whose principal developer, Rob Eisenberg, also created the popular WPF framework Caliburn.Micro, another MVVM framework. Over the next two chapters, we will be looking at how Durandal can help us build web applications easily while leveraging all of our experience and custom code from Knockout. This chapter is going to cover the following:</p><div><ul class="itemizedlist"><li class="listitem">Overview of the Durandal framework</li><li class="listitem">The composition system</li><li class="listitem">The router</li><li class="listitem">Modal dialogs</li><li class="listitem">The application's life cycle</li><li class="listitem">Widgets</li></ul></div><p class="calibre8">Once again, we will be using the <code class="literal">Contacts</code> application with the chapter's examples.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec35" class="calibre1"/>An overview of the Durandal framework</h1></div></div></div><p class="calibre8">Durandal is <a id="id375" class="calibre1"/>built on top of Knockout, jQuery, and RequireJS. Durandal's core is a collection of AMD modules, which provide composition, events, and activation features, as well as some utility functions. In addition to the core modules, Durandal also provides several plugins that can optionally be activated, or added to with community or personal plugins. The plugins include the router (a basic requirement for every SPA framework), dialogs, and widgets.</p><div><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">The documentation for <a id="id376" class="calibre1"/>Durandal can be found at <a class="calibre1" href="http://durandaljs.com/docs.html">http://durandaljs.com/docs.html</a>.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec78" class="calibre1"/>Promises</h2></div></div></div><p class="calibre8">To bring all of this together, Durandal's internal and external <a id="id377" class="calibre1"/>communication is handled through <a id="id378" class="calibre1"/>
<strong class="calibre9">promises</strong>. If you aren't familiar with JavaScript promises—sometimes called <em class="calibre12">thenables</em> because<a id="id379" class="calibre1"/> they provide a <code class="literal">then</code> method—you're missing out. To explain briefly, promises change the way asynchronous actions are handled by replacing a callback with a return object that represents the asynchronous work. It allows asynchronous tasks to be chained, and does error handling in a simple, easy-to-debug manner. I won't be covering how promises work here, but it is going to be relevant. You should read up on them if you haven't already done so.</p><p class="calibre8">If you are familiar with promises, you may already know that jQuery's promise implementation does not match the <a id="id380" class="calibre1"/>A+ specification (<a class="calibre1" href="https://promisesaplus.com">https://promisesaplus.com</a>), which most other promise libraries conform to. To minimize third-party dependencies, Durandal uses jQuery's promises by default, but their documentation provides a simple patch to allow the use of another promise implementation. This example, which uses Q (a very popular promise library), is taken from the Durandal documentation. Use it before the call to <code class="literal">app.start()</code> (we will learn more about this later):</p><div><pre class="programlisting">system.defer = function (action) {
  var deferred = Q.defer();
  action.call(deferred, deferred);
  var promise = deferred.promise;
  deferred.promise = function() {
    return promise;
  };
  return deferred;
};</pre></div><p class="calibre8">If you prefer another library, simply replace <code class="literal">Q</code> in the preceding code. I will be using Durandal's default promises in this chapter for simplicity, but I encourage you to use an A+ compliant implementation in real-world applications.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec79" class="calibre1"/>Getting started</h2></div></div></div><p class="calibre8">While Durandal's only real <a id="id381" class="calibre1"/>requirement on your filesystem is that all its core modules should be in the same folder and all its plugins should be in their own folder, there are some conventions for the way things are organized, as shown in the following screenshot:</p><div><img src="img/00009.jpeg" alt="Getting started" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">This should be familiar, as it isn't too different from what we have been using. The <code class="literal">app</code> directory contains our code, the <code class="literal">lib</code> directory contains third-party code, and the <code class="literal">content</code> directory contains our CSS and other visual assets. Durandal's entire source, which contains some of its own CSS, its core modules, as well as the standard plugins directory, is dropped into <code class="literal">lib</code>. Our <code class="literal">main.js</code> configuration looks like this:</p><div><pre class="programlisting">require.config({
  paths: {
    'text': '../lib/require/text',
    'durandal':'../lib/durandal/js',
    'plugins' : '../lib/durandal/js/plugins',
    'transitions' : '../lib/durandal/js/transitions',
    'knockout': '../lib/knockout-3.1.0',
    'bootstrap': '../lib/bootstrap-3.1.1',
    'jquery': '../lib/jquery-2.1.1.min'
  },
  shim: {
    'bootstrap': {
      deps: ['jquery'],
      exports: 'jQuery'
    }
  },
  waitSeconds: 30
});</pre></div><p class="calibre8">There shouldn't be <a id="id382" class="calibre1"/>anything surprising here, as we covered the configuration of RequireJS in the previous chapter. All of the paths, except <code class="literal">bootstrap</code>, are required by Durandal. After configuration, Durandal needs to be initialized; this is generally placed in <code class="literal">main.js</code>, just below <code class="literal">require.config</code>:</p><div><pre class="programlisting">define(['durandal/system', 'durandal/app'],
function(system, app, extensions) {

  system.debug(true);

  //specify which plugins to install and their configuration
  app.configurePlugins({
    //Durandal plugins
    router:true,
    dialog: true
  });

  app.title = 'Mastering Knockout';
  app.start().then(function () {
    app.setRoot('shell/shell');
  });
});</pre></div><p class="calibre8">The <code class="literal">app</code> and <code class="literal">system</code> modules are Durandal objects. The <code class="literal">system.debug</code> call instructs Durandal to log all of the steps it takes to the console, which is useful for development. The <code class="literal">app.configurePlugins</code> call registers the plugins to be installed, though they are not run until <code class="literal">app.start</code> is called. The <code class="literal">app.start</code> call initializes all the Durandal modules and installs the registered plugins. As <code class="literal">app.start</code> is a promise-returning function, a <code class="literal">then</code> method is attached, which calls <code class="literal">app.setRoot</code> when it is finished. The <code class="literal">setRoot</code> method composes the specified module into the DOM as the root viewmodel of the application.</p><p class="calibre8">The root of the application is placed inside a <code class="literal">div</code> element with the <code class="literal">applicationHost</code> ID, which is expected to be in the DOM already. As Durandal will take care of all the HTML rendering, the original DOM is pretty thin. It only requires the CSS that will be used, the <code class="literal">applicationHost</code> ID, and the <code class="literal">script</code> tag for RequireJS. This is the standard <code class="literal">index.html</code> file:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Mastering Knockout&lt;/title&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;link rel="stylesheet" href="content/css/bootstrap-3.1.1-darkly.css" type="text/css" media="all"  title="darkly" /&gt;
    &lt;link rel="alternate stylesheet" href="content/css/bootstrap-3.1.1-cosmo.css" type="text/css" media="all" title="cosmo" /&gt;
    &lt;link rel="stylesheet" href="content/css/font-awesome-4.0.3.css" type="text/css" media="all" /&gt;

    &lt;link rel="stylesheet" href="lib/durandal/css/durandal.css" /&gt;
    &lt;link rel="stylesheet" href="content/css/app.css" 
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!-- Main Application Body --&gt;
    &lt;div id="applicationHost"&gt;&lt;/div&gt;
    &lt;script type="text/javascript" src="img/require.js" data-main="app/main"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre8">That's it! Durandal has <a id="id383" class="calibre1"/>been started and everything after this point is going to be your application's code.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec36" class="calibre1"/>The composition system</h1></div></div></div><p class="calibre8">In the previous <a id="id384" class="calibre1"/>chapter, we looked at Knockout's new components feature, which lets us construct view/viewmodel pairs by instantiating them from the DOM with custom elements (or bindings). Knockout released this feature after Durandal, so there is some overlap between the two. Durandal's composition is like a blend of the components and the template binding.</p><p class="calibre8">Composition is primarily invoked in two ways, with <code class="literal">setRoot</code> to compose the <code class="literal">applicationHost</code> ID, and with the compose binding for data-bound values. Composition works by pairing a viewmodel with a view.</p><div><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">Durandal's documentation refers to viewmodels as modules, which I think is a bit confusing. I will be referring to composable modules as viewmodels throughout this chapter.</p></div><p class="calibre8">When composition is given a viewmodel, it looks up the view, loads it with the RequireJS's text loader, binds it to the view, and finally, attaches it to the DOM.</p><p class="calibre8"><strong class="calibre9">Composing the application's root</strong></p><p class="calibre8">Let's look at the root composition of our <a id="id385" class="calibre1"/>shell viewmodel. Our preceding sample<a id="id386" class="calibre1"/> was setting the root to <code class="literal">shell/shell</code>. If<a id="id387" class="calibre1"/> our <code class="literal">app</code> directory has a <code class="literal">shell</code> folder, the <code class="literal">shell.js</code> module will be loaded by <code class="literal">setRoot</code> and composed. Composition uses Durandal's <code class="literal">viewLocator</code> module to find an HTML file, by replacing the file extension of the module; so for <code class="literal">shell.js</code>, it will look for <code class="literal">shell.html</code> and use it as the view.</p><p class="calibre8">You can see a very simple example of this in <code class="literal">cp5-shell</code>. The <code class="literal">shell</code> module is very simple, containing just a <code class="literal">title</code> property that we will bind to:</p><div><pre class="programlisting">define(function (ko, app) {
  return {
    title: 'Welcome!'
  };
});</pre></div><pre>&lt;html&gt;</code> root element:</pre><div><pre class="programlisting">&lt;div class="jumbotron"&gt;
  &lt;h1 data-bind="text: title"&gt;&lt;/h1&gt;
  &lt;p&gt;This HTML was rendered into the DOM with Durandal's composition system. Notice the data-binding on the &lt;code&gt;h1&lt;/code&gt; tag with the viewmodel property &lt;code&gt;title&lt;/code&gt;.&lt;/p&gt; 
&lt;/div&gt;</pre></div><p class="calibre8">Durandal expects views to be partial HTML documents. They should not contain an <code class="literal">HTML</code>, <code class="literal">HEAD</code>, or <code class="literal">BODY</code> element; they should contain only the HTML that will be used as the template for the DOM contents.</p><p class="calibre8">If you run the code, you will see that this HTML is rendered into the DOM, and the title is bound to the <code class="literal">shell</code> module's <code class="literal">title</code> property. The object returned by the <code class="literal">shell</code> module is used as the binding context for the shell's view.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec80" class="calibre1"/>The compose binding</h2></div></div></div><p class="calibre8">Generally, the root of the<a id="id388" class="calibre1"/> application does not change, and instead, serves as the<a id="id389" class="calibre1"/> layout or shell for the HTML. It displays content that is present on every page (such as a navigation bar), and hence it doesn't need to change. Composition can also be invoked with the compose binding, which takes a viewmodel as a binding value.</p><p class="calibre8">Open the <code class="literal">cp5-composition</code> branch. Notice that the shell view is back to containing our familiar navigation bar, as well as a compose binding, in its main content area:</p><div><pre class="programlisting">&lt;div&gt;
  &lt;nav class="…" role="banner"&gt;
    //Standard Nav Bar HTML you've seen in every other sample
  &lt;/nav&gt;

  &lt;div class="page-host container"&gt;
    &lt;div data-bind="compose: currentModel"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre8">The shell viewmodel has a <code class="literal">currentModel</code> property, as well as two functions, to switch the <code class="literal">currentModel</code> property between the <code class="literal">edit</code> and <code class="literal">list</code> page objects:</p><div><pre class="programlisting">define(['knockout', 'durandal/app', 'contacts/edit', 'contacts/list'], 
function (ko, app, EditVm, ListVm) {
  var listVm = new ListVm(),
  editVm = new EditVm();
  return {
    title: app.title,
    currentModel: ko.observable(listVm),
    setEdit: function() { this.currentModel(editVm); },
    setList: function() { this.currentModel(listVm); }
  };
});</pre></div><p class="calibre8">Try pressing the buttons in the navigation bar to see the body content switch between the two pages. The compose binding is taking a module instance, locating its view, and binding the view as the content of the DOM. As <code class="literal">currentModel</code> is observable, the composition reruns anytime it changes.</p><p class="calibre8">As the <code class="literal">list</code> and <code class="literal">edit</code> objects are constructed once and just swapped, you should notice that values entered on the edit page are persistent. This is because, while the HTML is discarded and recreated when switching, the new HTML is still being bound against the same object.</p><p class="calibre8">Hopefully, the brevity of this example doesn't undercut the power of the composition system. The fact that they are so small should highlight just how easy composition is to work with; just by swapping a bound value, we can toggle between two completely different pages!</p><p class="calibre8">You may have noticed<a id="id390" class="calibre1"/> that composition is like a mirror of Knockout components. Instead <a id="id391" class="calibre1"/>of a custom element or binding in the DOM choosing what will be rendered, composition renders the value specified by JavaScript. This ends up having a large impact on flexibility. A component is the element that the DOM says it is, but a single compose binding can hold any module and it can change at any time. They may seem like competing features, but I think they are serving different goals.</p><p class="calibre8">Components are like advanced binding handlers, allowing the HTML to instantiate behavior-driven templates.</p><p class="calibre8">Composition uses the relationships created and managed by our viewmodel code and reflects them in the presentation layer.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec81" class="calibre1"/>Composition options</h2></div></div></div><p class="calibre8">We looked at two examples of <a id="id392" class="calibre1"/>composition—<code class="literal">setRoot</code> and the compose binding—that each took an instance of an object to compose. Of course, Durandal is a thoughtful framework, so the composition has several other modes of operation. The value taken by the compose binding can be any of the following.</p><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec29" class="calibre1"/>Module instance</h3></div></div></div><p class="calibre8">We've already covered this, but<a id="id393" class="calibre1"/> for the sake of completion, the compose <a id="id394" class="calibre1"/>binding can take an instance of a module and use it to locate the view. See the <code class="literal">cp5-composition</code> branch for an example. This is the most common use case for composition with the compose binding.</p></div><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec30" class="calibre1"/>Constructor</h3></div></div></div><p class="calibre8">In the <code class="literal">cp5-composition2</code> branch, you can<a id="id395" class="calibre1"/> see a modified shell that <a id="id396" class="calibre1"/>sets the <code class="literal">currentModel</code> property to the constructor functions directly:</p><div><pre class="programlisting">define(['knockout', 'durandal/app', 'contacts/edit', 'contacts/list'], 
function (ko, app, EditVm, ListVm) {
  return {
    title: app.title,
    currentModel: ko.observable(ListVm),
    setEdit: function() { this.currentModel(EditVm); },
   setList: function() { this.currentModel(ListVm); }
  };
});</pre></div><p class="calibre8">While this isn't a great use case, it is supported. Constructors are most commonly used for modules tied to the router, as a fresh viewmodel is generally desirable when navigating between pages. Unlike the previous <a id="id397" class="calibre1"/>example, which stored a reference to a constructed viewmodel for each page, this<a id="id398" class="calibre1"/> method will recreate the viewmodel each time it navigates.</p></div><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec31" class="calibre1"/>Module ID strings</h3></div></div></div><p class="calibre8">There are two ways to use <a id="id399" class="calibre1"/>strings for the compose binding value. The first is <a id="id400" class="calibre1"/>by supplying a module ID. You can see this in the <code class="literal">cp5-composition3</code> branch:</p><div><pre class="programlisting">currentModel: ko.observable(''contacts/list''),
setEdit: function() { this.currentModel(''contacts/edit''); },
setList: function() { this.currentModel('contacts/list'); }</pre></div><p class="calibre8">This results in the module being composed. If the module returns an object, it is composed directly; if the module returns a function, it is treated as a constructor to create the object. Of course, because it's a string, this could be used in the binding directly:</p><div><pre class="programlisting">&lt;div data-bind="compose: 'contacts/list'"&gt;&lt;/div&gt;</pre></div><p class="calibre8">While supported, I personally feel like this violates the separation of concerns. It ties the HTML view directly to a viewmodel.</p></div><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec32" class="calibre1"/>Viewpath strings</h3></div></div></div><p class="calibre8">The second way to<a id="id401" class="calibre1"/> use <a id="id402" class="calibre1"/>strings in the compose binding is with a viewpath. If the string contains an extension that the <code class="literal">viewEngine</code> module recognizes, it will be used to load that view and bind it to the current binding context. The common use case here is partial views:</p><div><pre class="programlisting">&lt;div class="page-host container"&gt;
    &lt;div data-bind="compose: 'shell/sub.html'"&gt;&lt;/div&gt;
&lt;/div&gt;</pre></div><p class="calibre8">Again, the string could be in the HTML or come from the viewmodel. In this case, as a view is referring to another view, I think the string belongs to the HTML. Otherwise, the reverse violation of the separation of concerns occurs, where a viewmodel has a direct reference to a view.</p><p class="calibre8">This sample can be seen in <code class="literal">cp5-composition4</code>.</p></div><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec33" class="calibre1"/>Explicit models and views</h3></div></div></div><p class="calibre8">The compose <a id="id403" class="calibre1"/>binding can also take a <a id="id404" class="calibre1"/>settings<a id="id405" class="calibre1"/> object that specifies a model, a <a id="id406" class="calibre1"/>view, or both. There isn't much to say about these examples, so this section is taken directly from the Durandal documentation:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">data-bind="compose: { model: model }"</code>: This uses the value of <code class="literal">model</code> with <code class="literal">viewLocator</code> to obtain a view. They are then bound and the view is injected into the DOM node.</li><li class="listitem"><code class="literal">data-bind="compose: { view: view }"</code>: This evaluates the value of <code class="literal">view</code>. If it is a string, then <code class="literal">viewLocator</code> is used to locate the view; otherwise, it is assumed to be a view. The resultant view is injected into the DOM node.</li><li class="listitem"><code class="literal">data-bind="compose: { model: model, view: view }"</code>: This resolves the value of <code class="literal">model</code>. The value of <code class="literal">view</code> is resolved and a view is constructed as indicated in the previous point. Both <code class="literal">model</code> and <code class="literal">view</code> are then bound and injected into the DOM node.</li><li class="listitem"><code class="literal">data-bind="compose: { model: model, view:'myView.html' }"</code>: The value of <code class="literal">model</code> is resolved. The <code class="literal">viewLocator</code> module is then used to obtain the view indicated by the <code class="literal">view</code> property. They are then bound, and the view is injected into the DOM node.</li><li class="listitem"><code class="literal">data-bind="compose: { model:'shell', view: view }"</code>: RequireJS is used to resolve the <code class="literal">shell</code> module. The value of <code class="literal">view</code> is resolved and a view is returned, as described in the previous point. The view is then bound to the resolved module and injected into the DOM node.</li><li class="listitem"><code class="literal">data-bind="compose: { model:'shell', view:'myView.html' }"</code>: RequireJS is used to resolve the <code class="literal">shell</code> module. The <code class="literal">viewLocator</code> module is then used to obtain the view indicated by <code class="literal">view</code>. The view is then bound to the resolved module and injected into the DOM node.</li></ul></div></div><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec34" class="calibre1"/>Containerless composition</h3></div></div></div><p class="calibre8">All of the preceding examples work <a id="id407" class="calibre1"/>with Knockout's containerless comment syntax as well, so the following is valid:</p><div><pre class="programlisting">&lt;!-- ko compose: model--&gt;&lt;!--/ko--&gt;</pre></div><div><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre8">The composition system has more features than there are in the scope of this chapter, including view caching, transitions, template mode, and custom view location strategies. They will be discussed in the next chapter, which covers more advanced use cases.</p></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec82" class="calibre1"/>View locations</h2></div></div></div><p class="calibre8">As mentioned earlier, the default <a id="id408" class="calibre1"/>behavior of the <code class="literal">viewLocator</code> module used by composition <a id="id409" class="calibre1"/>is to look for a view with the same path as the module, but with the <code class="literal">.html</code> extension. This results in modules grouped by folder:</p><div><img src="img/00010.jpeg" alt="View locations" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">In the preceding example, the <code class="literal">shell</code> directory contains the view and the viewmodel for the shell, and the <code class="literal">contacts</code> directory contains a base model for a contact, as well as a view and viewmodel for both <code class="literal">list</code> and <code class="literal">edit</code>. I think this organization is very easy to understand, and it scales well with large applications, as each feature or group of features is kept together.</p><p class="calibre8">Durandal offers another strategy though, which it calls the conventional strategy. You can activate it by modifying your <code class="literal">main.js</code> file to call <code class="literal">useConvention</code> on the <code class="literal">viewlocator</code> module:</p><div><pre class="programlisting">define(['durandal/system', 'durandal/app', 'durandal/viewLocator'],
function(system, app, viewLocator) {

  //plugin configuration omitted

  viewLocator.useConvention('viewmodels', 'views');

  app.title = 'Mastering Knockout';
  app.start().then(function () {
    app.setRoot('shell/shell');
  });
});</pre></div><p class="calibre8">This causes Durandal <a id="id410" class="calibre1"/>to look for a module with the <code class="literal">viewmodels/contactList</code> ID at <code class="literal">views/contactList.html</code>. While you can enter any strings for the viewmodels and<a id="id411" class="calibre1"/> views, paths, this is actually the default. Calling <code class="literal">viewLocator.useConvention()</code> (with no parameters) will produce the same effect.</p><p class="calibre8">I don't think this method scales as well, and I personally find it harder to work with. I prefer to have the viewmodel and view in the same location in the filesystem, so that I don't have to hunt for it. It's all up to you (or your team's) preference though.</p><p class="calibre8">All of the code samples shown here will use the default behavior, not the conventional behavior.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec37" class="calibre1"/>Using the router</h1></div></div></div><p class="calibre8">While technically an <a id="id412" class="calibre1"/>optional plugin, I don't imagine any real-world SPAs will do without the use of the router. While SammyJS ties a URL fragment to a function, Durandal's router ties the URL directly to a module ID. The module can return either a singleton or a constructor, and will be used to bind the view using the standard composition system.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec83" class="calibre1"/>Configuring the router</h2></div></div></div><p class="calibre8">Let's start <a id="id413" class="calibre1"/>configuring<a id="id414" class="calibre1"/> the router:</p><div><ol class="orderedlist"><li class="listitem" value="1">Route configuration is pretty straightforward. Here is the <code class="literal">shell</code> module with router configuration for the <code class="literal">Contact</code> application:<div><pre class="programlisting">define(['plugins/router', 'knockout', 'durandal/app'], 
function (router, ko, app) {
  return {
    title: app.title,
    router: router,
    activate: function() {

      router.map([
        { route: '', moduleId: 'contacts/list', title: 'Contacts', nav: true },
        { route: 'contacts/new', moduleId: 'contacts/edit', title: 'New Contact', nav: true },
        { route: 'contacts/:id', moduleId: 'contacts/edit', title: 'Contact Details', nav: false }
      ])
      .buildNavigationModel()
      .mapUnknownRoutes('shell/error', 'not-found');

      return router.activate();
    }
  };
});</pre></div></li><li class="listitem" value="2">The router plugin is required in the <code class="literal">shell</code> module and is set up during its <code class="literal">activate</code> method.</li><li class="listitem" value="3">The <code class="literal">map</code> method takes an array of routes and <code class="literal">buildNavigationModel</code> sets up those routes. The <code class="literal">mapUnknownRoutes</code> function takes a module ID and a route to use as a catch-all for attempts<a id="id415" class="calibre1"/> to navigate to routes that have not been registered. Without this, navigation will be canceled instead, with no error displayed to the user!</li><li class="listitem" value="4">We will<a id="id416" class="calibre1"/> cover <code class="literal">activate</code> and the other life cycle hooks in detail in a bit. For now, just know that <code class="literal">activate</code> is called during composition. If the return value from <code class="literal">activate</code> is a <code class="literal">promise</code>, then composition will wait until the promise resolves.</li><li class="listitem" value="5">Finally, <code class="literal">router.activate</code>, which also returns a <code class="literal">promise</code>, is returned to the shell's <code class="literal">activate</code> method, which chains the wait from composition until the router has finished.</li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec84" class="calibre1"/>Route properties</h2></div></div></div><p class="calibre8">The route's configuration objects that are passed to the <code class="literal">map</code> function take the following properties:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">route</code>: This is the URL <a id="id417" class="calibre1"/>to map to. It can be a string or an array of strings. Each string can take one of the following forms:<div><ul class="itemizedlist1"><li class="listitem">Default route: This is <code class="literal">route: ''</code>.</li><li class="listitem">Static route: This is <code class="literal">route: 'contacts'</code>.</li><li class="listitem">Parameterized route: This is <code class="literal">route: 'contacts/:id'</code>.</li><li class="listitem">Optional parameter route: This is <code class="literal">route: 'contacts(/:id)'</code>.</li><li class="listitem">Splat route: This is <code class="literal">route: 'contacts*details'</code>. It is a <em class="calibre12">wild card</em>, and will match any URL starting with <code class="literal">contacts</code>.</li></ul></div></li><li class="listitem"><code class="literal">moduleId</code>: This is the<a id="id418" class="calibre1"/> module to bind the route to.</li><li class="listitem"><code class="literal">hash</code>: This is used <a id="id419" class="calibre1"/>primarily for data binding <code class="literal">&lt;a&gt;</code> tags. In most cases, the router will generate this automatically, but it can be overridden. It is necessary to override this property on routes with optional parameters or splats.</li><li class="listitem"><code class="literal">title</code>: The <code class="literal">document.title</code> property is set to this value. If present, then the route is active; if <a id="id420" class="calibre1"/>absent, the <code class="literal">document.title</code> is not changed.</li><li class="listitem"><code class="literal">nav</code>: If <code class="literal">true</code>, the route <a id="id421" class="calibre1"/>will be included in the router's <code class="literal">navigationModel</code>, an observable array of routes created when <code class="literal">buildNavigationModel</code> is called, which can be used to easily generate navigation bars. The default value is <code class="literal">false</code>.</li></ul></div><p class="calibre8">If a module with an <code class="literal">activate</code> or <code class="literal">canActivate</code> function is activated by the router, the route's parameters are passed as arguments to it. Again, activation and other life cycle hooks will be covered in more detail later in this chapter.</p><p class="calibre8">Query strings are also passed in as the last parameters to <code class="literal">activate</code>/<code class="literal">canActivate</code> as objects with a key/value pair query string key.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec85" class="calibre1"/>Binding the router</h2></div></div></div><p class="calibre8">The router introduces a special binding, also called<a id="id422" class="calibre1"/> <strong class="calibre9">router</strong>, which wraps the compose binding with special handling logic. It shares the same properties as the compose binding:</p><div><pre class="programlisting">&lt;!-- ko router: { model: router.activeItem }--&gt; &lt;!-- /ko --&gt;</pre></div><p class="calibre8">The <code class="literal">activeItem</code> object on the router holds the currently active routes' module. If the <code class="literal">model</code> property on the router binding is omitted, the binding will look for a router property on the current binding context and take its <code class="literal">activeItem</code> object. The preceding example is equivalent to this one:</p><div><pre class="programlisting">&lt;!-- ko router: { }--&gt; &lt;!-- /ko --&gt;</pre></div><p class="calibre8">The router also has a <code class="literal">navigationModel</code> observable array, which is very useful in generating navigation bars:</p><div><pre class="programlisting">&lt;ul class="nav navbar-nav" data-bind="foreach: router.navigationModel"&gt;
  &lt;li data-bind="css: { active: isActive }"&gt;
    &lt;a class="" data-bind="attr: { href: hash }, text: title"&gt;&lt;/a&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">Each route has an <code class="literal">isActive</code> property, which indicates when the route is active, and a <code class="literal">hash</code> property, which can be used for a tag's <code class="literal">href</code> property.</p><p class="calibre8">Loading or navigating, are also exposed as observables on the router. This makes it easy to bind loading indicators on the page:</p><div><pre class="programlisting">&lt;i class="fa fa-spinner fa-3x fa-spin" data-bind="visible: router.isNavigating"&gt;&lt;/i&gt;</pre></div><p class="calibre8">Okay, time to look at a live example. Open the <code class="literal">cp5-router</code> branch. Try moving around the application by editing contacts or using the navigation bar links. Notice that the URL's hash is updated to match the current route. You can even use the browsers back and forward buttons to control navigation, as the router is hooked into the <code class="literal">window.location</code> object. Like all true SPAs, the<a id="id423" class="calibre1"/> navigation occurs inside the app, not by performing browser navigation.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec86" class="calibre1"/>Activating routes</h2></div></div></div><p class="calibre8">When a route is activated, the<a id="id424" class="calibre1"/> associated viewmodel module is loaded with RequireJS and composed into the DOM. The module loaded by RequireJS must either be an object, which will be treated as a singleton and bound to the view, or a function, which will be treated as a constructor and used to <code class="literal">new</code> up an object to bind to the view.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec87" class="calibre1"/>Navigation – hash change versus push state</h2></div></div></div><p class="calibre8">We just saw how the router <a id="id425" class="calibre1"/>handled navigation by changing the URL's hash. This is the default behavior, but the router also supports push state navigation. Push state navigation is the use of the HTML5 history API to modify the current URL and the history stack, without causing browser navigation. This results in prettier and normal looking URLs during router navigation. We see <code class="literal">http://localhost:3000/contacts/new</code> instead of <code class="literal">http://localhost:3000/#contacts/new</code>.</p><p class="calibre8">This mode of navigation can be activated by passing the <code class="literal">router.activate({ pushState: true })</code> calling. Though older browsers don't support push state, Durandal will gracefully degrade to hash change navigation when push state is not supported.</p><p class="calibre8">The reason this isn't the default behavior is because it requires support from the server to work properly. Currently, our server is only serving our application when we navigate to the root URL. If we try to navigate to <code class="literal">/contacts/new</code>, the server will display a <code class="literal">404</code> error. As Durandal is supposed to be in control of routes and navigation, adding this support route-by-route to the server would be a lot of duplication. The recommended way to support push state on the server is to use a wild card route to send all page requests to the index page. Once Durandal loads, it will detect the URL and activate the proper route.</p><p class="calibre8">The implementation of wild <a id="id426" class="calibre1"/>card routes will depend entirely on your server backend. Our examples are using a Node.js server, which makes it pretty easy:</p><div><pre class="programlisting">//Index Route
app.get('/*', function(req, res){
  res.sendfile(clientDir + '/index.html');
});</pre></div><p class="calibre8">That will take care of the page routing, but there is a much bigger supportability issue with push state routing; relative paths in HTML and the RequireJS config. Right now, all the links to CSS or the scripts in our code look like this:</p><div><pre class="programlisting">&lt;link rel="stylesheet" href="content/css/app.css" /&gt;</pre></div><p class="calibre8">This is a problem if the page tries to load <code class="literal">/contacts/new</code>, because <code class="literal">content/css</code> is a relative path; it will be treated by the browser as <code class="literal">/contacts/content/css</code>. Obviously this will fail; either the server will display a <code class="literal">404</code> error, or worse, the wild card route will cause the index page to be returned!</p><p class="calibre8">To fix this, all the paths need to be absolute paths; they have to start with a forward slash (<code class="literal">/</code>):</p><div><pre class="programlisting">&lt;link rel="stylesheet" href="/content/css/app.css" /&gt;</pre></div><p class="calibre8">This one can be nasty as is it requires manually updating any code with links in it, including the RequireJS config. As long as you are aware of the road you want to take when you start a project, this isn't much of a headache. If you can, I recommend going to the push state route. Having those nice looking URLs makes a big difference. It also frees the hash up to do its normal job of indicating a location or state on the page.</p><p class="calibre8">You can see an example of the push state scenario in <code class="literal">cp5-pushstate</code>. Note that as a special treat, this branch supports IE 8 so that you can see the graceful degradation to hash change navigation. The rest of the examples in this chapter will use push state navigation, but will return only to supporting ES5-compatible browsers.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec88" class="calibre1"/>Controlling the navigation from JavaScript</h2></div></div></div><p class="calibre8">Navigation can easily be done<a id="id427" class="calibre1"/> with the router's <code class="literal">navigate</code> function, which<a id="id428" class="calibre1"/> takes a URL string. The router is a singleton, and can be required into any module, using <code class="literal">plugins/router</code>:</p><div><pre class="programlisting">define(['durandal/app', 'knockout', 'services/mock', 'plugins/router'],
function(app, ko, dataService, router) {
  return function ContactListVM() {

    //…
    self.newEntry = function() {
      router.navigate('contacts/new');
    };
    self.editContact = function(contact) {
      router.navigate('contacts/' + contact.id());
    };
  };
});</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec38" class="calibre1"/>Modal dialogs</h1></div></div></div><p class="calibre8">After the overuse of modal dialogs in<a id="id429" class="calibre1"/> Windows, and alert boxes in early browser applications, modal dialogs have left a bad taste with some developers. However, when used appropriately, they are simple and powerful tools. Durandal's modal dialog implementation makes collecting user input from modals very easy, by making dialogs return promises that resolve when they close. Modal dialogs in Durandal come in two types, namely, message boxes and custom dialogs.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec89" class="calibre1"/>Message boxes</h2></div></div></div><p class="calibre8">For simple cases such <a id="id430" class="calibre1"/>as displaying a <a id="id431" class="calibre1"/>notification or collecting a single piece of user input, Durandal provides a modal dialog on <code class="literal">app.showMessage</code>, which takes the following parameters:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">Message (string)</code>: This contains <a id="id432" class="calibre1"/>the main contents of the message box.</li><li class="listitem"><code class="literal">Title (string, optional)</code>: This <a id="id433" class="calibre1"/>contains the title of the message box; the default title is <code class="literal">app.title</code>.</li><li class="listitem"><code class="literal">Buttons (array, optional)</code>: This<a id="id434" class="calibre1"/> is an array of buttons to show; the default is <code class="literal">['Ok']</code>. The first button in the array will be the default action of the dialog. If the array is an array of strings, then the text will be both the button text and the return value of clicking that button. To specify the value of a button, use an array of objects, that is, <code class="literal">[{ text: "One", value: 1 }, { text: "Two", value: 2 }]</code>.</li><li class="listitem"><code class="literal">Autoclose (boolean, optional)</code>: If <code class="literal">true</code>, the <a id="id435" class="calibre1"/>dialog will be closed if the user clicks outside of the dialog window; the default is <code class="literal">false</code>.</li><li class="listitem"><code class="literal">Settings (object, optional)</code>: See the <a id="id436" class="calibre1"/>upcoming <em class="calibre12">Message box settings</em> section.</li></ul></div><p class="calibre8">While a simple<a id="id437" class="calibre1"/> call to <code class="literal">app.showMessage('This is a message!')</code> is a good way to put something <a id="id438" class="calibre1"/>right in front of the user, I think the best use case for message boxes is the <em class="calibre12">Are you sure?</em> confirmation dialog:</p><div><img src="img/00011.jpeg" alt="Message boxes" class="calibre10"/></div><p class="calibre11"> </p><div><pre class="programlisting">self.deleteContact = function(contact) {
  app.showMessage('Are you sure you want to delete ' + contact.displayName() + '?', 'Delete Contact?', ['No', 'Yes'])
    .then(function(response) {
      if (response === 'Yes') {
        dataService.removeContact(contact.id(), function() {
          self.contacts.remove(contact);
        }); 
      }
    });
};</pre></div><p class="calibre8">Here we are showing <a id="id439" class="calibre1"/>a message box when someone tries to delete a contact. The message includes the contact's name (to provide context) and a title. The order of the two buttons, <strong class="calibre9">No</strong> then <strong class="calibre9">Yes</strong>, ensures that if the user hits enter immediately, <strong class="calibre9">No</strong> will be selected. I think it's good to default to the safer case. Whatever the user selects will be given to the promise returned from <code class="literal">showMessage</code>, which we can access in the <code class="literal">then</code> handler.</p><p class="calibre8">Depending on how you count those lines, we just double-checked a user action with a modal dialog in 2-3 lines of very-readable code. You can see an example of this in the <code class="literal">cp5-message</code> branch.</p><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec35" class="calibre1"/>Message box settings</h3></div></div></div><p class="calibre8">The last parameter to <code class="literal">showMessage</code> is an <a id="id440" class="calibre1"/>object that controls display options. It takes the following parameters:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">buttonClass</code>: This <a id="id441" class="calibre1"/>specifies a class for all buttons. The default is <code class="literal">btn</code>.</li><li class="listitem"><code class="literal">primaryButtonClass</code>: This <a id="id442" class="calibre1"/>specifies an additional class for the first button. The default is <code class="literal">btn-primary</code>.</li><li class="listitem"><code class="literal">secondaryButtonClass</code>: It <a id="id443" class="calibre1"/>specifies an additional class for buttons other than the first. The default is no class.</li><li class="listitem"><code class="literal">class</code>: This specifies<a id="id444" class="calibre1"/> the class of the outermost <code class="literal">div</code> element of the message box. The default is <code class="literal">"messageBox"</code>. Note that you must specify this property with quotes or it will crash in IE8; for example, <code class="literal">"class"</code> and <code class="literal">"myClass"</code>.</li><li class="listitem"><code class="literal">style</code>: This specifies<a id="id445" class="calibre1"/> additional styles for the outermost <code class="literal">div</code> element of the message box. The default is nothing.</li></ul></div><p class="calibre8">You can also control the default settings by passing the same settings object to <code class="literal">dialog.MessageBox.setDefaults</code>. This function will merge the settings passed to it with the defaults; if you leave settings out, they will be left alone, not removed.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec90" class="calibre1"/>Custom dialogs</h2></div></div></div><p class="calibre8">Message boxes are <a id="id446" class="calibre1"/>great<a id="id447" class="calibre1"/> for single input such as <code class="literal">yes</code>, <code class="literal">no</code>, or choosing an option from a list. However, when things need to get more complex than a single answer, Durandal allows us to create custom dialogs. To show a custom dialog, you can require the dialog object with <code class="literal">plugins/dialog</code> and call <code class="literal">dialog.show</code>, or use the alias <code class="literal">app.showDialog</code>. Dialogs use composition, so any viewmodel passed to <code class="literal">show</code> will look up and bind against its view using the standard methods.</p><p class="calibre8">To close itself and pass a result back to the caller, the dialog-hosted viewmodel will need to require <code class="literal">plugins/dialog</code> and call <code class="literal">dialog.close(self, result)</code>.</p><p class="calibre8">To see how this works, open the <code class="literal">cp5-dialog</code> branch. The <strong class="calibre9">Add Contact</strong> button on the main list page will open the edit viewmodel in a dialog, which will either close with <code class="literal">null</code> for a canceled entry or a new contact for the saved entry. Just to show how flexible it is, the <code class="literal">Add Contact</code> link in the nav bar will still navigate to a new page to create a new contact. Both, the dialog and the page are run by the same viewmodel!</p><div><pre class="programlisting">define(['durandal/system', 'knockout', 'plugins/router', 'services/mock', 'contacts/contact', 'plugins/dialog'], 
function(system, ko, router, dataService, Contact, dialog) {
  return function EditContactVm(init) {
    var self = this;

    self.contact = ko.observable(new Contact());

    self.activate = function(id) {
      //Id is only present when editing
      if (id)
        dataService.getContact(id, self.contact);
    };

    self.saveEntry = function() {
      var action = self.contact().id() === 0 
        ? dataService.createContact 
        : dataService.updateContact;

      action(self.contact(), function() {
        self.close(self.contact());
      });
    };

    self.cancel = function() {
      self.close(null);
    };

    self.close = function(result) {
      if (dialog.getDialog(self))
        dialog.close(self, result);
      else
        router.navigate('');
    };
  };
});</pre></div><p class="calibre8">As you can see, almost nothing has changed. Instead of always using the router to navigate home when finished, the new close method checks <code class="literal">dialog.getDialog(self))</code> to see whether it is a dialog, and closes itself with the result (null or the newly created contact). The <code class="literal">dialog.getDialog(self))</code> method returns the dialog context, or is <a id="id448" class="calibre1"/>undefined if none is found.</p><p class="calibre8">The list viewmodel has <a id="id449" class="calibre1"/>to only make the following change to open the dialog and keep the result:</p><div><pre class="programlisting">self.newEntry = function() {
  app.showDialog(new ContactVM())
  .then(function(newContact) {
    if (newContact) {
      self.contacts.push(newContact);
    }
  });
};</pre></div><p class="calibre8">The <code class="literal">ContactVM</code> object is the edit viewmodel, which is being required in with <code class="literal">contact/edit</code>. A new one is constructed and passed to <code class="literal">app.showDialog</code>. Composition renders the viewmodel and returns the promise for the dialog's result. This promise will be completed by the <code class="literal">dialog.close</code> call in the edit viewmodel. The <code class="literal">then</code> handler just checks to make sure it exists and adds it to its list of contacts.</p><p class="calibre8">There are some HTML/CSS considerations with custom dialogs. Unlike message boxes, which are styled with Bootstrap's modal classes by Durandal, custom dialogs are rendered into an empty <code class="literal">div</code> element that is centered with absolute positioning and a transparent background. Without some styling, the output looks pretty terrible:</p><div><img src="img/00012.jpeg" alt="Custom dialogs" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Thankfully, it doesn't take<a id="id450" class="calibre1"/> much to <a id="id451" class="calibre1"/>clean this up. This is the CSS I used:</p><div><pre class="programlisting">.edit-container {
  padding: 20px;
  min-width: 600px;
  background-color: #222222;
}</pre></div><p class="calibre8">The preceding CSS produces this much nicer looking result:</p><div><img src="img/00013.jpeg" alt="Custom dialogs" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">While the need for this<a id="id452" class="calibre1"/> might be surprising, I think it's better than the alternative<a id="id453" class="calibre1"/> where Durandal does apply some default styling to all modals, which has to forcefully be overridden when it doesn't match what you want. In the next chapter, we will cover adding custom dialog hosts, which provides a much nicer way to control default modal appearance for both message boxes and custom dialogs.</p><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec36" class="calibre1"/>An alternative method</h3></div></div></div><p class="calibre8">To keep the calling viewmodel a little <a id="id454" class="calibre1"/>cleaner and less aware of how the dialog viewmodel works, I prefer to encapsulate the actual dialog code. This is easy to do by adding a <code class="literal">show</code> method to the edit viewmodel:</p><div><pre class="programlisting">self.show = function() {
  return dialog.show(self);
};</pre></div><p class="calibre8">And calling it instead of <code class="literal">app.showDialog</code>, as seen here:</p><div><pre class="programlisting">self.newEntry = function() {
  new ContactVM().show()
  .then(function(newContact) {
    if (newContact) {
      self.contacts.push(newContact);
    }
  });
};</pre></div><p class="calibre8">This hides the specific method <a id="id455" class="calibre1"/>from the caller, allowing the edit viewmodel to control how it shows itself. The <code class="literal">show</code> method could even take the parameters that allowed configuration before showing the dialog. This is especially useful when multiple dialog hosts are available, which we will cover in the next chapter. You can see this example in the <code class="literal">cp5-dailog2</code> branch.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec39" class="calibre1"/>The application's life cycle</h1></div></div></div><p class="calibre8">Durandal's composition and <a id="id456" class="calibre1"/>activator services allow optional callbacks to control or hook into their life cycles. They can be useful when performing setup and teardown, or implementing logic to block or redirect page changes.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec91" class="calibre1"/>The activation life cycle</h2></div></div></div><p class="calibre8">An activator<a id="id457" class="calibre1"/> is a special <a id="id458" class="calibre1"/>computed observable, whose <code class="literal">write</code> function enforces the activation life cycle. Unless you are managing composition or routing yourself, the only activators you will work with are the ones used by the router and the dialog system. Though, if you are interested, you can create your own activator by requiring in the <code class="literal">durandal/activator</code> module and using the <code class="literal">create</code> function.</p><p class="calibre8">The following optional properties are called by the activator when the active value tries to change:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">canActivate</code>: This is <a id="id459" class="calibre1"/>called on the new value; it should return either a Boolean or a promise that resolves to a Boolean. If the result is <code class="literal">false</code>, activation is cancelled.</li><li class="listitem"><code class="literal">activate</code>: This is <a id="id460" class="calibre1"/>called on the new value after <code class="literal">canActivate</code>; it is used to perform any desired setup logic. If activate returns a promise, the new value will not become the active value until the promise resolves.</li><li class="listitem"><code class="literal">canDeactivate</code>: This is <a id="id461" class="calibre1"/>called on the old value; just like activate, it should return either a Boolean or a promise that resolves to a Boolean. If the result is false, activation is cancelled.</li><li class="listitem"><code class="literal">Deactivate</code>: This is called <a id="id462" class="calibre1"/>on the old value after activation succeeds, but before the switch is made. It is used to perform any teardown logic.</li></ul></div><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec37" class="calibre1"/>Preparing viewmodels with activate</h3></div></div></div><p class="calibre8">You have already seen the<a id="id463" class="calibre1"/> use of <code class="literal">activate</code> in the list and edit <a id="id464" class="calibre1"/>viewmodels, where it is used to load data:</p><div><pre class="programlisting">self.activate = function() {
  dataService.getContacts(function(contacts) {
    self.contacts(contacts);
  });
};</pre></div><p class="calibre8">What probably hasn't been obvious, because the mock data service is using local storage, is that if this service call actually took time, the page would render before the data got back. This could result in a jarring change when all of the contacts suddenly load. The <code class="literal">activate</code> call isn't waiting for this callback to finish, so Durandal is activating the viewmodel before it's really ready.</p><p class="calibre8">To see what this looks like, open the <code class="literal">cp5-timeout</code> branch. All the mock service calls have had a 1 second timeout added before their callbacks are used, which will result in a more real-world response time scenario. Loading the home page, you can see the list load after the rest of the page. This is especially problematic when trying to edit a contact, as the form will show the default values until the contact is loaded.</p><p class="calibre8">To stop the page loading until the list is retrieved, we can return a promise from activate. The <code class="literal">durandal/system</code> module provides a way to create promises if you aren't using your own library (such as Q) to do so:</p><div><pre class="programlisting">self.activate = function() {
  return system.defer(function(defer) {
    dataService.getContacts(function(contacts) {
      self.contacts(contacts);
      defer.resolve();
    });
  }).promise();
};</pre></div><p class="calibre8">Here, we are returning a promise that will be resolved by the callback to our mock data service. The <code class="literal">system.defer</code> function takes a handler that performs asynchronous working, calling it with a deferred object. The deferred object has the resolve and reject functions, which can take values for success or failure. You can see this in the <code class="literal">cp5-activate</code> branch, where the same change was made for the edit page. As activate is waiting on this promise, activation will not continue until it resolves. These pages will not activate until their data is loaded, so the user never sees the page before it is ready.</p><p class="calibre8">While this method works, there is a cleaner way to do it. Instead of using callbacks in our data service and promises in our viewmodels, which really mixes strategies, we can use promises in our data service. If <a id="id465" class="calibre1"/>our data service returns a promise, the activate method looks much nicer:</p><div><pre class="programlisting">self.activate = function() {
  return dataService.getContacts()
  .then(function(contacts) {
    self.contacts(contacts); 
  });
};</pre></div><p class="calibre8">What an improvement! In <a id="id466" class="calibre1"/>fact, we can take it even further. As <code class="literal">self.contacts</code> is an observable array, which is just a function, we can cut out the anonymous function in the <code class="literal">then</code> handler with this shorthand:</p><div><pre class="programlisting">self.activate = function() {
  return dataService.getContacts()
  .then(self.contacts);
};</pre></div><p class="calibre8">This works because <code class="literal">self.contacts</code> becomes the <code class="literal">then</code> handler, so when the service returns the list of contacts, the promise resolves directly into it. This doesn't appeal to everyone, and it might even look confusing. However, if it doesn't impair readability for you, the shorter code might be nice.</p><p class="calibre8">This method can be seen in the <code class="literal">cp5-activate2</code> branch, which fully converts all the data access code into promises, such as this one:</p><div><pre class="programlisting">getContacts: function() {
  return system.defer(function(defer) {
    //Return our POJO contacts as real contact objects
    var typedContacts = [];
    for (var c in contacts) {
      if (contacts.hasOwnProperty(c)) {
        typedContacts.push(new Contact(contacts[c]))
      }
    }
    setTimeout(function() {
      defer.resolve(typedContacts);
    }, 1000);
  }).promise();
}</pre></div><p class="calibre8">Because Durandal <a id="id467" class="calibre1"/>has this understanding of promises integrated <a id="id468" class="calibre1"/>into its life cycle hooks, it makes using promises for all asynchronous code that much more appealing. If you aren't doing this already, I strongly encourage you to consider it. All code samples from here on will be using promises.</p><p class="calibre8">This asynchronous activation is another advantage of the composition of components. Components can only construct and bind synchronously, which can make some components very tricky to initialize. Composition allows asynchronous work to be done, making it that much more flexible.</p></div><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec38" class="calibre1"/>A note on the router's isNavigating property</h3></div></div></div><p class="calibre8">In the previous section, <em class="calibre12">Binding the router</em>, we looked at the <code class="literal">isNavigating</code> property of the router, which is <code class="literal">true</code> during<a id="id469" class="calibre1"/> navigation. The activation life cycle is part of <a id="id470" class="calibre1"/>navigation, so <code class="literal">isNavigating</code> will be <code class="literal">true</code> during any asynchronous activity in the activation life cycle. This allows you to bind visual indicators on the page while your pages are loading, making your application feel more responsive.</p></div><div><div><div><div><h3 class="title2"><a id="ch05lvl3sec39" class="calibre1"/>Checking navigation with canDeactivate</h3></div></div></div><p class="calibre8">The <code class="literal">canActivate</code> and <code class="literal">canDeactivat</code>e methods also support promises. Going off to the server with an Ajax <a id="id471" class="calibre1"/>request to see whether a view can be deactivated might <a id="id472" class="calibre1"/>seem weird, but Ajax isn't the only source of promises. Perhaps the best possible use case for <code class="literal">canDeactivate</code> is with the promise from a simple message box—<strong class="calibre9">You have unsaved changes, are you sure you want to leave?</strong>
</p><p class="calibre8">Open the <code class="literal">cp5-deactivate</code> branch and open up a contact to edit. If you hit <strong class="calibre9">Cancel</strong>, you will still be taken back to the list, but if you make changes and hit <strong class="calibre9">Cancel</strong>, you will be prompted. If you hit <strong class="calibre9">No</strong>, navigation will be cancelled.</p><p class="calibre8">You might think that this is being done from the <strong class="calibre9">Cancel</strong> button, but it will also happen if the user clicks on the browser's back button or the navigation link (basically, anything but a hard browser navigation). This is because <code class="literal">canDeactivate</code> is run no matter what source the attempted deactivation comes from:</p><div><pre class="programlisting">self.canDeactivate = function() {
  if (!self.contact().state.isDirty())
  return true;
  return app.showMessage('You have unsaved changes. Are you sure you want to leave?', 'Cancel Edit?', ['No', 'Yes'])
  .then(function(response) {
    return response === 'Yes';
  });
};</pre></div><div><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre8">The dirty flag<a id="id473" class="calibre1"/> in this sample is taken from Ryan Niemeyer's blog <em class="calibre12">Knock Me Out</em> at <a class="calibre1" href="http://www.knockmeout.net/2011/05/creating-smart-dirty-flag-in-knockoutjs.html">http://www.knockmeout.net/2011/05/creating-smart-dirty-flag-in-knockoutjs.html</a>. It can be seen in the <code class="literal">common/extensions.js</code> file in the branch source code.</p></div><p class="calibre8">Here, we are just <a id="id474" class="calibre1"/>showing a standard message box and<a id="id475" class="calibre1"/> transforming the result into a Boolean for <code class="literal">canDeactivate</code>. The promise for this result is returned, and <code class="literal">canDeactivate</code> will wait until it resolves, to determine whether or not activation can continue.</p><p class="calibre8">We can actually shorten this, because the activator module will interpret the strings' responses by checking them against a list of affirmations and responses that it considers to be true. This is the code Durandal uses to check activation results, taken from the activator module:</p><div><pre class="programlisting">affirmations: ['yes', 'ok', 'true'],
interpretResponse: function(value) {
  if(system.isObject(value)) {
    value = value.can || false;
  }

  if(system.isString(value)) {
    return ko.utils.arrayIndexOf(this.affirmations, value.toLowerCase()) !== -1;
  }

  return value;
}</pre></div><p class="calibre8">This array of <code class="literal">truthy</code> strings can be changed by accessing <code class="literal">activator.defaults.affirmations</code>.</p><p class="calibre8">With this knowledge, we can just return the promise from the message box directly. The activator module will consider <code class="literal">Yes</code> to be a truthy result, and any other string to be <code class="literal">false</code>:</p><div><pre class="programlisting">self.canDeactivate = function() {
  if (!self.contact().state.isDirty())
    return true;
  return app.showMessage('You have unsaved changes. Are you sure you want to leave?', 'Cancel Edit?', ['No', 'Yes']);
};</pre></div><p class="calibre8">Doesn't that look nice? You can see this in the <code class="literal">cp5-deactivate2</code> branch.</p><p class="calibre8">While these <a id="id476" class="calibre1"/>examples are short, hopefully, they give <a id="id477" class="calibre1"/>you an idea of what the activation life cycle is capable of, especially when combined with promises. Because promises can be chained, you could block deactivation when you go to the server to get some information, then display it to the user in a message box, and pass the result to the activator module.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec92" class="calibre1"/>Composition</h2></div></div></div><p class="calibre8">The composition life cycle<a id="id478" class="calibre1"/> has another set of events that can be hooked into, which allow you to control how the DOM is rendered, or respond to various stages of composition. Again, all of these are optional:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">getView()</code>: This is a <a id="id479" class="calibre1"/>function that can return a view ID (path to a view file), or a DOM element. This overrides any other view location done by composition.</li><li class="listitem"><code class="literal">viewUrl</code>: This is a<a id="id480" class="calibre1"/> string property of a view ID, to override view location. It will only be used if <code class="literal">getView</code> is not present.</li><li class="listitem"><code class="literal">activate()</code>: Just like <a id="id481" class="calibre1"/>activation's <code class="literal">activate</code> method, this function will be called when composition begins. If the compose binding has an <code class="literal">activationData</code> method specified, it will be given to activate as a parameter. If a promise is returned, the composition will not continue until it resolves.</li><li class="listitem"><code class="literal">binding(view)</code>: This is<a id="id482" class="calibre1"/> called before binding occurs. The view is passed to this function as a parameter. If binding returns <code class="literal">false</code> or <code class="literal">{ applyBindings:false }</code>, binding will not be done on the view.</li><li class="listitem"><code class="literal">bindingComplete(view)</code>: This is<a id="id483" class="calibre1"/> called when binding finishes. The view is passed as a parameter.</li><li class="listitem"><code class="literal">attached(view, parent)</code>: This is<a id="id484" class="calibre1"/> called with the view and its parent DOM element after it is added to the DOM.</li><li class="listitem"><code class="literal">compositionComplete(view, parent)</code>: This is <a id="id485" class="calibre1"/>called with the view and its parent DOM element after all composition, including the composition of child elements, has been completed.</li><li class="listitem"><code class="literal">detached(view, parent)</code>: This is called <a id="id486" class="calibre1"/>after the view has been removed from the DOM.</li></ul></div><p class="calibre8">In the case of the combined activation and composition life cycles, such as the router's navigation, the activation module's <code class="literal">activate</code> method is the only one called.</p><p class="calibre8">With the exception of binding, which can stop binding from occurring, the composition life cycle hooks do not offer the opportunity to control or cancel the process like the activation hooks do. Though it is generally discouraged in MVVM for the viewmodel to interact directly with the view, the composition life cycle is designed to make it easy to do so. Patterns should only be followed as long as they are helpful or possible, and if binding just can't get your work done, you may need to work with the DOM in your viewmodel.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec40" class="calibre1"/>Widgets</h1></div></div></div><p class="calibre8">Widgets in Durandal<a id="id487" class="calibre1"/> are similar to Knockout components, in that they are viewmodel/view pairs that are instantiated from the DOM. Components use a custom element while widgets use a custom binding. There is definitely some overlap between them, but Durandal's widget system came before Knockout's component system. Widgets also have a killer feature over components; their views can have replaceable sections that can be overridden. This feature is commonly known as <a id="id488" class="calibre1"/>
<strong class="calibre9">transclusion</strong>—the inclusion of one document inside another.</p><p class="calibre8">It's difficult to talk about the widget API without using an example. When we looked at components, we made a contact list component; so let's see what it would look like doing the same thing with a widget. It may not be very reusable, making it an odd choice for a widget; but it will cover the whole process.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec93" class="calibre1"/>Creating a new widget</h2></div></div></div><p class="calibre8">Durandal expects <a id="id489" class="calibre1"/>widgets to be located in a directory named <code class="literal">widgets</code>, at the root of your app, which, in our case, would be under <code class="literal">client/app/widgets</code>. Each widget will store its code in a folder, which will be used as the name of the widget. The code for a widget must be a JavaScript file named <code class="literal">viewmodel.js</code> and an HTML file named <code class="literal">view.html</code>. So to make our contacts list item widget, we will use the following structure:</p><div><img src="img/00014.jpeg" alt="Creating a new widget" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">For the view, we are just going to pull the whole list section out of the <code class="literal">list.html</code> view:</p><div><pre class="programlisting">&lt;ul class="list-unstyled" data-bind="foreach: contacts"&gt;
  &lt;li&gt;
    &lt;h3&gt;
    &lt;span data-bind="text: displayName"&gt;&lt;/span&gt; &lt;small data-bind="text: phoneNumber"&gt;&lt;/small&gt;
    &lt;button class="btn btn-sm btn-default" data-bind="click: $parent.edit"&gt;Edit&lt;/button&gt;
    &lt;button class="btn btn-sm btn-danger" data-bind="click: $parent.delete"&gt;Delete&lt;/button&gt;
  &lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">As we are going to be<a id="id490" class="calibre1"/> binding against a new viewmodel, I've changed the <code class="literal">foreach</code> binding from <code class="literal">displayContacts</code> to <code class="literal">contacts</code>. Our viewmodel is going to look very similar to our normal page viewmodels. Like pages instantiated by the router, our widget's viewmodel won't be able to receive construction parameters; data passed to the widget through the binding will be given to the <code class="literal">activate</code> function:</p><div><pre class="programlisting">define(['durandal/app', 'knockout'], function(app, ko) {
  return function ContactListWidget() {
    var self = this;

    self.activate = function(options) {
      self.contacts = options.data;
      self.edit = options.edit;
      self.delete = options.delete;
    };
  };
});</pre></div><p class="calibre8">We are passing in the data the view needs here, that is, the <code class="literal">contacts</code> array, and a callback for <code class="literal">edit</code> and <code class="literal">delete</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec94" class="calibre1"/>Using a widget</h2></div></div></div><p class="calibre8">Durandal provides <a id="id491" class="calibre1"/>several ways to use the widget. First, we have to activate the widget plugin in our <code class="literal">main.js</code> file:</p><div><pre class="programlisting">app.configurePlugins({
  //Durandal plugins
  router:true,
  dialog: true,
  widget: true
});</pre></div><p class="calibre8">Now we can use the widget binding to create the widget:</p><div><pre class="programlisting">&lt;div data-bind="widget: { kind: 'contactList', 
   data: displayContacts, 
  edit: editContact, 
  delete: deleteContact }"&gt;
&lt;/div&gt;</pre></div><p class="calibre8">I don't really like this though; it's a little verbose. There are two ways to register the widget, which allow it to be used as if it was a binding itself:</p><div><pre class="programlisting">&lt;div data-bind="contactList: { data: displayContacts, 
  edit: editContact, 
  delete: deleteContact }"&gt;
&lt;/div&gt;</pre></div><p class="calibre8">I think this looks much nicer. To register a widget, you can either call <code class="literal">widget.registerKind('contactList')</code>, or modify the plugin configuration:</p><div><pre class="programlisting">app.configurePlugins({
  //Durandal plugins
  router:true,
  dialog: true,
  widget: {
    kinds: ['contactList']
  }
});</pre></div><p class="calibre8">I personally prefer this <a id="id492" class="calibre1"/>last method; though if you have a lot of widgets, you might prefer one of the other methods. You can see this widget being used in the <code class="literal">cp5-widget</code> branch. The result looks identical to the previous version, but the list is now in a separate view.</p></div><div><div><div><div><div></div></div></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec95" class="calibre1"/>Modifying widgets with data-part attributes</h2></div></div></div><p class="calibre8">So far, there isn't much to<a id="id493" class="calibre1"/> our widget. It doesn't add <a id="id494" class="calibre1"/>anything that a Knockout component couldn't have given us, and the components have the nicer looking custom element syntax going for them.</p><p class="calibre8">If you have an element in your widget's view with a <code class="literal">data-part</code> attribute, then that element can be overridden by the caller. Let's say, for example, that we wanted to be able to change the way the phone number was displayed. The first step is to add a <code class="literal">data-part</code> attribute to the widget:</p><div><pre class="programlisting">&lt;small data-bind="text: phoneNumber" data-part="phone"&gt;&lt;/small&gt;</pre></div><p class="calibre8">The next step is to use the same <code class="literal">data-part</code> attribute in the caller:</p><div><pre class="programlisting">  &lt;div data-bind="contactList: { data: displayContacts, 
    edit: editContact, 
    delete: deleteContact }"&gt;
    &lt;span data-part="phone" data-bind="text: phoneNumber"&gt;&lt;/span&gt;
  &lt;/div&gt;</pre></div><p class="calibre8">The result is the new <code class="literal">span</code> element that replaces the original small element inside the widget. You can see this in the <code class="literal">cp5-datapart</code> branch.</p><p class="calibre8">An important thing to notice here is that the new <code class="literal">span</code> element has a data binding that refers to a contact's <code class="literal">phoneNumber</code> property. The <code class="literal">data-part</code> attribute is overriding an element whose binding context is in the scope of the <code class="literal">foreach</code> loop of the widget, and this scope is maintained by the new element. The binding context of a <code class="literal">data-part</code> attribute, declared inside of a widget-bound element, is the binding context of the element it replaces.</p><p class="calibre8">The special <code class="literal">$root</code> property of a widget's binding context is set to the declaring scope, which is especially handy for overriding <code class="literal">data-part</code> attributes. If we want to refer to properties on the list viewmodel, we can do so:</p><div><pre class="programlisting">&lt;div data-bind="contactList: { data: displayContacts, delete: deleteContact }"&gt;

  &lt;small data-part="phone"&gt;&lt;em data-bind="text: phoneNumber"&gt;&lt;/em&gt;&lt;/small&gt;
  &lt;button data-part="edit-btn" data-bind="click: $root.editContact" class="btn btn-sm btn-default"&gt;Edit&lt;/button&gt;
&lt;/div&gt;</pre></div><p class="calibre8">This assumes that the matching button in the widget view has the <code class="literal">data-part="edit-btn"</code> attribute added to it. This button now directly references the <code class="literal">editContact</code> function on the list viewmodel, instead <a id="id495" class="calibre1"/>of the one on the widget. You can see this in action in the <code class="literal">cp5-datapart2</code> branch.</p><p class="calibre8">A widget can have any<a id="id496" class="calibre1"/> number of <code class="literal">data-part</code> attributes, and each <code class="literal">data-part</code> attribute can contain other <code class="literal">data-part</code> attributes. This allows maximum flexibility in controlling the appearance and functionality of templated widgets.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec41" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">These are just the basics of using Durandal, but hopefully you can already appreciate the power and simplicity the framework provides. It frequently happens online that Knockout is compared to more complete frameworks such as Angular, and where it lacks components, such as a router, they are taken as points against it. Durandal stacks up much more evenly with these frameworks while it still takes advantage of all of the things that make Knockout great.</p><p class="calibre8">In this chapter, you should have learned the composition system, as well as how the router brings organization and modularity to your application. We saw how promises combine with modal dialogs and the application life cycle to allow us to respond to asynchronous events easily and naturally. Finally, we saw how widgets can take the concepts behind Knockout components (reusable behavior-driven controls that are instantiated from the view markup) and add templated <code class="literal">data-part</code> attributes to achieve transclusion.</p><p class="calibre8">The next chapter will continue to explore how the Durandal framework simplifies Knockout application development.</p></div></body></html>