- en: Chapter 6. Using Proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Proxies are used to define the custom behavior for the fundamental operations
    on objects. Proxies are already available in the programming languages such as
    C#, C++, and Java, but JavaScript has never had proxies. ES6 introduced the Proxy
    API, which lets us create proxies. In this chapter, we will look at proxies, their
    usage, and the proxy traps. Due to the benefits of proxies, the developers are
    using proxies increasingly and therefore, it's important to learn about proxies
    in-depth with examples, which we will do in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating proxies using the Proxy API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding what proxies are and how to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intercepting various operations on the objects using traps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different kinds of available traps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some use cases of proxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxies in a nutshell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A proxy acts like a wrapper for an object, and defines the custom behavior for
    the fundamental operations on the object. Some fundamental operations on the objects
    are property lookup, property assignment, constructor invocation, enumeration,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Once an object is wrapped using a proxy, all the operations that are supposed
    to be done on the object should now be done on the proxy object, so that the custom
    behavior can take place.
  prefs: []
  type: TYPE_NORMAL
- en: Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some important terms that are used while studying proxies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Target: This is the object that is wrapped by proxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Traps: These are functions that intercept various operations on the target
    object, and define the custom behavior for those operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Handler: This is an object that holds the traps. A handler is attached to a
    proxy object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Proxy API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ES6 Proxy API provides the `Proxy` constructor to create proxies. The `Proxy`
    constructor takes two arguments, which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Target**: This is the object that will be wrapped by the proxy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handler**: This is an object that contains the traps for the target object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A trap can be defined for every possible operation on the target object. If
    a trap is not defined, then the default action takes place on the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example that shows how to create a proxy, and do various operations
    on the target object. In this example, we have not defined any traps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `age` property of the `target` object can be accessed
    via the `proxy` object. And when we added the `name` property to the `proxy` object,
    it was actually added to the `target` object.
  prefs: []
  type: TYPE_NORMAL
- en: As there was no trap attached for the property assignment, the `proxy.name`
    assignment resulted to the default behavior that is simply assigning the value
    to the property.
  prefs: []
  type: TYPE_NORMAL
- en: So, we can say a `proxy` is just a wrapper for a `target` object and traps can
    be defined to change the default behavior of operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many developers don''t keep a reference variable for the target object to make
    use of the proxy mandatory for accessing the object. Keep a reference for the
    handler only when you need to reuse it for multiple proxies. Here is how they
    rewrite the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Traps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are different traps for different operations that can be performed on
    an object. Some of the traps need to return values. There are some rules they
    need to follow while returning values. The returned values are intercepted by
    the proxy to filter, and/or to check if the returned values obey the rules. If
    a trap doesn't obey rules while returning value, then the proxy throws the `TypeError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `this` inside a trap is always a reference to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Lets take a look at the various kinds of traps.
  prefs: []
  type: TYPE_NORMAL
- en: The get(target, property, receiver) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `get` trap is executed when we retrieve a property value using the dot or
    bracket notation, or the `Reflect.get()` method. It takes three parameters, that
    is, the target object, the property name, and the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: It must return a value that represents the property value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which shows how to use the `get` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the `get` trap looks for the property in the `target`
    object, and if it finds it, then returns the property value. Otherwise, it returns
    a string indicating that it was not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `receiver` parameter is the reference of the object whose property we intended
    to access. Consider this example to better understand the value of the `receiver`
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here `obj` inherits the `proxy` object. Therefore, when the `name` property
    was not found in the `obj` object, it was looked in the `proxy` object. As the
    `proxy` object had a `get` trap, it provided a value.
  prefs: []
  type: TYPE_NORMAL
- en: So, the value of the `receiver` parameter when we accessed the `name` property
    via the `obj.name` expression, is `obj`, and when we accessed the `name` property
    via `proxy.name` expression is `proxy`.
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `receiver` parameter is decided in the same way for all other
    traps also.
  prefs: []
  type: TYPE_NORMAL
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `get` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: The value returned for a property must be the same as the value of the target
    object property if the target object property is a non-writable, non-configurable
    data property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value returned for a property must be `undefined` if the target object property
    is non-configurable accessor property that has `undefined` as its `[[Get]]` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The set(target, property, value, receiver) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `set` trap is invoked when we set the value of a property using the assignment
    operator, or the `Reflect.set()` method. It takes four parameters, that is, the
    target object, the property name, the new property value, and the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: The `set` trap must return `true` if the assignment was successful. Otherwise,
    it will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `set` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `set` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: If the target object property is a non-writable, non-configurable data property,
    then it will return as `false`, that is, you cannot change the property value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target object property is a non-configurable accessor property that has
    `undefined` as its `[[Set]]` attribute, then it will return as false, that is,
    you cannot change the property value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The has(target, property) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `has` trap is executed when we check if a property exists or not, using
    the `in` operator. It takes two parameters, that is, the target object and the
    property name. It must return a Boolean value that indicates whether the property
    exists or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `has` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `has` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot return `false` if the property exists as a non-configurable own property
    of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot return `false` if the property exists as an own property of the `target`
    object, and the `target` object is not extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The isExtensible(target) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `isExtensible` trap is executed when we check if the object is extensible
    or not, using the `Object.isExtensible()` method. It takes only one parameter,
    that is, the `target` object. It must return a Boolean value indicating whether
    the object is extensible or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `isExtensible` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `isExtensible` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot return `false` if the target is extensible. Similarly, you cannot
    return `true` if the target is non-extensible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getPrototypeOf(target) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getPrototypeOf` trap is executed when we retrieve the value of the internal
    `[[prototype]]` property, using either the `Object.getPrototypeOf()` method or
    the `__proto__` property. It takes only one parameter, that is, the `target` object.
  prefs: []
  type: TYPE_NORMAL
- en: It must return an object or `null` value. The `null` value indicates that the
    object doesn't inherit anything else and is the end of the inheritance chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `getPrototypeOf`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `getPrototypeOf` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: It must either return an object or return `null` value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the target is not extensible, then this trap must return the actual prototype
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The setPrototypeOf(target, prototype) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `setPrototypeOf` trap is executed when we set the value of the internal
    `[[prototype]]` property, using either the `Object.setPrototypeOf()` method or
    the `__proto__` property. It takes two parameters, that is, the target object
    and value of the property to be assigned.
  prefs: []
  type: TYPE_NORMAL
- en: This trap will return a Boolean, indicating whether it has successfully set
    the prototype or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `setPrototypeOf`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `setPrototypeOf` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: You must return `false` if the target is not extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preventExtensions(target) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `preventExtensions` trap is executed when we prevent the addition of new
    properties using the `Object.preventExtensions()` method. It takes only one parameter,
    that is, the `target` object.
  prefs: []
  type: TYPE_NORMAL
- en: It must return a Boolean, indicating weather it has successfully prevented the
    extension of the object or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `preventExtensions`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `preventExtensions` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: This trap can return `true` only if the target is non-extensible, or it has
    made the target non-extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The getOwnPropertyDescriptor(target, property) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getOwnPropertyDescriptor` trap is executed when we retrieve the descriptor
    of a property by using the `Object.getOwnPropertyDescriptor()` method. It takes
    two parameters, that is, the target object and the name of the property.
  prefs: []
  type: TYPE_NORMAL
- en: This trap must return a descriptor object or `undefined`. The `undefined` value
    is returned if the property doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `getOwnPropertyDescriptor`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `getOwnPropertyDescriptor`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: This trap must either return an object or return an `undefined` property
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot return the `undefined` value if the property exists as a non-configurable
    own property of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot return the `undefined` value if the property exists as an own property
    of the `target` object, and the `target` object is not extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will have to return `undefined`, if the property does not exist as an own
    property of the `target` object, and the `target` object is not extensible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot make the `configurable` property of the returned descriptor object
    false, if the property exists as an own property of the `target` object, or if
    it exists as a configurable own property of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The defineProperty(target, property, descriptor) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `defineProperty` trap is executed when we define a property using the `Object.defineProperty()`
    method. It takes three parameters, that is, the `target` object, the `property`
    name, and the `descriptor` object.
  prefs: []
  type: TYPE_NORMAL
- en: This trap should return a Boolean indicating whether it has successfully defined
    the property or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `defineProperty`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `defineProperty` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: It must return `false` if the `target` object is not extensible, and the property
    doesn't yet exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deleteProperty(target, property) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `deleteProperty` trap is executed when we delete a property using either
    the `delete` operator or the `Reflect.deleteProperty()` method. It takes two parameters,
    that is, the `target` object and the `property` name.
  prefs: []
  type: TYPE_NORMAL
- en: This trap must return a Boolean, indicating whether the property was deleted
    successfully or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `deleteProperty`
    trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This rule shouldn''t be violated while using the `deleteProperty` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: This trap must return `false` if the property exists as a non-configurable own
    property of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enumerate(target) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `enumerate` trap is executed when we loop over the property keys using either
    the `for…in` loop or the `Reflect.enumerate()` method. It takes one parameter,
    that is, the `target` object.
  prefs: []
  type: TYPE_NORMAL
- en: This trap must return an iterator object, representing the enumerable keys of
    the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `enumerate` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This rule shouldn''t be violated while using the `enumerate` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: This trap must return an object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ownKeys(target) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ownKeys` trap is executed when we retrieve the own property keys using
    the `Reflect.ownKeys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()`,
    and the `Object.keys()` methods. It takes only one parameter, that is, the `target`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The `Reflect.ownKeys()` method is similar to the `Object.getOwnPropertyNames()`
    method, that is, they return the enumerable and non-enumerable property keys of
    a object. They ignore the inherited properties. The only difference is that the
    `Reflect.ownKeys()` method returns both, the symbol and string keys, whereas the
    `Object.getOwnPropertyNames()` method returns only the string keys.
  prefs: []
  type: TYPE_NORMAL
- en: The `Object.getOwnPropertySymbols()` method returns the enumerable and non-enumerable
    properties whose keys are symbols. It ignores the inherited properties.
  prefs: []
  type: TYPE_NORMAL
- en: The `Object.keys()` method is similar to the `Object.getOwnPropertyNames()`
    method, but the only difference is that the `Objecy.keys()` method returns the
    enumerable properties only.
  prefs: []
  type: TYPE_NORMAL
- en: The `ownKeys` trap must return an array, representing the own property keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `ownKeys` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the values of the array returned by the `ownKeys` trap
    are filtered by the proxy, based on what the caller expected. For example, the
    `Object.getOwnPropertySymbols()` caller expected an array of symbols. Therefore,
    the proxy removed the strings from the returned array.
  prefs: []
  type: TYPE_NORMAL
- en: Rules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These rules shouldn''t be violated while using the `ownKeys` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: The elements of the returned array must either be a string or symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The returned array must contain the keys of all the non-configurable own properties
    of the `target` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `target` object is not extensible, then the returned array must contain
    all the keys, of the own properties, of the `target` object, and no other values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The apply(target, thisValue, arguments) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the target is a function, then calling the proxy will execute the `apply`
    trap. The `apply` trap is also executed for function's `apply()` and `call()`
    methods, and the `Reflect.apply()` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `apply` trap takes three parameters. The first parameter is the `target`
    object, and the third parameter is an array, representing the arguments of the
    function call. The second parameter is same as the value of `this` of the target
    function, that is, it's same as the value of `this` of the target function, if
    the target function would have been invoked without the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `apply` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The construct(target, arguments) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the target is a function, then calling the target as a constructor using
    the `new` operator or the `Reflect.construct()` method will execute the `construct`
    trap.
  prefs: []
  type: TYPE_NORMAL
- en: The `construct` trap takes two parameters. The first parameter is the `target`
    object, and the second parameter is an array, representing the arguments of the
    constructor call.
  prefs: []
  type: TYPE_NORMAL
- en: The `construct` trap must return an object, representing the newly created instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a code example, which demonstrates how to use the `construct` trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The Proxy.revocable(target, handler) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A revocable proxy is a proxy that can be revoked (that is, switched off).
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the revocable, proxies we have to use the `Proxy.revocable()` method.
    The `Proxy.revocable()` method is not a constructor. This method also takes the
    same arguments as the `Proxy` constructor, but instead of returning a revocable
    proxy instance directly, it returns an object with two properties, which are the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`proxy`: This is the revocable proxy object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`revoke`: When this function is called, it revokes the `proxy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once a revocable proxy is revoked, any attempts to use it will throw a `TypeError`
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate how to create a revocable proxy and revoke
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Use Case
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the revocable proxies instead of the regular proxies. You can use
    it when you pass a proxy to a function that runs asynchronously or is parallel
    so that you can revoke it anytime in case you don't want the function to be able
    to use that proxy anymore.
  prefs: []
  type: TYPE_NORMAL
- en: The uses of proxies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several uses of proxies. Here are some main use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating virtualized objects, such as remote objects, persistent objects, and
    more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lazy creation of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparent logging, tracing, profiling, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded domain specific languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generically interposing abstractions in order to enforce the access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned what proxies are and how to use them. We saw the
    various traps available with examples. We also saw different rules that need to
    be followed by different traps. This chapter explained everything in-depth about
    the ES6 Proxy API. Finally, we saw some use cases of proxies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will walk through the object oriented programming, and
    the ES6 classes.
  prefs: []
  type: TYPE_NORMAL
