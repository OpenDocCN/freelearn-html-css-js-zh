- en: Chapter 6. Using Proxies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 使用代理
- en: Proxies are used to define the custom behavior for the fundamental operations
    on objects. Proxies are already available in the programming languages such as
    C#, C++, and Java, but JavaScript has never had proxies. ES6 introduced the Proxy
    API, which lets us create proxies. In this chapter, we will look at proxies, their
    usage, and the proxy traps. Due to the benefits of proxies, the developers are
    using proxies increasingly and therefore, it's important to learn about proxies
    in-depth with examples, which we will do in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 代理用于定义对象基本操作的自定义行为。代理已经在编程语言如C#、C++和Java中可用，但JavaScript从未有过代理。ES6引入了Proxy API，它允许我们创建代理。在本章中，我们将探讨代理、它们的用法和代理陷阱。由于代理的好处，开发者越来越多地使用代理，因此深入了解代理并举例说明非常重要，我们将在本章中这样做。
- en: 'In this chapter, we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating proxies using the Proxy API
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Proxy API创建代理
- en: Understanding what proxies are and how to use them
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代理是什么以及如何使用它们
- en: Intercepting various operations on the objects using traps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用陷阱拦截对象上的各种操作
- en: The different kinds of available traps
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的不同类型的陷阱
- en: Some use cases of proxies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理的一些用例
- en: Proxies in a nutshell
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理概述
- en: A proxy acts like a wrapper for an object, and defines the custom behavior for
    the fundamental operations on the object. Some fundamental operations on the objects
    are property lookup, property assignment, constructor invocation, enumeration,
    and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代理就像对象的包装器，并定义了对象基本操作的自定义行为。对象的一些基本操作包括属性查找、属性赋值、构造函数调用、枚举等。
- en: Once an object is wrapped using a proxy, all the operations that are supposed
    to be done on the object should now be done on the proxy object, so that the custom
    behavior can take place.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用代理包装了一个对象，所有应该在对象上执行的操作现在都应该在代理对象上执行，以便执行自定义行为。
- en: Terminology
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语
- en: 'Here are some important terms that are used while studying proxies:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习代理时，这里有一些重要的术语：
- en: 'Target: This is the object that is wrapped by proxy.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '目标: 这是被代理器包装的对象。'
- en: 'Traps: These are functions that intercept various operations on the target
    object, and define the custom behavior for those operations.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '陷阱: 这些是拦截目标对象上各种操作并定义这些操作自定义行为的函数。'
- en: 'Handler: This is an object that holds the traps. A handler is attached to a
    proxy object.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '处理器: 这是一个持有陷阱的对象。处理器附加到代理对象上。'
- en: The Proxy API
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Proxy API
- en: 'The ES6 Proxy API provides the `Proxy` constructor to create proxies. The `Proxy`
    constructor takes two arguments, which are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 Proxy API提供了`Proxy`构造函数来创建代理。`Proxy`构造函数接受两个参数，它们是：
- en: '**Target**: This is the object that will be wrapped by the proxy'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**: 这是将被代理器包装的对象'
- en: '**Handler**: This is an object that contains the traps for the target object'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**: 这是一个包含目标对象陷阱的对象'
- en: A trap can be defined for every possible operation on the target object. If
    a trap is not defined, then the default action takes place on the target.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为目标对象上的每个可能的操作定义一个陷阱。如果没有定义陷阱，则默认行为将在目标对象上执行。
- en: 'Here is a code example that shows how to create a proxy, and do various operations
    on the target object. In this example, we have not defined any traps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，展示了如何创建代理，并在目标对象上执行各种操作。在这个例子中，我们没有定义任何陷阱：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we can see that the `age` property of the `target` object can be accessed
    via the `proxy` object. And when we added the `name` property to the `proxy` object,
    it was actually added to the `target` object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`target`对象的`age`属性可以通过`proxy`对象访问。当我们向`proxy`对象添加`name`属性时，它实际上被添加到了`target`对象上。
- en: As there was no trap attached for the property assignment, the `proxy.name`
    assignment resulted to the default behavior that is simply assigning the value
    to the property.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有为属性赋值附加陷阱，因此`proxy.name`赋值导致默认行为，即简单地将值赋给属性。
- en: So, we can say a `proxy` is just a wrapper for a `target` object and traps can
    be defined to change the default behavior of operations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以说`proxy`只是`target`对象的包装器，并且可以定义陷阱以更改操作的默认行为。
- en: 'Many developers don''t keep a reference variable for the target object to make
    use of the proxy mandatory for accessing the object. Keep a reference for the
    handler only when you need to reuse it for multiple proxies. Here is how they
    rewrite the previous code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者没有为目标对象保留引用变量以使用代理强制访问对象。只有在你需要为多个代理重用处理器时才保留处理器的引用。以下是他们重写之前代码的方式：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Traps
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 陷阱
- en: There are different traps for different operations that can be performed on
    an object. Some of the traps need to return values. There are some rules they
    need to follow while returning values. The returned values are intercepted by
    the proxy to filter, and/or to check if the returned values obey the rules. If
    a trap doesn't obey rules while returning value, then the proxy throws the `TypeError`
    exception.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以在对象上执行的不同操作，有不同的陷阱。其中一些陷阱需要返回值。在返回值时，它们需要遵循一些规则。返回的值被代理拦截以进行过滤，以及/或检查返回的值是否遵守规则。如果一个陷阱在返回值时违反规则，则代理抛出
    `TypeError` 异常。
- en: The value of `this` inside a trap is always a reference to the handler.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在陷阱内部，`this` 的值始终是处理器的引用。
- en: Lets take a look at the various kinds of traps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看各种陷阱。
- en: The get(target, property, receiver) method
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`get(target, property, receiver)` 方法'
- en: The `get` trap is executed when we retrieve a property value using the dot or
    bracket notation, or the `Reflect.get()` method. It takes three parameters, that
    is, the target object, the property name, and the proxy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用点或方括号表示法检索属性值，或使用 `Reflect.get()` 方法时，会执行 `get` 陷阱。它接受三个参数，即目标对象、属性名和代理。
- en: It must return a value that represents the property value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须返回表示属性值的值。
- en: 'Here is a code example, which shows how to use the `get` trap:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，展示了如何使用 `get` 陷阱：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we can see that the `get` trap looks for the property in the `target`
    object, and if it finds it, then returns the property value. Otherwise, it returns
    a string indicating that it was not found.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `get` 陷阱在 `target` 对象中查找属性，如果找到，则返回属性值。否则，它返回一个字符串，表示未找到。
- en: 'The `receiver` parameter is the reference of the object whose property we intended
    to access. Consider this example to better understand the value of the `receiver`
    parameter:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiver` 参数是我们打算访问其属性的对象的引用。考虑以下示例以更好地理解 `receiver` 参数的值：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here `obj` inherits the `proxy` object. Therefore, when the `name` property
    was not found in the `obj` object, it was looked in the `proxy` object. As the
    `proxy` object had a `get` trap, it provided a value.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `obj` 继承了 `proxy` 对象。因此，当在 `obj` 对象中找不到 `name` 属性时，它会在 `proxy` 对象中查找。由于 `proxy`
    对象有一个 `get` 陷阱，它提供了一个值。
- en: So, the value of the `receiver` parameter when we accessed the `name` property
    via the `obj.name` expression, is `obj`, and when we accessed the `name` property
    via `proxy.name` expression is `proxy`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们通过 `obj.name` 表达式访问 `name` 属性时，`receiver` 参数的值是 `obj`，当我们通过 `proxy.name`
    表达式访问 `name` 属性时，是 `proxy`。
- en: The value of the `receiver` parameter is decided in the same way for all other
    traps also.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有其他陷阱，`receiver` 参数的值也是以相同的方式决定的。
- en: Rules
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `get` trap:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `get` 陷阱时，不应违反以下规则：
- en: The value returned for a property must be the same as the value of the target
    object property if the target object property is a non-writable, non-configurable
    data property.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标对象的属性是一个不可写、不可配置的数据属性，则返回该属性的值必须与目标对象属性的值相同。
- en: The value returned for a property must be `undefined` if the target object property
    is non-configurable accessor property that has `undefined` as its `[[Get]]` attribute.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标对象的属性是一个不可配置的访问器属性，并且其 `[[Get]]` 属性为 `undefined`，则返回该属性的值必须是 `undefined`。
- en: The set(target, property, value, receiver) method
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`set(target, property, value, receiver)` 方法'
- en: The `set` trap is invoked when we set the value of a property using the assignment
    operator, or the `Reflect.set()` method. It takes four parameters, that is, the
    target object, the property name, the new property value, and the receiver.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用赋值运算符或 `Reflect.set()` 方法设置属性值时，会调用 `set` 陷阱。它接受四个参数，即目标对象、属性名、新属性值和接收者。
- en: The `set` trap must return `true` if the assignment was successful. Otherwise,
    it will return `false`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果赋值成功，`set` 陷阱必须返回 `true`。否则，它将返回 `false`。
- en: 'Here is a code example, which demonstrates how to use the `set` trap:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，展示了如何使用 `set` 陷阱：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Rules
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `set` trap:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `set` 陷阱时，不应违反以下规则：
- en: If the target object property is a non-writable, non-configurable data property,
    then it will return as `false`, that is, you cannot change the property value
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标对象属性是一个不可写、不可配置的数据属性，那么它将返回 `false`，也就是说，你不能更改属性值
- en: If the target object property is a non-configurable accessor property that has
    `undefined` as its `[[Set]]` attribute, then it will return as false, that is,
    you cannot change the property value
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标对象属性是一个不可配置的访问器属性，并且其 `[[Set]]` 属性为 `undefined`，那么它将返回 `false`，也就是说，你不能更改属性值
- en: The has(target, property) method
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`has(target, property)` 方法'
- en: The `has` trap is executed when we check if a property exists or not, using
    the `in` operator. It takes two parameters, that is, the target object and the
    property name. It must return a Boolean value that indicates whether the property
    exists or not.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `in` 操作符检查属性是否存在时，将执行 `has` 陷阱。它接受两个参数，即目标对象和属性名。它必须返回一个布尔值，表示属性是否存在。
- en: 'Here is a code example, which demonstrates how to use the `has` trap:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何使用 `has` 陷阱：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Rules
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `has` trap:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `has` 陷阱时，不应违反以下规则：
- en: You cannot return `false` if the property exists as a non-configurable own property
    of the `target` object
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为 `target` 对象的非配置性自身属性存在，你不能返回 `false`
- en: You cannot return `false` if the property exists as an own property of the `target`
    object, and the `target` object is not extensible
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为 `target` 对象的自身属性存在，并且 `target` 对象不可扩展，你不能返回 `false`
- en: The isExtensible(target) method
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`isExtensible(target)` 方法'
- en: The `isExtensible` trap is executed when we check if the object is extensible
    or not, using the `Object.isExtensible()` method. It takes only one parameter,
    that is, the `target` object. It must return a Boolean value indicating whether
    the object is extensible or not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Object.isExtensible()` 方法检查对象是否可扩展时，将执行 `isExtensible` 陷阱。它只接受一个参数，即
    `target` 对象。它必须返回一个布尔值，表示对象是否可扩展。
- en: 'Here is a code example, which demonstrates how to use the `isExtensible` trap:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何使用 `isExtensible` 陷阱：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Rules
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `isExtensible` trap:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `isExtensible` 陷阱时，不应违反以下规则：
- en: You cannot return `false` if the target is extensible. Similarly, you cannot
    return `true` if the target is non-extensible.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标可扩展，你不能返回 `false`。同样，如果目标不可扩展，你不能返回 `true`。
- en: The getPrototypeOf(target) method
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getPrototypeOf(target)` 方法'
- en: The `getPrototypeOf` trap is executed when we retrieve the value of the internal
    `[[prototype]]` property, using either the `Object.getPrototypeOf()` method or
    the `__proto__` property. It takes only one parameter, that is, the `target` object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Object.getPrototypeOf()` 方法或 `__proto__` 属性检索内部 `[[prototype]]` 属性的值时，将执行
    `getPrototypeOf` 陷阱。它只接受一个参数，即 `target` 对象。
- en: It must return an object or `null` value. The `null` value indicates that the
    object doesn't inherit anything else and is the end of the inheritance chain.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须返回一个对象或 `null` 值。`null` 值表示对象没有继承其他内容，并且是继承链的末端。
- en: 'Here is a code example, which demonstrates how to use the `getPrototypeOf`
    trap:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何使用 `getPrototypeOf` 陷阱：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Rules
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `getPrototypeOf` trap:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `getPrototypeOf` 陷阱时，不应违反以下规则：
- en: It must either return an object or return `null` value.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须返回一个对象或返回 `null` 值。
- en: If the target is not extensible, then this trap must return the actual prototype
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标不可扩展，那么这个陷阱必须返回实际的原型
- en: The setPrototypeOf(target, prototype) method
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`setPrototypeOf(target, prototype)` 方法'
- en: The `setPrototypeOf` trap is executed when we set the value of the internal
    `[[prototype]]` property, using either the `Object.setPrototypeOf()` method or
    the `__proto__` property. It takes two parameters, that is, the target object
    and value of the property to be assigned.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Object.setPrototypeOf()` 方法或 `__proto__` 属性设置内部 `[[prototype]]` 属性的值时，将执行
    `setPrototypeOf` 陷阱。它接受两个参数，即目标对象和要分配的属性值。
- en: This trap will return a Boolean, indicating whether it has successfully set
    the prototype or not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陷阱将返回一个布尔值，表示是否已成功设置原型。
- en: 'Here is a code example, which demonstrates how to use the `setPrototypeOf`
    trap:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个代码示例，演示了如何使用 `setPrototypeOf` 陷阱：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Rules
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `setPrototypeOf` trap:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `setPrototypeOf` 陷阱时，不应违反以下规则：
- en: You must return `false` if the target is not extensible
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标不可扩展，你必须返回`false`。
- en: The preventExtensions(target) method
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`preventExtensions(target)`方法'
- en: The `preventExtensions` trap is executed when we prevent the addition of new
    properties using the `Object.preventExtensions()` method. It takes only one parameter,
    that is, the `target` object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Object.preventExtensions()`方法防止添加新属性时，会执行`preventExtensions`陷阱。它只接受一个参数，即`target`对象。
- en: It must return a Boolean, indicating weather it has successfully prevented the
    extension of the object or not.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 它必须返回一个布尔值，指示是否已成功防止对象的扩展。
- en: 'Here is a code example, which demonstrates how to use the `preventExtensions`
    trap:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，演示了如何使用`preventExtensions`陷阱：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rules
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `preventExtensions` trap:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`preventExtensions`陷阱时，不应违反以下规则：
- en: This trap can return `true` only if the target is non-extensible, or it has
    made the target non-extensible
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此陷阱只有在目标不可扩展或已使目标不可扩展的情况下才能返回`true`。
- en: The getOwnPropertyDescriptor(target, property) method
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`getOwnPropertyDescriptor(target, property)`方法'
- en: The `getOwnPropertyDescriptor` trap is executed when we retrieve the descriptor
    of a property by using the `Object.getOwnPropertyDescriptor()` method. It takes
    two parameters, that is, the target object and the name of the property.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Object.getOwnPropertyDescriptor()`方法检索属性的描述符时，会执行`getOwnPropertyDescriptor`陷阱。它接受两个参数，即目标对象和属性名称。
- en: This trap must return a descriptor object or `undefined`. The `undefined` value
    is returned if the property doesn't exist.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此陷阱必须返回一个描述符对象或`undefined`。如果属性不存在，则返回`undefined`值。
- en: 'Here is a code example, which demonstrates how to use the `getOwnPropertyDescriptor`
    trap:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，演示了如何使用`getOwnPropertyDescriptor`陷阱：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Rules
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `getOwnPropertyDescriptor`
    trap:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`getOwnPropertyDescriptor`陷阱时，不应违反以下规则：
- en: This trap must either return an object or return an `undefined` property
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此陷阱必须返回一个对象或返回一个`undefined`属性。
- en: You cannot return the `undefined` value if the property exists as a non-configurable
    own property of the `target` object
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为`target`对象的非可配置自有属性存在，则不能返回`undefined`值。
- en: You cannot return the `undefined` value if the property exists as an own property
    of the `target` object, and the `target` object is not extensible
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为`target`对象的非可配置自有属性存在，并且`target`对象不可扩展，则不能返回`undefined`值。
- en: You will have to return `undefined`, if the property does not exist as an own
    property of the `target` object, and the `target` object is not extensible
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性不是`target`对象的自有属性，并且`target`对象不可扩展，你必须返回`undefined`。
- en: You cannot make the `configurable` property of the returned descriptor object
    false, if the property exists as an own property of the `target` object, or if
    it exists as a configurable own property of the `target` object
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为`target`对象的自有属性存在，或者作为可配置的自有属性存在，则不能将返回的描述符对象的`configurable`属性设置为`false`。
- en: The defineProperty(target, property, descriptor) method
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`defineProperty(target, property, descriptor)`方法'
- en: The `defineProperty` trap is executed when we define a property using the `Object.defineProperty()`
    method. It takes three parameters, that is, the `target` object, the `property`
    name, and the `descriptor` object.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Object.defineProperty()`方法定义属性时，会执行`defineProperty`陷阱。它接受三个参数，即`target`对象、属性名称和描述符对象。
- en: This trap should return a Boolean indicating whether it has successfully defined
    the property or not.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此陷阱应返回一个布尔值，指示是否已成功定义属性。
- en: 'Here is a code example, which demonstrates how to use the `defineProperty`
    trap:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个代码示例，演示了如何使用`defineProperty`陷阱：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Rules
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `defineProperty` trap:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`defineProperty`陷阱时，不应违反以下规则：
- en: It must return `false` if the `target` object is not extensible, and the property
    doesn't yet exist
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`target`对象不可扩展，并且属性尚未存在，则必须返回`false`。
- en: The deleteProperty(target, property) method
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`deleteProperty(target, property)`方法'
- en: The `deleteProperty` trap is executed when we delete a property using either
    the `delete` operator or the `Reflect.deleteProperty()` method. It takes two parameters,
    that is, the `target` object and the `property` name.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`delete`运算符或`Reflect.deleteProperty()`方法删除属性时，会执行`deleteProperty`陷阱。它接受两个参数，即`target`对象和`property`名称。
- en: This trap must return a Boolean, indicating whether the property was deleted
    successfully or not.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此陷阱必须返回一个布尔值，指示属性是否成功删除。
- en: 'Here is a code example, which demonstrates how to use the `deleteProperty`
    trap:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `deleteProperty` 陷阱：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Rules
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'This rule shouldn''t be violated while using the `deleteProperty` trap:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `deleteProperty` 陷阱时，不应违反此规则：
- en: This trap must return `false` if the property exists as a non-configurable own
    property of the `target` object
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性作为 `target` 对象的非配置性自身属性存在，则此陷阱必须返回 `false`。
- en: The enumerate(target) method
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`enumerate(target)` 方法'
- en: The `enumerate` trap is executed when we loop over the property keys using either
    the `for…in` loop or the `Reflect.enumerate()` method. It takes one parameter,
    that is, the `target` object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `for...in` 循环或 `Reflect.enumerate()` 方法遍历属性键时，会执行 `enumerate` 陷阱。它接受一个参数，即
    `target` 对象。
- en: This trap must return an iterator object, representing the enumerable keys of
    the object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个陷阱必须返回一个迭代器对象，表示对象的可枚举键。
- en: 'Here is a code example, which demonstrates how to use the `enumerate` trap:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `enumerate` 陷阱：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Output is:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Rules
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'This rule shouldn''t be violated while using the `enumerate` trap:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `enumerate` 陷阱时，不应违反此规则：
- en: This trap must return an object
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此陷阱必须返回一个对象
- en: The ownKeys(target) method
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ownKeys(target)` 方法'
- en: The `ownKeys` trap is executed when we retrieve the own property keys using
    the `Reflect.ownKeys()`, `Object.getOwnPropertyNames()`, `Object.getOwnPropertySymbols()`,
    and the `Object.keys()` methods. It takes only one parameter, that is, the `target`
    object.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `Reflect.ownKeys()`、`Object.getOwnPropertyNames()`、`Object.getOwnPropertySymbols()`
    和 `Object.keys()` 方法检索自身属性键时，会执行 `ownKeys` 陷阱。它只接受一个参数，即 `target` 对象。
- en: The `Reflect.ownKeys()` method is similar to the `Object.getOwnPropertyNames()`
    method, that is, they return the enumerable and non-enumerable property keys of
    a object. They ignore the inherited properties. The only difference is that the
    `Reflect.ownKeys()` method returns both, the symbol and string keys, whereas the
    `Object.getOwnPropertyNames()` method returns only the string keys.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflect.ownKeys()` 方法类似于 `Object.getOwnPropertyNames()` 方法，即它们返回对象的枚举和非枚举属性键。它们忽略继承的属性。唯一的区别是
    `Reflect.ownKeys()` 方法返回的是符号键和字符串键，而 `Object.getOwnPropertyNames()` 方法只返回字符串键。'
- en: The `Object.getOwnPropertySymbols()` method returns the enumerable and non-enumerable
    properties whose keys are symbols. It ignores the inherited properties.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.getOwnPropertySymbols()` 方法返回键为符号的可枚举和非枚举属性。它忽略继承的属性。'
- en: The `Object.keys()` method is similar to the `Object.getOwnPropertyNames()`
    method, but the only difference is that the `Objecy.keys()` method returns the
    enumerable properties only.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.keys()` 方法类似于 `Object.getOwnPropertyNames()` 方法，但唯一的不同是 `Objecy.keys()`
    方法只返回可枚举属性。'
- en: The `ownKeys` trap must return an array, representing the own property keys.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`ownKeys` 陷阱必须返回一个数组，表示自身的属性键。'
- en: 'Here is a code example, which demonstrates how to use the `ownKeys` trap:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `ownKeys` 陷阱：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we can see that the values of the array returned by the `ownKeys` trap
    are filtered by the proxy, based on what the caller expected. For example, the
    `Object.getOwnPropertySymbols()` caller expected an array of symbols. Therefore,
    the proxy removed the strings from the returned array.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到 `ownKeys` 陷阱返回的数组值被代理根据调用者期望的值进行过滤。例如，`Object.getOwnPropertySymbols()`
    调用者期望一个包含符号的数组。因此，代理从返回的数组中移除了字符串。
- en: Rules
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规则
- en: 'These rules shouldn''t be violated while using the `ownKeys` trap:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `ownKeys` 陷阱时，不应违反这些规则：
- en: The elements of the returned array must either be a string or symbol
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回数组的元素必须是字符串或符号
- en: The returned array must contain the keys of all the non-configurable own properties
    of the `target` object
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的数组必须包含 `target` 对象所有非配置性自身属性的键。
- en: If the `target` object is not extensible, then the returned array must contain
    all the keys, of the own properties, of the `target` object, and no other values
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `target` 对象不可扩展，则返回的数组必须包含 `target` 对象所有自身属性的键，且不包含其他值。
- en: The apply(target, thisValue, arguments) method
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`apply(target, thisValue, arguments)` 方法'
- en: If the target is a function, then calling the proxy will execute the `apply`
    trap. The `apply` trap is also executed for function's `apply()` and `call()`
    methods, and the `Reflect.apply()` method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是函数，则调用代理将执行 `apply` 陷阱。`apply` 陷阱也会在函数的 `apply()` 和 `call()` 方法以及 `Reflect.apply()`
    方法中执行。
- en: The `apply` trap takes three parameters. The first parameter is the `target`
    object, and the third parameter is an array, representing the arguments of the
    function call. The second parameter is same as the value of `this` of the target
    function, that is, it's same as the value of `this` of the target function, if
    the target function would have been invoked without the proxy.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply` 陷阱接受三个参数。第一个参数是 `target` 对象，第三个参数是一个数组，表示函数调用时的参数。第二个参数与目标函数的 `this`
    值相同，即它等同于目标函数在没有代理的情况下被调用时的 `this` 值。'
- en: 'Here is a code example, which demonstrates how to use the `apply` trap:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `apply` 陷阱：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The construct(target, arguments) method
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`construct(target, arguments)` 方法'
- en: If the target is a function, then calling the target as a constructor using
    the `new` operator or the `Reflect.construct()` method will execute the `construct`
    trap.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目标是函数，则使用 `new` 操作符或 `Reflect.construct()` 方法将目标作为构造函数调用时，将执行 `construct`
    陷阱。
- en: The `construct` trap takes two parameters. The first parameter is the `target`
    object, and the second parameter is an array, representing the arguments of the
    constructor call.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`construct` 陷阱接受两个参数。第一个参数是 `target` 对象，第二个参数是一个数组，表示构造函数调用时的参数。'
- en: The `construct` trap must return an object, representing the newly created instance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`construct` 陷阱必须返回一个对象，表示新创建的实例。'
- en: 'Here is a code example, which demonstrates how to use the `construct` trap:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何使用 `construct` 陷阱：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The Proxy.revocable(target, handler) method
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Proxy.revocable(target, handler)` 方法'
- en: A revocable proxy is a proxy that can be revoked (that is, switched off).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可撤销代理是一种可以被撤销（即关闭）的代理。
- en: 'To create the revocable, proxies we have to use the `Proxy.revocable()` method.
    The `Proxy.revocable()` method is not a constructor. This method also takes the
    same arguments as the `Proxy` constructor, but instead of returning a revocable
    proxy instance directly, it returns an object with two properties, which are the
    following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建可撤销的代理，我们必须使用 `Proxy.revocable()` 方法。`Proxy.revocable()` 方法不是一个构造函数。此方法也接受与
    `Proxy` 构造函数相同的参数，但它不会直接返回一个可撤销的代理实例，而是返回一个具有两个属性的对象，具体如下：
- en: '`proxy`: This is the revocable proxy object'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy`: 这是一个可撤销的代理对象'
- en: '`revoke`: When this function is called, it revokes the `proxy`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`revoke`: 当此函数被调用时，它将撤销 `proxy`'
- en: Once a revocable proxy is revoked, any attempts to use it will throw a `TypeError`
    exception.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦撤销了可撤销代理，任何尝试使用它的操作都将抛出 `TypeError` 异常。
- en: 'Here is an example to demonstrate how to create a revocable proxy and revoke
    it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示如何创建可撤销代理并撤销它的示例：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Use Case
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用例
- en: You can use the revocable proxies instead of the regular proxies. You can use
    it when you pass a proxy to a function that runs asynchronously or is parallel
    so that you can revoke it anytime in case you don't want the function to be able
    to use that proxy anymore.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用可撤销代理代替常规代理。当你将代理传递给一个异步运行或并行运行的函数时，你可以使用它，这样你就可以随时撤销它，以防你不想让该函数再使用该代理。
- en: The uses of proxies
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代理的使用
- en: 'There are several uses of proxies. Here are some main use cases:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 代理有多种用途。以下是一些主要用例：
- en: Creating virtualized objects, such as remote objects, persistent objects, and
    more
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建虚拟对象，例如远程对象、持久对象等
- en: The lazy creation of objects
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的懒加载创建
- en: Transparent logging, tracing, profiling, and more
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 透明的日志记录、跟踪、分析等
- en: Embedded domain specific languages
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入特定领域的语言
- en: Generically interposing abstractions in order to enforce the access control
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过泛化插入抽象来强制执行访问控制
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what proxies are and how to use them. We saw the
    various traps available with examples. We also saw different rules that need to
    be followed by different traps. This chapter explained everything in-depth about
    the ES6 Proxy API. Finally, we saw some use cases of proxies.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了什么是代理以及如何使用它们。我们通过示例看到了可用的各种陷阱。我们还看到了不同陷阱需要遵循的不同规则。本章深入解释了 ES6 Proxy
    API 的所有内容。最后，我们看到了一些代理的使用案例。
- en: In the next chapter, we will walk through the object oriented programming, and
    the ES6 classes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍面向对象编程和 ES6 类。
