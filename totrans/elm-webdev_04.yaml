- en: Preparing a Unit Conversion Website in Elm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml), *Preparing
    a Unit Conversion Website in Elm*. The goal of this chapter is to prepare a website
    that will convert miles to metric system measurements, that is, to kilometers. By
    completing this chapter, you will acquire practical skills that are integral to
    how Elm works, all in a fun project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics we will cover include:'
  prefs: []
  type: TYPE_NORMAL
- en: Elm language features used to make the website, which include type annotations,
    `case` expressions, union types, and messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding `Result` as a way to handle errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing Elm architecture, and workflow concepts to make the website
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with type annotations, case expressions, union types, and messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are we going to build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build the core of a simple unit conversion website.
    We will introduce a lot of new concepts and use them in practice right away. To
    be able to fit everything into one chapter, we'll only set up the basic plumbing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll expand on what we have built to create a more complex
    structure. To get started, we'll start a brand new Elm app.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, run the following command in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Remember that to run your app, you need to point your console to your new app
    folder, and then use the `elm-app start` command in your console. Now that we've
    set everything up for development, it's time to start building the app.
  prefs: []
  type: TYPE_NORMAL
- en: Building our Unit Conversion app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, let''s delete everything in `Main.elm`. Next, let''s set up a working
    bare-bones app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we have an app that works, that is, that displays on the screen.
    However, it doesn't really do anything. Still, it is worthwhile to look at what
    each line of the preceding code actually does. We start off the usual way, by
    declaring the `main` module and importing all the other modules used in our app.
  prefs: []
  type: TYPE_NORMAL
- en: The `init` function is our app's initial model, which we set to an empty `Record`.
    Next, we set up a union type of `Msg`, and give it the value of `Nothing`. `Nothing`
    is simply nothing—our `Msg` union type currently has no value.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we pass two parameters to our `update` function, `msg` and `model`, and
    return the `model`. The `view` function is just a `div` with a text node in its
    second `List`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let's look at the entry point of our app, the `main` function. We simply
    pass it the `beginnerProgram`, setting the `model` to the value of `init`, `view`
    to `view`, and `update` to `update`. Next, let's update the `init` function.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the init function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our `init` function will be the initial state of our app. Let''s update it
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `init` function gets assigned the value of a `Record` that has two `Strings`
    and two `Floats`. Basically, here we are modeling the data that our app will use.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations and type aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At this point, we might want to add the type annotation above the `init` function.
    If you are using the linter with Atom, you should see the following warning in
    the editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the order of named values inside the type annotation does not match
    the order we gave the `Record` we assigned to our `init` function. The reason
    is simple: records in Elm are not index-based.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we can choose to add the suggested type annotation above the `init` function,
    and the compiler will be happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is an even better thing that we can do: use a type alias instead.
    With type alias, we shorten our type annotations, making it easier to use them
    wherever needed. In this case, we need to create a type alias to use on the `init`
    function. Since the `init` function is basically just the initial model, it only
    makes sense to create a type alias called `Model`, and then use it as needed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, let''s set up a type alias `Model`, just above the `init` function in
    our code, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, our updated `Main.elm` will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the preceding code, we can see that the type annotation for `init` is
    simply `init : Model`, because now we are using the type alias of `Model`. Let''s
    turn our attention to the `view` and `update` functions now.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating the view and update functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to understand that the `view` and `update` functions are connected
    via messages. Whatever message is sent out by the `view` function is received
    by the `update` function. That's why the type of message that the `view` function
    sends should be the same type that the `update` message receives. This might seem
    obvious, but having no doubts about this will make you a better Elm developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s add some more content to our `view` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: At this point, our `view` is displaying on the screen, and the button sends
    the message of `Nothing` to `update`. If we compile the app and run it at this
    point, we will see an improved UI on our page. However, everything is static,
    and clicking the button will not do anything at this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin making the page interactive by replacing the `Nothing` value with
    a different value. We''ll call it `Swap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our `view` function is now sending the `Swap` message `onClick` of the
    button in our `view`, let''s update our union type of `Msg`, with the value of
    `Swap`, just above the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s tell the `update` function what to do with the message of `Swap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we are using some code that we have not seen
    before. Let''s look at how it works. If the `update` function receives a message
    of value `Swap`, it will run the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What does the preceding code do? Let''s start with this section of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code means—return the same model that you had previously, with
    the only update specified in the code on the right-hand side of the pipe character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code on the right of the pipe character does the following: it sets the
    value of `unit1` to `model.unit2`, and the value of `unit2` to `model.unit1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you save your app at this point and run it, you''ll see that after it renders
    the HTML in the browser; nothing else changes. To make sure the code actually
    does something, we need to replace the hard-coded `Strings` inside the `text`
    functions of our `view` to the appropriate `model` values, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, running our code and clicking the button will actually send the `Swap`
    message from the `view` to the `update`, which the user will see as "Kilometers"
    and "Miles" on the screen switching places on a button-click.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the conversion logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we can make our app convert the inputs it receives on a button- click.
    Let''s begin by updating our `view` function so that it displays the initial converted
    value, that is, the value of 0.0, as that is the value we gave the `Record` that
    we are passing to the `init` function. Note that the following code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running our app with the preceding update will result in the compiler throwing
    an error. Why? Simply because the `text` function must always receive a `String`.
    So, we need to first run the `toString` function on `model.convertedValue`, and
    then give the result of that expression to the `text` function. Like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Running the app at this point will only introduce a minor change on the screen.
    A zero will be displayed on the screen. However, if the user types into the input
    field, this will not affect the zero—it will still just sit there. Let's fix that
    now by improving the `input` function in our view.
  prefs: []
  type: TYPE_NORMAL
- en: Improving the input function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for our app to be able to convert the values entered into the input
    text field, we need to be able to do something with that input. In other words,
    we need to send the value of the input to the `update` function, and then tell
    the `update` function what to do with the message that it received.
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, let''s add to our `view` function so that when the user types something,
    it sends a `message` of that event to the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have just added another item to the first `List` of
    the `input` function. The item we added is the `onInput` function, which receives
    a parameter we called `Convert`.
  prefs: []
  type: TYPE_NORMAL
- en: The stumbling block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the development of our app, we haven't had any major issues. We are
    about to hit a minor road bump, and it's important to walk through this slowly,
    just as it's laid out in the section that follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done with the `view`. Now, we can change our `update` function accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we ran our app right now, it would not compile. Even though the preceding
    code is perfectly valid, there is a piece missing. Have a look at the error message,
    and try to understand what the reason is for this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, on line `28`, our `update` function is trying to pattern-match for
    the pattern called `Convert`, and it cannot find it. Similarly, on line `36`,
    our `view` function is trying to use a variable called `Convert`, but it cannot
    find it.
  prefs: []
  type: TYPE_NORMAL
- en: To solve this error, let's briefly think about the messages that our `view`
    function can send. How many are there?
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there are only two messages: `Swap` and `Convert`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the `Swap` message, you''ll see that it''s used in three places
    in our code: in the `view` function, as a parameter of the `onClick` function.
    In the `update` function''s `case` expression, it is used as the `Swap` pattern,
    and in the union type of `Msg`, it is used as its only possible value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to solve our error, we need to add the `Convert` value as another possible
    value of the `Msg` union type, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the app now will result in another error, but the solution to this
    one should be a bit more obvious. Here is the text of the error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the error message, the compiler is looking at the `Convert`
    pattern, and it sees that it has the argument we called `newValue`. But when it
    looks at the `Msg` union type, it only sees `Convert`. There are no arguments
    there!
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix the current error, we need to specify the argument that the `Convert`
    value must take along with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Saving the preceding changes in our app will bring us one step closer to the
    fully working code.
  prefs: []
  type: TYPE_NORMAL
- en: With the current code, even after the improvements, our app still won't compile.
    An impatient reader at this point might start getting slightly irritated with
    the compiler, helpful as it is.
  prefs: []
  type: TYPE_NORMAL
- en: However, what follows is probably the most important piece of knowledge in this
    entire chapter. It's about toggling primitive values in our apps - a subject that
    is rarely, if ever, discussed in online resources, perhaps because it is considered
    as another one of those *expected understandings*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s work through this stumbling block. To begin, let''s revisit our
    `model`, that is, the type alias of `Model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the `convertedValue` is a `Float`, not
    a `String`. We might think that the solution would be to simply change the value
    passed to `Convert` from `String` to `Float`, in our `Msg` union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this will only result in a different error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, obviously, our `onInput` message needs to be a `String`. Let''s try converting
    the `newValue`, which is a `String`, to a `Float`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will throw yet another error, and this one might look a
    bit intimidating at first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason why this message might look a bit less intuitive from what we''re
    used to is two-fold. Firstly, the message is reporting an error that has to do
    with our type alias `Model`, which was great at hiding complexity from our app,
    but now it might be hampering our efforts to understand the issue. Secondly, inside
    the error, we can see a new Elm keyword: `Result`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s resolve the error step by step. We''ll begin by trying to produce a
    more understandable error, by commenting out the type alias of `Model`, together
    with the `init` function''s type annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try recompiling the app to get a slightly different error message,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding error message makes it slightly more obvious. We are having issues
    with this `Result.Result` thing. Just what is it?
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with the Result.Result error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Result` is a type. We use the `Result` type whenever we have a function that
    could possibly return an error.'
  prefs: []
  type: TYPE_NORMAL
- en: In our preceding example, we have an input field. The user types into the input
    field, and we are expecting the input to be of type `Float`. However, what if
    the user types in one or more letters, or a combination of letters and numbers,
    or any other odd character other than just numbers?
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, it boils down to two possibilities—a function returns an *error*
    by virtue of the user typing unexpected characters into the input field, or it
    returns a *result*, by virtue of the user typing `Floats`, as we expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `Result` package is defined in the official documentation,
    available at: [http://package.elm-lang.org/packages/elm-lang/core/latest/Result](http://package.elm-lang.org/packages/elm-lang/core/latest/Result):'
  prefs: []
  type: TYPE_NORMAL
- en: '"A Result is the result of a computation that may fail. This is a great way
    to manage errors in Elm."'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official documentation gives the following union type definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So, if our function succeeds, we''ll get an `Ok` with the value; otherwise,
    we''ll get an `Err` with an error. This begs the question: how do we then deal
    with errors in our programs, using `Result`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, the solution is simple and elegant, like everything else in Elm:
    if we get an `Ok`, the function should return a value; if we get an `Err`, the
    function should return a *default* value. Let''s take another example from the
    official documentation and run it in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we are parsing the string of `"123"` to an `Int`, but
    just to be on the safe side, in case we get an `Err`, we set the default value
    to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the REPL returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try the second example now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'What will REPL return now? The exact same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The conclusion is, no matter what we write inside the double quotes, Elm will
    take care of it, as long as we have a default solution for `Err` values.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what `Result.Result` is, let's go back to fixing our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Result type to fix our app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After getting sidetracked with a lot of error messages and some dry theory,
    let''s put our new skills in to practice by changing the `update` function to
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should be a lot easier to understand now. If our `update`
    function receives a message that pattern-matches the `Convert` pattern with its
    `newValue` string, we'll execute the code after the arrow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code after the arrow says: use the existing model, with a change to be
    made only to the model''s `convertedValue`. The updated value to assign to `convertedValue`
    is the result of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Elm evaluates the expression starting with the parentheses: it takes the `newValue`
    String and converts it to `Float`.'
  prefs: []
  type: TYPE_NORMAL
- en: If the operation is successful, it returns the given `Float` as the value of
    the evaluated expression. If the operation is not successful, it returns number
    `10`, and that is indeed what you'll see on the screen if you type anything other
    than numbers into the input field in your running app.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one thing left to do: uncomment the type alias `Model` and the
    `init` function''s type annotation. With all the changes we have had, this is
    the full code of our app at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Run the app and test it out.
  prefs: []
  type: TYPE_NORMAL
- en: If you type a number into the input field, you'll get that same number on the
    next line. However, if you type any other characters inside the input field, you'll
    get number 10 on the next line—a clear sign that our function's `Result` was `Err`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll make our app actually convert the values it receives
    from the input field.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the conversion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s update the `Convert` pattern in the `update` function''s `case` expression.
    Our new code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: After the update, save the app and test the behavior of the input field. Once
    you start typing a number, you'll see it immediately being converted to its converted
    value in kilometers.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is another improvement we need to make. As our `Result.withDefault`
    is now 10, whenever a user types anything else besides numbers, or even before
    they start typing, we see the number `16.08` displayed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an easy enough fix. Instead of 10, we''ll simply use zero as the default
    `Result`. Update the code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now, the app has the expected behavior.
  prefs: []
  type: TYPE_NORMAL
- en: However, the expression after the `->` operator is a bit unwieldy. We will make
    our code a bit nicer to look at, and learn another feature of the Elm language
    along the way, by using a `let` expression.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our app using a let expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, we are ready to use a `let` expression to improve the `Convert`
    pattern of our `update` function's case expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `let` expression in Elm consists of two parts: `let` and `in`. The `let`
    part lets us declare variables and functions that will be used in the `in` section
    of the `let` expression. It''s important to note that the variables declared here
    are scoped to the function they are used in. The rest of our program is not aware
    of it. In other words, these variables are local, and do not exist in the rest
    of our program.  Contrast that to functions such as the `update` or the `view`
    functions, which live in the global scope.'
  prefs: []
  type: TYPE_NORMAL
- en: The `in` section of a `let` expression should return a single value as a result
    of whatever expressions are placed there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how we can write our `Convert` pattern as a `let` expression.
    To begin, let''s look at it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s think about putting a part of the preceding code in a variable,
    scoped to the `let` expression. An obvious candidate would be this bit of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: What name could we give to the preceding snippet of code?
  prefs: []
  type: TYPE_NORMAL
- en: 'How about `floatValue`? It''s a nice, descriptive name, since we are indeed
    converting the existing `newValue` string to a `Float`, and giving it the default
    value of zero. So, our updated code will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s rewrite our `Convert` pattern as a `let` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There, much better.
  prefs: []
  type: TYPE_NORMAL
- en: We've reduced the cognitive load of trying to decipher that long, one-line expression
    we previously had, into a nice `let` expression that is a lot easier to reason
    about. Working with `let` expressions will soon feel so natural to you that you'll
    wonder how you ever did without them. Why? Because writing our code like this
    makes a clear separation between variables being declared in the `let` part of
    the `let` expression, and the actual expression, in its `in` part.
  prefs: []
  type: TYPE_NORMAL
- en: Making our app look nicer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve covered a lot of theory and we''ve also put it into
    practice. Let''s look at the full code of our app at this stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next, we'll focus on making the app look nicer by using Bootstrap 4.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Bootstrap styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To begin, navigate to `index.html` in your project''s `public` folder and add
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The starting point of our code update will be a simple snippet of HTML, copied
    from the official Bootstrap documentation website. The code we will be using is
    for a Bootstrap-based input group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s convert the preceding snippet to Elm code, using the HTML to Elm page,
    available at: [https://mbylstra.github.io/html-to-elm/](https://mbylstra.github.io/html-to-elm/).
    After our HTML gets parsed, this is what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to map our existing Elm code to the preceding Elm code. To make
    it easier to work with, we will also assign it to a variable. After we''ve done
    that, our `view` function will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code gives a slightly different HTML structure than what we had
    so far, but it is also more semantic and nicer looking for the end user. Let''s
    look at the complete code for our app at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our app should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31e3afa6-b64e-4975-a7b0-f09d42ab9d06.png)'
  prefs: []
  type: TYPE_IMG
- en: There are a few improvements that can be made to our app at this point. For
    example, the Switch button only switches the names of units between kilometers
    and miles, but when the Switch button is pressed, it does not update the values
    that are already present in the input field. Also, the page layout and styling,
    although better than what we had, could still use a bit more improvement.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add these features and further improve the app
    so that it has multiple inputs for the conversion of multiple units. Now, we'll
    shift our focus to looking at ways to apply what we learned in this chapter and
    update our *FizzBuzz* app.
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the FizzBuzz app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can start improving our *FizzBuzz* app, let''s remind ourselves of
    where we left off in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s convert the preceding app so that it works with the Elm architecture,
    and so it prints out either a number or a word based on user input. We''ll begin
    with the bare-bones app we used before, which utilizes the `beginnerProgram` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s populate our initial model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add a type alias of `Model`, and update the type annotation of `initModel`
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s give our `view` function some HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: If we compile the app now, we'll see an input and a button in our browser. What
    we want to do in this version of the *FizzBuzz* app is we want the user to type
    a number inside the input, and after they click the button, the app will print
    out either a number or one of the words, as per the rules of the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can start to make the app receive user input. Let''s update the nested
    `input` function inside the `view` function by adding an `onInput` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to allow our `update` function to receive that message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we still need to make changes to the `Msg` union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If we ran our app now, we'd see an input, a button, and below it, the number
    zero. If we typed letters, nothing would change; however, if we typed numbers,
    they would get displayed in place of the zero.
  prefs: []
  type: TYPE_NORMAL
- en: Giving our FizzBuzz app some logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll give our *FizzBuzz* app some logic so that it displays
    results based on user input. Let''s do that by adding logic to the `DisplayInput`
    patter of our update function''s `case` expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'What we have done in the preceding code can be explained in several points:'
  prefs: []
  type: TYPE_NORMAL
- en: We have given our `DisplayInput` pattern a scoped variable we called `condition`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `condition` variable will evaluate to one of the `if` expressions inside
    of it, based on the number that the user typed into the `input` field (which was
    stored in the `newValue` variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `in` part of the `let` expression, we simply return the same model plus
    the updated `outputValue`, based on the value that the condition variable equated
    to in the `let` part of the `let` expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can now save and run our app and observe how it dynamically updates the text
    node of the `div` under the input field, based on user inputs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe the following behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Typing a number will result in a correct calculation of a number or a word from
    the *FizzBuzz* game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typing anything else will return that exact same string in the `div` under the
    input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that there is still more room for improvement for our app. We will
    improve it by simply adding another `if` expression to our condition variable,
    and resolving the rest to a message to the user telling them that they need to
    input a number, not other characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The update we need to make is easy enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our *FizzBuzz* app is behaving a lot nicer. Let''s see the full
    code of the app at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the welcome screen of our improved *FizzBuzz* app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e479343-888e-4467-9aa5-f5d9bc922d44.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Typing a number produces the desired result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a2f6929-879a-46f1-b759-0fe069fb0966.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Typing anything else will produce a user-friendly error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ca4b2331-2f12-4615-9ea0-9be167ccf830.png)'
  prefs: []
  type: TYPE_IMG
- en: There are still many things that we can improve, as we'll see in [Chapter 5](d141e3a8-3fa0-4e32-8804-6b1824eeff3f.xhtml),
    *Completing the Unit Conversion Website in Elm*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](5c3a6b83-d672-49a1-9da9-355bb415b8c4.xhtml), *Preparing a Unit
    Conversion Website in Elm*, we learned a number of important concepts, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the `Msg` union type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up our model's data with `Records`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using type annotations and type aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating only a section of our model using pipe characters in our expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with the `Result` union type to handle potential errors in our apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `let` expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will improve our unit conversion website by adding multiple
    inputs for converting various units.
  prefs: []
  type: TYPE_NORMAL
