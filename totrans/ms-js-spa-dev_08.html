<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Managing Data Using MongoDB</h1></div></div></div><p>MongoDB is the database for the MEAN stack, and we have already explored some of its more basic features. It is an extremely powerful, scalable, NoSQL database that has gained wide popularity for big data and web applications. It happens to be open source and supported on a wide variety of operating systems and platforms.</p><p>MongoDB can be accessed using the MongoDB shell, a command-line interface that uses JavaScript-like syntax.</p><p>In this chapter, we will explore MongoDB in greater depth and begin to incorporate it into our SPA. You will explore the various CRUD operations in the MongoDB shell, as well as using a Node.js plugin to access a database inside your single page application.</p><p>We will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">NoSQL databases</li><li class="listitem" style="list-style-type: disc">Commanding MongoDB using the shell</li><li class="listitem" style="list-style-type: disc">Incorporating MongoDB into the SPA</li><li class="listitem" style="list-style-type: disc">MongoDB performance</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec49"/>Exploring the NoSQL database model</h1></div></div></div><p>MongoDB is one of a number of NoSQL databases. Currently, it happens to be the most popular NoSQL database in use, according to statistics gathered by those who watch databases. SQL-based, relational databases have served us well for decades, so what's the big deal with NoSQL?</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec100"/>Defining NoSQL</h2></div></div></div><p>MongoDB is often referred to as a NoSQL database. NoSQL is a popular buzzword that applies to MongoDB and several other database engines. But what does it mean?</p><p>First, there is no standard definition by some governing body defining what NoSQL means. The term was first used in 1998 by Carlo Strozzi to describe an open source relational database that did not have an SQL interface. However, today the term is used differently. NoSQL databases tend to have two defining features.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec96"/>NoSQL</h3></div></div></div><p>As the name might imply, most NoSQL databases do not use SQL to access the database. There are some NoSQL databases, however, that allow languages that are SQL-like or derived from SQL. Therefore, some take NoSQL to mean <em>not only SQL</em>.</p><p>MongoDB databases are normally accessed through JavaScript-like syntax.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec97"/>Non-relational</h3></div></div></div><p>NoSQL databases do not use the relational model, where data is stored in structured tables of columns or rows. In the case of MongoDB, data is stored as documents in collections.</p><p>In relational databases, data is stored in tables, much like a table in a spreadsheet.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec98"/>Distributed</h3></div></div></div><p>MongoDB, and other NoSQL databases, are designed to be distributed to work well in clusters. This makes hosting NoSQL databases in the cloud among numerous servers easier and provides for security, backup, performance, and scaling.</p><p>MongoDB supports sharding. Sharding is a process where portions of the database are hosted on different servers. This can make MongoDB extremely fast and highly scalable.</p><p>While it's beyond the scope of this book, the distributed nature of MongoDB makes it appealing for big data projects. Certainly, it makes MongoDB a compelling solution for web applications, which is its most popular use currently.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec101"/>Features of MongoDB</h2></div></div></div><p>Mongo has a number of features you should be aware of that make it different from other databases. They are explained as follows.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec99"/>Document model</h3></div></div></div><p>There are a number of models used by NoSQL databases. Some of these include the graph model, key-value model, object model, and others. These other models are beyond the scope of this book.</p><p>MongoDB uses the document model. Data is stored in collections of documents in a MongoDB database.</p><p>Here's an example of a MongoDB document:</p><pre class="programlisting">{  &#13;
"_id" : ObjectId("566d9d4c1c09d090fd36ba82"), &#13;
"name" : "John",  &#13;
"address" : {  &#13;
"street" : "77 Main street",  &#13;
"city" : "Springfield" }  &#13;
} &#13;
</pre><p>As you can see, documents in MongoDB are a form of JSON. In this case, the document even contains a subdocument, the address.</p><p>The database itself binary encodes the documents and stores them in a form referred to as BSON. Not to worry, though, you will not have to be concerned about encoding or decoding any of the data yourself, that is all handled behind the scenes.</p><p>One of the main differences between JSON and BSON is that BSON supports a number of data types not supported by JSON. This includes binary data, regular expressions, symbols, dates, and so on. For example, a date may be represented in JSON output as a simple string. However, storing a date as date type in BSON allows efficient date comparisons and operations as part of queries or insertions.</p><p>For the most part, this is not something you'll need to worry about. MongoDB will seamlessly convert the data into usable JSON. However, when we get to Mongoose, data validation will be an important feature that will be handled by middleware.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec100"/>Schemaless</h3></div></div></div><p>One of the features of MongoDB, and some other NoSQL databases, is that it doesn't have a fixed schema.</p><p>In MongoDB, documents are stored in groups called <em>collections</em>. Documents stored in a collection should be related conceptually, but there is no restriction in the database software itself that enforces this. This is in stark contrast to databases where schemas strictly define the data which can be entered into a table.</p><p>There is a danger here that random documents can be placed into any collection making the organization of the collections meaningless. You could insert a document reflecting data for a car into a collection called pets, but this wouldn't make much sense and could render the data in that collection difficult to query meaningfully.</p><p>It bears some thought.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec101"/>Open source</h3></div></div></div><p>MongoDB is an open source database. A number of various licenses apply to the server itself, the drivers, tools, and the documentation.</p><p>Complete licensing information for MongoDB is available at <a class="ulink" href="https://www.mongodb.org/licensing">https://www.mongodb.org/licensing</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec102"/>Why use MongoDB?</h2></div></div></div><p>There are many choices of databases you could use to build a single page web application. For example, MySQL is a popular database for web applications overall. Why would you want to choose MongoDB over something like MySQL?</p><p>Ultimately, almost any database will do the job, but there are certain features in MongoDB that make it particularly attractive for use in SPAs.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec102"/>Well supported</h3></div></div></div><p>MongoDB enjoys wide support on a number of operating systems and platforms. MongoDB has downloads and installers for Windows, multiple flavors of Linux, Mac, and Solaris.</p><p>One of the popular ways to run MongoDB in the cloud is on a <strong>Platform as a Service</strong> (<strong>PaaS</strong>). PaaS is a service, normally provided by a vendor such as Amazon, that allows developers to build web applications in the cloud without the hassle of managing infrastructure. MongoDB maintains a list of supported platforms at <a class="ulink" href="https://docs.mongodb.org/ecosystem/platforms/">https://docs.mongodb.org/ecosystem/platforms/</a>.</p><p>MongoDB is supported in many popular languages. A quick visit to MongoDB's drivers page at <a class="ulink" href="https://docs.mongodb.org/ecosystem/drivers/">https://docs.mongodb.org/ecosystem/drivers/</a> shows that, as of the time of writing this book, MongoDB has supported drivers for C, C++, C#, Java, Node.js, Perl, PHP, Python, Motor, Ruby, and Scala. Additionally, community-supported drivers for Go and Erlang, undoubtedly, may will be on the way.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec103"/>Data model</h3></div></div></div><p>Because MongoDB's data model is based on JSON, it is ideal for use in web applications. JSON output can be consumed directly through frontend JavaScript and JavaScript frameworks such as AngularJs and others.</p><p>Because JSON is an object-oriented data format, the data works well with languages that are object-oriented themselves. The data structures can be modeled in the software you're writing very easily.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec104"/>Popularity</h3></div></div></div><p>As a developer, the popularity of the tools you are using is relatively important. For one thing, unpopular frameworks don't get the attention from development communities that popular ones get. Using a popular open source tool ensures that there is active development going on.</p><p>This extends to things such as books and learning resources, platform availability, and language support.</p><p>Popularity can also be an indication of quality or, at least, the quality of fit for popular types of applications. MongoDB has become very popular in <strong>Big Data</strong> circles, where unstructured data is the bread and butter or day-to-day operation. However, MongoDB really shines when it comes to some of the most popular types of web applications - such as CMS and geo-spatial data.</p><p>MongoDB is extremely popular. According to the 2015 press release from MongoDB (<a class="ulink" href="https://www.mongodb.com/press/mongodb-overtakes-postgresql-4-most-popular-dbms-db-engines-ranking">https://www.mongodb.com/press/mongodb-overtakes-postgresql-4-most-popular-dbms-db-engines-ranking</a>), MongoDB has surpassed PostgreSQL as the fourth most popular database. As of the press release, it was the only non-relational database in the top five. According to the same release, MongoDB has grown over 160% in popularity over the previous 2 years.</p><p>MongoDB is being used more and more in much wider places than many other databases. All indications are that it is going to be around, and be supported on all of the most popular platforms, for a long time.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Commanding MongoDB</h1></div></div></div><p>MongoDB comes with an interactive shell, which we have already used briefly in the previous chapter. To refresh your memory, after starting the MongoDB daemon by typing <code class="literal">mongod</code>, you access the shell in a separate terminal window by typing <code class="literal">mongo</code>.</p><p>Primarily, you will be accessing MongoDB using native code in your application. However, understanding the MongoDB shell is invaluable to using it. There will be times when you want to access the shell directly, particularly for debugging. You may also need to manage a MongoDB instance in the cloud.</p><p>You should have a good grasp of the MongoDB shell.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec103"/>Getting information</h2></div></div></div><p>One of the most important things you can do in the MongoDB shell is to manage your databases. Getting <em>meta</em> information out of MongoDB is most easily accomplished using shell commands. The following are some of the basic commands you can use in the MongoDB shell to get information.</p><p>
<code class="literal">help</code> - This will output a list of basic commands available in the MongoDB shell. For help with methods that operate on a database, you will use the <code class="literal">db.help()</code> method. Typing help into the MongoDB shell outputs the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">db.help()</code>: Help on db methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">db.mycoll.help()</code>: Help on collection methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">sh.help()</code>: Sharding helpers</li><li class="listitem" style="list-style-type: disc"><code class="literal">rs.help()</code>: Replica set helpers</li><li class="listitem" style="list-style-type: disc"><code class="literal">help admin</code>: Administrative help</li><li class="listitem" style="list-style-type: disc"><code class="literal">help connect</code>: Connecting to a db help</li><li class="listitem" style="list-style-type: disc"><code class="literal">help keys</code>: Key shortcuts</li><li class="listitem" style="list-style-type: disc"><code class="literal">help misc</code>: Misc things to know</li><li class="listitem" style="list-style-type: disc"><code class="literal">help mr</code>: Mapreduce</li><li class="listitem" style="list-style-type: disc"><code class="literal">show dbs</code>: Show database names</li><li class="listitem" style="list-style-type: disc"><code class="literal">show collection</code>s: Show collections in current database</li><li class="listitem" style="list-style-type: disc"><code class="literal">show users</code>: Show users in current database</li><li class="listitem" style="list-style-type: disc"><code class="literal">show profile</code>: Show most recent system.profile entries with time <em>s&gt;= 1 m</em></li><li class="listitem" style="list-style-type: disc"><code class="literal">show logs</code>: Show accessible logger names</li><li class="listitem" style="list-style-type: disc"><code class="literal">show log [name]</code>: Prints out last segment of log in memory; <code class="literal">global</code> is default</li><li class="listitem" style="list-style-type: disc"><code class="literal">use &lt;db_name&gt;</code>: Set current database</li><li class="listitem" style="list-style-type: disc"><code class="literal">db.foo.find()</code>: List objects in the <code class="literal">foo</code> collection</li><li class="listitem" style="list-style-type: disc"><code class="literal">db.foo.find( { a : 1 } )</code>: List objects in foo where a == 1</li><li class="listitem" style="list-style-type: disc"><code class="literal">it</code>: Result of the last line evaluated; use to further iterate</li><li class="listitem" style="list-style-type: disc"><code class="literal">DBQuery.shellBatchSize = x</code>: Set default number of items to display on shell</li><li class="listitem" style="list-style-type: disc"><code class="literal">exit</code>: Quit Mongo shell</li></ul></div><p>Some of the most important commands for gathering info from a database are the commands that begin with <code class="literal">show</code>. For example, <code class="literal">showdbs</code> will give you a list of the currently accessible database names on the system. <code class="literal">showcollections</code> will list the collections in the current database.</p><p>One thing that isn't listed here is a method for retrieving the database on which you are currently operating. To do that, simply type <code class="literal">db</code> and the shell will output the name of the current database.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec104"/>Inserting and updating data</h2></div></div></div><p>In the last chapter, we inserted some records using the insert method. You're going to do that a little differently here so that you can set up and load some data into your <code class="literal">giftapp</code> database, one that we created in the last chapter for the SPA you're building.</p><p>We're going to use two methods to insert data that you haven't used yet. One will be to execute a JavaScript file in the MongoDB shell which will set up and execute commands. We'll use this to insert some documents. The other method we'll use is a bulk operation that will allow us to set up some data and then execute and bulk insert it.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec105"/>Running scripts in the MongoDB shell</h3></div></div></div><p>The MongoDB shell allows you to load and execute JavaScript files. In your <code class="literal">giftapp</code> directory, create a new folder called <code class="literal">scripts</code> and create a JavaScript file called <code class="literal">db-init.js</code>:</p><pre class="programlisting">db = db.getSiblingDB('giftapp'); &#13;
 &#13;
var user1 = {firstName:"Mark", lastName:"Smith",       email:"msmith@xyzzymail.org"}; &#13;
 &#13;
var user2 = {firstName:"Sally", lastName:"Jones", email:"sjones@xyzzymail.org"}; &#13;
 &#13;
var users = [user1, user2]; &#13;
 &#13;
db.users.insert(users); &#13;
</pre><p>The first line, <code class="literal">db=db.getSiblingDB('giftapp'),</code> tells the MongoDB shell which database to work with in case you haven't already selected the <code class="literal">giftapp</code> database in some way. We need to use this method because the <code class="literal">use</code> command isn't valid JavaScript.</p><p>Next, you create two objects, <code class="literal">user1</code> and <code class="literal">user2</code>, using JavaScript object literal notations. These objects represent user data for the users' <code class="literal">Mark Smith</code> and <code class="literal">Sally Jones</code>. You then create an array called users that contains the two user objects.</p><p>Next, we invoke the <code class="literal">insert</code> method on the users collection and pass it the users array. If there is no users collection in the <code class="literal">giftapp</code> database, one will be created when we execute this script.</p><p>Note that when an array is passed to the insert method, MongoDB will insert each document separately. This is a powerful feature allowing for easy and efficient multiple document inserts.</p><p>There are two ways we can load and execute this script.</p><p>From the command-line in a terminal not running the MongoDB shell, navigate to the directory where the script is stored and type the following:</p><pre class="programlisting">
<strong>$ mongo localhost:27017/test db-init.js</strong>
<strong>MongoDB shell version: 3.0.4</strong>
<strong>connecting to: localhost:27017/test</strong>
</pre><p>Unfortunately, there won't be any really useful output to tell you that the inserts were completed. If you start the MongoDB shell, or use a terminal where it's already running, you can verify by doing the following:</p><pre class="programlisting">
<strong>&gt; db.users.count()</strong>
<strong>2</strong>
<strong>&gt; db.users.find()</strong>
<strong>{ "_id" : ObjectId("566dcc5b65d385d7fa9652e3"), "firstName" : "Mark", "lastName" : "Smith", "email" : "msmith@xyzzymail.org" }</strong>
<strong>{ "_id" : ObjectId("566dcc5b65d385d7fa9652e4"), "firstName" : "Sally", "lastName" : "Jones", "email" : "sjones@xyzzymail.org" }</strong>
</pre><p>The count method returns the number of documents in a collection. Here, there are two. We've already explored the find method. Here we invoke find with no arguments, which returns all the documents in the collection. You can see that <code class="literal">Mark</code> and <code class="literal">Sally</code> are now documents stored separately in the users collection.</p><p>If you run this script multiple times, it will create numerous <code class="literal">Mark</code> and <code class="literal">Sally</code> documents. If you want to clean out the collection and start over, you can use the drop method and verify using the following command:</p><pre class="programlisting">
<strong>&gt; db.users.drop()</strong>
<strong>true</strong>
<strong>&gt; db.users.count()</strong>
<strong>0</strong>
<strong>&gt; db.users.find()</strong>
<strong>&gt;</strong>
</pre><p>I promised you a second method of running scripts, and we'll get to that. Let's make a small modification to the script first:</p><pre class="programlisting">db = db.getSiblingDB('giftapp'); &#13;
var now = new Date(); &#13;
 &#13;
var user1 = {firstName:"Mark", lastName:"Smith", email:"msmith@xyzzymail.org", created: now}; &#13;
var user2 = {firstName:"Sally", lastName:"Jones", email:"sjones@xyzzymail.org", created: now}; &#13;
 &#13;
var users = [user1, user2]; &#13;
 &#13;
db.users.insert(users); &#13;
</pre><p>We added a variable called <code class="literal">now</code> that contains a new <code class="literal">Date</code> object. Creating a <code class="literal">Date</code> object in this way sets the date and time in the object to the current date and time. Next, we add a field called <code class="literal">created</code> to <code class="literal">Mark</code> and <code class="literal">Sally</code>, and give it the value of now, our date object.</p><p>In a terminal running the MongoDB shell, do the following:</p><pre class="programlisting">
<strong>&gt; db.users.drop()</strong>
<strong>true</strong>
<strong>&gt; db.users.count()</strong>
<strong>0</strong>
<strong>&gt; load('/[path to your directory]/giftapp/scripts/db-init.js')</strong>
<strong>true</strong>
<strong>&gt; db.users.count()</strong>
<strong>2</strong>
<strong>&gt; db.users.find()</strong>
<strong>{ "_id" : ObjectId("566dd0cb1c09d090fd36ba83"), "firstName" : "Mark", "lastName" : "Smith", "email" : "msmith@xyzzymail.org", "created" : ISODate("2015-12-13T20:10:51.336Z") }</strong>
<strong>{ "_id" : ObjectId("566dd0cb1c09d090fd36ba84"), "firstName" : "Sally", "lastName" : "Jones", "email" : "sjones@xyzzymail.org", "created" : ISODate("2015-12-13T20:10:51.336Z") }</strong>
</pre><p>Here, we use the load method to run the script, passing it the path to the script. We see that the two users have been added to the collection, and the find method retrieves their documents.</p><p>If you look at the created field on <code class="literal">Mark</code> and <code class="literal">Sally</code> documents you'll see something new. The <code class="literal">Date</code> may look a little different. Internally, MongoDB stores dates as a 64-bit integer representing the number of milliseconds since January 1st, 1970. Negative numbers are used to represent dates before that.</p><p>Storing dates and times as integers likes this, instead of strings, allows things such as date calculations and comparisons.</p><p>Fortunately, MongoDB outputs dates in a somewhat usable and readable format. We will explore displaying dates in a more human friendly way in a later chapter.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec106"/>Running bulk operations</h3></div></div></div><p>Another way to insert multiple documents into a MongoDB collection in a single pass is to use MongoDB's <code class="literal">Bulk</code> API. This allows us to set up a list of ordered or unordered operations and then run them all when we choose to execute We can experiment with this using the MongoDB shell commands.</p><p>Take a look at the following commands:</p><pre class="programlisting">
<strong>&gt; var bulk = db.users.initializeUnorderedBulkOp()</strong>
<strong>&gt; bulk.insert(</strong>
<strong>... { firstname: "John",</strong>
<strong>... lastname: "Smith",</strong>
<strong>... email: "jiggy@zzxxyy3.com",</strong>
<strong>... created: new Date()</strong>
<strong>... }</strong>
<strong>... );</strong>
<strong>&gt; bulk.insert(</strong>
<strong>... { firstname: "Jane",</strong>
<strong>... lastname: "Smothers",</strong>
<strong>... email: "janes@zzxxyy3.com",</strong>
<strong>... created: new Date()</strong>
<strong>... }</strong>
<strong>... );</strong>
<strong>&gt; bulk.execute()</strong>
<strong>BulkWriteResult({</strong>
<strong>  "writeErrors" : [ ],</strong>
<strong>  "writeConcernErrors" : [ ],</strong>
<strong>  "nInserted" : 2,</strong>
<strong>  "nUpserted" : 0,</strong>
<strong>  "nMatched" : 0,</strong>
<strong>  "nModified" : 0,</strong>
<strong>  "nRemoved" : 0,</strong>
<strong>  "upserted" : [ ]</strong>
<strong>})</strong>
</pre><p>In the first line, we opened up an unordered bulk operation on users and assigned it to the variable called <code class="literal">bulk</code>. We could also have made that an ordered operation, but we don't currently care about the order in which the inserts are executed.</p><p>We then add two <code class="literal">insert</code> commands to the bulk operation, one for <code class="literal">John Smith</code>, and another for <code class="literal">Jane Smothers</code>. We can then call execute on the <code class="literal">bulk</code> operation. The returned value tells us that there were no errors and that two documents were inserted.</p><p>Let's have a look at our collection now:</p><pre class="programlisting">
<strong>&gt; db.users.find().pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba83"),</strong>
<strong>  "firstName" : "Mark",</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "email" : "msmith@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba84"),</strong>
<strong>  "firstName" : "Sally",</strong>
<strong>  "lastName" : "Jones",</strong>
<strong>  "email" : "sjones@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba85"),</strong>
<strong>  "firstname" : "John",</strong>
<strong>  "lastname" : "Smith",</strong>
<strong>  "email" : "jiggy@zzxxyy3.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:26:42.165Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba86"),</strong>
<strong>  "firstname" : "Jane",</strong>
<strong>  "lastname" : "Smothers",</strong>
<strong>  "email" : "janes@zzxxyy3.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:28:00.383Z")</strong>
<strong>}</strong>
</pre><p>I added the <code class="literal">pretty</code> method to the end of the <code class="literal">find</code> method in order to tidy up our output and make it a bit more readable. As you can see, <code class="literal">John</code> and <code class="literal">Jane</code> have been added to our collection.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec105"/>Finding, modifying, and removing data</h2></div></div></div><p>Queries are how we search for and return data out of our database. We've been using queries all along every time we have used the <code class="literal">find</code> method. We know that find, on its own, will return every single document in a collection. That's not exactly useful.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec107"/>Specific results</h3></div></div></div><p>Generally, we want to query a collection and return specific results. We want only those states that export peanuts, or we want a list of customers who live in France.</p><p>To specify that we want documents where a specific field matches a specific value, we do this:</p><pre class="programlisting">
<strong>&gt; db.users.find({lastname:"Smith"}).pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba85"),</strong>
<strong>  "firstname" : "John",</strong>
<strong>  "lastname" : "Smith",</strong>
<strong>  "email" : "jiggy@zzxxyy3.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:26:42.165Z")</strong>
<strong>}</strong>
</pre><p>Here, I've called the find operation and passed it an object with a single field: <code class="literal">lastname</code>. This is called the criteria. The value of that field is <code class="literal">Smith</code>. As you can see this returned the record for <code class="literal">John Smith</code>. For more than one field, you would separate the fields by commas.</p><p>Wait a minute, shouldn't I also see the document for <code class="literal">Mark Smith</code>? If you look carefully, the documents for <code class="literal">Mark Smith</code> and <code class="literal">Sally Jones</code> camelcase <code class="literal">firstName</code> and <code class="literal">lastName</code>. That is, the <code class="literal">N</code> is a capital letter. Therefore, MongoDB doesn't see this as the same field.</p><p>This is a good illustration of one of the dangers of schemaless databases, and something to keep in mind. We will fix this in the section on updates.</p><p>Let's say that we want to get documents for users with <code class="literal">lastName</code> fields matching <code class="literal">Smith</code> or <code class="literal">Jones</code>. There are a couple of ways you could write this query, but the best way when comparing the same field is to use the <code class="literal">$in</code> operator, as shown in the following commands:</p><pre class="programlisting">
<strong>&gt; db.users.find({lastName: { $in: ['Jones', 'Smith']}}).pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba83"),</strong>
<strong>  "firstName" : "Mark",</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "email" : "msmith@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba84"),</strong>
<strong>  "firstName" : "Sally",</strong>
<strong>  "lastName" : "Jones",</strong>
<strong>  "email" : "sjones@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec108"/>Query operators</h3></div></div></div><p>MongoDB comes with a number of operators that all begin with the dollar sign. They are used for modifying and comparing within query criteria.</p><p>There are a number of types of query operators that include comparison operators such as <code class="literal">$eq</code>: equal to, <code class="literal">$gt</code>: greater than, and <code class="literal">$lte</code>: less than or equal to. Here's an example:</p><pre class="programlisting">
<strong>&gt; db.users.find({payrate: {$gt: 45}})</strong>
</pre><p>This would return all documents in the <code class="literal">users</code> collection that had a <code class="literal">payrate</code> field with a value greater than <code class="literal">45</code>.</p><p>Logical operators include <code class="literal">$or</code>, <code class="literal">$and</code>, <code class="literal">$not</code>, and <code class="literal">$nor</code>. Each of these behaves like you'd expect if you're used to logical operators. Here's an example:</p><pre class="programlisting">
<strong>db.find({$and: [{firstName: "Steve"},{lastName: "Smith"}]})</strong>
</pre><p>This query returns all documents that have a <code class="literal">firstName</code> field equal to <code class="literal">Steve</code> and a <code class="literal">lastName</code> field equal to <code class="literal">Smith</code>.</p><p>MongoDB includes two element operators: <code class="literal">$exists</code>: to check if a field exists, and <code class="literal">$type</code>: to check the type of a specified file. Take a look at the following command:</p><pre class="programlisting">
<strong>&gt; db.users.find({car: { $exists: true })</strong>
</pre><p>This query returns all documents in the <code class="literal">users</code> collection that have a <code class="literal">car</code> field.</p><p>MongoDB includes a number of other operators. These include things such as <code class="literal">regex</code> matching and geospatial comparison. There are also operators comparing arrays.</p><p>For a more complete list of operators, see the MongoDB documentation on operators at <a class="ulink" href="https://docs.mongodb.org/v3.0/reference/operator/query/">https://docs.mongodb.org/v3.0/reference/operator/query/</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec109"/>Projections</h3></div></div></div><p>We covered projections briefly in the previous chapter but, to refresh your memory, a projection specifies the fields returned in a query. We don't always want all of the fields in the documents that we return, so a projection lets us limit the data to the fields we are interested in.</p><p>Projections will be the second argument to the find method, as shown in the following commands:</p><pre class="programlisting">
<strong>&gt; db.users.find({},{ email: 1 })</strong>
<strong>{ "_id" : ObjectId("566dd0cb1c09d090fd36ba83"), "email" : &#13;
      "msmith@xyzzymail.org" }</strong>
<strong>{ "_id" : ObjectId("566dd0cb1c09d090fd36ba84"), "email" : &#13;
      "sjones@xyzzymail.org" }</strong>
<strong>{ "_id" : ObjectId("566dff161c09d090fd36ba85"), "email" : &#13;
      "jiggy@zzxxyy3.com" }</strong>
<strong>{ "_id" : ObjectId("566dff161c09d090fd36ba86"), "email" : "janes@zzxxyy3.com"&#13;
    }</strong>
</pre><p>We specified that we wanted all documents in the collection by passing an empty object as the first argument to find. Then, we used a projection to tell MongoDB that we wanted to see the <code class="literal">email</code> field.</p><p>You'll notice that the <code class="literal">_id</code> field is returned in the results. This is a default. To suppress that, we give it a value of <code class="literal">0</code> in the find in the projection as shown in the following command:</p><pre class="programlisting">
<strong>&gt; db.users.find({},{ email: 1, _id: 0 })</strong>
<strong>{ "email" : "msmith@xyzzymail.org" }</strong>
<strong>{ "email" : "sjones@xyzzymail.org" }</strong>
<strong>{ "email" : "jiggy@zzxxyy3.com" }</strong>
<strong>{ "email" : "janes@zzxxyy3.com" }</strong>
</pre><p>In this query, <code class="literal">email</code> is included, while <code class="literal">_id</code> is excluded.</p><p>There are also a number of projection operators. You can find the details for those in the MongoDB documentation at <a class="ulink" href="https://docs.mongodb.org/v3.0/reference/operator/query/">https://docs.mongodb.org/v3.0/reference/operator/query/</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec110"/>Query modifiers</h3></div></div></div><p>As the name implies, query modifiers are used to modify the data coming back from a query. This includes doing things such as sorting, or returning a maximum number of results.</p><p>There are two forms of modifiers in Mongo DB (I prefer the first). Take a look at the following commands:</p><pre class="programlisting">
<strong>db.collection.find( { &lt;query&gt; } )._addSpecial( &lt;option&gt; )</strong>
<strong>db.collection.find( { $query: { &lt;query&gt; }, &lt;option&gt; } )</strong>
</pre><p>Let me illustrate with an example:</p><pre class="programlisting">
<strong>&gt; db.users.find({},{ email:1, _id:0 }).sort({ email:1 })</strong>
<strong>{ "email" : "janes@zzxxyy3.com" }</strong>
<strong>{ "email" : "jiggy@zzxxyy3.com" }</strong>
<strong>{ "email" : "msmith@xyzzymail.org" }</strong>
<strong>{ "email" : "sjones@xyzzymail.org" }</strong>
</pre><p>Here, I am selecting all documents in the users collection. I am returning only the <code class="literal">email</code> field (and suppressing the <code class="literal">_id</code> field). I am then sorting by ascending order by <code class="literal">email</code>. If we wanted to sort the documents by the <code class="literal">email</code> field in descending order, we would make the value in the modifier <code class="literal">-1</code>, as shown in the following commands:</p><pre class="programlisting">
<strong>&gt; db.users.find({},{ email:1, _id:0 }).sort({ email:-1 })</strong>
<strong>{ "email" : "sjones@xyzzymail.org" }</strong>
<strong>{ "email" : "msmith@xyzzymail.org" }</strong>
<strong>{ "email" : "jiggy@zzxxyy3.com" }</strong>
<strong>{ "email" : "janes@zzxxyy3.com" }</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec111"/>Modifying data</h3></div></div></div><p>To modify MongoDB documents, you generally use the <code class="literal">update</code> method.</p><p>Take a look at following commands:</p><pre class="programlisting">
<strong>&gt; db.users.find({lastname:"Smothers"}).pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba86"),</strong>
<strong>  "firstname" : "Jane",</strong>
<strong>  "lastname" : "Smothers",</strong>
<strong>  "email" : "janes@zzxxyy3.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:28:00.383Z")</strong>
<strong>}</strong>
<strong>&gt; db.users.update({lastname:"Smothers"},{$set:{ &#13;
     email:"jsmothers@xxaayy4.com"}})</strong>
<strong>WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })</strong>
<strong>&gt; db.users.find({lastname:"Smothers"}).pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba86"),</strong>
<strong>  "firstname" : "Jane",</strong>
<strong>  "lastname" : "Smothers",</strong>
<strong>  "email" : "jsmothers@xxaayy4.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:28:00.383Z")</strong>
<strong>}</strong>
</pre><p>Here, we do a find just to display the document for <code class="literal">Jane Smothers</code>. We want to change the e-mail address of <code class="literal">Jane</code>, so we use the <code class="literal">update</code> method. The first argument to the <code class="literal">update</code> method is the same criteria used in the find method to select a document or set of documents. The second argument is the instruction for the update.</p><p>Here, we've used the <code class="literal">$set</code> operator to change the e-mail address. If there wasn't an <code class="literal">email</code> field in the document, the <code class="literal">$set</code> operator would create a new field.</p><p>It's important to note that update, by default, will only update a single document. To update multiple documents, you set a multi option as part of a third option to update.</p><p>Let's fix our users collection to make the fields for <code class="literal">firstname</code> and <code class="literal">lastname</code> into camelcase:</p><pre class="programlisting">
<strong>&gt; db.users.update({ lastname: { $exists: true }}, {$rename:&#13;
      {'lastname':'lastName','firstname':'firstName'}}, { multi: true })</strong>
<strong>WriteResult({ "nMatched" : 2, "nUpserted" : 0, "nModified" : 2 })</strong>
<strong>&gt; db.users.find().pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba83"),</strong>
<strong>  "firstName" : "Mark",</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "email" : "msmith@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba84"),</strong>
<strong>  "firstName" : "Sally",</strong>
<strong>  "lastName" : "Jones",</strong>
<strong>  "email" : "sjones@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba85"),</strong>
<strong>  "email" : "jiggy@zzxxyy3.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:26:42.165Z"),</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "firstName" : "John"</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba86"),</strong>
<strong>  "email" : "jsmothers@xxaayy4.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:28:00.383Z"),</strong>
<strong> "lastName" : "Smothers",</strong>
<strong>  "firstName" : "Jane"</strong>
<strong>}</strong>
</pre><p>The first argument to the <code class="literal">update</code> method uses the <code class="literal">$exists</code> operator to select any documents without the camelcase <code class="literal">lastname</code> field. The second argument uses the <code class="literal">$rename</code> operator to change both <code class="literal">firstname</code> and <code class="literal">lastname</code> field names to camelcase. The final argument sets the multi option to <code class="literal">true</code>, telling MongoDB to update all of the matched documents.</p><p>The result shows us that two documents were matched and two documents were updated. Running the <code class="literal">find</code> method shows us that all documents now have the same field names.</p><p>By default, if the query part of the <code class="literal">update</code> method doesn't match any documents, MongoDB doesn't do anything. We can tell MongoDB to create a new document if none are matched using the <code class="literal">upsert</code> option:</p><pre class="programlisting">
<strong>&gt; db.users.update(</strong>
<strong>... { email: "johnny5@fbz22.com"},</strong>
<strong>... {</strong>
<strong>...   firstName: "Johnny",</strong>
<strong>...   lastName: "Fiverton",</strong>
<strong>...   email: "johnny5@zfb22.com",</strong>
<strong>...   created: new Date()</strong>
<strong>... },</strong>
<strong>... { upsert: true })</strong>
<strong>WriteResult({</strong>
<strong>  "nMatched" : 0,</strong>
<strong>  "nUpserted" : 1,</strong>
<strong>  "nModified" : 0,</strong>
<strong>  "_id" : ObjectId("566eaec7fa55252158538298")</strong>
<strong>})</strong>
<strong>&gt; db.users.find().pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba83"),</strong>
<strong>  "firstName" : "Mark",</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "email" : "msmith@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba84"),</strong>
<strong>  "firstName" : "Sally",</strong>
<strong>  "lastName" : "Jones",</strong>
<strong>  "email" : "sjones@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba85"),</strong>
<strong>  "email" : "jiggy@zzxxyy3.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:26:42.165Z"),</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "firstName" : "John"</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba86"),</strong>
<strong>  "email" : "jsmothers@xxaayy4.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:28:00.383Z"),</strong>
<strong>  "lastName" : "Smothers",</strong>
<strong>  "firstName" : "Jane"</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566eaec7fa55252158538298"),</strong>
<strong>  "firstName" : "Johnny",</strong>
<strong>  "lastName" : "Fiverton",</strong>
<strong>  "email" : "johnny5@zfb22.com",</strong>
<strong>  "created" : ISODate("2015-12-14T11:57:59.196Z")</strong>
<strong>}</strong>
</pre><p>Here, we select documents where an <code class="literal">email</code> field matches <code class="literal">johnny5@fbz22.com</code>. As we know, there are no documents matching this query. The second argument to <code class="literal">update</code> lists the data we want to change. Finally, we set the <code class="literal">upsert</code> option to <code class="literal">true</code>.</p><p>The write result shows us that no documents were matched or modified, but that a single document was upserted.</p><p>Invoking find shows us that the record for <code class="literal">Johnny Fiverton</code> has been added.</p><p>You may have noticed that we did not use the <code class="literal">$set</code> operator this time around. If the second argument in update uses no operators, MongoDB will replace the entire document with the data in the second argument. This is something to be careful of; use <code class="literal">$set</code> when you don't want to replace the entire documents.</p><p>A list of <code class="literal">update</code> operators is available in the MongoDB documentation: <a class="ulink" href="https://docs.mongodb.org/v3.0/reference/operator/update/">https://docs.mongodb.org/v3.0/reference/operator/update/</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec112"/>Removing data</h3></div></div></div><p>So far, we have covered the: create, read, and update components of CRUD (create, read, update, delete). The remaining part is deleting documents. For deletion, MongoDB has the <code class="literal">remove</code> method.</p><p>
<code class="literal">Remove</code> has a somewhat familiar signature.</p><p>Take a look at the following commands:</p><pre class="programlisting">
<strong>&gt; db.users.remove({ email: "johnny5@zfb22.com" })</strong>
<strong>WriteResult({ "nRemoved" : 1 })</strong>
<strong>&gt; db.users.find().pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba83"),</strong>
<strong>  "firstName" : "Mark",</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "email" : "msmith@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba84"),</strong>
<strong>  "firstName" : "Sally",</strong>
<strong>  "lastName" : "Jones",</strong>
<strong>  "email" : "sjones@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba85"),</strong>
<strong>  "email" : "jiggy@zzxxyy3.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:26:42.165Z"),</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "firstName" : "John"</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba86"),</strong>
<strong>  "email" : "jsmothers@xxaayy4.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:28:00.383Z"),</strong>
<strong>  "lastName" : "Smothers",</strong>
<strong> "firstName" : "Jane"</strong>
<strong>}</strong>
</pre><p>And it's goodbye <code class="literal">Johnny</code>.</p><p>You can probably surmise that the first argument to remove is the query. Here, we have selected all documents with an <code class="literal">email</code> field matching <code class="literal">johnny5@zfb22.com</code>. In this case, there is only one. The write result tells us that the number of documents removed is one.</p><p>A word of caution: by default, remove will delete all matched documents. If the query is an empty object, remove will delete everything in the collection. The indexes, however, will stay intact. To ensure that you are only removing a single document, you set the <code class="literal">justOne</code> parameter, the second optional argument to remove, to <code class="literal">1,</code> as shown in the following command:</p><pre class="programlisting">
<strong>db.users.remove( { lastName: "Smith" }, 1 )</strong>
</pre><p>This would remove a single <code class="literal">Smith</code> from our users collection.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec106"/>The cursor</h2></div></div></div><p>In MongoDB, the result of invoking <code class="literal">db.collection.find()</code> is actually a <code class="literal">cursor</code>. A <code class="literal">cursor</code> is a pointer to the results of a query. In the MongoDB shell, if you do not assign a <code class="literal">cursor</code> to a variable, the cursor is automatically iterated and output. This is what we have been doing so far:</p><pre class="programlisting">
<strong>&gt; var cursor = db.users.find({},{ email:1, _id: 0 })</strong>
<strong>&gt; cursor</strong>
<strong>{ "email" : "msmith@xyzzymail.org" }</strong>
<strong>{ "email" : "sjones@xyzzymail.org" }</strong>
<strong>{ "email" : "jiggy@zzxxyy3.com" }</strong>
<strong>{ "email" : "janes@zzxxyy3.com" }</strong>
<strong>&gt; cursor</strong>
<strong>&gt;</strong>
</pre><p>Here, we create a variable called <code class="literal">cursor</code> and assign to it the <code class="literal">cursor</code> returned by the <code class="literal">find</code> method. We then manually iterate the <code class="literal">cursor</code> simply by typing its name and hitting <em>Enter</em>. Typing the <code class="literal">cursor</code> name again and hitting <em>Enter</em> does nothing because the <code class="literal">cursor</code> has already been iterated.</p><p>This, in itself, isn't very useful, but we can do all kinds of things with the cursor. For example, if we wanted to put all of our documents into an array we could do this:</p><pre class="programlisting">
<strong>&gt; var cursor = db.users.find({},{ email:1, _id: 0 })</strong>
<strong>&gt; var myDocs = cursor.toArray()</strong>
<strong>&gt; myDocs</strong>
<strong>[</strong>
<strong>  {</strong>
<strong>    "email" : "msmith@xyzzymail.org"</strong>
<strong>  },</strong>
<strong>  {</strong>
<strong>    "email" : "sjones@xyzzymail.org"</strong>
<strong>  },</strong>
<strong>  {</strong>
<strong>    "email" : "jiggy@zzxxyy3.com"</strong>
<strong>  },</strong>
<strong>  {</strong>
<strong>    "email" : "janes@zzxxyy3.com"</strong>
<strong>  }</strong>
<strong>]</strong>
</pre><p>MongoDB offers a ton of built-in cursor methods. Documentation for MongoDB JavaScript cursor methods can be found at: <a class="ulink" href="https://docs.mongodb.org/manual/reference/method/#js-query-cursor-methods">https://docs.mongodb.org/manual/reference/method/#js-query-cursor-methods</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Incorporating MongoDB into the SPA</h1></div></div></div><p>All this command-line stuff is great, but we need to start incorporating our MongoDB database into our SPA. In a future chapter, we will introduce the <code class="literal">mongoose</code> plugin for node, which will allow us to do data modeling, and which will perform a lot of heavy lifting for us.</p><p>For now, we're going to add a connection to MongoDB into our SPA in a simple way, which will highlight how to incorporate our database and display some dynamic data.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec107"/>Adding the NPM modules</h2></div></div></div><p>For this chapter, we need two modules to connect and easily access our MongoDB database inside our Express application. Those modules are <code class="literal">mongodb</code> and <code class="literal">monk</code>.</p><p>In your terminal, navigate to your <code class="literal">giftapp</code> directory and type the following (remember to lead with <code class="literal">sudo</code> if you're on a Mac or Linux):</p><pre class="programlisting">
<strong>npm install mongodb --save</strong>
<strong>...</strong>
<strong>npm install monk -save</strong>
</pre><p>The dependencies section of your <code class="literal">package.json</code> file should now look something like this:</p><pre class="programlisting">"dependencies": { &#13;
    "body-parser": "~1.13.2", &#13;
    "cookie-parser": "~1.3.5", &#13;
    "debug": "~2.2.0", &#13;
    "ejs": "~2.3.3", &#13;
    "express": "~4.13.1", &#13;
    "mongodb": "^2.1.1", &#13;
    "monk": "^1.0.1", &#13;
    "morgan": "~1.6.1", &#13;
    "serve-favicon": "~2.3.0" &#13;
  } &#13;
</pre></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec108"/>Adding MongoDB into the main application</h2></div></div></div><p>Next, we need to make our MongoDB database accessible inside the main application. We're going to add a few lines to our <code class="literal">app.js</code> file:</p><pre class="programlisting">var express = require('express'); &#13;
var path = require('path'); &#13;
var favicon = require('serve-favicon'); &#13;
var logger = require('morgan'); &#13;
var cookieParser = require('cookie-parser'); &#13;
var bodyParser = require('body-parser'); &#13;
 &#13;
<strong>//Database stuff</strong>
<strong>var mongodb = require('mongodb');</strong>
<strong>var monk = require('monk');</strong>
<strong>var db = monk('localhost:27017/giftapp')</strong> &#13;
 &#13;
var routes = require('./routes/index'); &#13;
var users = require('./routes/users'); &#13;
 &#13;
var app = express(); &#13;
 &#13;
// view engine setup &#13;
app.set('views', path.join(__dirname, 'views')); &#13;
app.set('view engine', 'ejs'); &#13;
 &#13;
// uncomment after placing your favicon in /public &#13;
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))); &#13;
app.use(logger('dev')); &#13;
app.use(bodyParser.json()); &#13;
app.use(bodyParser.urlencoded({ extended: false })); &#13;
app.use(cookieParser()); &#13;
app.use(express.static(path.join(__dirname, 'public'))); &#13;
 &#13;
<strong>//Database middleware</strong>
<strong>app.use(function(req,res,next){</strong>
<strong>    req.db = db;</strong>
<strong>    next();</strong>
<strong>});</strong> &#13;
 &#13;
app.use('/', routes); &#13;
app.use('/users', users); &#13;
 &#13;
// catch 404 and forward to error handler &#13;
app.use(function(req, res, next) { &#13;
  var err = new Error('Not Found'); &#13;
  err.status = 404; &#13;
  next(err); &#13;
}); &#13;
 &#13;
// error handlers &#13;
 &#13;
// development error handler &#13;
// will print stacktrace &#13;
if (app.get('env') === 'development') { &#13;
  app.use(function(err, req, res, next) { &#13;
    res.status(err.status || 500); &#13;
    res.render('error', { &#13;
      message: err.message, &#13;
      error: err &#13;
    }); &#13;
  }); &#13;
} &#13;
 &#13;
// production error handler &#13;
// no stacktraces leaked to user &#13;
app.use(function(err, req, res, next) { &#13;
  res.status(err.status || 500); &#13;
  res.render('error', { &#13;
    message: err.message, &#13;
    error: {} &#13;
  }); &#13;
}); &#13;
 &#13;
 &#13;
module.exports = app; &#13;
</pre><p>In the first highlighted section, we load the <code class="literal">mongodb</code> and <code class="literal">monk</code> modules using the require method. We then instantiate the database connection by invoking <code class="literal">monk</code> and assigning the connection to the variable <code class="literal">db</code>.</p><p>Next, we write a small piece of middleware. Note that it's important that this middleware shows up before the routing middleware. The middleware attaches the database connection to the request object and then passes it on to the next middleware by invoking the next function.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec109"/>Writing a query</h2></div></div></div><p>Now let's get some data out of your database and displayed onto the browser. For that, we need to add a new route. Open up your <code class="literal">routes/users.js</code> file and we'll add a few lines:</p><pre class="programlisting">var express = require('express'); &#13;
var router = express.Router(); &#13;
 &#13;
/* GET users listing. */ &#13;
router.get('/', function(req, res, next) { &#13;
  res.send('respond with a resource'); &#13;
}); &#13;
 &#13;
<strong>router.get('/show', function(req, res, next)&#13;
 {&#13;
</strong>
<strong>    var db = req.db;&#13;
</strong>
<strong>    var collection = db.get('users');&#13;
</strong>
<strong>    collection.find({},{},function(err,docs)&#13;
{</strong>
<strong>        &#13;
if(!err)&#13;
{</strong>
<strong>            &#13;
           res.json(docs);&#13;
</strong>
<strong>        }&#13;
else&#13;
{&#13;
</strong>
<strong>            res.send('error');&#13;
</strong>
<strong>        }&#13;
</strong>
<strong>    });&#13;
</strong>
<strong>});</strong> &#13;
 &#13;
module.exports = router; &#13;
</pre><p>We will cover Express routing in depth in a later chapter, but what we've done here is create a new router for the <code class="literal">/show</code> path after <code class="literal">/users</code>. We've aliased the database from the request object and set the collection we're interested in using the monk <code class="literal">get</code> method.</p><p>We then call the <code class="literal">monk</code> find method on the collection, passing an empty query. We know from our command-line experiments that an empty query should return all records in the collection.</p><p>The last argument to find here is a <code class="literal">callback</code> function, which is executed when the query returns. The first argument to this function receives an error if the query results in an error. The second argument receives the documents returned from the query.</p><p>We check to make sure there's no error, and if there isn't, we output the documents using the response object's <code class="literal">json</code> function. As the name implies, the output is returned to the browser as JSON.</p><p>Ensure that your MongoDB daemon is still running, or restart it in a terminal window. In another terminal window, navigate to your <code class="literal">giftapp</code> directory and type <code class="literal">npm start</code> to start up your server.</p><p>Navigating to <code class="literal">localhost:3000/users/show</code> in your browser will display something like this:</p><pre class="programlisting">[{"_id":"566dd0cb1c09d090fd36ba83","firstName":"Mark","lastName":"Smith","email":"msmith@xyzzymail.org","created":"2015-12-13T20:10:51.336Z"},{"_id":"566dd0cb1c09d090fd36ba84","firstName":"Sally","lastName":"Jones","email":"sjones@xyzzymail.org","created":"2015-12-13T20:10:51.336Z"},{"_id":"566dff161c09d090fd36ba85","email":"jiggy@zzxxyy3.com","created":"2015-12-13T23:26:42.165Z","lastName":"Smith","firstName":"John"},{"_id":"566dff161c09d090fd36ba86","email":"jsmothers@xxaayy4.com","created":"2015-12-13T23:28:00.383Z","lastName":"Smothers","firstName":"Jane"}] &#13;
</pre><p>It's not pretty, but it is an array that contains all of our documents in JSON format. We could already consume this as a web service, but let's do something a little prettier with it.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec110"/>Displaying data in a page</h2></div></div></div><p>Let's format our data and put it into an HTML page to make it a little nicer to look at. Inside your <code class="literal">views</code> folder, create a new folder called <code class="literal">users</code>. Inside there, create a new file called <code class="literal">show.ejs</code> with the following code in it:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
    &lt;title&gt;Show Users&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
&lt;h1&gt;User List&lt;/h1&gt; &#13;
 &#13;
&lt;table&gt; &#13;
    &lt;thead&gt; &#13;
        &lt;tr&gt; &#13;
 &#13;
            &lt;th&gt;First Name&lt;/th&gt; &#13;
            &lt;th&gt;Last Name&lt;/th&gt; &#13;
            &lt;th&gt;Email Address&lt;/th&gt; &#13;
        &lt;/tr&gt; &#13;
    &lt;/thead&gt; &#13;
    &lt;tbody&gt; &#13;
    &lt;% users.forEach(function(user, index){ -%&gt; &#13;
        &lt;tr&gt; &#13;
            &lt;td&gt;&lt;%= user.firstName %&gt;&lt;/td&gt; &#13;
            &lt;td&gt;&lt;%= user.lastName %&gt;&lt;/td&gt; &#13;
            &lt;td&gt;&lt;%= user.email %&gt;&lt;/td&gt; &#13;
        &lt;/tr&gt; &#13;
    &lt;% }); %&gt; &#13;
    &lt;/tbody&gt; &#13;
&lt;/table&gt; &#13;
 &#13;
 &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>We've created an embedded JavaScript document here that takes a collection of items called <code class="literal">users</code>. We iterate over that using the <code class="literal">forEach</code> function, assigning each instance to a variable called <code class="literal">user</code>.</p><p>For each pass through we create a table row. That table row contains table data elements for the user's first name, last name, and e-mail address.</p><p>This alone won't work; we have to query the database and pass the data to the page. To do that we need to change up the route we just created to render this template and pass the docs we retrieve to it.</p><p>Here are the changes to the <code class="literal">users</code> router file:</p><pre class="programlisting">var express = require('express'); &#13;
var router = express.Router(); &#13;
 &#13;
/* GET users listing. */ &#13;
router.get('/', function(req, res, next) { &#13;
  res.send('respond with a resource'); &#13;
}); &#13;
 &#13;
router.get('/show', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.find({}, {}, function(err,docs){ &#13;
        if(!err){ &#13;
<strong>            //res.json(docs);</strong>
<strong>            res.render('users/show', { users: docs });</strong> &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
 &#13;
module.exports = router; &#13;
</pre><p>The only real change here is that we've commented out the line that sent the results as JSON back to the browser using the response's <code class="literal">json</code> method. Instead, we use the response's render function to choose the <code class="literal">users/show.ejs</code> template, and pass the retrieved docs as a property called <code class="literal">users</code>.</p><p>Now, if you restart the <code class="literal">giftapp</code> server and navigate to <code class="literal">localhost:3000/users/show</code>, you should see this:</p><p>
</p><div><img src="img/image_08_001.jpg" alt="Displaying data in a page"/></div><p>
</p><p>You can see how using Express with MongoDB gives us a lot of ease and flexibility in sending data to the browser. It's a simple thing to send JSON formatted data, and it is also simple to render pages dynamically.</p><p>As we continue to build our SPA, we will rely more on building out web services which will return JSON data.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>MongoDB database performance</h1></div></div></div><p>Topics such as replication and sharding are beyond the scope of this book. However, there are a number of things developers can do to optimize the performance of your MongoDB database.</p><p>Mainly, we'll talk about cover indexing and tuning queries for performance.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec111"/>Indexing</h2></div></div></div><p>In many database systems, adding an <code class="literal">index</code> in a field when appropriate can speed up querying. Queries are optimized when performed on indexed fields. MongoDB is no different.</p><p>The downside to indexes is that they add some extra time to write operations. They also take up extra space in the database. It makes sense to index wisely. When considering adding indexes, you want to think about whether you expect more read than write operations. This would be a plus for adding additional indexes.</p><p>Let's add an index to our user collection. We'll say that we want to frequently look up our users by their last names. It makes sense to add an <code class="literal">index</code> on the <code class="literal">lastname</code> field, as shown in the following commands:</p><pre class="programlisting">
<strong>&gt; db.users.createIndex({lastname:1})</strong>
<strong>{</strong>
<strong>  "createdCollectionAutomatically" : false,</strong>
<strong>  "numIndexesBefore" : 1,</strong>
<strong>  "numIndexesAfter" : 2,</strong>
<strong>  "ok" : 1</strong>
<strong>}</strong>
</pre><p>We use the collection's <code class="literal">createIndex</code> method command passing it an object containing a single field. That field has the key of <code class="literal">lastname</code> with a value of <code class="literal">1</code>. This tells MongoDB that we want to create an index where we store the <code class="literal">lastname</code> fields in the collection in ascending order.</p><p>Internally, this creates a list of all the last names in ascending order, with pointers to the documents. Read operations keyed to the <code class="literal">lastname</code> field are efficient because the MongoDB engine doesn't have to search through every single document in the collection to find matching values, it can just search the list of last names.</p><p>Write operations will be slightly slower, because they will also have to update the <code class="literal">index</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec112"/>Optimizing queries</h2></div></div></div><p>Web application performance can be impacted by slow data read operations. Optimizing database operations can help in scaling operations, but also in perceived performance, enhancing user satisfaction.</p><p>One of the ways developers can significantly impact performance is by optimizing queries. The main methods for reducing the amount of time taken for queries revolve around reducing the amount of data returned and by using indexes to make the lookup more efficient.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec113"/>Using limit</h3></div></div></div><p>The <code class="literal">limit()</code> method, when added to a query, limits the number of records returned in the query. Limiting the number of records returned means less data transfer and thus faster performance and less use of resources.</p><p>Take a look at the following commands:</p><pre class="programlisting">
<strong>&gt; db.users.find().limit(2).pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba83"),</strong>
<strong>  "firstName" : "Mark",</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "email" : "msmith@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba84"),</strong>
<strong>  "firstName" : "Sally",</strong>
<strong>  "lastName" : "Jones",</strong>
<strong>  "email" : "sjones@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
</pre><p>We've added the <code class="literal">limit</code> function here to find with no query, giving it an argument of 2. This tells MongoDB to return two documents, which you can see here.</p><p>Note that we can still add the <code class="literal">pretty()</code> function onto the end by chaining.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec114"/>Using projections</h3></div></div></div><p>We've already discussed projections as a way to limit the number of fields returned per document. Projections are another tool that reduce data transfer, as shown in the following commands:</p><pre class="programlisting">
<strong>&gt; db.users.find({},{email:1,_id:0}).limit(2)</strong>
<strong>{ "email" : "msmith@xyzzymail.org" }</strong>
<strong>{ "email" : "sjones@xyzzymail.org" }</strong>
</pre><p>In this query, we've added a projection to show <code class="literal">email</code> and suppress <code class="literal">_id</code>. We've kept the <code class="literal">limit</code> function. The result is two documents each containing only the <code class="literal">email</code> field.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec115"/>Using hint()</h3></div></div></div><p>Using the <code class="literal">hint()</code> function forces MongoDB to use a particular <code class="literal">index</code> for a query.</p><p>If you remember, we created an <code class="literal">index</code> on the <code class="literal">lastname</code> field of the <code class="literal">users</code> collection earlier. However, this isn't going to help us, since we changed our documents to use the camelCased field name <code class="literal">lastName</code>. Let's have a look:</p><pre class="programlisting">
<strong>db.users.getIndexes()</strong>
<strong>[</strong>
<strong>  {</strong>
<strong>    "v" : 1,</strong>
<strong>    "key" : {</strong>
<strong>      "_id" : 1</strong>
<strong>    },</strong>
<strong>    "name" : "_id_",</strong>
<strong>    "ns" : "giftapp.users"</strong>
<strong>  },</strong>
<strong>  {</strong>
<strong>    "v" : 1,</strong>
<strong>    "key" : {</strong>
<strong>      "lastname" : 1</strong>
<strong>    },</strong>
<strong>    "name" : "lastname_1",</strong>
<strong>    "ns" : "giftapp.users"</strong>
<strong>  }</strong>
<strong>]</strong>
</pre><p>You can see that both <code class="literal">_id</code> and <code class="literal">lastname</code> are indexes. Let's drop <code class="literal">lastname</code> and add <code class="literal">lastName</code>:</p><pre class="programlisting">
<strong>&gt; db.users.dropIndex({ 'lastname':1})</strong>
<strong>{ "nIndexesWas" : 2, "ok" : 1 }</strong>
<strong>&gt; db.users.createIndex({ lastName:1 })</strong>
<strong>{</strong>
<strong>  "createdCollectionAutomatically" : false,</strong>
<strong>  "numIndexesBefore" : 1,</strong>
<strong>  "numIndexesAfter" : 2,</strong>
<strong>  "ok" : 1</strong>
<strong>}</strong>
<strong>&gt; db.users.getIndexes()</strong>
<strong>[</strong>
<strong>  {</strong>
<strong>    "v" : 1,</strong>
<strong>    "key" : {</strong>
<strong>      "_id" : 1</strong>
<strong>    },</strong>
<strong>    "name" : "_id_",</strong>
<strong>    "ns" : "giftapp.users"</strong>
<strong>  },</strong>
<strong>  {</strong>
<strong>    "v" : 1,</strong>
<strong>    "key" : {</strong>
<strong>      "lastName" : 1</strong>
<strong>    },</strong>
<strong>    "name" : "lastName_1",</strong>
<strong>    "ns" : "giftapp.users"</strong>
<strong>  }</strong>
<strong>]</strong>
</pre><p>Now we can execute our query ensuring we use the <code class="literal">lastName</code> index:</p><pre class="programlisting">
<strong>&gt; db.users.find({ lastName: "Smith" }).hint({ lastName:1 }).pretty()</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dd0cb1c09d090fd36ba83"),</strong>
<strong>  "firstName" : "Mark",</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "email" : "msmith@xyzzymail.org",</strong>
<strong>  "created" : ISODate("2015-12-13T20:10:51.336Z")</strong>
<strong>}</strong>
<strong>{</strong>
<strong>  "_id" : ObjectId("566dff161c09d090fd36ba85"),</strong>
<strong>  "email" : "jiggy@zzxxyy3.com",</strong>
<strong>  "created" : ISODate("2015-12-13T23:26:42.165Z"),</strong>
<strong>  "lastName" : "Smith",</strong>
<strong>  "firstName" : "John"</strong>
<strong>}</strong>
</pre></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec116"/>Analyzing performance</h3></div></div></div><p>If you'd like to get into the nitty-gritty of a query, you can use the <code class="literal">explain()</code> method tacked onto a query.</p><p>Take a look at the following commands:</p><pre class="programlisting">
<strong>&gt; db.users.find({},{email:1,_id:0}).limit(2).explain()</strong>
<strong>{</strong>
<strong>  "queryPlanner" : {</strong>
<strong>    "plannerVersion" : 1,</strong>
<strong>    "namespace" : "giftapp.users",</strong>
<strong>    "indexFilterSet" : false,</strong>
<strong>    "parsedQuery" : {</strong>
<strong>      "$and" : [ ]</strong>
<strong>    },</strong>
<strong>    "winningPlan" : {</strong>
<strong>      "stage" : "LIMIT",</strong>
<strong>      "limitAmount" : 2,</strong>
<strong>      "inputStage" : {</strong>
<strong>        "stage" : "PROJECTION",</strong>
<strong>        "transformBy" : {</strong>
<strong>          "email" : 1,</strong>
<strong>          "_id" : 0</strong>
<strong>        },</strong>
<strong>        "inputStage" : {</strong>
<strong>          "stage" : "COLLSCAN",</strong>
<strong>          "filter" : {</strong>
<strong>            "$and" : [ ]</strong>
<strong>          },</strong>
<strong>          "direction" : "forward"</strong>
<strong>        }</strong>
<strong>      }</strong>
<strong>    },</strong>
<strong>    "rejectedPlans" : [ ]</strong>
<strong>  },</strong>
<strong>  "serverInfo" : {</strong>
<strong>    "host" : "Mac-695b35ca77e.local",</strong>
<strong>    "port" : 27017,</strong>
<strong>    "version" : "3.0.4",</strong>
<strong>    "gitVersion" : "nogitversion"</strong>
<strong>  },</strong>
<strong>  "ok" : 1</strong>
<strong>}</strong>
</pre><p>To make sense of the output, consult the MongoDB documentation at <a class="ulink" href="https://docs.mongodb.org/v3.0/reference/explain-results/">https://docs.mongodb.org/v3.0/reference/explain-results/</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Summary</h1></div></div></div><p>MongoDB is a flexible and scalable NoSQL database. It's non-relational, maintaining its records as documents in collections as opposed to rows in tables. MongoDB is schemaless; its collections are flexible and do not enforce a particular data structure.</p><p>MongoDB documents are stored as binary encoded JSON, or BSON. The object-oriented nature of its documents makes MongoDB well suited for use with object-oriented languages such as JavaScript.</p><p>As with all databases, MongoDB offers CRUD operations. Operations on MongoDB are carried out using JavaScript-like syntax.</p><p>Optimizing MongoDB performance as a developer involves reducing the amount of data returned by queries and using indexes well.</p><p>In the next chapter, you will begin handling web requests for your SPA using the Express web application framework.</p></div></body></html>