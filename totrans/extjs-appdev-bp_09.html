<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;A Shopping Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. A Shopping Application</h1></div></div></div><p>In this chapter, we'll design one last application from start to finish. Rather than continuing to introduce new ideas or techniques to visualize and construct an application architecture, we'll double up on the work we've done so far. We'll incorporate routes, view models, and events in order to consolidate everything that's been discussed, and we'll create design documentation to inform the application's structure.</p><p>In each chapter of this book so far, I've tried to stress that there's no "one true way" to application architecture. Every application is different; there is plenty of room for interpretation. At the beginning of the book, we discussed the MVC and MVVM design patterns and what an architect must find is their own pattern (a way of working that feels natural). More than this, a pattern is something that emerges because of a regularity in our work, that is, repeating the same thing again and again. While different architects will have different ways of working and can use different methods in different ways, in the practical chapters, we've completed there is a logical development path that it's easy to fall into.</p><p>"Falling into the pit of success" is a phrase used to describe a methodology that works well without users having to try hard to follow it. That's what we've been working towards. Showing you the choices Ext JS provides, not only giving you options, but also trying to illustrate why they're good options to use. By now, you should have a picture of the design of an Ext JS application and the features you can use to fulfill this design.</p><p>In this final practical chapter, we'll once again see how, despite having a choice in how to implement this application, we'll end up selecting a a path that's similar to the one we took before, a path that feels logical and that makes development easy.</p><div class="section" title="About the app"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec104"/>About the app</h1></div></div></div><p>The application we'll build is <a id="id522" class="indexterm"/>designed to shop on a tablet-sized screen. We'll be taking advantage of the burgeoning "craft beer" scene and creating an application that allows customers to select from categorized beers in the store. Here's the full feature list:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Login and register</li><li class="listitem" style="list-style-type: disc">Category list</li><li class="listitem" style="list-style-type: disc">Product list with sorting</li><li class="listitem" style="list-style-type: disc">Shopping cart</li><li class="listitem" style="list-style-type: disc">Touch-friendly</li></ul></div><p>In other words, the standard set <a id="id523" class="indexterm"/>of features you'd see on a straightforward e-commerce website. The final product looks like this:</p><div class="mediaobject"><img src="graphics/5308OT_09_01.jpg" alt="About the app"/></div><p>We have a simple interface that provides large tappable areas for tablet users. There are more screens in this application than any other we've worked on so far, so let's sketch these out and see what the full app will look like:</p><div class="mediaobject"><img src="graphics/5308OT_09_02.jpg" alt="About the app"/></div><p>Here, we have the <a id="id524" class="indexterm"/>wireframe of the first screen that the user sees when opening the site. As you can see, it maps out the features and layout, as shown in the previous screenshot.</p><p>This mockup mentions all of the main features of the application. Note that, unlike in our earlier e-mail application, the user doesn't have to log in to start browsing. This only happens when they want to place an order.</p><p>The categories of beer are listed on the left-hand side in alphabetical order; the user can scroll through the list when it extends past the bottom of their screen. In the main part of the screen, the beers in the selected category are listed with the sort order determined by a combo box above the list. Each beer on sale is represented by its name, an image, and its price.</p><p>Finally, at the top-right corner of the screen, we have the "login" and "cart buttons" that will change to reflect the application state and are both clickable, revealing further windows.</p><div class="section" title="The product window"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec103"/>The product window</h2></div></div></div><p>This next screen shows the<a id="id525" class="indexterm"/> product detail<a id="id526" class="indexterm"/> page when the user selects a product to view:</p><div class="mediaobject"><img src="graphics/5308OT_09_03.jpg" alt="The product window"/></div><p>This screen fleshes out more of our requirements and the way they'll be implemented. When the user clicks on a product from the list, a modal window pops up showing more information about the product in question, such as a discount message showing price reduction, a full description, the brewery that made the beer, and a tagline that sells beer to the customer. This is all accompanied by a larger image of the product as well as buttons to add the beer to the shopping cart and to close the product window.</p></div><div class="section" title="The shopping cart"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec104"/>The shopping cart</h2></div></div></div><p>At the top-right corner of the <a id="id527" class="indexterm"/>main app screen, we can see a shopping cart icon and <a id="id528" class="indexterm"/>a label that changes to reflect the number of items in the cart. When the user clicks on the icon or label, the cart window is shown:</p><div class="mediaobject"><img src="graphics/5308OT_09_04.jpg" alt="The shopping cart"/></div><p>This modal window contains a list of products in the cart and the quantity of each item. The user can adjust the quantities of each item here as well by clicking on or tapping the plus or minus icons. The other key feature of this window is the <span class="strong"><strong>Order Now</strong></span> button, which processes the current cart into an order.</p><p>If the user hasn't already logged in, clicking on this button will show the login and registration screen, which we'll look at next.</p></div><div class="section" title="Login and registration"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec105"/>Login and registration</h2></div></div></div><p>The <span class="strong"><strong>Login</strong></span> and <span class="strong"><strong>Register</strong></span> options <a id="id529" class="indexterm"/>are <a id="id530" class="indexterm"/>shown in <a id="id531" class="indexterm"/>the following<a id="id532" class="indexterm"/> screenshot:</p><div class="mediaobject"><img src="graphics/5308OT_09_05.jpg" alt="Login and registration"/></div><p>The login and registration forms are shown side-by-side because they're simple enough to fit in the same window. The fields will have validation in order to ensure e-mails are correctly formatted and required fields are completed. When the registration or login process is completed, the <span class="strong"><strong>Login</strong></span> icon on the main screen will be replaced by the user's e-mail address; clicking on this link will show an account screen.</p></div><div class="section" title="User account"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec106"/>User account</h2></div></div></div><p>The<a id="id533" class="indexterm"/> user account page<a id="id534" class="indexterm"/> allows the user to edit their details and view their past orders:</p><div class="mediaobject"><img src="graphics/5308OT_09_06.jpg" alt="User account"/></div><p>The text fields on the left-hand side allow the user to amend their address and user credentials, and the pane on the right-hand side is a list of previous orders, showing the items that were ordered, the date, and the total amount.</p></div><div class="section" title="Design overview"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec107"/>Design overview</h2></div></div></div><p>We've looked at all of the <a id="id535" class="indexterm"/>main application views in turn; for simplicity, we've <a id="id536" class="indexterm"/>excluded an actual payment process to avoid integrating with a third-party service. When the user proceeds with an order, it will immediately be processed and added as a past order in their account.</p><p>One great thing about Ext JS 5 is that it adds support for touch devices and includes a touch-friendly theme. This should make it super simple to achieve our goal of presenting this app to tablet users; however, we'll include some theming tweaks to create a custom look and improve the<a id="id537" class="indexterm"/> experience<a id="id538" class="indexterm"/> for users on tablet devices.</p></div></div></div>
<div class="section" title="Back to Ext JS"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec105"/>Back to Ext JS</h1></div></div></div><p>While we now know that Ext JS<a id="id539" class="indexterm"/> can help with the creation of a touch-friendly interface, does our design suggest any other ideas that Ext JS might not be able to cope with? Remember that the design phase is an exploration of what works for the user and what is possible with the technology at hand. Let's break it down:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The scrolling product category list can be a <code class="literal">Ext.grid.Panel</code> class with most features, such as headers, disabled</li><li class="listitem" style="list-style-type: disc">The scrolling product list can be an <code class="literal">Ext.view.View</code> class (also known as a DataView), as we need to include custom HTML for each product to display an image and other details</li><li class="listitem" style="list-style-type: disc">Product list sorting will be achieved via a combo box containing the sort criteria</li></ul></div><p>Other than this, we just need modal windows (which Ext JS supports), another grid for the shopping cart, a few form fields for the login and registration. We're pretty much there.</p><p>In addition to this, we'll use routing to provide the ability to bookmark categories or products, which allows the user to share links. We'll also use view models and events to wire everything together. The data will again be drawn from a server-side API, so let's look at this next.</p></div>
<div class="section" title="The data layer"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec106"/>The data layer</h1></div></div></div><p>The <a id="id540" class="indexterm"/>shopping application <a id="id541" class="indexterm"/>needs to be supplied with the following data:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A list of categories</li><li class="listitem" style="list-style-type: disc">A list of products, filtered by category and sorted by the selected criteria</li><li class="listitem" style="list-style-type: disc">Details of a single product</li></ul></div><p>This makes things pretty straightforward. So, in a moment, we'll break down exactly what sort of data responses we'll see when we make a server request.</p><p>Before this, you might notice that we're skipping over the part of the application that will integrate with the server-side. The key reason for this is that it will add complexity to our example application without adding much more value; we want to highlight the decisions that we made in order to piece together this application and do it in a concise and understandable way. While there are many features we can add to this application and indeed our previous examples, we want to make sure that the really important aspects of building an application can shine through.</p><p>Let's go back to the <a id="id542" class="indexterm"/>data that we'd like our backend to supply. Firstly, retrieving<a id="id543" class="indexterm"/> a list of categories:</p><div class="informalexample"><pre class="programlisting">GET: /category
Accepts: N/A
Returns: [{"id":1,"name":"Pilsner"},{"id":2,"name":"IPA"}]</pre></div><p>It accepts no parameters and returns a JSON array containing the ID and name of each available category. To see the products in a category, we talk to the products API:</p><div class="informalexample"><pre class="programlisting">GET: /product
Accepts:
sort = [{"property":"id","direction":"ASC"}]
filter = [{"property":"categoryId","value":2}]
Returns: [{"id":1,"name":"Sierra Nevada Torpedo Extra IPA","price":"19.99", "imagePath":"snte1.jpg"}]</pre></div><p>It returns an array of objects, each containing the properties needed to render a product list item. The array can be filtered by passing a sort query parameter with a JSON array of fields to sort against, and we fetch only the category of products we need by passing a <code class="literal">filter</code> query parameter with a JSON array. This array contains one object to filter the <code class="literal">categoryId</code> property. This JSON filter and sort approach is one we've used in the past and it fits well with the way Ext JS works on the client side.</p><p>Finally, we have the request for the details of a single product as follows.</p><div class="informalexample"><pre class="programlisting">GET: /product/:id
Accepts: N/A
Returns: { "id": 1, &lt;all product fields omitted&gt; }</pre></div><p>It does not accept any query parameters per se. Instead, the ID is passed as part of the URL path, as it's more often seen in a RESTful API. The full JSON response is omitted for brevity, but it returns the full set of fields required to populate the product window.</p><p>Now that we've gathered this information, we can start to think about how it will shape our data classes.</p><div class="section" title="Information contemplation"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec108"/>Information contemplation</h2></div></div></div><p>Based on the API we've just described, we have <a id="id544" class="indexterm"/>two main models and their associated stores:</p><div class="informalexample"><pre class="programlisting">Alcohology.model.Product: extends Alcohology.model.BaseModel
- id
- name
- imagePath
- description
- price
- previousPrice
- brewery
- features
- categoryId

Alcohology.model.Category: extends Alcohology.model.BaseModel
- id
- name</pre></div><p>These will have accompanying stores that do nothing more than wrap their model. In addition to the classes that interact with the API, we'll have a couple more to deal with some other moving parts in the application. Firstly, we'll look at the various items in the cart:</p><div class="informalexample"><pre class="programlisting">Alcohology.model.CartItem: extends Alcohology.model.BaseModel
- productId
- productName
- price
- quantity</pre></div><p>An alternative to this design will be to hold only <code class="literal">productId</code> and <code class="literal">quantity</code> and look up the product details from the product store at render time. However, the method we've chosen makes the resulting code simpler and it also allows you to store data such as the price at the time the user adds it to the cart. This can be handy in complex or busy sites if the product price changes after the user adds it to the cart.</p><p>Secondly, we have a model to hold an order:</p><div class="informalexample"><pre class="programlisting">Alcohology.model.Order: extends Alcohology.model.BaseModel
- date
- totalCost
- items[]
    - productId
    - productName
    - price
    - quantity</pre></div><p>This will be used to represent a shopping cart that has been converted to an order. While this class will be consumed by a simple wrapper store, <code class="literal">CartItem</code> will have a store that does a little bit more:</p><div class="informalexample"><pre class="programlisting">Alcohology.store.Cart: extends Ext.data.Store
- addProduct
- toOrder</pre></div><p>The <code class="literal">addProduct</code> method can <a id="id545" class="indexterm"/>be passed to a product model that is to be added to the cart. It adds a bit of logic to detect whether a matching product already exists in the cart; if it does, it increments the quantity rather than creating a new cart item.</p><p>The <code class="literal">toOrder</code> method converts the cart and all its items to an <code class="literal">Order</code> model, which can then be saved to the server.</p><p>The API for this project is simple, but we'll also use models and stores to organize our data and application state in memory, favoring the <code class="literal">Ext.data</code> classes over standard JavaScript objects in order to leverage their powerful features. With the data design pretty much complete, we can move on to see how this data will interact with the rest of the application.</p></div></div>
<div class="section" title="Component interaction"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec107"/>Component interaction</h1></div></div></div><p>In Ext JS 4, we have the <a id="id546" class="indexterm"/>MVC pattern to build and<a id="id547" class="indexterm"/> clean well-structured applications. Looking back at our past few practical chapters, though, it seems difficult to imagine going back to MVC from the MVVM architecture that Ext JS gives us because, in each example, we've used view models to great effect to provide a logical way for data to flow through our application.</p><p>The interesting thing about these examples is how little code we write in many situations. Analyzing the application requirements and spiking a few tricky areas leads to writing a small amount of configuration of UI, controllers, view models, and so on. Ext JS automatically builds the plumbing through which our data can flow.</p><p>It's another example of why application architecture is so important, particularly when combined with a strong understanding of the tools at hand. It would be very easy for a naïve developer to jump in and start writing code to manually handle movement of data from an API through to the user interface using <code class="literal">Ext.Ajax</code> rather than models and proxies and manually loading data into components. However, by taking a patient and methodical approach, we can build a conceptual overview of the application that easily slots into the framework provided by Ext JS. By thinking about things upfront, we're making our lives much simpler for later use.</p><p>To this end, let's think <a id="id548" class="indexterm"/>about the controllers and views we'll need in this application.</p><div class="section" title="In control"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec109"/>In control</h2></div></div></div><p>What's the purpose of a <a id="id549" class="indexterm"/>controller? As you learned in <a class="link" href="ch02.html" title="Chapter 2. MVC and MVVM">Chapter 2</a>, <span class="emphasis"><em>MVC and MVVM</em></span>, it's to act as the glue between other parts of the application, and in the majority of cases, this is manifested in code that handles events. From UI clicks to routing events, the controller consumes them and passes off the real work to another class.</p><p>What does this mean for the way we think about architecture? It means that any action or event in the application will likely need an associated controller. If these actions can be bundled into a distinct grouping, then this could be an indication they warrant their own controller. With this in mind, let's look at our shopping application again:</p><div class="mediaobject"><img src="graphics/5308OT_09_07.jpg" alt="In control"/></div><p>What elements of the<a id="id550" class="indexterm"/> page could raise an event? A click on a category in the blue left-hand pane, so alongside the category list view, we'll have a category view controller as follows:</p><div class="informalexample"><pre class="programlisting">Alcohology.view.categories.CategoriesController: extends Ext.app.ViewController
- onItemClick</pre></div><p>Clicking on a product in the product list is an action we need to handle, so we'll have a product list view and a product view controller as follows:</p><div class="informalexample"><pre class="programlisting">Alcohology.view.product.ProductController: extends 
Ext.app.ViewController
- onSortSelect
- onCategoryRoute
- onProductRoute
- onProductClick
- onProductClose
- onAddToCart
</pre></div><p>Next up, the two icons at the top-right corner of the window need to trigger UI changes, so they need a view controller. Do we want a "header" controller to handle the events from the cart and account icons or can we use a "main" controller? It's one of these things that can boil down to a matter of preference; here, we'll use the main controller just to keep the number of<a id="id551" class="indexterm"/> classes from getting out of hand:</p><div class="informalexample"><pre class="programlisting">Alcohology.view.main.MainController: extends Ext.app.ViewController
- onLoginRequired
- onCartClick
- onAccountClick
- onAccountRoute
- onCartRoute
</pre></div><p>Let's look back at our other UI wireframes. There are three remaining UI components and they're all modal windows. Firstly, the product detail window (interactions with this will be handled by the product controller that we've already identified).</p><p>Next is the shopping cart window, which will be paired with a controller that handles the user's interactions with the various buttons on the cart:</p><div class="informalexample"><pre class="programlisting">Alcohology.view.cart.CartController: extends 
Ext.app.ViewController
- onCartClose
- onOrderNow
</pre></div><p>Finally, the account window with its account view controller to handle login and registration is shown in the following code:</p><div class="informalexample"><pre class="programlisting">Alcohology.view.account.AccountController: extends 
Ext.app.ViewController
- onAccountClose
- onLoginRegister
</pre></div><p>There's a final place that will raise events that our application will need to handle. The requirements for this project stipulate that we implement routing to allow product pages to be shared via e-mail or social media. To meet this need, we'll have a controller specify the routes' definitions and matching handlers. The exact controller to take this role will depend on the nature of the route definitions, for example, if it's a route related to products, then the product controller will handle it. You can see a few of these route handling methods dotted around the controller designs in the preceding section.</p><p>Grouping actions and events in this way will often make the choice of which controllers to build an easy one, particularly when used in association with wireframes that allow you to look at the corresponding UI views.</p></div></div>
<div class="section" title="The simplicity of view models"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec108"/>The simplicity of view models</h1></div></div></div><p>We've discussed <a id="id552" class="indexterm"/>view models and application architecture <a id="id553" class="indexterm"/>using the word "flow" several times. As the user manipulates various parts of the user interface, data flows through controllers and view models to represent the current state of the application. Rather than writing out a list of all of the junctions through which data can flow in this application, let's try and picture it instead as follows:</p><div class="mediaobject"><img src="graphics/5308OT_09_08.jpg" alt="The simplicity of view models"/><div class="caption"><p>Interactions between the cart store on the main view model and its dependents</p></div></div><p>Being able to conceptualize your application at this level is a good sign that it is well-understood and well-conceived. In larger applications, it will be hard to visualize every part of the application in this way, so it will often be broken into multiple smaller visualizations. Either way, building a top-level mapping of data and user flow is a fantastic way to confirm the logic and simplicity of a design.</p></div>
<div class="section" title="Code, code, and more code"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec109"/>Code, code, and more code</h1></div></div></div><p>It's time to get our hands <a id="id554" class="indexterm"/>dirty and put fingers to keyboards. As always, we generated a new base application using Sencha Cmd and will use the resulting "main" view as a starting point for our user interface. First though, let's flesh out the data layer that we designed earlier:</p><div class="informalexample"><pre class="programlisting">// app/model/BaseModel.js
Ext.define('Alcohology.model.BaseModel', {
    extend: 'Ext.data.Model',

    schema: {
        namespace: 'Alcohology.model',
        urlPrefix: 'http://localhost:3000',
        proxy: {
            type: 'rest',
            url: '{prefix}/{entityName:uncapitalize}'
        }
    }
});</pre></div><p>We've used a base model in <a id="id555" class="indexterm"/>previous chapters because it gives us a good way of centralizing proxy configuration. The models that inherit from it are all straightforward, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// app/model/CartItem.js
Ext.define('Alcohology.model.CartItem', {
    extend: 'Alcohology.model.BaseModel',
    fields: [
        { name: 'productId' },
        { name: 'productName' },
        { name: 'price' },
        { name: 'quantity' }
    ]
});

// app/model/Category.js
Ext.define('Alcohology.model.Category', {
    extend: 'Alcohology.model.BaseModel',
    fields: [
        { name: 'id', type: 'integer'}
    ]
});

// app/model/Order.js
Ext.define('Alcohology.model.Order', {
    extend: 'Alcohology.model.BaseModel',
    fields: [
        { name: 'date', type: 'date' },
        { name: 'items', type: 'auto' }
    ]
});

// app/model/Product.js
Ext.define('Alcohology.model.Product', {
    extend: 'Alcohology.model.BaseModel',
 fields: [
        { name: 'id', type: 'integer'},
        { name: 'name', type: 'string' },
        { name: 'imagePath', type: 'string' }
    ]
});</pre></div><p>Looking back at our design, these <a id="id556" class="indexterm"/>models exactly follow the specification we laid out. All we've really done is add the Ext JS implementation on top of the original field definitions.</p><div class="section" title="What's in store?"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec110"/>What's in store?</h2></div></div></div><p>As we know, stores are often just wrappers to <a id="id557" class="indexterm"/>give us a few more helpful methods to work with a <a id="id558" class="indexterm"/>collection of models. Looking back at our design documents, this is the case for three of the stores in this application:</p><div class="informalexample"><pre class="programlisting">// app/store/Categories.js
Ext.define('Alcohology.store.Categories', {
    extend: 'Ext.data.Store',
    model: 'Alcohology.model.Category',
    alias: 'store.categories'
});

// app/store/PastOrders.js
Ext.define('Alcohology.store.PastOrders', {
    extend: 'Ext.data.Store',
    model: 'Alcohology.model.Order',
    alias: 'store.pastorders'
});

// app/store/Products.js
Ext.define('Alcohology.store.Products', {
    extend: 'Ext.data.Store',
    model: 'Alcohology.model.Product',
    alias: 'store.products'
});</pre></div><p>All very straightforward. The <a id="id559" class="indexterm"/>cart store is a bit more interesting, as shown in the<a id="id560" class="indexterm"/> following code:</p><div class="informalexample"><pre class="programlisting">// app/store/Cart.js
Ext.define('Alcohology.store.Cart', {
    extend: 'Ext.data.Store',
    model: 'Alcohology.model.CartItem',
    alias: 'store.cart',

    addProduct: function(product) {
        // find a product with a matching ID
        var item = this.findRecord('productId', product.getId());

        if(item) {
            item.set('quantity', item.get('quantity') + 1);
            item.commit();
        } else {
            item = this.add({
                productName: product.get('name'),
                price: product.get('price'),
                productId: product.getId(),
                quantity: 1
            });
        }

        return item;
    },

    toOrder: function() {
        var items = [], total = 0;

        this.each(function(item) {
            items.push({
                name: item.get('productName'),
                quantity: item.get('quantity')
            });

            total += item.get('price') * item.get('quantity');
        });

        return Ext.create('Alcohology.model.Order', {
            date: new Date(), items: items, total: total
        });
    }
});</pre></div><p>Many of the stores we've built in past chapters have been used to store information that has been fetched from the server. Here, we're using the store as an in-memory representation of the shopping cart itself; we're adding a couple of custom methods to help with this function.</p><p>The <code class="literal">addProduct</code> method will add the specified product to the store by converting it to a <code class="literal">CartItem</code> model. If a product with the same ID already exists as an item in the cart, it will have its quantity increased by one rather than being duplicated.</p><p>The <code class="literal">toOrder</code> method converts the whole cart to an <code class="literal">Order</code> model, which is used later in the application to show past orders in the user's account.</p><p>These methods <a id="id561" class="indexterm"/>are interesting because they demonstrate a place <a id="id562" class="indexterm"/>where we're not writing glue code or code that handles events. It's the code that deals with the really interesting parts of an application, sometimes called "business logic". One of the benefits of developing a strong architecture with strong development practices is that you will have less boilerplate code and more time to work on the business logic that's important to your client.</p><p>In <a class="link" href="ch11.html" title="Chapter 11. Application Testing">Chapter 11</a>, <span class="emphasis"><em>Application Testing</em></span>, we'll look at ways to isolate this business logic and create automated tests that give you confidence in your code base.</p><p>That's our data layer in place, so we can move on to building the user interface.</p></div></div>
<div class="section" title="Interface in your face"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec110"/>Interface in your face</h1></div></div></div><p>An Ext JS application created with <a id="id563" class="indexterm"/>Sencha Cmd will set up the main view as a viewport<a id="id564" class="indexterm"/> filling the entire browser window. We'll use this view and adapt it to our needs, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// app/view/main/Main.js
Ext.define('Alcohology.view.main.Main', {
    extend: 'Ext.Panel',
    xtype: 'app-main',

    controller: 'main',
    viewModel: 'main',
    layout: 'border',

    header: { xtype: 'app-header' },
    items: [
        { xtype: 'categories', width: 200, region: 'west' },
        { xtype: 'product-list', region: 'center' }
    ],

    initComponent: function() {
        this.callParent(arguments);

        this.add(Ext.create('Alcohology.view.cart.Cart', {
            reference: 'cartWindow'
        }));

        this.add(Ext.create('Alcohology.view.account.Account', {
            reference: 'accountWindow'
        }));
    }
});</pre></div><p>Here we are! Our first view<a id="id565" class="indexterm"/> component, the panel that will contain everything <a id="id566" class="indexterm"/>else in the application. The <code class="literal">header</code> config is set to a custom <code class="literal">xtype</code> that we'll build later. The items in the panel are configured to use a border layout and consist of the category list and the product list.</p><p>There is one oddity here: adding windows to a panel within the <code class="literal">initComponent</code> method. This provides two benefits:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The main view controller can refer to the windows using <code class="literal">lookupReference</code></li><li class="listitem" style="list-style-type: disc">The windows will have access to the main view model via the view model inheritance</li></ul></div><p>This is a simple approach that solves an obvious sounding issue, that is, where do I create my windows? It doesn't feel "right" to put them in the <code class="literal">items</code> config with the product and category list, although we certainly can without any ill effect. Another common solution is to instantiate the window in the view controller itself, but as the window then isn't a child of the main view, this leads to issue with the view model inheritance. Creating the windows in the <code class="literal">initComponent</code> method feels like a natural way to bypass this problem.</p><div class="section" title="One step ahead"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec111"/>One step ahead</h2></div></div></div><p>We decided earlier that the<a id="id567" class="indexterm"/> main view controller will also handle events from the header, so let's look at the header view next:</p><div class="informalexample"><pre class="programlisting">// app/view/header/Header.js
Ext.define('Alcohology.view.header.Header', {
    extend: 'Ext.panel.Header',
    xtype: 'app-header',
    cls: 'app-header',
    layout: 'hbox',
    title: 'alcohology.',
    items: [
        { xtype: 'account-indicator', width: 80, bind: '{currentUser}' },
        bind: { data: { count: '{cartCount}' } }}
    ]
});</pre></div><p>Our custom header component inherits from <code class="literal">Ext.panel.Header</code> and implements an <code class="literal">hbox</code> layout. The two items contained within are also custom classes, one for the cart icon and one for the account icon. These are configured to bind to <code class="literal">currentUser</code> and <code class="literal">cartCount</code> respectively, which are values in the main view model that we'll look at later.</p><p>The cart icon is called <code class="literal">MiniCart</code> and it looks like this:</p><div class="informalexample"><pre class="programlisting">// app/view/header/MiniCart.js
Ext.define('Alcohology.view.header.MiniCart', {
    extend: 'Alcohology.ux.ClickContainer',
    xtype: 'minicart',
    cls: 'mini-cart',
    tpl: new Ext.Template('&lt;span style="font-family:FontAwesome;"&gt;',
        '&amp;#xf07a;&lt;/span&gt; {count} items')
});</pre></div><p>In the <code class="literal">header</code> component, we specified that the <code class="literal">data</code> config for <code class="literal">MiniCart</code> should be an object with a <code class="literal">count</code> value. This <code class="literal">count</code> value will be bound to a <code class="literal">cartCount</code> value in the view model. In turn, we now use this <code class="literal">count</code> value in the template, which allows you to have an icon that updates with the count of items in the cart.</p><p>There are a couple of other <a id="id568" class="indexterm"/>things to note here. We're using the <code class="literal">FontAwesome</code> icon set to add a bit of graphical flair to the cart; you can see it being used in a <code class="literal">span</code> tag in the <code class="literal">tpl</code> configuration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>
<code class="literal">FontAwesome</code> can be found <a id="id569" class="indexterm"/>at <a class="ulink" href="http://fortawesome.github.io/Font-Awesome/">http://fortawesome.github.io/Font-Awesome/</a>.</p></div></div><p>The second point to note is that this class inherits from <code class="literal">Alcohology.ux.ClickContainer</code>. What's this? Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">// app/ux/ClickContainer.js
Ext.define('Alcohology.ux.ClickContainer', {
    extend: 'Ext.Container',
    xtype: 'clickcontainer',
    listeners: {
        'afterrender': function(me) {
            me.getEl().on('click', function() {
                me.fireEvent('click');
            });
        }
    }
});</pre></div><p>A normal container doesn't have a <code class="literal">click</code> event, so this <code class="literal">ClickContainer</code> hooks into the underlying element that allows you to handle user interaction with the container. This is handy if you don't need button styling and would like a bare-bones clickable component.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>This feature can also be implemented as a mixin rather than a base class.</p></div></div><p>The account indicator also extends <code class="literal">ClickContainer</code> as follows:</p><div class="informalexample"><pre class="programlisting">// app/view/header/AccountIndicator.js
Ext.define('Alcohology.view.header.AccountIndicator', {
    extend: 'Alcohology.ux.ClickContainer',
    xtype: 'account-indicator',
    cls: 'account-indicator',
    config: {
        user: null
    },
    defaultBindProperty: 'user',
    data: {
        label: 'Login'
    },
    tpl: '&lt;span style="font-family:FontAwesome;"&gt;&lt;/span&gt; {label}',

    applyUser: function(user) {
        if(user) {
            this.setData({ label: user.email });
        }
    }
});</pre></div><p>Our favorite trick of <a id="id570" class="indexterm"/>binding to a custom configuration option is again used here with a little twist. If the value of a user being bound is <code class="literal">null</code>, that is, if the user has yet to log in, we use the default value of the <code class="literal">data</code> config to set a label on this component. If they have logged in, we set the label to their e-mail address.</p><p>You can see in the <code class="literal">tpl</code> configuration that we're using <code class="literal">FontAwesome</code> again. It's also the place we use the label that has a default value of <code class="literal">login</code>.</p><p>Let's get back to the code that handles the user's interactions with these components.</p></div><div class="section" title="Under the main control"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec112"/>Under the main control</h2></div></div></div><p>The main controller is not only the place that handles user clicks and taps, but the place that defines some relevant routes. It even handles a <a id="id571" class="indexterm"/>custom event. Let's take a look:</p><div class="informalexample"><pre class="programlisting">// app/view/main/MainController.js
Ext.define('Alcohology.view.main.MainController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.main',

    listen: {
        component: {
            'component[cls="mini-cart"]': { click: 'onCartClick' },
            'component[cls="account-indicator"]': { click: 'onAccountClick' },
        },

        controller: { '*': { loginrequired: 'onLoginRequired' } }
    },

    routes: {
        'account': 'onAccountRoute',
        'cart': 'onCartRoute'
    },

    onLoginRequired: function() {
        Ext.toast('Please login or register.');
        this.redirectTo('account', true);
    },

    onCartClick: function() {
        this.redirectTo('cart', true);
    },

    onAccountClick: function() {
        this.redirectTo('account', true);
    },

    onAccountRoute: function() {
        this.lookupReference('accountWindow').show();
    },

    onCartRoute: function() {
        this.lookupReference('cartWindow').show();
    }
});</pre></div><p>There's a very handy technique <a id="id572" class="indexterm"/>demonstrated here: the <code class="literal">click</code> handlers for <code class="literal">account-indicator</code> and <code class="literal">minicart</code> both simply redirect to their relevant routes. This means that we can put the logic to show the account and cart windows in <code class="literal">onAccountRoute</code> and <code class="literal">onCartRoute</code> route handlers.</p><p>The other piece of functionality implemented in this view controller is the listener on the controller domain. It listens for any controller firing the <code class="literal">loginrequired</code> event and handles it with the <code class="literal">onLoginRequired</code> method. Within <code class="literal">onLoginRequired</code>, we pop up a brief note to the user via the <code class="literal">Ext.toast</code> feature and simply redirect them to the <code class="literal">login/registration</code> page.</p><p>This enables any controller or view controller to request the user to log in without having to be explicitly aware of the implementation of the account system. Let's take a look at the view model for the main viewport:</p><div class="informalexample"><pre class="programlisting">// app/view/main/MainModel.js
Ext.define('Alcohology.view.main.MainModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.main',

    stores: {
        cart: { type: 'cart' },
        orders: { type: 'pastorders'}
    },

    data: {
        cartCount: 0
    },

    constructor: function() {
        var me = this;

        me.callParent(arguments);

        me.get('cart').on('datachanged', function(store) {
            me.set('cartCount', store.count());
        });
    }
});</pre></div><p>This top-level view <a id="id573" class="indexterm"/>model provides the stores for past orders and the shopping cart as well as a property giving us the number of items in the shopping cart.</p><p>Due to the default in Ext JS, we have to manually listen to the <code class="literal">datachanged</code> event on the cart store in order to get a "live" count of items because a change in the size of the store won't trigger a databind.</p><p>We've covered the "main" view and associated classes, so let's move on to the view that will list product categories.</p></div></div>
<div class="section" title="Categorically speaking"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec111"/>Categorically speaking</h1></div></div></div><p>We're going to use a simplified grid<a id="id574" class="indexterm"/> to build this view:</p><div class="informalexample"><pre class="programlisting">// app/view/categories/Categories.js
Ext.define('Alcohology.view.categories.Categories', {
    extend: 'Ext.grid.Panel',
    xtype: 'categories',
    controller: 'categories',
    viewModel: 'categories',
    bodyCls: 'categories-body',
    requires: [
        'Alcohology.view.categories.CategoriesModel',
        'Alcohology.view.categories.CategoriesController'
    ],
    bind: {
        store: '{categories}'
    },
 hideHeaders: true,
    viewConfig: {
        trackOver: false
    },
    columns: [
        { text: 'Name',  dataIndex: 'name', flex: 1 }
    ]
});</pre></div><p>We've hidden the <code class="literal">grid</code> headers and used the <code class="literal">flex</code> configuration option to tell the single column to fill all of the available space. This gives us the functionality we need for a simple scrolling list.</p><p>The list's store is then bound to the <code class="literal">categories</code> that's defined on the category view model that we'll look at shortly. First, let's take a look at the categories view controller:</p><div class="informalexample"><pre class="programlisting">// app/view/categories/CategoriesController.js
Ext.define('Alcohology.view.categories.CategoriesController', {
  extend: 'Ext.app.ViewController',
  alias: 'controller.categories',
  listen: {
    component: {
      'categories': { 'itemclick': 'onItemClick' }
    }
  },

  onItemClick: function(view, record) {
    this.redirectTo('category/' + record.getId());
  }
});</pre></div><p>This really couldn't be much <a id="id575" class="indexterm"/>simpler; just catch the <code class="literal">itemclick</code> event, grab the ID of the selected category, and pass it off to the routing system so that another controller can take care of it. The final part of the category puzzle is the view model and it's even more straightforward, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// app/view/categories/CategoriesModel.js
Ext.define('Alcohology.view.categories.CategoriesModel', {
    extend: 'Ext.app.ViewModel',
    requires: ['Alcohology.store.Categories'],
    alias: 'viewmodel.categories',
    stores: {
        categories: {
            type: 'categories',
            autoLoad: true
        }
    }
});</pre></div><p>This is the MVVM pattern in action, each of the three classes shown here are doing its own thing and nothing more. The view class is describing the presentation, the view model provides the data behind this presentation, and the view controller deals with user interaction.</p></div>
<div class="section" title="Product placement"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec112"/>Product placement</h1></div></div></div><p>Here's the code for<a id="id576" class="indexterm"/> the list of<a id="id577" class="indexterm"/> products:</p><div class="informalexample"><pre class="programlisting">// app/view/product/List.js
Ext.define('Alcohology.view.product.List', {
    extend: 'Ext.Panel',
    controller: 'product',
    xtype: 'product-list',
    cls: 'product-list',
    viewModel: 'product',
    tbar: [
        {
            xtype: 'combo',
            store: Ext.create('Ext.data.Store', {
                fields: ['text', 'field', 'direction'],
                data : [
                    { text: 'Date Added', property: 'id', direction: 'DESC' },
                    { text: 'Name A-Z', property: 'name', direction: 'ASC' },
                    { text: 'Name Z-A', property: 'name', direction: 'DESC' },
                    { text: 'Price ASC', property: 'price', direction: 'ASC' }
                ]
            }),
            displayField: 'text',
            queryMode: 'local',
            fieldLabel: 'Sort By',
            emptyText: 'None',
            editable: false
        }
    ],
    items: [
        { 
            xtype: 'dataview', itemId: 'productListView', 
            emptyText: '&lt;span class="empty"&gt;No Products Found.&lt;/span&gt;',
            itemSelector: '.product', bind: '{products}',
            tpl: '&lt;tpl for="."&gt;&lt;div class="product"&gt;&lt;h2&gt;{name}&lt;/h2&gt;&lt;img src="/resources/product-images/{imagePath}-thumb.jpg" /&gt;&lt;p&gt;&amp;pound;{price}&lt;/p&gt;&lt;/div&gt;&lt;/tpl&gt;',
        }
    ],

    constructor: function() {
        this.callParent(arguments);
        
        this.add(Ext.create('Alcohology.view.product.Detail', {
            reference: 'productWindow'
        }));
    }
});</pre></div><p>The top toolbar for the product list contains a combo box with an inline store containing available sort options. Note that we include the property to sort against and the direction of the sort so that we can pass these straight through to the server later.</p><p>There's a case to be made for this combo to be extracted into a separate class or the store to be set up on the view model; it might make this class a bit clearer. On the other hand, the proliferation of files and classes for their own sake will make things less clear too, so we'll keep it inline.</p><p>The real work in this<a id="id578" class="indexterm"/> class is performed by the <code class="literal">dataview</code> bound to a<a id="id579" class="indexterm"/> products store on the view model. Note how again that we're creating a window in the constructor of this class too, which will enable it to use the same view controller as the product list <code class="literal">dataview</code>.</p><p>Here's the code for this window (it's the one that shows details of a product):</p><div class="informalexample"><pre class="programlisting">// app/view/product/Detail.js
Ext.define('Alcohology.view.product.Detail', {
    extend: 'Ext.Window',
    modal: true,
    header: false,
    resizable: false,
    autoScroll: true,
    height: 600,
    width: 800,
    layout: 'column',
    cls: 'product-detail',
    items: [
        {
            xtype: 'container',
            columnWidth: 0.5,
            defaults: {
                xtype: 'component',
                bind: { data: '{currentProduct}' }
            },
            items: [
                { 
                    xtype: 'container', 
                    tpl: '&lt;img src="/resources/product-images/{imagePath}-thumb.jpg" /&gt;' 
                },
                { tpl: '&lt;ul&gt;&lt;li&gt;{features}&lt;/li&gt;&lt;/ul&gt;' }
            ]
        },
        {
            xtype: 'container',
            columnWidth: 0.5,
            defaults: {
                xtype: 'component',
                bind: { data: '{currentProduct}' }
            },
            items: [
                { tpl: new Ext.Template('&lt;h1&gt;{name}&lt;/h1&gt;',
                    '&lt;h2 class="brewery"&gt;{brewery}&lt;/h2&gt;',
                    '&lt;h2&gt;&lt;p class="price"&gt;&amp;pound;{price}&lt;/p&gt;',
                    '&lt;p class="previousPrice"&gt;Was: &amp;pound;{previousPrice}&lt;/p&gt;',
                    '&lt;/h2&gt;') },
                { tpl: '&lt;div class="description"&gt;{description}&lt;/div&gt;' }
            ]
        }
    ],

    bbar: [
        { text: 'Back', itemId: 'close', glyph: 0xf190 },
        '-&gt;',
        { text: 'Add to Cart', itemId: 'addToCart', glyph: 0xf07a }
    ]
});</pre></div><p>There's a neat little trick<a id="id580" class="indexterm"/> used in this class. The window is split<a id="id581" class="indexterm"/> into two using a column layout and filled with a number of components that have their <code class="literal">data</code> config bound to the <code class="literal">currentProduct</code> on the view model. By using the <code class="literal">tpl</code> config on these components to set up an HTML template, each pane in the window can pull properties from the <code class="literal">currentProduct</code> and they'll be incorporated in the template. This gives us a hybrid approach that leverages the Ext JS column layout and standard HTML/CSS for customization.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>In <code class="literal">bbar</code> for this window, we use the <code class="literal">glyph</code> property to set <code class="literal">FontAwesome</code> icons on the buttons using the <code class="literal">unicode</code> character code of the icon in question.</p></div></div><p>The view controller that <a id="id582" class="indexterm"/>works with the product list and detail has a <a id="id583" class="indexterm"/>couple of interesting features as follows:</p><div class="informalexample"><pre class="programlisting">// app/view/product/ProductController.js
Ext.define('Alcohology.view.product.ProductController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.product',
    listen: {
        component: {
            '#productListView': { 'itemclick': 'onProductClick' },
            '#close': { 'click': 'onProductClose' },
            '#addToCart': { 'click': 'onAddToCart' },
            'combo': { 'select': 'onSortSelect' }
        }
    },

    routes : {
        'product/:id': 'onProductRoute',
        'category/:id': 'onCategoryRoute'
    },

    onSortSelect: function(combo, records) {
        if(records.length &gt; 0) {
            var prop = records[0].get('property'),
                dir = records[0].get('direction');

            this.getViewModel().set('sortProperty', prop);
            this.getViewModel().set('sortDirection', dir);
        }
    },

    onCategoryRoute: function(id) {
        var cfg = { reference: 'Alcohology.model.Category', id: id };
        this.getViewModel().linkTo('currentCategory', cfg);
        this.lookupReference('productWindow').hide();
    },

    onProductRoute: function(id) {
        var cfg = { reference: 'Alcohology.model.Product', id: id };
        this.getViewModel().linkTo('currentProduct',  cfg);
        this.lookupReference('productWindow').show();
    },

    onProductClick: function(view, record, el) {    
        this.redirectTo('product/' + record.getId());
    },

    onProductClose: function() {
        var id = this.getViewModel().get('currentCategory').getId();
        this.redirectTo('category/' + id);
    },

    onAddToCart: function() {
        var product = this.getViewModel().get('currentProduct');

        this.getViewModel().get('cart').addProduct(product);

        Ext.toast('Product Added');
    }
});</pre></div><p>After wiring up <a id="id584" class="indexterm"/>event listeners and routes, we have <a id="id585" class="indexterm"/>the <code class="literal">onSortSelect</code> method that handles the user's selection of a <code class="literal">sort</code> option. We pick out the values we need and send them to the view model.</p><p>The routing handles on this view controller: <code class="literal">onCategoryRoute</code> and <code class="literal">onProductRoute</code> deal with the selection of a category (which shows a list of products) and the selection of a product (which shows a single product), and do so using a technique (which is new to us).</p><p>By using the <code class="literal">linkTo</code> method, we tell Ext JS to load the record with the specified ID if it's not already loaded it before. By doing this, we save the manual labor of loading the record ourselves. It's a neat shortcut that lets us set <code class="literal">currentProduct</code> and <code class="literal">currentCategory</code> on the view model with minimal code.</p><p>The <code class="literal">onProductClick</code> and <code class="literal">onProductClose</code> methods use <code class="literal">redirectTo</code> and hand off the real behavior to the relevant routes. The <code class="literal">onAddToCart</code> method grabs the cart store from the view model and uses the <code class="literal">addProduct</code> method that we created back in our data layer to push the current product into the cart.</p><p>Finally, we have the product view model:</p><div class="informalexample"><pre class="programlisting">// app/view/product/ProductModel.js
Ext.define('Alcohology.view.product.ProductModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.product',
    links: {
        currentCategory: {
            type: 'Alcohology.model.Category',
            id: 1
        }
    },
    data: {
        sortProperty: 'id',
        sortDirection: 'ASC'
    },
    stores: {
        products: {
            type: 'products',
            autoLoad: true,
            remoteFilter: true,
            remoteSort: true,
            sorters: [{
                property: '{sortProperty}',
                direction: '{sortDirection}'
            }],
            filters: [{
                property: 'categoryId',
                value: '{currentCategory.id}'
            }]
        }
    }
});</pre></div><p>The <code class="literal">links</code> configuration <a id="id586" class="indexterm"/>sets up the initial category to be <a id="id587" class="indexterm"/>loaded; Ext JS will do this automatically and anything that's been bound to it will be able to make use of it as soon as the load is complete. No manual intervention here is required; just wire up the configuration and go.</p><p>The <code class="literal">data</code> object contains the default values for product sorting and you can see that these are used by the <code class="literal">products</code> store and sent off to the server thanks to <code class="literal">remoteSort</code>. The product store is used to power the list of products in a category, and to this end it has a filter that's bound to the ID of <code class="literal">currentCategory</code>. This gets sent along with the sort options as JSON.</p><p>Categories and <a id="id588" class="indexterm"/>products are taken care of. It's time to move on to <a id="id589" class="indexterm"/>the shopping cart UI.</p></div>
<div class="section" title="A basket case"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec113"/>A basket case</h1></div></div></div><p>The cart itself is a <a id="id590" class="indexterm"/>grid showing the products in the cart and the quantity of <a id="id591" class="indexterm"/>each. It's enclosed in a window with a couple of action buttons at the bottom as follows:</p><div class="informalexample"><pre class="programlisting">// app/view/cart/Cart.js
Ext.define('Alcohology.view.cart.Cart', {
    extend: 'Ext.Window',
    requires: ['Alcohology.view.cart.CartController'],
    controller: 'cart',
    width: 500,
    height: 350,
    modal: true,
    resizable: false,
    header: false,
    onEsc: Ext.emptyFn,
    layout: 'fit',
    items: [
        {
            xtype: 'grid',
            bind: '{cart}',
            plugins: {
                ptype: 'cellediting',
                clicksToEdit: 1
            },
            listeners: {
                edit: function(editor, e) {
                    e.record.commit();
                }
            },
            hideHeaders: true,
            emptyText: 'No items in the cart.',
            columns: [
                { name: 'Product', dataIndex: 'productName', flex: 1 },
                {
                    name: 'Quantity', dataIndex: 'quantity',
                    editor: {
                        xtype: 'numberfield',
                        allowBlank: false
                    }
                }
            ]
        }
    ],
    bbar: [
        '-&gt;',
        { text: 'Close', itemId: 'closeCart' },
        { text: 'Order Now', itemId: 'orderNow' }
    ]
});</pre></div><p>Within the grid, we <a id="id592" class="indexterm"/>have used the <code class="literal">cellediting</code> plugin <a id="id593" class="indexterm"/>that allows the user to tap the quantity column and use the plus or minus icons that Ext JS provides on the touch-friendly theme to adjust the item quantity. When the quantity is edited and the <code class="literal">edit</code> event fires on the grid, we immediately commit the change to the cart store, which is bound to the grid from the parent view model.</p><p>Note that there is no specific view model for this view. Instead, as we instantiated this window within the constructor of the main view, it'll inherit the main view model. This means that we can share the cart store with multiple components by having it high up in the view model hierarchy.</p><p>Let's move on to the cart view controller, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// app/view/cart/CartController.js
Ext.define('Alcohology.view.cart.CartController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.cart',
    listen: {
        component: {
            '#closeCart': { click: 'onCartClose' },
            '#orderNow': { click: 'onOrderNow' }
        }
    },

    onCartClose: function() {
        this.getView().hide();
    },

    onOrderNow: function() {
        var vm = this.getViewModel();

        if(!vm.get('currentUser')) {
            this.fireEvent('loginrequired');
        } else {
               var order = vm.get('cart').toOrder();

            vm.get('cart').removeAll();
            vm.get('orders').add(order);

            Ext.toast('Order Accepted!');

            this.getView().hide();
        }
    }
});</pre></div><p>We wire up event<a id="id594" class="indexterm"/> handlers for the window's buttons by <a id="id595" class="indexterm"/>using <code class="literal">itemId</code>, which we defined in the view as the selector. The <code class="literal">onCartClose</code> method is straightforward, but the <code class="literal">onOrderNow</code> one is a little more interesting.</p><p>It first determines if the user is logged in by checking whether <code class="literal">currentUser</code> on the view model is <code class="literal">null</code>. If the user is not logged in, a <code class="literal">loginrequired</code> event will be fired; if you remember, we handled this earlier in the main view controller. If the user is logged in, we perform the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Call the <code class="literal">toOrder</code> method from the cart store to get an <code class="literal">Order</code> model</li><li class="listitem" style="list-style-type: disc">Remove all the items from the cart</li><li class="listitem" style="list-style-type: disc">Add the new <code class="literal">Order</code> model to the orders store on the view model</li><li class="listitem" style="list-style-type: disc">Show a toast notification to the user</li><li class="listitem" style="list-style-type: disc">Hide the cart window</li></ul></div><p>All of this results in the <a id="id596" class="indexterm"/>cart being moved to an order. In a comprehensive<a id="id597" class="indexterm"/> e-commerce application, this is the bit that will be replaced by credit card capturing and payment processing, but we've taken the simple approach here, that is, composing various calls to other classes to perform the action we need.</p><p>As previously discussed, the cart view doesn't have its own view model because it inherits from its parent, so we'll now move on to the final view in the application; the account window.</p></div>
<div class="section" title="The account window"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec114"/>The account window</h1></div></div></div><p>The account <a id="id598" class="indexterm"/>view is a window that contains several <a id="id599" class="indexterm"/>subcomponents (such as login, register, and past orders). Let's take a look at the lengthy, but straightforward code for it:</p><div class="informalexample"><pre class="programlisting">// app/view/account/Account.js
Ext.define('Alcohology.view.account.Account', {
    extend: 'Ext.Window',
    xtype: 'account',
    layout: 'fit',
    controller: 'account',
    modal: true,
    resizable: false,
    header: false,
    onEsc: Ext.emptyFn,
    width: 800,
    autoHeight: true,
    frame: true,
    items: [
        {
            xtype: 'container',
            layout: 'column',
            items: [
                { xtype: 'login', title: 'Login', columnWidth: 0.5 },
                { xtype: 'register', title: 'Register', columnWidth: 0.5 }
            ],
            bind: { hidden: '{currentUser}' }
        },
        {
            xtype: 'container',
            layout: 'column',
            items: [
                { xtype: 'register', title: 'Register', columnWidth: 0.5 },
                {
                    xtype: 'panel',  title: 'Past Orders',
                    columnWidth: 0.5, items: [
                        { xtype: 'pastorders', bind: '{orders}' }
                    ]
                }
            ],
            bind: { hidden: '{!currentUser}' }
        }
    ],
    bbar: [
        '-&gt;',
        { text: 'Close', itemId: 'close' },
        {
            text: 'Login/Register', itemId: 'loginRegister',
            bind: { hidden: '{currentUser}' }
        }
    ]
});</pre></div><p>We've got two <a id="id600" class="indexterm"/>panels here, both set to use a <code class="literal">column</code> <a id="id601" class="indexterm"/>layout. One contains the login and registration forms and is shown when the user is logged out. Another shows the registration form repurposed as a way to let the user edit their profile details and the past orders. The second panel is only shown when the user is logged in.</p><p>The hiding and showing of components in the account window is accomplished by binding the <code class="literal">hidden</code> config to <code class="literal">currentUser</code> at the top-level main view model. Ext JS converts the user object to a "truthy" value, that is, either true or false. This is used to set the component's visibility.</p><p>Next, we have the <code class="literal">login</code> component, which is just an <code class="literal">Ext.FormPanel</code> with the relevant fields along with a little bit of explanatory text, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// app/view/account/Login.js
Ext.define('Alcohology.view.account.Login', {
    extend: 'Ext.FormPanel',
    xtype: 'login',
    items: [
        { 
            xtype: 'fieldset', margin: 10, padding: 10,
            defaults: { xtype: 'textfield', width: '100%' },
            items: [
                { fieldLabel: 'Email', bind: '{email}', vtype: 'email' },
                { fieldLabel: 'Password', inputType: 'password' }
            ]
        },
        {
            xtype: 'container',
            padding: 10,
            html: 'If you've already got an Alcohology account,please enter your login details above. If not, please complete the registration form and join us!'
        }
    ]
});</pre></div><p>Then, we have the <code class="literal">register</code> component, another form containing the fields that a user must complete in <a id="id602" class="indexterm"/>order<a id="id603" class="indexterm"/> to sign up:</p><div class="informalexample"><pre class="programlisting">// app/view/account/Register.js
Ext.define('Alcohology.view.account.Register', {
    extend: 'Ext.FormPanel',
    xtype: 'register',
    defaultType: 'textfield',
    items: [
        {
            xtype: 'fieldset', margin: 10, padding: 10,
            defaults: { xtype: 'textfield', width: '100%' },
            items: [
                { fieldLabel: 'Email', bind: '{email}', vtype: 'email' },
                { fieldLabel: 'Password', inputType: 'password' }
            ]
        },
        {
            xtype: 'fieldset', margin: 10, padding: 10,
            defaults: { xtype: 'textfield', width: '100%' },
            items: [
                { fieldLabel: 'House Number' },
                { fieldLabel: 'Street' },
                { fieldLabel: 'Town' },
                { fieldLabel: 'County' },
                { fieldLabel: 'Postcode' }
            ]
        }
    ]
});</pre></div><p>The final piece of the <a id="id604" class="indexterm"/>account user interface is the past orders <a id="id605" class="indexterm"/>component:</p><div class="informalexample"><pre class="programlisting">// app/view/account/PastOrders.js
Ext.define('Alcohology.view.account.PastOrders', {
    extend: 'Ext.DataView',
    xtype: 'pastorders',
    tpl: new Ext.XTemplate('&lt;tpl for="."&gt;&lt;div class="past-order"&gt;',
        '&lt;h3&gt;Ordered on {date:date("m F Y")}&lt;/h3&gt;',
        '&lt;ul&gt;&lt;tpl for="items"&gt;{name} x {quantity}&lt;/tpl&gt;&lt;/ul&gt;',
        '&lt;p&gt;Total: &amp;pound;{total}&lt;/p&gt;&lt;/div&gt;&lt;/tpl&gt;'),
    itemSelector: '.fake',
    emptyText: 'No Previous Orders.'
});</pre></div><p>Here, we use DataView with <code class="literal">itemTpl</code> configured to output all of the orders as well as loop through the items within this order. As none of the past orders are clickable, there's no detail view for orders to click on to. Therefore, we need to specify a fake <code class="literal">itemSelector</code>. Binding this component's store to the orders store on the view model was performed in the containing account window.</p><p>Finally, we have a simple view controller to handle interactions with the account window, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">// app/view/account/AccountController.js
Ext.define('Alcohology.view.account.AccountController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.account',
    listen: {
        component: {
            '#close': { click: 'onAccountClose' },
            '#loginRegister': { click: 'onLoginRegister' }
        }
    },

    onAccountClose: function(btn) {
        this.getView().hide();
    },

    onLoginRegister: function() {
        this.getViewModel().set('currentUser', {
            email: this.getViewModel().get('email')
        });

        this.getView().hide();
    }
});</pre></div><p>This is standard stuff in <code class="literal">onAccountClose</code>, but in <code class="literal">onLoginRegister</code>, we perform a very naïve login action in which the <code class="literal">currentUser</code> gets set to an object with the e-mail address that the user<a id="id606" class="indexterm"/> entered for login or registration. As <a id="id607" class="indexterm"/>previously discussed, we're bypassing a full authentication system for simplicity, but this demonstrates the general idea, that is, perform an action that ends up with a user being set on the inherited view model. Once again, you'll see that we don't have a separate account view model as everything's passed up and down to the one that's defined on the main view.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec115"/>Summary</h1></div></div></div><p>This chapter's been a whistle-stop tour through a set of features and ideas that we should already be familiar with. It was a consolidation of the work we've done over the past few chapters and a demonstration of how to build an application with multiple views, but with a low level of complexity.</p><p>In the next chapter, we'll be moving on from full applications and looking at performance and debugging considerations involved in an Ext JS project. How can we design our applications to help developers when issues arise? How can we try and make sure our application feels responsive to end users? We'll also be looking at these questions in-depth in the next chapter.</p></div></body></html>