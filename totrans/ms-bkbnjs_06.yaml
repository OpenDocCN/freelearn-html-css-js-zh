- en: Chapter 6. Store data in the Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Backbone was mainly designed to work with RESTful API servers; however, you
    don't want to always store the data in a server for offline applications or to
    bust application loading storing cache data in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two choices to store data in the user browser: use localStorage or
    the new IndexedDB API. While localStorage has wide support on major browsers,
    IndexedDB is the new specification that is yet to be supported in the near future.
    Another option that is available currently; however, in deprecated status is Web
    SQL. If you are developing modern web applications, you should avoid using Web
    SQL.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Basics of localStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of IndexedDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using localStorage instead of a RESTful server to store information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using IndexedDB instead of a RESTful server to store information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The localStorage is the simplest and the most supported browser data store.
    At the moment of writing this book, it is supported in almost all the major browsers.
    As shown in the figure below, the only browser that does not support localStorage
    is Opera Mini:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The localStorage](img/B01962_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 Browser support of localStorage
  prefs: []
  type: TYPE_NORMAL
- en: 'The localStorage is a simple key/value database that is able to only store
    text. In localStorage, you have three main methods to access the data: `setItem()`,
    `getItem()`,and `removeItem()`. With these three functions, you can manage the
    data in the store pretty well.'
  prefs: []
  type: TYPE_NORMAL
- en: The downside of localStorage is that it does not have tables or collections,
    therefore, all the data is mixed; another issue with localStorage is that it is
    limited to 5 Mb of information. If your storage requirements are bigger than that,
    you will need IndexedDB.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with localStorage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To store the data in the localStorage store, you need to call the `setItem()`
    method in the `localStorage` global object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it, this would store the information in the browser. We can explore
    the result of these instructions in Google Chrome as seen in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with localStorage](img/B01962_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 Google Chrome and localStorage
  prefs: []
  type: TYPE_NORMAL
- en: The data stored in localStorage is organized by site, which means that can you
    can only access the data stored on your site. In the above figure, you can see
    the available sites (`http://localhost:4000`) on the left-hand side. On the right-hand
    side, you can explore the data that we have stored with the `setItem()` method
    for the given site.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the information from localStorage, you have to use the `getItem()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete an item from the store, we can use the `removeItem()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, localStorage only stores strings on it. However, we want
    to store objects, how do we do that?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops…that''s not what we expected. The localStorage automatically converts
    the object into string before storing the object. You can serialize objects with
    the `JSON.stringify()` function so that localStorage receives a string instead
    of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the stored object back, you can use the `JSON.parse()` inverse function
    that converts a string into an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is how you can store and retrieve objects from localStorage. You will need
    to encode and decode objects as you go. It is not recommended to store big objects
    in localStorage due to the heavy use of JSON functions; every time you encode
    or decode an object, the JavaScript thread will block that object.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone and localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To store Backbone models in localStorage, you can use the `ID` attribute as
    key and the serialized data as the value. However, remember that all the data
    in localStorage is mixed and this strategy will lead to identifier collisions.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that you have two different models (contacts and invoices) with the
    same `ID`; when you store one of them in the localStorage, it will overwrite the
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue with localStorage is that when you want to retrieve data from
    the store before getting an item from the store, you need to know which key does
    it have. However, in localStorage, we don't have a clue about what IDs are currently
    in the store, therefore, we need a way to keep track of the IDs that are in the
    store at a given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with these issues, you can create a well-known key in the store as
    an index of the IDs that are available for a given collection. See how it works
    in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To prevent collision between collections of models with the same ID, you can
    generate prefixed keys for the collection items so that instead of having number
    keys such as `1`, you can use keys such as `contacts-1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Store models in localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how to store and retrieve data from localStorage, it's time
    to store your models. In the following figure, you can see how to make data storage
    in local instead of a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when you call the `save()` method on a model Backbone, it transforms
    the action into an HTTP request for a RESTFul server. To store the data in local,
    you need to change the default behavior in order to use localStorage instead of
    making HTTP requests; you will learn how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the storage layer maintainable, you will need to create a Backbone
    driver for localStorage first. The responsibility of the driver is to store and
    retrieve data from localStorage so that the connection between Backbone and localStorage
    is simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Store models in localStorage](img/B01962_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 Store models in localStorage
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, I will show you how to construct the `DataStore` driver
    to store the Backbone models in localStorage.
  prefs: []
  type: TYPE_NORMAL
- en: Store Backbone models in localStorage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to use what you have learned about `localStorage` to store and retrieve
    objects. The `DataStore` object is responsible to transform models into strings
    to be stored in localStorage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The DataStore object needs a name to be used as a collection index prefix.
    The first use case is to create a new item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When a new model is created, it assigns a new ID with a `generateId()`function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `itemName()` function generates a key that is to be used in localStorage
    given the model ID; the `serialize()`method transforms a model into a JSON string
    that is ready to be stored in localStorage. Finally, the `index` attribute in
    DataStore tracks all the available IDs so that we should push the model ID in
    the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the update method, we will overwrite the current value of the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you call the `setItem()` method with an existent key on localStorage, the
    previous value is overwritten with the new one, the net effect is an update operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are looking for a model, you need to set the ID of the model and call
    the `fetch()` method on it in order to retrieve the data from a server. In our
    DataStore, we can call this operation `find`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find()` method is very simple, it tries to get the data from localStorege
    with an ID built with the `itemName()` method; if the model is not found, it will
    return a `null` value. While returning a single model is very simple, retrieving
    a list of them is a more complex operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This method loops over all the available keys for the given collection; for
    each item in the list, it converts it from string to a JSON object. All items
    are aggregated in a single array that returns as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove an item from DataStore, you will need to remove its value from localStorage
    and drop the index that is related to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `updateIndex()` method when the collection of models is altered
    in localStorage; it should store a list of IDs as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Model IDs are generated with the name of the collection and its ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `DataStore` class, by itself, can store and retrieve models from localStorage;
    however, it is not fully integrated with Backbone. In the next section, we will
    examine how Backbone stores and retrieves models from a RESTful API and how to
    change this behavior to use the `DataStore` driver.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone.sync
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is responsible to handle connections between a RESTful server and the
    Backbone application is the Backbone.sync module. It transforms the `fetch()`
    and `save()` operations into HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetch()` is mapped as a `read` operation. This will make `GET` to the the
    `urlRoot` attribute with the model ID for a model or the `url` attribute for a
    collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`save()` is mapped as a `create` or `update` operation; it depends on the `isNew()`
    method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will be mapped as `create` if the model does not have an ID (`isNew()`
    method return `true`). A POST request is executed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This will be mapped as `update` if the model already has an ID (`isNew()` method
    returns `false`). A PUT request is executed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destroy()` is mapped as a `delete` operation. This will make DELETE to the
    the `urlRoot` attribute with the model ID for a model or the `url` attribute for
    a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better understand how Backbone.sync does its job, consider the following
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can read in the Backbone documentation, `Backbone.sync` has the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the method is the operation that is to be issued (`read`, `create`, `update`,
    or `delete`). You can easily overwrite this function in order to redirect the
    requests to localStorage instead of a RESTful server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While the localStorage API is synchronous, it does not need to use callbacks
    or promises; however, in order to be compatible with the default implementation,
    we need to create a `Deferred` object and return a `promise`.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't know what a promise or `Deferred` objects are, please refer to
    the jQuery documentation for more information about it. The explanation of how
    promises work is out of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous `Backbone.sync` implementation is looking for a `dataStore` attribute
    in the models/collections. The attribute should be included in these objects in
    order to be stored correctly. As you may guess, it should be an instance of our
    DataStore driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The implementation that we made earlier for localStorage is inspired from the
    Backbone.localStorage plugin. If you want to store all your models in the browser,
    please use the plugin that has the support of the community.
  prefs: []
  type: TYPE_NORMAL
- en: Due the limitations of localStorage, it is not suitable to store avatar images
    on it as we will reach the limits with only a few records.
  prefs: []
  type: TYPE_NORMAL
- en: Using localStorage as cache
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Datastore driver is useful to develop small applications that do not need
    to fetch and store the data in a remote server. It can be enough to prototype
    small web applications or store configuration data in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, another use for the driver can be cache server response in order to
    speed up the application performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the application needs to read the data, it tries to read the data from
    localStorage first. If no model is found, it will use the original Backbone.sync
    function to fetch the data from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the server responds, it will store the response in localStorage for future
    use. To cache a server response, it should store the server response or drop the
    model from the cache when the model is deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Dropping the model from the cache is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To store and retrieve the data in the cache is more complex; you should have
    a cache expiration policy. For this project, we will expire the cached responses
    after 15 minutes, which means that we will remove the cached data and then make
    a `fetch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `fetchedAt` attribute is used to show the time we fetched the data from
    the server. When the cache expires, it removes the model from the cache and returns
    `null` to force a server `fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a model is cached, it should set the `fetchedAt` attribute for the first
    time when it is fetched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to replace the original Backbone.sync function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: IndexedDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you have seen in the previous sections, localStorage is very easy; however,
    it has the limitation of 5 MB of storage capacity. IndexedDB, on the other hand,
    does not have this limitation; however, it has a complex API. The main downside
    of IndexedDB is that it is not fully supported on all major browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![IndexedDB](img/B01962_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: Browser support for IndexedDB'
  prefs: []
  type: TYPE_NORMAL
- en: At the moment of writing this book, IndexedDB is fully supported by Chrome and
    Firefox, while Safari and IE have partial support.
  prefs: []
  type: TYPE_NORMAL
- en: A big difference between localStorage and IndexedDB is that IndexedDB is not
    a key/value store; IndexedDB has collections (tables) and a query API. If you
    have worked with MongoDB, you will be familiar with the way IndexedDB stores data.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with IndexedDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An IndexedDB database is composed of one or more stores. A store is like a JSON
    container, it contains a collection of JSON. If you have worked with SQL, then
    a store is like a table. If you have worked with MongoDB, a store is a like a
    collection. In the same way as MongoDB, IndexedDB is schemaless, which means that
    you don't need to define the schema of the records (JSONs).
  prefs: []
  type: TYPE_NORMAL
- en: One of the consequences of schemaless is that the data in the collections is
    not heterogeneous, you can have different types JSON objects in the same store.
    For example, you can store contact and invoice data in the same store.
  prefs: []
  type: TYPE_NORMAL
- en: 'IndexedDB is more flexible and powerful than localStorage; however, with great
    power comes great responsibility. You will have to deal with stores, cursors,
    indexes, transactions, migrations, and asynchronous API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started with IndexedDB](img/B01962_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: IndexedDB'
  prefs: []
  type: TYPE_NORMAL
- en: Database versions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Databases usually change with time; maybe a new feature needs a new store or
    adds an index. All IndexedDB databases have a version number. The first time that
    you create a new database, it starts with version 1\. With the help of each version
    number, you can define the stores and indexes as you need.
  prefs: []
  type: TYPE_NORMAL
- en: IndexedDB does not allow you to create new stores or indexes, unless you have
    changed the version number. When a new version number is detected, IndexedDB enters
    a `versionchange` state and calls the `onupgradedneeded()` callback, which you
    can use to modify the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time you change the version number, you have the opportunity to run database
    migrations in the `onupgradedneeded()` callback. Every time you open a connection
    with IndexedDB, you can specify a version number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The first time you open a database, IndexedDB enters the `versionchange` state
    and calls the `onupgradedneeded()`callback.
  prefs: []
  type: TYPE_NORMAL
- en: Creating stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create stores on IndexedDB, you need to put the database on the version
    change state, which you can do in the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the version number of the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the following example, we are creating a new database named library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When the `open()` method is called, it returns a request object that we can
    use to register the `onscuccess()`callback called when the database is successfully
    opened and is ready to be used. As we are creating a new database, the `onupgradeneeded()`callback
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database handler is in the `result` attribute of the `request` object.
    You can use the `createObjectStore()` method of the database handler in order
    to create a new store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument of the `createObjectStore()` method is the name of the store,
    in our example it is library. The `options` arguments should be a plain object
    where the available fields are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option name | Description | Default value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **autoIncrement** | This auto increments the `primary key` attribute | `false`
    |'
  prefs: []
  type: TYPE_TB
- en: '| **keyPath** | This is the attribute name in the objects that is to be used
    as `primary key` | `null` |'
  prefs: []
  type: TYPE_TB
- en: 'After the object store creation, a store handler is returned, which you can
    use to insert new records in the recently created object store. The `put()`method
    is used to insert new records in the store it accepts as argument the JSON to
    be stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating stores](img/B01962_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: IndexedDB in Google Chrome'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding image, the object store has the objects that
    we insert with the `put()` method in the `onupgradeneeded` event.
  prefs: []
  type: TYPE_NORMAL
- en: Delete a database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can always delete a database with the `deleteDatabse()` method. If you
    did something wrong and want to start over, just delete the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Add elements to an object store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have seen how to create and delete stores. Now, you will see how to connect
    to a database and add records to an object store outside of the `onupgradeneeded()`
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we are creating an IndexedDB transaction. The IndexedDB specification
    by W3C defines a transaction as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A transaction is used to interact with the data in a database. Whenever data
    is read or written to the database it is done by using a transaction.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Transactions offer some protection from application and system failures. A
    transaction may be used to store multiple data records or to conditionally modify
    certain data records. A transaction represents an atomic and durable set of data
    access and data mutation operations.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `transaction()`method of the `indexedDB` object has two arguments: scope
    and mode, as shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Description | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **scope** | The store or stores where the transaction interacts | ''books'',[''contacts'',
    ''invoices''] |'
  prefs: []
  type: TYPE_TB
- en: '| **mode** | This states what type of interaction will be done | ''readonly'',
    ''readwrite'' |'
  prefs: []
  type: TYPE_TB
- en: When the transaction is created, you can access the stores with the `objectStore()`method
    of the transaction object, which returns an object store handler that you can
    use to add or remove records.
  prefs: []
  type: TYPE_NORMAL
- en: The `put()` method is used to insert objects into the store; however, the method
    is asynchronous, which means that the records are not stored immediately like
    in localStorage. You should register an `oncomplete()` callback in the transaction
    object that will be called when the operations are done.
  prefs: []
  type: TYPE_NORMAL
- en: Performing queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To query the data in an object store, you need to open a `readonly` transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Queries are to be done by opening cursors with the `openCursor()` method. The
    first argument of the `openCursor()` method is a query that should be an `IDBKeyRange`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '`only(value)`: It looks for the value, such as an == operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lower(value)`: It looks for the values lower or equal to the value, such as
    a <= operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lowerOpen(value)`: It looks for values lower than the value, such as a < operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper(value)`: It looks for values greater than or equal to the value, such
    as a >= operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upperOpen(value)`: It looks for values greater than the value, such as a >
    operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are some of the queries that are available; please refer to the IndexedDB
    specification for a complete list of all the available queries. IndexedDB uses
    the query to compare the values that are passed as an argument with the objects
    in the store; however, which attribute in the store is compared? The answer is
    the key that is specified in `keyPath`. In our example, the `isbn` attribute will
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: The cursor will call the `onsuccess()` callback repeatedly for every object
    found, you should call the `continue()` method on the cursor object to fetch the
    next object. The result will be `null` when no more objects are found.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to query the objects by a different attribute, you should create
    indexes in the store for the attributes that you need. Use a different version
    number to add new indexes to the object stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding example, you can use an index to query objects.
    The same `onsuccess()` method is invoked every time that the index finds a result.
  prefs: []
  type: TYPE_NORMAL
- en: Delete objects in the store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To delete objects, you should call the `delete()` method in the object store
    with a query argument for these objects that you want to remove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: IndexedDB in Backbone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the IndexedDB API is more complex than localStorage, it will be more difficult
    to create an IndexedDB driver for Backbone as we did with localStorage; in this
    section, you will use what you have learned about IndexedDB in order to build
    a driver for Backbone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The driver should open a database and initialize the stores when it is created
    for the first time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When the connection is opened, it creates the contacts store and puts the first
    records in the store. After that it caches the database handler in the `db` attribute
    to reuse the connection for future requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we should create the necessary method to create, update, delete, and read
    the data from the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When a record is created, we should ensure that the model has an ID. We can
    generate it for the models that do not have an ID assigned. The `store()` method
    will put the record in the indexedDB database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `store()` method obtains the name of the store from the `modelstore` attribute
    and then, creates a `readwrite` transaction for the given store name to put the
    record on it. The `update()` method uses the same `store()` method to save the
    record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The update method does not assign an ID to the model, it completely replaces
    the previous record with the new model data. To delete a record, you can use the
    `delete()` method of the object store handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'To get all the models stored on an object store, you need to open a cursor
    and put all the items in an array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how this time the transaction opened is in the `readonly` mode. A single
    object can be obtained by querying the model ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way as we did with localStorage, this IndexedDB driver can be used
    to overwrite the `Backbone.sync` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, models should add the `store` attribute to indicate in which object store
    the model will be saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'IndexedDB allows you to store more data than localStorage; therefore, you can
    use it to store the avatar image too. Just make sure that the `avatar` attribute
    is set so that an image is always selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not try to upload the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have learned two ways to store data in the browser and use them as a replacement
    for a RESTful API server. The localStorage method has a simple API and it is widely
    supported for all major browsers; this is going to be your first choice if you
    want support old browsers; however, it has the limitation that you can only store
    five megabytes.
  prefs: []
  type: TYPE_NORMAL
- en: IndexedDB is powerful; however, its API is more complicated than localStorage.
    You need to learn some concepts before you start working with it. Once you know
    how it works, you should write your app asynchronously.
  prefs: []
  type: TYPE_NORMAL
