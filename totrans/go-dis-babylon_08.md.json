["```js\n\nvar scriptLoaded = new Promise(\n    (resolve, reject) =>\n        $.getJSON(routeDataURL)\n            .done(d => resolve(d))\n);\n```", "```js\n\nvar createScene = async function () {\n    var routeJSON = await scriptLoaded;\n    var scene = new BABYLON.Scene(engine);\n    const run = await drive(scene, routeJSON);\n    run();\n    return scene;\n};\n```", "```js\n\nawait loadAssets();\ninitializeDrivingPhase();\ninitializeGui();\nreturn run;\n```", "```js\n\nlet path3d = new Path3D(pathPoints.map(p => p.position),\n  new Vector3(0, 1, 0), false, false);\nlet curve = path3d.getCurve();\n```", "```js\n\nlet pathA = [];\nlet pathB = [];\nlet pathC = [];\nlet pathD = [];\nfor (let i = 0; i < pathPoints.length; i++) {\n    const { position, gravity, velocity } = pathPoints[i];\n    let p = position;\n    let speed = velocity.length();\n    let pA = new Vector3(p.x+speed, p.y-speed, p.z+speed);\n    let pB = new Vector3(p.x-speed, p.y-speed, p.z-speed);\n    let pC = pB.clone().addInPlaceFromFloats(0, speed * 2,\n      0);\n    let pD = pA.clone().addInPlaceFromFloats(0, speed * 2,\n      0);\n    pathA.push(pA);\n    pathB.push(pB);\n    pathC.push(pC);\n    pathD.push(pD);\n}\n```", "```js\n\nconst NUM_SEGMENTS = 24;\nlet paths = [];\nfor (let i = 0; i < NUM_SEGMENTS; i++) {\n    paths.push([]);\n}\n```", "```js\n\nfor (let i = 0; i < pathPoints.length; i++) {\n    let { position, velocity } = pathPoints[i];\n    const last = position;\n    for (let pathIdx = 0; pathIdx < NUM_SEGMENTS;\n      pathIdx++) {\n        let radiix = (pathIdx / NUM_SEGMENTS) *\n          Scalar.TwoPi;\n        let speed = velocity.length();\n        let path = paths[pathIdx];\n        let pathPoint = last.clone().addInPlaceFromFloats(\n            Math.sin(radiix) * speed * 2,\n            Math.cos(radiix) * speed, 0);\n        path.push(pathPoint);\n    }\n}\n```", "```js\n\nreturn Promise.all([nodeMatProm, truckLoadProm])\n          .then(v => console.log('finished loading\n            assets'));\n```", "```js\n\nconst nodeMatProm = NodeMaterial.ParseFromSnippetAsync\n  (radarNodeMatSnippet, scene)\n      .then(nodeMat => {\n         radarTexture = nodeMat.createProceduralTexture(\n         radarTextureResolution, scene);\n      });\n```", "```js\n\nconst { \n        truckModelName, \n        truckModelScaling, \n        radarTextureResolution } = gameData;\n```", "```js\n\nconst truckLoadProm = SceneLoader.ImportMeshAsync\n  (truckModelName, truckModelURL, \"\", scene)\n    .then((result) => {\n        let { meshes } = result;\n        let m = meshes[1];\n        truckModel = m;\n        truckModel.setParent(null);\n        meshes[0].dispose();\n        truckModel.layerMask = SCENE_MASK;\n        truckModel.rotation = Vector3.Zero();\n        truckModel.position = Vector3.Zero();\n        truckModel.scaling.setAll(truckModelScaling);\n        truckModel.bakeCurrentTransformIntoVertices();\n        m.refreshBoundingInfo();\n    }).catch(msg => console.log(msg));\n```", "```js\n    var cameraDolly = new TransformNode(\"dolly\", scene);\n    ```", "```js\n    for (var k in followCamSetup) {\n        followCamera[k] = followCamSetup[k];\n    }\n    ```", "```js\n            cameraDolly.parent = truckModel;\n            followCamera.parent = cameraDolly;\n    ```", "```js\n\nvar groundMat = new GridMaterial(\"roadMat\", scene);\nvar ground = MeshBuilder.CreateRibbon(\"road\", {\n    pathArray: route.paths,\n    sideOrientation: Mesh.DOUBLESIDE\n}, scene);\nground.layerMask = SCENE_MASK;\nground.material = groundMat;\nground.visibility = 0.67;\nground.physicsImpostor = new PhysicsImpostor(ground,\n    PhysicsImpostor.MeshImpostor,\n    {\n        mass: 0,\n        restitution: 0.25\n    }, scene);\n```", "```js\n\nconst curve = route.path3d.getPointAt(0);\nconst curveTan = route.path3d.getTangentAt(0);\ntruckModel.position.copyFrom(curve);\ntruckModel.rotationQuaternion =\n  Quaternion.FromLookDirectionRH(curveTan, truckModel.up);\ntruckModel.physicsImpostor.setAngularVelocity(currAngVel);\ntruckModel.physicsImpostor.setLinearVelocity(currVelocity);\n```", "```js\n\nif (keyMap['KeyW']) {\n    currVelocity.addInPlace(currDir.scale(currAccel));\n}\nelse if (keyMap['KeyS']) {\n    currVelocity.addInPlace(currDir.scale(currAccel)\n        .negateInPlace());\n}\n```", "```js\n\nlet left = Vector3.Cross(currDir, truckModel.up);\ncurrVelocity.addInPlace(left.scale(currAccel / 2));\n```", "```js\n\nlinVel.addInPlace(currVelocity);\ntruckModel.physicsImpostor.setLinearVelocity(linVel);\nangVel.addInPlace(currAngVel);\ncurrVelocity.setAll(0);\ncurrAngVel.setAll(0);\n// dampen any tendencies to pitch, roll, or yaw from\n   physics effects\nangVel.scaleInPlace(0.987);\ntruckModel.physicsImpostor.setAngularVelocity(angVel);\n```", "```js\n\nconst initializeEnvironment = (screen) => {\n    const { scene } = screen;\n    var light = new HemisphericLight(\"light\", new\n      Vector3(0, 1, 0), scene);\n    light.intensity = 1;\n    var skyTexture = new CubeTexture(envTextureUrl, scene);\n    skyTexture.coordinatesMode = Texture.SKYBOX_MODE;\n    scene.reflectionTexture = skyTexture;\n    var skyBox = scene.createDefaultSkybox(skyTexture,\n      false, skyBoxSize);\n    skyBox.layerMask = SCENE_MASK;\n    screen.environment = { skyBox, light, skyTexture };\n    return screen.environment;\n};\nexport default initializeEnvironment;\n```", "```js\n\nthis._routePlanningScene.routeAcceptedObservable.add(() \n  => {\n    const routeData = this._routePlanningScene.routePath;\n    this.goToDrivingState(routeData);\n});\n```", "```js\n\ngoToDrivingState(routeData) {\n    this._engine.displayLoadingUI();\n    routeData = routeData ??\n      this._routePlanningScene.routePath;\n    this._currentScene?.actionProcessor?.detachControl();\n    this._engine.loadingUIText = \"Loading Driving\n      Screen...\";\n    this._drivingScene = new SpaceTruckerDrivingScreen\n      (this._engine, routeData, this.inputManager);     \n    this._currentScene = this._drivingScene;\n    this._routePlanningScene.dispose();\n    this._routePlanningScene = null;\n    this.moveNextAppState(AppStates.DRIVING);\n    this._currentScene.actionProcessor.attachControl();\n}\n```", "```js\n\ndispose() {\n    this.soundManager.dispose();\n    this.onStateChangeObservable.clear();\n    this.routeAcceptedObservable.clear();\n    this.encounterManager.dispose();\n    this.scene.dispose();\n}\n```", "```js\n\nconst queryString = window.location.search;\nif (queryString.includes(\"testDrive\")) {\n    this.goToDrivingState(sampleRoute);\n}\n```", "```js\n\nupdate(deltaTime) {\n        const dT = deltaTime ?? \n          (this.scene.getEngine().getDeltaTime() / 1000);\n        this.actionProcessor?.update();\n        if (this.isLoaded) {\n            this.truck.update(dT);\n        }\n    }\n```", "```js\n\nconst inputMapPatches = {\n    w: \"MOVE_IN\", W: \"MOVE_IN\",\n    s: \"MOVE_OUT\", S: \"MOVE_OUT\",\n    ArrowUp: 'MOVE_UP',\n    ArrowDown: 'MOVE_DOWN',\n    ArrowLeft: 'ROTATE_LEFT',\n    ArrowRight: 'ROTATE_RIGHT'\n};\nSpaceTruckerInputManager.patchControlMap(inputMapPatches);\n```", "```js\n\nstatic patchControlMap(newMaps) {\n    tempControlsMap = Object.assign({}, controlsMap);\n    Object.assign(controlsMap, newMaps);\n}\nstatic unPatchControlMap() {\n    controlsMap = tempControlsMap;\n    tempControlsMap = {};\n}\n```", "```js\n\nconst cargoData = this.cargo.lastFlightPoint;\ncargoData.encounter = encounter;\n```", "```js\n\n// temporary until the encounter spawner is implemented\nthis.tempObstacleMesh = CreateSphere(\"tempObstacle\",\n  this.scene);\nthis.tempObstacleMesh.visibility = 1;\nthis.tempObstacleMesh.layerMask = 0;\n```", "```js\n\nlet point = pathPoints[seed];\nlet {encounter, position, gravity, velocity} = point;\nlet encounterMesh = tempObstacleMesh.createInstance\n  (encounter.id + '-' + seed);\n```", "```js\n\nlet guiCamera = new UniversalCamera(\"guiCam\", new\n  Vector3(0, 50, 0), scene);\n    guiCamera.layerMask = GUI_MASK;\n    guiCamera.viewport = new Viewport(0, 0, 1 - 0.6, \n      1 - 0.6);\n    guiCamera.mode = UniversalCamera.ORTHOGRAPHIC_CAMERA;\n    guiCamera.orthoTop = guiViewportSize / 2;\n    guiCamera.orthoRight = guiViewportSize / 2;\n    guiCamera.orthoLeft = -guiViewportSize / 2;\n    guiCamera.orthoBottom = -guiViewportSize / 2;\n    scene.activeCameras.push(guiCamera);\n```", "```js\n\nlet radarMesh = MeshBuilder.CreatePlane(\"radarMesh\", \n  { width: guiViewportSize, height: guiViewportSize },\n  scene);\nradarMesh.layerMask = GUI_MASK;\nradarMesh.rotation.x = Math.PI / 2;\n//...\nlet radarGui =\n  AdvancedDynamicTexture.CreateForMeshTexture(radarMesh,\n  radarTextureResolution, radarTextureResolution, false);\n```", "```js\n\nradarMesh.material = radarMaterial;\nradarMaterial.diffuseTexture = radarGui;\n```", "```js\n\nencounters.forEach((o, i) => {\n    let blip = new Rectangle(\"radar-obstacle-\" + i);\n    o.uiBlip = blip;\n    blip.width = \"3%\";\n    blip.height = \"3%\";\n    blip.background = \"white\";\n    blip.color = \"white\";\n    blip.cornerRadius = \"1000\";\n    radarGui.addControl(blip);\n});\nvar gl = new GlowLayer(\"gl\", scene, { blurKernelSize: 4,\n  camera: guiCamera });\n```", "```js\n\nlet r = Vector3.Distance(obstacle.absolutePosition,\n  absolutePosition);\nlet theta = Vector3.GetAngleBetweenVectorsOnPlane\n  (absolutePosition, up, obstacle.absolutePosition);\n```", "```js\n\nlet posLeft = Math.cos(theta) * r;\nlet posTop = -1 * Math.sin(theta) * r;\nuiBlip.left = posLeft * 4.96 - (r * 0.5);\nuiBlip.top = posTop * 4.96 - (r * 0.5);\n```"]