<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Securing the Application</h1>
                </header>
            
            <article>
                
<p>Once deployed in production, an application is exposed to a large number of requests. Inevitably, some of them will be malicious. This brings the requirement of granting explicit access permissions only to authenticated users, that is, authenticating a selected number of consumers to have access to your service. Most of the consumers will use the service only for data provisioning. However, a few will need to be able to provide new, or modify the existing, catalog data. To ensure that only appropriate consumers will be able to execute the <kbd>POST</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> requests, we will have to introduce the concept of authorization into our application, which will grant only explicitly selected users modification permissions.</p>
<p>Data services may provide sensitive private information, such as email addresses; the HTTP protocol, being a text protocol, may not be secure enough. The information transmitted through it is subject to <strong>man-in-the-middle</strong> attacks, which can lead to data leakage. To prevent such cases, <strong>Transport Layer Security </strong>(<strong>TLS</strong>) should be used. The HTTPS protocol encrypts the transmitted data, ensuring that only appropriate consumers who have the right decryption key will be able to consume the data exposed by the service.</p>
<p>In this chapter, we will look at how Node.js enables the following security features:</p>
<ul>
<li>Basic authentication</li>
<li>Passport-based basic authentication</li>
<li>Passport-based third-party authentication</li>
<li>Authorization</li>
<li>Transport layer security</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authentication</h1>
                </header>
            
            <article>
                
<p>An application considers a user authenticated when their identity has been successfully validated against a trusted store. Such trusted stores can <span>either </span>be any kind of specially maintained database, storing the credentials of the application (basic authentication), or a third-party service that checks a given identity against its own trusted store (third-party authentication).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Basic authentication</h1>
                </header>
            
            <article>
                
<p>HTTP basic authentication is one of the most popular and straightforward authentication mechanisms available out there. It relies on HTTP headers in the request, which provide the user's credentials. Optionally, the server may reply with a header, forcing the clients to authenticate themselves. The following diagram shows a client-server interaction when basic authentication is carried out:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/5d1da2ce-4ecb-44c8-b8cb-bbfc01a8a690.png" style="width:26.42em;height:31.92em;" width="536" height="650"/></div>
<p>Whenever an HTTP request is sent to an endpoint secured by HTTP basic authentication, the server replies with an HTTP <kbd>401 Unauthorized</kbd> status code, and, optionally, with a <kbd>WWW-Authenticate</kbd> header. This header forces the client to send another request, containing the <kbd>Authorization</kbd> header, which specifies that the authentication method is <kbd>basic</kbd>. This request is followed by a base64-encoded key/value pair, providing the username and the password to authenticate with. Optionally, the server can specify a message to the client with the <kbd>realm</kbd> attribute.</p>
<p>This attribute specifies that resources sharing the same <kbd>realm</kbd> value should support the same authentication means. In the preceding diagram, the <kbd>realm</kbd> message is <kbd>MyRealmName</kbd>. The client authenticates by sending the <kbd>Authentication</kbd> header with the value of <kbd>Basic YWRtaW46YWRtaW4</kbd>, specifying that <kbd>Basic</kbd> authentication is used, followed by the base64-encoded value. In the diagram, the literal <kbd>YWRtaW46YWRtaW4</kbd> decoded in base64 represents the <kbd>admin:admin</kbd> <span>literal. </span>In case such a username/password combination is successfully authenticated, the HTTP server will respond with the JSON payload of the requested items. If the authentication fails, the server will respond with the <kbd>401 Unauthorized</kbd> <span>status code, </span>but this time without including the <kbd>WWW-Authenticate</kbd> header.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passport</h1>
                </header>
            
            <article>
                
<p>There are plenty of authentication methods to choose from nowadays. Perhaps the most popular methods are basic authentication, where each user has their own username and password, and third-party authentication, where users can identify themselves with their already-existing account for an external public service, such as personal social services such as LinkedIn, Facebook, and Twitter.</p>
<p>Choosing the most appropriate type of authentication for a web API depends mainly on its consumers. Apparently, an application consuming an API to fetch data is not likely to authenticate with a personal social account. This approach is more suitable when the API is used via a frontend directly by a human being.</p>
<p>Implementing a solution capable of switching between different authentication methods easily is a complex and time-consuming task. In fact, it can become hardly possible if not considered at the initial design phase of an application.</p>
<p><strong>Passport</strong> is a piece of authentication middleware for Node.js, created especially for use-cases where the means of authentication should be easily switched from one to another. It has modular architecture that enables the usage of a specific authentication provider, called <strong>strategy</strong>. The strategy takes care of implementing a chosen authentication approach.</p>
<p>There are plenty of authentication strategies to choose from, for example, a regular basic authentication strategy or social platform-based strategies for services such as Facebook, LinkedIn, and Twitter. Refer to the official Passport website, <span class="URLPACKT"><a href="http://www.passportjs.org/">http://www.passportjs.org/</a></span>, for a complete list of the available strategies.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passport's basic authentication strategy</h1>
                </header>
            
            <article>
                
<p>Now it is time to look at how to utilize Passport's strategies; we will start with the basic authentication strategy; it is a logical choice now that we know how basic authentication works.</p>
<p>As usual, we will start by installing the relevant modules with the NPM package manager. We will need the <kbd>passport</kbd> module, which provides the base functionality that allows you to plug in different authentication strategies, and a concrete strategy for basic authentication, provided by the <kbd>passport-http</kbd> module:</p>
<pre>  <strong>npm install passport</strong>
  <strong>npm install passport-http</strong></pre>
<p>Next, we have to instantiate both the Passport middleware and the basic authentication strategy. <kbd>BasicStrategy</kbd> takes as an argument a callback function, which checks whether the provided username/password combination is valid. Finally, passport's authenticate method is provided as a middleware function to the express route, assuring that unauthenticated requests will be rejected with an appropriate <kbd>401 Unauthorized</kbd> status:</p>
<pre>const passport = require('passport');<br/>const BasicStrategy = require('passport-http').BasicStrategy;<br/><br/>passport.use(new BasicStrategy(function(username, password, done) {<br/>  if (username == 'user' &amp;&amp; password=='default') {<br/>    return done(null, username);<br/>  }<br/>}));<br/><br/>router.get('/v1/', <br/>  passport.authenticate('basic', { session: false }), <br/>     function(request,    response, next) {<br/>       catalogV1.findAllItems(response);<br/>});<br/>router.get('/v2/', <br/>  passport.authenticate('basic', { session: false }), <br/>     function(request,    response, next) {<br/>       catalogV1.findAllItems(response);<br/>});<br/><br/>router.get('/', <br/>  passport.authenticate('basic', { session: false }), <br/>     function(request,    response, next) {<br/>       catalogV1.findAllItems(response);<br/>});</pre>
<p>The <kbd>BasicStrategy</kbd> constructor takes a handler function as an argument. It gives us access to the username and password supplied by the client, and to the Passport middleware's <kbd>done()</kbd> function, which notifies Passport with whether the user has been successfully authenticated. Invoke the <kbd>done()</kbd> function with <kbd>user</kbd> as an argument in order to grant authentication, or pass the <kbd>error</kbd> argument to it to revoke the authentication:</p>
<pre>passport.use(new BasicStrategy(
function(username, password, done) {
  AuthUser.findOne({username: username, password: password}, 
    function(error, user) {
      if (error) {
        return done(error);
      } else {
        if (!user) {
          console.log('unknown user');
          return done(error);
        } else {
          console.log(user.username + ' 
          authenticated successfully');
          return done(null, user);
        }
      }
    });  
  })
); </pre>
<p>Finally, use the <kbd>passort</kbd> <kbd>authenticate()</kbd> function in the router middleware to attach it to a specific HTTP method-handler function.</p>
<p>In our case, we specify that we don't want to store any authentication details in a session. This is because, when using basic authentication, there is no need to store any user information in a session, as each request contains the <kbd>Authorization</kbd> header that provides the login details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passport's OAuth Strategy</h1>
                </header>
            
            <article>
                
<p>OAuth is an open standard for third party authorization, it defines a delegation protocol used fer authorizing against a third party authentication providers. OAuth uses special tokens, once issued,  identify the user instead of user credentials. Let's look closer at OAuth workflow, with a sample scenario. The main actors in the scenario are - a <strong>user</strong> interacting with a <strong>web application,</strong> which consumes a restful service from a <strong>back-end</strong> system  providing some kind of data. The web application delegates its authorization to a separate <strong>third-party authorization server.</strong></p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/75f57608-98ed-4992-994a-8398fea14145.png" style="width:33.83em;height:23.50em;" width="1358" height="992"/></div>
<ol>
<li>The user requests a web application which requires authentication to establish communication with the back-end service. This is the initial request thus the user is still not authenticated, so they get redirected to a login page asking for their credentials for the relevant third party account.</li>
<li>After a successful authentication an authorization code is issued by the authentication server to the web application. This authorization code is a composite combination between an issued client-id and a secret issued by the provider. They should be sent from a web application to the authentication server and is exchanged for an access token that has a limited lifetime.</li>
<li>The Web application uses the authentication token for authentication until it gets expired. Afterwards it has to request a new token using the authorization code.</li>
</ol>
<p>Passport.js hides the complexity behind this process with a separate strategy module automating the OAuth workflow. It is available in the <kbd>npm</kbd> repository</p>
<pre>npm install passport-oauth</pre>
<p>Create an instance of the strategy and supply it with the urls for requesting tokens and for authenticating it together, it is your personal consumer key and a secret phrase of your choice.</p>
<pre><span class="keyword">var</span> passport = <span class="built_in">require</span>(<span class="string">'passport'</span>)
  , OAuthStrategy = <span class="built_in">require</span>(<span class="string">'passport-oauth'</span>).OAuthStrategy;

passport.use(<span class="string">'provider'</span>, <span class="keyword">new</span> OAuthStrategy({
    <span class="attr">requestTokenURL</span>: <span class="string">'https://www.provider.com/oauth/request_token'</span>,
    <span class="attr">accessTokenURL</span>: <span class="string">'https://www.provider.com/oauth/access_token'</span>,
    <span class="attr">userAuthorizationURL</span>: <span class="string">'https://www.provider.com/oauth/authorize'</span>,
    <span class="attr">consumerKey</span>: <span class="string">'123-456-789'</span>,
    <span class="attr">consumerSecret</span>: <span class="string">'secret'</span>
    callbackURL: <span class="string">'https://www.example.com/auth/provider/callback'</span>
  }, <span class="function"><span class="keyword">function</span>(<span class="params">token, tokenSecret, profile, done</span>) </span>{  <br/>    //lookup the profile and authenticate   and call done
  }
));</pre>
<p>Passport.js provides separate strategy wrapping different providers, like linkedin or github. They ensure that your application stays up to date with the token issuing URLs. Once you have made up your mind about the provider you want to support, you should check for specific strategies for them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Passport's third-party authentication strategies</h1>
                </header>
            
            <article>
                
<p>Today, almost everyone owns at least one personal public social media account, such as Twitter, Facebook, and LinkedIn. Recently, it has become really popular for websites to allow their visitors to authenticate themselves via one of their social accounts by just clicking on an icon to bind their social service account to a service-internal automatically generated account.</p>
<p>This approach is very convenient for web users who are <span>usually </span>permanently logged into at least one of their accounts. If they are not currently logged in, clicking on an icon will redirect them to their social service login page, and, after a successful login, another redirection takes place, ensuring that the user gets the content they originally requested. When it comes to exposing data via a web API, this approach is not really an option.</p>
<p>Publicly exposed APIs cannot predict whether they are to be consumed by a human or by an application. Also, APIs aren't usually consumed directly by humans. Thus, third-party authentication is the only option when you, as API authors, are convinced that the exposed data will be directly <span>available </span>to the end users who have requested it manually through a frontend from an internet browser. Once they have successfully logged into their social account, a unique user identifier will be stored in a session, so your service will need to be able to handle such sessions appropriately.</p>
<p>To enable session support for storing user login information with Passport and Express, you have to initialize the Express session middleware before initializing Passport and its session middleware:</p>
<pre>app.use(express.session()); 
app.use(passport.initialize()); 
app.use(passport.session()); </pre>
<p>Then, specify the user whose details Passport should serialize/deserialize into or out of the session. For that purpose, Passport provides the <kbd>serializeUser()</kbd> and <kbd>deserializeUser()</kbd> functions, which store complete user information in a session:</p>
<pre>passport.serializeUser(function(user, done) { done(null, user); }); passport.deserializeUser(function(obj, done) { done(null, obj); });</pre>
<div class="packt_infobox">The order of initializing the session handling of the Express and Passport middleware is important. The Express session should be passed to the application first and should be followed by the Passport session.</div>
<p>After enabling session support, you have to decide which third-party authentication strategy to rely on. Basically, third-party authentication is enabled via a plugin or application created by the third-party provider, for example, a social service site. We will briefly look at creating a LinkedIn application that allows authentication via the OAuth standard.</p>
<p>Usually, this is done via a pair of public key and a secret (token) associated with the social media application. Creating a LinkedIn application is easy—you just have to log into <span class="URLPACKT"><a href="http://www.linkedin.com/secure/developer">http://www.linkedin.com/secure/developer</a></span> and fill out a brief application information form. You will be given a secret key and a token to enable the authentication. Perform the following steps to enable LinkedIn authentication:</p>
<ol>
<li>
<p>Install the <kbd>linkedin-strategy</kbd> module—<kbd>npm install linkedin-strategy</kbd></p>
</li>
</ol>
<ol start="2">
<li>
<p>Get an instance of the LinkedIn strategy and initialize it to the Passport middleware by the <kbd>use()</kbd> function after session support has been enabled:</p>
</li>
</ol>
<pre>      var passport = require('passport')
        , LinkedInStrategy = require('passport-
        linkedin').Strategy;

        app.use(express.session());
        app.use(passport.initialize());
        app.use(passport.session());

      passport.serializeUser(function(user, done) {
        done(null, user);
      });

      passport.deserializeUser(function(obj, done) {
        done(null, obj);
      });

        passport.use(new LinkedInStragety({
          consumerKey: 'api-key',
          consumerSecret: 'secret-key',
          callbackURL: "http://localhost:3000/catalog/v2"
        },
          function(token, tokenSecret, profile, done) {
            process.nextTick(function () {
              return done(null, profile);
            });
          })
        ); </pre>
<ol start="3">
<li>
<p>Explicitly s<span>pecify </span>that the LinkedIn strategy should be used as Passport for each individual route, ensuring that session handling is enabled:</p>
</li>
</ol>
<pre>      router.get('/v2/', 
        cache('minutes',1), 
        passport.authenticate('linked', { session: true}), 
        function(request, response) {
          //...
        }
      });</pre>
<ol start="4">
<li>
<p>Provide a means for a user to log out by exposing a logout URI, making use of <kbd>request.logout</kbd>:</p>
</li>
</ol>
<pre>      router.get('/logout', function(req, res){
      request.logout();
        response.redirect('/catalog');
      });
 </pre>
<div class="packt_infobox">The given third-party URLs and service data are subject to change. You should always refer to the service policy when providing third-party authentication.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Authorization</h1>
                </header>
            
            <article>
                
<p>So far, the catalog data service uses basic authentication to protect its routes from unknown users; however, a catalog application should allow only few white-listed users to modify the items inside the catalog. To restrict access to the catalog, we will introduce the concept of authorization, that is, a subset of authenticated users, with appropriate permission allowed.</p>
<p>When Passport's <kbd>done()</kbd> function is invoked to authenticate a successful login, it takes as an argument a <kbd>user</kbd> instance of the user that has been granted authentication. The <kbd>done()</kbd> function adds that user model instance to the <kbd>request</kbd> object, and, in this way, provides access to it via the <kbd>request.user</kbd> property, after successful authentication. We will make use of that property to implement a function performing the authorization check after successful authentication:</p>
<pre>function authorize(user, response) {
  if ((user == null) || (user.role != 'Admin')) {
    response.writeHead(403, { 'Content-Type' : 
    'text/plain'});
    response.end('Forbidden');
    return;
  }
} </pre>
<div class="packt_infobox">The HTTP 403 Forbidden status code can be easily confused with 405 Not allowed. However, the 405 Not Allowed <span>status code </span>indicates that a specific HTTP verb is not supported by the requested resource, so it should be used only in that context.</div>
<p>The <kbd>authorize()</kbd> function will close the <kbd>response</kbd> stream, returning the <kbd>403 Forbidden</kbd> <span>status code, </span>which indicates that the logged-in user is recognized but has insufficient permissions. This revokes access to the resource. This function has to be used in each route that carries out data manipulation.</p>
<p>Here's an example of how a <kbd>post</kbd> route implements authorization:</p>
<pre>app.post('/v2', 
  passport.authenticate('basic', { session: false }), 
    function(request, response) {
      authorize(request.user, response);
      if (!response.closed) {
        catalogV2.saveItem(request, response);
      }
    }
); </pre>
<p>After <kbd>authorize()</kbd> is invoked, we check whether the <kbd>response</kbd> object still allows writing to its output by checking the value of the closed property of the <kbd>response</kbd> object. It will return <kbd>true</kbd> once the end function of the <kbd>response</kbd> object has been called, which is exactly what the <kbd>authorize()</kbd> function does when the user lacks admin permissions. Thus, we can rely on the closed property in our implementation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Transport layer security</h1>
                </header>
            
            <article>
                
<p>Publicly available information in the web easily becomes the subject of different types of cyber attacks. Often it is not enough just to keep the so-called "bad guys" out. Sometimes, they won't bother gaining authentication at all and may prefer to carry out a <strong>man-in-the-middle</strong> (<strong>MiM</strong>) attack, pretending to be the final receiver of a message and sniffing the communication channel that transmits the data<span class="_Tgc">—</span>or, even worse, altering the data while it flows.</p>
<p>Being a text-based protocol, HTTP transfers data in a human-readable format, which makes it an easy victim of MiM attacks. Unless transferred in an encrypted format, all the catalog data of our service is vulnerable to MiM attacks. In this section, we will switch our transport from an insecure HTTP protocol to the secure HTTPS protocol.</p>
<p>HTTPS is secured by asymmetric cryptography, also known as <strong>public-key encryption</strong>. It is based on a pair of keys that are mathematically related. The key used for encryption is called <strong>public key</strong>, and the key used for decryption is called <strong>private key</strong>. The idea is to freely provide the encryption key to partners who have to send encrypted messages and to perform decryption with the private key.</p>
<p>A typical public-key encryption communication scenario between two parties, <em>A</em> and <em>B</em>, will be the following:</p>
<ol>
<li>
<p>Party <em>A</em> composes a message, encrypts it with Party B's public key, and sends it</p>
</li>
<li>
<p>Party <em>B</em> decrypts the message with its own private key and processes it</p>
</li>
<li>
<p>Party <em>B</em> composes a response message, encrypts it with Party <em>A</em>'s public key, and then sends it</p>
</li>
<li>
<p>Party <em>A</em> decrypts the response message with its own private key</p>
</li>
</ol>
<p>Now that we know how public-key encryption works, let's go through a sample of HTTPS client-server communication, as shown in this diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/7e9cca56-58bb-4d83-ac09-b630c429fe3a.png" style="width:38.50em;height:35.08em;" width="747" height="681"/></div>
<p>The client sends an initial request against an SSL-secured endpoint. The server responds to that request by sending its public key to be used for encrypting further incoming requests. Then, the client has to check the validity and verify the identity of the received key. After successful verification of the server's public key, the client has to send its own public key back to the server. Finally, after the key exchange procedure is complete, the two parties can start communicating securely.</p>
<p>HTTPS relies on trust; thus, it is vital to have a reliable way of checking whether a specific public key belongs to a specific server. Public keys are exchanged within an X.509 certificate, which has a hierarchical structure. This structure enables clients to check whether a given certificate has been generated from a trusted root certificate. Clients should trust only certificates that have been issued by a known <strong>certificate authority</strong> (<strong>CA</strong>).</p>
<p>Before switching our service to use the HTTPS transport, we need a public/private key pair. Since we are not a certificate authority, we will have to use OpenSSL tooling to generate test keys for us.</p>
<p>OpenSSL is available for download at <span class="URLPACKT"><a href="http://www.openssl.org/">http://www.openssl.org/</a></span>, where source code distributions are available for all popular operating systems. OpenSSL can be installed as follows:</p>
<ol>
<li>
<p>Binary distribution is available for download for Windows, and Debian and Ubuntu users can make use of the packaged distribution by executing the following:</p>
</li>
</ol>
<pre style="padding-left: 60px"><strong>sudo apt-get install openssl</strong></pre>
<div class="packt_infobox">Windows users will have to set an environment variable, OPENSSL_CNF, specifying the location of the <kbd>openssl.cnf</kbd> configuration file, typically located in the share directory in the installation archive.</div>
<ol start="2">
<li>
<p>Now let's generate a test key/value pair with OpenSSL:</p>
</li>
</ol>
<pre style="padding-left: 60px"><strong>opensslreq -x509 -nodes -days 365 -newkey rsa:2048-keyoutcatalog.pem -out catalog.crt</strong></pre>
<p class="mce-root"/>
<p>OpenSSL will prompt some details required for generating the certificate, such as country code, city, and fully qualified domain name. Afterward, it will generate a private key in the <kbd>catalog.pem</kbd> file and a public key certificate that will be valid for a year in the <kbd>catalog.crt</kbd> file. We will be using these newly generated files, so copy them into a new subdirectory, called <kbd>ssl</kbd>, in the catalog data service directory.</p>
<p>Now we have everything needed to modify our service to use HTTPS:</p>
<ol>
<li>
<p>First, we need to switch and use the HTTPS module instead of HTTP and specify the port that we want to use to enable HTTPS communication:</p>
</li>
</ol>
<pre style="padding-left: 60px">var https = require('https');
var app = express();
app.set('port', process.env.PORT || 3443); </pre>
<ol start="2">
<li>
<p>Then, we have to read the private key from the <kbd>catalog.cem</kbd> file and the certificate from <kbd>catalog.crt</kbd> into an array:</p>
</li>
</ol>
<pre style="padding-left: 60px" class="mce-root">var options = {key : fs.readFileSync('./ssl/catalog.pem'),
                cert : fs.readFileSync('./ssl/catalog.crt')<br/>}; </pre>
<ol start="3">
<li>
<p>Finally, we pass the array containing the key pair to the HTTPS instance when creating the server and start listening through the specified port:</p>
</li>
</ol>
<pre style="padding-left: 60px">https.createServer(options, app).listen(app.get('port'));</pre>
<p>That's all you need to do to enable HTTPS for an Express-based application. Save your changes and give it a try by requesting <kbd>https://localhost:3443/catalog/v2</kbd> in a browser. You will be shown a warning message informing you that the server you are connecting to is using a certificate that is not issued by a trusted certificate authority. That's normal, as we generated the certificate on our own, and we are not a CA for sure, so just ignore that warning.</p>
<div class="packt_infobox">Before deploying a service on a production environment, you should always ensure that you use a server certificate issued by a trusted CA.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Self-test questions</h1>
                </header>
            
            <article>
                
<p>Go through the following questions:</p>
<ul>
<li>
<p>Is HTTP basic authentication secure against man-in-the-middle attacks?</p>
</li>
<li>
<p>What are the benefits of Transport Layer Security?</p>
</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to protect exposed data by enabling a means of authentication and authorization. This is a critical aspect of any publicly available data service. In addition, you learned how to prevent man-in-the-middle attacks using the secured layer transport protocol between a service and its users. As a developer of such services, you should always consider the most appropriate security features that your application should support.</p>
<p>I hope this was a useful experience! You gained enough knowledge and practical experience, which should have made you much more confident in understanding how RESTful APIs work and how they are designed and developed. I strongly encourage you to go through the code evolution chapter by chapter. You should be able to further refactor it, adopting it to your own coding style. Of course, some parts of it can be further optimized, as they repeat quite often. That is an intentional decision rather than good practice, as I wanted to emphasize their importance. You should always strive to improve your code-base, making it easier to maintain.</p>
<p>Finally, I would like to encourage you to always follow the development of the <kbd>Node.js</kbd> modules you use in your applications. Node.js has an extraordinary community that is eager to grow rapidly. There is always something exciting going on there, so ensure that you don't miss it. Good luck!</p>


            </article>

            
        </section>
    </div>



  </body></html>