<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;Logging, Debugging, and Error Management"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Logging, Debugging, and Error Management</h1></div></div></div><p class="calibre7">Until now, we have learned the basics of architecting and building Ember.js applications. In this chapter, we will learn how to debug these applications in order to not only reduce development time, but also to make development more fun. We will, therefore, cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Logging</li><li class="listitem">Tracing events</li><li class="listitem">Debugging errors</li><li class="listitem">Using the Ember.js inspector</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Logging, Debugging, and Error Management">
<div class="book" title="Logging and debugging"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec100" class="calibre1"/>Logging and debugging</h1></div></div></div><p class="calibre7">Ember.js can <a id="id420" class="calibre1"/>be downloaded in two formats that are meant to be used in development and production environments accordingly. The development (magnified) build is recommended to be used during the application development period for easier debugging. There are various ways to log and inspect objects created inside an application. We will discuss how to log and debug each of these objects in detail.</p></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Logging, Debugging, and Error Management">
<div class="book" title="Logging and debugging">
<div class="book" title="Objects"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec40" class="calibre1"/>Objects</h2></div></div></div><p class="calibre7">Besides<a id="id421" class="calibre1"/> the logging <a id="id422" class="calibre1"/>functions already provided<a id="id423" class="calibre1"/> by <a id="id424" class="calibre1"/>the browser's <code class="email">console</code> object, Ember.js provides the following <code class="email">Ember.Logger</code> logging utilities that are specifically meant to log Ember.js objects:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">assert</code></li><li class="listitem"><code class="email">debug</code></li><li class="listitem"><code class="email">error</code></li><li class="listitem"><code class="email">info</code></li><li class="listitem"><code class="email">log</code></li><li class="listitem"><code class="email">warn</code></li></ul></div><p class="calibre7">Ember.js bindings can be logged as they occur. To enable this logging, add the following code to a program before the application is initialized:</p><div class="informalexample"><pre class="programlisting">Ember.LOG_BINDINGS = true;</pre></div><p class="calibre7">Most <a id="id425" class="calibre1"/>browsers <a id="id426" class="calibre1"/>allow setting breakpoints at <a id="id427" class="calibre1"/>predetermined points in an <a id="id428" class="calibre1"/>application. Breakpoints pause the execution of a program using the <code class="email">debugger</code> keyword. Pausing a program can help troubleshoot problems as well as trace events. For example, we could set a breakpoint that will let us know whether a property was computed as expected:</p><div class="informalexample"><pre class="programlisting">App.Book = Ember.Object.extend({
  summary: function(){
    debugger;
  }.property('title', 'publisher')
});</pre></div><p class="calibre7">This creates a breakpoint, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Objects" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Hitting the <span class="strong"><em class="calibre9">F8</em></span> key <a id="id429" class="calibre1"/>resumes the execution of the application. Multiple <a id="id430" class="calibre1"/>breakpoints <a id="id431" class="calibre1"/>could be set up to trace the execution of an event. The sidebar <a id="id432" class="calibre1"/>on the right-hand side of the developer tools could then be used to enable, disable, or inspect these points.</p></div></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Logging, Debugging, and Error Management">
<div class="book" title="Logging and debugging">
<div class="book" title="Router and routes"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec41" class="calibre1"/>Router and routes</h2></div></div></div><p class="calibre7">When<a id="id433" class="calibre1"/> an <a id="id434" class="calibre1"/>application <a id="id435" class="calibre1"/>transitions<a id="id436" class="calibre1"/> from<a id="id437" class="calibre1"/> one <a id="id438" class="calibre1"/>route <a id="id439" class="calibre1"/>to another, it <a id="id440" class="calibre1"/>may be necessary to trace these events in the case of misbehavior. Enabling this behavior is easy:</p><div class="informalexample"><pre class="programlisting">var App = Em.Application.create({
  LOG_TRANSITION: true
});</pre></div><p class="calibre7">More <a id="id441" class="calibre1"/>detailed<a id="id442" class="calibre1"/> logging can <a id="id443" class="calibre1"/>be enabled by additionally passing the <code class="email">LOG_TRANSITIONS_INTERNAL</code> option as <code class="email">true</code>:</p><div class="informalexample"><pre class="programlisting">var App = Em.Application.create({
  LOG_TRANSITIONS_INTERNAL: true
});</pre></div><p class="calibre7">Even <a id="id444" class="calibre1"/>with <a id="id445" class="calibre1"/>this simple application, running it will log the following transition:</p><div class="informalexample"><pre class="programlisting">Transitioned into 'index'</pre></div><p class="calibre7">The application <a id="id446" class="calibre1"/>controller houses two useful pieces of information about <a id="id447" class="calibre1"/>the current application <a id="id448" class="calibre1"/>state. To get the current application route name, we will reference this from the application controller, shown as follows:</p><div class="informalexample"><pre class="programlisting">var currentRouteName = this
  .controllerFor("application")
  .get("currentRouteName");
Ember.Logger.log(currentRouteName); // post.like</pre></div><p class="calibre7">The full path of this current route could be looked up appropriately, as follows:</p><div class="informalexample"><pre class="programlisting">var currentPath = this
  .controllerFor("application")
  .get("currentPath");
Ember.Logger.log(currentPath); // user.post.like</pre></div><p class="calibre7">Any instantiated route can be referenced from the application container, shown as follows:</p><div class="informalexample"><pre class="programlisting">App.__container__.lookup("route:index");</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Logging, Debugging, and Error Management">
<div class="book" title="Logging and debugging">
<div class="book" title="Templates"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec42" class="calibre1"/>Templates</h2></div></div></div><p class="calibre7">As we've <a id="id449" class="calibre1"/>seen time <a id="id450" class="calibre1"/>and again, templates <a id="id451" class="calibre1"/>can be looked up from <a id="id452" class="calibre1"/>the <code class="email">Ember.TEMPLATES</code> object; for example:</p><div class="informalexample"><pre class="programlisting">Ember.TEMPLATES['index'];</pre></div><p class="calibre7">Breakpoints can also be set right from templates! For example, consider that we have an <code class="email">index</code> template defined as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script type='text/x-handlebars' id='index'&gt;
     {{#link-to 'books'}}books{{/link-to}}
  {{#link-to 'pens'}}pens{{/link-to}}
&lt;/script&gt;</pre></div><p class="calibre7">We may want <a id="id453" class="calibre1"/>to inspect the rendering of this template by using the <code class="email">debugger</code> expression:</p><div class="informalexample"><pre class="programlisting">&lt;script type='text/x-handlebars' id='index'&gt;
     {{#link-to 'books'}}books{{/link-to}}
     {{debugger}}
  {{#link-to 'pens'}}pens{{/link-to}}
   &lt;/script&gt;</pre></div><p class="calibre7">Logging <a id="id454" class="calibre1"/>from <a id="id455" class="calibre1"/>the template is also possible using the <code class="email">log</code> expression:</p><div class="informalexample"><pre class="programlisting">{{log model}}</pre></div><p class="calibre7">This logs the route's model to the browser's console.</p></div></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Logging, Debugging, and Error Management">
<div class="book" title="Logging and debugging">
<div class="book" title="Controllers"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec43" class="calibre1"/>Controllers</h2></div></div></div><p class="calibre7">A<a id="id456" class="calibre1"/> specific <a id="id457" class="calibre1"/>controller can be looked up globally via the main application container:</p><div class="informalexample"><pre class="programlisting">App.__container__.lookup("controller:index");</pre></div><p class="calibre7">This application<a id="id458" class="calibre1"/> container registers classes to be instantiated by the application, which <a id="id459" class="calibre1"/>can, in turn, be referenced. Note that the preceding example should be used for debug purposes only. Controller dependency should instead be used to access other controllers from routes and controllers, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">App.ApplicationController = Em.Controller.extend({
  title: 'My app'
});

App.IndexController = Em.Controller.extend({
  needs: [
    'application'
  ],
  actions: {
    save: function(){
      var title =this.get('controllers.application');
      console.log(title);
    }
  }
});</pre></div><p class="calibre7">Finally, we can enable logs that will indicate generation of controllers by passing another option during application instantiation, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">App = Ember.Application.create({
  LOG_ACTIVE_GENERATION: true
});</pre></div></div></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Logging, Debugging, and Error Management">
<div class="book" title="Logging and debugging">
<div class="book" title="Views"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch09lvl2sec44" class="calibre1"/>Views</h2></div></div></div><p class="calibre7">Instantiated <a id="id460" class="calibre1"/>views have <a id="id461" class="calibre1"/>unique IDs and can therefore be looked up accordingly, as follows:</p><div class="informalexample"><pre class="programlisting">Ember.Logger.log(Ember.View.views['ember1']);</pre></div><p class="calibre7">Just as with <a id="id462" class="calibre1"/>routes, we <a id="id463" class="calibre1"/>can also log view events on route transitions. This may be useful in cases where we need to verify whether registered view classes are being used. This behavior can be enabled as follows:</p><div class="informalexample"><pre class="programlisting">var App = Ember.Application.create({
  LOG_VIEW_LOOKUPS: true
});</pre></div></div></div></div>
<div class="book" title="Using the Ember.js inspector"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec101" class="calibre1"/>Using the Ember.js inspector</h1></div></div></div><p class="calibre7">An Ember.js application can be<a id="id464" class="calibre1"/> inspected via a browser extension that is available for Chrome, Opera, and Firefox. This extension lets you inspect objects in <a id="id465" class="calibre1"/>your application from an Ember.js tab that is created in the developer tools. To get started in Chrome, you'll need to do the following:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Visit <code class="email">chrome://flags</code> and ensure <span class="strong"><strong class="calibre8">Experimental Extension APIs</strong></span> is enabled.</li><li class="listitem" value="2">Install <a id="id466" class="calibre1"/>the extension at <a class="calibre1" href="https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi">https://chrome.google.com/webstore/detail/ember-inspector/bmdblncegkenkacieihfhpjfppoconhi</a>.</li><li class="listitem" value="3">Restart Chrome.</li><li class="listitem" value="4">Open your Ember.js application and press the <span class="strong"><em class="calibre9">Ctrl</em></span> + <span class="strong"><em class="calibre9">U</em></span> keys to launch the developer tools.</li></ol><div class="calibre22"/></div><p class="calibre7">An <span class="strong"><strong class="calibre8">Ember</strong></span> tab should have been created next to the <span class="strong"><strong class="calibre8">Console</strong></span> tab, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Using the Ember.js inspector" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">From the sidebar, clicking on <span class="strong"><strong class="calibre8">View Tree</strong></span> gives detailed information about the current state of the <a id="id467" class="calibre1"/>application, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Using the Ember.js inspector" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The next tab shows all the routes, views, controllers, and templates registered in the application. Here is a screenshot taken from the <span class="strong"><strong class="calibre8">Todos</strong></span> application used in the previous chapter:</p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Using the Ember.js inspector" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">If an application <a id="id468" class="calibre1"/>uses Ember.js data, the <span class="strong"><strong class="calibre8">Data</strong></span> tab will display all the loaded models:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Using the Ember.js inspector" class="calibre10"/></div><p class="calibre11"> </p></div>
<div class="book" title="Client-side tracing"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec102" class="calibre1"/>Client-side tracing</h1></div></div></div><p class="calibre7">When<a id="id469" class="calibre1"/> developing an Ember.js or any other MVC application, it may be wise to trace events that occur in the application. Tracing events has the benefit of yielding data that becomes meaningful when presented as graphs. A simple tracer could be implemented by logging the timestamp of predetermined points of an ongoing event. For example, let's create an application that traces progress in loading models from the server:</p><div class="informalexample"><pre class="programlisting">App.ApplicationRoute = Ember.Route.extend({
  trace: function(event){
    var timestamp = Date.now();
    var data = {
      timestamp: timestamp,
      event: event
    };
    Ember.$.ajax('/logs', {
      type: 'POST',
      data: data
    });
  },
  model: function(){
    this.trace('load-application-model');
    return this.getJSON('/books');
  },
  setupController: function(controller, model){
   this._super(controller, model);
   this.trace('load-application-model');
  }
});</pre></div><p class="calibre7">This will produce<a id="id470" class="calibre1"/> logs similar to the following code:</p><div class="informalexample"><pre class="programlisting">{
  timestamp: 1396376883120,
    event: 'load-application-model'
}
{
  timestamp: 1396376883130,
    event: 'load-application-model'
}</pre></div><p class="calibre7">Graphing this data could help us gain an insight into the performance of our application.</p></div>
<div class="book" title="Error management"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec103" class="calibre1"/>Error management</h1></div></div></div><p class="calibre7">In addition<a id="id471" class="calibre1"/> to saving logs back to the server, we could also <code class="email">POST</code> any errors that could occur in the application by the following signature:</p><div class="informalexample"><pre class="programlisting">Ember.onerror = function(error) {
  var data = {
    stack: error.stack,
    event: 'error'
  };
  Ember.$.ajax('/logs', {
    type: 'POST',
    data: data
  });
};</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec104" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">We just learned how to log events as well as debug bottlenecks in our Ember.js applications. A lot of development time could be saved as a result of the proper logging and tracing of events in client-side applications. In the next chapter, we'll learn how to write and run tests for our applications.</p></div></body></html>