- en: Service Worker Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web development has become complicated today with so many options, steps, and
    tools. **Progressive Web Apps** (**PWAs**) require a new model but that can produce
    many opportunities for errors to creep into the code. The good news is that there
    are several tools that you can integrate into your workflow to improve your application
    code's integrity.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will review several tools I have found invaluable in helping
    me ensure that my applications meet a level of consistent quality before I ship
    them. These includeÂ **PWABuilder**, **Lighthouse**, **Sonar**, and **WorkBox**.
  prefs: []
  type: TYPE_NORMAL
- en: Lighthouse and Sonar are *linting tools* you can use to audit your web pages
    to ensure that a minimum criteria is met, including PWA, performance, hosting,
    and SEO requirements. PWABuilder and Workbox are very helpful in scaffolding important
    aspects of progressive web apps including the manifest, icons, and service workers.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, all of these tools are available as node modules which you can execute
    as part of a script and from the command line. This means that you can include
    much of this functionality as part of your automated workflow and build processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding PWA assets with PWABuilder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing web pages using Lighthouse
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auditing web pages using Sonar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making complex service workers with WorkBox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PWABuilder to scaffold your PWA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PWABuilder is a progressive web application scaffolding tool built by the Microsoft
    Edge team and publicly hosted at [https://pwabuilder.com](https://pwabuilder.com).
    I love this tool because you can quickly scaffold the assets you need to upgrade
    any website to a progressive web app in less than a minute.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three steps to scaffolding the PWA components, which are generating
    a web manifest file, picking a simple service worker, and downloading the assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00121.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's check each of these steps in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Generating a valid web manifest file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A valid web manifest file is one of the primary PWA requirements, but you would
    be surprised at how many sites miss this simple step. Most of them just forget
    an important field or to supply values that don't meet the guidelines, such as
    a long and short name value.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest mistake is not including the minimum set of icons required by all
    the different browsers and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the online tool, you need to supply a public URL, two primary application
    colors, and a logo or image you want to make application icons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00122.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The wizard will try to parse values to supply properties, such as full name,
    short name, and description. If your site already has a web manifest file, it
    will use those properties. Don''t worry: you can supply or change any value in
    the online form, as well as specify display orientation and language, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00123.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step in the PWABuilder wizard is to generate a set of application
    icons, and there are over 100 at the time of writing this book. You can either
    supply a URL to a public image or upload a base image. The image generator will
    create a set of images to meet the criteria of each major platform: iOS, Android,
    and Windows. It also covers Chrome and FireFox requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'My favorite feature is how it includes proper references for each image in
    the generated web manifest file. I can''t emphasize how much time this saves and
    how it eliminates potential errors. The fact that the service creates a complete
    set of images also means that you won''t miss an important icon size that could
    keep your PWA from qualifying as a progressive web app on different platforms.
    Check out the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00124.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When you click the Input Image input field, you are greeted with a form so
    that you can upload an image. You can choose a file on your hard drive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00125.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the wizard completes, the product is a package containing all the icons
    and a manifest file with the icons referenced:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00126.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Building a service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After uploading a source image to make the application icons, the service worker
    step displays. Here, you are given a selection of premade service workers. These
    are all basic service workers that can work with most sites so that you can start
    the progressive web application journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are five starter service worker options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Offline page**: Initializes the service worker cache with an offline fallback
    page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Offline copy of pages**: As the user visits pages on your site, they are
    cached, making return visits fast and offline capable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offline copy with a backup of offline pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache-First Network**: Checks the cache for a valid response before hitting
    the network, which adds network responses to the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced Pre-Caching**: Currently under development, but designed to give
    you more control over site assets that are cached when the service worker is installed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Downloading your site's PWA assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After selecting a starter service worker, PWABuilder provides links to download
    packaged versions of your PWA and native apps. You have the option to download
    just the progressive web app assets, a pre-packaged Windows appx file, and native
    apps for the Google Play and iOS App stores.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, the native app versions won't be needed, but can be handy just
    in case you need access to platform-specific APIs and integrations.
  prefs: []
  type: TYPE_NORMAL
- en: You can click the buttons corresponding to the package you need. PWABuilder
    will then generate a package, a ZIP file, containing the assets you need. The
    site also provides instructions for integrating the scaffolded code into your
    site and submitting the app store packages to the various stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of the generated web manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00127.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Scaffolded PWA images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I think the best part to PWABuilder is how it quickly generates all the application
    icons as the web manifest file that properly references each image. It generates
    over 100 images, and I don't know about you, but I don't have the time or patience
    to create that many variations, much less add the code to my web manifest file.
  prefs: []
  type: TYPE_NORMAL
- en: This is part of the PWABuilder wizard, but you may have already created a valid
    web manifest file and a service worker and only need a collection of icons.
  prefs: []
  type: TYPE_NORMAL
- en: This is where you can access the image generation service directly at [https://www.pwabuilder.com/imageGenerator](https://www.pwabuilder.com/imageGenerator).
    You'll see the same form that's included in the wizard interface. The only difference
    is that once you provide the base image, you can directly click the Download button
    to get just your PWA icons and the web manifest JSON.
  prefs: []
  type: TYPE_NORMAL
- en: You are not limited to just using the online image generator. The source code
    is an open source ASP.NET project, [https://github.com/pwa-builder/App-Image-Generator](https://github.com/pwa-builder/App-Image-Generator).
    You will need to stand up a web server that's capable of servicing an ASP.NET
    site, which you could do using Docker. I don't think this version is built on
    .NET Core, which means you will need an instance of IIS on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: The tool does not modify any files in your site, so you still need to update
    your pages to register the service worker and web manifest file. You will also
    need to copy the icons, manifest, and service worker files to your site's folder.
  prefs: []
  type: TYPE_NORMAL
- en: Running PWABuilder locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If your site is not public, don''t worry: you can still take advantage of PWABuilder
    by running it locally. PWABuilder is actually the second generation of PWA tools
    produced by Microsoft. In its previous life, it was called Manifold JS, and still
    uses that engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Manifold is a collection of node modules, used by the PWABuilder site, that
    generate the files needed for your PWA. The Manifold JS components are available
    both on GitHub ([https://github.com/pwa-builder](https://github.com/pwa-builder))
    and npmÂ ([https://www.npmjs.com/package/manifoldjs](https://www.npmjs.com/package/manifoldjs)).
  prefs: []
  type: TYPE_NORMAL
- en: You can run PWABuilder directly from the command line. Since it is a node module,
    you will need Nodejs installed, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend installing the PWABuilder node library globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can execute `pwabuilder` from any command line. In the following example,
    I added a couple of options, one to specify the target directly to save the generated
    assets and another to designate what platform to generate assets:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00128.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If you want to get even more ambitious, you can build your own node script to
    execute the PWABuilder libraries directly. You can clone the PWABuilder projects
    and examine the source code and how the command-line utility executes to see how
    you can incorporate parts of the library in your own scaffolding routines.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing web pages using Lighthouse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lighthouse ([https://developers.google.com/web/tools/lighthouse/](https://developers.google.com/web/tools/lighthouse/))
    is an automated tool managed by the Chrome team that can help you audit your site
    to identify problems that need attention. The tools audits more than just progressive
    web app requirements, as it checks for many best practices including performance,
    accessibility, and SEO.
  prefs: []
  type: TYPE_NORMAL
- en: Lighthouse is an open source project, and contributions are welcome.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier in this book, Lighthouse can be executed two different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in to the Chrome Developer tools' Audit tab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Node Module ([https://www.npmjs.com/package/Lighthouse](https://www.npmjs.com/package/Lighthouse))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chrome extension was the original implementation, but this is being phased
    out. Today, the extension is redundant since Lighthouse is built-in to the Developer
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Lighthouse will exercise a given URL in Chrome and run it through a battery
    of tests. These tests cover different scenarios emulating mobile cellular network
    and desktop versions.
  prefs: []
  type: TYPE_NORMAL
- en: It runs a battery of test against the URL in these different scenarios, looking
    for potential issues. It can establish a baseline for your application's performance
    and how well it meets minimum requirements, like being a PWA.
  prefs: []
  type: TYPE_NORMAL
- en: Lighthouse produces a score/report card, listing how a page has performed against
    the battery of tests. Over the course of a minute or so, an audit will reload
    the page several times under different conditions, with loads capturing traces
    each time. How long it took to load pages, become interactive, how well it worked
    offline, and so on are all logged.
  prefs: []
  type: TYPE_NORMAL
- en: The primary categories the Lighthouse audits are for progressive web application
    features, web performance optimization, accessibility, and general best practices.
    Recently, the tool added an SEO audit section, but this functionality is still
    limited at this time.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you run a Lighthouse audit, you will see a report card. This is an example
    of the five top level audit type scores. These scores are based on a 0-100 scale,
    with 100 being perfect. The score is comprised of a weighted score for each point
    in the audit group:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00129.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each one of these top-level audits runs granular tests and provides a very detailed
    report. Lighthouse can produce a report as either JSON or the default HTML. You
    can also save the data collected during a Developer tools test so that you can
    review and compare it with a later test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML report will automatically highlight areas you either failed on or
    need to address. It also provides helpful links to documentation that will help
    point you to a solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From time to time, I like to run Lighthouse from the Chrome Developer tools,
    just to see where I'm at in my development process. It's a quick and automated
    tool that can help me get insight into where I may have missed something mundane
    that can have a measurable impact.
  prefs: []
  type: TYPE_NORMAL
- en: For progressive web apps, it runs through a set of checklist items to be a full-blown
    progressive web app. Most can be automatically tested, but a few must be manually
    evaluated. The Lighthouse report list items should be manually verified.
  prefs: []
  type: TYPE_NORMAL
- en: The big two are obvious, HTTPS, web manifest file in a service worker, but it
    goes to a deeper level. It also looks at your performance and if you can load
    in under three seconds over a cellular connection. It does this by simulating
    slower network conditions and CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: It also checks to make sure that you have valid icons for the different viewports
    and that you can prompt the Homescreen banner.
  prefs: []
  type: TYPE_NORMAL
- en: All tests are run, emulating a 3G connection and throttle down your CPU 4x from
    its default speed. This last part can obviously skew your test results from device
    to device based on the available CPU. I work on a very new i7 Surface Laptop,
    which runs much faster than a more seasoned i3 or i5 processor. You will also
    see variability as you use different virtual machines with different CPU power
    allocated.
  prefs: []
  type: TYPE_NORMAL
- en: Collectively, all these little things will help you know if your website will
    provide a good user experience or not. It's not the only way to test, but it does
    give you a good baseline that covers most of the areas that you need to audit.
  prefs: []
  type: TYPE_NORMAL
- en: Running Lighthouse from the Chrome Developer Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to use Lighthouse is from the Chrome Developers Tools. By now,
    you should know how to open these tools. All desktop browsers contain Developer
    tools and they can be opened by pressing *F12* or *Ctrl* + *Shift* + *I*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Developer tools are open ,you have multiple options. Lighthouse is
    one of those options. It is labeled Audits and is presented as the last native
    tab. If you are like me, you may have an extension that has parked a custom tab
    in the tools as well. They are listed after the Audits tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00131.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Initially, there is not much to the Audits tab when you open it, just the Lighthouse
    dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialog has a list of the five current audit categories, and theÂ Run audit
    and Cancel buttons. Each category can be toggled on or off. Pressing the Run audit
    button starts the audit process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00132.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: During the audit process, you will see a new dialog, assuring you that the audit
    is running and sharing useful web development facts and stats to keep you entertained.
    Meanwhile, the corresponding browser tab is being exercised by Lighthouse.
  prefs: []
  type: TYPE_NORMAL
- en: If you watch the browser tab, you will see it use the built-in emulation tools
    to load the target page in different virtual devices and under different network
    conditions, including offline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on how the page behaves and loads, the different tests either pass or
    fail. In the end, Lighthouse produces a report, which you can then use to evaluate
    how your page stands. Use the report to identify different aspects of the page
    and site to improve:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00133.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After the audit completes, you are presented with a nicely formatted report
    featuring a high-level grade in each category at the top. Below the scores, each
    category lists any failing tests or tests that you did not quite meet target numbers
    but should investigate. All tests that passed are grouped together and collapsed
    out of view but can still be viewed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every test should have a link with more details, indicated with a separate
    Learn more link, about what was tested and hopefully guidance to help you improve
    the page, so that you can pass the test:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You should also consider the hosting environment you are testing against. Some
    tests will fail on a local site because you may not have a full production scale
    web server. While the node http-server makes it easy to run a local web server,
    it does not have HTTPS and HTTP/2 by default. This makes your page fail any tests
    that are looking for these two features.
  prefs: []
  type: TYPE_NORMAL
- en: In these scenarios, you can safely ignore these test results due to environment
    limitations. I do advise performing additional tests once the site is deployed
    to full scale environments like development, staging, and production.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, when running in the Developer tools, you should use this as an important
    triage step to ensure that your code and site updates improve the overall site's
    experience. They are not the actual experience a real user may have, because the
    site is hosted in a different environment. Also remember the conditions Lighthouse
    emulates are just that, emulated, and may not perfectly reflect a real-world device
    or network conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Another big issue with the Developer tools Lighthouse implementation is that
    there is the inability to customize the audit beyond toggling major test categories.
    You cannot extend the audit with your own tests and categories.
  prefs: []
  type: TYPE_NORMAL
- en: This is where running Lighthouse directly as a node module offers big benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Running Lighthouse as a command-line utility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I really enjoy the ability to execute Lighthouse as a node module. The Lighthouse
    node module has a dependency on Chrome Launcher ([https://www.npmjs.com/package/chrome-launcher](https://www.npmjs.com/package/chrome-launcher)),
    which will open an instance of Chrome to execute the test.
  prefs: []
  type: TYPE_NORMAL
- en: This means the machine executing Lighthouse should have Chrome installed. The
    tool uses a full instance of Chrome because it needs to render the page and use
    the Developer tools to emulate different modes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because Lighthouse is a node module, you need to install it using either npm
    or yarn. Like the other tools, I recommend installing it globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run a full audit right from the command line by executing Lighthouse
    followed by the target URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This launches a new instance of Chrome and runs the test battery against the
    target URL. When completed, an HTML report file is created in the current folder.
    You can load this in a browser to review. It is the same report that's loaded
    in the Developer tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of an automated test report file loaded into the Lighthouse
    report viewer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00135.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can customize Lighthouse to perform the tests you need and report in the
    format you want. These are just some of the common options I use on my projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--config-path`: The local path to the configuration file you want to use for
    the audit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output`: The report format. Options are JSON, CSV, and HTML with HTML by
    default. You can designate more than one format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--output-path`: The location to write the report. If multiple formats are
    designated, the path is ignored, but each format is saved to the current path
    based on the target''s basename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--view`: Launches a HTML report in the browser once it is written.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--block-url-patterns`: Forces the browser to ignore certain assets. This is
    good to test without third-party scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--throttling-*`: Different options here to granularly control how network
    and CPU throttling is set during tests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--save-assets`: Persists test assets like screenshots to disks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, a full audit is run and saved in both JSON and HTML formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The report is saved locally in both output formats. I like doing this because
    the HTML report is easy to read and the JSON report is easy to consume into third
    party or custom reporting solutions.
  prefs: []
  type: TYPE_NORMAL
- en: The default Lighthouse audit may not cover the rules you need to monitor or
    more than you want to test. You can also create your own tests, which need to
    be included. You can customize the audit with your own configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom configurations are written as JSON objects. This example extends the
    default configuration, but limits the tests to just the performance and progressive
    web app tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To use the custom configuration file, you must supply the path as a command-line
    switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Ultimately, you can control everything Lighthouse uses to run an audit, including
    gathers, test groups, categories, and how different passes execute.
  prefs: []
  type: TYPE_NORMAL
- en: A custom configuration file makes it very easy for you to control how Lighthouse
    is exercised against your web app without fussing with extended command-line options.
    This also makes testing very repeatable and you can include the configuration
    files in your source control to easily restore and audit how tests were executed.
  prefs: []
  type: TYPE_NORMAL
- en: Lighthouse and headless testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recently, the Chrome team also released a tool called Puppeteer ([https://github.com/GoogleChrome/puppeteer](https://github.com/GoogleChrome/puppeteer)),
    which executes a headless instance of Chromium. This is not Chrome, but a variation
    in the code base upon which many popular applications such as Visual Studio Code
    are built.
  prefs: []
  type: TYPE_NORMAL
- en: A headless browser can execute a page, but not with the ability to view the
    page. Because the page is not visibly rendered, some of the tests are not run.
    You should keep this mind when executing an audit using a headless browser.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to exercise Lighthouse against a headless browser has opened up
    opportunities for the tool to be integrated in different tools. For example, WebPageTest,
    HTTPArchive, Calibre, and others use Lighthouse to add additional test points
    to their reports. You can follow their lead and incorporate the Lighthouse node
    module in your in-house test and auditing work flows.
  prefs: []
  type: TYPE_NORMAL
- en: Because Lighthouse can be executed from a script as a node module, you can create
    an automated test to exercise over your entire website or a sample set of URLs
    in your website. You can then audit the results and find the common area areas
    you need to address.
  prefs: []
  type: TYPE_NORMAL
- en: 'I do advise running it over more than one URL in your site because there are
    many different types of pages that compose most applications. But a word of caution:
    limit the number of pages you automate testing. Each test instance will launch
    a new instance of Chrome, which can quickly get out of hand if you try to test
    an entire site.'
  prefs: []
  type: TYPE_NORMAL
- en: The lightcrawler ([https://github.com/github/lightcrawler](https://github.com/github/lightcrawler))
    project is a possible tool you can use to automate testing your entire site. Lighthouse
    Cron ([https://github.com/thearegee/Lighthouse-cron](https://github.com/thearegee/lighthouse-cron))
    allows you to audit a site at scheduled and random intervals using cron jobs to
    collect scores over time. These are just a couple of examples of how Lighthouse
    and similar tools are being used to provide valuable testing and performance audits
    to make web applications better.
  prefs: []
  type: TYPE_NORMAL
- en: I would also recommend running multiple test cycles to create a comparison.
    Any time I run a site or page audit, I find result variations. Sometimes, like
    any real scientific experiment, you find outliers that do not accurately reflect
    the overall experience.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the test machine may have a high CPU background task running or
    one that consumes disk and memory I/O, causing performance issues. When testing
    against a live site, you may also encounter network issues that fall outside of
    your control.
  prefs: []
  type: TYPE_NORMAL
- en: These can all lead to failed tests and poor audit results. When I see poor performance
    results, I will typically run 3-5 more tests to see what sort of variations I
    may have. When I consistently see a test fail or log poor results, I then work
    to improve the issue. If a failed test is consistent, the problem is my site,
    not the environment around the site.
  prefs: []
  type: TYPE_NORMAL
- en: Running Lighthouse in a Node script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like Sonar (which will be covered in the next section) and the other node-based
    utilities, you can also use Lighthouse in your own node scripts and modules. You
    need to create references to both the `Lighthouse` and `chrome-launcher` modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Both the Chrome Launcher and Lighthouse modules return promises. You must create
    a new Chrome instance before launching Lighthouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chrome Launcher resolves a reference to a Chrome instance. You need to pass
    the developer port number to the Lighthouse module. This is how Lighthouse communicates
    with Chrome to perform the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You should also supply your custom configuration to the Lighthouse method. You
    can leave this empty and the default audit is executed.
  prefs: []
  type: TYPE_NORMAL
- en: When Lighthouse starts, a new instance of Chrome is opened, just like from the
    command line. You can watch your site run through all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: When Lighthouse is finished, it resolves the results in the target format.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous build with Lighthouse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to use Lighthouse is to embed it as part of your build and deployment
    workflow. For example, you may use a tool like **Travis**, which exercises a script
    to deploy and test applications. This way, you can make sure that the project
    passes the Lighthouse audits before deploying to a production server.
  prefs: []
  type: TYPE_NORMAL
- en: There is a problem running more modern sites requiring authentication like the
    PWA ticket application. Because Lighthouse exercises web pages using an unprimed
    environment and sometimes when storage is not available, persisted tokens may
    not be available.
  prefs: []
  type: TYPE_NORMAL
- en: In the PWA ticket application, this means the site redirects to the login page.
    I have seen a few mentions of potential solutions to this issue, but have not
    had much success.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, one of the cool Lighthouse tools I found is Eric Bidel''s Score badges
    ([https://github.com/ebidel/Lighthouse-badge](https://github.com/ebidel/lighthouse-badge)).
    You can include the badges as part of your project''s `readme` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00136.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Lighthouse is a fantastic tool that can help you find and diagnose many common
    issues that will affect your overall application user experience. It provides
    valid valued insight into things like progressive web application features, web
    performance, accessibility, and feature acts. And as we've recently seen, the
    team is continually adding new test sets to Lighthouse. The SEO set is just the
    start of a new air area that Lighthouse will cover.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in tooling gives you, the developer, or any concerned party, the ability
    to quickly test a page to see how well you meet expectations in the default categories.
    You should remember the default tests run by the Chrome tool are what the Chrome
    team considers important and they may not match exactly to your needs.
  prefs: []
  type: TYPE_NORMAL
- en: I do recommend starting with the default tests to benchmark your site's current
    state. The default tests are a great set of baseline tests that I personally think
    every site should use as a minimum standard.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to run Lighthouse directly using node gives you the ability to not
    only tailor tests to your requirements, but gives you the ability to customize
    and extend the test battery. You can dig into the Lighthouse documentation to
    see how to create your own tests.
  prefs: []
  type: TYPE_NORMAL
- en: Auditing web pages with Sonar
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to Lighthouse, the Microsoft Edge team has also released a new site
    linting tool called **SonarÂ **([https://sonarwhal.com/](https://sonarwhal.com/)).
    Like Lighthouse, it is an open source node module that serves as a testing harness
    to execute rules over a web page.
  prefs: []
  type: TYPE_NORMAL
- en: The two tools offer similar testing abilities, but also offer a different set
    of abilities and test batteries. Both provide a default starting point to execute
    a base set of tests on a page. Both can be customized with your own configurations
    and even extended with custom tests and reports.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Lighthouse, Sonar is not built into the browser developers tools. At
    least not yet, and I only say that because I could see the tool being integrated
    into Edge at some point, like Lighthouse is in Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Sonar also differs because it can execute tests in either Microsoft Edge, Chrome,
    or other testing libraries. For example, Sonar ships with a jsdom parser.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Sonar CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because Sonar is not part of a browser, but a node module, it needs to be executed
    either within a custom node script or by using its command-line interface. The
    CLI is the best place to start using Sonar, and like Lighthouse, you need to install
    Sonar first. Again, I recommend a global install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Before you can run Sonar, you need to create a configuration file, `.sonarwhalrc`.
    You can do this by hand or use the command line to initialize a configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This kicks off a wizard, asking you a series of questions to initialize your
    configuration. You can choose a predefined configuration or make a custom configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00137.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two predefined configurations available at this time: `web-recommended`
    and `progressive-web-apps`. Depending on which configuration you choose, the wizard
    will install any required node dependencies. I will cover the Sonar components
    a little later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00138.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This produces a started config file, extending the built-in `web-recommended`
    package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This contains a base configuration with a minimum set of rules, a formatter,
    and connector definition. This is what the `web-recommended` configuration file
    looks like. You can use the following code as a reference to see how to create
    your own configuration files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I will demonstrate how to customize this configuration a little later.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are not limited to a single configuration to extend, as you can extend
    multiple configurations, as mentioned in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You are not limited to the built-in configurations and you don''t need to run
    the initialization wizard. You can create your own configuration file, as they
    are just JSON documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Sonar has a configuration, you can execute it from the command line. Like
    Lighthouse, you just need to execute Sonar followed by a valid URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can customize the test by creating a custom configuration file. Sonar will
    look for the `.sonarwhalrc` file in the current folder.
  prefs: []
  type: TYPE_NORMAL
- en: Sonar components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are five components of Sonar you need to familiarize yourself with to
    understand how the tool works.
  prefs: []
  type: TYPE_NORMAL
- en: Configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These are the `.sonarwhalrc` files I covered earlier. These are the files that
    drive a specific test or audit against your site.
  prefs: []
  type: TYPE_NORMAL
- en: Connectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The connector is the interface between the rules Sonar executes and the URL.
    Right now, there are three official connectors available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`jsdom`: A nodejs implementation of the WHATWG DOM, which means it provides
    a pretty good engine to test how the page renders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chrome`: Executes the rules by launching Chrome, using it''s debugging protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`edge`: Exercises the rules using Microsoft Edge. This requires Windows 10
    because Edge only works on Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Formatters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Formatters take the test results and *print*Â them. There are currently five
    formatters being maintained by the Sonar team:'
  prefs: []
  type: TYPE_NORMAL
- en: '`json`: Creates a JSON formatted report'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stylish`: Produces a table formatted report'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`excel`: Generates the report as an Excel worksheet'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`codeframe`: Produces the report in a codeframe style'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`summary`: Formats the report in a table'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: My personal favorite is JSON because I can then use that as a raw data source
    to add it to a custom report or combine it with other tools like Lighthouse's
    reports to complete a full site audit.
  prefs: []
  type: TYPE_NORMAL
- en: Parsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rules subscribe to parsers and the events they emit to perform tests. They are
    designed to focus on specific resource types, like JavaScript and web manifest
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rules are the heart of Sonar because they are responsible for exercising the
    page to see if the desired criteria are met. There are a number of rules included
    in the default Sonar installation. Like the rest of Sonar, you are free to create
    your own rules.
  prefs: []
  type: TYPE_NORMAL
- en: Automating site audits with the Sonar node module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The combination of being a nodejs module and the command-line interface gives
    you multiple ways to integrate Sonar as part of your build and deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Lighthouse, there are no command-line switches because it relies on the
    configuration file. If you want to execute different configurations, you need
    to run sonarwhal from the target folder so that the desired custom configuration
    is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Making complex service workers with workbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Workbox** ([https://developers.google.com/web/tools/workbox/](https://developers.google.com/web/tools/workbox/))
    is another open source project to help you create service workers. It is maintained
    by the Chrome team, but like the other projects, I have reviewed those open to
    public contributions.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of Workbox is to help scaffold complete service workers or add complex
    components to existing service workers. Workbox allows you to build on a solid
    foundation, so you can configure to meet your specific needs. It gives you control
    over how you build your service worker. You can manually add features to existing
    service workers and tooling to scaffold a service worker from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: A properly configured service worker uses a combination of appropriate caching
    strategies. The key part of that sentence is a *properly configured service worker*,
    which is, as you should know by now, not simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Workbox is a tool to scaffold the caching components in your service worker.
    The tool focuses on providing boilerplate code to help with the following service
    worker areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Precaching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background sync
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helpful debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workbox's history is rooted in a pair of now deprecated projects, `sw_precache`
    and `sw_toolbox. sw_precache`, which are managed precaching assets and `sw_toolbox`
    handled dynamic caching. Workbox focuses on managing all caching and invalidation
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Workbox is currently at version 3.2 and has
    come a long way in the past 18 months. Its strength is its ability to abstract
    complex code away from you, the developer. Instead, you can focus on configuration
    and in some cases, customization.
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this chapter, I will focus on updating the PWA ticket application
    to replace most of the code covered in [Chapter 8](part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d),Â *Applying
    Advanced Service Worker Cache Strategies*, with Workbox. I created a separate
    branch in the source repository called workbox.
  prefs: []
  type: TYPE_NORMAL
- en: Installing workbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Workbox is a collection of library and node modules. To get the full breadth
    of the tool, you need to install the node modules globally and clone the GitHub
    repository. Cloning the library is not required, but I recommend it so that you
    can study how the library is structured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Workbox node modules include command-line interfaces to help you scaffold
    your service worker and Workbox components. I will cover how to use the CLI as
    I explain the different parts of the tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step you need to take after installing the CLI is to run the Workbox
    wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will start a series of questions about your application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00139.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create a configuration file that the `workbox-cli` tool can use during
    additional steps. This is what it generates when run and choosing the default
    options for the PWA ticket app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The CLI commands use the settings in the configuration file to find all the
    files matching the `globPatterns` and creates an entry in the precache array.
    I will cover the precache list format in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00140.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: I don't advise precaching 600 files and 11 MB like this example demonstrates.
    Instead, you should customize the configuration to trim the list to a proper amount.
    In this case, the PWA tickets app has all the ticket barcodes generated as part
    of the build process, so there is data to develop against.
  prefs: []
  type: TYPE_NORMAL
- en: I'll circle back around to show you how to customize the configuration file
    to maximize your Workbox service worker experience. The configuration file and
    the workbox-cli commands to compose your service worker are key to using the library.
  prefs: []
  type: TYPE_NORMAL
- en: You are free to use the Workbox library any way you see fit. The configuration
    is for the command-line tools. If you are not familiar with the different nuances
    to how Workbox works, then I suggest starting with the wizard first.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have mastered or at least feel very comfortable with how the Workbox
    library works, you can start integrating it by hand. It all starts with importing
    the library to your service worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous chapters, I demonstrated how you can use `importScripts` to reference
    additional scripts within your service worker. You will need to reference the
    workbox library using `importScripts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This example shows how I replaced some of the supporting libraries in the PWA
    tickets app with a reference to the CDN hosted Workbox script. The library is
    hosted in the Google Cloud CDN.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `workbox-cli copyLibrary` command to copy the library to
    your site. The library is not a single file, but a collection of many files containing
    different JavaScript classes. These files are all copied to the target directory.
    I used the `/sw` folder in the PWA tickets app.
  prefs: []
  type: TYPE_NORMAL
- en: 'A folder with the current Workbox version number is created within the target
    folder. To add a reference to the library, you need to reference the `workbox-sw.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In previous Workbox versions, the entire library was loaded, which is a lot
    of code. This has been improved, so that now only the files needed by your service
    worker are loaded, reducing the payload and required storage. The 3.2 version
    I am using for this example has 23 different files or classes.
  prefs: []
  type: TYPE_NORMAL
- en: If you look in the folder that's created by the `copyFiles` method, you will
    see more. There are two versions for each class, production and debug. There are
    also source map files as well. I will show you how to toggle which versions are
    used as well as how to tell Workbox how to find the local modules a little later.
  prefs: []
  type: TYPE_NORMAL
- en: The CLI tool is a great way to familiarize yourself with using Workbox to scaffold
    your service worker, but it is really just a library. In the next section, I will
    review how the library is structured and get you started with how to use Workbox
    in your service workers to maximize your experience.
  prefs: []
  type: TYPE_NORMAL
- en: Workbox structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you import the Workbox library, you are importing the root level module.
    The module loads additional components belonging to the workbox namespace, such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '`workbox`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.precaching`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.routing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.strategies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`` `workbox.expiration` ``'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.backgroundSync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.googleAnalytics`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.cacheableResponse`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.broadcastUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.rangeRequest`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox.streams`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each library has its own API. Some are higher level and others work within or
    even extend others. Routing uses the strategies classes, which in turn can be
    extended through plugins. The Workbox libraries can handle most scenarios out
    of the box, but are configurable and extensible to allow you to customize them
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: You are not limited to the modules included in the library. You can create your
    own components and add even more value to Workbox's functionality. You can also
    use their modules as references to build your own custom solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Service worker setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Workbox uses a debug version of the library with extra logging
    capabilities. You can turn this off and use the production version by setting
    the debug flag to false in the `setConfig` method. The production version is more
    lightweight, which means you won''t be as much of a burden on your customer''s
    data plans. The production code is minified and has heavier logging capabilities
    removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By default, Workbox loads modules from the CDN. If you are hosting Workbox on
    your server, then you need to configure Workbox to load modules from your server.
    This requires using the `modulePathPrefix` in the configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure Workbox to use a local production version, the `setConfig` call
    would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can let Workbox manage everything about your service worker, including
    life cycle events. If you want your service worker to immediately become active,
    you should do this for the `skipWaiting` (in [Chapter 5](part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d),
    *The Service Worker Life Cycle*) and `clientsClaim` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you are integrating Workbox components in your service worker and are not
    outsourcing all life cycle management to Workbox, then you can still manage this
    within the install and active events, as you learned earlier in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-caching with Workbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this book, I covered the concept of pre-caching assets within the
    install event. The standard pattern used is to create a list of URLs to cache
    and pass those to the `cache.addAll` method. This is great when your application
    is very stable and rarely changes assets. But what if you only need to update
    a handful of the pre-cached responses?
  prefs: []
  type: TYPE_NORMAL
- en: Instead of using the `cache.addAll` method, you need to create more sophisticated
    routines to check revisions against cached assets and perform updates.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the Workbox precaching module is helpful. It abstracts the complex
    logic required to manage your pre-cached assets. You can still supply a simple
    array of URLs, as I have demonstrated in previous chapters, and it will cache
    those. But you have the option of also including a corresponding hash or revision
    value Workbox which you can use to track the asset.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `workbox.precaching.precahceAndRoute` method accepts an array which can
    contain strings, objects, or a combination of both. In this example, I have just
    copied the PWA tickets pre-cache list into the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Workbox maintains an index of cached responses with extra meta data in `IndexedDB`.
    It can only use this to update precached assets when needed. The change you need
    to make is converting your pre-cache list from just strings to objects containing
    the URL and a revision value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, I have a modified the version of the list, showing just a few of the
    entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The most common way to generate a revision value is to calculate the file's
    hash. I demonstrated how to generate file hashes in [Chapter 8](part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d),
    *Applying Advanced Service Worker Cache Strategies*. You can leverage this routine
    as part of your build process or you can leverage the Workbox CLI to help.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the Workbox CLI wizard, it uses the glob patterns to identify
    your site''s assets. It creates a list of files to pre-cache with a hash value
    assigned to the corresponding revision values. You have two options: let the wizard
    scaffold your entire service worker, or have it inject the precaching code into
    an existing service worker.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `injectManifest` functionality allows you to inject pre-caching code using
    the Workbox infrastructure. This is done using the CLI and the `injectManifest`
    command. You need to supply the path to the configuration script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The CLI tool looks for the following to replace with a call to `preCacheAndRoute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This method allows you to maintain a source service worker you can modify as
    part of your build process. It also allows you to lean on the wizard to create
    the file hashes for you.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a file naming convention that includes a hash or revision value,
    you can continue to do this without supplying the hash to Workbox. For these scenarios,
    you can just supply the string reference.
  prefs: []
  type: TYPE_NORMAL
- en: Some files cannot use revision values in their file names, like the path to
    any HTML. Changing the URL changes the address, which means you either need to
    configure complex 301 redirect rules or worse, break links to assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the `precacheAndRoute` method is passed an array of both strings,
    URLs with revision values built into the names, and objects for the HTML files
    without a revisioned name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You can build your list and call the `preCacheAndRoute` method, as I have shown,
    but you can also break the precache list into logical groups so that you can supply
    those individually using the `workbox.precaching.precache` method. After you have
    supplied all the precache references, you must call the `addRoute` method to complete
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you are using the CLI to generate a list of files and hash values to pre-cache,
    you need to trim or limit the files it includes in the list. For example, the
    PWA tickets application automatically creates hashed names for style sheets and
    scripts, but not the templates and HTML assets.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple modification of the site''s Workbox configuration file removes the
    css and js files from the automated process. Just remove those extensions from
    the `globPatterns` regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Also note that I added a `globIgnores` property to the config as well. This
    tells the wizard to ignore any files matching these patterns. I know that the
    QR codes are generated by ticket and the venue images should only be loaded as
    needed. I also added a few additional patterns to the ignore list. Now, those
    assets are not pre-cached, and instead of precaching over 11 MB of assets, the
    service worker will now pre-cache 886 KB in 39 files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00141.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Workbox ships with three ways you can use it to generate the revision values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`workbox-build`: Can be included in a task runner like grunt, gulp, or npm
    script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox-cli`:Â Can generate a list and add it to a scaffolded service worker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workbox-webpack-plugin`:Â For webpack users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You are not limited to the revision values the Workbox tools generate, and you
    can generate them as part of your own build process. The revision value just needs
    to be unique for each version of the file so that the Workbox service worker libraries
    can check to see if it needs to update the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Workbox can manipulate requests to match variations to cached versions. For
    example, often, marketing tags are added in the `QueryString` and vary for many
    reasons. Workbox can be configured to ignore `QueryString` patterns to avoid duplicate
    content caching.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the common variation scenarios Workbox can be configured to optimize:'
  prefs: []
  type: TYPE_NORMAL
- en: '**queryStrings and URL parameters**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Default documents**: `index.html` and `default.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cean URLs**: Automatically appending `.html` to extension-less URLs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom manipulations**: An opportunity for you to define a callback method
    to return an array of possible matches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This requires using the `precaching.PrecacheController` object. To do so, you
    need to create a new instance of the controller and use the `addToCacheList` method.
    This method consumes the same array(s) used with the precaching methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is that you must manage the service worker install, activate,
    and fetch events manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Inside the service worker event install and activate handlers, you need to call
    the `precacheController` `install` and `cleanup` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-caching is just one of Workbox's strengths. Its pre-caching system solves
    a common issue encountered with pre-caching, and that is how to keep the cached
    assets up to date without flushing the entire cache and reloading. Now, you can
    update the service worker and it will only update changed assets, a big win.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-caching system is also highly configurable and customizable. Even though
    Workbox performs a lot of work behind abstractions, you don't need to feel like
    you lost control.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic routes with Workbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, the Workbox section has focused on scaffolding, pre-caching,
    and configuration concerns. But as you should know by this point, the complexity
    of a service worker grows, managing dynamic requests or any request that does
    not have a pre-cached response.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Workbox really flexes its muscles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic routes, like the PWA tickets event pages, need to have custom caching
    logic applied to them. This is where the `workbox.routing` object comes into play.
    For each dynamic route, you need to register what the route is and a handler using
    the `registerRoute` method. Its signature looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The method requires a match and handler callback method. Each one of these callback
    methods is supplied a URL and event (`FetchEvent`) object. The callback methods
    use these parameters to determine what to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The callback signatures should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The match callback should evaluate the request and return back a truthy value,
    indicating if the request matches the pattern or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can also supply a regular expression object (`RegEx`). This gives you the
    flexibility to assign a route handler to multiple, related assets at the same
    time. This is the most common way you will use Workbox routing.
  prefs: []
  type: TYPE_NORMAL
- en: The handler callback is free to apply any caching strategy needed. Again, the
    method should use the URL and event objects to perform these actions, just like
    you learned in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example shows how you might integrate the `fetchAndRenderResponseCache`
    functionality demonstrated in [Chapter 8](part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d),
    *Applying Advanced Service Worker Cache Strategies*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In most cases, you won't need to create your own custom callback methods because
    Workbox has strategy modules for most common scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also define a default handler for any route that may not have an explicit
    handler registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Notice how I used one of the caching strategies as the default, `cacheFirst`?
    This should help us segway to the next step in dynamic routes, using caching strategies.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should probably have a handler any time there is an exception retrieving
    a response. Workbox can do this with the `routing.setCacheHandler` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Caching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Workbox has the five most common caching strategies built into the library:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Stale-While-Revalidate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cache-First`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Network-First`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Network-Only`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cache-Only`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of these strategies is available as a method in the `workbox.strategies`
    namespace. You can use these strategies without any custom configuration, but
    as you have seen, everything in Workbox of highly configurable.
  prefs: []
  type: TYPE_NORMAL
- en: The best part is that these strategy methods return a reference to a properly
    configured route response handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use any of these strategies with your own fetch handler, feel
    free. Create a new instance of the desired strategy. Then, use the `event.respondWith`
    method, suppling the strategy''s handle method. You just need to supply the `fetch`
    `event` object to the handle method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Each strategy method lets you configure the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: The cache name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expiration policy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins to extend the functionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each caching strategy method accepts an `options` object. Here, you can specify
    these customizations. First, is the `cacheName`. In this example, I am registering
    a custom route to catch individual event page requests and cache them in the events
    named cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: I like this option because it makes it easier to manage how different asset
    types are cached and invalidated. Workbox makes managing invalidation easier with
    a custom module.
  prefs: []
  type: TYPE_NORMAL
- en: Workbox cache invalidation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cache invalidation is handled by the Workbox Expiration plugin. This plugin
    allows you to control how many responses, lifetime, or a combination of both can
    be cached for a specific rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'The expiration plugin is applied to the route''s handler or caching strategy
    method. This is done by adding a new expiration plugin reference to the strategy''s
    plugins array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If you want to limit the number of cached responses for the rule, supply a numeric
    value for the `maxEntries` property. If you want to limit a responses time to
    live, supply a numeric value matching the number of seconds a response is valid
    for. As the preceding example demonstrates, you can use both at the same time.
    In this situation when either of the conditions is true, the clean-up logic is
    triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Adding background sync functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service worker background sync is a little complicated. It requires that you
    wrap all network-related activities you want to include in your sync logic in
    tags. This means in many cases that you must modify or completely rewrite your
    caching logic.
  prefs: []
  type: TYPE_NORMAL
- en: Plus, most browsers do not have support for this feature yet. We are on the
    verge of ubiquitous support, but that has limited this important feature's appeal.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Workbox includes a plugin module to make background sync a breeze.
    Just like the Expiration plugin, you add the Background Sync plugin to a strategy''s
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Inside the plugin, a queue is managed that works with the background sync API
    to make sure requests are sent to the server. You can limit how long the service
    worker will try to connect with the server. In this example, I limited the retry
    to a single day. Unlike the expiration plugin, the `maxRetentionTime` property
    is measured in minutes, not seconds.
  prefs: []
  type: TYPE_NORMAL
- en: The added complexity background sync adds to your service worker code, which
    been a big roadblock for my enthusiasm. Workbox making this feature easy to integrate
    means it is much easier for you and I to add an extra layer of functionality to
    our web apps without writing this complex code.
  prefs: []
  type: TYPE_NORMAL
- en: Background sync is an important feature if you are expecting responses or data
    from end users. I know many enterprise applications rely on internet connectivity,
    but employees may not be on stable Wi-Fi. This gives them to the ability to be
    productive when there is intermittent or no connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: As a word of caution, I do advise you to give the user advice about the state
    of the requests hanging in the background synch queue. This way, they know the
    form they submitted has not been submitted to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google Analytics, even when the user is offline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common question I am asked and see others asking in various forums is, "how
    can I use analytics services like Google Analytics with a service worker?"
  prefs: []
  type: TYPE_NORMAL
- en: What they are ultimately asking is how they can use an analytics package when
    the device is offline, but the service worker allows the user to continue using
    the application. How do user activities get logged to the analytics tool?
  prefs: []
  type: TYPE_NORMAL
- en: The good news is that you can track offline activity with a service worker,
    but it does require extra plumbing on your part to store all the activities in
    a custom queue and sync those to the analytics package when the device comes back
    online.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds simple, right?
  prefs: []
  type: TYPE_NORMAL
- en: One area I did not spend any time on in this book is the background sync API.
    There were a few good reasons, mostly due to limited browser support and the added
    complexity it brings to your service worker.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever written an application with a dependency on an analytics package
    like GA, Ensighten, and so on, you know things can be complex. Stakeholders use
    this data to know if their marketing campaigns and websites are working and where
    they can focus improvement activities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that Workbox has you covered, at least for Google Analytics.
    Workbox is a Google project, so you should expect them to offer easy support for
    one of their products! Easy might be understating their solution, as it is a single
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This turns on the Workbox library that manages Google analytics. Every request
    and response is managed through a background sync layer. If you need to perform
    some advanced configurations, you have that option as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you need to differentiate online versus offline activities,
    you can provide overrides. If you understand custom dimensions, the cd1 parameter
    will make sense to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Even though Workbox only includes a Google Analytics provider does not mean
    you can't create a similar handler for your analytics package. You can use the
    GA provider as a reference or template to create your own analytics package provider.
    The production code is located in the `workbox-google-analytics.prod.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Don't limit yourself to just thinking about analytics packages when it comes
    to synchronizing offline activities. Use this as a model for any online API you
    may need to interact with where the user can continue interaction, even when their
    device is offline. This can be very handy for companies with line of business
    apps for field agents.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have always been a fan of tooling and automation to make my applications faster
    to code with more maintainability and hopefully fewer bugs, but it is important
    you have a firm understanding of what any generate code or component is doing.
    This is why even when you are using the progressive web application tools I highlighted
    in this chapter that you need to be able recognize their strengths and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to have a firm understanding of how complex features like service
    workers function before you start using a tool like Workbox. Without this fundamental
    knowledge, you can quickly make a service worker that does not work as you expect.
    You also need to have a strong knowledge foundation to help you debug issues when
    these tools break.
  prefs: []
  type: TYPE_NORMAL
- en: I chose four tools I think add the most value for the developers to review in
    this chapter. This by no means that all the tools available to you help you build
    great progressive web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Pinterest has a small collection of tools you may find useful on GitHub ([https://github.com/pinterest/service-workers](https://github.com/pinterest/service-workers)).
    They also have a tool to generate a service worker. There is also a webpack plugin.
    But the most intriguing tool may be their service worker unit testing mocking
    environment. This allows you to write unit tests against your service worker without
    running a browser instance.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the major frameworks have also released command-line utilities to help
    you generate routing logic against your single page applications. I am also very
    intrigued with the rapid inclusion of CLI tools to convert these rendering engines
    into server engines using the same logic they have shipped to the client. I think
    these static sites are much easier to build PWA logic around as they have real
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: With the increased demand for PWAs by businesses, developers are put in the
    position where we need to have a deep knowledge of how to create new and update
    existing web apps so that they can be progressive web apps with a range of service
    worker complexity. The tools surveyed in this chapter should help you craft those
    solutions. I hope this book has helped give you the firm foundation you need to
    make those applications.
  prefs: []
  type: TYPE_NORMAL
