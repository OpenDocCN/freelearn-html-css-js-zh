<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-150"><a id="_idTextAnchor152"/>10</h1>
<h1 id="_idParaDest-151"><a id="_idTextAnchor153"/>State Management with Svelte Stores</h1>
<p>Every user interface control has a state. A checkbox has a checked-unchecked state. A textbox’s state is its current input value. A table’s state is the data displayed and the columns currently being sorted. Sometimes when you have multiple user interface controls present across the screen at the same time, you need to synchronize the state across them—this is where state management comes in.</p>
<p>In this chapter, we are going to discuss managing states in Svelte using Svelte stores. We will start with why we should use Svelte stores, and then discuss tips that will help you when using Svelte stores for state management.</p>
<p>Next, we will go into the topic of using state management libraries. We will talk about why and how to use them. With that, we will be going through a few examples of integrating third-party state management libraries into Svelte through Svelte stores.</p>
<p>This chapter includes sections on the following topics:</p>
<ul>
<li>Managing states with Svelte stores</li>
<li>Using state management libraries with Svelte</li>
</ul>
<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/>Technical requirements</h1>
<p>The code in this chapter can be found on GitHub: <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10</a>.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/>Managing states with Svelte stores</h1>
<p>When<a id="_idIndexMarker365"/> building<a id="_idIndexMarker366"/> an interactive user interface, the first thing we consider is determining the necessary states to represent the various components and interactions.</p>
<p>For example, in the following snippet, I have a login form that has a few components, including two inputs, one checkbox, and one button:</p>
<pre class="source-code">
&lt;Input name="username" /&gt;
&lt;Input name="password" /&gt;
&lt;Checkbox label="Show Password" /&gt;
&lt;Button&gt;Submit&lt;/Button&gt;</pre> <p>Each of the Svelte components has multiple states, as outlined here:</p>
<ul>
<li>The <code>&lt;Input /&gt;</code> component has an input value state and an error state set during validation</li>
<li>The <code>&lt;Checkbox /&gt;</code> component has a checked/unchecked state, checked to reveal the password in the input</li>
<li>The password <code>&lt;Input /&gt;</code> component has an additional state to reveal/hide the password</li>
<li>The <code>&lt;Button /&gt;</code> component has an enabled/disabled state, disabled when the form is incomplete</li>
</ul>
<p>Each of these states can be represented by a variable. The variables themselves can be interrelated.</p>
<p>Let us examine <a id="_idIndexMarker367"/>how <a id="_idIndexMarker368"/>these variables can be related to each other. For example, when the checkbox is checked, the password input needs to reveal the password. When the name and password inputs are filled, the button needs to turn into an enabled state. When the button is pressed, validation is performed, and the inputs’ error state is updated accordingly.</p>
<p>The art of managing multiple states across components to form a cohesive experience is called state management.</p>
<p>It would be clearer and easier to group all these states together and manage them as one, rather than separate individual states. In the following snippet, I group all of the aforementioned variables into one variable object:</p>
<pre class="source-code">
const state = {
  nameValue: '',
  nameError: null,
  passwordValue: '',
  passwordError: null,
  revealPassword: false,
  submitDisabled: true,
}</pre> <p>Here, you can see the related states in one place, making it easier to see and tell if something is wrong.</p>
<p>To illustrate this, let’s say the <code>nameValue</code> and <code>submitDisabled</code> variables are kept as two separate <a id="_idIndexMarker369"/>variables<a id="_idIndexMarker370"/> in two separate components; in the <code>Input</code> component, we have the <code>nameValue</code> variable:</p>
<pre class="source-code">
&lt;!-- Input.svelte --&gt;
&lt;script&gt;
  export let nameValue = '';
&lt;/script&gt;
&lt;input bind:value={nameValue} /&gt;</pre> <p>And in the <code>Button</code> component, we have the <code>submitDisabled</code> variable:</p>
<pre class="source-code">
&lt;!-- Button.svelte --&gt;
&lt;script&gt;
  export let submitDisabled = false;
&lt;/script&gt;
&lt;button disabled={submitDisabled}&gt;Submit&lt;/button&gt;</pre> <p>From the code, you can see that it is not straightforward to tell whether the <code>nameValue</code> and <code>submitDisabled</code> variables are related. If one of the states is not updated as expected, you don’t have one convenient place to inspect both states at once; you will have to inspect them in each separate component.</p>
<p>For example, if the <code>submitDisabled</code> state in the <code>&lt;Button /&gt;</code> component did not change to <code>false</code> to enable the button after typing in the name input, you would need to find and inspect the <code>nameValue</code> variable in a separate component (the <code>&lt;Input /&gt;</code> component).</p>
<p>If, instead, the states are grouped into a <code>state</code> object, then you can inspect the <code>state</code> object and check the <code>nameValue</code> and the <code>submitDisabled</code> properties and see if they are set correctly. Have a look at the following example:</p>
<pre class="source-code">
const state = {
  nameValue: '',
  submitDisabled: true,
};</pre> <p>Now that we’ve established that we should group multiple related states into one state object, the next question is this: If we could group states using a simple JavaScript object, why would it be necessary to group states using a Svelte store?</p>
<p>Well, the truth is, it is not always necessary. In some cases, using a simple JavaScript object to group states can work just as effectively. However, a Svelte store offers additional benefits and functionality that can enhance your state management experience.</p>
<p>As we<a id="_idIndexMarker371"/> explored<a id="_idIndexMarker372"/> in <a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a>, a Svelte store is useful as it can be passed around components and have its updates propagate across components. Then, in <a href="B18887_09.xhtml#_idTextAnchor135"><em class="italic">Chapter 9</em></a>, we saw how useful a Svelte store is, being able to encapsulate logic within the Svelte store, as well as being able to define data logic right next to the data itself.</p>
<p>So, for the sake of the chapter, we are going to proceed with grouping multiple related states into a state object using a Svelte store. Here’s a short snippet of code of how it would look:</p>
<pre class="source-code">
&lt;script&gt;
  import { writable } from 'svelte/store';
  const state = writable({
    nameValue: '',
    nameError: null,
    passwordValue: '',
    passwordError: null,
    revealPassword: false,
    submitDisabled: true,
  });
&lt;/script&gt;</pre> <p>Here, we use a <code>writable()</code> store for creating the state object because we will be modifying the state object.</p>
<p>The state object can be defined either inside or outside a Svelte component. Since our state object is a Svelte store, we can import the state object into any component, and any updates to the state object will be propagated across all Svelte components that use the state object—so, it doesn’t matter in which file we define the state object in.</p>
<p>If we define our<a id="_idIndexMarker373"/> state <a id="_idIndexMarker374"/>object in a Svelte component, then we can pass our state object to the component’s child component through props. Here’s an example of doing so:</p>
<pre class="source-code">
&lt;script&gt;
  const state = writable({ name: 'Svelte' });
&lt;/script&gt;
&lt;Input {state} /&gt;</pre> <p>On the other hand, if we define our state object in a JavaScript module, then we can import our state object into any Svelte components that will be using the state object. The following is a snippet of importing a Svelte store state object into a Svelte component:</p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  // import state object defined in './state.js'</strong>
<strong class="bold">  import { state } from './state.js';</strong>
&lt;/script&gt;</pre> <p>In <a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a>, we learned how to read, subscribe to, and update a Svelte store. Whether the data stored inside a Svelte store is a state object or anything else, there is no difference in terms of the operations to read, subscribe, and update the Svelte store state object like any other Svelte store.</p>
<p>But as the state is used more frequently in a growing project, you will have more state values inside a <code>state</code> store object. As the <code>state</code> store gets larger and more complex, your application may get slower, and you may feel the need to optimize/improve it. Therefore, I am dedicating the following subsections to sharing my tips and opinions on state management with a Svelte store.</p>
<p>Of course, you shouldn’t apply all these methods blindly. As said by Donald Knuth, the famous<a id="_idIndexMarker375"/> computer <a id="_idIndexMarker376"/>scientist, “<em class="italic">Premature optimization is the root of all evil</em>”—you should measure and evaluate whether any of the following tips apply. As I go through the tips, I will explain what they are and why and when are they useful.</p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor156"/>Tip 1 – simplify complex state updates with unidirectional data flow</h2>
<p>When your application<a id="_idIndexMarker377"/> becomes more complex, with multiple components and multiple places to update your state, managing state updates becomes even more challenging.</p>
<p>How would you know when managing state updates becomes unmanageable? You may run into situations such as this:</p>
<ul>
<li>Your application state changes, and you find it hard to track down why the state changed</li>
<li>You change a certain state value, but unknowingly, this causes other seemingly unrelated state values to update as well, and you have a hard time working out why</li>
</ul>
<p>These are signs that the state updates have grown complex and become difficult to manage. In such situations, having unidirectional data flow can help simplify state management.</p>
<p>With unidirectional data flow, state updates are managed in a single direction, and the flow of data can be easily traced and debugged.</p>
<p>There are state management libraries such as Redux, MobX, and XState that help to enforce a single data flow and enable you to reason with the state changes. You may be curious about how to use these state management libraries with a Svelte store; I will be covering them later in this chapter and will use one of the libraries as an example.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor157"/>Tip 2 – prefer smaller self-contained state objects over one big state object</h2>
<p>In Svelte, when a state object changes, all components that use that state object are updated, even if the specific state value that a component uses did not change. This means that if a state object becomes larger and more complex, with many unrelated state values, updating that state object can trigger unnecessary updates to many components in the application.</p>
<p>Here, I am going to use a product details page of an e-commerce web application as an example. In a typical e-commerce web app, you have a page that shows the details of a product. You will see other information, such as the shopping cart and product reviews, on the same page as well.</p>
<p>If I use one state<a id="_idIndexMarker378"/> object for all the information on the page, it may look like this:</p>
<pre class="source-code">
&lt;script&gt;
  let state = {…}
&lt;/script&gt;
&lt;ShoppingCart cart={$state.cart} /&gt;
&lt;ProductDetails product={$state.product} /&gt;
&lt;ProductRatings ratings={$state.ratings} /&gt;</pre> <p>In the preceding code, we use the same state object, <code>$state</code>, across three components: <code>ShoppingCart</code>, <code>ProductDetails</code>, and <code>ProductRatings</code>. When any part of the <code>$state</code> state object changes, such as changing <code>$state.cart</code>, all three components will be triggered to update.</p>
<p>This is undesirable—multiple components updating unnecessarily could lead to slower performance and a less responsive user interface.</p>
<p>So, it is recommended to split big state objects into smaller state objects. Using the same example, that would mean splitting the <code>$state</code> state object into three smaller state objects, like so:</p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  let cartState = {…};</strong>
<strong class="bold">  let productState = {…};</strong>
<strong class="bold">  let ratingState = {…};</strong>
&lt;/script&gt;
&lt;ShoppingCart cart={<strong class="bold">$cartState</strong>} /&gt;
&lt;ProductDetails product={<strong class="bold">$productState</strong>} /&gt;
&lt;ProductRatings ratings={<code>$cartState</code>, would not trigger an update on the <code>&lt;ProductDetails /&gt;</code> and <code>&lt;ProductRatings /&gt;</code> components.</p>
<p>So, if you have big state objects and you find components update unnecessarily and the performance of your application is impacted by it, then consider breaking these big state objects down into smaller state objects.</p>
<p>But what if the state object is still big, yet the different values in the state objects are closely related <a id="_idIndexMarker379"/>and you are unable to break it apart into smaller state objects? Well, there is still hope, which leads us to our third tip.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor158"/>Tip 3 – derive a smaller state object from a bigger state object</h2>
<p>If state values are related to each other and so you can’t break a big state object into smaller state objects, we can create smaller state objects that derive from the big state object. Let me show you some code to explain this clearly.</p>
<p>Let’s say that you have a state object, <code>userInfo</code>, that has two closely related state values, <code>$userInfo.personalDetails</code> and <code>$userInfo.socials</code>, as shown here:</p>
<pre class="source-code">
import { writable } from 'svelte/store';
const userInfo = writable({
  personalDetails: {...},
  socials: {...},
});</pre> <p>You may realize that one part of the <code>userInfo</code> state object doesn’t change as often as the other. But whenever any part of <code>userInfo</code> changes, all the components that use either the <code>$userInfo.personalDetails</code> or <code>$userInfo.socials</code> state values will be updated.</p>
<p>To ensure that components using only <code>$userInfo.socials</code> are updated exclusively when <code>$userInfo.socials</code> changes, one way would be to break the state object into smaller, more focused state objects, like so:</p>
<pre class="source-code">
import { writable } from 'svelte/store';
const userPersonalDetails = writable({...});
const userSocials = writable({...});</pre> <p>As you can see, you now have two separate state objects, <code>userPersonalDetails</code> and <code>userSocials</code>.</p>
<p>But this would mean that places where you previously updated the <code>userInfo</code> state object would have <a id="_idIndexMarker380"/>to change since <code>userInfo</code> is now split into two separate state objects.</p>
<p>Here is how you would change the code:</p>
<pre class="source-code">
// previously
$userInfo = newUserInfo;
// now
$userPersonalDetails = newUserInfo.personalDetails;
$userSocials = newUserInfo.socials;</pre> <p>So, the question now is this: Is there an alternative to not having to change this, yet being able to update the components that use <code>$userInfo.socials</code> only when <code>$</code><code>userInfo.socials</code> changes?</p>
<p>I believe I’ve leaked the answer already. The alternative is to derive a new state object. In the following code snippet, I am deriving a new <code>userSocials</code> state object from the <code>userInfo</code> state object:</p>
<pre class="source-code">
import { derived } from 'svelte/store';
const userSocials = derived(userInfo, $userInfo =&gt; $userInfo.socials);</pre> <p>The component that uses <code>$userSocials</code> will only update whenever the <code>userSocial</code> state changes. The <code>userSocial</code> state changes only when the <code>$userInfo.socials</code> changes. So, when the component uses <code>$userSocials</code> instead of <code>$userInfo.socials</code>, it will not update when any other part of the <code>userInfo</code> state object changes.</p>
<p>I believe that seeing is believing, and it will be much clearer to see and interact with an example to get this idea forward. So, I’ve prepared some demo examples at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10/01-user-social">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10/01-user-social</a>, and you can try them out and see what I mean.</p>
<p>Let’s quickly recap the three tips:</p>
<ul>
<li>Whenever the state update logic is complex and convoluted, introduce some state management libraries to enforce simpler and unidirectional data flows</li>
<li>If the state object gets too big, and state changes update more components than needed, break the state object into smaller state objects</li>
<li>If you can’t split a Svelte store state object, consider deriving it into a smaller state object</li>
</ul>
<p>So, we’ve gone<a id="_idIndexMarker381"/> through my three general tips for managing complex stores in a Svelte application; let’s now elaborate more on my first tip on how to use state management libraries with Svelte.</p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor159"/>Using state management libraries with Svelte</h1>
<p>If you google <em class="italic">State management library for frontend development</em>, at the time of writing, you <a id="_idIndexMarker382"/>will get list after list of libraries, such <a id="_idIndexMarker383"/>as Redux, XState, MobX, Valtio, Zustand, and many more.</p>
<p>These libraries have their own take on how states should be managed, each with different design considerations and design constraints. For the longevity of the content of this book, we are not going to compare and analyze each of them since these libraries will change and evolve over time and potentially be replaced by newer alternatives.</p>
<p>It is worth noting that some of the state management libraries are written for a specific web framework. For example, at the<a id="_idIndexMarker384"/> time of writing, the Jōtai library (<a href="https://jotai.org/">https://jotai.org/</a>) is written specifically for React, which means you can only use Jōtai if you write your web application in React.</p>
<p>On the other hand, there are framework-agnostic state management libraries. An example is <a id="_idIndexMarker385"/>XState (<a href="https://xstate.js.org/">https://xstate.js.org/</a>), which can be used by any web framework as the XState team has created packages such as <code>@xstate/svelte</code> to work with Svelte, <code>@xstate/react</code> for the React framework, <code>@xstate/vue</code> for Vue, and many more.</p>
<p>While the <code>@xstate/svelte</code> package is tailored for seamless integration of XState in Svelte, not all state management libraries offer this level of compatibility. Nevertheless, there are several other state management libraries that you can use in Svelte, and integrating them is straightforward. In fact, I will provide some examples to showcase how simple it is to integrate these libraries in Svelte and utilize Svelte’s first-class capabilities for working with stores.</p>
<p>One such state management library that works seamlessly <a id="_idIndexMarker386"/>with Svelte is Valtio (<a href="https://github.com/pmndrs/valtio">https://github.com/pmndrs/valtio</a>), a minimalist library that turns objects into self-aware proxy states. We are going to explore how we can use Valtio in Svelte, by turning Valtio’s proxy <a id="_idIndexMarker387"/>state into a Svelte store and using the <a id="_idIndexMarker388"/>Svelte store’s <code>$</code>-prefixed syntax to subscribe to the proxy state changes and access the proxy state value.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor160"/>Example – using Valtio as a Svelte store</h2>
<p>Before we start<a id="_idIndexMarker389"/> talking about how to use Valtio in Svelte, let’s look <a id="_idIndexMarker390"/>at how to use Valtio on its own.</p>
<h3>Using Valtio</h3>
<p>Valtio turns the<a id="_idIndexMarker391"/> object you pass to it into a self-aware proxy state. In the following code snippet, we create a Valtio state named <code>state</code> through the <code>proxy()</code> method:</p>
<pre class="source-code">
import { proxy } from 'valtio/vanilla';
const state = proxy({ count: 0, text: 'hello' });</pre> <p>To update the proxy state, you can make changes to it the same way you would to a normal JavaScript object. For example, we can increment the value of <code>state.count</code> by mutating the value directly, as follows:</p>
<pre class="source-code">
setInterval(() =&gt; {
  state.count++;
}, 1000);</pre> <p>To be notified of modifications in the proxy state, we can use Valtio’s <code>subscribe</code> method, as illustrated here:</p>
<pre class="source-code">
import { subscribe } from 'valtio';
const unsubscribe = subscribe(state, () =&gt; {
  console.log('state object changed');
});</pre> <p>In this case, every time we modify the state, the callback function passed into the <code>subscribe</code> method will be called, and we will see a new log in the console, printing <code>'state </code><code>object changed'</code>.</p>
<p>Valtio also allows <a id="_idIndexMarker392"/>you to subscribe only to a portion of a state. For example, in the following snippet, we subscribe only to the changes made to <code>state.count</code>:</p>
<pre class="source-code">
const unsubscribe = subscribe(<strong class="bold">state.count</strong>, () =&gt; {
  console.log('state count changed');
});</pre> <p>Since in this case, we are subscribing only to the changes made to <code>state.count</code>, then modifying <code>state.text</code> would not see a <code>'state count changed'</code> log added to the console as the change to <code>state.text</code> is not subscribed.</p>
<p>The Valtio proxy state is meant for tracking update changes. To read the latest value of the proxy state, we should use the <code>snapshot()</code> method to create a snapshot object, as follows:</p>
<pre class="source-code">
import { subscribe, <strong class="bold">snapshot</strong> } from 'valtio';
const unsubscribe = subscribe(state, () =&gt; {
  <strong class="bold">const obj = snapshot(state);</strong>
});</pre> <h3>Using Valtio as a Svelte store</h3>
<p>Now that <a id="_idIndexMarker393"/>we’ve learned about basic Valtio operations and concepts, let’s<a id="_idIndexMarker394"/> create a simple counter application to see how we can use Valtio in Svelte. Firstly, we create a proxy state for our counter application:</p>
<pre class="source-code">
// filename: data.js
import { proxy } from 'valtio';
export const state = proxy({ count1: 0, count2: 0 });</pre> <p>Here, I am creating two counters, <code>count1</code> and <code>count2</code>, which will later allow us to experiment with subscribing to a specific portion of the proxy state. This way, we can observe whether our application updates only when one of the counters changes.</p>
<p>Also, we are creating the proxy state in a separate file, <code>data.js</code>, rather than declaring it inside a Svelte component; this way, we can import the state separately in each Svelte component later on.</p>
<p>In addition, let’s create two functions to increment the counters:</p>
<pre class="source-code">
export function increment1() {
  state.count1 ++;
}
export function increment2() {
  state.count2 ++;
}</pre> <p>Now, let’s import the proxy state into our Svelte component; I have created two buttons to increment each counter separately:</p>
<pre class="source-code">
&lt;script&gt;
  import { state, increment1, increment2 } from './data.js';
&lt;/script&gt;
Count #1: {state.count1}
Count #2: {state.count2}
&lt;button on:click={increment1}&gt;Increment 1&lt;/button&gt;
&lt;button on:click={increment2}&gt;Increment 2&lt;/button&gt;</pre> <p>If you try clicking on the buttons, you’ll realize that they are not working as expected— the counters are not incrementing.</p>
<p>However, if you add the following code to <code>data.js</code> and click on the button, the console will print out the current value of the counters, indicating that the counters are incrementing successfully:</p>
<pre class="source-code">
import { subscribe } from 'valtio';
subscribe(state, () =&gt; {
  console.log(state);
});</pre> <p>As you can see, the counters are updating as expected. The issue, therefore, does not lie in the inability to increment the counters, but rather in the failure to display the changes on the screen. It is possible that Svelte is not recognizing the changes to the counters, and therefore, it is not updating the elements to show the latest value of the counters.</p>
<p>So, what can <a id="_idIndexMarker395"/>we<a id="_idIndexMarker396"/> do to make Svelte aware of the changes to Valtio’s proxy state?</p>
<p>One approach would be to use a Svelte store, as it provides a mechanism for Svelte components to react to changes in data. We can turn Valtio’s proxy state into a Svelte store. Then, by subscribing to the store, Svelte will be aware of the changes to the state and will update the elements accordingly.</p>
<p>This approach of converting states from other state management libraries into a Svelte store in order to take advantage of Svelte’s built-in update mechanism is very common. It allows developers to use their preferred state management solution while still taking advantage of Svelte’s reactive capabilities.</p>
<p>So, let’s see how we can turn Valtio’s proxy state into a Svelte store. To start off, I am creating a function called <code>valtioStateToSvelteStore</code>:</p>
<pre class="source-code">
function valtioStateToSvelteStore(proxyState) {
  return {};
}</pre> <p>Before creating the Svelte store from the Valtio proxy state, let’s have a quick recap on what the Svelte store contract is. The Svelte store contract dictates that a Svelte store should have a <code>subscribe</code> method and an optional <code>set</code> method. The <code>subscribe</code> method takes a callback function as its only parameter, which will be called whenever the store’s value changes, and returns an <code>unsubscribe</code> function to stop further notifications.</p>
<p>So, let’s define the <code>subscribe</code> method in the returned object of the <code>valtioStateToSvelteStore</code> function, like so:</p>
<pre class="source-code">
function valtioStateToSvelteStore(proxyState) {
  return {
<strong class="bold">    subscribe(fn) {</strong>
<strong class="bold">    },</strong>
  };
}</pre> <p>The initial value <a id="_idIndexMarker397"/>of<a id="_idIndexMarker398"/> the Svelte store can be defined by calling the callback function synchronously with the value of the proxy state:</p>
<pre class="source-code">
function valtioStateToSvelteStore(proxyState) {
  return {
    subscribe(fn) {
      <strong class="bold">fn(snapshot(proxyState));</strong>
    },
  };
}</pre> <p>Our next step is to subscribe to changes in the Valtio proxy state:</p>
<pre class="source-code">
function valtioStateToSvelteStore(proxyState) {
  return {
    subscribe(fn) {
      fn(snapshot(proxyState));
<strong class="bold">      return subscribe(proxyState, () =&gt; {</strong>
<strong class="bold">        fn(snapshot(proxyState));</strong>
<strong class="bold">      });</strong>
    },
  };
}</pre> <p>Based on the Svelte store contract, within the <code>subscribe</code> method, we need to return a function to unsubscribe the callback function from the Svelte store. In our code, the reason we return the return value of the <code>subscribe</code> function from Valtio in our <code>subscribe</code> method is that the return value of Valtio’s <code>subscribe</code> function is a function to unsubscribe from the proxy state.</p>
<p>A function to unsubscribe from changes is just what we need. Isn’t this convenient?</p>
<p>It’s no coincidence that most state management libraries provide methods for subscribing to state changes and unsubscribing from them, just like what we need to define a Svelte store. This is because both Svelte stores and state management libraries are designed based on the Observer pattern we discussed in <a href="B18887_08.xhtml#_idTextAnchor121"><em class="italic">Chapter 8</em></a>. In summary, to turn a state <a id="_idIndexMarker399"/>management <a id="_idIndexMarker400"/>library’s state into a Svelte store, we need to understand how the library works and how its APIs translate into the Svelte store contract.</p>
<p>Now that we have a function to transform a Valtio’s proxy state into a Svelte store, let’s try to use it by running the following code:</p>
<pre class="source-code">
&lt;script&gt;
  import { state, increment1, increment2, <strong class="bold">valtioStateToSvelteStore</strong> } from './data.js';
  <strong class="bold">const store = valtioStateToSvelteStore(state);</strong>
&lt;/script&gt;
Count #1: {<strong class="bold">$store.count1</strong>}
Count #2: {<strong class="bold">$store.count2</strong>}</pre> <p>Clicking on any button in the component, you will see that the counter works perfectly fine now.</p>
<p>So, this is how we turn a Valtio proxy state into a Svelte store.</p>
<p>The next thing I would like to explore is creating a Svelte store that subscribes only to partial updates of the Valtio proxy state. By selecting only a specific portion of the state to monitor, we can ensure that the Svelte store updates only when a particular part of the state changes.</p>
<p>Before we do that, let’s add a few more lines to show you what I mean:</p>
<pre class="source-code">
&lt;script&gt;
  // ...
  $: console.log('count1: ', $store.count1);
  $: console.log('count2: ', $store.count2);
&lt;/script&gt;</pre> <p>As you click on <a id="_idIndexMarker401"/>either <a id="_idIndexMarker402"/>of the increment buttons, you will notice that both reactive statements are called, indicating that <code>$store</code> is updated whenever either <code>count1</code> or <code>count2</code> is updated.</p>
<p>As discussed in the third tip earlier in the chapter, if state changes cause unnecessary code to run, we can derive a smaller state from the original state to only subscribe to partial updates. So, let’s do that:</p>
<pre class="source-code">
&lt;script&gt;
  import { state, increment1, increment2, valtioStateToSvelteStore } from './data.js';
  <strong class="bold">const count1 = valtioStateToSvelteStore(state.count1);</strong>
  <strong class="bold">const count2 = valtioStateToSvelteStore(state.count2);</strong>
  $: console.log('count1: ', <strong class="bold">$count1</strong>);
  $: console.log('count2: ', <strong class="bold">$count2</strong>);
&lt;/script&gt;</pre> <p>Here, instead of turning <code>state</code> into a Svelte store, we are turning <code>state.count1</code> into a Svelte store. This allows us to create separate Svelte stores that only subscribe to a portion of the proxy state.</p>
<p>This should work, but unfortunately, it doesn’t. The reason for this has nothing to do with our code but with the data structure of our state. <code>state.count1</code> is a primitive value, which Valtio is unable to subscribe to.</p>
<p>To work around this, I’m going to change the data type of <code>state.count1</code> from a primitive value to an object:</p>
<pre class="source-code">
export const state = proxy({
  count1: <strong class="bold">{ value: 0 }</strong>,
  count2: <strong class="bold">{ value: 0 }</strong>,
});
export function increment1() {
  <strong class="bold">state.count1.value ++</strong>;
}</pre> <p>In the <a id="_idIndexMarker403"/>preceding <a id="_idIndexMarker404"/>code snippet, we changed <code>state.count1</code> to an object with a property called <code>value</code>. We still keep the code of deriving the <code>count1</code> Svelte store from the <code>state.count1</code> proxy state. So, now, the derived Svelte store of <code>count1</code> would be an object, and to get the value of the count, we will be referring to <code>$count1.value</code> instead of <code>$count1</code>:</p>
<pre class="source-code">
$: console.log('count1: ', <code>count1</code>. Conversely, when you click on the other button, labeled <code>count2</code>. The reactive statement will only run when the respective counter is incremented. That’s because our <code>count1</code> and <code>count2</code> stores only update when a specific part of the Valtio proxy state changes.</p>
<p>So, let’s conclude what we’ve done so far.</p>
<p>We explored the integration of Valtio in Svelte by converting the Valtio proxy state into a Svelte store. Step by step, we implemented the Svelte store contract by leveraging Valtio’s built-in methods for subscribing and unsubscribing. Toward the end, we explored how to subscribe to partial updates of the proxy state, minimizing unnecessary reactivity.</p>
<p>I believe you <a id="_idIndexMarker405"/>are <a id="_idIndexMarker406"/>eager to try it out yourself by now, so let’s use the next state management library as an exercise.</p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor161"/>Exercise – transforming an XState state machine into a Svelte store</h2>
<p>XState (<a href="https://xstate.js.org/">https://xstate.js.org/</a>) is a<a id="_idIndexMarker407"/> JavaScript<a id="_idIndexMarker408"/> library for managing states using state machines. In this exercise, you are going to transform an<a id="_idIndexMarker409"/> XState state machine into a Svelte store.</p>
<p>XState provides a package named <code>@xstate/svelte</code> that includes utilities specifically designed for integrating XState in Svelte. Although this package can be a source of inspiration for your task, the use of <code>@xstate/svelte</code> is, however, not permitted for this exercise. The goal here is to challenge you to implement the function to transform an XState state machine into a Svelte store without the aid of pre-existing integration utilities.</p>
<p>To get started with this exercise, follow these steps:</p>
<ol>
<li><strong class="bold">Understand XState</strong>: If you’re not already familiar with XState, spend some time reading its documentation and experimenting with its features. Understand how state machines work and how XState implements them.</li>
<li><strong class="bold">Create a state machine</strong>: Using XState, create a state machine that you’d like to convert into a Svelte store. This could be a simple machine with a few states and transitions, or something more complex if you’re comfortable with it.</li>
<li><strong class="bold">Transform the state machine into a Svelte store</strong>: Now comes the key part of the exercise. You’ll need to write a function that converts your XState state machine into a Svelte store. This involves subscribing to state changes in the machine and forwarding them to the Svelte store, as well as mapping actions from the store back to transitions in the state machine.</li>
<li><strong class="bold">Test your implementation</strong>: After you’ve completed your conversion, ensure you thoroughly test it. Change states in your store and observe whether the same changes are reflected in your state machine and vice versa.</li>
</ol>
<p>If you’re stuck, take <a id="_idIndexMarker410"/>a<a id="_idIndexMarker411"/> step back and refer to the documentation of XState and this chapter, or the source code of <code>@xstate/svelte</code>.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor162"/>Summary</h1>
<p>In this chapter, we learned about how we can manage our application states with Svelte.</p>
<p>At the beginning of the chapter, we discussed some of the tips for managing states in Svelte through a Svelte store. These tips will be useful to you as your Svelte application grows larger and more complex.</p>
<p>One of the tips that we discussed is using state management libraries to manage data changes and data flows. That’s why we spent the second half of the chapter exploring how we can use state management libraries in Svelte, by transforming the state management libraries’ state into Svelte stores.</p>
<p>In the next chapter, we are going to explore how we can use a combination of both a Svelte context and a Svelte store to create renderless components—logical components that do not render any content.</p>
</div>
</div></body></html>