<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-150"><a id="_idTextAnchor152"/>10</h1>
<h1 id="_idParaDest-151"><a id="_idTextAnchor153"/>State Management with Svelte Stores</h1>
<p>Every user interface control has a state. A checkbox has a checked-unchecked state. A textbox’s state is its current input value. A table’s state is the data displayed and the columns currently being sorted. Sometimes when you have multiple user interface controls present across the screen at the same time, you need to synchronize the state across them—this is where state management <span class="No-Break">comes in.</span></p>
<p>In this chapter, we are going to discuss managing states in Svelte using Svelte stores. We will start with why we should use Svelte stores, and then discuss tips that will help you when using Svelte stores for <span class="No-Break">state management.</span></p>
<p>Next, we will go into the topic of using state management libraries. We will talk about why and how to use them. With that, we will be going through a few examples of integrating third-party state management libraries into Svelte through <span class="No-Break">Svelte stores.</span></p>
<p>This chapter includes sections on the <span class="No-Break">following topics:</span></p>
<ul>
<li>Managing states with <span class="No-Break">Svelte stores</span></li>
<li>Using state management libraries <span class="No-Break">with Svelte</span></li>
</ul>
<h1 id="_idParaDest-152"><a id="_idTextAnchor154"/>Technical requirements</h1>
<p>The code in this chapter can be found on <span class="No-Break">GitHub: </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/>Managing states with Svelte stores</h1>
<p>When<a id="_idIndexMarker365"/> building<a id="_idIndexMarker366"/> an interactive user interface, the first thing we consider is determining the necessary states to represent the various components <span class="No-Break">and interactions.</span></p>
<p>For example, in the following snippet, I have a login form that has a few components, including two inputs, one checkbox, and <span class="No-Break">one button:</span></p>
<pre class="source-code">
&lt;Input name="username" /&gt;
&lt;Input name="password" /&gt;
&lt;Checkbox label="Show Password" /&gt;
&lt;Button&gt;Submit&lt;/Button&gt;</pre> <p>Each of the Svelte components has multiple states, as <span class="No-Break">outlined here:</span></p>
<ul>
<li>The <strong class="source-inline">&lt;Input /&gt;</strong> component has an input value state and an error state set <span class="No-Break">during validation</span></li>
<li>The <strong class="source-inline">&lt;Checkbox /&gt;</strong> component has a checked/unchecked state, checked to reveal the password in <span class="No-Break">the input</span></li>
<li>The password <strong class="source-inline">&lt;Input /&gt;</strong> component has an additional state to reveal/hide <span class="No-Break">the password</span></li>
<li>The <strong class="source-inline">&lt;Button /&gt;</strong> component has an enabled/disabled state, disabled when the form <span class="No-Break">is incomplete</span></li>
</ul>
<p>Each of these states can be represented by a variable. The variables themselves can <span class="No-Break">be interrelated.</span></p>
<p>Let us examine <a id="_idIndexMarker367"/>how <a id="_idIndexMarker368"/>these variables can be related to each other. For example, when the checkbox is checked, the password input needs to reveal the password. When the name and password inputs are filled, the button needs to turn into an enabled state. When the button is pressed, validation is performed, and the inputs’ error state is <span class="No-Break">updated accordingly.</span></p>
<p>The art of managing multiple states across components to form a cohesive experience is called <span class="No-Break">state management.</span></p>
<p>It would be clearer and easier to group all these states together and manage them as one, rather than separate individual states. In the following snippet, I group all of the aforementioned variables into one <span class="No-Break">variable object:</span></p>
<pre class="source-code">
const state = {
  nameValue: '',
  nameError: null,
  passwordValue: '',
  passwordError: null,
  revealPassword: false,
  submitDisabled: true,
}</pre> <p>Here, you can see the related states in one place, making it easier to see and tell if something <span class="No-Break">is wrong.</span></p>
<p>To illustrate this, let’s say the <strong class="source-inline">nameValue</strong> and <strong class="source-inline">submitDisabled</strong> variables are kept as two separate <a id="_idIndexMarker369"/>variables<a id="_idIndexMarker370"/> in two separate components; in the <strong class="source-inline">Input</strong> component, we have the <span class="No-Break"><strong class="source-inline">nameValue</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
&lt;!-- Input.svelte --&gt;
&lt;script&gt;
  export let nameValue = '';
&lt;/script&gt;
&lt;input bind:value={nameValue} /&gt;</pre> <p>And in the <strong class="source-inline">Button</strong> component, we have the <span class="No-Break"><strong class="source-inline">submitDisabled</strong></span><span class="No-Break"> variable:</span></p>
<pre class="source-code">
&lt;!-- Button.svelte --&gt;
&lt;script&gt;
  export let submitDisabled = false;
&lt;/script&gt;
&lt;button disabled={submitDisabled}&gt;Submit&lt;/button&gt;</pre> <p>From the code, you can see that it is not straightforward to tell whether the <strong class="source-inline">nameValue</strong> and <strong class="source-inline">submitDisabled</strong> variables are related. If one of the states is not updated as expected, you don’t have one convenient place to inspect both states at once; you will have to inspect them in each <span class="No-Break">separate component.</span></p>
<p>For example, if the <strong class="source-inline">submitDisabled</strong> state in the <strong class="source-inline">&lt;Button /&gt;</strong> component did not change to <strong class="source-inline">false</strong> to enable the button after typing in the name input, you would need to find and inspect the <strong class="source-inline">nameValue</strong> variable in a separate component (the <strong class="source-inline">&lt;Input /&gt;</strong> <span class="No-Break">component).</span></p>
<p>If, instead, the states are grouped into a <strong class="source-inline">state</strong> object, then you can inspect the <strong class="source-inline">state</strong> object and check the <strong class="source-inline">nameValue</strong> and the <strong class="source-inline">submitDisabled</strong> properties and see if they are set correctly. Have a look at the <span class="No-Break">following example:</span></p>
<pre class="source-code">
const state = {
  nameValue: '',
  submitDisabled: true,
};</pre> <p>Now that we’ve established that we should group multiple related states into one state object, the next question is this: If we could group states using a simple JavaScript object, why would it be necessary to group states using a <span class="No-Break">Svelte store?</span></p>
<p>Well, the truth is, it is not always necessary. In some cases, using a simple JavaScript object to group states can work just as effectively. However, a Svelte store offers additional benefits and functionality that can enhance your state <span class="No-Break">management experience.</span></p>
<p>As we<a id="_idIndexMarker371"/> explored<a id="_idIndexMarker372"/> in <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, a Svelte store is useful as it can be passed around components and have its updates propagate across components. Then, in <a href="B18887_09.xhtml#_idTextAnchor135"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we saw how useful a Svelte store is, being able to encapsulate logic within the Svelte store, as well as being able to define data logic right next to the <span class="No-Break">data itself.</span></p>
<p>So, for the sake of the chapter, we are going to proceed with grouping multiple related states into a state object using a Svelte store. Here’s a short snippet of code of how it <span class="No-Break">would look:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { writable } from 'svelte/store';
  const state = writable({
    nameValue: '',
    nameError: null,
    passwordValue: '',
    passwordError: null,
    revealPassword: false,
    submitDisabled: true,
  });
&lt;/script&gt;</pre> <p>Here, we use a <strong class="source-inline">writable()</strong> store for creating the state object because we will be modifying the <span class="No-Break">state object.</span></p>
<p>The state object can be defined either inside or outside a Svelte component. Since our state object is a Svelte store, we can import the state object into any component, and any updates to the state object will be propagated across all Svelte components that use the state object—so, it doesn’t matter in which file we define the state <span class="No-Break">object in.</span></p>
<p>If we define our<a id="_idIndexMarker373"/> state <a id="_idIndexMarker374"/>object in a Svelte component, then we can pass our state object to the component’s child component through props. Here’s an example of <span class="No-Break">doing so:</span></p>
<pre class="source-code">
&lt;script&gt;
  const state = writable({ name: 'Svelte' });
&lt;/script&gt;
&lt;Input {state} /&gt;</pre> <p>On the other hand, if we define our state object in a JavaScript module, then we can import our state object into any Svelte components that will be using the state object. The following is a snippet of importing a Svelte store state object into a <span class="No-Break">Svelte component:</span></p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  // import state object defined in './state.js'</strong>
<strong class="bold">  import { state } from './state.js';</strong>
&lt;/script&gt;</pre> <p>In <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, we learned how to read, subscribe to, and update a Svelte store. Whether the data stored inside a Svelte store is a state object or anything else, there is no difference in terms of the operations to read, subscribe, and update the Svelte store state object like any other <span class="No-Break">Svelte store.</span></p>
<p>But as the state is used more frequently in a growing project, you will have more state values inside a <strong class="source-inline">state</strong> store object. As the <strong class="source-inline">state</strong> store gets larger and more complex, your application may get slower, and you may feel the need to optimize/improve it. Therefore, I am dedicating the following subsections to sharing my tips and opinions on state management with a <span class="No-Break">Svelte store.</span></p>
<p>Of course, you shouldn’t apply all these methods blindly. As said by Donald Knuth, the famous<a id="_idIndexMarker375"/> computer <a id="_idIndexMarker376"/>scientist, “<em class="italic">Premature optimization is the root of all evil</em>”—you should measure and evaluate whether any of the following tips apply. As I go through the tips, I will explain what they are and why and when are <span class="No-Break">they useful.</span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor156"/>Tip 1 – simplify complex state updates with unidirectional data flow</h2>
<p>When your application<a id="_idIndexMarker377"/> becomes more complex, with multiple components and multiple places to update your state, managing state updates becomes even <span class="No-Break">more challenging.</span></p>
<p>How would you know when managing state updates becomes unmanageable? You may run into situations such <span class="No-Break">as this:</span></p>
<ul>
<li>Your application state changes, and you find it hard to track down why the <span class="No-Break">state changed</span></li>
<li>You change a certain state value, but unknowingly, this causes other seemingly unrelated state values to update as well, and you have a hard time working <span class="No-Break">out why</span></li>
</ul>
<p>These are signs that the state updates have grown complex and become difficult to manage. In such situations, having unidirectional data flow can help simplify <span class="No-Break">state management.</span></p>
<p>With unidirectional data flow, state updates are managed in a single direction, and the flow of data can be easily traced <span class="No-Break">and debugged.</span></p>
<p>There are state management libraries such as Redux, MobX, and XState that help to enforce a single data flow and enable you to reason with the state changes. You may be curious about how to use these state management libraries with a Svelte store; I will be covering them later in this chapter and will use one of the libraries as <span class="No-Break">an example.</span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor157"/>Tip 2 – prefer smaller self-contained state objects over one big state object</h2>
<p>In Svelte, when a state object changes, all components that use that state object are updated, even if the specific state value that a component uses did not change. This means that if a state object becomes larger and more complex, with many unrelated state values, updating that state object can trigger unnecessary updates to many components in <span class="No-Break">the application.</span></p>
<p>Here, I am going to use a product details page of an e-commerce web application as an example. In a typical e-commerce web app, you have a page that shows the details of a product. You will see other information, such as the shopping cart and product reviews, on the same page <span class="No-Break">as well.</span></p>
<p>If I use one state<a id="_idIndexMarker378"/> object for all the information on the page, it may look <span class="No-Break">like this:</span></p>
<pre class="source-code">
&lt;script&gt;
  let state = {…}
&lt;/script&gt;
&lt;ShoppingCart cart={$state.cart} /&gt;
&lt;ProductDetails product={$state.product} /&gt;
&lt;ProductRatings ratings={$state.ratings} /&gt;</pre> <p>In the preceding code, we use the same state object, <strong class="source-inline">$state</strong>, across three components: <strong class="source-inline">ShoppingCart</strong>, <strong class="source-inline">ProductDetails</strong>, and <strong class="source-inline">ProductRatings</strong>. When any part of the <strong class="source-inline">$state</strong> state object changes, such as changing <strong class="source-inline">$state.cart</strong>, all three components will be triggered <span class="No-Break">to update.</span></p>
<p>This is undesirable—multiple components updating unnecessarily could lead to slower performance and a less responsive <span class="No-Break">user interface.</span></p>
<p>So, it is recommended to split big state objects into smaller state objects. Using the same example, that would mean splitting the <strong class="source-inline">$state</strong> state object into three smaller state objects, <span class="No-Break">like so:</span></p>
<pre class="source-code">
&lt;script&gt;
<strong class="bold">  let cartState = {…};</strong>
<strong class="bold">  let productState = {…};</strong>
<strong class="bold">  let ratingState = {…};</strong>
&lt;/script&gt;
&lt;ShoppingCart cart={<strong class="bold">$cartState</strong>} /&gt;
&lt;ProductDetails product={<strong class="bold">$productState</strong>} /&gt;
&lt;ProductRatings ratings={<strong class="bold">$ratingState</strong>} /&gt;</pre> <p>This way, changing the shopping cart’s state, <strong class="source-inline">$cartState</strong>, would not trigger an update on the <strong class="source-inline">&lt;ProductDetails /&gt;</strong> and <strong class="source-inline">&lt;ProductRatings /&gt;</strong> <span class="No-Break">components.</span></p>
<p>So, if you have big state objects and you find components update unnecessarily and the performance of your application is impacted by it, then consider breaking these big state objects down into smaller <span class="No-Break">state objects.</span></p>
<p>But what if the state object is still big, yet the different values in the state objects are closely related <a id="_idIndexMarker379"/>and you are unable to break it apart into smaller state objects? Well, there is still hope, which leads us to our <span class="No-Break">third tip.</span></p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor158"/>Tip 3 – derive a smaller state object from a bigger state object</h2>
<p>If state values are related to each other and so you can’t break a big state object into smaller state objects, we can create smaller state objects that derive from the big state object. Let me show you some code to explain <span class="No-Break">this clearly.</span></p>
<p>Let’s say that you have a state object, <strong class="source-inline">userInfo</strong>, that has two closely related state values, <strong class="source-inline">$userInfo.personalDetails</strong> and <strong class="source-inline">$userInfo.socials</strong>, as <span class="No-Break">shown here:</span></p>
<pre class="source-code">
import { writable } from 'svelte/store';
const userInfo = writable({
  personalDetails: {...},
  socials: {...},
});</pre> <p>You may realize that one part of the <strong class="source-inline">userInfo</strong> state object doesn’t change as often as the other. But whenever any part of <strong class="source-inline">userInfo</strong> changes, all the components that use either the <strong class="source-inline">$userInfo.personalDetails</strong> or <strong class="source-inline">$userInfo.socials</strong> state values will <span class="No-Break">be updated.</span></p>
<p>To ensure that components using only <strong class="source-inline">$userInfo.socials</strong> are updated exclusively when <strong class="source-inline">$userInfo.socials</strong> changes, one way would be to break the state object into smaller, more focused state objects, <span class="No-Break">like so:</span></p>
<pre class="source-code">
import { writable } from 'svelte/store';
const userPersonalDetails = writable({...});
const userSocials = writable({...});</pre> <p>As you can see, you now have two separate state objects, <strong class="source-inline">userPersonalDetails</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">userSocials</strong></span><span class="No-Break">.</span></p>
<p>But this would mean that places where you previously updated the <strong class="source-inline">userInfo</strong> state object would have <a id="_idIndexMarker380"/>to change since <strong class="source-inline">userInfo</strong> is now split into two separate <span class="No-Break">state objects.</span></p>
<p>Here is how you would change <span class="No-Break">the code:</span></p>
<pre class="source-code">
// previously
$userInfo = newUserInfo;
// now
$userPersonalDetails = newUserInfo.personalDetails;
$userSocials = newUserInfo.socials;</pre> <p>So, the question now is this: Is there an alternative to not having to change this, yet being able to update the components that use <strong class="source-inline">$userInfo.socials</strong> only when <strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">userInfo.socials</strong></span><span class="No-Break"> changes?</span></p>
<p>I believe I’ve leaked the answer already. The alternative is to derive a new state object. In the following code snippet, I am deriving a new <strong class="source-inline">userSocials</strong> state object from the <strong class="source-inline">userInfo</strong> <span class="No-Break">state object:</span></p>
<pre class="source-code">
import { derived } from 'svelte/store';
const userSocials = derived(userInfo, $userInfo =&gt; $userInfo.socials);</pre> <p>The component that uses <strong class="source-inline">$userSocials</strong> will only update whenever the <strong class="source-inline">userSocial</strong> state changes. The <strong class="source-inline">userSocial</strong> state changes only when the <strong class="source-inline">$userInfo.socials</strong> changes. So, when the component uses <strong class="source-inline">$userSocials</strong> instead of <strong class="source-inline">$userInfo.socials</strong>, it will not update when any other part of the <strong class="source-inline">userInfo</strong> state <span class="No-Break">object changes.</span></p>
<p>I believe that seeing is believing, and it will be much clearer to see and interact with an example to get this idea forward. So, I’ve prepared some demo examples at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10/01-user-social">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter10/01-user-social</a>, and you can try them out and see what <span class="No-Break">I mean.</span></p>
<p>Let’s quickly recap the <span class="No-Break">three tips:</span></p>
<ul>
<li>Whenever the state update logic is complex and convoluted, introduce some state management libraries to enforce simpler and unidirectional <span class="No-Break">data flows</span></li>
<li>If the state object gets too big, and state changes update more components than needed, break the state object into smaller <span class="No-Break">state objects</span></li>
<li>If you can’t split a Svelte store state object, consider deriving it into a smaller <span class="No-Break">state object</span></li>
</ul>
<p>So, we’ve gone<a id="_idIndexMarker381"/> through my three general tips for managing complex stores in a Svelte application; let’s now elaborate more on my first tip on how to use state management libraries <span class="No-Break">with Svelte.</span></p>
<h1 id="_idParaDest-157"><a id="_idTextAnchor159"/>Using state management libraries with Svelte</h1>
<p>If you google <em class="italic">State management library for frontend development</em>, at the time of writing, you <a id="_idIndexMarker382"/>will get list after list of libraries, such <a id="_idIndexMarker383"/>as Redux, XState, MobX, Valtio, Zustand, and <span class="No-Break">many more.</span></p>
<p>These libraries have their own take on how states should be managed, each with different design considerations and design constraints. For the longevity of the content of this book, we are not going to compare and analyze each of them since these libraries will change and evolve over time and potentially be replaced by <span class="No-Break">newer alternatives.</span></p>
<p>It is worth noting that some of the state management libraries are written for a specific web framework. For example, at the<a id="_idIndexMarker384"/> time of writing, the Jōtai library (<a href="https://jotai.org/">https://jotai.org/</a>) is written specifically for React, which means you can only use Jōtai if you write your web application <span class="No-Break">in React.</span></p>
<p>On the other hand, there are framework-agnostic state management libraries. An example is <a id="_idIndexMarker385"/>XState (<a href="https://xstate.js.org/">https://xstate.js.org/</a>), which can be used by any web framework as the XState team has created packages such as <strong class="source-inline">@xstate/svelte</strong> to work with Svelte, <strong class="source-inline">@xstate/react</strong> for the React framework, <strong class="source-inline">@xstate/vue</strong> for Vue, and <span class="No-Break">many more.</span></p>
<p>While the <strong class="source-inline">@xstate/svelte</strong> package is tailored for seamless integration of XState in Svelte, not all state management libraries offer this level of compatibility. Nevertheless, there are several other state management libraries that you can use in Svelte, and integrating them is straightforward. In fact, I will provide some examples to showcase how simple it is to integrate these libraries in Svelte and utilize Svelte’s first-class capabilities for working <span class="No-Break">with stores.</span></p>
<p>One such state management library that works seamlessly <a id="_idIndexMarker386"/>with Svelte is Valtio (<a href="https://github.com/pmndrs/valtio">https://github.com/pmndrs/valtio</a>), a minimalist library that turns objects into self-aware proxy states. We are going to explore how we can use Valtio in Svelte, by turning Valtio’s proxy <a id="_idIndexMarker387"/>state into a Svelte store and using the <a id="_idIndexMarker388"/>Svelte store’s <strong class="source-inline">$</strong>-prefixed syntax to subscribe to the proxy state changes and access the proxy <span class="No-Break">state value.</span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor160"/>Example – using Valtio as a Svelte store</h2>
<p>Before we start<a id="_idIndexMarker389"/> talking about how to use Valtio in Svelte, let’s look <a id="_idIndexMarker390"/>at how to use Valtio on <span class="No-Break">its own.</span></p>
<h3>Using Valtio</h3>
<p>Valtio turns the<a id="_idIndexMarker391"/> object you pass to it into a self-aware proxy state. In the following code snippet, we create a Valtio state named <strong class="source-inline">state</strong> through the <span class="No-Break"><strong class="source-inline">proxy()</strong></span><span class="No-Break"> method:</span></p>
<pre class="source-code">
import { proxy } from 'valtio/vanilla';
const state = proxy({ count: 0, text: 'hello' });</pre> <p>To update the proxy state, you can make changes to it the same way you would to a normal JavaScript object. For example, we can increment the value of <strong class="source-inline">state.count</strong> by mutating the value directly, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
setInterval(() =&gt; {
  state.count++;
}, 1000);</pre> <p>To be notified of modifications in the proxy state, we can use Valtio’s <strong class="source-inline">subscribe</strong> method, as <span class="No-Break">illustrated here:</span></p>
<pre class="source-code">
import { subscribe } from 'valtio';
const unsubscribe = subscribe(state, () =&gt; {
  console.log('state object changed');
});</pre> <p>In this case, every time we modify the state, the callback function passed into the <strong class="source-inline">subscribe</strong> method will be called, and we will see a new log in the console, printing <strong class="source-inline">'state </strong><span class="No-Break"><strong class="source-inline">object changed'</strong></span><span class="No-Break">.</span></p>
<p>Valtio also allows <a id="_idIndexMarker392"/>you to subscribe only to a portion of a state. For example, in the following snippet, we subscribe only to the changes made <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">state.count</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const unsubscribe = subscribe(<strong class="bold">state.count</strong>, () =&gt; {
  console.log('state count changed');
});</pre> <p>Since in this case, we are subscribing only to the changes made to <strong class="source-inline">state.count</strong>, then modifying <strong class="source-inline">state.text</strong> would not see a <strong class="source-inline">'state count changed'</strong> log added to the console as the change to <strong class="source-inline">state.text</strong> is <span class="No-Break">not subscribed.</span></p>
<p>The Valtio proxy state is meant for tracking update changes. To read the latest value of the proxy state, we should use the <strong class="source-inline">snapshot()</strong> method to create a snapshot object, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
import { subscribe, <strong class="bold">snapshot</strong> } from 'valtio';
const unsubscribe = subscribe(state, () =&gt; {
  <strong class="bold">const obj = snapshot(state);</strong>
});</pre> <h3>Using Valtio as a Svelte store</h3>
<p>Now that <a id="_idIndexMarker393"/>we’ve learned about basic Valtio operations and concepts, let’s<a id="_idIndexMarker394"/> create a simple counter application to see how we can use Valtio in Svelte. Firstly, we create a proxy state for our <span class="No-Break">counter application:</span></p>
<pre class="source-code">
// filename: data.js
import { proxy } from 'valtio';
export const state = proxy({ count1: 0, count2: 0 });</pre> <p>Here, I am creating two counters, <strong class="source-inline">count1</strong> and <strong class="source-inline">count2</strong>, which will later allow us to experiment with subscribing to a specific portion of the proxy state. This way, we can observe whether our application updates only when one of the <span class="No-Break">counters changes.</span></p>
<p>Also, we are creating the proxy state in a separate file, <strong class="source-inline">data.js</strong>, rather than declaring it inside a Svelte component; this way, we can import the state separately in each Svelte component <span class="No-Break">later on.</span></p>
<p>In addition, let’s create two functions to increment <span class="No-Break">the counters:</span></p>
<pre class="source-code">
export function increment1() {
  state.count1 ++;
}
export function increment2() {
  state.count2 ++;
}</pre> <p>Now, let’s import the proxy state into our Svelte component; I have created two buttons to increment each <span class="No-Break">counter separately:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { state, increment1, increment2 } from './data.js';
&lt;/script&gt;
Count #1: {state.count1}
Count #2: {state.count2}
&lt;button on:click={increment1}&gt;Increment 1&lt;/button&gt;
&lt;button on:click={increment2}&gt;Increment 2&lt;/button&gt;</pre> <p>If you try clicking on the buttons, you’ll realize that they are not working as expected— the counters are <span class="No-Break">not incrementing.</span></p>
<p>However, if you add the following code to <strong class="source-inline">data.js</strong> and click on the button, the console will print out the current value of the counters, indicating that the counters are <span class="No-Break">incrementing successfully:</span></p>
<pre class="source-code">
import { subscribe } from 'valtio';
subscribe(state, () =&gt; {
  console.log(state);
});</pre> <p>As you can see, the counters are updating as expected. The issue, therefore, does not lie in the inability to increment the counters, but rather in the failure to display the changes on the screen. It is possible that Svelte is not recognizing the changes to the counters, and therefore, it is not updating the elements to show the latest value of <span class="No-Break">the counters.</span></p>
<p>So, what can <a id="_idIndexMarker395"/>we<a id="_idIndexMarker396"/> do to make Svelte aware of the changes to Valtio’s <span class="No-Break">proxy state?</span></p>
<p>One approach would be to use a Svelte store, as it provides a mechanism for Svelte components to react to changes in data. We can turn Valtio’s proxy state into a Svelte store. Then, by subscribing to the store, Svelte will be aware of the changes to the state and will update the <span class="No-Break">elements accordingly.</span></p>
<p>This approach of converting states from other state management libraries into a Svelte store in order to take advantage of Svelte’s built-in update mechanism is very common. It allows developers to use their preferred state management solution while still taking advantage of Svelte’s <span class="No-Break">reactive capabilities.</span></p>
<p>So, let’s see how we can turn Valtio’s proxy state into a Svelte store. To start off, I am creating a function <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">valtioStateToSvelteStore</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
function valtioStateToSvelteStore(proxyState) {
  return {};
}</pre> <p>Before creating the Svelte store from the Valtio proxy state, let’s have a quick recap on what the Svelte store contract is. The Svelte store contract dictates that a Svelte store should have a <strong class="source-inline">subscribe</strong> method and an optional <strong class="source-inline">set</strong> method. The <strong class="source-inline">subscribe</strong> method takes a callback function as its only parameter, which will be called whenever the store’s value changes, and returns an <strong class="source-inline">unsubscribe</strong> function to stop <span class="No-Break">further notifications.</span></p>
<p>So, let’s define the <strong class="source-inline">subscribe</strong> method in the returned object of the <strong class="source-inline">valtioStateToSvelteStore</strong> function, <span class="No-Break">like so:</span></p>
<pre class="source-code">
function valtioStateToSvelteStore(proxyState) {
  return {
<strong class="bold">    subscribe(fn) {</strong>
<strong class="bold">    },</strong>
  };
}</pre> <p>The initial value <a id="_idIndexMarker397"/>of<a id="_idIndexMarker398"/> the Svelte store can be defined by calling the callback function synchronously with the value of the <span class="No-Break">proxy state:</span></p>
<pre class="source-code">
function valtioStateToSvelteStore(proxyState) {
  return {
    subscribe(fn) {
      <strong class="bold">fn(snapshot(proxyState));</strong>
    },
  };
}</pre> <p>Our next step is to subscribe to changes in the Valtio <span class="No-Break">proxy state:</span></p>
<pre class="source-code">
function valtioStateToSvelteStore(proxyState) {
  return {
    subscribe(fn) {
      fn(snapshot(proxyState));
<strong class="bold">      return subscribe(proxyState, () =&gt; {</strong>
<strong class="bold">        fn(snapshot(proxyState));</strong>
<strong class="bold">      });</strong>
    },
  };
}</pre> <p>Based on the Svelte store contract, within the <strong class="source-inline">subscribe</strong> method, we need to return a function to unsubscribe the callback function from the Svelte store. In our code, the reason we return the return value of the <strong class="source-inline">subscribe</strong> function from Valtio in our <strong class="source-inline">subscribe</strong> method is that the return value of Valtio’s <strong class="source-inline">subscribe</strong> function is a function to unsubscribe from the <span class="No-Break">proxy state.</span></p>
<p>A function to unsubscribe from changes is just what we need. Isn’t <span class="No-Break">this convenient?</span></p>
<p>It’s no coincidence that most state management libraries provide methods for subscribing to state changes and unsubscribing from them, just like what we need to define a Svelte store. This is because both Svelte stores and state management libraries are designed based on the Observer pattern we discussed in <a href="B18887_08.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. In summary, to turn a state <a id="_idIndexMarker399"/>management <a id="_idIndexMarker400"/>library’s state into a Svelte store, we need to understand how the library works and how its APIs translate into the Svelte <span class="No-Break">store contract.</span></p>
<p>Now that we have a function to transform a Valtio’s proxy state into a Svelte store, let’s try to use it by running the <span class="No-Break">following code:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { state, increment1, increment2, <strong class="bold">valtioStateToSvelteStore</strong> } from './data.js';
  <strong class="bold">const store = valtioStateToSvelteStore(state);</strong>
&lt;/script&gt;
Count #1: {<strong class="bold">$store.count1</strong>}
Count #2: {<strong class="bold">$store.count2</strong>}</pre> <p>Clicking on any button in the component, you will see that the counter works perfectly <span class="No-Break">fine now.</span></p>
<p>So, this is how we turn a Valtio proxy state into a <span class="No-Break">Svelte store.</span></p>
<p>The next thing I would like to explore is creating a Svelte store that subscribes only to partial updates of the Valtio proxy state. By selecting only a specific portion of the state to monitor, we can ensure that the Svelte store updates only when a particular part of the <span class="No-Break">state changes.</span></p>
<p>Before we do that, let’s add a few more lines to show you what <span class="No-Break">I mean:</span></p>
<pre class="source-code">
&lt;script&gt;
  // ...
  $: console.log('count1: ', $store.count1);
  $: console.log('count2: ', $store.count2);
&lt;/script&gt;</pre> <p>As you click on <a id="_idIndexMarker401"/>either <a id="_idIndexMarker402"/>of the increment buttons, you will notice that both reactive statements are called, indicating that <strong class="source-inline">$store</strong> is updated whenever either <strong class="source-inline">count1</strong> or <strong class="source-inline">count2</strong> <span class="No-Break">is updated.</span></p>
<p>As discussed in the third tip earlier in the chapter, if state changes cause unnecessary code to run, we can derive a smaller state from the original state to only subscribe to partial updates. So, let’s <span class="No-Break">do that:</span></p>
<pre class="source-code">
&lt;script&gt;
  import { state, increment1, increment2, valtioStateToSvelteStore } from './data.js';
  <strong class="bold">const count1 = valtioStateToSvelteStore(state.count1);</strong>
  <strong class="bold">const count2 = valtioStateToSvelteStore(state.count2);</strong>
  $: console.log('count1: ', <strong class="bold">$count1</strong>);
  $: console.log('count2: ', <strong class="bold">$count2</strong>);
&lt;/script&gt;</pre> <p>Here, instead of turning <strong class="source-inline">state</strong> into a Svelte store, we are turning <strong class="source-inline">state.count1</strong> into a Svelte store. This allows us to create separate Svelte stores that only subscribe to a portion of the <span class="No-Break">proxy state.</span></p>
<p>This should work, but unfortunately, it doesn’t. The reason for this has nothing to do with our code but with the data structure of our state. <strong class="source-inline">state.count1</strong> is a primitive value, which Valtio is unable to <span class="No-Break">subscribe to.</span></p>
<p>To work around this, I’m going to change the data type of <strong class="source-inline">state.count1</strong> from a primitive value to <span class="No-Break">an object:</span></p>
<pre class="source-code">
export const state = proxy({
  count1: <strong class="bold">{ value: 0 }</strong>,
  count2: <strong class="bold">{ value: 0 }</strong>,
});
export function increment1() {
  <strong class="bold">state.count1.value ++</strong>;
}</pre> <p>In the <a id="_idIndexMarker403"/>preceding <a id="_idIndexMarker404"/>code snippet, we changed <strong class="source-inline">state.count1</strong> to an object with a property called <strong class="source-inline">value</strong>. We still keep the code of deriving the <strong class="source-inline">count1</strong> Svelte store from the <strong class="source-inline">state.count1</strong> proxy state. So, now, the derived Svelte store of <strong class="source-inline">count1</strong> would be an object, and to get the value of the count, we will be referring to <strong class="source-inline">$count1.value</strong> instead <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">$count1</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
$: console.log('count1: ', <strong class="bold">$count1.value</strong>);</pre> <p>Now, when you click on the button labeled <strong class="bold">Increment 1</strong>, you will only see logs printed for <strong class="source-inline">count1</strong>. Conversely, when you click on the other button, labeled <strong class="bold">Increment 2</strong>, you will see new logs printed only for <strong class="source-inline">count2</strong>. The reactive statement will only run when the respective counter is incremented. That’s because our <strong class="source-inline">count1</strong> and <strong class="source-inline">count2</strong> stores only update when a specific part of the Valtio proxy <span class="No-Break">state changes.</span></p>
<p>So, let’s conclude what we’ve done <span class="No-Break">so far.</span></p>
<p>We explored the integration of Valtio in Svelte by converting the Valtio proxy state into a Svelte store. Step by step, we implemented the Svelte store contract by leveraging Valtio’s built-in methods for subscribing and unsubscribing. Toward the end, we explored how to subscribe to partial updates of the proxy state, minimizing <span class="No-Break">unnecessary reactivity.</span></p>
<p>I believe you <a id="_idIndexMarker405"/>are <a id="_idIndexMarker406"/>eager to try it out yourself by now, so let’s use the next state management library as <span class="No-Break">an exercise.</span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor161"/>Exercise – transforming an XState state machine into a Svelte store</h2>
<p>XState (<a href="https://xstate.js.org/">https://xstate.js.org/</a>) is a<a id="_idIndexMarker407"/> JavaScript<a id="_idIndexMarker408"/> library for managing states using state machines. In this exercise, you are going to transform an<a id="_idIndexMarker409"/> XState state machine into a <span class="No-Break">Svelte store.</span></p>
<p>XState provides a package named <strong class="source-inline">@xstate/svelte</strong> that includes utilities specifically designed for integrating XState in Svelte. Although this package can be a source of inspiration for your task, the use of <strong class="source-inline">@xstate/svelte</strong> is, however, not permitted for this exercise. The goal here is to challenge you to implement the function to transform an XState state machine into a Svelte store without the aid of pre-existing <span class="No-Break">integration utilities.</span></p>
<p>To get started with this exercise, follow <span class="No-Break">these steps:</span></p>
<ol>
<li><strong class="bold">Understand XState</strong>: If you’re not already familiar with XState, spend some time reading its documentation and experimenting with its features. Understand how state machines work and how XState <span class="No-Break">implements them.</span></li>
<li><strong class="bold">Create a state machine</strong>: Using XState, create a state machine that you’d like to convert into a Svelte store. This could be a simple machine with a few states and transitions, or something more complex if you’re comfortable <span class="No-Break">with it.</span></li>
<li><strong class="bold">Transform the state machine into a Svelte store</strong>: Now comes the key part of the exercise. You’ll need to write a function that converts your XState state machine into a Svelte store. This involves subscribing to state changes in the machine and forwarding them to the Svelte store, as well as mapping actions from the store back to transitions in the <span class="No-Break">state machine.</span></li>
<li><strong class="bold">Test your implementation</strong>: After you’ve completed your conversion, ensure you thoroughly test it. Change states in your store and observe whether the same changes are reflected in your state machine and <span class="No-Break">vice versa.</span></li>
</ol>
<p>If you’re stuck, take <a id="_idIndexMarker410"/>a<a id="_idIndexMarker411"/> step back and refer to the documentation of XState and this chapter, or the source code <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">@xstate/svelte</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor162"/>Summary</h1>
<p>In this chapter, we learned about how we can manage our application states <span class="No-Break">with Svelte.</span></p>
<p>At the beginning of the chapter, we discussed some of the tips for managing states in Svelte through a Svelte store. These tips will be useful to you as your Svelte application grows larger and <span class="No-Break">more complex.</span></p>
<p>One of the tips that we discussed is using state management libraries to manage data changes and data flows. That’s why we spent the second half of the chapter exploring how we can use state management libraries in Svelte, by transforming the state management libraries’ state into <span class="No-Break">Svelte stores.</span></p>
<p>In the next chapter, we are going to explore how we can use a combination of both a Svelte context and a Svelte store to create renderless components—logical components that do not render <span class="No-Break">any content.</span></p>
</div>
</div></body></html>