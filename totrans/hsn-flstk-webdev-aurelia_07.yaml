- en: Advanced Features on Aurelia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Congratulations! Finally, we are here. Welcome to the last chapter of the second
    section of this book! At this point, we are really sure that you know how to plan
    and develop, and now we will add some cool features to make our application more
    interesting and scalable. Maybe you were thinking about how to share some properties
    or trigger events across all the components, or make your application understandable
    for people from different countries speaking different languages. Well, internationalization
    is a great concept that you are going to meet in this chapter. What if you need
    to perform operations to convert dates, numbers, or currency? Well, these kinds
    of situations (and so much more) are very common in a real application, so you
    need to be prepared to deal with it. You know what? We have good news! Aurelia
    is prepared with a great solution for every case (and so much more too!). In this
    chapter, you will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Event Aggregator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aurelia dialog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Value converters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom binding behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with this awesome chapter; I assure you that you will find it very
    useful and interesting. We promise.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing and publishing events – Event Aggregator at the rescue!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our current application, we have different components and views. Some of
    them need to retrieve data from the server, others just need to process data provided
    for other components, and yet others just help our user interface be more elegant
    and understandable. Okay, all looks good at this point. Note that at this point,
    our application supports different kinds of processing—data load, transformation,
    and how this is displayed. Each one implies a different cost of performance, and
    because of that one could take longer than others. That being said, let's describe
    a common scenario—the user enters our application and navigates to the page listing
    all the matches for this month. There is a lot of data to be retrieved, and you
    need to calculate the time between today and the match date (for each one).
  prefs: []
  type: TYPE_NORMAL
- en: The time remaining for the cost of all of this operation will depend on the
    amount of data returned by the server, so you need to remember something—when
    you design an application, design it while taking into consideration the most
    extreme cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting back to our application case, we can find two scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: The most convenient one is where the user knows that the application is retrieving
    data and waits patiently until the page is completely loaded. Honestly, based
    on our experience, this scenario represents 5% of the common user behaviors with
    digital applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second and most probable scenario is an impatient user, who thinking that
    their internet connection is lost, refreshes the page constantly, or presses some
    button, or, worse yet, leaves our application forever.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We need to take action to tell the user "Hey! I'm working on something, please
    wait!" and at the same time, block every button that can trigger an event causing
    more waiting time. We are sure you know the answer, the famous loading bar icon.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a0f994f-c817-4178-be27-e0981dceecaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We have two options to implement it:'
  prefs: []
  type: TYPE_NORMAL
- en: Put a loading bar icon on every view/component and manage its behavior inside
    each one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put just one loading bar icon in our main application template and call it from
    other components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maybe you are wondering, how can I call one event from another child component?
    Well, without Aurelia, of course, it could be a hard task to perform, but luckily,
    it won't be that case. Aurelia comes with an incredible and easy-to-learn/understand
    feature—Event Aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: Like choosing to use anything, the decision to use the Event Aggregator module
    should be dictated by your application requirements. In most cases, it's for dealing
    with *cross-cutting concerns.*
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an over view of what cross-cutting concerns are.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there is some method that should be triggered at some event of the application/components
    lifetime and not have any relationship with it, we are talking about a cross-cutting
    concern. Some generic examples are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Application loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Session validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Event Aggregator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Event Aggregator class is not hard to understand. Incredibly, it just has
    three exposed methods. Like any other Aurelia module, you just need to import
    and inject it into your view model before using it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's explore the Event Aggregator methods in detail.
  prefs: []
  type: TYPE_NORMAL
- en: publish(event, data)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This method allows you to fire events. Remember that our `EventAggregator` will
    be placed in some parent component, so you know which components will be subscribed
    to it. So, because of that, this method does not have a specific target; they
    are just events triggered to space and doesn't matter if they have zero or more
    subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is the event name. You can choose any name for this, as it
    is your custom event. It will be used as an identifier to call it from external
    components across our application. In this case, you can use `EventAggregator`
    to configure our loading bar, so it would be right to name our event according
    to it. We will call it `dataRetrievingEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: The second argument is the data you want to pass to the event (to supply some
    data, for example) and it's completely optional. Most of the time, it will be
    an array or an object of data. You can even pass through a string value if you
    like. However, not all events need to receive new data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will call this method using our class definition variable for `EventAggregator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: That was very easy. We have our first custom event configured and ready to be
    called from any component in our application.
  prefs: []
  type: TYPE_NORMAL
- en: subscribe(event, callbackFunction)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we published an event at the first method, now it's time to listen to it.
    The first parameter is the event name we want to subscribe, and the second is
    a callback function that can be used to get the value sent by the event publisher.
    This data can be a simple string, or, like in our case, an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the preceding example, we can access this method through our `EventAggregator`
    class instance in our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We have defined a `subscriber` object which is basically a method call. This
    object will make a direct reference to the subscribed event and allows us to execute
    directly a child function called `dispose`. This function is used to delete the
    existing subscription, generally used when our component is destroyed. Keep in
    mind that even the Event Aggregator is a great feature; a little cost in performance
    will be paid, so don't abuse it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a subscription that is removed when the view model is
    detached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is a garbage collection measure and ensures that your app does not use
    resources that it no longer requires.
  prefs: []
  type: TYPE_NORMAL
- en: subscribeOnce(event, callbackFunction)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method is exactly the same as the `subscribe()` method, but with just
    one difference—it automatically unsubscribes the event once the callback is raised.
    Maybe in some cases, you will find some situations that just require a *one-time* subscription,
    such as our loading bar. The example is very similar to the `subscribe()` method
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are sure that you will find this feature really useful. This is just the
    beginning! Let's explore other awesome APIs!
  prefs: []
  type: TYPE_NORMAL
- en: Adding more languages to our application – Internationalization!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more interesting (and useful) features for every web application
    is internationalization. We are developing an application for the FIFA World Cup
    Russia 2018, so, based on that, it would be awesome if our application supported multiple
    languages for all the users worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this purpose, we will use the official `aurelia-i18n` plugin; this will
    be used to get the current app location. This plugin is based on the `i18next`
    library, with some very interesting characteristics such as those listed:'
  prefs: []
  type: TYPE_NORMAL
- en: Translation loaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language detection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Product localization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flexibility and scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last one is the most important feature. With scalability in mind, you can
    implement internationalization with just one configuration file for smaller projects,
    and if you need to implement it on a bigger project, just create multiple translation
    files and load them according to the user's need.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on which build tool you've chosen to create and configure your application,
    you will find many ways to install and get ready with the `aurelia-i18n` plugin.
    At this point, we've used the Aurelia CLI, but let's explore how to configure
    it in case we had chosen a different option, remember them?
  prefs: []
  type: TYPE_NORMAL
- en: Webpack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSPM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aurelia CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Webpack users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to retrieve the plugin from the `npm` repository, so just type the
    following command to get the latest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It will download and save the plugin in your project dependencies. As we said
    earlier, `aurelia-i18n` is based on `i18n` framework, so you should install a
    backend plugin. One of the most famous is `i18next-xhr-backend`, a simple `i18next`
    backend to be used in the browser. How does it work? Easy, using `XHR`, it will
    load resources from some backend server. Yes, your translation files! If you want
    to use the built-in `aurelia-loader` backend, the same plugin Aurelia use to get
    resources, it's okay, you can ignore the next step.
  prefs: []
  type: TYPE_NORMAL
- en: You know what to do now.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost ready. In your Webpack configuration file, you must add `aurelia-i18n` to
    your project''s Aurelia bundles list (on the Aurelia section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: JSPM users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar way as the first two steps, but instead of using the known NPM, we
    will use JSPM. First, we will download the `aurelia-i18n` plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For the backend, type this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Since we will use the built-in `aurelia-i18n-loader`, we don't need to add any additional
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia CLI users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost the same as we explained in the Webpack user section, we need to retrieve
    the `aurelia-i18n` plugin and backend server from the `npm` repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to tell our project that we have new dependencies to be configured.
    Open your Aurelia configuration file (`aurelia.json`) and look for the `dependencies` section.
    You must add the following entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If your application was created using the `Aurelia CLI 0.33.1`, you can omit
    this last step.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are done with the plugins. Now, let's configure it to our application!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and defining our first translation files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application is ready to start using the `i18n` framework. There are some
    steps to get ready with the plugin, so let's explore them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need is to locate our `index.html` file. This should be
    located in our main root application folder. Ensure that your `<body>` section
    is the same as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you are a `Webpack` user, locate the `index.js` file instead of `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, in your root app location, create a folder called `locales`. It will be
    used to store all your location files. Create one folder per language you want
    to support. Then, inside each folder, create a file called `translation.json`.
    This file will contain all your text translation structures, depending on your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your application folder structure must look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/72d55340-b07d-4dd7-9e9e-d1edb6a939f5.png)'
  prefs: []
  type: TYPE_IMG
- en: '`i18next` works based on a predefined transaction-file schema. Look at the
    following example of our en-EN transaction file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, one for es-ES language support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So these are simply for example purposes and very useful to understand how this
    plugin works. Now, it's time to configure the plugin backend. Do you remember
    that we created the `src/main.js` file to define our configuration function? Well,
    it's time to open this file and add some new configuration. If you haven't created
    this file yet, this is a good time to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For those who have chosen the `i18next-xhr-backend` support, first of all,
    open the `main.js` file and find the Aurelia''s configuration section. In the
    first lines of the file, you must import the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new plugin pipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside the new plugin pipe, add the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Let's explain a little of what are we doing in this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to configure our `i18n` aliases, so just declare them on a simple
    string array and pass it as a parameter to the static `configureAliases()` method.
    This will map the defined values in our `<html>` tags to call the correct values.
    It may sound a little confusing at this time, but don''t worry, you are very near
    to seeing the whole picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we register the imported backend plugin (`i18next-xhr-backend`) into
    our `aurelia-i18n` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to add some configuration. This is completely based on the
    `i18n` configuration documents, so you can find more information about this at [http://i18next.com/docs/options](https://www.i18next.com/configuration-options.html).
    That `promise` configuration must be returned; because of that, we are adding
    the `return` statement before the `instance.setup()` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The last options are used to map fallback language, default language and so
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are ready to start using the plugin. Good job!
  prefs: []
  type: TYPE_NORMAL
- en: 'If your are a Webpack user, don''t forget to put the PLATFORM prefix before
    the plugin name. Example:    .plugin(PLATFORM.moduleName(''aurelia-i18n''), (instance)
    => {......});'
  prefs: []
  type: TYPE_NORMAL
- en: Using the plugin – Multilanguage support!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start using our files, you must tell your `ViewModel` components which language
    to use. We will perform this operation at constructor method; check out this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'What if you want to get the active locale? Easy, change the configuration file
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to `setLocale()`, we have the `getLocale()` method. You can retrieve
    the active locale by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, on the HTML file, we just need to call our translation aliases to map
    the properties we have defined in our `translation.json` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Optionally, we are able to use our second alias to map values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now you are ready to start adding multiple language support for your application!
    There are so many other advanced hints to get the best results using this plugin.
    We will show you one of them up next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you need to map `<html>` tags in your translation files. Is that
    possible? Yes. Imagine you need to render some long test (a product description,
    for example) and need to bold just a few words like price or discount. What do
    we need to do? Very easy, just add the HTML tag you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s use this in our `View` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at your window, you''ll see something like `&lt;b&gt;bold&lt;/b&gt;`;
    don''t be scared, it''s normal. It''s because we didn''t set the correct markup
    to make our HTML tag correctly interpreted. You must know that there are four
    main attributes to add custom behavior to our translation file variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[text]`: Default attribute, escapes the tag value as simple text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[html]`: Tells our translation file "Hey, this contains HTML tags, render
    it as them!"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[append]`: Appends the translation to the current content already present
    in the element (allows HTML)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`[prepend]`: Prepends the translation to the current content already present
    in the element (allows HTML)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This attribute has to be before our translation identifier key. You know what
    to do next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Awesome? Yes, it is. It's up to you to research about other more advanced features;
    we are very sure you will enjoy all the options that `i18n` offers. That's all
    for this chapter? Of course, no. Let's keep exploring!
  prefs: []
  type: TYPE_NORMAL
- en: Tracking method calls and user actions – Logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a developer, you know how important it is to know what is happening in your
    application. Some information about the user clicks, event triggers, or error
    messages, having a good logging tool by your side telling you whether your application
    is okay (or really bad) is good practice. Commonly, developers use the common
    `console.log()` statement and when it's time to deploy it to UAT or production,
    they comment all these lines.
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia knows how important this feature is, and guess what—yes, it has its
    own plugin for this purpose. Let's explore!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your log manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Aurelia has the logging API already in their dependencies, so you
    don't need to run any `npm` command at this point. Of course, if for some reason
    that library is missing, you know how to deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to create a file to configure our log levels. In the `resources`
    folder, create a file called `custom-log-appender.js`. This name is completely
    optional; you can name it in the most convenient way.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s configure all our log levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost ready. Now, open the main configuration file (`main.js`) and
    import the logging dependencies from Aurelia:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, import our recently created `CustomLogAppender`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, configure the Aurelia''s `LogManager` with your created `CustomLogAppender`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Look for the `configure()` function. Just need to add one single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this kind of configuration will apply for all the environments (dev,
    test, prod). Commonly, logging is most used to detect error on development phase,
    so let''s add some improvement to the previous configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a file called `environment.js`. This file will contain
    our current activated environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to import that file into our `src/main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You are ready to start using the logger! Let''s open one `ViewModel` file and
    start recording what is happening inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is so easy and so useful. Of course, we have so many more special features
    to show you. Keep reading man!
  prefs: []
  type: TYPE_NORMAL
- en: Modal configuration – Aurelia dialog at rescue!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every application needs to show different kinds of information to the final
    user. Does that information need to be displayed on one page? Not necessarily.
    The final user is very familiarized with the bootstrap dialog (commonly called
    `Modal`), which is a custom JavaScript `alert()` element. More elegant and more
    friendly to add custom behavior, it could now be used only to show alerts information,
    also you can configure entire forms or confirmation dialogs. In our FIFA World
    Cup application, the `Aurelia-materialize` plugin has already configured this
    feature for the modal component, but let's explore how this works and how we can
    improve it. Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Aurelia-dialog plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are using JSPM manager, type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Else, for `Webpack` / `Aurelia CLI` users, use the known `npm install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Remember to save this dependency into your `project dependencies` section. It's
    very important, because it will be used in the final application build.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s tell our application that we have a new plugin. Like other plugins
    seen earlier, open your Aurelia configuration file (`aurelia.json`) and add a
    new plugin section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We have already configured our `index.html` file to use manual bootstrapping;
    if not, just ensure that it has the `<body>` element with the `aurelia-app="main"`
    tag inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In your application config file (`main.js`), add a new `plugin()` entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, if you want to add a more customized behavior to your `modal`, you can
    implement some configuration inside this `plugin()` pipe. Optionally, you can
    configure the `aurelia-dialog` plugin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You are ready! Now, it's time to listen to our plugin!
  prefs: []
  type: TYPE_NORMAL
- en: Adding dialog components to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a `UserRegister` modal for our application. This will look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This is very simple by now. Remember that this component will be the modal itself.
    The modals are displayed over the main content, so now we will configure this
    behavior into our `Home` component. Pay attention to this section; it's a little
    tricky, but we are sure that you will find it easy to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s import `DialogService` from our recently imported `aurelia-dialog`
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, let''s import our recently created `UserForm` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s configure the dialog behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, the `<template>` file needs to contain one `<button>` to trigger
    the `openModal()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the `openModal()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to open the modal. We will set some default values for our recently
    created user object. This method will return a `promise` object. Why? So simple,
    with this `promise`, we will be able to handle any event triggered inside the
    modal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `then()` statement, our `promise` will be defined in such a way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at our `<template>` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can customize how our modal is displayed. For example, bootstrap
    by default adds 50% opacity in the modal background. To get the same result, include
    this CSS class in an existing or new style sheet. Depending on which CSS preprocessor
    you are using, don''t forget to import it if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we are overwriting an existing class from Aurelia dialog, so you
    don't need to specify this class in the `<html>` component.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are ready to add a more user-friendly behavior to your application
    with the use of dynamic dialogs.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic value converters – Less code, more functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said at the beginning of this chapter, our application should be available
    for all the users worldwide. You are completely free to model the application
    according to your own purposes. Maybe you want to implement premium features that
    would need you to pay to access them, so you will need to express the cost in
    the user currency. Another good thing could be to have a custom formatted date,
    or simply add some number conversion, decimal rounds, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You already know how to bind and interpolate values between Aurelia `View` and
    `ViewModel` components. Now we will see how to improve that data binding. Come
    on!
  prefs: []
  type: TYPE_NORMAL
- en: The problem – Data is not exposed as we need
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the common problems we could have is the date formatting. In other code
    languages such as Java, you have a utility class like `SimpleDateFormat`, which
    converts the `Date()` object to a more friendly human reading format. In JavaScript,
    we have some libraries to do that job, but they are not so simple to call. Let's
    see an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'You get the current date in your `ViewModel` component; then, you pass that
    value to the `View` layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `View` file, we map the `currentDate` value to be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the example, you will be displayed in your screen the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we can do better; it''s time to call our value-converters, but exactly,
    what is a value converter? The Aurelia documents explain it really good:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A value converter is a class whose responsibility is to convert view-model
    values into values that are appropriate to display in the view and vice versa."'
  prefs: []
  type: TYPE_NORMAL
- en: That being said, let's create one value-converter file just for example purposes.
    Since we are working with a `Date()` value, we will work with the `moment` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don''t have it in your dependencies tree, just import it from `npm`
    repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, first of all, import this library in our value-converter file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now let''s explain how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: You know that Aurelia is a convention over configuration-based framework. With
    that being said, if you name this class terminating it `ValueConverter`, the framework
    will use this class as a custom value converter without any more configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `toView()` method is inherited from the Aurelia `ValueConverter` interface.
    It defines the data flow direction, if it comes to `ViewModel` to `View`, or vice
    versa, you have the `fromView()` method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those value-converter methods could receive more than one parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we just need to import this value-converter in our `View` file like any
    other dependency, using the `<require>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add the converter to our binding syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, refresh your browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'So much better, right? Well, this same dynamic can be applied to number format
    converters, currency, and so on. Let''s make the example a little more advanced—what
    if we need to show multiple date formats across our entire application? Should
    we define a value-converter file per format we need? It''s a valid option, but
    not the most effective. Do you remember when we said that value-converter interface
    methods can receive more than one parameter? Well, what if we send the date format
    as parameter too? Let''s try to see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify a default format in case no one was provided: `toView(value,
    format = ''M/D/YYYY''){ ... }`'
  prefs: []
  type: TYPE_NORMAL
- en: Nice, our formatter now accepts the `format` pattern as a parameter. It's not
    the magic of Aurelia; it's because we are using `moment.js` a nice JavaScript
    library, which allows us to perform this kind of operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our `View` file, we can add as many time formats as we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, look at your browser window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: That was very nice. Now it's time to take a look at a little more complicated
    example but with a more common usage—arrays order.
  prefs: []
  type: TYPE_NORMAL
- en: 'You know how to retrieve data from one backend service; often this data is
    retrieved as an `array` object and shown as a list in the `View` file. That''s
    all okay, but what if we need to order these values according to some property?
    Look at the code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: What are we doing? Let's explain.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are receiving two parameters, one array, and one config property. The config
    property is an object with two values: `config.direction`, which can be one of
    these two options: ascending or any other string. Depending on that, the sorter
    can order the list incrementing values `1`, or decreasing with `-1` in descending
    order. Then, in the return statement, we are using the sort function of the array
    itself, and we are sending as parameter the anonymous function to compare the
    mapped `config.propertyName` values in the config object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how we are retrieving the data from some backend service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing weird at this point. Now, let''s check the `View` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: It's beautiful. We don't need to add any JavaScript function or weird configuration
    to start using this very useful functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Binding custom behaviors to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's continue with our Aurelia special features exploration. In the last section,
    we saw value-converters, and it's impossible to not make a relationship between
    this feature and the binding engine of Aurelia framework. Maybe you think that
    both features have much in common, well, not so much really. Let's start explaining
    how the binding engine works.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view resources in Aurelia framework can be divided into four categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Value converters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will focus only on the last one. It's not because the others are less important
    but because it will be better for us to understand how this works first and then
    explore the other categories. Don't worry, value-converters are already covered,
    and you will have a clearer idea about the difference between both features.
  prefs: []
  type: TYPE_NORMAL
- en: The value-converter acts just as a bridge interceptor between `View` and `ViewModel`
    (or vice versa). The binding behavior goes beyond—it has full access to the binding
    instance across the complete component life-cycle. This allows us to make changes
    in the binding behavior, such as modifying the binding throttle time, or adding
    customization to how the values are updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that Aurelia is a two-way binding framework, so you don''t need to
    worry about the data synchronization between `View` and `ViewModel`. How is this
    performed? Aurelia has a predefined throttle mechanism that updates values each
    200 ms, by default. Could it be updated? Yes, Aurelia left us free to manage this
    value according to our needs. Similar to the `value-converters` syntax, we need
    to call the binding behavior in the `<template>` file, where we need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you note the `&` symbol? It''s the first difference with the already covered
    value-converters. When we need to define a binding behavior, we tell this to the
    framework using the `&` wildcard. Another thing you must note is that we can send
    parameters to the binding behaviors. Just need to add the `:` symbol after the
    behavior declaration and send the value. Its possible to send multiple params?
    Yes. How? Look at the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you are allowed to declare more than one behavior in one element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In the same way, you can define the updating time period between `View` and
    `ViewModel`; you have another interesting binding behavior called **debounce**.
    We can refer to this behavior in the same category of *throttle*, but the difference
    is that instead of calculating updating time, it prevents the binding from being
    updated until a specified interval has passed without any changes.
  prefs: []
  type: TYPE_NORMAL
- en: Maybe you will find this feature more useful; let's explain it through a real
    use case.
  prefs: []
  type: TYPE_NORMAL
- en: In our FIFA World Cup application, one of the most demanded features could be
    a search input, more specifically, an autocomplete. You already know that autocomplete
    component should retrieve data according to the users' input value. The big question
    when you develop this feature is "when should we trigger the `searchByKey()` method
    of the autocomplete? On every keypress? When the input length is greater than
    `2` or `3`?". Really, this is a hard question; your application performance is
    directly compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good moment to think about *debounce*. Instead of triggering the
    `searchByKey()` method each time the user enters a value, trigger it some time
    after the user enters their search key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Other really useful binding behavior you can use is `oneTime`. By default,
    Aurelia set the preconfigured two-way binding to each `ViewModel` property. The
    big question is "do we really need this two-way binding activated for each property
    in our components?". Most of the time, the answer is no. Here''s where `oneTime`
    comes and becomes our performance optimization partner. Really, it has a direct
    impact on application performance? Yes. To enable double binding, Aurelia needs
    to implement multiple observers looking for any changes in your component properties.
    With `oneTime`, we just tell the app—map this property to my view and forget it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Of course, there are many more predefined binding behaviors to explore, but
    if you remember, we used one binding behavior defined as `customBehavior` in our
    first example. Did you note that? Guess what, Aurelia allows you to define your
    own binding behavior, and now it's time to learn how.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to custom value-converters, you can create custom binding behaviors.
    Check the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Like the last examples, let's explain what the code is doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you must know that similar to the `toView()` and `fromView()` methods
    from value-converters, custom binding behaviors need to implement two methods:
    `bind(binding, src, expressions...)` and `unbind(binding, src)`.'
  prefs: []
  type: TYPE_NORMAL
- en: On the `bind()` method, we are manipulating the user input value passed as a
    parameter. Something you must know is that on the `bind()` method, the first two
    parameters are sent by Aurelia. The other params can be one or more custom parameters;
    in this case, `rawExpresions`.
  prefs: []
  type: TYPE_NORMAL
- en: The `unbind()` method just ensures that our binding behavior returns to normal
    when our data processing ends.
  prefs: []
  type: TYPE_NORMAL
- en: Looks simple? Yes, the example looks easy, but a real implementation will be
    harder to understand. Don't worry, the predefined set of binding behavior commonly provided
    by Aurelia framework is enough for every application's purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Improving our application forms – Validators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We know how the binding engine of Aurelia works. Also, we know how to intercept
    and customize that binding behavior. We know too how to transform data between
    `View`-`ViewModel` layer according to our needs. Just some things are pending,
    and the `aurelia-validation` plugin is one of them. When you need data provided
    by the user, you have to expect anything. The user didn''t know your app. He will
    do anything he wants, and you need to be prepared for that. You need to ensure
    that data provided by the user is, at least, in the right format your back service
    is expecting. You need to filter just the right values and send alerts to the
    user telling which values are wrong and how they can fix it. We often need to
    put ourselves on the user''s side. Software development is more than just programming,
    more than just creating forms and storing/retrieving data. We need to make our
    application fault-tolerant and as we said earlier, think always in the worst case.
    Just imagine something like this—you are developing an application that needs
    to perform some calculations. You have three inputs: `a`, `b`, and `c`; you need
    to calculate the sum. Well, that sounds easy, right? We have two users who type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You press the Submit button and get the correct sum—`88`. Fine, the application
    accomplished their purpose. Let''s see what second user puts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the last user presses by error the `j` character. Will it rely
    on an application error? No. Our operation will be performed, JavaScript is not
    a typed language, so it will operate in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The user will see that value, and we are sure they will never use your application
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing for war – Getting the validation plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like other plugins we could have installed, the installation and configuration
    steps are very similar. If this is the first time you are performing this operation,
    just carry out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using NPM as package manager, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you are a JSPM user, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, open your `main.js` file where we had configured our application plugins.
    In the `configure()` function, add the new plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, open your `aurelia.json` file and add the following plugin declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: We are ready. Let's go!
  prefs: []
  type: TYPE_NORMAL
- en: First steps – Defining our rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Aurelia validation plugin is based on standard rules. We need to define
    our own set of rules using the `ValidationRules` class. This class has some static
    methods that receive our values and verify that the input value meet our requirements.
    Also, one validation rule must have one predefined format. The first method we
    will explain is `ensure()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This method accepts one argument that will be our property name that we want
    to validate. Also, in case you were validating an object, you are allowed to pass
    anonymous functions as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'The second method we will explain is `displayName()`. This is not required
    but is useful if you need to show this property in one predefined format in your
    validation messages; consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to define our set of rules that will apply to that field;
    some of the most used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`required()` prevents the user from submitting null or blank values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matches(regex)` helps us ensure that the input value meets a predefined format,
    and is common on date fields'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email()` is an easy way to ensure that the email is in the right format'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minLength(length)` and `maxLength(length)` validate the length of string properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If our user''s first name should never be null, the validation rule will be
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Did you note something different? Yes, we are using the `withMessage()` method
    to customize our validation error message. The thing becomes more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if you need these validation rules to apply just for one object? Don''t
    worry, Aurelia has the problem solved. You need to tag the object you want to
    apply the rule on; the example is self-explanatory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We are almost ready. Now, we need to configure our form controller with the
    recently created validation rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Maybe you are wondering why we need this `NewInstance.of()` statement? Well,
    for each validation rule we are applying, we need a single controller to validate
    it. So, with this statement, we just ensure that a new `ValidationController`
    instance is created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s explain what is occurring inside our constructor method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 1: We are creating a new instance of the `User` object to use his properties
    in our form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 2: We are assigning the new `ValidatorController` instance into our `formValidator`
    object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Line 3: We are saying to our `formValidator` that the evaluated object is our
    user instance, and will use the imported `UserRules`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other way to configure our `formValidator` is defining the properties and rules
    inside the `validate()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `submit()` method, we just need to add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we need to tell our template where the validators will be placed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The first value will be passed as a parameter to the `ensure()` function. Hey,
    wait a second! We need to specify where our error messages will be placed! Well,
    that''s really simple, we would implement an error list like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you want to display the message beside the wrong `input`
    element, you can use the `<span>` tag and other very interesting custom attribute:
    `validation-errors`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The `validation-errors` attribute contains all validation errors regarding to
    the specified element (in this case `firstNameErrors`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, start putting validation rules across your application forms! See you in
    the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating the DOM – Custom attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are almost done with the most used advanced features of Aurelia. Now, it's
    time to explore other categories belonging to binding engine plugins—what exactly are
    custom attributes? Let's explain that in a very easy way—you know the `HTML` tags,
    such as `<div>`, `<input>`, and `<span>`. Also, you know that each element has
    attributes such as `class`, `type`, and `style`. Well, now we can add more attributes
    to make the element more customizable and add a more advanced behavior. Let's
    look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had also seen the value-converters, but don''t you think it would be awesome
    if we implement a custom attribute to perform this operation on any element? Consider
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Also, `match.date` will be a simple `Date()` JavaScript object without any format.
    Why do we need to accomplish this? Pay attention, we are sure that at this point,
    knowing the basic binding concepts, you will find it very easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a class to configure your `customAttribute`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: What is `Element` doing? That's simple—it helps us point to the right element
    we want to apply the custom attribute to. Next, we just need to call our file
    into the template we need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very interesting way to define your custom attribute is using the already
    known convention over configuration feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in our `View` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: What if we need this custom attribute available for all my application components?
    Well, we have a very good news—you can configure it as a global resource into
    your application configuration file (`main.js`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Identify the `configure` method and add a global resource pointing to our recently
    created custom attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: At this time, you must find all these features very easy to learn, and this
    is because you know more advanced features that helped us understand how the framework
    works. See you in the last section!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how computed properties work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the last section of this chapter! You can consider yourself a full
    stack programmer with strong knowledge on frontend technologies. If you note,
    the concepts that Aurelia uses to implement the different features are based on
    common problems that every web application needs to deal with, no matter which
    framework it is using. Also, as open source tools, the different plugins are based
    on other tools that actually give support to other framework plugins, such as
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the last feature that we will explain is about computed properties. We
    can resume it in a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: Computed properties are those that are preprocessed on the `ViewModel` layer
    in a JavaScript function.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a very simple practical use—you are developing a page that shows the
    `${firstName}` and `${lastName}` as a single value—`${completeName}`.
  prefs: []
  type: TYPE_NORMAL
- en: A common solution should create a JavaScript function to concatenate both values
    and map it into a `ViewModel` property. This is valid, but Aurelia comes with
    a better solution—the `aurelia-computed` plugin. This improves the efficiency
    of data-binding computed properties.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember the `getter`/`setter` function we mentioned in the first chapter?
    Well, it's time to use them.
  prefs: []
  type: TYPE_NORMAL
- en: This plugin uses Aurelia's JavaScript parser to parse the body of the property's
    getter function and check the result for observability purposes. If the getter
    function is observable, a specialized observer is returned to Aurelia's binding
    system. The observer publishes change events when properties accessed by the getter
    function change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing special yet. This function is using `dirty-checking` to bind
    the `completeName` computed property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why dirty? It''s because the observer strategy wont be waiting for any change
    performed in the two values needed to retrieve the `completeName` property. It
    means the getter function will be executed many times across your component life
    cycle. Should we consider it as an issue? Really no, but if your application is
    becoming bigger and you have many computed properties, your performance could
    be directly impacted. So, what''s Aurelia''s solution? Just one annotation—`@computedFrom`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Aurelia's binding system will observe the specified properties and reevaluate
    bindings when any of the properties change. The `aurelia-computed` plugin simply
    automates the dependency identification and is able to support more complex scenarios
    such as observing property paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common use for this feature is to retrieve the current logged user
    data. We can define a Boolean property to tell our component whether the user
    is logged in or not, and based on this, show the real username or just `Visitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Definitely this was a very extensive chapter. We recommend to have a second
    read in the topics you consider more important, also as be said before, remember
    that if you want a complete understanding of each feature explained, you must
    research and do proof of concept to get the best option and experience. Due to
    the nature of our application, the FIFA World Cup is a worldwide event, so you
    need to make it available for all countries, `i18n` help us a lot to deal with
    internationalization with a very easy implementation. If you need to share properties
    or trigger events between your components, `EventAggregator` is the best choice.
    Aurelia offers a very usable variety of binding behaviors, making your code more
    clean, understandable and maintainable. Value converters, validators, computed
    properties are just a few binding behaviors that allows developer to reduce code.
    Remember that many of these features have dependence on third party libraries,
    so don't forget to download them and configure it into your project bundle.
  prefs: []
  type: TYPE_NORMAL
- en: We are really sure that this chapter was the most interesting...until this moment!
    See you in the next chapter!
  prefs: []
  type: TYPE_NORMAL
