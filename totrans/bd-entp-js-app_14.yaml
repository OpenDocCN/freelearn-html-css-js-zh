- en: Creating UI with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have focused on the development of our back-end API;
    but our application won't be complete without an intuitive user interface (UI) our
    end-users can interact with. Thus, this chapter will focus on building a web application
    that consumes our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, by following this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the pros and cons of different UI frameworks and libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about the basics of **React**, including **JSX** and **virtual DOM**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bundle our code using **Webpack**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking a front-end framework/library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we've already discussed in [Chapter 2](47a4c8b3-b1b3-4095-b127-621624a2fa37.xhtml), *The
    State of JavaScript*, **single-page applications** (**SPAs**) are a great improvement
    over the more traditional **multi-page applications** (**MPAs**) that uses a **client-server** architecture.
    With SPAs, a lot of the logic that was traditionally done on the server has been
    delegated to the client. This means there'll be less load on the server, and the
    application can respond more quickly to user interaction. Therefore, for our client
    application, we will be building an SPA. Now, the next step is to pick a technology
    stack for our SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Vanilla JavaScript vs. frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPAs are often discussed in conjunction with popular frameworks and libraries,
    such as **AngularJS**/**Angular**, **React**, **Vue.js**, **Ember**, and **Meteor**;
    but we should remember that SPAs can be written with vanilla HTML, CSS, and JavaScript
    alone. We may also choose to employ utility libraries, such as **jQuery**, to
    abstract away prickly web APIs, such as `XMLHttpRequest`, and to keep our code
    more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, without using a framework or library, we''d have to handle all the
    logic of:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Routing**: Navigating from one page to the next'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DOM manipulation**: Adding/removing components to/from the page'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data binding:** Keeping the template updated with the data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This may be manageable for simply fetch-and-display applications, such as a
    user directory, whose main logic is to fetch data from an API, substitute it into
    a template, and render it. For more complicated applications, we might find ourselves
    re-implementing much of the features provided by a framework/library anyways.
    Similar to how Express abstracts low-level details to make dealing with HTTP requests
    and routing easier, these frameworks/libraries can abstract away a lot of logic
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a framework/library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is a myriad of client-side frameworks/libraries available, including **Aurelia**,
    Ember, **Polymer**, **Backbone**, AngularJS/Angular, Vue.js, React, **Preact**, **Knockout**,
    jQuery, **Mithril**, **Inferno**, **Riot**, **Svelte**, and so on. However, three
    frameworks/libraries dominate: AngularJS/Angular, React, and Vue.js.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us examine each one based on different factors, in order for us to make
    an informed decision as to which library/ framework is best for our use case.
  prefs: []
  type: TYPE_NORMAL
- en: Popularity/community
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Client-side web application frameworks, such as Knockout, Backbone, and Ember,
    existed before AngularJS was released in 2012, but AngularJS was the first to
    gain widespread adoption and has retained the title of "Most popular front-end
    framework" for many years. However, because it was the first, there were many
    rough edges that developers soon found annoying. According to the *State* *of
    JavaScript 2017* survey, out of all those who have used AngularJS (version 1),
    only 32.9% would use it again.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when React was released in 2013, many Angular developers migrated
    to React, boosting React's popularity. Satisfaction among React developers is
    also high, with 93.1% of developers in the aforementioned survey saying they would
    use it again.
  prefs: []
  type: TYPE_NORMAL
- en: In 2014, the AngularJS team attempted to respond by promising to completely
    re-write the AngularJS framework. However, the new version (now called "Angular")
    would be incompatible with the old version (now called "AngularJS"), which means
    migration from AngularJS to Angular would require a complete rewrite of the application.
    This caused much backlash in the Angular community, further pushing more developers
    toward React. To add to the woes of Angular, there were many delays in the development
    of Angular 2, and the final version was released only 2 years later, in 2016\.
    Two years is a very long period of time in the front-end ecosystem, and by then,
    React had already captured the lion's share of developers.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js is the newest kid on the block, and is designed with the lessons learned
    from both Angular and React (Vue.js's creator, Evan You, was an architect at Google).
    Since its release in 2014, it has, in a way, made the same impact on the ecosystem
    as when React first came out. It also has a high satisfaction rate, with 91.1%
    of developers saying they would use Vue.js again.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of hard numbers, according to the same *State of JavaScript* survey,
    out of 23,704 respondents, 14,689 (62.0%) have used React, a slight gain from
    57.1% in 2016\. A total of 11,322 (47.8%) have used AngularJS 1, down from 63.6%
    in 2016, and 6,738 (28.4%) have used Angular 2, up from 20.5% in 2016\. The biggest
    climber has been Vue.js, with 5,101 (21.5%) of respondents saying they've used
    it, almost doubling the figure from 10.8% in 2016.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of contributors to the source code, 1,598 developers have contributed
    to Angular, 1,177 have contributed to React, and only 187 have contributed to
    Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the most popular framework doesn't mean it is the
    best framework, and a developer should never choose a framework solely based on
    its popularity (a.k.a. **hype-driven development**). However, the more popular
    a framework is, the more developers use that framework, and thus there is likely
    to be more community support on forums and Q&A sites, such as Stack Overflow.
    From the business' perspective, it'll also make it easier to hire developers.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, from the popularity/community/ecosystem point of view, Angular is
    in decline, Vue.js is on the rise, but React is still the obvious choice.
  prefs: []
  type: TYPE_NORMAL
- en: Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Angular first came out, it handled the routing, the (two-way) data-binding,
    and DOM manipulation. It was the first of its kind, and it set the standards of
    what a client-side web application framework should look like.
  prefs: []
  type: TYPE_NORMAL
- en: Then, when React came out, it redefined what that standard is. Whilst Angular
    promoted its two-way data binding as a killer feature, React shunted it and called
    it a source of bugs; instead, it promoted one-way data-binding.
  prefs: []
  type: TYPE_NORMAL
- en: But the biggest change in the paradigm with React is the introduction of the
    virtual DOM and JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The virtual DOM is a simplified abstraction of the real DOM. In React, instead
    of manually manipulating the real DOM, developers should instead manipulate the
    Virtual DOM. React would then compare the old Virtual DOM state with the new one,
    and calculate the most efficient way of manipulating the real DOM.
  prefs: []
  type: TYPE_NORMAL
- en: DOM manipulation is a heavy operation and humans often don't see the most efficient
    method of manipulating it. Therefore, having React automatically calculate the
    most efficient way makes updating the DOM much more efficient, and leads to a
    faster, more reactive UI.
  prefs: []
  type: TYPE_NORMAL
- en: JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX is a new language that compiles down to JavaScript. It allows developers
    to define components of the UI in an HTML-like syntax. Instead of using `document.createElement()`, `React.createElement()`,
    or a templating engine, you can write your component in JSX. JSX is like a template,
    in the sense that you can add placeholders within the template that'll be substituted
    with real data. The difference is that JSX gets compiled down to plain JavaScript,
    which means you can use any JavaScript syntax directly inside a JSX file.
  prefs: []
  type: TYPE_NORMAL
- en: If you're familiar with **CSS preprocessors**, you can think of JSX as the preprocessor
    for HTML, similar to what **Sass** does for CSS. The introduction of JSX means
    developers have a much easier way to visualize their UI components in code.
  prefs: []
  type: TYPE_NORMAL
- en: Post-React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To say React revolutionized front-end development would not be an understatement.
    React introduced new concepts that other libraries and frameworks have copied.
    For instance, Vue.js also implements a Virtual DOM and supports the JSX syntax
    in its templates.
  prefs: []
  type: TYPE_NORMAL
- en: However, Angular has very much fallen behind the pack. The Angular team have
    stuck to the "Angular way" and have not moved alongside the community. Dare I
    say, their best is past them; the best they can do is play catch-up at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Angular is a framework, which means you must commit to building the entirety
    of your application using the framework. As demonstrated when the Angular team
    rewrote Angular, changing a framework requires rewriting the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, React and Vue.js are libraries, which means you can add them
    to your project and use them whenever is appropriate for you. You can also add
    additional libraries (for example, routers, state management) that will work with
    React/Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in terms of flexibility, React and Vue.js are the winners here.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stefan Krause has developed and published a series of benchmarks on some basic
    operations using each framework (available at [github.com/krausest/js-framework-benchmark](https://github.com/krausest/js-framework-benchmark)).
    The results show that React is ever so slightly faster than Vue.js, especially
    in terms of making partial updates, but also consumes slightly more memory.
  prefs: []
  type: TYPE_NORMAL
- en: Angular performs about the same as React and Vue, but consumes noticeably more
    memory and has a longer initiation time.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common mistake that companies make when choosing their technology stacks is
    that they are inconsistent. For instance, I have worked in a startup where we
    had four projects, and each one was using a different front-end stack:  AngularJS,
    Angular, Polymer, and React. The result was that developers working on Angular
    were unable to help with the project using React, and vice versa. Some developers
    ended up learning all of the frameworks, but the quality of the code was bad,
    as they became a "Jack of all trades, master of none". Therefore, having a consistent
    stack for all your front-end projects is important. Quite often, this might involve
    not only web applications, but also native mobile and desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid applications with Ionic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Around 1 year after the release of AngularJS, **Ionic** was released. Ionic
    is a framework for building **hybrid** mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, you build a web application using Angular, and then Ionic will
    use another tool called **Cordova** to wrap the complete application inside a **WebView** container.
    A WebView is basically a simplified web browser that native apps can add into
    their application. Therefore, a hybrid application is basically the same as using
    your web application through a browser that is inside the native app. With a hybrid
    application, you can "write once, run anywhere".
  prefs: []
  type: TYPE_NORMAL
- en: However, because there are so many layers, the response time of the UI was initially
    slow, giving the hybrid app a jittery feel.
  prefs: []
  type: TYPE_NORMAL
- en: Native UI with React Native and Weex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Facebook announced **React Native** for iOS and Android in 2015, it was
    big news. It meant developers could now use the same React principles and syntax
    to develop the front-end for both web and mobile applications. It also meant that
    non-platform-specific logic could be shared, which prevents multiple implementations
    of the same logic in different languages (Java for Android and Swift/Objective-C
    for iOS).
  prefs: []
  type: TYPE_NORMAL
- en: This was also dubbed “Learn once, write everywhere”, and allows React developers
    to easily transition between a web developer and mobile developer. Nowadays, React
    Native can even be used for building Windows applications and virtual reality
    (VR) applications.
  prefs: []
  type: TYPE_NORMAL
- en: For Vue.js, they've been involved in an ongoing collaboration with the Alibaba
    Group to develop a similar cross-platform UI library called **Weex**. Soon, Vue.js
    will also support writing in **NativeScript**. However, as admitted by the Vue.js
    team themselves, Weex is still in active development and not as battle-tested
    as React Native, and NativeScript support is a community-driven effort that is
    not yet ready.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in terms of using the same framework/library across multiple platforms,
    React has the most mature tooling and ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Learning curve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While this may be subjective, I, and many others, have found Angular to have
    the steepest learning curve. There are many Angular-specific concepts, such as
    their **digest cycle**, that you must understand before you can be productive
    with Angular. Angular also uses a lot of tools that developers may not be familiar
    with, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TypeScript**: Provides static typing to JavaScript'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RxJS**: Allows you to write functional reactive code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SystemJS**:  A module loader'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**karma**:  A tool for running unit tests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protractor**: An E2E test runner that allows you to run tests that interact
    with a real browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although each of these tools brings a lot of value into the application, it
    no doubts adds to the already-steep learning curve for Angular.
  prefs: []
  type: TYPE_NORMAL
- en: React, on the other hand, is just a view rendering library, and so is much easier
    to understand. The basic idea is that you create components, pass in some inputs,
    and React will generate the final view and render it onto the page. You can arrange
    these components in different ways and nest them inside each other, as it's all
    composable. You may have to learn about the difference between states and props,
    and also the lifecycle methods, but that can be done in a few hours at most.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps what people are referring to when they say "React has a steep learning
    curve" is the ecosystem around it. The React ecosystem is organized in a way where
    you have many tools, each doing one specific thing. This is generally a good thing
    but it also means you'd have to spend the time to pick from the different options,
    and perhaps spend even more time debugging incompatibilities when you try to integrate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you may use React Router to route your pages. You'd need to learn
    Redux or MobX to manage your state. Most of the time, you'd use Webpack to bundle
    your application. However, many React developers also use libraries, such as ImmutableJS,
    Flow, TypeScript, Karma, and ESLint, which are not compulsory tools, but can often
    confuse new developers.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to use a full-featured boilerplate, such as React
    Boilerplate ([reactboilerplate.com](http://www.reactboilerplate.com/)), which
    has a shallower learning curve, but you'd still have to learn the conventions
    used by the boilerplate author. Furthermore, if there's a bug/issue with the boilerplate,
    it'll be much harder for you to debug.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of concepts, React is much simpler than Angular. Even with the React
    ecosystem, the learning curve is still manageable. Personally, having to stitch
    your own stack together forces you to understand what each tool does, and how
    it interacts with other tools, which is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js boasts an even simpler learning curve. It does not use JSX, but a simpler
    template-like syntax with its own domain-specific language (DSL). It does not
    require Webpack and developers can enable Vue.js just by including a typical `<script>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, it's easier for developers not using a framework to migrate to Vue.js,
    as they can more easily convert their HTML into HTML-like templates, and can incrementally
    adapt the entire application to Vue.js.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In terms of community, richness, maturity of the ecosystem, features, flexibility,
    and cross-platform capabilities, React is the stand-out choice.
  prefs: []
  type: TYPE_NORMAL
- en: The one thing that Vue.js may have over React right now is the learning curve.
    In a year or two, however, we may see Vue.js overtake React in all the other factors.
    If not, another framework/library probably will.
  prefs: []
  type: TYPE_NORMAL
- en: Angular is unlikely to disappear altogether, as there are enough early-adaptors
    and hard-core advocates of Angular remaining, meaning that we'll still see Angular
    on the market for at least a few more years. But unless they do something drastically
    different (and better), it's safe to assume Angular will fade slowly into the
    background, just as its predecessors have done before it.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, for all the reasons listed so far, we will develop our client-side
    web application using React.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, although React itself is quite simple, the ecosystem around
    it can be a little overwhelming. Tessa Thorton, a former senior front-end developer
    for Shopify, once wrote a blog post titled *How to learn web frameworks* ([ux.shopify.com/how-to-learn-web-frameworks-9d447cb71e68](https://ux.shopify.com/how-to-learn-web-frameworks-9d447cb71e68))
    In it, she reminded us that "Frameworks don’t exist to impress people or make
    your life harder. They exist to solve problems."
  prefs: []
  type: TYPE_NORMAL
- en: This reminds me of the first ever application I ever built, a clone of Amazon.
    It was built completely in vanilla JavaScript and PHP because I didn't even know
    there were frameworks available! However, there was a piece of animation I couldn't
    get right, and after Googling a lot (and finding the paradise that is Stack Overflow),
    I ended up using jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: For learning how to program, this was not a bad strategy. It allowed me to understand
    what is possible without frameworks, and appreciate the framework more when I
    do use it.
  prefs: []
  type: TYPE_NORMAL
- en: Most tutorials will ask you to set up all the tools first, before explaining
    how to use them. We are going to take a different approach - we will build our
    page from scratch using the minimum set of tools, and introducing new concepts
    and tools *only when needed*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will use this approach to build the Register page
    of our application.
  prefs: []
  type: TYPE_NORMAL
- en: What is React?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'React is a library used for building client-facing user interfaces for applications.
    In principle, it works similar to other front-end frameworks: it takes some data,
    plugs it into some sort of template, and renders the combined view onto the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, everything you build are *components*. Imagine a component as a LEGO
    brick; by combining components together, you get a complete UI. A button can be
    a component, an input field can be another component.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers use the terms "element" and "components" interchangeably. Generally
    speaking, you should use "element" when referring to HTML elements, and "component"
    when describing React components.
  prefs: []
  type: TYPE_NORMAL
- en: Each component contains its own HTML, CSS, and JavaScript, so it is independent
    of other components. This includes methods to run when the component is first
    rendered on-screen, and methods to run when it is removed from view (collectively,
    these are called *lifecycle methods*).
  prefs: []
  type: TYPE_NORMAL
- en: Components can be combined to form new components. For example, we can take
    two `HobnobInput` components, add an `HobnobButton` component, and then wrap them
    inside a `<form>` element, and call that the `HobnobForm` component.
  prefs: []
  type: TYPE_NORMAL
- en: Every React application has a single **root component**, and you mount **child
    components** (which can have their own child components) into the root component.
    In the end, you build up a tree of components, similar to the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React components actually exist inside a space called the *Virtual DOM*, an
    object that serves as a light-weight representation of the actual DOM. Essentially,
    when the page renders, React generates a Virtual DOM object from the data and
    the components, and then it translates this Virtual DOM into DOM elements and
    inserts them into the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: So why not just translate the React components into the DOM nodes directly?
    The answer is performance.
  prefs: []
  type: TYPE_NORMAL
- en: How Virtual DOM improves performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: HTML is a linear, string representation of the structure of a website/app. The
    string, in and of itself, conveys no information about hierarchy or structure.
    For the browser to understand and render the structure represented by the HTML,
    it parses this HTML and abstracts it into a tree-like representation called the **Document
    Object Model**, or **DOM**. Essentially, the tags in your linear HTML become nodes
    inside the DOM tree.
  prefs: []
  type: TYPE_NORMAL
- en: However, this parsing is relatively expensive. There are many layers of nesting,
    and each node has many properties and methods associated with them. So, if your
    application contains many (nested) components, your end users may notice a delay
    in the rendering. This is also true for DOM manipulation (when you move nodes
    around in the DOM), so it's best to keep DOM manipulation to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: React uses the concept of a Virtual DOM to minimize DOM manipulation. In React,
    when we try to render a component, React will pass the relevant data into the `render()` method
    of your component, and generate a lightweight representation of your view, which
    forms part of the Virtual DOM. The Virtual DOM is a JavaScript object and does
    not have all the unnecessary properties and methods that the real DOM elements
    have, and so manipulating them is much faster.
  prefs: []
  type: TYPE_NORMAL
- en: If this is the first time the page is rendered, the Virtual DOM will be translated
    into markup and injected into the document. Whenever the input to the component
    changes, the `render()` method could be called again, which produces another representation
    of your view. React then find the differences between the previous representation
    and the current representation ("diffing" the Virtual DOM), and generates the
    minimum set of changes to apply to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: This means that if the change in input does not require a re-render, then the
    DOM is not manipulated. Furthermore, it is often difficult to see the most efficient
    way to manipulate the DOM, especially for complex UIs. React's algorithms take
    care of that to find the most efficient way possible to achieve the new UI state.
  prefs: []
  type: TYPE_NORMAL
- en: React is declarative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a traditional application, you may have to listen for changes in the data,
    process it, and update the DOM yourself using something like jQuery. This is an
    imperative style, because you are specifying what and how the DOM should change
    based on the data. For example, on the user search page, when the results come
    in, it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In contrast, React uses a declarative style, which means you don't need to handle
    the DOM update itself. You simply declare how you want the data to be processed
    and displayed, and React will figure out a way to reach that state.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The declarative style encourages you to write deterministic UI components, whose
    job is simply to faithfully reflect the state. When done this way, the UI will
    always render in the same way when given the same state object. This makes the
    job of the developer much easier, as all he/she needs to do is to ensure the state
    has the correct values.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, in the example above, all the developer needs to do is to ensure
    the `state.users` array contains the latest list of users, and update it when
    necessary. He/she never have to manually manipulate the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: React summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have just covered everything we need to know to get started with React.
    Here''s a short summary:'
  prefs: []
  type: TYPE_NORMAL
- en: React is a front-end framework that takes in data and outputs a user interface
    (UI)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A React application consists of components being rendered inside one another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These React components correspond to real DOM nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React is performant because it minimizes DOM manipulation by using the Virtual
    DOM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React is declarative; we do not need to handle DOM manipulation ourselves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will start building our Register screen.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our back-end code is encapsulated and exposed only through the API. Therefore,
    our front-end web application must interact with our back-end code through this
    API. Because our back-end and front-end are well-decoupled, it makes sense for
    us to create a new repository for our front-end application.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You may want to use ESLint to help keep your code tidy. You can use the same `eslint
    --init` wizard as before to generate the `.eslintrc` file. However, this time,
    when it asks you `Do you use React?`, pick `Yes` instead of `No`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding some boilerplate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're now ready to get started! Inside our new project directory, create a new `index.html` file.
    Inside it, add in the following boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We will be using two libraries: `react` and `react-dom`. `react` is the base
    package that allows you to define components; the `react-dom` package allows you
    to translate React components in the Virtual DOM to DOM elements, and mount those
    DOM nodes into the DOM itself.
  prefs: []
  type: TYPE_NORMAL
- en: The reason they are separated into two packages is because React is not only
    used for web applications, it can also be used in Native applications with React
    Native, or inside `<canvas>` elements with React Canvas. React simply provides
    a framework to create reusable components, and is oblivious to how those components
    are used and rendered.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's add those two libraries inside our `index.html`'s `<head>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This exposes `React` and `ReactDOM` as global variables, which we can use further
    down the page.
  prefs: []
  type: TYPE_NORMAL
- en: Open your HTML file on the browser, and open up the developer tools. In the
    console, start typing in the word `React`. You'll see that both `React` and `ReactDOM` are
    available.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b5b15d6d-337a-482a-b33e-31005bf713e6.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating our first component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have everything set up, let''s create our first component! For
    our Register form, we need to have a form element, inside of which are two input
    fields, one Register button, and an area to display errors. In React, we can create
    a new React element using the `createElement()` method, which takes three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `type` can be an HTML tag name (for example, `div`, `span`, `form`), a React
    component class, or a React fragment type (more on the latter two later).
  prefs: []
  type: TYPE_NORMAL
- en: '`props` are properties that we can pass into a React element and may alter
    it in some ways. This is similar to how you can specify attributes on an HTML
    element. In fact, if the element being created is a native HTML element, these
    props are used as tag attributes. `props` should be specified as an object.'
  prefs: []
  type: TYPE_NORMAL
- en: '`children` is a list of React elements that nest within this component. In
    our case, we would create a form element, and nest our `input` and `button` elements
    inside the form.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we passed in `{ type: ''email'' }` as the `props` for `emailInput`;
    this will be rendered on the DOM as `<input type="email">`. We also passed in
    the string `''Register''` into the `registerButton` element; this will cause the
    text to be rendered inside the `button` element, like `<button>Register</button>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To display the `registerForm` element onto the page, we need to use the `ReactDOM.render()` method,
    which takes two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The component to render
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DOM element to render it into
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we should create a new HTML element inside our body and use `ReactDOM.render` to
    render our React component into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If you open `index.html` in the browser, you'll see the input boxes and button
    displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/594f88e9-ce2e-4b1d-a12d-9991cad0cde3.png)'
  prefs: []
  type: TYPE_IMG
- en: And upon a closer inspection of the HTML output, you'll see the props turning
    into HTML tag attributes, and that the children passed into `createElement()` are
    nested inside.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: And because we have specified a `type` of `email`, most browsers will automatically
    validate the field for us.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/265f6b6d-ec5d-4549-b72b-b716f9412a73.png)'
  prefs: []
  type: TYPE_IMG
- en: JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have successfully rendered something on to the screen, but that was already
    a lot of code for such as simple form. And it is not going to get any better.
    To make it clear the role of each input element, we should attach a label to each
    one. If we add this label on top of the input, the code will look even more bloated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: A typical web application has thousands of moving parts. Using `createElement` thousands
    of times can make the code unreadable, so let's try an alternative: *JSX*.
  prefs: []
  type: TYPE_NORMAL
- en: 'JSX, or **JavaScript XML**, is a syntax that allows you to create React elements
    and components in XML format. For example, our `registrationForm` element would
    look like this in JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The structure of our element is now immediately more clear. But you might be
    thinking, "But that''s just HTML!", and you are not wrong. JSX is designed to
    look and work just like HTML. So let''s try to replace the `registrationForm` element
    with the new JSX syntax and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When we open `index.html` on the browser, it will now throw an error message
    on the console which reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's because JSX is not valid JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Transpiling JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you've ever used **CoffeeScript**, JSX is similar to that. You can't run
    CoffeeScript in the browser; you must first transpile it to JavaScript. Or if
    you've used a CSS preprocessor, such as Sass, JSX is also similar. Sass features
    such as `@include` or `@extend` are not valid CSS, and you must use a preprocessor
    to transform Sass to CSS. The same is true for JSX;  we must use a transpiler/preprocessor
    to transform it into plain JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: For JSX, the most popular transpiler is the **Babel** transpiler, which we have
    already used when developing our API. In a way, you can think of JSX in the same
    way as newer ECMAScript syntax. Some ECMAScript features are not supported in
    the browser, and therefore we must transpile it down into JavaScript that the
    browser can understand. JSX is not supported in the browser, and therefore, we
    must transpile it down to JavaScript that is supported by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how Babel transforms JSX into JavaScript, we can use the Babel REPL,
    available at [babeljs.io/repl/](https://babeljs.io/repl/). Open it up, and paste
    in everything inside our `<script>` tag. You should see the transpiled JavaScript
    on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/45ef51a1-b4eb-4f9b-9a9b-21d5f467949a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the server, we used Babel to precompile our code from the `src/` directory
    to the `dist/` directory. On the client, we can transpile JSX directly inside
    the browser itself. To do that, we need to include the Babel Standalone Library
    as a script inside the `<head>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We also need to change our `<script>` tag to include the attribute `type="text/babel"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `type="text/babel"` attribute tells our browser to not treat what's inside
    as JavaScript, but as plain text. This means our JSX would no longer throw an
    error. The Babel Standalone Library we included in the `<head>` element would
    then search for any script tags with the type `text/babel` and transpile it to
    JavaScript, and then execute the transpiled JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Open up your browser, and you should see the same thing as we had before, but
    now we are writing in JSX!
  prefs: []
  type: TYPE_NORMAL
- en: Defining React components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we have made our React code much clearer by using JSX, it's still not
    as clean and DRY as it could be. For instance, we are defining the same input
    element twice, even though they have the same structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not ideal because of the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: It can lead to inconsistency. To achieve a consistent user experience, we should
    apply a consistent style and layout for all components, including these input
    boxes. Defining input boxes without a standard template will make it difficult
    to do this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is difficult to update. If the designs change and we need to update all the
    input boxes to fit this new design, it'll be difficult to find all occurrences
    of the input box and update its style. Humans are error-prone and we might miss
    one or two.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We should ensure our React code is DRY; therefore, we should define an independent
    component that we can reuse wherever an input field is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Functional and class components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A React component takes in **props** (input data) and returns a React element(s).
    In React, you can define a component in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional components**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class components**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For instance, we can define an `Input` React component using the functional
    component syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The curly braces (`{}`) are JSX syntax. Whatever is between the braces are evaluated
    as JavaScript, and the value substituted in place.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, we can define the same `Input` component using the class syntax,
    which uses ES6 classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Both are functionally equivalent, and can be used like this to create the `RegistrationForm` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are passing in the `label` and `type` props into the `Input` component,
    which we then used in the component's `render` method.
  prefs: []
  type: TYPE_NORMAL
- en: So which syntax should you use to define React components? Functional components
    are simpler to understand; after all, they are just JavaScript functions. Class
    components have a more complex syntax, but supports more features, such as holding
    a state, and can make use of different life-cycle methods, which we will cover
    soon. Therefore, if your component does not need these additional features, then
    you should prefer the functional syntax over the class syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Pure components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Regardless of the syntax, all React components must be *pure*. A pure component
    is one where:'
  prefs: []
  type: TYPE_NORMAL
- en: The return value (the React element) is **deterministic**, based only on the
    component's input (props).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The component does not produce **side-effects**. For example, a pure component
    should not mutate the props.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pure functions and functional components are good because they are easier to
    understand and test. Therefore, when we have a large or heavily-nested component
    like our `Form` element, it's good practice to break it down into smaller pure
    functional components, and use these components to compose the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try turning our button into its own (simple) component. The end result should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Maintaining the state and listening for events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's work on the `Input` component a little more. When a user types inside
    the input box, it'd be great for user experience to validate the user's input
    and display an indicator next to it. The indicator can be colored green if the
    input is valid, or red if not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, our `Input` component needs to:'
  prefs: []
  type: TYPE_NORMAL
- en: Listen and handle events, so that it can validate the input when the value changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintain the state, so the component can persist the result of the validation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Currently, our `Input` component is defined in the functional components style.
    This is preferred but it is limited in features; it cannot hold the state. Therefore,
    let''s first convert the `Input` component into a class component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can give each instance of the `Input` component a state. A state in
    React is simply a key-value store (that is, an object) that is internal (private)
    to the instance. For us, we will use the state to hold information about whether
    the input is valid.
  prefs: []
  type: TYPE_NORMAL
- en: We can define an initial state of the component inside the component class' `constructor` method,
    which is a special method that is called when the class is instantiated with the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We are setting the state property `valid` to `null`, because before the user
    has entered anything, we don't want to say that it is valid or invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add event listeners to the `input` HTML element. Event listeners
    in JSX are similar to the HTML ones, except that they are `camelCase` instead
    of lowercase. For instance, an `onchange` listener in HTML would be `onChange`.
    The value of the event handler prop should be an event handler function. Update
    the `input` element inside the label tag to include the `onChange` prop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, whenever the value of the input changes, `this.validate` is invoked, passing
    in the event object as its only argument. Since this method doesn't exist yet,
    we must now define it.
  prefs: []
  type: TYPE_NORMAL
- en: Handling events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Inside a class method, `this` refers to the React element (which is an instance
    of this `Input` React component type). Therefore, we can define a method called `validate` that
    will validate the user input and update the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `validate` method gets the value of the input box from `event.target.value`,
    and then uses an external `validator` object to actually validate the value. The `validator` method
    would return `true` if the value is valid, or `false` if it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the `validate` method updates the state using the `setState` method,
    which is available for all class components.
  prefs: []
  type: TYPE_NORMAL
- en: setState and immutability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You should use `setState` to update the state instead of simply modifying the
    existing state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The end result is the same: `this.state` is changed to its new value. However,
    if we directly update the `this.state` object, then React must poll the value
    of `this.state` regularly to be notified of any changes. This is slow and inefficient,
    and not how React is implemented. Instead, by changing the state via the `this.setState` method,
    it will 'reactively' informs React that the state has changed, and React may opt
    to trigger a re-render of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering the state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, in our `render` method, let's add an indicator component. We will read
    from the state of the component to determine the color of our indicator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, open `index.html` on your browser, and try out the input boxes. If you
    enter an invalid email, or your password is too short/long, the indicator will
    show red.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39555ef1-ff61-4e9c-ba7e-579c5fa9c422.png)'
  prefs: []
  type: TYPE_IMG
- en: It is not very pretty, but "function over form" - let's care about the looks
    once we have the functionality in place.
  prefs: []
  type: TYPE_NORMAL
- en: Submitting forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our form ready, let's take the next logical step and figure
    out how to submit the data to our API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to add an `onSubmit` event handler to the
    form. The handler is specific to the registration form, and thus should be associated
    with `RegistrationForm`. The most obvious place to define it is as a class method.
    Update `RegistrationForm` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`this.handleRegistration` is triggered whenever the form is submitted (for
    example, when a user presses the Register button) and the event is passed in as
    its only parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior for the form is to send an HTTP request to the URL specified
    in the `action` attribute of the form. Here, we are not specifying an `action` attribute
    because we want to handle the form differently. Thus, we are calling `event.preventDefault()` to
    stop the form from sending the request. We are also calling `event.stopPropagation()` to
    stop this event from **capturing** or **bubbling**; in other words, it prevents
    other event handlers from handling it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to figure out how to obtain the value of each input box, compose
    the request, and then send it to our API.
  prefs: []
  type: TYPE_NORMAL
- en: Uncontrolled form elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we said that the state of each component is internal (private) to
    the component. However, there are no private class methods in JavaScript. Our
    only equivalent is the closure; therefore, our state isn't truly private. If we
    can obtain a reference to the React element, we can also get its state.
  prefs: []
  type: TYPE_NORMAL
- en: React supports a feature called **ref**. We can create refs using the `React.createRef()` method,
    and then attach that ref to any child DOM element or React element. We can then
    refer to that element using the ref.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, in the constructor of `RegistrationForm`, we created
    two refs, which we've assigned to `this.email` and `this.password`. We then attached
    these two refs to the two `Input` elements using the `ref` prop.
  prefs: []
  type: TYPE_NORMAL
- en: The `ref` prop is a special prop that is not passed down to the child element.
  prefs: []
  type: TYPE_NORMAL
- en: We can now obtain a reference to the email `Input` element using `this.email.current`.
    And we can obtain its `state` property using `this.email.current.state`. Try opening
    up the browser, type in some values in the input box and click Register; you should
    see each input box's current state in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's update the `handleRegistration` method to first check the state
    object, to see whether the values are valid; if they are, extract and assign them
    to a variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to hash the password, compose the request, and send it to our
    API server. Let's define a `register` function, which will provide a layer of
    abstract and allow our `handleRegistration` method to remain easy to read.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: These two functions use the **Fetch API** to send the request to our API server
    (assuming to be running on `http://localhost:8080/`).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to call the `register` functions we defined earlier to actually
    authenticate the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we are using `bcrypt.hashSync` to hash the password; therefore, we need
    to load the `bcryptjs` library, which we can get from the RawGit CDN via the following
    URL: [https://rawgit.com/dcodeIO/bcrypt.js/master/dist/bcrypt.min.js](https://rawgit.com/dcodeIO/bcrypt.js/master/dist/bcrypt.min.js).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Resolving CORS issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, if we reload the page, fill in our details, and press the Register button,
    we'll encounter a CORS-related error. This is because our API server is currently
    only servicing requests from our Swagger documentation page (on `http://localhost:8100`);
    requests from other websites are rejected.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this, we need to provide the Hobnob API with information about the
    location of our client. We can do this by adding a few more environment variables.
    Add the following entries to the `envs/.env` and `envs/.env.example` files in
    our Hobnob API repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to add the client''s origin to the list of origins our API should
    allow. We can do this by updating the CORS middleware to set the `Access-Control-Allow-Origin` header
    dynamically. Make the following change inside `src/index.js` of our Hobnob API
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, coming back to our client application, we need to ensure that the client
    is serving at the port we specified, and also that CORS is enabled. We can do
    this simply by using the `-p` and `--cors` flag provided by the `http-server` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, if we reload both our API server and our client, and try to register, we
    should get back a success response.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the Button component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make the user experience more intuitive, let's disable the Register button
    until both the email and password fields are valid. To do that, we need to provide
    a way for the `RegistrationForm` component to not just read the values of the `Input` components
    when the form is submitted, but after each time the value has changed.
  prefs: []
  type: TYPE_NORMAL
- en: A naive approach would be to poll the `valid` state of each component every
    100 ms or so, but that will not be performant. Instead, we can pass a function
    (via the `onChange` prop) into the `Input` component that will get called whenever
    the value of the `Input` changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And then inside the `validate` method of our `Input` component, we would call `this.props.onChange`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `setState` method accepts a callback as its second parameter, which only
    gets called after the state has been updated. This ensures that when the parent
    component (`RegistrationForm`) checks the `Input` elements' states, it will be
    the updated state.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to define the `handleInputChange` method in `RegistrationForm`.
    It should check whether both inputs are valid, and store the result in the state
    of `RegistrationForm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to modify our `Button` component to accept a `disabled` prop,
    which should disable the button when `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Now, refresh the page and play around with the inputs. The Register button should
    now be disabled until both inputs are valid (that is, both indicators are green).
  prefs: []
  type: TYPE_NORMAL
- en: Controlled form elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You now have some experience working with props, state and refs. However, there
    are several major flaws with our current implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: We are holding states in multiple places. This is hard to manage because we
    have to remember where each state is stored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are duplicating the same states in multiple places. We are holding the `valid` state
    in both the `RegistrationForm` element as well as the `Input` elements. The `RegistrationForm`'s `valid` state
    can be derived from the states of the `Input` elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To prevent both of these flaws, we should **lift the state** store to the closest
    common ancestor of the components that need it; for us, this will be the `RegistrationForm` component.
  prefs: []
  type: TYPE_NORMAL
- en: Here's how it would work. First, we turn the `Input` components back into stateless,
    dumb component, whose output depends solely on the props passed in. We are going
    to be passing down one new prop, `name`, which is a name that is used to identify
    the input. It is similar to the `name` attribute on a normal `input` HTML element.
    We will also change the signature of our `RegistrationForm.handleInputChange()` method
    to accept the `name` of the input as its first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `Input` components are no longer holding any state, nor carrying out any
    validation. Instead, these tasks have been delegated to the component''s closest
    common ancestor, which is the `RegistrationForm`. So, inside RegistrationForm,
    we can:'
  prefs: []
  type: TYPE_NORMAL
- en: Remove any references to these Input components - because they no longer hold
    any state, we have no reasons to hold on to these references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update `this.state` to hold the values and validity information for the `Input` components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, update our JSX components to pass down states like `value` and `valid` to
    the `Input` components. We are also passing down a `name` prop that helps identify
    the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will completely rewrite our `handleInputChange` method of `RegistrationForm` to
    validate the input and store both the value and its validity into the state. It
    will use the `name` and `event` parameters passed by the `onChange` event handler
    of `Input`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we no longer need to use refs to get the values of the `Input` components
    and validate them, since they are already in the state. So, remove those lines
    from our `handleRegistration` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Now, refresh the page and everything should work as it did before.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have lifted the state of our components and consolidated
    it into a single place. This makes our state easier to manage. However, the way
    we are changing the state is by passing down `onChange` props. Whilst this is
    fine for simple components like this, it gets much less performant once the components
    are heavily nested. A single change may invoke tens of functions and this is not
    sustainable. Therefore, as we continue to develop our application, we will use
    a state management tool, such as Redux or MobX.
  prefs: []
  type: TYPE_NORMAL
- en: Modularizing React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But for now, we must solve another pressing issue - our code is not very modular.
    Everything is defined inside a single `<script>` tag. Not only is this hard to
    read, but it is also not maintainable. We can't define every component in one
    file!
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we are including libraries using `<script>` tags. Because some
    libraries depend on others (for example, `react-dom` depends on `react`), we must
    manually ensure our scripts are loaded in the right order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already looked at CommonJS and ES6 modules when we discussed server-side
    modules. However, we must consider other factors when using modules on client-side
    code, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The size of each module. Dependencies are downloaded before the application
    is run. On the server, the application is only initialized once, after which it
    will keep running for a long time (weeks to years). Therefore, the initial time
    required for downloading dependencies is a one-time cost. On the client, however,
    these dependencies need to be downloaded each time a client loads the application.
    Therefore, it is much more important to keep the file size of the application
    and its dependencies to be as low as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many separate requests are made? On the server, all dependencies reside
    on the server, and therefore importing a dependency costs virtually nothing. On
    the client, each request to the server is a new HTTP request, which requires a
    new TCP handshake. All these operations take a relatively long time, and thus
    we must ensure that as few requests are made to the server as possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous. We have already looked at CommonJS modules in [Chapter 4](76e42f28-9731-49ca-9e87-fab7b2b6a7e8.xhtml), *Setting
    Up Development Tools*. CommonJS modules are loaded synchronously, this means modules
    are loaded in the order they are required inside the file/module being run. As
    a module can have hundreds of dependencies, it means it can take a long time to
    resolve and download all dependencies. This is not a problem for server applications,
    because after the initial time requirement, the server application would run for
    a long time without interruption. On the client, if A depends on B, and B depends
    on C, C cannot be downloaded until B is downloaded, because we simply cannot know
    in advance that B depends on C.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of these concerns, we need to use different tools to make our client-side
    application performant on the client. So let's spend some time to review them
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we developed our server-side code, we used packages from the [npmjs.com](https://www.npmjs.com/) registry.
    These packages were initially intended only for server-side code. Soon, front-end
    developers realized the power of all these server-side packages, and wanted to
    utilize them on the client.
  prefs: []
  type: TYPE_NORMAL
- en: This becomes an issue because CommonJS, with its synchronous loading, does not
    work well on the browser. It would take a long time to load because the modules
    that are required are not available on the client, and must be downloaded when
    the page is first accessed. So if a module has an extended dependency tree of
    over 100 modules, it'd have to download 100 modules before the page/application
    can be loaded. Since web pages are rarely kept open for a long period of time,
    the initial load would usually not be worthwhile to the end user, and they will
    abandon the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different solutions to this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: Module bundling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous module loading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module bundling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of the client (the browser) resolving hundreds of dependencies and downloading
    them directly from the client, we would download all dependencies on the server,
    concatenate them in the right order into a single file (or **bundle**), and send
    that to the client. The bundle contains the application and *all* dependencies,
    and can be loaded like any regular script. Because all dependencies are resolved
    ahead of time, the time required to resolve dependencies on the client are eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: But because everything is crammed into one file, the bundle may grow quite large,
    but the load time will be reduced as the client doesn't need to make hundreds
    of separate requests; now it's just one. Furthermore, if one of the external servers
    are down, it would not affect our bundled code, as this is served from our own
    server.
  prefs: []
  type: TYPE_NORMAL
- en: There are four module bundlers that you'll encounter in the wild: **Browserify**, **Webpack**, **Rollup**,
    and **Parcel**.
  prefs: []
  type: TYPE_NORMAL
- en: Browserify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browserify was the first module bundler and it changed the way frontend code
    was written. Browserify will analyze and follow the `require` calls from an entry
    point JavaScript file, build up a list of dependencies, download them, and then
    bundle everything into a single JavaScript file that can be injected using a single `<script>` tag.
    The modules are added recursively, meaning the innermost dependencies are added
    first. This ensures modules are bundled in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: To use it, you simply install the `browserify` package, and specify the entry
    point of your application as well as the location where you want the bundle to
    be placed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Webpack has essentially succeeded Browserify to become the *de facto* leader.
    Whilst Browserify did only module bundling, Webpack also tries to integrate features
    from popular **task runners**, such as **Grunt** or **Gulp**. With Webpack, you
    can preprocess files (for example, minifying JavaScript and transforming Sass
    files) before/after bundling them.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the standout features of Webpack is **code splitting**. This allows
    you to split the bundle into multiple files: those that are essential to the initialization
    and function of the app, and those that can be loaded later. You can then prioritize
    the transfer of the essential code first, giving your users a faster load time,
    and a better user experience. The non-essential code can be loaded later, or only
    on-demand.'
  prefs: []
  type: TYPE_NORMAL
- en: Rollup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Browserify and Webpack focus on CommonJS modules, and require a Babel plugin
    to support ES6 modules. Rollup supports native ES6 modules out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Rollup also supports **tree-shaking**, a feature that eliminates unused code
    from the bundle. Let's say you are importing a large utility library supporting
    100 functions, but are only using four of them; tree-shaking will remove the 96
    that are not required for our app. This can significantly reduce bundle size for
    applications that have a lot of dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, the community consensus is to use Webpack for applications,
    and Rollup for libraries. There are two reasons for this:'
  prefs: []
  type: TYPE_NORMAL
- en: Webpack generally produces more boilerplate and thus produces a noticeably larger
    bundle size that's unnecessary for libraries. This is especially true for earlier
    versions of Webpack, which would wrap every module inside its own function closures.
    Not only does this increase bundle size, but it also slows down performance. However,
    since Webpack 3, these modules are enclosed into one closure using a technique
    called **scope hoisting**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webpack supports code-splitting, which is useful for applications but doesn't
    really help with libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, since their inception, Webpack has added support for tree-shaking,
    and Rollup has added support for code-splitting, and so the similarities between
    the tools are increasing.
  prefs: []
  type: TYPE_NORMAL
- en: Parcel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lastly, a relatively new tool called Parcel has appeared whose selling point
    is a zero-configuration setup. Whilst this may speed up initial development, having
    zero-configuration also means it's likely to support fewer features, and you'll
    have less control over the final bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous module loading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alternative to module bundling is to load modules asynchronously on the client.
    Asynchronous module loading means the modules that do not depend on each other
    can be loaded in parallel. This partially alleviates the slow startup time that
    clients face when using CommonJS.
  prefs: []
  type: TYPE_NORMAL
- en: AMD and Require.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Asynchronous Module Definition** (**AMD**) is the most popular module specification
    that implements asynchronous module loading. AMD is actually an early fork of
    CommonJS, and also uses the `require` and `exports` syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as there are module bundlers for CommonJS modules, there are **module
    loaders** for AMD modules. These tools are called loaders because they load the
    modules from the client directly. The most popular module loader is **Require.js**.
    Require.js provides you with a `define` function, which you can use to define
    your module. You can pass in a list of dependencies as its first argument. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: When the `main` module is initiated, it will first load the `greeter` module,
    and pass the object returned into the function that defines the `main` module.
    This ensures that modules are loaded in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Require.js handles the loading of these modules in the background, parallelizing
    them if possible. This means downstream code execution is not blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Module Definition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**UMD**, or **Universal Module Definition**, is a module definition format
    that aims to be compatible with both CommonJS and AMD. It also allows you to export
    the module as a global variable that you can include in your application through
    a simple `<script>` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: It does this by wrapping the modules in a boilerplate that checks the environment
    to detect how the module is used, and produces the correct exported object.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the preceding `greeter` example would look like this with UMD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: SystemJS and the Loader specification
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Loader specification** ([whatwg.github.io/loader/](https://whatwg.github.io/loader/))
    is a work in progress specification that "describes the behavior of loading JavaScript
    modules from a JavaScript host environment". In other words, it describes a standard
    way to load JavaScript modules in both the browser and the server. It is developed
    by the WHATWG but not yet adopted as a living standard.
  prefs: []
  type: TYPE_NORMAL
- en: '**SystemJS** is an implementation of the Loader specification that works on
    the browser. More specifically, SystemJS is a **universal dynamic module loader**.
    Here, "universal" means it can load not only CommonJS modules, but also ES6 modules,
    AMD, and global scripts. It does this through the `SystemJS.import` method, which
    is akin to a universal `require` that works for all major module definitions.
    The code for importing an `App` component and rendering it may look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: jspm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, if SystemJS can import modules from any sources, how does it know where
    to find the modules? For instance, if we do `SystemJS.import('moment')`, should
    SystemJS fetch the package from the NPM registry? Or is it a custom repository?
    SystemJS can't know for sure. Therefore, to use SystemJS efficiently, we must
    use a package manager that can maintain a mapping between package names and their
    location. Luckily for us, there is **jspm**, which stands for **JavaScript Package
    Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: jspm is similar to npm and yarn, but it can download modules/packages from anywhere,
    not just from npm. Furthermore, it will automatically create a SystemJS configuration
    file with all the package-to-location mapping we talked about previously.
  prefs: []
  type: TYPE_NORMAL
- en: Module bundler versus module loader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After that brief overview of the tooling surrounding client-side modules, we
    are still left with the question - should we use a bundler or a loader? The status
    quo is to use a module bundler. With a loader, you may have to fire hundreds of
    HTTP requests to download all the dependencies. Even if these happen in the background,
    it can still lead to a slow load time. Therefore, using a module bundler is likely
    to allow the application to load quicker.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP/2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, this problem might be a non-issue once HTTP/2 becomes more widely adopted.
    With HTTP/1.1, we need to establish separate HTTP *and* TCP connections for each
    resource we want to retrieve, even when those resources reside on the same server.
    Establishing a TCP connection requires a **three-way handshake**, which is expensive.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41bca6bc-9aff-4433-8b90-0530bbf353a9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With HTTP/2's multiplexing feature, a single TCP connection can be used to make
    multiple HTTP requests. Furthermore, multiple request and response messages can
    be sent in-flight simultaneously. Therefore, if HTTP/2 is widely adopted, making
    multiple requests would not be expensive anymore.
  prefs: []
  type: TYPE_NORMAL
- en: For HTTP/2 to work, it needs to be supported for both the browser and the server.
  prefs: []
  type: TYPE_NORMAL
- en: According to `caniuse.com` ([caniuse.com/#feat=http2](https://caniuse.com/#feat=http2)),
    at the time of writing, only 84.53% of browsers support HTTP/2\. And according
    to W3Techs ([w3techs.com/technologies/details/ce-http2/all/all](https://w3techs.com/technologies/details/ce-http2/all/all)),
    at the time of writing, HTTP/2 is used by only 25.3% of all websites. Therefore,
    a significant segment of browser usage is still on HTTP/1.x browsers. On those
    browsers, we'd still have to make hundreds to thousands of TCP connections on
    each page load; this is unacceptable. Therefore, until HTTP/2 support is almost
    universal, the status quo is still to use a module bundler in order to reduce
    load speed.
  prefs: []
  type: TYPE_NORMAL
- en: As we have mentioned, the most mature and widely-adopted module bundler is Webpack,
    and so for the rest of this chapter, we will convert our application to using
    ES6 modules, and using Webpack to process and bundle our application together.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use yarn to manage our dependencies, just like we did for the
    client-side code. So let''s initiate a new configuration file and add the `webpack` package
    as a development dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Just like Babel, Webpack will take in source files, transforms them and output
    it somewhere. Therefore, let's also create two directories to separate them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Modularizing our components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we are going to completely gut out every JavaScript script inside our `src/index.html`.
    First, remove all the dependency `<script>` tags, such as React, ReactDOM, Babel,
    and bcryptjs. Then, we will use `yarn` to install them instead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Babel is split into multiple smaller packages. This allows developers to use
    just the one they want, and not include unnecessary features.
  prefs: []
  type: TYPE_NORMAL
- en: We can now use these packages by importing them, just as we did with our back-end
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will split our JavaScript code within `index.html` into separate modules.
    We will create:'
  prefs: []
  type: TYPE_NORMAL
- en: A `utils` directory to hold utility functions that can be re-used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `components` directory to hold all our components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index.jsx` as the entry point. This will be where we import the overall `App` component
    and render it onto the DOM with `ReactDOM.render()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Run the following on your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `.jsx` extension here to denote that this file contains JSX
    syntax. Later on, this convention will help Webpack to efficiently determine which
    files it needs to process.
  prefs: []
  type: TYPE_NORMAL
- en: First, let's move the `validator` object from the `src/index.html` file into `src/utils/validator/index.js` and
    export it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Do the same for the `register` function. Then, extract each component into its
    own `index.jsx`. For instance, `src/components/button/index.jsx` would contain
    the code below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And `src/components/input/index.jsx` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '`react` must be imported into every module that uses React and JSX.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `RegistrationForm` component, which has external dependencies, we can `import` it
    at the top of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in our `src/index.jsx`, import the `RegistrationForm` component and
    render it onto the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Entry/output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned already, Webpack is a module bundler. It takes your application
    code, and all its dependencies, and bundles them into one or a small number of
    files. These files can then be transferred to the client and executed. More formally,
    it takes many source **input** files and bundles them into **output** file(s).
    With Webpack, the developer specifies one or several entry points, and Webpack
    will follow `require` or `import` statements in each file to build up a tree of
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack's original selling point is its configurability. So let's begin by creating
    a configuration file at `webpack.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: In Webpack 4, sensible defaults have been set for the most common configurations.
    This means we can use Webpack without a `webpack.config.js` (they've marketed
    this as **Zero configuration JavaScript** (**0CJS**)). However, it is always better
    to be explicit rather than implicit, and so we will still maintain `webpack.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see what happens when we run the Webpack CLI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The Webpack CLI is complaining that it does not understand the `import` syntax.
    This is because, by default, Webpack only fully-supports ES5 syntax, and doesn't
    support ES6 modules. To allow Webpack to understand ES6 syntax, we must use the `babel-loader` package.
  prefs: []
  type: TYPE_NORMAL
- en: Loaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loaders are transformation programs that run on the source files *individually*.
    For example, you'd use loaders to transform CoffeeScript/TypeScript into ES5 before
    bundling them; in our case, we use it to transform ES2015+ syntax and JSX into
    ES5\. First, let's install the loader using yarn.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will update `webpack.config.js` to instruct Webpack to use the loader.
    We can do this by defining loader specifications inside the `module.rules` property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Each loader specification contains two important sub-properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`test` determines which files should be processed by this loader. Here, we
    are using a regular expression, `/\.jsx?$/`, to tell Webpack to use this loader
    to process all files with an extension of `.jsx`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`use` specifies which loaders should be used to transform these files, plus
    any additional options to pass into the loaders. Here, we are instructing Webpack
    to use the `babel-loader` module we just installed, and Babel should use the React
    and `env` presets, as well as the Transform Class Properties plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, when we run `webpack` again, you will see that `dist/bundle.js` being created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: It may also print some warnings regarding optimizing the build. We can ignore
    these for now.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have `bundle.js` at the root of the `dist/` directory, we should
    update our `src/index.html` to use the bundled script. Replace the `<script type="text/babel">...</script>` block
    with `<script src="img/bundle.js"></script>`.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `index.html` is not copied across from the `src/` directory to
    the `dist/` directory. This is because Webpack only processes JavaScript (`.js` / `.mjs`),
    JSON, and WebAssembly files (`.wasm`). To copy the `index.html` file across, we
    need another type of tool called a **plugin**.
  prefs: []
  type: TYPE_NORMAL
- en: CSS and HTML modules are planned to be supported in Webpack 5, so some of the
    plugins we introduce here may not be necessary in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loaders work on transforming *individual* files, "in place", *before or during* the
    creation of the bundle. In contrast, plugins work on the output of the loaders
    and process the bundle as a whole *after* it's created.
  prefs: []
  type: TYPE_NORMAL
- en: Copying files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To copy our `src/index.html` file across, we can use the aptly-named Copy Webpack
    plugin (`copy-webpack-plugin`). As its name suggests, this plugin copies individual
    files or entire directories to the build directory. Let's install it with yarn.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: And add the plugin to our `webpack.config.js`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The `CopyWebpackPlugin` constructor has the following signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Here,`patterns` specifies a set of matching files it should copy. We are simply
    specifying a single file.
  prefs: []
  type: TYPE_NORMAL
- en: Run `webpack` again and you'll see both `bundle.js` and `index.html` being written
    to the `dist/` directory. We can now use the `http-server` package to serve the `dist/` directory
    statically.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: You should be presented with the same Registration form as before. But now our
    code is much more modular.
  prefs: []
  type: TYPE_NORMAL
- en: Final steps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we finish, let's also document the commands we've run into npm scripts.
    This will make building and serving our application easier in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `package.json`, define the build step with the following `scripts` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will write a script to serve our application. We''d like to specify
    the host and port of the application using environment variables (instead of hard-coding
    it), so let''s create an `.env` and an `.env.example` file, and fill them with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a Bash script at `scripts/serve.sh` and give it the execute permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the Bash script, we will simply load the environment variables, build
    the application, and use `htttp-server` to serve the bundled files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need to run our Bash script using an npm script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have built a basic Registration form using React, and bundled
    it using Webpack. In the next chapter, we will look at how to perform E2E testing
    for front-end applications using **Selenium**.
  prefs: []
  type: TYPE_NORMAL
