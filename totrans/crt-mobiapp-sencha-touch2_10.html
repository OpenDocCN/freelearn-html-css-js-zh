<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Game On</h1></div></div></div><p>A quick browse through any of the online app stores quickly shows that the largest segment of the mobile applications market belongs to gaming. While most programmers would not think of JavaScript when it comes to developing games, it is actually well suited for a wide variety of games, including turn-based strategy games.</p><p>These games require only limited animation and can easily be built using the Sencha Touch Framework and the Sencha.io platform for communication. For turn-based strategy games, we only need to do a few basic things such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build a game board</li><li class="listitem" style="list-style-type: disc">Build the individual pieces</li><li class="listitem" style="list-style-type: disc">Handle moves</li><li class="listitem" style="list-style-type: disc">Handle the outcomes when one piece attacks another</li><li class="listitem" style="list-style-type: disc">Handle communication of the moves between players at the end of a turn</li><li class="listitem" style="list-style-type: disc">Define the end of the game</li></ul></div><p>While this might seem a trivial style of game, it covers everything from tic-tac-toe to chess, poker, Go, Risk, and the incredibly complex tabletop strategy games of the pre-Internet era, such as Axis and Allies.</p><div><div><h3 class="title"><a id="note54"/>Note</h3><p>If you really want an idea of how complex some of these games can get, take a look at <a class="ulink" href="http://boardgamegeek.com/">http://boardgamegeek.com/</a> and check out the strategy section.</p></div></div><p>Since we don't have an entire book to dedicate to this single topic, we are going to start with a relatively simple game of checkers. We will also explore some of the possible ways to take this simple game and build on it to create more complex games.</p><div><div><div><div><h1 class="title"><a id="ch10lvl1sec60"/>Building the basic board</h1></div></div></div><p>With any type <a id="id910" class="indexterm"/>of turn-based strategy game, it all starts with the board. The board determines where the pieces are placed and where they are allowed to move.</p><p>A board for checkers or chess consists of an 8 by 8 grid of squares. The squares alternate in color between light and dark (typically red and black for a dedicated checkers board).</p><p>Additionally, only the dark squares can be used by the pieces in checkers.</p><p>You could use a number of different Sencha Touch components to create such a board, but for these purposes a DataView is probably the most appropriate. A DataView<a id="id911" class="indexterm"/> will allow us to tap and select the piece we want to move as well as the place we want to move it to. These selection methods are already built into the DataView. We can also apply styles based on these selections to let the user know which moves are valid.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec103"/>Creating the square model</h2></div></div></div><p>Our <a id="id912" class="indexterm"/>DataView <a id="id913" class="indexterm"/>will be fed by a store with a model we call <code class="literal">Square</code>. It looks like this:</p><div><pre class="programlisting">Ext.define('Checkers.model.Square', {
    extend: 'Ext.data.Model',
    config: {
        fields: [
            {name: 'squareID', type: 'string'},
            {name: 'occupiedBy', type: 'string'},
            {name: 'pieceType', type: 'string'},
            {name: 'decoration', type: 'string'},
            {name: 'background', type: 'string'}
        ],
        idProperty: 'squareID'
    }
});</pre></div><p>This model carries five key<a id="id914" class="indexterm"/> pieces of information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">squareID</code> tells us exactly where the square is located on our board.</li><li class="listitem" style="list-style-type: disc">The value for <code class="literal">occupiedBy</code> tells us if the square is currently occupied by a red piece, a black piece, or if it is unoccupied (<code class="literal">none</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">pieceType</code> will tell us if we are dealing with a regular piece or a king.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">decoration</code> setting will allow us to indicate the current movement path for the pieces and if a particular piece has been jumped.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">background</code> setting controls the background color of the piece. We will use this to set a style in our xTemplate for the DataView.</li></ul></div><p>Our initial load <a id="id915" class="indexterm"/>in of data would look something like this:</p><div><pre class="programlisting">{squareID: 'A1', occupiedBy: 'none', pieceType: 'none', decoration: '', background: 'light'},
{squareID: 'B1', occupiedBy: 'black', pieceType: 'Piece', decoration: '', background: 'dark'},
{squareID: 'C1', occupiedBy: 'none', pieceType: 'none', decoration: '', background: 'light'},
{squareID: 'D1', occupiedBy: 'black', pieceType: 'Piece', decoration: '', background: 'dark'},
{squareID: 'E1', occupiedBy: 'none', pieceType: 'none', decoration: '', background: 'light'},
{squareID: 'F1', occupiedBy: 'black', pieceType: 'Piece', decoration: '', background: 'dark'},
{squareID: 'G1', occupiedBy: 'none', pieceType: 'none', decoration: '', background: 'light'},
{squareID: 'H1', occupiedBy: 'black', pieceType: 'Piece', decoration: '', background: 'dark'},
{squareID: 'A2', occupiedBy: 'black', pieceType: 'Piece', decoration: '', background: 'dark'},
{squareID: 'B2', occupiedBy: 'none', pieceType: 'none', decoration: '', background: 'light'},
{squareID: 'C2', occupiedBy: 'black', pieceType: 'Piece', decoration: '', background: 'dark'},
{squareID: 'D2', occupiedBy: 'none', pieceType: 'none', decoration: '', background: 'light'},
{squareID: 'E2', occupiedBy: 'black', pieceType: 'Piece', decoration: '', background: 'dark'},
{squareID: 'F2', occupiedBy: 'none', pieceType: 'none', decoration: '', background: 'light'},
{squareID: 'G2', occupiedBy: 'black', pieceType: 'Piece', decoration: '', background: 'dark'},
{squareID: 'H2', occupiedBy: 'none', pieceType: 'none', decoration: '', background: 'light'}…</pre></div><p>This would continue on to give us eight rows of eight squares per row. Squares are designated A through H and rows are numbered 1 through 8. This data will also lay out our initial pieces in the standard layout for the start of a checkers game.</p><p>You will also notice that when we alternate the backgrounds, we keep the last item of the row and the first item of the next row as the same color (<code class="literal">H1</code> and <code class="literal">A2</code> are both <code class="literal">dark</code>). This gives us our checkerboard pattern.</p><div><img src="img/8901OS_10_01.jpg" alt="Creating the square model"/></div><p>The actual board image itself is a single background image. We have arranged our DataView to fit over <a id="id916" class="indexterm"/>the board and align with the individual squares. This will let us place elements on any square we choose using CSS. The <code class="literal">dataview</code> code<a id="id917" class="indexterm"/> is included as one of the items in our <code class="literal">view/Main.js</code> file:</p><div><pre class="programlisting">{
    xtype: 'dataview',
    itemTpl: ['&lt;div class="gameSquare {background} {decoration}"&gt;{squareID}',
              "&lt;tpl if='occupiedBy != \"none\" &amp;&amp; pieceType != \"none\"'&gt;&lt;img src=\"resources/images/{occupiedBy}{pieceType}.png\" height=\"72\" width=\"72\" /&gt;&lt;/tpl&gt;",
              '&lt;/div&gt;'],
    store: 'BoardStore',
    height: 619,
    width: 619,
    scrollable: false,
    cls: 'board',
    margin: 5,
    padding: 5,
    mode: 'MULTI'
}</pre></div><p>This DataView <a id="id918" class="indexterm"/>has a <code class="literal">cls</code> value of <code class="literal">board</code> so we can set the background image to the big checkerboard image in our <code class="literal">resources/css/app.css</code> file.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec104"/>Exploring itemTpl</h2></div></div></div><p>We also<a id="id919" class="indexterm"/> make extensive use of classes in the <code class="literal">itemTpl</code> config. Let's <a id="id920" class="indexterm"/>take a look at the template line by line:</p><div><pre class="programlisting">'&lt;div class="gameSquare {background} {decoration}"&gt;{squareID}'</pre></div><p>The first line sets up a <code class="literal">div</code> element with a <code class="literal">class</code> value of <code class="literal">gameSquare</code>. Each <code class="literal">gameSquare</code> is set in the <code class="literal">app.css</code> file to:</p><div><pre class="programlisting">.gameSquare {
  height: 72px;
  width: 72px;
  margin: 2px;
  float: left;
  position: relative;
}</pre></div><p>This sets the individual items in our DataView to line up with our game board. By setting <code class="literal">position: relative</code>, we can also position items absolutely within <code class="literal">gameSquare</code>.</p><p>We also add a class for <code class="literal">{background}</code>. This value will be pulled from our data store and it will be either light or dark. We add this class so we can change the font color for our dark tiles to white. In the CSS, this looks like:</p><div><pre class="programlisting">.gameSquare.dark {
    color: white;
}</pre></div><p>The next class we set is <code class="literal">decoration</code>. The <code class="literal">decoration</code> class<a id="id921" class="indexterm"/> will be used <a id="id922" class="indexterm"/>to show arrows for<a id="id923" class="indexterm"/> movement and a negation symbol when a piece will be jumped as part of a move as shown in the following screenshot:</p><div><img src="img/8901OS_10_02.jpg" alt="Exploring itemTpl"/></div><p>These images can be inserted into a style using the <code class="literal">before</code> CSS selector. This selector will insert content before our <code class="literal">div</code> element. In this case, we will insert a green arrow to indicate the direction the piece is moving.</p><p>For example, a piece moving up and to the left will have its <code class="literal">decoration</code> value set to <code class="literal">up_left</code> and the following style is applied in our <code class="literal">app.css</code> file:</p><div><pre class="programlisting">.up_left:before {
    content: '';
    background: url("../images/up_left.png");
    height: 32px;
    width: 32px;
    margin: 0;
    padding: 0;
    position: absolute;
    top: -16px;
    left: -16px;
    z-index: 1000;
}</pre></div><p>By using <code class="literal">position: absolute</code>, we can set the <code class="literal">top</code> and <code class="literal">left</code> position of our image to any value we like including a negative number. The negative number places it up and to the left <a id="id924" class="indexterm"/>of the <a id="id925" class="indexterm"/>actual square (overlapping the square to the upper-left corner). The high <code class="literal">z-index</code> value insures that the image appears on top of the other images and text.</p><p>We have similar CSS styles created for <code class="literal">.up_right</code>, <code class="literal">.down_left</code>, and <code class="literal">.down_right</code>. This gives us indicators for four diagonal directions of movement.</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>All of our images have been saved in the <code class="literal">resources/images</code> directory. If you change the location of the images, you will need to adjust the CSS file to match your setup.</p></div></div><p>We also have a decoration class called <code class="literal">removed</code>. This class uses the CSS selector <code class="literal">after</code> to insert content after the <code class="literal">div</code> element and display our negation symbol over a piece that will be jumped during the current move. The CSS looks like this:</p><div><pre class="programlisting">.removed:after {
    content: '';
    background: url("../images/removed.png");
    height: 72px;
    width: 72px;
    position:absolute;
    top: 0;
    left: 0;
    z-index: 1001;
}</pre></div><p>It is similar to our styles for our arrows, except we need this symbol to show up over the top of our piece. We set its <code class="literal">top</code> and <code class="literal">left</code> attribute to <code class="literal">0</code> and because the image is the same size as our square, it floats over the top of the image of our piece. The higher z-index assures that it is the top element.</p><p>The next line of <code class="literal">itemTpl</code> is what controls the piece that occupies the square:</p><div><pre class="programlisting">&lt;tpl if='occupiedBy != \"none\" &amp;&amp; pieceType != \"none\"'&gt;&lt;img src=\"resources/images/{occupiedBy}{pieceType}.png\" height=\"72\" width=\"72\" /&gt;&lt;/tpl&gt;</pre></div><p>We use a <code class="literal">tpl if</code> statement here to check and see if the square is occupied and if so, by what kind of piece. We use two of our data values to determine this value.</p><p>The first is <code class="literal">occupiedBy</code>, which can be <code class="literal">red</code>, <code class="literal">black</code>, or <code class="literal">none</code>.</p><p>The second is <code class="literal">pieceType</code>, which can be <code class="literal">regular</code>, <code class="literal">king</code>, or <code class="literal">none</code>.</p><p>If both data values are set to <code class="literal">none</code>, we do not place a piece in the square. If we have a piece in the square, we use the combination of <code class="literal">occupiedBy</code> and <code class="literal">pieceType</code> to determine our image.</p><div><img src="img/8901OS_10_03.jpg" alt="Exploring itemTpl"/></div><p>These CSS <a id="id926" class="indexterm"/>values along with the individual <a id="id927" class="indexterm"/>squares from our DataView allow us to set the appearance of every square on the board by using the values stores in our data store.</p><p>Our individual moves can be created using the <code class="literal">select</code> event in our DataView. By setting the <code class="literal">mode</code> attribute to <code class="literal">MULTI</code>, the user can tap the piece they want to move and then the square they wish to move to. They can continue to tap squares if they are in a position to jump multiple pieces. We can also use the DataView's built-in <code class="literal">x-item-selected</code> class to highlight the squares the user has tapped.</p><p>We just add the highlighted styles to our stylesheet:</p><div><pre class="programlisting">.x-item-selected .gameSquare {
    outline: 3px solid rgba(0,175,0,0.75);
    color: rgb(0,175,0);
}
.x-item-selected .gameSquare.dark {
    color: rgb(0,255,0);
}</pre></div><p>This gives us a green border to match our arrows and changes the text color as well. We also set a slightly different text color in our dark squares for readability.</p><p>Now that we have all of our different display possibilities mapped out, we need to set up the logic for the game.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec61"/>Creating the game controller</h1></div></div></div><p>The<a id="id928" class="indexterm"/> game controller <a id="id929" class="indexterm"/>is where the logic for our game will go. Here we will follow the basic rules for checkers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Pieces are initially arranged on the opposite sides of the board in three rows, only on the black squares</li><li class="listitem" style="list-style-type: disc">Pieces can move diagonally</li><li class="listitem" style="list-style-type: disc">Pieces can only move to an empty square</li><li class="listitem" style="list-style-type: disc">Regular pieces can only move forward</li><li class="listitem" style="list-style-type: disc">Pieces can only move one square, unless jumping over an adjacent piece</li><li class="listitem" style="list-style-type: disc">Pieces can only jump one piece at a time</li><li class="listitem" style="list-style-type: disc">Jumped pieces are removed from the board</li><li class="listitem" style="list-style-type: disc">King pieces can move forward and backwards</li><li class="listitem" style="list-style-type: disc">A regular piece that reaches the opposite side of the board is changed to a king piece, ending their current turn</li><li class="listitem" style="list-style-type: disc">The game is finished when all the pieces from one side have been jumped and removed</li></ul></div><p>Our controller <a id="id930" class="indexterm"/>will check each move to see if it follows these rules and remove the pieces that have been jumped. For the purposes of this chapter, we will only be creating a local game. This is one in which two players would play by passing back and forth a single device. However, this game could easily be modified to allow for networked play using Sencha.io or an external API.</p><p>Before we dive into the code for the controller, we need to add some things to our main view. We need a way for each user to start and finish a turn. We will also need a way to show a previous turn so that a user can see what occurred during the last move.</p><p>To do this, we will add a toolbar with two buttons to the bottom of our main view:</p><div><pre class="programlisting">{
    xtype : 'toolbar',
    docked: 'bottom',
    items: [
        {
            xtype: 'spacer'
        },
        { text: 'Start Turn', action: 'mainButton' },
        { text: 'Show Previous', action: 'altButton' },
        {
        xtype: 'spacer'
        }
    ]
}</pre></div><p>We will expand the functionality of these two buttons in our controller, so that they will also allow us to finish a turn or clear a currently selected move if we change our mind before finishing.</p><p>Now let's see<a id="id931" class="indexterm"/> how this all fits together in the controller.</p><p>As always, we start out by setting up our controller with the <code class="literal">control</code> and <code class="literal">refs</code> sections:</p><div><pre class="programlisting">Ext.define('Checkers.controller.Game', {
 extend: 'Ext.app.Controller',
 config: {
  control: {
   board: {
    select: 'doSelect',
    deselect: 'doDeselect'
   },
   mainBtn: {
    tap: 'doMainBtn'
   },
   altBtn: {
    tap: 'doAltBtn'
   }
  },
  refs: {
   board: 'main dataview',
   mainBtn: 'button[action="mainButton"]',
   altBtn: 'button[action="altButton"]'
  }
 }
});</pre></div><p>We create references for our board and our two buttons. In the <code class="literal">control</code> section, we add <code class="literal">select</code> and <code class="literal">deselect</code> functions for our board, and <code class="literal">tap</code> functions for our two buttons. The <code class="literal">mainBtn</code> function<a id="id932" class="indexterm"/> will start a turn and execute the finished move. The <code class="literal">altBtn</code> function<a id="id933" class="indexterm"/> will show the previous turn or clear the current set of moves. We will swap the text and functionality appropriately as part of the <code class="literal">tap</code> functions.</p><p>In order to track the turns, we are going to add two custom variables to our controller. These go down below our <code class="literal">refs</code> section (inside the <code class="literal">config</code> section):</p><div><pre class="programlisting">previousTurn: {
 player: null,
 piece: null,
 moves: [],
 removedPieces: []
},
currentTurn: {
 player: 'black',
 piece: null,
 moves: [],
 removedPieces: [],
 endOfTurn: false,
 hasJumped: false,
 started: false,
 kingable: false
}</pre></div><p>The <code class="literal">previousTurn</code> variable<a id="id934" class="indexterm"/> will store red or black for <code class="literal">player</code>, <code class="literal">piece</code> (piece that was moved), <code class="literal">moves</code> (moves<a id="id935" class="indexterm"/> that were made—as an array), and <code class="literal">removedPieces</code> (pieces removed—as an array). This will let us highlight the squares from the previous turn when the user clicks on the <strong>Show Previous Turn</strong> button.</p><p>The <code class="literal">currentTurn</code> variable<a id="id936" class="indexterm"/> stores the same information as <code class="literal">previousTurn</code>, but it also adds <code class="literal">Boolean</code> data for:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">endOfTurn</code>: Has the user confirmed and completed the current move?</li><li class="listitem" style="list-style-type: disc"><code class="literal">hasJumped</code>: Has the user jumped a piece as part of their turn?</li><li class="listitem" style="list-style-type: disc"><code class="literal">started</code>: Has the user pressed the <strong>Start Turn</strong> button?</li><li class="listitem" style="list-style-type: disc"><code class="literal">kingable</code>: Has the user reached the opposite end of the board as part of the current move?</li></ul></div><p>We also set the value for player to <code class="literal">black</code> by default, as black traditionally moves first in checkers.</p><p>By declaring these <code class="literal">previousTurn</code> and <code class="literal">currentTurn</code> variables as part of <code class="literal">config</code>, we automatically create getters and setters for both. This means we can do things like <code class="literal">this.getPreviousTurn()</code> and <code class="literal">this.setCurrentTurn()</code> inside any of our controller functions. We will be using these functions extensively throughout the controller.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec105"/>Understanding basic controller functions</h2></div></div></div><p>Another thing that <a id="id937" class="indexterm"/>we will be using extensively in this<a id="id938" class="indexterm"/> controller is the concept of <strong>subordinate functions</strong>
<a id="id939" class="indexterm"/>. These are functions that are called by other functions. While it might seem counter intuitive at first, splitting larger functions apart into smaller sub functions makes the logic easier to follow.</p><p>This is especially true in the case of game logic, where the rules for the game can quickly spiral into a series of incomprehensible "if…then" statements. By splitting the logic into smaller functions, the logic is much easier to check. You can simply use <code class="literal">console.log()</code>
<a id="id940" class="indexterm"/> to output the value you start with and the value you finish with in each of the smaller functions. This makes it much easier to tell which pieces are functioning as expected.</p><p>For this application, we have some smaller functions that help us with our game logic. We won't go into great detail <a id="id941" class="indexterm"/>about these smaller functions but they can be found in the <code class="literal">controller/Game.js</code> file. These functions include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">nextLetter</code> and <code class="literal">previousLetter</code>: Given <a id="id942" class="indexterm"/>a letter <a id="id943" class="indexterm"/>and a distance, these two functions return the next or previous letter in the sequence. For example, <code class="literal">nextLetter('c', 2)</code> would return <code class="literal">e</code> when called. These will help us determine positioning on the board.</li><li class="listitem" style="list-style-type: disc"><code class="literal">getIntermediateSquare</code>: <a id="id944" class="indexterm"/>Given a <em>from location</em> and a <em>to location</em>, this function will return the square located between the two squares. This is used when a piece is jumped, so we can determine if a move is valid and apply the correct decorations to the square (arrows and negation symbol for jumped pieces).</li><li class="listitem" style="list-style-type: disc"><code class="literal">isKingable</code>: Given<a id="id945" class="indexterm"/> the location the piece is moving to, is it eligible to be kinged?</li><li class="listitem" style="list-style-type: disc"><code class="literal">clearTurn</code>: Clears<a id="id946" class="indexterm"/> out any old data from the current term and deselects any selected squares in the DataView.</li><li class="listitem" style="list-style-type: disc"><code class="literal">clearDecorations</code>: <a id="id947" class="indexterm"/>Clears any decorations from the data store (clearing this data also removes it from the display).</li></ul></div><p>Aside from these smaller functions, the main logic for the board is handled in the <code class="literal">select</code> event. This event needs to check and see if we have a valid move, and then add the appropriate decorations to the board. These decorations will show the selected piece, the direction of the move, and any affected squares or pieces.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec62"/>The game board logic</h1></div></div></div><p>The game logic will <a id="id948" class="indexterm"/>function as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">A player clicks on the <strong>Start Turn</strong> button.</li><li class="listitem">The game responds with an alert telling the player it is black's or red's turn.</li><li class="listitem">The player taps a piece.</li><li class="listitem">The game checks that a valid piece was tapped and stores the information in the <code class="literal">currentMove</code> variable<a id="id949" class="indexterm"/>.</li><li class="listitem">The player taps a destination square.</li><li class="listitem">The game checks if the destination is valid and stores the information in the <code class="literal">currentMove</code> variable.</li><li class="listitem">The player can then tap <strong>Finish</strong> <strong>Turn!</strong> to complete the turn or tap additional squares if jumping multiple pieces (finally tapping <strong>Finish</strong> <strong>Turn!</strong> when all moves for the turn are complete).</li><li class="listitem">Once the player taps <strong>Finish Turn!</strong>, the system removes any jumped pieces, removes all decorations for the move, and stores the move in the <code class="literal">previousMove</code> variable<a id="id950" class="indexterm"/>.</li></ol></div><p>We will begin <a id="id951" class="indexterm"/>our trip through the game logic at the most logical place, the function that fires when the user clicks on the <strong>Start Turn</strong> button.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec106"/>Starting a turn</h2></div></div></div><p>Our <strong>Start Turn</strong> button <a id="id952" class="indexterm"/>actually has two functions that it handles, <a id="id953" class="indexterm"/>starting and finishing the turn. This means that we will switch functionality based on the current status (text) of the button. In the controller, this button is referred to as <code class="literal">mainBtn</code> and the tap function looks like this:</p><div><pre class="programlisting">doMainBtn: function(btn) {
 var turn = this.getCurrentTurn();
 if (btn.getText() == 'Start Turn') {
  btn.setText('Finish Turn!');
  this.getAltBtn().setText('Clear Moves');
  turn.started = true;
  this.setCurrentTurn(turn);
  this.clearTurn();
  Ext.Msg.alert("Ready to play!", "It is "+turn.player[0].toUpperCase() + turn.player.slice(1)+"'s turn!");
 } else {
  if (turn.moves.length &gt; 1) {
  this.commitTurn(turn);
  turn.player = (turn.player == 'red')?'black':'red';
  this.setCurrentTurn(turn);
  this.clearTurn();
  btn.setText('Start Turn');
  this.getAltBtn().setText('Show Previous');
   }
 }
}</pre></div><p>We start by grabbing our <code class="literal">currentTurn</code> variable using <code class="literal">this.getCurrentTurn()</code>. If the game has just started, the turn belongs to black. The rest of our values will be empty or false at this point.</p><p>We then <a id="id954" class="indexterm"/>check to see what the text value of the button is, so that we can determine what to do next. If the text is <code class="literal">Start Turn</code>, we need to change the text of the button to <code class="literal">Finish Turn!</code>.</p><p>Our other button (<code class="literal">altBtn</code>) also changes its text based on the status of the current turn. If we are starting a new turn, <code class="literal">altBtn</code> will be set to <code class="literal">Clear Move</code>. This will allow the player to clear the move if they change their mind before finishing.</p><p>Next, we update<a id="id955" class="indexterm"/> our <code class="literal">turn</code> value for <code class="literal">started</code> to <code class="literal">true</code>. This lets us know that the current move has begun. We use the function called <code class="literal">clearTurn()</code> to clear out any old turn data and remove any previous selections from the board. We then inform the current player that it is their turn.</p><p>If the text of the button is set to <code class="literal">Finish Turn!</code>, the button will commit the selected move(s) for the current turn using another sub function called <code class="literal">commitTurn()</code>. We then change the current player, clear out the turn data, and reset the text for our two buttons. We'll come back to finishing a turn a bit later, but first we need to see what happens once the turn begins.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec107"/>Checking the turn</h2></div></div></div><p>Once the<a id="id956" class="indexterm"/> turn<a id="id957" class="indexterm"/> has started, the user taps on the DataView to move a piece. We then need to make sure that each selection they make is valid. We do this by listening to the DataView's <code class="literal">select</code> event<a id="id958" class="indexterm"/> with a function called<a id="id959" class="indexterm"/> <code class="literal">doSelect()</code>.</p><p>The first thing we want to make sure of is that the user has selected a valid piece, so the first thing we do is get the current turn:</p><div><pre class="programlisting">doSelect: function (view, record) {
 var turn = this.getCurrentTurn();</pre></div><p>Next, we have a few moves we know are illegal, in which case we can return false to prevent the player from selecting this moves:</p><div><pre class="programlisting">if (turn.endOfTurn || !turn.started) {
  return false;
 }</pre></div><p>This prevents the user from moving before the turn starts or after it has ended. We also don't want the user to select any or the light squares on the board:</p><div><pre class="programlisting">if (record.get('background') == 'light') {
  return false;
}</pre></div><p>With the obvious illegal moves out of the way, we start checking for allowed moves, starting with this one:</p><div><pre class="programlisting">if (turn.moves.length == 0 &amp;&amp; record.get('occupiedBy') != turn.player) {
 return false;
}</pre></div><p>This checks<a id="id960" class="indexterm"/> that we are at the beginning of a turn (<code class="literal">turn.moves.length == 0</code>) and the player has not <a id="id961" class="indexterm"/>clicked one of his or her opponent's pieces. If so, we return false to prevent the selection.</p><div><pre class="programlisting">} else if (turn.moves.length == 0) {
  turn.moves.unshift(record);
  turn.piece = record;
  this.setCurrentTurn(turn);
  return true;
}</pre></div><p>If we are at the beginning of a move and the user has clicked the correct piece, we add the record onto the beginning of our <code class="literal">moves</code> array.</p><div><div><h3 class="title"><a id="note56"/>Note</h3><p>We store <code class="literal">moves</code> in reverse order so that the first move in the list is the last move made. This is because it makes it much easier to grab the first element in the array (which will always be <code class="literal">turns.moves[0]</code>), than it is to count the array elements to grab the one on the end of the array.</p></div></div><p>We then set the current turn with our new information and return true, so that the selection event fires and the square the piece is in highlights.</p><p>If this is not the first move (<code class="literal">turn.moves.length</code> is greater than zero), it means the user has previously selected a piece and is now selecting a square for the piece to move into. If this is the case, we move on to the next <code class="literal">else</code> statement, which checks to see if the move is legal under our game rules:</p><div><pre class="programlisting">} else if (this.isLegalMove(turn.moves[0], record)) {
  turn.moves.unshift(record);
  
  if (this.isKingable(record)) {
   turn.kingable = true;
   this.setEndOfTurn();
   Ext.Msg.alert("King me!", "Landing here would cause you to be kinged and end your turn.");
  }

  this.setCurrentTurn(turn);
  this.decorateCurrentTurn();
  return true;
 } else {
  return false;
}</pre></div><p>If the move is <a id="id962" class="indexterm"/>legal, we also check <code class="literal">isKingable()</code>
<a id="id963" class="indexterm"/> to see if the player has reached the opposite side of the board. If the move is legal, we set the turn appropriately and add the arrows for the move using the <code class="literal">decorateCurrentTurn()</code> function<a id="id964" class="indexterm"/>. We will take a closer look at how<a id="id965" class="indexterm"/> the <code class="literal">decorateCurrentTurn()</code> function works a little later, but first we want to cover the logic behind the <code class="literal">isLegalMove()</code> function<a id="id966" class="indexterm"/>.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl3sec20"/>Checking if a move is legal</h2></div></div></div><p>The <code class="literal">isLegalMove()</code> function<a id="id967" class="indexterm"/> is called when the user has<a id="id968" class="indexterm"/> selected a valid piece and is attempting to move it to a new square. The move isn't actually committed in this function, we are just checking to see if the square the player taps is a valid move. If it is, we allow the DataView's <code class="literal">select</code> event to fire by returning true.</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>The source code for this application includes extensive console logs inside this function. These will print out information to the console in Safari or Chrome and should help when trying to follow the logic inside this function. Try clicking on valid and invalid moves while looking at the console to see which pieces of the function are responding, and how the move is validated.</p></div></div><p>To make this determination, we follow the basic rules for checkers and examine the move with the following criteria:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The destination square cannot be occupied</li><li class="listitem" style="list-style-type: disc">The move must be in the correct direction (regular pieces can only move forward)</li><li class="listitem" style="list-style-type: disc">The move can be one square away from the current position</li><li class="listitem" style="list-style-type: disc">The move can be two squares away from the current position, <em>if</em> there is an opponent's piece in between the two squares</li></ul></div><p>Since this is a rather large function, we will cover it in several parts, starting with the overall skeleton and filling in the details as we go.</p><p>We start our function by passing it values for our <code class="literal">from</code> and <code class="literal">to</code> locations for the move. We then grab the current turn and set some variables for later use:</p><div><pre class="programlisting">isLegalMove: function (from, to) {
 var turn = this.getCurrentTurn(),
 fromID, toID, distance, intermediate;
   
 if (to.get('occupiedBy') != 'none') {
  return false;
 }

 fromID = from.get('squareID').split('');
 toID = to.get('squareID').split(''); 
 // This makes the letter element 0, and the number element 1.

 distance = Math.abs(toID[1] - fromID[1]);
 
 if (distance == 1 &amp;&amp; !turn.hasJumped) {
  // here we will check for our different piece types: king, black or red
 }
 if (distance == 2) {
  // here we will check for our different piece types: king, black or red
 }

 return false;
}</pre></div><p>The first thing we check is if the destination square is occupied using <code class="literal">to.get('occupiedBy')</code>. If the square is clear this variable should be <code class="literal">none</code> and if it is occupied, it will be either <code class="literal">red</code> or <code class="literal">black</code>. If we get back <code class="literal">red</code> or <code class="literal">black</code>, we immediately return false which will exit our <code class="literal">isLegalMove()</code> function.</p><p>Next, we <a id="id969" class="indexterm"/>use the <code class="literal">split</code> function to take our values for <code class="literal">to</code> and <code class="literal">from</code>, and split them into an array. Since we <code class="literal">split</code> on <code class="literal">''</code>, it assigns the letter (A-H) to the first element of the array (<code class="literal">fromID[0]</code> and <code class="literal">toID[0]</code>) and assigns the number (1-8) to the second element of the array (<code class="literal">fromID[1]</code> and <code class="literal">toID[1]</code>).</p><p>We then use <code class="literal">Math.abs</code> to give us the distance between the two number values. <code class="literal">abs</code> is an absolute value, which ensures that we get back a positive number even if <code class="literal">fromID[1]</code> is greater than <code class="literal">toID[1]</code>.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>It is important to note that this distance is the row distance and not the actual number of squares between the start and the end of the move.</p></div></div><p>Next, we need to make sure our distance is one row (no jumping) or two rows (jumping). If it's neither, we return false and do not allow the move. These two sections are currently empty, so let's fill them out with some code.</p><p>As it turns out, these two options also have a few possibilities we need to account for. We will start off with a possible move of one row:</p><div><pre class="programlisting">if (distance == 1 &amp;&amp; !turn.hasJumped) {</pre></div><p>This checks our distance of one row and it also makes sure that the user does not jump a piece and then attempt to move a single row afterwards as part of the same move.</p><p>Inside of this <code class="literal">if</code> statement, we need to check three possibilities:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Is the piece a king?</li><li class="listitem" style="list-style-type: disc">Is the piece red?</li><li class="listitem" style="list-style-type: disc">Is the piece black?</li></ul></div><p>These criteria <a id="id970" class="indexterm"/>determine which direction the piece can move and allow us to check if the move is valid. For the king we check the following condition:</p><div><pre class="programlisting">if (turn.piece.get('pieceType') == 'King') {
    if (toID[0] == this.nextLetter(fromID[0])) {
        this.setEndOfTurn();
        return true;
    } else if (toID[0] == this.previousLetter(fromID[0])) {
        this.setEndOfTurn();
        return true;
    }
} </pre></div><p>Here we use our <code class="literal">nextLetter()</code> and <code class="literal">previousLetter()</code> functions as part of a check to see if the move is on the diagonal:</p><div><img src="img/8901OS_10_04.jpg" alt="Checking if a move is legal"/></div><p>In the example above, a king located in the <strong>2</strong> row of the board can move to either the <strong>1</strong> row or the <strong>3</strong> row, in the <strong>D</strong> or <strong>F</strong> column. Since our previous <code class="literal">doSelect()</code> function<a id="id971" class="indexterm"/> already checked to make sure we did not select a light background, we know that these are all valid moves. This is true for a king of either color.</p><p>We then call <code class="literal">setEndOfTurn()</code>
<a id="id972" class="indexterm"/> and return true to fire the select function and select the square.</p><p>For regular red and black pieces, we need to make sure the move is in the correct direction. For red, this looks like this:</p><div><pre class="programlisting">} else if (turn.piece.get('occupiedBy') == 'red') {
 if (toID[1] &lt; fromID[1]) {
  if (toID[0] == this.nextLetter(fromID[0])) {
   this.setEndOfTurn();
   return true;
  } else if (toID[0] == this.previousLetter(fromID[0])) {
   this.setEndOfTurn();
   return true;
  }
 }
}</pre></div><p>Since our rows are numbered 1 - 8 from top to bottom and red moves from bottom to top, we need to make sure that the row number we are coming from is less than the row number we are going to (<code class="literal">toID[1] &lt; fromID[1]</code>).</p><div><img src="img/8901OS_10_05.jpg" alt="Checking if a move is legal"/></div><p>We also need to make sure we are going to the next or previous letter before calling <code class="literal">setEndOfTurn()</code> and <a id="id973" class="indexterm"/>returning true to select the square in the DataView.</p><p>For the black pieces, we will be moving from top to bottom, so we need to make sure our destination row is greater than our starting row. This will close out our <code class="literal">if</code> statement for distances of one row (no jumping):</p><div><pre class="programlisting">} else {
 if (toID[1] &gt; fromID[1]) {
  if (toID[0] == this.nextLetter(fromID[0])) 
   { 
    this.setEndOfTurn();
    return true;
   } else if (toID[0] == this.previousLetter(fromID[0])) {
    this.setEndOfTurn();
    return true;
   }
 }
}</pre></div><p>As before, this checks our row letters to make sure we only move to the adjacent rows, calls <code class="literal">setEndOfTurn()</code> and returns true to select the square:</p><div><img src="img/8901OS_10_06.jpg" alt="Checking if a move is legal"/></div><p>Now that we have our single row moves accounted for, we need to take a look at what happens when <a id="id974" class="indexterm"/>we try to move a distance of two rows.</p><p>From the user's perspective, they will select a piece by tapping on it, and then select an empty square with an opponent's piece in between the two squares. If additional jumps are available, the play will tap those squares as well before clicking on the <strong>Finish Move</strong> button:</p><div><img src="img/8901OS_10_07.jpg" alt="Checking if a move is legal"/></div><p>In this example, the player would tap the red king piece and then tap the three squares (shown here with check marks) before <a id="id975" class="indexterm"/>clicking on the <strong>Finish Move</strong> button. Let's take a look at how the code checks for this move.</p><p>This is where we fill out the second <code class="literal">if</code> statement inside of our <code class="literal">isValidMove()</code> function:</p><div><pre class="programlisting">if (distance == 2) {
 intermediate = this.getIntermediateSquare(from, to);</pre></div><p>This will check our row distance and grab the square located between the <code class="literal">from</code> and <code class="literal">to</code> locations using a <code class="literal">getIntermediateSquare()</code> function. In the preceding example, the move from <strong>D5</strong> to <strong>B3</strong> would grab <strong>C4</strong> as the intermediate square.</p><p>Much like before, we will also need to check and see if the piece is black, red, or a king so we can make sure the jump is in the correct direction. However, there are a few new wrinkles to allow for.</p><p>First, we have to <a id="id976" class="indexterm"/>make sure that there is an opposing piece in between the <code class="literal">from</code> and <code class="literal">to</code> locations. Second, we need to allow for multiple jumps.</p><p>If you remember back at the top of our controller, we had two variables for <code class="literal">currentTurn</code> and <code class="literal">previousTurn</code>. Inside of these were empty arrays for <code class="literal">moves</code> and <code class="literal">removedPieces</code>. We will use these arrays to store the multiple jumps.</p><p>For the king pieces, we open up a new <code class="literal">if</code> statement, right below where we grabbed the intermediate square:</p><div><pre class="programlisting">if (turn.piece.get('pieceType') == 'King') {
  if (intermediate.get('occupiedBy') == 'red' &amp;&amp; turn.piece.get('occupiedBy') == 'black') {
   turn.moves.unshift(intermediate);
   turn.removedPieces.push(intermediate);
   turn.hasJumped = true;
   this.setCurrentTurn(turn);
   return true;
  } else if (intermediate.get('occupiedBy') == 'black' &amp;&amp; turn.piece.get('occupiedBy') == 'red') {
   turn.moves.unshift(intermediate);
   turn.removedPieces.push(intermediate);
   turn.hasJumped = true;
   this.setCurrentTurn(turn);
   return true;
  }
 }</pre></div><p>Once we know that we have a <code class="literal">King</code> piece, we don't need to check for the direction of the jump, we just need to make sure that the <code class="literal">intermediate</code> piece is the opposite color from the piece that is moving (our <code class="literal">occupiedBy</code> piece). Once we have determined this is a valid king jump, we use <code class="literal">unshift</code> to add the move onto the beginning of our array of moves.</p><div><div><h3 class="title"><a id="note59"/>Note</h3><p>Remember we need to add things to the beginning of the <code class="literal">moves</code> array, so we can quickly access the most recent of these moves later on by using <code class="literal">moves[0]</code> in our other functions. This is necessary for placing the arrow decorations correctly (as we will see later on). It is less critical for our <code class="literal">removedPieces</code> array, which places the negation symbol directly over the piece. So for <code class="literal">removedPieces</code>, we use the <code class="literal">push()</code> function instead.</p></div></div><p>We also add<a id="id977" class="indexterm"/> the <code class="literal">intermediate</code> location to our <code class="literal">removedPieces</code> array and set <code class="literal">hasJumped</code> to <code class="literal">true</code>. This lets us know that there are potentially more moves to be executed. Finally, we use <code class="literal">setCurrentTurn()</code>
<a id="id978" class="indexterm"/> to record the location the user selected and return true to select the square in the DataView.</p><p>For moving a red piece, we run a check to see if the piece is jumping forward by checking to make sure that <code class="literal">toID[1] &lt; fromID[1]</code>:</p><div><pre class="programlisting">} else if (turn.piece.get('occupiedBy') == 'red') {
 if (toID[1] &lt; fromID[1]) {
  if (intermediate.get('occupiedBy') == 'black') {
   turn.moves.unshift(intermediate);
   turn.removedPieces.push(intermediate);
   turn.hasJumped = true;
   this.setCurrentTurn(turn);
   return true;
  }
 }
}</pre></div><p>We also check to see if the piece that was jumped is black. The rest of the code follows the same pattern as the code for the king jump.</p><p>We add the same basic code block to check the jump for a black piece:</p><div><pre class="programlisting">} else {
  if (toID[1] &gt; fromID[1]) {
   if (intermediate.get('occupiedBy') == 'red') {
    turn.moves.unshift(intermediate);
    turn.removedPieces.push(intermediate);
    turn.hasJumped = true;
    this.setCurrentTurn(turn);
    return true;
   }
  }
 }</pre></div><p>Again, we check our direction using <code class="literal">toID[1] &gt; fromID[1]</code>, and check our intermediate square for a red piece. The rest of the code follows the same pattern as the code for both the red and the king jumps.</p><p>At the bottom of our <code class="literal">isValidMove()</code> function<a id="id979" class="indexterm"/>, after all the <code class="literal">if</code> statements, we close out the function with <code class="literal">return false</code>. This covers us when the user does something totally outside of our set of <code class="literal">if…then</code> rules.</p><p>Once we have<a id="id980" class="indexterm"/> determined if the move is valid, we need to add the correct classes to our game board to let the user know they have chosen a valid move, and what will happen when the move is finished.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec109"/>Decorating the move</h2></div></div></div><p>Once the <a id="id981" class="indexterm"/>user has <a id="id982" class="indexterm"/>started a turn and clicked on a square, there needs to be some indication that a valid move was selected. This happens as part of the <code class="literal">doSelect()</code> function<a id="id983" class="indexterm"/> and it happens in two different ways.</p><p>The first way is that when we validate the selected move, we return either <code class="literal">true</code> or <code class="literal">false</code>. When we return <code class="literal">true</code>, that DataView fires the <code class="literal">select</code> event and the selected square is highlighted (this is the default behavior for a DataView).</p><p>When we return <code class="literal">false</code>, we actually prevent the <code class="literal">select</code> event from firing and the square is not highlighted.</p><p>As we mentioned earlier in the chapter, the highlight color is controlled with CSS styles and a class of <code class="literal">x-item-selected</code>. This class is automatically applied to any selected item in a DataView. We can use a similar methodology to add additional CSS decorations to our squares, which will give the user a better idea of what is happening in the game.</p><p>This happens in the <code class="literal">decorateCurrentTurn()</code> function<a id="id984" class="indexterm"/>.</p><p>Earlier in the chapter we talked about our decoration classes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">up_left</code>: This suggests an arrow in the upper-left corner</li><li class="listitem" style="list-style-type: disc"><code class="literal">up_right</code>: This suggests an arrow in the upper-right corner</li><li class="listitem" style="list-style-type: disc"><code class="literal">down_left</code>: This suggests an arrow in the lower-left corner</li><li class="listitem" style="list-style-type: disc"><code class="literal">down_right</code>: This suggests an arrow in the lower-right corner</li><li class="listitem" style="list-style-type: disc"><code class="literal">removed</code>: This suggests a negation center in the middle of the square</li></ul></div><p>On the game board, they look like this:</p><div><img src="img/8901OS_10_08.jpg" alt="Decorating the move"/></div><p>The <code class="literal">decorateTurn()</code> function<a id="id985" class="indexterm"/> will loop through our array of moves for a turn and apply the correct styles.</p><p>We start by <a id="id986" class="indexterm"/>getting the <code class="literal">fromID</code> and <code class="literal">toID</code> values for the <a id="id987" class="indexterm"/>move and splitting it into an array with two elements: a number and a letter. Then we compare them to create a class name that corresponds to one of our four arrows:</p><div><pre class="programlisting">decorateTurn: function(turn) {
        var i, from, to, fromID, toID, cls;

        for (i = turn.moves.length - 1; i &gt; 0; i--) {
            from = turn.moves[i];
            to = turn.moves[i - 1];
            fromID = from.get('squareID').split('');
            toID = to.get('squareID').split(''); 
            if (fromID[1] &lt; toID[1]) {
                cls = 'down';
            } else {
                cls = 'up';
            }
            if (fromID[0] &lt; toID[0]) {
                cls += '_right';
            } else {
                cls += '_left';
            }
            from.set('decoration', cls);
        }

        for (i = 0; i &lt; turn.removedPieces.length; i++) {
            cls = turn.removedPieces[i].get('decoration');
            cls += ' removed';
            turn.removedPieces[i].set('decoration', cls);
        }

        this.getBoard().refresh();
    }</pre></div><p>For example, let's assume we have a piece moving from <strong>E4</strong> to <strong>D3</strong>. If we split these values and check <a id="id988" class="indexterm"/>them in the preceding code, we would see that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">4 &lt; 3 is false and we would set the value of <code class="literal">cls</code> to <code class="literal">up</code></li><li class="listitem" style="list-style-type: disc">D &lt; C is also false and we would add the text <code class="literal">_left</code> to our <code class="literal">cls</code> value</li></ul></div><p>This leaves us with a class of <code class="literal">up_left</code> applied to our square, and an arrow in the upper-left corner.</p><div><div><h3 class="title"><a id="note60"/>Note</h3><p>Comparing greater than / less than for text values in JavaScript compares the ASCII values for the letters. This is fine if you are comparing single letters, all with the same case, but it can become problematic in many cases. For example, "Z" &lt; "a" is actually true in JavaScript, because all uppercase letters have a lower ASCII value than lowercase letters. In this case we are comparing a single uppercase letter to another single uppercase letter, which works just fine.</p></div></div><p>Once we<a id="id989" class="indexterm"/> have set our arrow to indicate the direction using <code class="literal">from.set('decoration', cls);</code>, we need to account for any pieces to be removed. We handle this by looping through our <code class="literal">removedPieces</code> array that is part of our <code class="literal">turn</code> variable. We add <code class="literal">'removed'</code> to the class for all of the pieces in this array. The space in front of the string means that it will be added as an additional class on the square.</p><p>This means the CSS class would be something like <code class="literal">"up_left removed"</code>, if the turn jumps over a piece that is up and to the left of its current location. Both styles would be applied to the square, giving it an upper-left arrow and a negation symbol.</p><p>Once we have applied our styles for each move, we call <code class="literal">this.getBoard().refresh();</code> to refresh the board and make everything show up.</p><p>The beauty of creating a separate function for <code class="literal">decorateTurn()</code> is that we can use it to decorate the previous turn as well as the current one:</p><div><pre class="programlisting">decoratePreviousTurn: function() {
 var turn = this.getPreviousTurn();
 if (turn.player == null &amp;&amp; turn.piece == null) {
  Ext.Msg.alert('Game not started', 'There is no previous turn to show');
 return false;
}
 this.getBoard().select(turn.moves, false, true);
 return this.decorateTurn(turn);
}</pre></div><p>This function runs <a id="id990" class="indexterm"/>a check to see if we have a previous<a id="id991" class="indexterm"/> turn. If we do, we just pass it along to our decorate turn function and let it handle showing the appropriate decorations. If you were feeling particularly ambitious, you could store all the turns and replay every one of them by looping through and passing each turnoff to the <code class="literal">decorateTurn()</code> function.</p><p>However, before we get too ambitious, let's take a look at how we clear a move and its decorations.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec110"/>Clearing the move</h2></div></div></div><p>When we <a id="id992" class="indexterm"/>clear a move, we need to accomplish two main things: <a id="id993" class="indexterm"/>clear the data out of our <code class="literal">currentTurn</code> variable<a id="id994" class="indexterm"/> and clear the decoration values out of our store. We split this into two separate functions to make things easier to update and maintain. The first function handles resetting the values for our <code class="literal">currentTurn</code> variable and then deselects everything on the board:</p><div><pre class="programlisting">clearTurn: function() {
 var turn = this.getCurrentTurn();
 turn.piece = null;
 turn.moves = [];
 turn.removedPieces = [];
 turn.endOfTurn = false;
 turn.hasJumped = false;
 turn.kingable = false;
 this.setCurrentTurn(turn);
 this.getBoard().deselectAll(true);
 this.clearDecorations();
},
clearDecorations: function() {
 var store = this.getBoard().getStore();
 store.each(function(square) {
  square.set('decoration', '');
 });
}</pre></div><p>The second function clears all of the decorations from the store. You might remember from previously<a id="id995" class="indexterm"/> in the chapter, the decorations are the arrows<a id="id996" class="indexterm"/> that indicate movement and the negation symbols used to designate a jumped piece. These are all applied as CSS styles to the squares in our DataView. When we clear the value for decoration on each square in the store, the DataView will automatically remove the arrows and symbols from the display.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec63"/>Going beyond the finished game</h1></div></div></div><p>Playing through the <a id="id997" class="indexterm"/>finished game can lead to some interesting ideas for modifications and improvements.</p><div><img src="img/8901OS_10_09.jpg" alt="Going beyond the finished game"/></div><p>The squares could <a id="id998" class="indexterm"/>easily be adapted to the traditional hex grid used in most tabletop role-playing games.</p><div><img src="img/8901OS_10_10.jpg" alt="Going beyond the finished game"/></div><p>Even with a hex layout, the basic logic flow for the game still remains the same:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The user selects a piece and we check if it is a valid selection</li><li class="listitem" style="list-style-type: disc">The user selects a destination and we check if the destination is valid</li><li class="listitem" style="list-style-type: disc">If it is a valid move we provide visual feedback through CSS to tell the user</li><li class="listitem" style="list-style-type: disc">We determine the result of the move and remove or modify pieces as appropriate</li><li class="listitem" style="list-style-type: disc">We check to see if the game has ended and if not, we repeat the process for the next player</li></ul></div><p>The validation is<a id="id999" class="indexterm"/> also still a matter of math and some basic <code class="literal">if…then</code> logic. Granted, this logic can become much more complex, but the basic rules and game flow will remain the same.</p><p>Additionally, CSS transitions could be used to add a more visual appeal to the game play. A number of options can be found in the documentation at <a class="ulink" href="http://docs.sencha.com/touch/2-0/#!/api/Ext.Anim">http://docs.sencha.com/touch/2-0/#!/api/Ext.Anim</a>.</p><p>These variations allow you to take a simple game model and truly make it your own.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec64"/>Summary</h1></div></div></div><p>In this chapter we covered the creation of a basic game of checkers:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We built the basic game board</li><li class="listitem" style="list-style-type: disc">Explored the CSS and HTML structure to create our layout</li><li class="listitem" style="list-style-type: disc">We built the basic game controller and covered the game board logic</li><li class="listitem" style="list-style-type: disc">We showed you how to start, validate, decorate, and clear the moves on the board</li><li class="listitem" style="list-style-type: disc">We also talked about some options for expanding the game and making it your own original idea</li></ul></div></div></body></html>