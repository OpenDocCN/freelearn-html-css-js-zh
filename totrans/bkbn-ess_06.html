<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Creating Client-side Pages with Routers</h1></div></div></div><p>In this chapter, we'll examine Backbone's <code class="literal">Router</code> class to learn about the following:</p><div><ul class="itemizedlist"><li class="listitem">How routers simulate browser history to create virtual pages</li><li class="listitem">How to create new <code class="literal">Router</code> subclasses and instances</li><li class="listitem">The various mechanisms for defining routing patterns</li><li class="listitem">How to handle special cases, such as nonexistent routes</li><li class="listitem">How to use a page view to render routes consistently</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Backbone routers enable single-page applications</h1></div></div></div><p>Until now, all the Backbone<a id="id207" class="indexterm"/> features we've looked at have been<a id="id208" class="indexterm"/> enhancements to previously existing functionality; Backbone's classes improve on native JavaScript classes—<code class="literal">Models</code> and <code class="literal">Collections</code>—as well as enhance the functionality of objects and arrays, and <code class="literal">Views</code> improve on the DOM manipulation and event binding that jQuery already facilitates.</p><p>
<code class="literal">Routers</code>, however, break this trend. Instead of enhancing something that already exists, <code class="literal">Routers</code> allow you to do something entirely new: create an entire site using only a single HTML page. As discussed in <a class="link" title="Chapter 1. Building a Single-Page Site Using Backbone" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <em>Building a Single-page Site Using Backbone</em>, single-page applications offer several advantages over traditional multipage websites: most notably, enhanced performance and complete client-side control over the application. Backbone's <code class="literal">Router</code> class is what makes all this possible.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>How Routers work</h1></div></div></div><p>On a traditional <a id="id209" class="indexterm"/>multipage site, the browser provides both routing and page history without the need for any extra effort. When a user visits a URL on the site, the browser asks the server for that URL's content, and then when the user moves to another URL, the browser tracks the change in the user's browsing history. In a Backbone-powered site, however, both of these must be handled by a <code class="literal">Router</code> instead. When the user visits a new page, the <code class="literal">Router</code> determines which <code class="literal">Views</code> to render, and when they leave that page, the <code class="literal">Router</code> informs the browser of the new history entry. This lets a Backbone-powered site act just like a traditional one, including allowing the user to use their browser's <code class="literal">Back</code> button.</p><p>There are two different approaches by which a <code class="literal">Router</code> can accomplish this, and Backbone lets you decide which approach you want to use. The first, and default, approach is hash-based routing, which takes advantage of URL fragments (also known as named anchors). You've probably seen URLs with these fragments before, for instance <a class="ulink" href="http://www.example.com/foo#bar">www.example.com/foo#bar</a>. By using these fragments to define the pages of your site, Backbone can both know what page to load and can tell the browser how to track the user's movement across pages.</p><p>If you don't want your users to see hashes in your URLs, Backbone offers a second option that relies on the recently added HTML5 pushState technology. While this definitely helps URLs look cleaner, the pushState approach comes with a significant drawback. Although pushState is available in most web browsers, older browsers, such as Internet Explorer 9 and below, do not support it. If you try to use pushState-based routing in a browser without support for it, Backbone will instead fall back on hash-based routing. Even if only 1 percent of your users have an older browser, it still means that these 1 percent users will see a different URL from the rest of your users, which may cause confusion if (for instance) users with different browsers share links.</p><p>Routing based on pushState also has a minor drawback: if a user refreshes the page on a pushState-powered site, the browser will request that URL from the server. This can be solved by simply making your server return your application's single HTML page whenever the browser requests for such a URL. However, given both of these drawbacks, using pushState is only recommended if you care strongly about the appearance of your URLs and believe that all your users will have modern browsers.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Backbone.history</h1></div></div></div><p>Because it's<a id="id210" class="indexterm"/> possible to use multiple <code class="literal">Routers</code> at once (although it's not generally recommended, as we'll discuss later in the chapter), Backbone has a separate global object known as <code class="literal">Backbone.history</code> that handles history management. It is important to understand, however, that this object doesn't actually replace your browser's history; instead, it simply helps to manage what gets added to the history and when.</p><p>When you load a page that uses a Backbone <code class="literal">Router</code>, you need to invoke the <code class="literal">start</code> method of this history object in order to tell Backbone to begin routing. This <code class="literal">start</code> method also lets you tell Backbone which routing technology you need to employ. If you want Backbone to rely on hash-based routing, you can simply call the <code class="literal">this</code> method without any arguments:</p><div><pre class="programlisting">Backbone.history.start();</pre></div><p>If instead you wish <a id="id211" class="indexterm"/>to use pushState-based routing, you need to provide one extra argument to indicate it:</p><div><pre class="programlisting">Backbone.history.start({pushState: true});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Differences between routes and pages</h1></div></div></div><p>Routes and pages are very <a id="id212" class="indexterm"/>similar concepts and are often used interchangeably by Backbone <a id="id213" class="indexterm"/>programmers. This is natural since routes are essentially just the Backbone implementation of pages. However, there are important differences between the two, at least when you compare the pages of a multi-page website to the routes of a Backbone single-page application.</p><p>In traditional, multi-page websites, each new page that the user visits requires you to make a new request to the site's server. In a Backbone-powered site, however, the user can navigate through as many pages (routes) as they want, making new requests only when it is necessary to fetch new data. This feature alone accounts for a significant increase in speed on a Backbone-powered site.</p><p>Another important difference is that standard web pages trigger an entire page load, whereas routes trigger only a specific JavaScript function. This means that unlike a traditional application, which has to limit the number of pages (and thus the number of HTTP requests) it makes, routes can be used for just about any possible change in state. Routes can be used in a similar way to traditional web pages, or they can be used for much smaller changes to a page. They can even (rarely) be used when there is no change to the DOM at all.</p><p>Of course, while Backbone routes have many advantages, they also have some downsides. The most important downside is that because they do not refresh the page, existing DOM elements, style changes, and event bindings are not cleared automatically. This means that you will need to handle these clean-up tasks yourself. Luckily, this isn't very difficult to do, especially if you rely on a page view, which we will introduce shortly.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Creating a new Router</h1></div></div></div><p>As with all Backbone <a id="id214" class="indexterm"/>classes, you can create a new <code class="literal">Router</code> subclass by using <code class="literal">extend</code>, where the first argument provides the class's instance properties and methods and the second argument provides the static ones:</p><div><pre class="programlisting">var MyRouter = Backbone.Router.extend({
    // instance methods/properties go here
}, {
    // static methods/properties go here
);</pre></div><p>Similar to <code class="literal">Views</code>, <code class="literal">Routers</code> take only a single <code class="literal">options</code> argument when they are instantiated. This argument is completely optional, and the only real option it takes is the <code class="literal">routes</code> option. As mentioned, once the <code class="literal">Router</code> has been created, you will need to run <code class="literal">Backbone.history.start()</code> before it can handle routes:</p><div><pre class="programlisting">myRouter = new Backbone.Router({
    routes: {
        'foo': function() {
            // logic for the "/foo" or "#foo" route would go here }
    }
});
Backbone.History.start(); // siteRouter won't work without this</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Creating routes</h1></div></div></div><p>The problem with<a id="id215" class="indexterm"/> passing in your routes when you create a <code class="literal">Router</code> is that you have to supply all the routing functions together with your routes, which (especially if you have a lot of routes on your site) can easily become messy. Instead, many Backbone programmers define their routes on the <code class="literal">Router</code> class itself, as shown here:</p><div><pre class="programlisting">var SiteRouter = Backbone.Router.extend({
    routes: {
        'foo': 'fooRoute'
    },
    fooRoute: function() {
        // logic for the "/foo" or "#foo" route would go here }
});
var siteRouter = new SiteRouter();
Backbone.History.start(); // siteRouter won't work without this</pre></div><p>As you can see, this approach simplifies the routes' definition and makes them more similar to the <code class="literal">events</code> properties of <code class="literal">Models</code> and <code class="literal">Collections</code>. Instead of defining routing methods with the routes themselves, you can simply give the route the name of a routing method and Backbone will look for that method inside the <code class="literal">Router</code> class.</p><p>There is also a third way to add routes and that is by using Backbone's <code class="literal">route</code> method. This method takes the <code class="literal">route</code> as the first argument, the route's name as the second argument, and the route's handler as the third argument. If the third argument is omitted, Backbone will look for a method on the <code class="literal">Router</code> with the same name as the <code class="literal">route</code> itself:</p><div><pre class="programlisting">For example:SiteRouter = new Backbone.Router({
    initialize: function() {
        this.route('foo', 'fooRoute');
    },
    fooRoute: function() {
        // logic for the "/foo" or "#foo" route would go here}
});</pre></div><p>Just as the <code class="literal">on</code> <a id="id216" class="indexterm"/>method of <code class="literal">Models</code> and <code class="literal">Collections</code> lets you create event bindings after an instance of the class is created, the <code class="literal">route</code> method of <code class="literal">Routers</code> allows you to define a new route at any time. This means that you can dynamically create all your routes on the fly after the <code class="literal">Router</code> class is created. However, just as you would normally want all the pages of your site to be available to your user when they first visit it, you will generally want all your routes to be available too, which means that you will usually create them in your <code class="literal">Routers initialize</code> method.</p><p>The main advantage of using the <code class="literal">route</code> method is that you can apply logic to your routes. For instance, let's say you have several routes on your site that are only for administrators. If your <code class="literal">t</code> can check an <code class="literal">isAdmin</code> attribute of a user <code class="literal">Model</code>, then it can use this attribute to dynamically add or remove these administrator-only routes when the <code class="literal">Router</code> class is initialized, as shown here:</p><div><pre class="programlisting">// NOTE: In a real case user data would come from the server
var user = new Backbone.Model({isAdmin: true});SiteRouter = new Backbone.Router({
     initialize: function(options) {
        if(user.get('isAdmin')) {
            this.addAdminRoutes();
        }
    },
    addAdminRoutes: function() {
        this.route('adminPage1', 'adminPage1Route');
        this.route('adminPage2', 'adminPage2Route');
        // etc.
    }
});</pre></div><p>As you can see in the preceding example, another advantage of using the <code class="literal">route</code> method is that you can organize groups of routes into separate functions. This can be useful if you want to turn certain groups of routes on or off together, but it can also be useful simply to organize constant routes. In fact, you can even define some of your routes in an entirely different file as long<a id="id217" class="indexterm"/> as your <code class="literal">Router</code> has access to them, as shown here:</p><div><pre class="programlisting">// File #1
window.addFooRoutes = function(router) {
    router.route('foo', function() {
        //...
    })
}

// File #2SiteRouter = new Backbone.Router({
    initialize: function(options) {
        if(options.includeFooRoutes) {
            addFooRoutes(this);
        }
    }
});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Route styles</h1></div></div></div><p>In addition to having the choice to <a id="id218" class="indexterm"/>decide how you hook up your routes, you also have the choice to decide how to define the routes. So far, all the routes you've seen have been simple routes; they define a string of characters, and when Backbone sees that exact string of characters in the URL, it triggers the appropriate routing method. Sometimes, however, you'll want to have routes that are more flexible.</p><p>For example, imagine that we have a site which sells books and we want to have a "learn about a particular book" <code class="literal">route</code>. If we have a good number of books on our site, creating routes for each of them individually might get painful:</p><div><pre class="programlisting">var SiteRouter = new Backbone.Router({
    initialize: function(options) {
        this.route('book/1', 'book1Route'); // for the book with ID 1
        this.route('book/2', 'book2Route'); // for the book with ID 2
        this.route('book/3', 'book3Route'); // for the book with ID 3
        // this will get old fast
    }
});</pre></div><p>Luckily, there are two alternatives that solve this problem: routing strings and regular expression routes. First, let's look at how regular expression routes can solve this problem:</p><div><pre class="programlisting">SiteRouter = new Backbone.Router({
    initialize: function(options) {
        // This regex will match "book/" followed by a number
        this.route(/^book\/(\d+)$/, 'bookRoute');
    },
    bookRoute: function(bookId) {
        // book route logic would go here
    }
});</pre></div><p>As you can see in the preceding example, we were able to create a single route with a regular expression that matches all our possible book routes. Because this expression contains a group (the part of the regular expression that is surrounded by parentheses), Backbone will pass the matching part of the route to the routing function as an argument, allowing us to know the book's ID from within our routing function. If we were to include multiple groups in our regular expression, Backbone would have provided each matching part of the route as a separate argument to our routing function.</p><p>Regular expressions are powerful, which makes them a good choice for defining routes. However, they have one major downside: they are hard for humans to read, especially when you revisit them months after writing them. As the old programming adage goes: you had a problem and tried to solve it using regular expressions. Now you have two problems. For this reason, Backbone provides a third option for defining routes: routing strings.</p><p>Routing strings are similar to regular<a id="id219" class="indexterm"/> expressions; in that, they let you define dynamic routes but are much more limited. You can only define groups (also known as <a id="id220" class="indexterm"/>
<strong>parameters</strong>), wildcard groups (also known as <a id="id221" class="indexterm"/>
<strong>splats</strong>), and optional parts. By trading away some of the power of regular expressions, routing strings gain a great deal of readability. Instead of using <code class="literal">(\d+)</code> to match a part of the route for a book's ID, a routing string will use the more readable <code class="literal">bookId</code>.</p><p>Just as with a regular expression route, Backbone will provide the route's parameters as arguments to the routing function, as shown here:</p><div><pre class="programlisting">SiteRouter = new Backbone.Router({
    initialize: function(options) {
        this.route('book/:bookId', 'bookRoute');
    },
    bookRoute: function(bookId) {
        // book route logic would go here
    }
});</pre></div><p>If we wanted to make that part of the route optional, we can wrap it with parentheses (for example, <code class="literal">book/(:bookId)</code>). However, there's a problem; routing strings stop matching parameters (optional or not) when they see a <code class="literal">/ </code>character, which means that they won't work if your book ID has a <em>/</em> in it. For instance, if we tried to navigate to <code class="literal">book/example/with/slash/5</code>, our route wouldn't get triggered. To get around this issue, Backbone provides a <code class="literal">wildcard</code> or <code class="literal">splat</code> option, which will match the remaining portion of the <code class="literal">route</code> class. These splats are like parameters, but they use a <code class="literal">*</code> character instead of a <code class="literal">:</code> character:</p><div><pre class="programlisting">SiteRouter = new Backbone.Router({
    initialize: function(options) {
        this.route('book/*bookId', 'bookRoute');
    },
    bookRoute: function(bookId) {
        // book route logic would go here
    }
});
// if we now navigate to "book/example/with/slash/5 " our bookRoute 
// method will receive an argument of "example/with/slash/5 "</pre></div><p>Because Backbone is <a id="id222" class="indexterm"/>not particular about whether you use simple routes, regular expressions, or routing strings, you can freely combine all the three types in any given <code class="literal">Router</code>. You'll probably find it best, however, to use the most readable form possible each time. In other words, you should start by trying to use a simple route, then switch to a routing string if you need to add a few variables, and only use a regular expression if you can't define the route with a routing string.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>A note about routing conflicts</h1></div></div></div><p>Whichever method you use to <a id="id223" class="indexterm"/>create your routes, you should be careful to avoid defining the same route twice or defining two routes that overlap each other, such as <code class="literal">foo</code> and <code class="literal">splatThatCouldBeFoo</code>. While Backbone will allow you to define such routes and will continue working fine in spite of them, it will silently ignore any routes after the first that match. Take an example of the following code snippet:</p><div><pre class="programlisting">new Backbone.Router({
    routes: {
        'foo': function() {alert('bar')},
        ':splatThatCouldBeFoo': function() {alert('baz')},
    }
}) 
Backbone.history.start();
// navigating to #foo alerts('bar')</pre></div><p>One could take advantage of this behavior by deliberately defining specific routes, and then less specific overlapping routes, but this is not generally recommended. While a few simple overlapping routes are unlikely to cause problems, if you have too many they can make your <code class="literal">Router</code> difficult to work with. When you have such overlapping routes you have to first stop and understand every route involved before you can make changes to any of them, and then if you make<a id="id224" class="indexterm"/> a mistake it's all to easy to create a difficult to find bug.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Trailing slashes</h1></div></div></div><p>Before we move on from routes there <a id="id225" class="indexterm"/>is one last detail worth mentioning: trailing slashes. Normally web developers don't need to think about trailing slashes, because most web servers treat <code class="literal">foo</code> and <code class="literal">foo</code>/ the same. Technically however they are different, and Backbone treats them as such, which means that a route of <code class="literal">foo</code> will not be triggered when the user navigates to <code class="literal">foo</code>/.</p><p>Luckily this can easily be solved if you are using routing strings by adding (<code class="literal">/</code>) to the end of each string. If you are using regular expressions you can achieve a similar effect by adding <code class="literal">\/?</code> to the end of each of your regular expressions. However, if you are using simple strings you will either need to define two separate routes (<code class="literal">foo</code> and <code class="literal">foo</code>/), or you will just need to be careful never to create any links to <code class="literal">foo</code>/.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Redirects</h1></div></div></div><p>Normally users traverse a site by clicking<a id="id226" class="indexterm"/> on anchor tags, better known as hyperlinks. The same is true for Backbone-powered sites; even if you use hash-based routes you can still create normal hyperlinks for them:</p><div><pre class="programlisting">&lt;a href="#foo"&gt;Click here to go to the "foo" route&lt;/a&gt;</pre></div><p>Sometimes however you will want to move the user to a different route using JavaScript instead. For instance, you might have a <strong>Submit</strong> button on a page and after it triggers a save of the page's <code class="literal">Model</code> you want it to redirect the user to a different route. This can be done by using the <code class="literal">Routers navigate</code> method, like so:</p><div><pre class="programlisting">var router = new Backbone.Router({
    routes: {
        foo: function() {
            alert('You have navigated to the "foo" route!');
        }
    }
});
router.navigate('foo', {trigger: true});</pre></div><p>It's important to note the addition of the <code class="literal">trigger</code> option as the second argument to <code class="literal">navigate</code>. Without this extra argument, Backbone will take the user to the route's URL but won't actually trigger the route's logic.</p><p>The <code class="literal">navigate</code> method can also take one other option: <code class="literal">replace</code>. If this option is provided, Backbone will navigate to the specified route but will not add an entry to the browser's history. Take an example of the following line of code:</p><div><pre class="programlisting">router.navigate('bar', {replace: true, trigger: true});</pre></div><p>Not creating a history entry <a id="id227" class="indexterm"/>means that, for instance, if the user visits another page and then clicks on their browser's <strong>Back</strong> button instead of going back to the replaced page, they will be taken to the page before it in the browser's history. Since this sort of behavior will likely be confusing for your user, it is recommended that you limit the use of <code class="literal">replace: true</code> to routes that are temporary, such as the route for loading a page.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>404s and other errors</h1></div></div></div><p>Until now, we've focused on what <a id="id228" class="indexterm"/>happens when a route matches, but what happens when the user visits a URL that doesn't have a matching route? This can happen, for instance, because of a stale link or because the user mistyped a URL. On a traditional website, the server will handle this by throwing a <code class="literal">404</code> error, but on a Backbone-powered site, the <code class="literal">Router</code> class will just do nothing, by default. This means that if you want to have a <code class="literal">404</code> page on your site, you'll have to create it yourself.</p><p>One way to do this is to rely on the <code class="literal">start</code> method. This method returns <code class="literal">true</code> or <code class="literal">false</code> depending on whether any matching routes are found for the current URL:</p><div><pre class="programlisting">if (!Backbone.history.start()) {
    // add logic to handle the "404 Page Not Found" case here
}</pre></div><p>However, since that method will only be called once, when the page is first loaded, it won't allow you to catch nonmatching routes that occur after the page is loaded. To catch these cases, you'll need to define a special <code class="literal">404</code> route, which you can do using the routing string's <code class="literal">splat</code> syntax:</p><div><pre class="programlisting">var SiteRouter = Backbone.Router.extend({
    initialize: function(options) {
        this.route('normalRoute/:id', 'normalRoute');
        this.route('*nothingMatched', 'pageNotFoundRoute');
    },
    pageNotFoundRoute: function(failedRoute) {
        alert( failedRoute + ' did not match any routes');
    }
});</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Routing events</h1></div></div></div><p>Normally, route-based logic is <a id="id229" class="indexterm"/>handled by the <code class="literal">Router</code> class itself. However, sometimes you may wish to <em>trigger</em> additional logic. For instance, you may want to add a certain element to the page whenever the user visits one of several routes. In such a case, you can take advantage of the fact that Backbone triggers events each time routing occurs, allowing you to listen and respond to route changes from outside the <code class="literal">Router</code> class itself.</p><p>You can listen for routing events the same way as events in <code class="literal">Models</code> and <code class="literal">Collections</code>, by using the <code class="literal">on</code> method, as follows:</p><div><pre class="programlisting">var router = new Backbone.Router();
router.on('route:foo', function() {
    // do something whenever the route "foo" is navigated to
});</pre></div><p>The following table shows the three different routing events that you can listen for on a <code class="literal">Router</code> class:</p><div><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Event name</p>
</th><th valign="bottom">
<p>Trigger</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">route</code>
</p>
</td><td valign="top">
<p>This is triggered when any route is matched</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">route:name</code>
</p>
</td><td valign="top">
<p>This is triggered when the route with the specified name is matched</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">all</code>
</p>
</td><td valign="top">
<p>This is triggered when any event is triggered on the <code class="literal">Router</code> class</p>
</td></tr></tbody></table></div><p>In addition, Backbone also provides a <code class="literal">route</code> event that you can listen to on the <code class="literal">Backbone.history</code> object, as follows:</p><div><pre class="programlisting">Backbone.history.on('route', function() { ... });</pre></div><p>The advantage of listening to <code class="literal">history</code> instead of a particular <code class="literal">Router</code> is that it will catch events from all the <code class="literal">Routers</code> on your site, instead of just a particular one.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Multiple routers</h1></div></div></div><p>In general, you only need a <a id="id230" class="indexterm"/>single <code class="literal">Router</code> to power your entire site. However, if you have reason to do so, you can easily include multiple <code class="literal">Routers</code>, and Backbone will happily allow this. If two or more <code class="literal">Routers</code> on the same page match a particular route, Backbone will trigger the route from the first <code class="literal">Router</code> with a matching route defined.</p><p>There are two main reasons why you should use multiple <code class="literal">Routers</code>. The first reason is to separate your routing into logical groups. For instance, in an earlier example, we used a conditional to add certain admin-only routes to the <code class="literal">Router</code> class when the current user was an administrator. If our site has enough of these routes, it might make sense to create a separate <code class="literal">Router</code> for the admin-only routes, as follows:</p><div><pre class="programlisting">var NormalRouter = Backbone.Router({
     routes: {
        // routes for all users would go here
    }
};
var AdminRouter = Backbone.Router({
     routes: {
        // routes for admin users only would go here
    }
};
new NormalRouter();
if (user.get('isAdmin') {
    new AdminRouter();
}</pre></div><p>The other reason why you need to use multiple <code class="literal">Routers</code> is when you have two different sites that need to share some common code. For instance, a book-selling site might want a main site for their shoppers to buy books and an entirely different site for publishers to submit new books. However, even though the sites are different, they might both want to share some common code, such as a <code class="literal">Book Model</code> or a book-rendering <code class="literal">View</code>. By using multiple <code class="literal">Routers</code>, our bookseller can share any code they want between the two sites, while keeping the pages/routes of each entirely separate from one another.</p><p>In practice though, using <a id="id231" class="indexterm"/>multiple <code class="literal">Routers</code> can be confusing, especially if they have overlapping routes. Since you can easily add routes dynamically (as we did with our earlier administrator example), there typically won't be any need for you to rely on multiple <code class="literal">Routers</code> and you will likely avoid confusion by sticking to only one.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec61"/>Page views</h1></div></div></div><p>Before we finish this chapter, it's worth <a id="id232" class="indexterm"/>discussing how <code class="literal">Views</code> interact with <code class="literal">Routers</code>. Throughout this chapter, we've deliberately been vague about what you should actually do inside your routing functions, and part of the beauty of Backbone is that it leaves this decision entirely up to you.</p><p>For many Backbone users, however, a very common pattern is to create a special <code class="literal">Page View</code> and then instantiate a different subclass of that <code class="literal">View</code> in every route-handling method. Take an example of the following code snippet:</p><div><pre class="programlisting">var Book = Backbone.Model.extend({urlRoot: '/book/'});
var Page = Backbone.View.extend({render: function() {
        var data = this.model ? this.model.toJSON() : {};
        this.$el.html(this.template(data));
        return this;
    }
});
var BookPage = Page.extend({
   template: 'Title: &lt;%= title %&gt;' 
});
var SiteRouter = new Backbone.Router({
    route: {
        'book/:bookId(/)': 'bookRoute',
    },
    bookRoute: function(bookId) {
        var book = new Book({id:  bookId});
        book.fetch().done(function() {
            var page = new BookPage({model: book});
            page.render();
        });
    }
});</pre></div><p>If your site has multiple sections, for<a id="id233" class="indexterm"/> instance a side navigation bar and a main content area, you can split up these parts into their own <code class="literal">View</code> classes and then make those parts the defaults used by your <code class="literal">Page View</code> class. You can then override these defaults as needed in your <code class="literal">Page View</code> subclasses to allow these <code class="literal">Views</code> to change the different parts of your site.</p><p>For instance, let's say most of the time, your site has a single side navigation bar but on certain pages, you wish to add some extra links to it. By using the <code class="literal">Page View</code> architecture, such a scenario is easy to implement:</p><div><pre class="programlisting">var StandardSidebar = Backbone.View.extend({
    // Logic for rendering the standard sidebar });Page = Backbone.View.extend({
    sideBarClass:  StandardSidebar,

    render: function() {
        // render the base page HTML
        this.$el.html('&lt;div id="sidebar"&gt;&lt;/div&gt;' +
                      '&lt;div id="content"&gt;&lt;/div&gt;');

        // render the sidebar
        var sidebar = new this.sideBarClass({
            el: this.$('#sidebar')
        });
        sidebar.render();

        // logic for rendering the content area would go here
        return this;
    }
});
var AlternateSidebar  = Backbone.View.extend({
    // Logic for rendering the alternate sidebar });
var AlternateSidebarPage = Page.extend({
   sidebarClass: AlternateSidebar
});</pre></div><p>As you can see in the <a id="id234" class="indexterm"/>preceding example, our <code class="literal">AlternateSidebar</code> and <code class="literal">AlternateSidebarPage</code> classes are very short. Thanks to the power of inheritance, they don't need to redefine any of your existing logic and can instead focus entirely on what makes them different: the logic for rendering the alternate sidebar. While your site may not even have a sidebar, it is no doubt made up of composable parts, and by breaking these parts into separate <code class="literal">View</code> classes, your routes can simply use the appropriate class for whichever <code class="literal">View</code> they wish to render.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec62"/>Summary</h1></div></div></div><p>In this chapter, we explored Backbone's <code class="literal">Router</code> class. You learned how Backbone simulates pages by creating <code class="literal">routes</code> on a <code class="literal">Router</code> class and how <code class="literal">Routers</code> can operate using either hash-based or pushState-based routing. You also learned about the three different ways to add routes (via a <code class="literal">routes</code> option, a <code class="literal">routes</code> property, or the <code class="literal">route</code> method) and the three types of routes (simple, route strings, and regular expressions). Finally, you saw how to handle missing routes, respond to routing events, use multiple <code class="literal">Routers</code>, and most importantly how to combine a page view with composable sub-<code class="literal">Views</code> to power your routing methods.</p><p>In the next chapter, we'll take a look at some more advanced uses of Backbone, such as using methods in place of Backbone properties, such as <code class="literal">model</code>, or mixing sets of methods into multiple classes.</p></div></body></html>