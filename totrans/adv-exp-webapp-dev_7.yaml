- en: Chapter 7. Production
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 生产
- en: In this chapter we will discuss putting an Express application into production.
    We start this chapter by making our Express application a bit more robust as we
    look at handling exceptions. We then take a look at a series of performance improvements
    we will need to make in order for our application to survive in a production environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论将Express应用程序投入生产。我们首先通过查看异常处理使我们的Express应用程序更加健壮。然后我们看一下为了使应用程序能够在生产环境中生存，我们需要进行的一系列性能改进。
- en: Error handling, domains, and crash-only design
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理、域和仅崩溃设计
- en: 'The Node community has embraced a crash-only design pattern, which simply means
    this: if you get an uncaught exception, catch it, log it, and restart the process.
    Crash-only design and domains work quite well as a pattern, particularly if your
    application is using `cluster`. Let''s make a change to our `cluster` module,
    `./lib/cluster/index.js`, on `vision-core`. Here, we include the `domain` module;
    instead of simply including our module to run in a cluster, we create a domain
    and call the `run` method. We then include a domain-based `error` handler that
    logs and then closes the process via `process.exit(1)`. The cluster `exit` handler
    will pick this up and `fork` a new process:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Node社区采用了仅崩溃的设计模式，这简单意味着：如果你遇到未捕获的异常，捕获它，记录它，然后重启进程。仅崩溃设计和域作为一个模式工作得相当好，尤其是如果你的应用程序正在使用`cluster`。让我们在`vision-core`上的`cluster`模块`./lib/cluster/index.js`中做一些更改，这里我们包含了`domain`模块；而不是简单地包含我们的模块以在集群中运行，我们创建了一个域并调用`run`方法。然后我们包含了一个基于域的`error`处理器，它通过`process.exit(1)`记录并关闭进程。集群的`exit`处理器将捕获这个信号并`fork`一个新的进程：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Redis sessions
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Redis会话
- en: The majority of Express applications in production that require session support
    will probably use Redis, so making Redis performant is quite important. Our Redis
    client, `node-redis`, uses a pure JavaScript parser; the node-redis documentation
    suggests using an alternative module for parsing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，大多数需要会话支持的Express应用程序可能会使用Redis，因此使Redis性能良好非常重要。我们的Redis客户端`node-redis`使用纯JavaScript解析器；node-redis文档建议使用一个替代模块进行解析。
- en: 'Hiredis is a binding to the official Hiredis C library; it''s non-blocking
    and fast. If you install `hiredis`, node-redis will use it by default. Let''s
    install Hiredis on `vision-core`:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Hiredis是对官方Hiredis C库的绑定；它是非阻塞的且速度快。如果你安装了`hiredis`，node-redis将默认使用它。让我们在`vision-core`上安装Hiredis：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: SSL termination
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SSL终止
- en: '**SSL termination** is the term given to the decrypting of a TLS-encrypted
    (HTTPS) stream into plain text (HTTP). The TLS module in Node core is not as fast
    as some other technologies used for terminating SSL and is generally not used
    in production. Our application runs entirely over HTTPS, so TLS performance is
    vital.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**SSL终止**是指将TLS加密（HTTPS）流解密为纯文本（HTTP）。Node核心中的TLS模块不如一些用于终止SSL的其他技术快，通常不用于生产。我们的应用程序完全运行在HTTPS上，因此TLS性能至关重要。'
- en: 'Fortunately, we have options for SSL; we will use `stud`, a network proxy that
    terminates TLS/SSL connections and forwards the unencrypted traffic to a web server.
    Stud is built on `libev` and is non-blocking; it is designed to handle tens of
    thousands of connections efficiently on multicore machines. Let''s clone the stud
    GitHub repository:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有SSL选项；我们将使用`stud`，这是一个网络代理，它终止TLS/SSL连接并将未加密的流量转发到Web服务器。Stud基于`libev`构建，是非阻塞的；它被设计用来在多核机器上高效地处理数万个连接。让我们克隆stud的GitHub仓库：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now compile stud from source:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在从源代码编译stud：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the installation is complete, we can generate a stud file. Stud comes
    with a default configuration that we can request via:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以生成一个stud文件。Stud附带一个默认配置，我们可以通过以下方式请求：
- en: '[PRE4]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our stud file, `./vision-web/stud.conf`, requires a couple of important changes
    for it to work; the `frontend` configuration should be set to port `8443`, and
    the `backend` configuration should be set to our Hipache load balancer for `vision-web`,
    which we have hosted on port `3003`. Finally, we set `pem-file`, which is a single
    PEM file that includes an SSL certificate and private key:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的研究文件`./vision-web/stud.conf`需要一些重要的更改才能正常工作；`frontend`配置应设置为端口`8443`，而`backend`配置应设置为托管在端口`3003`上的Hipache负载均衡器`vision-web`。最后，我们设置`pem-file`，这是一个包含SSL证书和私钥的单个PEM文件：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have our stud configuration in place, our Hipache load balancer
    will no longer need to terminate SSL. Let''s remove the SSL configuration from
    our Hipache configuration, `./vision-web/config/server.json`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了stud配置，我们的Hipache负载均衡器将不再需要终止SSL。让我们从Hipache配置`./vision-web/config/server.json`中移除SSL配置：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With our configuration in place, let's create a certificate with a private key
    as a single PEM file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置就绪后，让我们创建一个带有私钥的单个PEM文件证书。
- en: Simply copy your `cert.pem` and `key.pem` into a single file called `./lib/secure/vision.pem`;
    private key first followed by your certificate.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将您的`cert.pem`和`key.pem`复制到一个名为`./lib/secure/vision.pem`的单个文件中；首先放置私钥，然后是您的证书。
- en: 'Now, we can run stud in front of our Hipache load balancer; stud will handle
    SSL and will direct unencrypted traffic to Hipache as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在Hipache负载均衡器前面运行stud；stud将处理SSL并将未加密的流量按如下方式定向到Hipache：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Please run the following set of commands to run our stack behind stud:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请运行以下命令集以在stud后面运行我们的堆栈：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Caching
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: 'Our static file requirements are minimal; the only static content we serve
    would be the components used on the client side of our application. In order to
    cache our static files/components, let''s make a simple change to `vision-web/lib/express/index.js`.
    We set the `maxAge` property to a week, which we store in config, as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的静态文件需求很小；我们提供的唯一静态内容将是应用客户端使用的组件。为了缓存我们的静态文件/组件，让我们对`vision-web/lib/express/index.js`进行简单的修改。我们将`maxAge`属性设置为一周，并将其存储在配置中，如下所示：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s add the config value, `staticCache`, to `vision-web/config/*.json`,
    as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将配置值`staticCache`添加到`vision-web/config/*.json`中，如下所示：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, when we hit our application, the response headers will have a cache-control
    header. If you visit the homepage for our application and check the response headers
    via your browser tools for any of the resources served, you should see:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们访问我们的应用时，响应头将包含一个缓存控制头。如果您访问我们应用的首页并通过浏览器工具检查提供的任何资源的响应头，您应该看到以下内容：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Favicon
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网站图标
- en: 'Lets add a favicon to our application using the `connect.favicon` middleware.
    From a performance perspective, this has some value as we can cache it. Also,
    your browser will request a favicon even if one does not exist, and this can result
    in 404 errors being thrown. We will use the existing `staticCache` config value
    to set `maxAge` for the favicon. Let''s edit the Express server, `/vision-web/lib/express/index.js`,
    and add the `favicon` middleware:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`connect.favicon`中间件为我们的应用添加一个网站图标。从性能角度来看，这有一些价值，因为我们可以缓存它。此外，即使不存在图标，您的浏览器也会请求它，这可能导致抛出404错误。我们将使用现有的`staticCache`配置值来设置图标的`maxAge`。让我们编辑Express服务器`/vision-web/lib/express/index.js`并添加`favicon`中间件：
- en: '[PRE12]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Minification
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 压缩
- en: 'We can improve page load time by minifying our static assets. We will minify
    our JavaScript and CSS files by installing the following two grunt tasks:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过压缩我们的静态资源来提高页面加载时间。我们将通过安装以下两个grunt任务来压缩我们的JavaScript和CSS文件：
- en: '`grunt-contrib-uglify`: This allows you to minify JavaScript files:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`grunt-contrib-uglify`：这允许您压缩JavaScript文件：'
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`grunt-contrib-cssmin`: This allows you to minify CSS files:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`grunt-contrib-cssmin`：这允许您压缩CSS文件：'
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s add these minification tasks to our grunt file, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些压缩任务添加到我们的grunt文件中，如下所示：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s run the following commands:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE16]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Not all of our JavaScript components have a minified version, so we minify these
    as well, adding a `.min` version for json2 and handlebars.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 并非我们所有的JavaScript组件都有压缩版本，因此我们也对这些组件进行压缩，为json2和handlebars添加`.min`版本。
- en: Compression
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩
- en: 'We can improve page load times further by compressing static files. Express
    includes the `compress` middleware, which will gzip an HTTP response. Let''s edit
    the Express server, `/vision-web/lib/express/index.js`, and add the `compress`
    middleware, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过压缩静态文件进一步提高页面加载时间。Express包括`compress`中间件，它将gzip HTTP响应。让我们编辑Express服务器`/vision-web/lib/express/index.js`并添加`compress`中间件，如下所示：
- en: '[PRE17]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you visit the homepage for our application and check the response headers
    via your browser tools for all of the resources served, you should see this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问我们应用的首页并检查通过浏览器工具提供的所有资源的响应头，您应该看到以下内容：
- en: '[PRE18]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Logging
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录日志
- en: 'The Express server, `./lib/express/index.js`, uses the `logger` middleware
    for logging. The Express logger should only be used in development. In fact, in
    a production environment, this will seriously impact performance as console functions
    are synchronous. Let''s change the Express server and switch off logging when
    in production, as shown in the following code snippet:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Express 服务器，`./lib/express/index.js`，使用 `logger` 中间件进行日志记录。Express 日志记录器应仅在开发环境中使用。实际上，在生产环境中，这将对性能产生严重影响，因为控制台函数是同步的。让我们更改
    Express 服务器，并在生产时关闭日志，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Express in commercial production environments can look a little different, but
    for good reason. Many of the tasks Express/Node support can be performed better
    by other tools. In our application, we have tried to stay on the node stack; we
    have chosen to use stud to terminate SSL as our entire application runs on SSL.
    Stud will outperform all in this space, including Nginx and Haproxy. Stud will
    forward unencrypted responses to Hipache, which balances load. Hipache is based
    on node-http-proxy; it uses cluster for failover. More importantly, unlike node-http-proxy,
    it can manage memory, making it a reasonable choice for a load balancer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在商业生产环境中，Express 可能看起来有些不同，但这是有充分理由的。许多 Express/Node 支持的任务可以由其他工具更好地执行。在我们的应用程序中，我们尽量保持在
    node 堆栈上；我们选择使用 stud 终止 SSL，因为我们的整个应用程序都运行在 SSL 上。Stud 将在这个领域超越所有其他工具，包括 Nginx
    和 Haproxy。Stud 将将未加密的响应转发到 Hipache，以平衡负载。Hipache 基于 node-http-proxy；它使用集群进行故障转移。更重要的是，与
    node-http-proxy 不同，它可以管理内存，使其成为负载均衡器的合理选择。
- en: Hipache works well, but if it's performance you really seek, Nginx and Haproxy
    are the de facto tools to reach for. For failover, we are using node's cluster
    module, which along with domains, makes our application a little more robust.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Hipache 工作得很好，但如果你真正寻求性能，Nginx 和 Haproxy 是事实上的工具选择。对于故障转移，我们使用 node 的集群模块，结合域名，使我们的应用程序更加健壮。
- en: Our static file requirements are minimal, so we have chosen to serve, cache,
    compress, and minify our static resources via Express. Any deviation from these
    minimal requirements will make me reach for either Nginx or Haproxy to deliver
    statics, or a Content Delivery Network.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的静态文件需求很小，因此我们选择通过 Express 提供静态资源，包括缓存、压缩和精简。任何偏离这些最小需求的行为都会让我选择 Nginx 或 Haproxy
    来提供静态内容，或者使用内容分发网络。
- en: We have managed to automate many tasks. Our code coverage is sitting at around
    80 percent, running YSlow and PageSpeed on our application produces good results.
    Ideally, we would like to have driven all our requirements via test, driven some
    of the smaller code modules with unit tests, and added more acceptance tests using
    Cucumber. I hope that you have at least managed to get the feel of all these elements
    and will be able to make your own informed choices about testing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功自动化了许多任务。我们的代码覆盖率大约在 80%，在我们的应用程序上运行 YSlow 和 PageSpeed 产生了良好的结果。理想情况下，我们希望通过测试驱动所有需求，通过单元测试驱动一些较小的代码模块，并使用
    Cucumber 添加更多验收测试。我希望你至少已经能够感受到所有这些元素，并能够根据自己的判断做出关于测试的明智选择。
- en: The Node/Express stack is a great platform for building web applications. Working
    with full-stack JavaScript is a great development experience. The node community
    and the thousands of Node module developers make Node a vibrant and interesting
    space to work in.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Node/Express 堆栈是构建 Web 应用程序的一个非常好的平台。与全栈 JavaScript 一起工作是一种非常好的开发体验。Node 社区和数千名
    Node 模块开发者使 Node 成为一个充满活力和有趣的领域来工作。
