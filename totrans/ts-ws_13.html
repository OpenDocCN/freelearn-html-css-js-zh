<html><head></head><body>
		<div>
			<div id="_idContainer141" class="Content">
			</div>
		</div>
		<div id="_idContainer142" class="Content">
			<h1 id="_idParaDest-234">12. <a id="_idTextAnchor283"/>Guide to Promises in TypeScript</h1>
		</div>
		<div id="_idContainer152" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter explores asynchronous programming in TypeScript using promises and discusses uses for asynchronous programming and how it is implemented in single-threaded JavaScript with the event loop. By the end of the chapter, you should have a solid understanding of how promises work and how TypeScript can enhance them. You will also be able to build a promise-based app using the concepts taught in this chapter.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor284"/>Introduction</h1>
			<p>In the previous chapter, we learned about asynchronous programming using callbacks. With this knowledge, we can manage concurrent requests and write non-blocking code that allows our applications to render web pages faster or serve concurrent requests on a Node.js server.</p>
			<p>In this chapter, we will learn how promises allow us to write more readable, concise code to better manage asynchronous processes and forever escape deep callback nesting, sometimes known as "callback hell." We will explore the evolution of the <strong class="source-inline">Promise</strong> object and how it eventually became part of the JavaScript language. We'll look at different transpilation targets for TypeScript and how TypeScript can enhance promises and allow developers to leverage generics to infer return types.</p>
			<p>We will work on some practical exercises, such as managing multiple API requests from a website and managing concurrency in Node.js. We will use the Node.js FileSystem API to perform asynchronous operations on files and see how powerful asynchronous programming can be.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor285"/>The Evolution of and Motivation for Promises</h1>
			<p>As we've learned, a callback is a function that is given as an argument to another function, in effect saying, "do this when you are done." This capability has been in JavaScript since its inception in 1995 and can work very well, but as the complexity of JavaScript applications grew through the 2000s, developers found callback patterns and nesting in particular to be too messy and unreadable, giving rise to complaints about "callback hell" as shown in the following example:</p>
			<p class="source-code">doSomething(function (err, data) {</p>
			<p class="source-code">  if(err) {</p>
			<p class="source-code">    console.error(err);</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    request(data.url, function (err, response) {</p>
			<p class="source-code">      if(err) {</p>
			<p class="source-code">        console.error(err);</p>
			<p class="source-code">      } else {</p>
			<p class="source-code">        doSomethingElse(response, function (err, data) {</p>
			<p class="source-code">          if(err) {</p>
			<p class="source-code">            console.error(err);</p>
			<p class="source-code">          } else {</p>
			<p class="source-code">            // ...and so it goes!</p>
			<p class="source-code">          }</p>
			<p class="source-code">        })</p>
			<p class="source-code">      }</p>
			<p class="source-code">    })</p>
			<p class="source-code">  }</p>
			<p class="source-code">});</p>
			<p>In addition to making code more readable and concise, promises have advantages beyond callbacks in that promises are objects that contain the state of the resolving asynchronous function. This means that a promise can be stored and either queried for the current state or called via its <strong class="source-inline">then()</strong> or <strong class="source-inline">catch()</strong> methods at any time to obtain the resolved state of the promise. We'll discuss those methods later in this chapter, but it's worth calling out at the beginning here that promises are more than syntactic sugar. They open up entirely new programming paradigms in which event handling logic can be decoupled from the event itself, just by storing the event in a promise.</p>
			<p>Promises are not unique to JavaScript but were first proposed as a computer programming concept in the 1970s. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information, refer to  Friedman, Daniel; David Wise (1976). <em class="italic">The Impact of Applicative Programming on Multiprocessing</em>. International Conference on Parallel Processing. pp. 263–272.</p>
			<p>As web frameworks gained popularity, proposals for promises started to appear in 2009 and libraries such as jQuery started implementing promise-like objects in 2011. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information, refer to the following: <a href="https://groups.google.com/g/commonjs/c/6T9z75fohDk">https://groups.google.com/g/commonjs/c/6T9z75fohDk</a> and <a href="https://api.jquery.com/category/version/1.5/">https://api.jquery.com/category/version/1.5/</a></p>
			<p>It wasn't long before Node.js started to have some promise libraries as well. Google's AngularJS bundled the Q library. All of these libraries wrapped callbacks in a higher-level API that appealed to developers and helped them to write cleaner and more readable code.</p>
			<p>In 2012, promises were proposed as an official specification in order to standardize the API. The specification was accepted in 2015 and has since been implemented in all major browsers as well as Node.js. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more details, refer to <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor">http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor</a>.</p>
			<p>"Promisification," the ability to wrap an existing asynchronous function in a promise, was added to many libraries and became part of the <strong class="source-inline">util</strong> package in the standard Node.js library as of version 8.0 (released in 2017).</p>
			<p>TypeScript, as a superset of JavaScript, will always support native language features such as promises; however, TypeScript does not provide polyfills, so if the target environment doesn't support native promises, a library is required.</p>
			<p>Most JavaScript runtimes (such as a web browser or Node.js server) are single-threaded execution environments. That means the main JavaScript process will only do one thing at a time. Thanks to the event loop, the runtime will seem like it's capable of doing many things at once as long as we write non-blocking code. The event loop recognizes asynchronous events and can turn to other tasks while it waits for those events to resolve.</p>
			<p>Consider the example of a web page that needs to call an API to load data into a table. If that API call were blocking, then that would mean the page render couldn't complete until the data loaded. Our user would have to stare at a blank page until all the data loaded and page elements rendered. But because of the event loop, we can register a listener that allows rendering of the website to continue and then load the table when our data is finally returned. This is visualized in the following figure:</p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B14508_12_01.jpg" alt="Figure 12.1: A typical event loop&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1: A typical event loop</p>
			<p>This can be implemented using callbacks or promises. The event loop is what makes this possible. Node.js works similarly, but now we may be responding to requests from a multitude of clients. In this simple example, three different requests are being made: </p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B14508_12_02.jpg" alt="Figure 12.2: Multiple requests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2: Multiple requests</p>
			<p>The API is not blocking so additional requests can come in even when the initial one has not been served. The requests are served in the order the work is completed.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor286"/>Anatomy of a Promise</h1>
			<p>A promise is a JavaScript object that can exist in three states: <em class="italic">pending</em>, <em class="italic">fulfilled</em>, or <em class="italic">rejected</em>. Although promises can be instantly fulfilled or rejected, it is most typical for a promise to be created in a pending state and then resolved to be fulfilled or rejected as an operation succeeds or fails. Promises are chainable and implement several convenience methods that we'll go into.</p>
			<p>To understand the states of a promise better, it's important to know that the states of a promise cannot be queried. As a programmer, we do not check the state of the promise and take action based on that state. Rather we provide a function callback that will be invoked when the promise reaches that state. For example, we make an HTTP request to our backend server and get a promise in response. Now we have set up our event and we merely need to tell the promise what to do next and how to handle any errors. Examples of this will follow.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor287"/>The Promise Callback</h2>
			<p>A promise can be instantiated using the <strong class="source-inline">new</strong> keyword and <strong class="source-inline">Promise</strong> constructor. When instantiated in this way, <strong class="source-inline">Promise</strong> expects a callback argument that contains the actual work to be done. The callback has two arguments of its own, <strong class="source-inline">resolve</strong> and <strong class="source-inline">reject</strong>. These arguments can be called explicitly to either resolve or reject the promise. For example, we can create a promise that resolves after 100 ms like this:</p>
			<p class="source-code">new Promise&lt;void&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">  setTimeout(() =&gt; resolve(), 100);</p>
			<p class="source-code">});</p>
			<p>We could also create a promise that rejects after 100 ms:</p>
			<p class="source-code">new Promise&lt;void&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">  setTimeout(() =&gt; reject(), 100);</p>
			<p class="source-code">});</p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor288"/>then and catch</h2>
			<p>Promises can be chained into callback functions of their own using <strong class="source-inline">then</strong> and <strong class="source-inline">catch</strong>. The callback function given to <strong class="source-inline">then</strong> will fire only once the promise is fulfilled and the callback function given to <strong class="source-inline">catch</strong> will only fire if the promise is rejected. Most libraries that return promises will automatically call <strong class="source-inline">resolve</strong> and <strong class="source-inline">reject</strong>, so we only need to provide <strong class="source-inline">then</strong> and <strong class="source-inline">catch</strong>. Here's an example using the Fetch API:</p>
			<p class="source-code">fetch("https://my-server.com/my-resource")</p>
			<p class="source-code">  .then(value =&gt; console.log(value))</p>
			<p class="source-code">  .catch(error =&gt; console.error(error));</p>
			<p>This code will make a call to our backend server and log out the result. If the call fails, it'll log that too.</p>
			<p>If this were a real application, we might have a couple of functions, <strong class="source-inline">showData</strong> and <strong class="source-inline">handleError</strong>, that could manage what our application does with the response from the server. In that case, the use of <strong class="source-inline">fetch</strong> would likely be something like this:</p>
			<p class="source-code">fetch("https://my-server.com/my-resource")</p>
			<p class="source-code">  .then(data =&gt; showData(data))</p>
			<p class="source-code">  .catch(error =&gt; handleError(error));</p>
			<p>Using promises like this shows how we can decouple our asynchronous processes from business logic and display elements.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor289"/>Pending State</h2>
			<p>A pending promise is one that has yet to complete its work. It's simple to create a promise that is forever stuck in a pending state:</p>
			<p class="source-code">const pendingPromise = new Promise((resolve, reject) =&gt; {});</p>
			<p class="source-code">console.log(pendingPromise);</p>
			<p>This promise will never do anything as neither <strong class="source-inline">resolve</strong> nor <strong class="source-inline">reject</strong> are ever called. The promise will remain in a pending state. If we execute this code, it'll print out <strong class="source-inline">Promise { &lt;pending&gt; }</strong>. As noted above, we do not query the state of a promise but rather provide a callback for the eventual resolution of a promise. The sample code above contains a promise that can never be resolved and as such could be seen as invalid code. There is no use case for promises that cannot resolve.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor290"/>Fulfilled State</h2>
			<p>We can create a promise that is fulfilled immediately:</p>
			<p class="source-code">const fulfilledPromise = new Promise(resolve =&gt; {</p>
			<p class="source-code">  resolve("fulfilled!");</p>
			<p class="source-code">});</p>
			<p class="source-code">console.log(fulfilledPromise);</p>
			<p>This will log out <strong class="source-inline">Promise { 'fulfilled!' }</strong>. </p>
			<p>Unlike the pending state, creating a promise that resolves immediately has a few more practical use cases. The primary use of an immediately resolved promise would be when working with an API that expects a promise. </p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor291"/>Rejected State</h2>
			<p>We can create a promise that is fulfilled immediately:</p>
			<p class="source-code">const rejectedPromise = new Promise((resolve, reject) =&gt; {</p>
			<p class="source-code">  reject("rejected!");</p>
			<p class="source-code">});</p>
			<p class="source-code">console.log(rejectedPromise);</p>
			<p>This will log out <strong class="source-inline">Promise { &lt;rejected&gt; 'rejected!' }</strong> and then throw an unhandled promise rejection warning. Rejected promises always need to be caught. Failure to catch a promise rejection may cause our program to crash!</p>
			<p>As with the fulfilled state, the primary use case for immediately rejecting a promise would be for writing a good unit test, but there may be secondary use cases in which some process throws an error during an asynchronous workflow and it may make sense to return a rejected promise. This circumstance would be most likely when working with a third-party library where the API isn't quite to our liking and we need to wrap it with something more in line with the rest of our application architecture.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor292"/>Chaining</h2>
			<p>One of the main advantages of promises over callbacks is the ability to chain promises together. Consider a function that waits 1 second, generates a random number between 0 and 99, and adds it to the previous result. There are better ways to write recursive functions, but this is meant to simulate a website making several calls to a backend:</p>
			<p class="source-code-heading">Example01.ts</p>
			<p class="source-code">1  const getTheValue = async (val: number, cb: Function) =&gt; {</p>
			<p class="source-code">2    setTimeout(() =&gt; {</p>
			<p class="source-code">3      const number = Math.floor(Math.random() * 100) + val;</p>
			<p class="source-code">4      console.log(`The value is ${number}`);</p>
			<p class="source-code">5      cb(number);</p>
			<p class="source-code">6    }, 1000);</p>
			<p class="source-code">7  };</p>
			<p class="source-code">8  </p>
			<p class="source-code">9  getTheValue(0, (output: number) =&gt; {</p>
			<p class="source-code">10    getTheValue(output, (output: number) =&gt; {</p>
			<p class="source-code">11      getTheValue(output, (output: number) =&gt; {</p>
			<p class="source-code">12        getTheValue(output, (output: number) =&gt; {</p>
			<p class="source-code">13          getTheValue(output, (output: number) =&gt; {</p>
			<p class="source-code">14            getTheValue(output, (output: number) =&gt; {</p>
			<p class="source-code">15              getTheValue(output, (output: number) =&gt; {</p>
			<p class="source-code">16                getTheValue(output, (output: number) =&gt; {</p>
			<p class="source-code">17                  getTheValue(output, (output: number) =&gt; {</p>
			<p class="source-code">18                    getTheValue(output, () =&gt; {});</p>
			<p class="source-code">19                  });</p>
			<p class="source-code">20                });</p>
			<p class="source-code">21              });</p>
			<p class="source-code">22            });</p>
			<p class="source-code">23          });</p>
			<p class="source-code">24        });</p>
			<p class="source-code">25      });</p>
			<p class="source-code">26    });</p>
			<p class="source-code">27  });</p>
			<p class="source-code-link">Link to the example: <a href="https://packt.link/VHZJc">https://packt.link/VHZJc</a></p>
			<p>A sample output of this program is the following:</p>
			<p class="source-code">The value is 49</p>
			<p class="source-code">The value is 133</p>
			<p class="source-code">The value is 206</p>
			<p class="source-code">The value is 302</p>
			<p class="source-code">The value is 395</p>
			<p class="source-code">The value is 444</p>
			<p class="source-code">The value is 469</p>
			<p class="source-code">The value is 485</p>
			<p class="source-code">The value is 528</p>
			<p class="source-code">The value is 615</p>
			<p>Each time we call <strong class="source-inline">getTheValue</strong>, we wait 1 second, then generate a random number and add it to the value we passed in. In a real-world scenario, we can think of this as a program that completes several asynchronous tasks, using the output from the last one as input to the next. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">As the starting point of the program is a random number, your output would be different from the one presented above.</p>
			<p>Everything in the previous program works correctly; however, the callback nesting isn't very nice to look at and could be challenging to maintain or debug. The next exercise will teach you how you can write more readable and maintainable code using promises.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor293"/>Exercise 12.01: Chaining Promises</h2>
			<p>In this exercise, we will refactor the preceding example and chain promises to eliminate nesting and make the code more readable:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/IO8Pz">https://packt.link/IO8Pz</a>.</p>
			<ol>
				<li>Write the following program, which refactors the previous example using promises:<p class="source-code">const getTheValue = async (val: number): Promise&lt;number&gt; =&gt; {</p><p class="source-code">  return new Promise(resolve =&gt; {</p><p class="source-code">    setTimeout(() =&gt; {</p><p class="source-code">      const number = Math.floor(Math.random() * 100) + val;</p><p class="source-code">      console.log(`The value is ${number}`);</p><p class="source-code">      resolve(number);</p><p class="source-code">    }, 1000);</p><p class="source-code">  });</p><p class="source-code">};</p><p class="source-code">getTheValue(0)</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result))</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result))</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result))</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result))</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result))</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result))</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result))</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result))</p><p class="source-code">  .then((result: number) =&gt; getTheValue(result));</p><p>The nesting is gone and the code is a lot more readable. Our <strong class="source-inline">getTheValue</strong> function now returns a promise instead of using a callback. Because it returns a promise, we can call <strong class="source-inline">.then()</strong> on the promise, which can be chained into another promise call. </p></li>
				<li>Run the program. The chain of promises will resolve each in turn and we'll get similar output to the previous program:<p class="source-code">The value is 50</p><p class="source-code">The value is 140</p><p class="source-code">The value is 203</p><p class="source-code">The value is 234</p><p class="source-code">The value is 255</p><p class="source-code">The value is 300</p><p class="source-code">The value is 355</p><p class="source-code">The value is 395</p><p class="source-code">The value is 432</p><p class="source-code">The value is 451</p><p>Note that you will get an output that is different from the one shown above because the program uses a random number as the starting point.</p></li>
			</ol>
			<p>Chaining can also be a big help when it comes to error conditions. If my <strong class="source-inline">getTheValue</strong> function rejects the promise, I'm able to catch the error by chaining a single <strong class="source-inline">catch</strong> to the end of the chain:</p>
			<p class="source-code-heading">Example02.ts</p>
			<p class="source-code">1  const getTheValue = async (val: number): Promise&lt;number&gt; =&gt; {</p>
			<p class="source-code">2   return new Promise((resolve, reject) =&gt; {</p>
			<p class="source-code">3      setTimeout(() =&gt; {</p>
			<p class="source-code">4        const number = Math.floor(Math.random() * 100) + val;</p>
			<p class="source-code">5        if (number % 10 === 0) {</p>
			<p class="source-code">6          reject("Bad modulus!");</p>
			<p class="source-code">7        } else {</p>
			<p class="source-code">8          console.log(`The value is ${number}`);</p>
			<p class="source-code">9          resolve(number);</p>
			<p class="source-code">10        }</p>
			<p class="source-code">11      }, 1000);</p>
			<p class="source-code">12    });</p>
			<p class="source-code">13  };</p>
			<p class="source-code">14  </p>
			<p class="source-code">15  getTheValue(0)</p>
			<p class="source-code">16    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">17    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">18    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">19    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">20    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">21    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">22    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">23    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">24    .then((result: number) =&gt; getTheValue(result))</p>
			<p class="source-code">25    .catch(err =&gt; console.error(err));</p>
			<p class="source-code-link">Link to the example: <a href="https://packt.link/sBTgk">https://packt.link/sBTgk</a></p>
			<p>We are introducing a 10% chance (the chance our number when divided by 10 will have a remainder of 0) of throwing an error on each iteration. On average, our program will fail more often than it executes successfully now:</p>
			<p class="source-code">The value is 25</p>
			<p class="source-code">The value is 63</p>
			<p class="source-code">The value is 111</p>
			<p class="source-code">Bad modulus!</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor294"/>finally</h2>
			<p>In addition to <strong class="source-inline">then</strong> and <strong class="source-inline">catch</strong> methods, the <strong class="source-inline">Promise</strong> object also exposes a <strong class="source-inline">finally</strong> method. This is a callback function that will be called regardless of whether an error is thrown or caught. It's great for logging, closing a database connection, or simply cleaning up resources, regardless of how the promise is eventually resolved.</p>
			<p>We can add a <strong class="source-inline">finally</strong> callback to the above promise:</p>
			<p class="source-code-heading">Example03.ts</p>
			<p class="source-code">1  const getTheValue = async (val: number) =&gt; {</p>
			<p class="source-code">2    return new Promise&lt;number&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">3      setTimeout(() =&gt; {</p>
			<p class="source-code">4        const number = Math.floor(Math.random() * 100) + val;</p>
			<p class="source-code">5        if (number % 10 === 0) {</p>
			<p class="source-code">6          reject("Bad modulus!");</p>
			<p class="source-code">7        } else {</p>
			<p class="source-code">8          console.log(`The value is ${number}`);</p>
			<p class="source-code">9          resolve(number);</p>
			<p class="source-code">10      }</p>
			<p class="source-code">11     }, 1000);</p>
			<p class="source-code">12   });</p>
			<p class="source-code">13 };</p>
			<p class="source-code">14 </p>
			<p class="source-code">15 getTheValue(0)</p>
			<p class="source-code">16   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">17   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">18   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">19   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">20   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">21   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">22   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">23   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">24   .then(result =&gt; getTheValue(result))</p>
			<p class="source-code">25   .catch(err =&gt; console.error(err))</p>
			<p class="source-code">26   .finally(() =&gt; console.log("We are done!"));</p>
			<p class="source-code-link">Link to the example: <a href="https://packt.link/izqwS">https://packt.link/izqwS</a></p>
			<p>Now <strong class="source-inline">"We are done!"</strong> will be logged regardless of whether or not we trip the <strong class="source-inline">"Bad modulus!"</strong> error condition:</p>
			<p class="source-code">The value is 69</p>
			<p class="source-code">The value is 99</p>
			<p class="source-code">Bad modulus!</p>
			<p class="source-code">We are done!</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor295"/>Promise.all</h2>
			<p><strong class="source-inline">Promise.all</strong> is one of the most useful utility methods that <strong class="source-inline">Promise</strong> has to offer. Even code written with async/await syntax (see <em class="italic">Chapter 13, Async/Await</em>) can make good use of <strong class="source-inline">Promise.all</strong>. This method takes an iterable (likely an array) of promises as an argument and resolves all of them. Let's see how we can change our example promise using <strong class="source-inline">Promise.all</strong>:</p>
			<p class="source-code-heading">Example04.ts</p>
			<p class="source-code">1  const getTheValue = async (val: number = 0) =&gt; {</p>
			<p class="source-code">2    return new Promise&lt;number&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">3      setTimeout(() =&gt; {</p>
			<p class="source-code">4        const number = Math.floor(Math.random() * 100) + val;</p>
			<p class="source-code">5        if (number % 10 === 0) {</p>
			<p class="source-code">6          reject("Bad modulus!");</p>
			<p class="source-code">7        } else {</p>
			<p class="source-code">8          console.log(`The value is ${number}`);</p>
			<p class="source-code">9          resolve(number);</p>
			<p class="source-code">10       }</p>
			<p class="source-code">11     }, 1000);</p>
			<p class="source-code">12   });</p>
			<p class="source-code">13 };</p>
			<p class="source-code">14</p>
			<p class="source-code">15 Promise.all([</p>
			<p class="source-code">16   getTheValue(),</p>
			<p class="source-code">17   getTheValue(),</p>
			<p class="source-code">18   getTheValue(),</p>
			<p class="source-code">19   getTheValue(),</p>
			<p class="source-code">20   getTheValue(),</p>
			<p class="source-code">21   getTheValue(),</p>
			<p class="source-code">22   getTheValue(),</p>
			<p class="source-code">23   getTheValue(),</p>
			<p class="source-code">24   getTheValue(),</p>
			<p class="source-code">25   getTheValue()</p>
			<p class="source-code">26 ])</p>
			<p class="source-code">27   .then(values =&gt;</p>
			<p class="source-code">28     console.log(</p>
			<p class="source-code">29       `The total is ${values.reduce((prev, current) =&gt; prev + current, 0)}`</p>
			<p class="source-code">30     )</p>
			<p class="source-code">31   )</p>
			<p class="source-code">32   .catch(err =&gt; console.error(err))</p>
			<p class="source-code">33   .finally(() =&gt; console.log("We are done!"));</p>
			<p class="source-code-link">Link to the example: <a href="https://packt.link/8pzx4">https://packt.link/8pzx4</a></p>
			<p>The output should be similar to the ones obtained for the preceding examples. In this example, we call the same function 10 times, but imagine these are 10 different API calls we need to reach and then sum the total. Each call takes approximately 1 second. If we chain a series of promises, this operation will take just over 10 seconds. By using <strong class="source-inline">Promise.all</strong>, we are able to run those operations in parallel and now it takes only 1 second to complete the function.</p>
			<p><strong class="source-inline">Promise.all</strong> is useful any time you can run two or more asynchronous processes in parallel. It can be useful for persisting data to multiple database tables, letting multiple independent components render in a web browser independently, or making multiple HTTP requests. A good example of making multiple HTTP requests in parallel would be a service that monitors the uptime and ping duration of other services. There's no reason such an operation would need to be synchronous and <strong class="source-inline">Promise.all</strong> lets us wait on several web requests within the same process.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor296"/>Exercise 12.02: Recursive Promise.all</h2>
			<p>In this exercise, instead of repeating the same function call 10 times, let's optimize the programs from the previous examples to be more DRY (don't repeat yourself). We can load up an array of promises and then use <strong class="source-inline">Promise.all</strong> to resolve all the promises in parallel and use <strong class="source-inline">catch</strong> and <strong class="source-inline">finally</strong> to resolve errors and ensure we return some output:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/KNpqx">https://packt.link/KNpqx</a>.</p>
			<ol>
				<li value="1">The following code will be our starting place for this refactor:<p class="source-code">const getTheValue = async (val: number = 0) =&gt; {</p><p class="source-code">  return new Promise&lt;number&gt;((resolve, reject) =&gt; {</p><p class="source-code">    setTimeout(() =&gt; {</p><p class="source-code">      const number = Math.floor(Math.random() * 100) + val;</p><p class="source-code">      if (number % 10 === 0) {</p><p class="source-code">        reject('Bad modulus!');</p><p class="source-code">      } else {</p><p class="source-code">        console.log(`The value is ${number}`);</p><p class="source-code">        resolve(number);</p><p class="source-code">      }</p><p class="source-code">    }, 1000);</p><p class="source-code">  });</p><p class="source-code">};</p><p class="source-code">Promise.all([</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">  getTheValue(),</p><p class="source-code">])</p><p class="source-code">  .then((values) =&gt;</p><p class="source-code">    console.log(</p><p class="source-code">      `The total is ${values.reduce((prev, current) =&gt; prev + current, 0)}`</p><p class="source-code">    )</p><p class="source-code">  )</p><p class="source-code">  .catch((err) =&gt; console.error(err))</p><p class="source-code">  .finally(() =&gt; console.log('We are done!'));</p><p>In order to catch errors and make the program recursive, we'll need to wrap <strong class="source-inline">Promise.all</strong> in a function. Recursion is a pattern in which the same function can be called multiple times within the same execution. </p></li>
				<li>To add the recursion, create a new function and make the <strong class="source-inline">Promise.all</strong> statement the body of that function. Then call the function:<p class="source-code">const doIt = () =&gt; {</p><p class="source-code">  Promise.all([</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">    getTheValue(),</p><p class="source-code">])</p><p class="source-code">  .then((values) =&gt;</p><p class="source-code">      console.log(</p><p class="source-code">        `The total is ${values.reduce((prev, current) =&gt; prev + current, 0)}`</p><p class="source-code">      )</p><p class="source-code">  )</p><p class="source-code">  .catch((err) =&gt; console.error(err))</p><p class="source-code">  .finally(() =&gt; console.log('We are done!'));</p><p>We can use some functional programming techniques to, rather than having an array in which <strong class="source-inline">getTheValue()</strong> is repeated 10 times, programmatically construct an array of 10 elements, all of which are that function call. Doing this won't change how our program operates, but it will make it a bit nicer to work with. </p></li>
				<li>Update the code given in the preceding step with the following:<p class="source-code">  Promise.all(</p><p class="source-code">  Array(10)</p><p class="source-code">    .fill(null)</p><p class="source-code">    .map(() =&gt; getTheValue())</p><p class="source-code">)</p><p>The logic here is that <strong class="source-inline">Array(10)</strong> creates a new array of 10 elements, <strong class="source-inline">fill(null)</strong> will initialize the array, then <strong class="source-inline">map</strong> will remap the array elements to be the <strong class="source-inline">getTheValue()</strong> function call. </p><p>Th above code actually calls the function and returns the pending promise to the array that is already wrapped in <strong class="source-inline">Promise.all</strong>.</p><p>Now we want to use recursion in the case of an error. We will change our <strong class="source-inline">catch()</strong> callback from simply logging the error to starting the process over again. In this case, our business rule is we want the entire set of calculations to complete and we will restart if there is an error. The code to do this is very easy as <strong class="source-inline">catch()</strong> expects a function as its callback so we can just pass our <strong class="source-inline">doIt</strong> function back to it again.</p></li>
				<li>Pass the <strong class="source-inline">doIt</strong> function back to <strong class="source-inline">catch()</strong>:<p class="source-code">  .catch(doIt)</p><p>Note that we do not invoke the callback function here. We want to pass a function and it will be invoked in the case of an error.</p></li>
				<li>We will now want to clean up our error messages a little so we can have a clean run:<p class="source-code">const getTheValue = async (val: number = 0) =&gt; {</p><p class="source-code">  return new Promise&lt;number&gt;((resolve, reject) =&gt; {</p><p class="source-code">    setTimeout(() =&gt; {</p><p class="source-code">      const number = Math.floor(Math.random() * 100) + val;</p><p class="source-code">      if (number % 10 === 0) {</p><p class="source-code">        reject('Bad modulus!');</p><p class="source-code">      } else {</p><p class="source-code">        // console.log(`The value is ${number}`);</p><p class="source-code">        resolve(number);</p><p class="source-code">      }</p><p class="source-code">    }, 1000);</p><p class="source-code">  });</p><p class="source-code">};</p><p class="source-code">let loopCount = 0;</p><p class="source-code">const doIt = () =&gt; {</p><p class="source-code">  Promise.all(</p><p class="source-code">    Array(10)</p><p class="source-code">      .fill(null)</p><p class="source-code">      .map(() =&gt; getTheValue())</p><p class="source-code">  )</p><p class="source-code">    .then((values) =&gt;</p><p class="source-code">      console.log(</p><p class="source-code">        `The total is ${values.reduce((prev, current) =&gt; prev + current, 0)}`</p><p class="source-code">      )</p><p class="source-code">    )</p><p class="source-code">    .catch(doIt)</p><p class="source-code">    .finally(() =&gt; console.log(`completed loop ${++loopCount}`));</p><p class="source-code">};</p><p class="source-code">doIt();</p><p>When we run the program, we'll see a few iterations of the program looping. The output may be something like this:</p><p class="source-code">completed loop 1</p><p class="source-code">The total is 438</p><p class="source-code">completed loop 2</p><p>Note that depending on the number of iterations, you might get an output different from the one shown above.</p></li>
			</ol>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor297"/>Promise.allSettled</h2>
			<p>This method is a variation on <strong class="source-inline">Promise.all</strong>, which is ideal for when it's acceptable for some of our promises to resolve successfully and some of them to be rejected. Let's see how it's different from <strong class="source-inline">Promise.all</strong>:</p>
			<p class="source-code">const getTheValue = async (val: number = 0) =&gt; {</p>
			<p class="source-code">  return new Promise&lt;number&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">    setTimeout(() =&gt; {</p>
			<p class="source-code">      const number = Math.floor(Math.random() * 100) + val;</p>
			<p class="source-code">      // Arbitrary error condition - if the random number is divisible by 10.</p>
			<p class="source-code">      if (number % 10 === 0) {</p>
			<p class="source-code">        reject("Bad modulus!");</p>
			<p class="source-code">      } else {</p>
			<p class="source-code">        console.log(`The value is ${number}`);</p>
			<p class="source-code">        resolve(number);</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }, 1000);</p>
			<p class="source-code">  });</p>
			<p class="source-code">};</p>
			<p class="source-code">const generateTheNumber = (iterations: number): void =&gt; {</p>
			<p class="source-code">  Promise.allSettled(</p>
			<p class="source-code">    // Produces an array of `iterations` length with the pending promises of `getTheValue()`.</p>
			<p class="source-code">    Array(iterations)</p>
			<p class="source-code">      .fill(null)</p>
			<p class="source-code">      .map(() =&gt; getTheValue())</p>
			<p class="source-code">  )</p>
			<p class="source-code">    .then((settledResults) =&gt; {</p>
			<p class="source-code">      // Map all the results into the failed, succeeded and total values.</p>
			<p class="source-code">      const results = settledResults.reduce(</p>
			<p class="source-code">        (prev, current) =&gt; {</p>
			<p class="source-code">          return current.status === "fulfilled"</p>
			<p class="source-code">            ? {</p>
			<p class="source-code">                ...prev,</p>
			<p class="source-code">                succeeded: prev.succeeded + 1,</p>
			<p class="source-code">                total: prev.total + current.value,</p>
			<p class="source-code">              }</p>
			<p class="source-code">            : { ...prev, failed: prev.failed + 1 };</p>
			<p class="source-code">        },</p>
			<p class="source-code">        {</p>
			<p class="source-code">          failed: 0,</p>
			<p class="source-code">          succeeded: 0,</p>
			<p class="source-code">          total: 0,</p>
			<p class="source-code">        }</p>
			<p class="source-code">      );</p>
			<p class="source-code">      console.log(results);</p>
			<p class="source-code">    })</p>
			<p class="source-code">    .finally(() =&gt; console.log("We are done!"));</p>
			<p class="source-code">};</p>
			<p class="source-code">generateTheNumber(10);</p>
			<p>The program will generate output like this:</p>
			<p class="source-code">current { status: 'fulfilled', value: 85 }</p>
			<p class="source-code">current { status: 'fulfilled', value: 25 }</p>
			<p class="source-code">current { status: 'fulfilled', value: 11 }</p>
			<p class="source-code">current { status: 'fulfilled', value: 43 }</p>
			<p class="source-code">current { status: 'rejected', reason: 'Bad modulus!' }</p>
			<p class="source-code">current { status: 'fulfilled', value: 41 }</p>
			<p class="source-code">current { status: 'fulfilled', value: 81 }</p>
			<p class="source-code">current { status: 'rejected', reason: 'Bad modulus!' }</p>
			<p class="source-code">current { status: 'rejected', reason: 'Bad modulus!' }</p>
			<p class="source-code">current { status: 'fulfilled', value: 7 }</p>
			<p class="source-code">{ failed: 3, succeeded: 7, total: 293 } </p>
			<p class="source-code">We are done!</p>
			<p>We've made a couple of enhancements here. For one thing, we are now passing the array size into <strong class="source-inline">generateTheNumber</strong>, which can give a bit more flavor or variation to our program. The main improvement now is the use of <strong class="source-inline">Promise.allSettled</strong>. Now, <strong class="source-inline">Promise.allSettled</strong> allows us to have a mix of successes and failures, unlike <strong class="source-inline">Promise.all</strong>, which will call the <strong class="source-inline">then()</strong> method if all the promises resolve successfully or call the <strong class="source-inline">catch()</strong> method if any of them fail. The output of <strong class="source-inline">Promise.allSettled</strong> could look something like this:</p>
			<p class="source-code">settledResults [</p>
			<p class="source-code">  { status: 'fulfilled', value: 85 },</p>
			<p class="source-code">  { status: 'fulfilled', value: 25 },</p>
			<p class="source-code">  { status: 'fulfilled', value: 11 },</p>
			<p class="source-code">  { status: 'fulfilled', value: 43 },</p>
			<p class="source-code">  { status: 'rejected', reason: 'Bad modulus!' },</p>
			<p class="source-code">  { status: 'fulfilled', value: 41 },</p>
			<p class="source-code">  { status: 'fulfilled', value: 81 },</p>
			<p class="source-code">  { status: 'rejected', reason: 'Bad modulus!' },</p>
			<p class="source-code">  { status: 'rejected', reason: 'Bad modulus!' },</p>
			<p class="source-code">  { status: 'fulfilled', value: 7 }</p>
			<p class="source-code">]</p>
			<p>Each of the resolved promises will have a status containing the string <strong class="source-inline">'fulfilled'</strong> if the promise resolved successfully or <strong class="source-inline">'rejected'</strong> if there was an error. Fulfilled promises will have a <strong class="source-inline">value</strong> property containing the value the promise resolved to and rejected promises will have a <strong class="source-inline">reason</strong> property containing the error.</p>
			<p>In the example given, we are totaling the rejected promises and summing the values of the fulfilled promises, then returning that as a new object. To perform this operation, we use the built-in array function <strong class="source-inline">reduce()</strong>. Now, <strong class="source-inline">reduce()</strong> will iterate over each element of an array and collect transformed results in an accumulator, which is returned by the function. <strong class="source-inline">MapReduce</strong> functions are common in functional programming paradigms.</p>
			<p>Note that <strong class="source-inline">Promise.allSettled</strong> is a fairly recent addition to ECMAScript, having landed in Node.js 12.9. In order to use it, you'll need to set your <strong class="source-inline">compilerOptions</strong> target to <strong class="source-inline">es2020</strong> or <strong class="source-inline">esnext</strong> in your <strong class="source-inline">tsconfig.json</strong> file. Most modern browsers support this method, but it's a good idea to verify support before using this recent feature.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor298"/>Exercise 12.03: Promise.allSettled</h2>
			<p>We've seen an example of using <strong class="source-inline">Promise.allSettled</strong> to produce a mixed result of fulfilled and rejected promises. Now let's combine <strong class="source-inline">Promise.allSettled</strong> and <strong class="source-inline">Promise.all</strong> to aggregate multiple results of our runs of <strong class="source-inline">getTheValue()</strong>:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/D8jIQ">https://packt.link/D8jIQ</a>.</p>
			<ol>
				<li value="1">Start with the code from the example above. We are going to want to call <strong class="source-inline">generateTheNumber()</strong> three times. Once we have all the results, we can sort them to print out the highest and lowest results. We can use the same <strong class="source-inline">Array().fill().map()</strong> technique described above to create a new array of <strong class="source-inline">generateTheNumber()</strong> calls:<p class="source-code">Promise.all(</p><p class="source-code">  Array(3)</p><p class="source-code">    .fill(null)</p><p class="source-code">    .map(() =&gt; generateTheNumber(10))</p><p class="source-code">);</p></li>
				<li>Now that we can resolve three separate calls, we need to manage the output. First, we can log out the results to see what we need to do next:<p class="source-code">Promise.all(</p><p class="source-code">  Array(3)</p><p class="source-code">    .fill(null)</p><p class="source-code">    .map(() =&gt; generateTheNumber(10))</p><p class="source-code">).then((result) =&gt; console.log(result));</p><p>We log out <strong class="source-inline">[undefined, undefined, undefined]</strong>. That's not what we wanted. The reason for this is <strong class="source-inline">generateTheNumber</strong> doesn't actually return its promise – it didn't need to in the prior example. </p></li>
				<li>We can fix that by adding a <strong class="source-inline">return</strong> statement and removing the <strong class="source-inline">void</strong> return type. We also need our callback function to return the results instead of simply logging them out. All these changes would help a program like this integrate into a larger application:<p class="source-code">const generateTheNumber = (iterations: number) =&gt; {</p><p class="source-code">  return Promise.allSettled(</p><p class="source-code">    Array(iterations)</p><p class="source-code">      .fill(null)</p><p class="source-code">      .map(() =&gt; getTheValue())</p><p class="source-code">  )</p><p class="source-code">    .then((settledResults) =&gt; {</p><p class="source-code">      const results = settledResults.reduce(</p><p class="source-code">        (prev, current) =&gt; {</p><p class="source-code">          return current.status === 'fulfilled'</p><p class="source-code">            ? {</p><p class="source-code">                ...prev,</p><p class="source-code">                succeeded: prev.succeeded + 1,</p><p class="source-code">                total: prev.total + current.value,</p><p class="source-code">              }</p><p class="source-code">            : { ...prev, failed: prev.failed + 1 };</p><p class="source-code">        },</p><p class="source-code">        {</p><p class="source-code">          failed: 0,</p><p class="source-code">          succeeded: 0,</p><p class="source-code">          total: 0,</p><p class="source-code">        }</p><p class="source-code">      );</p><p class="source-code">      return results;</p><p class="source-code">    })</p><p class="source-code">    .finally(() =&gt; console.log('Iteration done!'));</p><p class="source-code">};</p><p class="source-code">With that done we can get our output.</p><p class="source-code">[</p><p class="source-code">  { failed: 0, succeeded: 10, total: 443 },</p><p class="source-code">  { failed: 1, succeeded: 9, total: 424 },</p><p class="source-code">  { failed: 2, succeeded: 8, total: 413 },</p><p class="source-code">]</p></li>
				<li>The last step to complete this exercise is we only want to output the highest and lowest totals. To accomplish this, we can use the <strong class="source-inline">Array.map()</strong> function to extract only the totals from the output and the <strong class="source-inline">Array.sort()</strong> function to order the above output from lowest to highest, then print the totals from the first and last entries:<p class="source-code">  const totals = results.map((r) =&gt; r.total).sort();</p><p class="source-code">  console.log(`The highest total is ${totals[totals.length - 1]}.`);</p><p class="source-code">  console.log(`The lowest total is ${totals[0]}.`);</p><p>You might get an output similar to the following:</p><p class="source-code">The value is 62</p><p class="source-code">The value is 77</p><p class="source-code">The value is 75</p><p class="source-code">The value is 61</p><p class="source-code">The value is 61</p><p class="source-code">The value is 61</p><p class="source-code">The value is 15</p><p class="source-code">The value is 83</p><p class="source-code">The value is 4</p><p class="source-code">The value is 23</p><p class="source-code">Iteration done!</p><p class="source-code">.</p><p class="source-code">.</p><p class="source-code">.</p><p class="source-code">The highest total is 522.</p><p class="source-code">The lowest total is 401.</p><p>Note that only a section of the actual output is displayed for ease of presentation. </p><p>This exercise showed us how we can filter and sort the results of many promises and create data structures that accurately reflect the state of our application.</p></li>
			</ol>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor299"/>Promise.any</h2>
			<p>At the other end of the spectrum from <strong class="source-inline">Promise.allSettled</strong> lies <strong class="source-inline">Promise.any</strong>. This method takes an iterable (or array) of promises, but instead of settling all of them, it will resolve to the value of the first promise that resolves successfully. <strong class="source-inline">Promise.any</strong> is so new it has yet to be implemented in every browser and at the time of writing is not available in the LTS version of Node.js. You should check compatibility and availability before using it.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor300"/>Promise.race</h2>
			<p><strong class="source-inline">Promise.race</strong> has been around for some time and is similar to <strong class="source-inline">Promise.any</strong>. Now, <strong class="source-inline">Promise.race</strong> again takes an iterable of promises and executes them all. The first promise that resolves or rejects will resolve or reject the race. This is in contrast to <strong class="source-inline">Promise.any</strong> in that if the first promise in <strong class="source-inline">Promise.any</strong> rejects, the other promises still have an opportunity to resolve successfully:</p>
			<p class="source-code">const oneSecond = new Promise((_resolve, reject) =&gt; {</p>
			<p class="source-code">  setTimeout(() =&gt; reject("Too slow!"), 1000);</p>
			<p class="source-code">});</p>
			<p class="source-code">const upToTwoSeconds = new Promise(resolve =&gt; {</p>
			<p class="source-code">  setTimeout(() =&gt; resolve("Made it!"), Math.random() * 2000);</p>
			<p class="source-code">});</p>
			<p class="source-code">Promise.race([oneSecond, upToTwoSeconds])</p>
			<p class="source-code">  .then(result =&gt; console.log(result))</p>
			<p class="source-code">  .catch(err =&gt; console.error(err));</p>
			<p>In this example, one promise always rejects in 1 second while the other resolves at a random interval between 0 and 2 seconds. If the <strong class="source-inline">oneSecond</strong> promise wins the race, the entire promise is rejected. If <strong class="source-inline">upToTwoSeconds</strong> takes less than a second, then the promise resolves successfully with the message <strong class="source-inline">"Made It!"</strong>.</p>
			<p>A practical example of using <strong class="source-inline">Promise.race</strong> might be a timeout and fallback feature where if the primary web service can't respond within an expected amount of time, the application either switches to a secondary source for data or exhibits some other behavior. Or perhaps we want to deal with a slow render issue in a web browser where if a screen paint hasn't finished in the expected amount of time, we switch to a simpler view. There are lots of cases where <strong class="source-inline">Promise.race</strong> can ease the complexity of handling asynchronous operations in TypeScript.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor301"/>Enhancing Promises with Types</h1>
			<p>The example we're working with so far specifies the type of input to the promise, but we have to provide a type for the result in each step of the chain. That's because TypeScript doesn't know what the promise may resolve to so we have to tell it what kind of type we're getting as the result.</p>
			<p>In other words, we're missing out on one of TypeScript's most powerful features: <em class="italic">type inference</em>. Type inference is the ability for TypeScript to know what the type of something should be without having to be told. A very simple example of type inference would be the following:</p>
			<p class="source-code">const hello = "hello";</p>
			<p>No type is specified. This is because TypeScript understands that the variable <strong class="source-inline">hello</strong> is being assigned a string and cannot be reassigned. If we try to pass this variable as an argument to a function that expects another type, we will get a compilation error, even though we never specified the type. Let's apply type inference to promises.</p>
			<p>First, let's look at the type definition for the <strong class="source-inline">Promise</strong> object:</p>
			<p class="source-code">new &lt;T&gt;(executor: (resolve: (value?: T | PromiseLike&lt;T&gt;) =&gt; void, reject: (reason?: any) =&gt; void) =&gt; void): Promise&lt;T&gt;;</p>
			<p><strong class="source-inline">T</strong> is what's known as a generic. It means any type can be specified to take the place of <strong class="source-inline">T</strong>. Let's say we define a promise like this:</p>
			<p class="source-code">new Promise(resolve =&gt; {</p>
			<p class="source-code">  resolve("This resolves!");</p>
			<p class="source-code">});</p>
			<p>What we're doing here is stating the <strong class="source-inline">resolve</strong> argument will resolve to an unknown type. The receiving code will need to provide a type for it. This can be improved by adding a type value for <strong class="source-inline">T</strong>:</p>
			<p class="source-code">new Promise&lt;string&gt;(resolve =&gt; {</p>
			<p class="source-code">  resolve("This resolves!");</p>
			<p class="source-code">});</p>
			<p>Now the promise constructor resolves to a type of <strong class="source-inline">Promise&lt;string&gt;</strong>. When the promise becomes fulfilled, it is expected to return a type of <strong class="source-inline">string</strong>.</p>
			<p>Let's examine an example where casting the return type of a promise becomes important:</p>
			<p class="source-code">const getPromise = async () =&gt; new Promise(resolve =&gt; resolve(Math.ceil(Math.random() * 100)));</p>
			<p class="source-code">const printResult = (result: number) =&gt; console.log(result);</p>
			<p class="source-code">getPromise().then(result =&gt; printResult(result)); </p>
			<p>If you put this example into an IDE such as VS Code, you'll see that you have a type error on the <strong class="source-inline">result</strong> parameter given to <strong class="source-inline">printResult</strong>. The type that the promise returned by <strong class="source-inline">getPromise</strong> is unknown but <strong class="source-inline">printResult</strong> expects <strong class="source-inline">number</strong>. We can fix this problem by providing a type to the promise when we declare it:</p>
			<p class="source-code">const getPromise = async () =&gt; new Promise&lt;number&gt;(resolve =&gt; resolve(Math.ceil(Math.random() * 100)));</p>
			<p class="source-code">const printResult = (result: number) =&gt; console.log(result);</p>
			<p class="source-code">getPromise().then(result =&gt; printResult(result));</p>
			<p>We have added <strong class="source-inline">&lt;number&gt;</strong> immediately after our promise declaration and TypeScript knows this promise is expected to resolve to a number. This type-checking will also be applied to the resolution of our promise. For example, if we tried to resolve to a value of <strong class="source-inline">"Hello!"</strong>, we'd get another type error now that our promise is expected to return a number.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor302"/>Exercise 12.04: Asynchronous Rendering</h2>
			<p>In this exercise, we'll create a simple website with synchronous rendering and refactor it so the rendering is asynchronous: </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/q8rka">https://packt.link/q8rka</a>.</p>
			<ol>
				<li value="1">Clone the project from GitHub (<a href="https://packt.link/q8rka">https://packt.link/q8rka</a>) to begin. Then, install dependencies:<p class="source-code">npm i</p><p>We just installed TypeScript into our project as well as <strong class="source-inline">http-server</strong>, which is a simple Node.js HTTP server that will allow us to run our website on localhost.</p><p>Now we'll add a few files to get the project started.</p></li>
				<li>In the root of your project, create a file called <strong class="source-inline">index.html</strong> and add the following lines to it:<p class="source-code">&lt;html&gt;</p><p class="source-code">  &lt;head&gt;</p><p class="source-code">    &lt;title&gt;The TypeScript Workshop - Exercise 12.03&lt;/title&gt;</p><p class="source-code">    &lt;link href="styles.css" rel="stylesheet"&gt;&lt;/link&gt;</p><p class="source-code">  &lt;/head&gt;</p><p class="source-code">  &lt;body&gt;</p><p class="source-code">    &lt;div id="my-data"&gt;&lt;/div&gt;</p><p class="source-code">  &lt;/body&gt;</p><p class="source-code">  &lt;script type="module" src="data-loader.js"&gt;&lt;/script&gt;</p><p class="source-code">&lt;/html&gt;</p></li>
				<li>Next, optionally add a stylesheet as the default styles are quite an eyesore. Bring your own or use something simple like this:<p class="source-code">body {</p><p class="source-code">  font-family: Arial, Helvetica, sans-serif;</p><p class="source-code">  font-size: 12px;</p><p class="source-code">}</p><p class="source-code">input {</p><p class="source-code">  width: 200;</p><p class="source-code">}</p></li>
				<li>Add a file called <strong class="source-inline">data.json</strong> to represent the data we are fetching from a remote server:<p class="source-code">{ "message": "Hello Promise!" }</p></li>
				<li>One more to go. Let's add a TypeScript file called <strong class="source-inline">data-loader.ts</strong>:<p class="source-code">const updateUI = (message: any): void =&gt; {</p><p class="source-code">  const item = document.getElementById("my-data");</p><p class="source-code">  if (item) {</p><p class="source-code">    item.innerText = `Here is your data: ${message}`;</p><p class="source-code">  }</p><p class="source-code">};</p><p class="source-code">const message = fetch("http://localhost:8080/data.json");</p><p class="source-code">updateUI(message);</p><p>That's all you need to run a local service with a TypeScript web application! Later in the book, we'll see some more robust solutions, but for now, this will let us focus on the TypeScript without too many bells or whistles around.</p></li>
				<li>To see our application, we'll need to transpile the TypeScript and start the local server. For the best experience, we'll need two separate Command Prompt windows. In one of them, we'll type a command to transpile the TypeScript and watch for changes:<p class="source-code">npx tsc -w data-loader.ts</p></li>
				<li>And in the other window, we'll start our server with a flag to avoid caching so we can see our changes right away:<p class="source-code">npx http-server . -c-1</p></li>
				<li>If we navigate to <strong class="source-inline">http://localhost:8080</strong>, we'll see our application load and receive this message:<p class="source-code"> "Here is your data: [object Promise]". </p><p>Something hasn't worked correctly. What we want to see is <strong class="source-inline">"Here is your data: Hello Promise!"</strong>. If we go and look at the TypeScript code, we'll see this line:</p><p class="source-code">const message = fetch("http://localhost:8080/data.json");</p></li>
			</ol>
			<p>This isn't working correctly. <strong class="source-inline">fetch</strong> is an asynchronous request. We are just seeing the unresolved promise and printing it to the screen.</p>
			<p>Another warning sign is the use of <strong class="source-inline">any</strong> in the <strong class="source-inline">updateUI</strong> function. Why is the <strong class="source-inline">any</strong> type being used there when it should be a string? That's because TypeScript won't allow us to use a string. TypeScript knows we're calling <strong class="source-inline">updateUI</strong> with an unresolved promise and so we'll get a type error if we try to treat that as a string type. New developers sometimes think they are fixing a problem by using <strong class="source-inline">any</strong>, but more often than not they will be ignoring valid errors.</p>
			<p>In order to get this code to work correctly, you will need to refactor it so that the promise <strong class="source-inline">fetch</strong> returns is resolved. When it works correctly, <strong class="source-inline">fetch</strong> returns a response object that exposes a <strong class="source-inline">data</strong> method that also returns a promise, so you will need to resolve two promises in order to display the data on your page.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The fetch library is a web API for browsers that is a great improvement on the original <strong class="source-inline">XMLHttpRequest</strong> specification. It retains all the power of <strong class="source-inline">XMLHttpRequest</strong> but the API is much more ergonomic and as such is used by many web applications, rather than installing a third-party client library. <strong class="source-inline">fetch</strong> is not implemented in Node.js natively but there are some libraries that provide the same functionality. We'll take a look at those later in the chapter.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor303"/>Libraries and Native Promises — Third-Party Libraries, Q, and Bluebird</h1>
			<p>As stated previously, promises became part of the ECMAScript standard in 2015. Up until that point, developers used libraries such as Q or Bluebird to fill the gap in the language. While many developers choose to use native promises, these libraries remain quite popular with weekly downloads still growing. That said, we should carefully consider whether it's a good idea to depend on a third-party library over a native language feature. Unless one of these libraries provides some critical functionality that we can't do without, we should prefer native features over third-party libraries. Third-party libraries can introduce bugs, complexity, and security vulnerabilities and require extra effort to maintain. This isn't an indictment against open source. </p>
			<p>Open source projects (such as TypeScript) are an essential part of today's developer ecosystem. That said, it's still a good idea to carefully choose our dependencies and make sure they are well-maintained libraries that are not redundant with native features.</p>
			<p>It's also worth noting that the APIs of third-party libraries may differ from the native language feature. For example, the Q library borrows a deferred object from the jQuery implementation:</p>
			<p class="source-code">import * as Q from "q";</p>
			<p class="source-code">const deferred = Q.defer();</p>
			<p class="source-code">deferred.resolve(123);</p>
			<p class="source-code">deferred.promise.then(val =&gt; console.log(val));</p>
			<p>This written in a native promise is more like the examples we've seen so far:</p>
			<p class="source-code">const p = new Promise&lt;number&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">  resolve(123);</p>
			<p class="source-code">});</p>
			<p class="source-code">p.then(val =&gt; console.log(val));</p>
			<p>There's nothing inherently wrong with the Q implementation here, but it's non-standard and this may make our code less readable to other developers or prevent us from learning standard best practices.</p>
			<p>Bluebird is more similar to the native promise. In fact, it could be used as a polyfill.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor304"/>Polyfilling Promises</h2>
			<p>TypeScript will transpile code, but it will <em class="italic">not</em> polyfill native language features that are not present in your target environment. This is critical to understand to avoid frustration and mysterious bugs. What TypeScript will do for us is allow us to specify the target environment. Let's look at a simple example.</p>
			<p>Consider the following <strong class="source-inline">tsconfig.json</strong> file:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "compilerOptions": {</p>
			<p class="source-code">    "target": "es6",</p>
			<p class="source-code">    "module": "commonjs",</p>
			<p class="source-code">    "outDir": "./public",</p>
			<p class="source-code">    "strict": true,</p>
			<p class="source-code">    "esModuleInterop": true,</p>
			<p class="source-code">    "forceConsistentCasingInFileNames": true</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Now consider this module in <strong class="source-inline">promise.ts</strong>:</p>
			<p class="source-code">const p = new Promise&lt;number&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">  resolve(123);</p>
			<p class="source-code">});</p>
			<p class="source-code">p.then(val =&gt; console.log(val));</p>
			<p>Our code will transpile fine. We enter <strong class="source-inline">npx</strong> <strong class="source-inline">tsc</strong> and the transpiled JavaScript output looks very much like our TypeScript code. The only difference is the type has been removed:</p>
			<p class="source-code"> const p = new Promise((resolve, reject) =&gt; {</p>
			<p class="source-code">    resolve(123);</p>
			<p class="source-code">});</p>
			<p class="source-code">p.then(val =&gt; console.log(val));</p>
			<p>However, consider if we change the target to <strong class="source-inline">es5</strong>:</p>
			<p class="source-code">{</p>
			<p class="source-code">  "compilerOptions": {</p>
			<p class="source-code">    "target": "es5",</p>
			<p class="source-code">    "module": "commonjs",</p>
			<p class="source-code">    "outDir": "./public",</p>
			<p class="source-code">    "strict": true,</p>
			<p class="source-code">    "esModuleInterop": true,</p>
			<p class="source-code">    "forceConsistentCasingInFileNames": true</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Now the project will no longer build:</p>
			<p class="source-code">% npx tsc</p>
			<p class="source-code">src/promise.ts:1:15 - error TS2585: 'Promise' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the `lib` compiler option to es2015 or later.</p>
			<p class="source-code">1 const p = new Promise&lt;number&gt;((resolve, reject) =&gt; {</p>
			<p class="source-code">                ~~~~~~~</p>
			<p class="source-code">Found 1 error.</p>
			<p>TypeScript even warns me that I might want to fix my target. Note that <strong class="source-inline">"es2015"</strong> and <strong class="source-inline">"es6"</strong> are the same thing (as are <strong class="source-inline">"es2016"</strong> and <strong class="source-inline">"es7"</strong>, and so on). This is a somewhat confusing convention that we simply need to get used to.</p>
			<p>This will be fine if I can build my project for an <strong class="source-inline">es6+</strong> environment (such as a current version of Node.js or any modern browser), but if I need to support a legacy browser or a very old version of Node.js, then "fixing" this by setting the compilation target higher will only result in a broken application. We'll need to use a polyfill.</p>
			<p>In this case, Bluebird can be a really good choice as it has an API very similar to native promises. In fact, all I will need to do is <strong class="source-inline">npm</strong> <strong class="source-inline">install</strong> <strong class="source-inline">bluebird</strong> and then import the library into my module. The Bluebird library does not include typings so to have full IDE support, you'd need to also <strong class="source-inline">install</strong> <strong class="source-inline">@types/bluebird</strong> as a <strong class="source-inline">devDependency</strong>:</p>
			<p class="source-code">import { Promise } from "bluebird";</p>
			<p class="source-code">const p = new Promise&lt;number&gt;(resolve =&gt; {</p>
			<p class="source-code">  resolve(123);</p>
			<p class="source-code">});</p>
			<p class="source-code">p.then(val =&gt; console.log(val));</p>
			<p>My transpiled code will now run in a very early version of Node.js, such as version 0.10 (released in 2013).</p>
			<p>Note that Bluebird is designed to be a full-featured <strong class="source-inline">Promise</strong> library. If I'm just looking for a polyfill, I might prefer to use something like <strong class="source-inline">es6-promise</strong>. Its use is exactly the same. I <strong class="source-inline">npm</strong> <strong class="source-inline">install</strong> <strong class="source-inline">es6-promise</strong> and then import the <strong class="source-inline">Promise</strong> class into my module:</p>
			<p class="source-code">import { Promise } from "es6-promise";</p>
			<p class="source-code">const p = new Promise&lt;number&gt;(resolve =&gt; {</p>
			<p class="source-code">  resolve(123);</p>
			<p class="source-code">});</p>
			<p class="source-code">p.then(val =&gt; console.log(val));</p>
			<p>If you want to try this yourself, be aware that modern versions of TypeScript won't even run on Node.js 0.10! You'll have to transpile your code in a recent version (such as Node.js 12) and then switch to Node.js 0.10 to execute the code. To do this, it's a good idea to use a version manager such as <strong class="source-inline">nvm</strong> or <strong class="source-inline">n</strong>.</p>
			<p>This is actually a great example of the power of TypeScript. We can write and build our code on a modern version but target a legacy runtime. Setting the compilation target will make sure we build code that is suitable for that runtime.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor305"/>Promisify</h1>
			<p>Promisification is the practice of taking an asynchronous function that expects a callback and turning it into a promise. This is essentially a convenience utility that allows you to always write in promises instead of having to use the callbacks of a legacy API. It can be really helpful to promisify legacy APIs so that all our code can use promises uniformly and be easy to read. But it's more than just a convenience to convert callbacks into promises. Some modern APIs will only accept promises as parameters. If we could only work on some code with callbacks, we would have to wrap the callback asynchronous code with promises manually. Promisification saves us the trouble and potentially many lines of code.</p>
			<p>Let's work through an example of <em class="italic">promisifying</em> a function that expects a callback. We have a few options to choose from. Bluebird again provides this functionality with <strong class="source-inline">Promise.promisify</strong>. This time, we'll try a polyfill, <strong class="source-inline">es6-promisify</strong>. Let's start with a function that expects a callback:</p>
			<p class="source-code">const asyncAdder = (n1: number, n2: number, cb: Function) =&gt; {</p>
			<p class="source-code">  let err: Error;</p>
			<p class="source-code">  if (n1 === n2) {</p>
			<p class="source-code">    cb(Error("Use doubler instead!"));</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    cb(null, n1 + n2);</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p class="source-code">asyncAdder(3, 4, (err: Error, sum: number) =&gt; {</p>
			<p class="source-code">  if (err) {</p>
			<p class="source-code">    throw err;</p>
			<p class="source-code">  }</p>
			<p class="source-code">  console.log(sum);</p>
			<p class="source-code">});</p>
			<p>Functions that can be promisified follow a convention where the first argument into the callback is an error object. If the error is null or undefined, then the function is considered to have been invoked successfully. Here, I am calling <strong class="source-inline">asyncAdder</strong>, giving it two numbers and a callback function. My callback understands that <strong class="source-inline">asyncAdder</strong> will have an error in the first argument position if an error was thrown or the sum of the two numbers in the second argument position if it was successful. By adhering to this pattern, the function can be promisified. First, we <strong class="source-inline">npm install</strong> <strong class="source-inline">es6-promisify</strong> and then we import the module:</p>
			<p class="source-code">import { promisify } from "es6-promisify";</p>
			<p class="source-code">const asyncAdder = (n1: number, n2: number, cb: Function) =&gt; {</p>
			<p class="source-code">  let err: Error;</p>
			<p class="source-code">  if (n1 === n2) {</p>
			<p class="source-code">    cb(Error("Use doubler instead!"));</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    cb(null, n1 + n2);</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p class="source-code">const promiseAdder = promisify(asyncAdder);</p>
			<p class="source-code">promiseAdder(3, 4)</p>
			<p class="source-code">  .then((val: number) =&gt; console.log(val))</p>
			<p class="source-code">  .catch((err: Error) =&gt; console.log(err));</p>
			<p>We use the <strong class="source-inline">promisify</strong> import to wrap our function and now we can work exclusively with promises.</p>
			<p>Bluebird gives us exactly the same functionality:</p>
			<p class="source-code">import { promisify } from "bluebird";</p>
			<p class="source-code">const asyncAdder = (n1: number, n2: number, cb: Function) =&gt; {</p>
			<p class="source-code">  if (n1 === n2) {</p>
			<p class="source-code">    cb(Error("Use doubler instead!"));</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    cb(null, n1 + n2);</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p class="source-code">const promiseAdder = promisify(asyncAdder);</p>
			<p class="source-code">promiseAdder(3, 4)</p>
			<p class="source-code">  .then((val: number) =&gt; console.log(val))</p>
			<p class="source-code">  .catch((err: Error) =&gt; console.log(err));</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor306"/>Node.js util.promisify</h2>
			<p>Node.js introduced its own version of <strong class="source-inline">promisify</strong> as a native feature in version 8 (2017). Instead of using <strong class="source-inline">es6-promise</strong> or Bluebird, if we are targeting a Node.js 8+ environment, we can leverage the <strong class="source-inline">util</strong> package. Note that since we are writing TypeScript, we will need to add the <strong class="source-inline">@types/node</strong> dependency to take advantage of this package. Otherwise, TypeScript will not understand our import. We'll run <strong class="source-inline">npm</strong> <strong class="source-inline">install</strong> <strong class="source-inline">-D @types/node</strong>. The <strong class="source-inline">-D</strong> flag will install the type as a <strong class="source-inline">devDependency</strong>, which means it can be excluded from production builds:</p>
			<p class="source-code">import { promisify } from "util";</p>
			<p class="source-code">const asyncAdder = (n1: number, n2: number, cb: Function) =&gt; {</p>
			<p class="source-code">  let err: Error;</p>
			<p class="source-code">  if (n1 === n2) {</p>
			<p class="source-code">    cb(Error("Use doubler instead!"));</p>
			<p class="source-code">  } else {</p>
			<p class="source-code">    cb(null, n1 + n2);</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p class="source-code">const promiseAdder = promisify(asyncAdder);</p>
			<p class="source-code">promiseAdder(3, 4)</p>
			<p class="source-code">  .then((val: number) =&gt; console.log(val))</p>
			<p class="source-code">  .catch((err: Error) =&gt; console.log(err));</p>
			<p>Obviously, if we want our code to run in a browser, this won't work and we should use one of the other libraries, such as Bluebird, to enable this functionality.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor307"/>Asynchronous FileSystem</h1>
			<p>As of Node.js 10 (released 2018), the FileSystem API (<strong class="source-inline">fs</strong>) comes with promisified async versions of all the functions as well as blocking synchronous versions of them. Let's look at the same operation with all three alternatives.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor308"/>fs.readFile</h2>
			<p>Many Node.js developers have worked with this API. This method will read a file, taking the file path as the first argument and a callback as the second argument. The callback will receive one or two arguments, an error (should one occur) as the first argument and a data buffer object as the second argument, should the read be successful:</p>
			<p class="source-code">import { readFile } from "fs";</p>
			<p class="source-code">import { resolve } from "path";</p>
			<p class="source-code">const filePath = resolve(__dirname, "text.txt");</p>
			<p class="source-code">readFile(filePath, (err, data) =&gt; {</p>
			<p class="source-code">  if (err) {</p>
			<p class="source-code">    throw err;</p>
			<p class="source-code">  }</p>
			<p class="source-code">  console.log(data.toString());</p>
			<p class="source-code">});</p>
			<p>We read the file and log out the contents asynchronously. Anyone who has worked with the Node.js <strong class="source-inline">fs</strong> library in the past has probably seen code that looks like this. The code is non-blocking, which means even if the file is very large and the read is very slow, it won't prevent the application from performing other operations in the meantime. There's nothing wrong with this code other than it's not as concise and modern as we might like.</p>
			<p>In the example above, we're reading the file and logging to the console – not very useful, but in a real-world scenario, we might be reading a config file on startup, handling the documents of clients, or managing the lifecycle of web assets. There are many reasons you might need to access the local filesystem in a Node.js application.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor309"/>fs.readFileSync</h2>
			<p>The <strong class="source-inline">fs</strong> library also exposes a fully synchronous API, meaning its operations are blocking and the event loop won't progress until these operations are complete. Such blocking operations are more often used with command-line utilities where taking full advantage of the event loop isn't a priority and instead, simple, clean code is the priority. With this API, we can write some nice, concise code like this:</p>
			<p class="source-code">import { readFileSync } from "fs";</p>
			<p class="source-code">import { resolve } from "path";</p>
			<p class="source-code">const filePath = resolve(__dirname, "text.txt");</p>
			<p class="source-code">console.log(readFileSync(filePath).toString());</p>
			<p>It could be tempting to write code like this and call it a day, but <strong class="source-inline">readFileSync</strong> is a blocking operation so we must beware. The main execution thread will actually be paused until this work is complete. This may still be appropriate for a command-line utility, but it could be a real disaster to put code like this in a web API.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor310"/>The fs Promises API</h2>
			<p>The <strong class="source-inline">fs</strong> library exposes the promises API, which can give us the best of both worlds, asynchronous execution and concise code:</p>
			<p class="source-code">import { promises } from "fs";</p>
			<p class="source-code">import { resolve } from "path";</p>
			<p class="source-code">const filePath = resolve(__dirname, "text.txt");</p>
			<p class="source-code">promises.readFile(filePath).then(file =&gt; console.log(file.toString()));</p>
			<p>Using the promises API lets us write nearly as concise code as the synchronous version, but now we are fully asynchronous, making the code suitable for a high-throughput web application or any other process where a blocking operation would be unacceptable.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor311"/>Exercise 12.05: The fs Promises API</h2>
			<p>In this exercise, you will use the <strong class="source-inline">fs</strong> promises API to concatenate two files into one. Whenever possible, make your code DRY (don't repeat yourself) by using functions. You'll need to use <strong class="source-inline">readFile</strong> and <strong class="source-inline">writeFile</strong>. The only dependencies needed for this program are <strong class="source-inline">ts-node</strong> (for execution), <strong class="source-inline">typescript</strong>, and <strong class="source-inline">@types/node</strong> so we have the types for the built-in <strong class="source-inline">fs</strong> and <strong class="source-inline">path</strong> libraries in Node.js: </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/M3MH3">https://packt.link/M3MH3</a>.</p>
			<ol>
				<li value="1">Using the file in the GitHub repo as a basis for this exercise, navigate to the exercise directory and type <strong class="source-inline">npm</strong> <strong class="source-inline">i</strong> to install these dependencies.</li>
				<li>We are going to want to read two separate files using <strong class="source-inline">readFile</strong> and then use <strong class="source-inline">writeFile</strong> to write our output text file. The sample project already has two text files with some simple text. Feel free to add your own files and text.</li>
				<li>This project could be completed using <strong class="source-inline">readFileSync</strong> and <strong class="source-inline">writeFileSync</strong>. That code would look something like this:<p class="source-code">import { readFileSync, writeFileSync } from "fs";</p><p class="source-code">import { resolve } from "path";</p><p class="source-code">const file1 = readFileSync(resolve(__dirname, 'file1.txt'));</p><p class="source-code">const file2 = readFileSync(resolve(__dirname, 'file2.txt'));</p><p class="source-code">writeFileSync(resolve(__dirname, 'output.txt'), [file1, file2].join('\n'));</p><p>The <strong class="source-inline">resolve</strong> function from the path library resolves paths on your filesystem and is often used alongside the <strong class="source-inline">fs</strong> library, as depicted above. Both these libraries are part of the Node.js standard library so we need only install typings, not the libraries themselves.</p></li>
				<li>We can execute this program with <strong class="source-inline">npx</strong> <strong class="source-inline">ts-node</strong> <strong class="source-inline">file-concat.ts</strong>. This will produce a file called <strong class="source-inline">output.txt</strong>, which contains this text:<p class="source-code">Text in file 1.</p><p class="source-code">Text in file 2.</p><p>So this works without promises. And this is probably fine for a command-line utility executed by a single user on a single workstation. However, if this kind of code were put into a web server, we might start to see some blocking issues. Synchronous filesystem calls are <em class="italic">blocking</em> and block the event loop. Doing this in a production application can cause latency or failure.</p></li>
				<li>We could solve this problem using <strong class="source-inline">readFile</strong> and <strong class="source-inline">writeFile</strong>, which are both asynchronous functions that take callbacks, but then we'd need to nest the second <strong class="source-inline">readFile</strong> inside the first. The code would look like this:<p class="source-code">import { readFile, writeFile } from 'fs';</p><p class="source-code">import { resolve } from 'path';</p><p class="source-code">readFile(resolve(__dirname, 'file1.txt'), (err, file1) =&gt; {</p><p class="source-code">  if (err) throw err;</p><p class="source-code">  readFile(resolve(__dirname, 'file1.txt'), (err, file2) =&gt; {</p><p class="source-code">    if (err) throw err;</p><p class="source-code">    writeFile(</p><p class="source-code">      resolve(__dirname, 'output.txt'),</p><p class="source-code">      [file1, file2].join('\n'),</p><p class="source-code">      (err) =&gt; {</p><p class="source-code">        if (err) throw err;</p><p class="source-code">      }</p><p class="source-code">    );</p><p class="source-code">  });</p><p class="source-code">});</p><p>We are now clear of blocking issues, but the code is looking quite ugly. It's not hard to imagine another developer failing to understand the intent of this code and introducing a bug. Additionally, by putting the second <strong class="source-inline">readFile</strong> as a callback in the first, we are making the function slower than it needs to be. In a perfect world, those calls can be made in parallel. To do that, we can leverage the promises API.</p></li>
				<li>The best way to do things in parallel with promises is <strong class="source-inline">Promise.all</strong>. We can wrap our two <strong class="source-inline">readFile</strong> calls in a single <strong class="source-inline">Promise.all</strong>. To do that, we need to promisify <strong class="source-inline">readFile</strong>. Lucky for us, the <strong class="source-inline">fs</strong> library comes with a helper that will do that for us. Instead of importing <strong class="source-inline">readFile</strong>, we import promises from <strong class="source-inline">fs</strong> and call the <strong class="source-inline">readFile</strong> method on that object:<p class="source-code">import { promises } from 'fs';</p><p class="source-code">import { resolve } from 'path';</p><p class="source-code">Promise.all([</p><p class="source-code">  promises.readFile(resolve(__dirname, 'file1.txt')),</p><p class="source-code">  promises.readFile(resolve(__dirname, 'file2.txt')),</p><p class="source-code">]);</p></li>
				<li>These two reads will now run asynchronously in parallel. Now we can handle the output and use the same <strong class="source-inline">array.join</strong> function from the earlier example along with <strong class="source-inline">promises.writeFile</strong>:<p class="source-code">import { promises } from 'fs';</p><p class="source-code">import { resolve } from 'path';</p><p class="source-code">Promise.all([</p><p class="source-code">  promises.readFile(resolve(__dirname, 'file1.txt')),</p><p class="source-code">  promises.readFile(resolve(__dirname, 'file2.txt')),</p><p class="source-code">]).then((files) =&gt; {</p><p class="source-code">  promises.writeFile(resolve(__dirname, 'output.txt'), files.join('\n'));</p><p class="source-code">});</p></li>
				<li>This code is looking quite a lot cleaner than the nested code above. When we execute it with <strong class="source-inline">npx</strong> <strong class="source-inline">ts-node</strong> <strong class="source-inline">file-concat.ts</strong>, we get the expected output of <strong class="source-inline">output.txt</strong> containing the concatenated text:<p class="source-code">Text in file 1.</p><p class="source-code">Text in file 2.</p><p>Now that we have this working, we can certainly imagine much more complicated programs manipulating other types of files, such as a PDF merge function as a web service. Though some of the internals would be a lot more challenging to implement, the principles would be the same.</p></li>
			</ol>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor312"/>Working with Databases</h1>
			<p>It is very common for Node.js applications to work with a backend database such as <strong class="source-inline">mysql</strong> or <strong class="source-inline">postgres</strong>. It is critical that queries against a database be made asynchronously. Production-grade Node.js web services may serve thousands of requests per second. If it were necessary to pause the main execution thread for queries made synchronously against a database, these services just wouldn't scale at all. Asynchronous execution is critical to making this work.</p>
			<p>The process of negotiating a database connection, sending a SQL string, and parsing the response is complicated and not a native feature of Node.js and so we will almost always use a third-party library to manage this. These libraries are guaranteed to implement some kind of callback or promise pattern and we'll see it throughout their documentation and examples. Depending on the library you choose, you may have to implement a callback pattern, you may get to work with promises, or you may be presented with <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong> (see <em class="italic">Chapter 13 Async/Await</em>). You may even get a choice of any of these as it's definitely possible to provide all of the above as options.</p>
			<p>For these examples, we'll use <strong class="source-inline">sqlite</strong>. Now, <strong class="source-inline">sqlite</strong> is a nice library that implements a fairly standard SQL syntax and can operate against a static file as a database or even run in memory. We will use the in-memory option. This means that there is nothing that needs to be done to set up our database. But we will have to run a few scripts to create a table or two and populate it on startup. It would be fairly simple to adapt these exercises to work with <strong class="source-inline">mysql</strong>, <strong class="source-inline">postgres</strong>, or even <strong class="source-inline">mongodb</strong>. All of these databases can be installed on your workstation or run in a Docker container for local development.</p>
			<p>For the first example, let's look at <strong class="source-inline">sqlite3</strong>. This library has an asynchronous API. Unlike more permanent and robust databases such as <strong class="source-inline">mysql</strong> or <strong class="source-inline">postgres</strong>, some <strong class="source-inline">sqlite</strong> client libraries are actually synchronous, but we won't be looking at those as they aren't very useful for demonstrating how promises work. So <strong class="source-inline">sqlite3</strong> implements an asynchronous API, but it works entirely with callbacks. Here is an example of creating an in-memory database, adding a table, adding a row to that table, and then querying back the row we added:</p>
			<p class="source-code">import { Database } from "sqlite3";</p>
			<p class="source-code">const db = new Database(":memory:", err =&gt; {</p>
			<p class="source-code">  if (err) {</p>
			<p class="source-code">    console.error(err);</p>
			<p class="source-code">    return db.close();</p>
			<p class="source-code">  }</p>
			<p class="source-code">  db.run("CREATE TABLE promise (id int, desc char);", err =&gt; {</p>
			<p class="source-code">    if (err) {</p>
			<p class="source-code">      console.error(err);</p>
			<p class="source-code">      return db.close();</p>
			<p class="source-code">    }</p>
			<p class="source-code">    db.run(</p>
			<p class="source-code">      "INSERT INTO promise VALUES (1, 'I will always lint my code.');",</p>
			<p class="source-code">      () =&gt; {</p>
			<p class="source-code">        db.all("SELECT * FROM promise;", (err, rows) =&gt; {</p>
			<p class="source-code">          if (err) {</p>
			<p class="source-code">            console.error(err);</p>
			<p class="source-code">            return db.close();</p>
			<p class="source-code">          }</p>
			<p class="source-code">          console.log(rows);</p>
			<p class="source-code">          db.close(err =&gt; {</p>
			<p class="source-code">            if (err) {</p>
			<p class="source-code">              return console.error(err);</p>
			<p class="source-code">            }</p>
			<p class="source-code">          });</p>
			<p class="source-code">        });</p>
			<p class="source-code">      }</p>
			<p class="source-code">    );</p>
			<p class="source-code">  });</p>
			<p class="source-code">});</p>
			<p>This is exactly what developers mean when they complain about "callback hell." Again, this code executes perfectly well, but it is needlessly verbose, becomes deeply nested, and repeats itself, especially in the error-handling department. Of course, the code could be improved by adding abstractions and chaining together methods, but that doesn't change the fact that callbacks aren't a very modern way to think about writing Node.js code.</p>
			<p>Since all of these callbacks follow the pattern of expecting the first argument to be an error object, we could promisify <strong class="source-inline">sqlite3</strong>, but as is often the case, somebody has already done this work for us and provided a library called simply <strong class="source-inline">sqlite</strong> that mimics the exact API of <strong class="source-inline">sqlite3</strong>, but implements a promise API.</p>
			<p>I can rewrite the same code using this library and the result is a good deal more pleasing:</p>
			<p class="source-code">import { open } from "sqlite";</p>
			<p class="source-code">import * as sqlite from "sqlite3";</p>
			<p class="source-code">open({ driver: sqlite.Database, filename: ":memory:" }).then((db) =&gt; {  return db</p>
			<p class="source-code">    .run("CREATE TABLE promise (id int, desc char);")</p>
			<p class="source-code">    .then(() =&gt; {</p>
			<p class="source-code">      return db.run(</p>
			<p class="source-code">        "INSERT INTO promise VALUES (1, 'I will always lint my code.');"</p>
			<p class="source-code">      );</p>
			<p class="source-code">    })</p>
			<p class="source-code">    .then(() =&gt; {</p>
			<p class="source-code">      return db.all("SELECT * FROM promise;");</p>
			<p class="source-code">    })</p>
			<p class="source-code">    .then(rows =&gt; {</p>
			<p class="source-code">      console.log(rows);</p>
			<p class="source-code">    })</p>
			<p class="source-code">    .catch(err =&gt; console.error(err))</p>
			<p class="source-code">    .finally(() =&gt; db.close());</p>
			<p class="source-code">});</p>
			<p>We've dropped nearly half of the lines of code and it's not nested as deeply. This still could be improved, but it's much cleaner now. Best of all, we have a single <strong class="source-inline">catch</strong> block followed by <strong class="source-inline">finally</strong>, to make sure the database connection is closed at the end.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor313"/>Developing with REST</h1>
			<p>In the next exercise, we'll build a RESTful API. REST is a very common standard for web traffic. Most websites and web APIs operate using REST. It stands for Representational State Transfer and defines concepts such as operations (sometimes called "methods" or even "verbs") such as <strong class="source-inline">GET</strong>, <strong class="source-inline">DELETE</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">PATCH</strong> and resources (the "path" or "noun"). The full scope of REST is beyond this book.</p>
			<p>Developers working on RESTful APIs frequently find it useful to work with some sort of REST client. The REST client can be configured to make different kinds of requests and display the responses. Requests can be saved and run again in the future. Some REST clients allow the creation of scenarios or test suites.</p>
			<p>Postman is a popular and free REST client. If you don't already have a REST client you're comfortable working with, try downloading Postman at <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a> before the next exercise. Once you've installed Postman, check its documentation (<a href="https://learning.postman.com/docs/getting-started/sending-the-first-request/">https://learning.postman.com/docs/getting-started/sending-the-first-request/</a>) and get ready for the next exercise.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor314"/>Exercise 12.06: Implementing a RESTful API backed by sqlite</h2>
			<p>In this exercise, you will create a REST API backed by <strong class="source-inline">sqlite</strong>. In this project, you will implement all CRUD (create, read, update, and delete) operations in the <strong class="source-inline">sqlite</strong> database and we will expose the corresponding REST verbs (<strong class="source-inline">POST</strong>, <strong class="source-inline">GET</strong>, <strong class="source-inline">PUT</strong>, and <strong class="source-inline">DELETE</strong>) from our web server:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/rlX7G">https://packt.link/rlX7G</a>.</p>
			<ol>
				<li value="1">To get started, clone the project from GitHub and change to the directory for this exercise.</li>
				<li>Install the dependencies:<p class="source-code">npm i</p><p>This will install typings for Node.js, as well as <strong class="source-inline">ts-node</strong> and <strong class="source-inline">typescript</strong> as development dependencies while <strong class="source-inline">sqlite</strong> and <strong class="source-inline">sqlite3</strong> are regular dependencies. All of these dependencies are already specified in the project's <strong class="source-inline">package.json</strong> file. Some of the dependencies, such as <strong class="source-inline">@types/node</strong>, <strong class="source-inline">ts-node</strong>, and <strong class="source-inline">typescript</strong>, are specified as <strong class="source-inline">devDependencies</strong> and others are regular dependencies. For the purpose of this exercise, the distinction is not going to matter but it's a common practice to run application builds so that only the necessary dependencies are part of the production build, thus the separation. The way to run this kind of build is <strong class="source-inline">npm install --production</strong> if you only wish to install the production dependencies or <strong class="source-inline">npm prune --production</strong> if you've already installed your <strong class="source-inline">devDependencies</strong> and wish to remove them.</p></li>
				<li>Now let's create a file to hold our <strong class="source-inline">sqlite</strong> database. Add a file in the root of your project called <strong class="source-inline">db.ts</strong>. We'll go with an object-oriented approach for the database and create a singleton object to represent our database and access patterns. One reason for doing this is we are going to want to maintain the state of whether or not the database has been initialized. Calling open on an in-memory <strong class="source-inline">sqlite</strong> database will destroy the database and create another one immediately, thus we only want to open the database connection if it isn't already open:<p class="source-code">import { Database } from "sqlite";</p><p class="source-code">import sqlite from "sqlite3";</p><p class="source-code">export interface PromiseModel {</p><p class="source-code">  id: number;</p><p class="source-code">  desc: string;</p><p class="source-code">}</p><p class="source-code">export class PromiseDB {</p><p class="source-code">  private db: Database;</p><p class="source-code">  private initialized = false;</p><p class="source-code">  constructor() {</p><p class="source-code">    this.db = new Database({</p><p class="source-code">      driver: sqlite.Database,</p><p class="source-code">      filename: ":memory:",</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">}</p><p>It's always a good idea to create a class or interface to describe our entity, so here we have created <strong class="source-inline">PromiseModel</strong>. It will be useful to other parts of our application to be able to understand the properties our entity has as well as their types, since the database will only return untyped query results. We export the interface so that it can be used by other modules.</p></li>
				<li>Our database is an object with a constructor that will have a private member representing the actual database connection and a Boolean value to track whether the database has been initialized. Let's add a method for initialization:<p class="source-code">  initialize = () =&gt; {</p><p class="source-code">    if (this.initialized) {</p><p class="source-code">      return Promise.resolve(true);</p><p class="source-code">    }</p><p class="source-code">    return this.db</p><p class="source-code">      .open()</p><p class="source-code">      .then(() =&gt;</p><p class="source-code">        this.db</p><p class="source-code">          .run("CREATE TABLE promise (id INTEGER PRIMARY KEY, desc CHAR);")</p><p class="source-code">          .then(() =&gt; (this.initialized = true))</p><p class="source-code">      );</p><p class="source-code">  };</p><p>First, we check to see if we've already initialized the database. If so, we're done and we resolve the promise. If not, we call <strong class="source-inline">open</strong>, then once that promise has resolved, run our table creation SQL, and then finally update the state of the database so that we don't accidentally re-initialize it.</p><p>We could try to initialize the database in the constructor. The problem with that approach is that constructors do not resolve promises before returning. Constructor functions may call methods that return promises, but they will not resolve the promise. It's usually cleaner to create the singleton object and then invoke the initialization promise separately. For more information about singleton classes, see <em class="italic">Chapter 8, Dependency Injection in TypeScript</em>.</p></li>
				<li>Now let's add some methods. This will be pretty simple since our table only has two columns:<p class="source-code">  create = (payload: PromiseModel) =&gt;</p><p class="source-code">    this.db.run("INSERT INTO promise (desc) VALUES (?);", payload.desc);</p><p>This method takes an object of type <strong class="source-inline">PromiseModel</strong> as an argument, sends a prepared statement (a parameterized SQL statement that is safe from SQL injection attacks), and then returns <strong class="source-inline">RunResult</strong>, which contains some metadata about the operation that took place. Since the <strong class="source-inline">sqlite</strong> library ships with typings, we're able to infer the return type without needing to specify it. The return type in this case is <strong class="source-inline">Promise&lt;ISqlite.RunResult&lt;sqlite.Statement&gt;&gt;</strong>. We could paste all of that into our code, but it's much cleaner the way it is. Remember, if a good type can be inferred, it's best to just let TypeScript do the heavy lifting.</p></li>
				<li>In addition to the <strong class="source-inline">create</strong> method, we will want <strong class="source-inline">delete</strong>, <strong class="source-inline">getAll</strong>, <strong class="source-inline">getOne</strong>, and <strong class="source-inline">update</strong> methods. The <strong class="source-inline">delete</strong> method is very straightforward:<p class="source-code">  delete = (id: number) =&gt; this.db.run("DELETE FROM promise WHERE id = ?", id);</p></li>
				<li>Since we're calling <strong class="source-inline">db.run</strong> again, we're again returning that <strong class="source-inline">RunResult</strong> type. Let's see what it looks like to return some of your own data:<p class="source-code">  getAll = () =&gt; this.db.all&lt;PromiseModel[]&gt;("SELECT * FROM promise;");</p><p class="source-code">  getOne = (id: number) =&gt;</p><p class="source-code">    this.db.get&lt;PromiseModel&gt;("SELECT * FROM promise WHERE id = ?", id);</p><p>These methods use type parameters to specify the expected return types. If the type parameters were omitted, these methods would return <strong class="source-inline">any</strong> types, which wouldn't be very helpful to the other parts of our application.</p></li>
				<li>Last of all is the <strong class="source-inline">update</strong> method. This one will use our <strong class="source-inline">PromiseModel</strong> again to type check the input:<p class="source-code">  update = (payload: PromiseModel) =&gt;</p><p class="source-code">    this.db.run(</p><p class="source-code">      "UPDATE promise SET desc = ? where id = ?",</p><p class="source-code">      payload.desc,</p><p class="source-code">      payload.id</p><p class="source-code">    );</p></li>
				<li>The final code for the class looks like this:<p class="source-code">import { Database } from "sqlite";</p><p class="source-code">import sqlite from "sqlite3";</p><p class="source-code">export interface PromiseModel {</p><p class="source-code">  id: number;</p><p class="source-code">  desc: string;</p><p class="source-code">}</p><p class="source-code">export class PromiseDB {</p><p class="source-code">  private db: Database;</p><p class="source-code">  private initialized = false;</p><p class="source-code">  constructor() {</p><p class="source-code">    this.db = new Database({</p><p class="source-code">      driver: sqlite.Database,</p><p class="source-code">      filename: ":memory:",</p><p class="source-code">    });</p><p class="source-code">  }</p><p class="source-code">  initialize = () =&gt; {</p><p class="source-code">    if (this.initialized) {</p><p class="source-code">      return Promise.resolve(true);</p><p class="source-code">    }</p><p class="source-code">    return this.db</p><p class="source-code">      .open()</p><p class="source-code">      .then(() =&gt;</p><p class="source-code">        this.db</p><p class="source-code">          .run("CREATE TABLE promise (id INTEGER PRIMARY KEY, desc CHAR);")</p><p class="source-code">          .then(() =&gt; (this.initialized = true))</p><p class="source-code">      );</p><p class="source-code">  };</p><p class="source-code">  create = (payload: PromiseModel) =&gt;</p><p class="source-code">    this.db.run("INSERT INTO promise (desc) VALUES (?);", payload.desc);</p><p class="source-code">  delete = (id: number) =&gt; this.db.run("DELETE FROM promise WHERE id = ?", id);</p><p class="source-code">  getAll = () =&gt; this.db.all&lt;PromiseModel[]&gt;("SELECT * FROM promise;");</p><p class="source-code">  getOne = (id: number) =&gt;</p><p class="source-code">    this.db.get&lt;PromiseModel&gt;("SELECT * FROM promise WHERE id = ?", id);</p><p class="source-code">  update = (payload: PromiseModel) =&gt;</p><p class="source-code">    this.db.run(</p><p class="source-code">      "UPDATE promise SET desc = ? where id = ?",</p><p class="source-code">      payload.desc,</p><p class="source-code">      payload.id</p><p class="source-code">    );</p><p class="source-code">}</p><p>The next step is to build an HTTP server implementing a RESTful interface. Many Node.js developers use frameworks such as Express.js, Fastify, or NestJS, but for this exercise, we're just going to build a basic HTTP server. It won't have all the niceties of those frameworks, but it'll help us focus on asynchronous programming.</p></li>
				<li>To create our server, we'll create a class called <strong class="source-inline">App</strong> and expose an instance of it. Create a file called <strong class="source-inline">app.ts</strong> and declare the class:<p class="source-code">import { createServer, IncomingMessage, Server, ServerResponse } from "http";</p><p class="source-code">import { PromiseDB } from "./db";</p><p class="source-code">class App {</p><p class="source-code">  public db: PromiseDB;</p><p class="source-code">  private server: Server;</p><p class="source-code">  constructor(private port: number) {</p><p class="source-code">    this.db = new PromiseDB();</p><p class="source-code">    this.server = createServer(this.requestHandler);</p><p class="source-code">  }</p><p class="source-code">}</p><p class="source-code">export const app = new App(3000);</p></li>
				<li>Our <strong class="source-inline">App</strong> class takes an argument of the port number we'll run our server on. The class will maintain the state of the running server as well as the database connection. Like our <strong class="source-inline">PromiseDB</strong> class, the constructor needs to be supplemented by an <strong class="source-inline">initialize</strong> method to handle the asynchronous setup: <p class="source-code">  initialize = () =&gt; {</p><p class="source-code">    return Promise.all([</p><p class="source-code">      this.db.initialize(),</p><p class="source-code">      new Promise((resolve) =&gt; this.server.listen(this.port, () =&gt; resolve(true))),</p><p class="source-code">    ]).then(() =&gt; console.log("Application is ready!"));</p><p class="source-code">  };</p><p>This method uses <strong class="source-inline">Promise.all</strong> so that we can initialize our database and server in parallel. When both are ready, it'll log a message letting us know the application is ready to handle requests. We are calling the <strong class="source-inline">initialize</strong> method on the <strong class="source-inline">PromiseDB</strong> instance that we've exposed to our <strong class="source-inline">App</strong> class. Unfortunately, <strong class="source-inline">server.listen</strong> doesn't return a promise but instead implements a fairly primitive API that requires a callback so we are wrapping it in our own promise. It's tempting to want to wrap <strong class="source-inline">server.listen</strong> in <strong class="source-inline">util.promisify</strong>, but even that won't work because <strong class="source-inline">util.promisify</strong> expects the callback function to expect the first argument to be an error object and the <strong class="source-inline">server.listen</strong> callback doesn't take any arguments. Sometimes, despite our best efforts, we just have to use a callback, but we can usually wrap them with promises.</p></li>
				<li>We're also going to need to add a <strong class="source-inline">requestHandler</strong> method. <strong class="source-inline">createServer</strong> is a method exposed by the <strong class="source-inline">http</strong> module in Node.js. It takes an argument that should be a function to handle requests and supply a response. Again, the API for the <strong class="source-inline">http</strong> module is fairly low-level:<p class="source-code">requestHandler = (req: IncomingMessage, res: ServerResponse) =&gt; {</p><p class="source-code">    res.setHeader("Access-Control-Allow-Origin", "*");</p><p class="source-code">    res.setHeader("Access-Control-Allow-Headers", "*");</p><p class="source-code">    res.setHeader(</p><p class="source-code">      "Access-Control-Allow-Methods",</p><p class="source-code">      "DELETE, GET, OPTIONS, POST, PUT"</p><p class="source-code">    );</p><p class="source-code">    if (req.method === "OPTIONS") {</p><p class="source-code">      return res.end();</p><p class="source-code">    }</p><p class="source-code">    const urlParts = req.url?.split("/") ?? "/";</p><p class="source-code">    switch (urlParts[1]) {</p><p class="source-code">      case "promise":</p><p class="source-code">        return promiseRouter(req, res);</p><p class="source-code">      default:</p><p class="source-code">        return this.handleError(res, 404, "Not Found.");</p><p class="source-code">    }</p><p class="source-code">  };</p><p>We want our application to direct all traffic on the <strong class="source-inline">/promise</strong> resource to our promises API. This will allow us to add more resources (maybe <strong class="source-inline">/admin</strong> or <strong class="source-inline">/users</strong>) later on. The request handler's job is to see if we have requested the <strong class="source-inline">/promise</strong> route and then direct traffic to that specific router. Since we haven't defined any other resources, we'll return a 404 if we request any other route.</p><p>Note that we are handling the <strong class="source-inline">OPTIONS</strong> HTTP verb differently than any other. If we get a request with that verb, we set the <strong class="source-inline">"Access-Control-Allow-Origin"</strong> header and return a successful response. This is for development convenience. The topic of CORS is beyond the scope of this book, and readers are encouraged to learn more about it before implementing it in a production environment.</p></li>
				<li>That error handler needs a definition, so let's add one:<p class="source-code">  handleError = (</p><p class="source-code">    res: ServerResponse,</p><p class="source-code">    statusCode = 500,</p><p class="source-code">    message = "Internal Server Error."</p><p class="source-code">  ) =&gt; res.writeHead(statusCode).end(message);</p><p>This is a nice one-liner that by default will throw a 500 status code <strong class="source-inline">Internal Server Error</strong>, but can take optional parameters to return any error code or message. Our default handler sets the status code to 404 and provides the message <strong class="source-inline">"Not Found"</strong>.</p></li>
				<li>We add a call to <strong class="source-inline">initialize</strong> at the end and we're good to go. Let's take another look at the <strong class="source-inline">App</strong> class:<p class="source-code">import { createServer, IncomingMessage, Server, ServerResponse } from "http";</p><p class="source-code">import { PromiseDB } from "./db";</p><p class="source-code">import { promiseRouter } from "./router";</p><p class="source-code">class App {</p><p class="source-code">  public db: PromiseDB;</p><p class="source-code">  private server: Server;</p><p class="source-code">  constructor(private port: number) {</p><p class="source-code">    this.db = new PromiseDB();</p><p class="source-code">    this.server = createServer(this.requestHandler);</p><p class="source-code">  }</p><p class="source-code">  initialize = () =&gt; {</p><p class="source-code">    return Promise.all([</p><p class="source-code">      this.db.initialize(),</p><p class="source-code">      new Promise((resolve) =&gt; this.server.listen(this.port, () =&gt; resolve(true))),</p><p class="source-code">    ]).then(() =&gt; console.log("Application is ready!"));</p><p class="source-code">  };</p><p class="source-code">  handleError = (</p><p class="source-code">    res: ServerResponse,</p><p class="source-code">    statusCode = 500,</p><p class="source-code">    message = "Internal Server Error."</p><p class="source-code">  ) =&gt; res.writeHead(statusCode).end(message);</p><p class="source-code">requestHandler = (req: IncomingMessage, res: ServerResponse) =&gt; {</p><p class="source-code">    res.setHeader("Access-Control-Allow-Origin", "*");</p><p class="source-code">    res.setHeader("Access-Control-Allow-Headers", "*");</p><p class="source-code">    res.setHeader(</p><p class="source-code">      "Access-Control-Allow-Methods",</p><p class="source-code">      "DELETE, GET, OPTIONS, POST, PUT"</p><p class="source-code">    );</p><p class="source-code">    if (req.method === "OPTIONS") {</p><p class="source-code">      return res.end();</p><p class="source-code">    }</p><p class="source-code">    const urlParts = req.url?.split("/") ?? "/";</p><p class="source-code">    switch (urlParts[1]) {</p><p class="source-code">      case "promise":</p><p class="source-code">        return promiseRouter(req, res);</p><p class="source-code">      default:</p><p class="source-code">        return this.handleError(res, 404, "Not Found.");</p><p class="source-code">    }</p><p class="source-code">  };</p><p class="source-code">}</p><p class="source-code">export const app = new App(3000);</p><p class="source-code">app.initialize();</p><p>If you've implemented all this in code, you're probably still getting an error on <strong class="source-inline">promiseRouter</strong>. That's because we haven't written that yet.</p></li>
				<li>Add a <strong class="source-inline">router.ts</strong> file to your project. This will be the last part we need to build this simple API. A more complicated application would hopefully include a more sophisticated directory structure and most likely be based on a leading framework such as Express.js or NestJS.<p>Unlike our database and server modules, the router is stateless. It does not need to be initialized and does not track any variables. We could still create a class for our router, but let's instead use a functional programming style. There's really no right or wrong way to do this. Instead of using classes for our database and server, we could likewise use a functional style.</p><p>We're going to work on creating several handlers, tie them together with a router based on HTTP verbs, and also create a body parser. Let's start with the body parser.</p></li>
				<li>Readers who have some experience with the Express.js framework may have used its powerful <strong class="source-inline">bodyParser</strong> module. It's normally a good idea to use an off-the-shelf solution for something like that, but in this exercise, you will write your own in order to get a closer look at how we can take the request or <strong class="source-inline">IncomingMessage</strong> object as a stream and convert it into a typed object:<p class="source-code">const parseBody = (req: IncomingMessage): Promise&lt;PromiseModel&gt; =&gt; {</p><p class="source-code">  return new Promise((resolve, reject) =&gt; {</p><p class="source-code">    let body = "";</p><p class="source-code">    req.on("data", (chunk) =&gt; (body += chunk));</p><p class="source-code">    req.on("end", () =&gt; {</p><p class="source-code">      try {</p><p class="source-code">        resolve(JSON.parse(body));</p><p class="source-code">      } catch (e) {</p><p class="source-code">        reject(e);</p><p class="source-code">      }</p><p class="source-code">    });</p><p class="source-code">  });</p><p class="source-code">};</p><p>The data stream is again a fairly low-level API that we must wrap in a promise. The stream is event-based, as are a lot of the Node.js APIs. In this case, we are listening for two separate events, <strong class="source-inline">data</strong> and <strong class="source-inline">end</strong>. Each time we get a <strong class="source-inline">data</strong> event, we add data to the <strong class="source-inline">body</strong> string. When we receive the <strong class="source-inline">end</strong> event, we can finally resolve our promise. Since the data is a string at this point and we want an object, we will use <strong class="source-inline">JSON.parse</strong> to parse the object. <strong class="source-inline">JSON.parse</strong> must be wrapped with <strong class="source-inline">try/catch</strong> to catch any parsing errors.</p><p>By default, <strong class="source-inline">JSON.parse</strong> returns an <strong class="source-inline">any</strong> type. This type is too broad to be of any use in checking our application for type correctness. Fortunately, we can add proper type checking by setting the return type of <strong class="source-inline">parseBody</strong> to <strong class="source-inline">Promise&lt;PromiseModel&gt;</strong>. This will narrow the type of the object returned by <strong class="source-inline">JSON.parse</strong> to <strong class="source-inline">PromiseModel</strong> and the rest of our application can expect that type to have been parsed. Note that this is a compile-time check and does not guarantee the correct data has come from a third-party source such as an end user. It is advisable to combine type checks with validators or type guards to ensure consistency. When in doubt, employ good error handling.</p></li>
				<li>Now that you have a good method for parsing the request body, let's add one to handle the create action:<p class="source-code">const handleCreate = (req: IncomingMessage, res: ServerResponse) =&gt;</p><p class="source-code">  parseBody(req)</p><p class="source-code">    .then((body) =&gt; app.db.create(body).then(() =&gt; res.end()))</p><p class="source-code">    .catch((err) =&gt; app.handleError(res, 500, err.message));</p></li>
				<li>This function parses the body of the request, attempts to insert it into our database, and then responds with a default 200 response if the operation was successful. Note that the chained catch at the end will catch any errors that occur in the promise. If our body parsing fails, the error will be caught here, even though it's placed after <strong class="source-inline">db.create</strong> in the chain.</li>
				<li>Now let's handle the delete action:<p class="source-code">const handleDelete = (requestParam: number, res: ServerResponse) =&gt;</p><p class="source-code">  app.db</p><p class="source-code">    .delete(requestParam)</p><p class="source-code">    .then(() =&gt; res.end())</p><p class="source-code">    .catch((err) =&gt; app.handleError(res, 500, err.message));</p><p>The HTTP <strong class="source-inline">DELETE</strong> verb does not use a body. Instead, we will take the ID of the row we want to delete from the URL. We'll see how that routing works in a moment.</p></li>
				<li>The <strong class="source-inline">GET</strong> operations need to return some data and will use <strong class="source-inline">JSON.stringify</strong> to serialize their response objects to send them to a client:<p class="source-code">const handleGetAll = (res: ServerResponse) =&gt;</p><p class="source-code">  app.db</p><p class="source-code">    .getAll()</p><p class="source-code">    .then((data) =&gt; res.end(JSON.stringify(data)))</p><p class="source-code">    .catch((err) =&gt; app.handleError(res, 500, err.message));</p><p class="source-code">const handleGetOne = (requestParam: number, res: ServerResponse) =&gt;</p><p class="source-code">  app.db</p><p class="source-code">    .getOne(requestParam)</p><p class="source-code">    .then((data) =&gt; res.end(JSON.stringify(data)))</p><p class="source-code">    .catch((err) =&gt; app.handleError(res, 500, err.message));</p></li>
				<li>The update action looks similar to delete:<p class="source-code">const handleUpdate = (req: IncomingMessage, res: ServerResponse) =&gt;</p><p class="source-code">  parseBody(req)</p><p class="source-code">    .then((body) =&gt; app.db.update(body).then(() =&gt; res.end()))</p><p class="source-code">    .catch((err) =&gt; app.handleError(res, 500, err.message));</p></li>
				<li>Finally, we just need a router. Your router will need to make a decision based on the HTTP verb used as well as any request parameter that may refer to the ID of the row we want to interact with. We will also set the <strong class="source-inline">Content-Type</strong> header to <strong class="source-inline">application/json</strong> for all responses. Then we simply need to delegate to the correct handler:<p class="source-code">export const promiseRouter = (req: IncomingMessage, res: ServerResponse) =&gt; {</p><p class="source-code">  const urlParts = req.url?.split("/") ?? "/";</p><p class="source-code">  const requestParam = urlParts[2];</p><p class="source-code">  res.setHeader("Content-Type", "application/json");</p><p class="source-code">  switch (req.method) {</p><p class="source-code">    case "DELETE":</p><p class="source-code">      if (requestParam) {</p><p class="source-code">        return handleDelete(Number.parseInt(requestParam), res);</p><p class="source-code">      }</p><p class="source-code">    case "GET":</p><p class="source-code">      if (requestParam) {</p><p class="source-code">        return handleGetOne(Number.parseInt(requestParam), res);</p><p class="source-code">      }</p><p class="source-code">      return handleGetAll(res);</p><p class="source-code">    case "POST":</p><p class="source-code">      return handleCreate(req, res);</p><p class="source-code">    case "PUT":</p><p class="source-code">      return handleUpdate(req, res);</p><p class="source-code">    default:</p><p class="source-code">      app.handleError(res, 404, "Not Found.");</p><p class="source-code">  }</p><p class="source-code">};</p></li>
				<li>Now it's time to try our application. We installed <strong class="source-inline">ts-node</strong> earlier. This library allows us to transpile and run our TypeScript program in a single step. It is not necessarily recommended to use <strong class="source-inline">ts-node</strong> in production, but it makes for a very handy development tool. Let's try it now:<p class="source-code"> npx ts-node app.ts</p><p>You should see the following on your console:</p><p class="source-code">Application is ready!</p><p>This implies that your application is ready to start receiving requests. If not, you may have a typo somewhere. Let's try it out. You can either use a REST client or curl. This exercise uses Postman</p></li>
				<li>If you make a <strong class="source-inline">GET</strong> request to <strong class="source-inline">http://localhost:3000/promise</strong>, you will get an empty array ([]) back: <div id="_idContainer145" class="IMG---Figure"><img src="image/B14508_12_03.jpg" alt="Figure 12.3: Initial GET request&#13;&#10;"/></div><p class="figure-caption">Figure 12.3: Initial GET request</p><p>This is because we haven't created any records yet. </p></li>
				<li>Try a <strong class="source-inline">POST</strong> with the payload <strong class="source-inline">{"desc":"Always lint your code"}</strong>: <div id="_idContainer146" class="IMG---Figure"><img src="image/B14508_12_04.jpg" alt="Figure 12.4: POST data&#13;&#10;"/></div><p class="figure-caption">Figure 12.4: POST data</p></li>
				<li>Now the <strong class="source-inline">GET</strong> request returns <strong class="source-inline">[{"id":1,"desc":"Always lint your code"}]</strong>: <div id="_idContainer147" class="IMG---Figure"><img src="image/B14508_12_05.jpg" alt="Figure 12.5: Use GET to retrieve data&#13;&#10;"/></div><p class="figure-caption">Figure 12.5: Use GET to retrieve data</p></li>
				<li>If you do a request to <strong class="source-inline">http://localhost:3000/promise/1</strong>, you will get a single object back: <div id="_idContainer148" class="IMG---Figure"><img src="image/B14508_12_06.jpg" alt="Figure 12.6: Single object&#13;&#10;"/></div><p class="figure-caption">Figure 12.6: Single object</p></li>
				<li>If you request <strong class="source-inline">http://localhost:3000/promise/2</strong>, you will get nothing: <div id="_idContainer149" class="IMG---Figure"><img src="image/B14508_12_07.jpg" alt="Figure 12.7: No items found&#13;&#10;"/></div><p class="figure-caption">Figure 12.7: No items found</p></li>
				<li>If you request <strong class="source-inline">http://localhost:3000/something-else</strong>, you will get a 404 response: </li>
			</ol>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/B14508_12_08.jpg" alt="Figure 12.8: 404 response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8: 404 response</p>
			<p>Looks like things are working. Experiment with the different HTTP verbs. Try giving invalid input and see how the error handling works. We'll use this API in the next section.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor315"/>Putting It All Together – Building a Promise App</h1>
			<p>We've learned techniques for using promises in web projects as well as Node.js APIs. Let's combine our earlier exercises to build a web application that renders progressively as data is ready and makes use of asynchronous programming on the server to avoid blocking the event loop.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor316"/>Activity 12.01: Building a Promise App</h2>
			<p>In this activity, we're going to build a web application that talks to the API we just built. Although frameworks such as Angular, React, and Vue are very popular, those are covered in later chapters so we will build a very basic TypeScript application with no bells or whistles.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This activity provides a UI application that communicates with the backend API we built in <em class="italic">Exercise 12.06</em>, <em class="italic">Implementing a RESTful API backed by sqlite</em>. In order to get the output shown, you will need to have your API running. Return to that exercise for help if you need it.</p>
			<p>This UI application will connect to our API and allow us to modify the data we store in our database. We will be able to list out the data we've saved (the promises we make), create new items to save, and delete items. Our UI application will need to make <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">DELETE</strong> calls to our backend API. It will need to use an HTTP client to do that. We could install a library such as <strong class="source-inline">axios</strong> to handle that or we could use the native Fetch API available in all modern web browsers.</p>
			<p>Our web application will also need to be able to dynamically update the UI. Modern view libraries such as <strong class="source-inline">react</strong> or <strong class="source-inline">vue</strong> do that for us, but in this case we are framework-free so we'll need to use more DOM (document object model) APIs such as <strong class="source-inline">getElementById</strong>, <strong class="source-inline">createElement</strong>, and <strong class="source-inline">appendChild</strong>. These are natively available in all web browsers with no libraries needed.</p>
			<p>Implementing this application using promises will be critical because all of the API calls will be asynchronous. We will perform an action, such as a click, our application will call the API, then it will respond with data and then and only then will the promise resolve and cause a change in the DOM state.</p>
			<p>Here are some high-level steps that will enable you to create the app:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/RlYli">https://packt.link/RlYli</a>.</p>
			<ol>
				<li value="1">Create a static <strong class="source-inline">html</strong> page with <strong class="source-inline">css</strong> to be served via <strong class="source-inline">http-server</strong> for local development.</li>
				<li>Add an <strong class="source-inline">app.ts</strong> file to make a web request to the backend using <strong class="source-inline">fetch</strong> and do the required DOM manipulation based on the response.</li>
				<li>Transpile the <strong class="source-inline">app.ts</strong> file into <strong class="source-inline">app.js</strong> and test against the local server using a web browser.</li>
				<li>Make adjustments to <strong class="source-inline">app.ts</strong> and continue testing until all the scenarios are working.<p>Once you have completed the activity, you should be able to view the form on <strong class="source-inline">localhost:8080</strong>. An example is shown here:</p></li>
			</ol>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/B14508_12_09.jpg" alt="Figure 12.9: Completed form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.9: Completed form</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor441">this link</a>.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor317"/>Summary</h1>
			<p>We have learned how promises came to be a part of the ECMAScript standard, taken a tour of the native implementation, and worked through sample projects using promises to solve real-world problems. We also explored how TypeScript can enhance the promise spec and how we can polyfill promises when targeting environments that don't include native promise support. We contrasted the Bluebird promise library with native promises. We learned about different ways of interacting with the filesystem using Node.js and we also covered managing asynchronous database connections and queries. In the end, we put all of this together into a working application.</p>
			<p>In the next chapter, we will build upon the asynchronous programming paradigm by covering <strong class="source-inline">async</strong> and <strong class="source-inline">await</strong>. We'll discuss when to use these over promises and the place promises still have in the TypeScript ecosystem.</p>
		</div>
		<div>
			<div id="_idContainer153" class="Content">
			</div>
		</div>
	</body></html>