<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-234">12. <a id="_idTextAnchor283"/>Guide to Promises in TypeScript</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter explores asynchronous programming in TypeScript using promises and discusses uses for asynchronous programming and how it is implemented in single-threaded JavaScript with the event loop. By the end of the chapter, you should have a solid understanding of how promises work and how TypeScript can enhance them. You will also be able to build a promise-based app using the concepts taught in this chapter.</p>
			<h1 id="_idParaDest-235"><a id="_idTextAnchor284"/>Introduction</h1>
			<p>In the previous chapter, we learned about asynchronous programming using callbacks. With this knowledge, we can manage concurrent requests and write non-blocking code that allows our applications to render web pages faster or serve concurrent requests on a Node.js server.</p>
			<p>In this chapter, we will learn how promises allow us to write more readable, concise code to better manage asynchronous processes and forever escape deep callback nesting, sometimes known as "callback hell." We will explore the evolution of the <code>Promise</code> object and how it eventually became part of the JavaScript language. We'll look at different transpilation targets for TypeScript and how TypeScript can enhance promises and allow developers to leverage generics to infer return types.</p>
			<p>We will work on some practical exercises, such as managing multiple API requests from a website and managing concurrency in Node.js. We will use the Node.js FileSystem API to perform asynchronous operations on files and see how powerful asynchronous programming can be.</p>
			<h1 id="_idParaDest-236"><a id="_idTextAnchor285"/>The Evolution of and Motivation for Promises</h1>
			<p>As we've learned, a callback is a function that is given as an argument to another function, in effect saying, "do this when you are done." This capability has been in JavaScript since its inception in 1995 and can work very well, but as the complexity of JavaScript applications grew through the 2000s, developers found callback patterns and nesting in particular to be too messy and unreadable, giving rise to complaints about "callback hell" as shown in the following example:</p>
			<pre>doSomething(function (err, data) {
  if(err) {
    console.error(err);
  } else {
    request(data.url, function (err, response) {
      if(err) {
        console.error(err);
      } else {
        doSomethingElse(response, function (err, data) {
          if(err) {
            console.error(err);
          } else {
            // ...and so it goes!
          }
        })
      }
    })
  }
});</pre>
			<p>In addition to making code more readable and concise, promises have advantages beyond callbacks in that promises are objects that contain the state of the resolving asynchronous function. This means that a promise can be stored and either queried for the current state or called via its <code>then()</code> or <code>catch()</code> methods at any time to obtain the resolved state of the promise. We'll discuss those methods later in this chapter, but it's worth calling out at the beginning here that promises are more than syntactic sugar. They open up entirely new programming paradigms in which event handling logic can be decoupled from the event itself, just by storing the event in a promise.</p>
			<p>Promises are not unique to JavaScript but were first proposed as a computer programming concept in the 1970s. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information, refer to  Friedman, Daniel; David Wise (1976). <em class="italic">The Impact of Applicative Programming on Multiprocessing</em>. International Conference on Parallel Processing. pp. 263–272.</p>
			<p>As web frameworks gained popularity, proposals for promises started to appear in 2009 and libraries such as jQuery started implementing promise-like objects in 2011. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information, refer to the following: <a href="https://groups.google.com/g/commonjs/c/6T9z75fohDk">https://groups.google.com/g/commonjs/c/6T9z75fohDk</a> and <a href="https://api.jquery.com/category/version/1.5/">https://api.jquery.com/category/version/1.5/</a></p>
			<p>It wasn't long before Node.js started to have some promise libraries as well. Google's AngularJS bundled the Q library. All of these libraries wrapped callbacks in a higher-level API that appealed to developers and helped them to write cleaner and more readable code.</p>
			<p>In 2012, promises were proposed as an official specification in order to standardize the API. The specification was accepted in 2015 and has since been implemented in all major browsers as well as Node.js. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more details, refer to <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor">http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor</a>.</p>
			<p>"Promisification," the ability to wrap an existing asynchronous function in a promise, was added to many libraries and became part of the <code>util</code> package in the standard Node.js library as of version 8.0 (released in 2017).</p>
			<p>TypeScript, as a superset of JavaScript, will always support native language features such as promises; however, TypeScript does not provide polyfills, so if the target environment doesn't support native promises, a library is required.</p>
			<p>Most JavaScript runtimes (such as a web browser or Node.js server) are single-threaded execution environments. That means the main JavaScript process will only do one thing at a time. Thanks to the event loop, the runtime will seem like it's capable of doing many things at once as long as we write non-blocking code. The event loop recognizes asynchronous events and can turn to other tasks while it waits for those events to resolve.</p>
			<p>Consider the example of a web page that needs to call an API to load data into a table. If that API call were blocking, then that would mean the page render couldn't complete until the data loaded. Our user would have to stare at a blank page until all the data loaded and page elements rendered. But because of the event loop, we can register a listener that allows rendering of the website to continue and then load the table when our data is finally returned. This is visualized in the following figure:</p>
			<div><div><img src="img/B14508_12_01.jpg" alt="Figure 12.1: A typical event loop&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1: A typical event loop</p>
			<p>This can be implemented using callbacks or promises. The event loop is what makes this possible. Node.js works similarly, but now we may be responding to requests from a multitude of clients. In this simple example, three different requests are being made: </p>
			<div><div><img src="img/B14508_12_02.jpg" alt="Figure 12.2: Multiple requests&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.2: Multiple requests</p>
			<p>The API is not blocking so additional requests can come in even when the initial one has not been served. The requests are served in the order the work is completed.</p>
			<h1 id="_idParaDest-237"><a id="_idTextAnchor286"/>Anatomy of a Promise</h1>
			<p>A promise is a JavaScript object that can exist in three states: <em class="italic">pending</em>, <em class="italic">fulfilled</em>, or <em class="italic">rejected</em>. Although promises can be instantly fulfilled or rejected, it is most typical for a promise to be created in a pending state and then resolved to be fulfilled or rejected as an operation succeeds or fails. Promises are chainable and implement several convenience methods that we'll go into.</p>
			<p>To understand the states of a promise better, it's important to know that the states of a promise cannot be queried. As a programmer, we do not check the state of the promise and take action based on that state. Rather we provide a function callback that will be invoked when the promise reaches that state. For example, we make an HTTP request to our backend server and get a promise in response. Now we have set up our event and we merely need to tell the promise what to do next and how to handle any errors. Examples of this will follow.</p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor287"/>The Promise Callback</h2>
			<p>A promise can be instantiated using the <code>new</code> keyword and <code>Promise</code> constructor. When instantiated in this way, <code>Promise</code> expects a callback argument that contains the actual work to be done. The callback has two arguments of its own, <code>resolve</code> and <code>reject</code>. These arguments can be called explicitly to either resolve or reject the promise. For example, we can create a promise that resolves after 100 ms like this:</p>
			<pre>new Promise&lt;void&gt;((resolve, reject) =&gt; {
  setTimeout(() =&gt; resolve(), 100);
});</pre>
			<p>We could also create a promise that rejects after 100 ms:</p>
			<pre>new Promise&lt;void&gt;((resolve, reject) =&gt; {
  setTimeout(() =&gt; reject(), 100);
});</pre>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor288"/>then and catch</h2>
			<p>Promises can be chained into callback functions of their own using <code>then</code> and <code>catch</code>. The callback function given to <code>then</code> will fire only once the promise is fulfilled and the callback function given to <code>catch</code> will only fire if the promise is rejected. Most libraries that return promises will automatically call <code>resolve</code> and <code>reject</code>, so we only need to provide <code>then</code> and <code>catch</code>. Here's an example using the Fetch API:</p>
			<pre>fetch("https://my-server.com/my-resource")
  .then(value =&gt; console.log(value))
  .catch(error =&gt; console.error(error));</pre>
			<p>This code will make a call to our backend server and log out the result. If the call fails, it'll log that too.</p>
			<p>If this were a real application, we might have a couple of functions, <code>showData</code> and <code>handleError</code>, that could manage what our application does with the response from the server. In that case, the use of <code>fetch</code> would likely be something like this:</p>
			<pre>fetch("https://my-server.com/my-resource")
  .then(data =&gt; showData(data))
  .catch(error =&gt; handleError(error));</pre>
			<p>Using promises like this shows how we can decouple our asynchronous processes from business logic and display elements.</p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor289"/>Pending State</h2>
			<p>A pending promise is one that has yet to complete its work. It's simple to create a promise that is forever stuck in a pending state:</p>
			<pre>const pendingPromise = new Promise((resolve, reject) =&gt; {});
console.log(pendingPromise);</pre>
			<p>This promise will never do anything as neither <code>resolve</code> nor <code>reject</code> are ever called. The promise will remain in a pending state. If we execute this code, it'll print out <code>Promise { &lt;pending&gt; }</code>. As noted above, we do not query the state of a promise but rather provide a callback for the eventual resolution of a promise. The sample code above contains a promise that can never be resolved and as such could be seen as invalid code. There is no use case for promises that cannot resolve.</p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor290"/>Fulfilled State</h2>
			<p>We can create a promise that is fulfilled immediately:</p>
			<pre>const fulfilledPromise = new Promise(resolve =&gt; {
  resolve("fulfilled!");
});
console.log(fulfilledPromise);</pre>
			<p>This will log out <code>Promise { 'fulfilled!' }</code>. </p>
			<p>Unlike the pending state, creating a promise that resolves immediately has a few more practical use cases. The primary use of an immediately resolved promise would be when working with an API that expects a promise. </p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor291"/>Rejected State</h2>
			<p>We can create a promise that is fulfilled immediately:</p>
			<pre>const rejectedPromise = new Promise((resolve, reject) =&gt; {
  reject("rejected!");
});
console.log(rejectedPromise);</pre>
			<p>This will log out <code>Promise { &lt;rejected&gt; 'rejected!' }</code> and then throw an unhandled promise rejection warning. Rejected promises always need to be caught. Failure to catch a promise rejection may cause our program to crash!</p>
			<p>As with the fulfilled state, the primary use case for immediately rejecting a promise would be for writing a good unit test, but there may be secondary use cases in which some process throws an error during an asynchronous workflow and it may make sense to return a rejected promise. This circumstance would be most likely when working with a third-party library where the API isn't quite to our liking and we need to wrap it with something more in line with the rest of our application architecture.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor292"/>Chaining</h2>
			<p>One of the main advantages of promises over callbacks is the ability to chain promises together. Consider a function that waits 1 second, generates a random number between 0 and 99, and adds it to the previous result. There are better ways to write recursive functions, but this is meant to simulate a website making several calls to a backend:</p>
			<pre>Example01.ts
1  const getTheValue = async (val: number, cb: Function) =&gt; {
2    setTimeout(() =&gt; {
3      const number = Math.floor(Math.random() * 100) + val;
4      console.log(`The value is ${number}`);
5      cb(number);
6    }, 1000);
7  };
8  
9  getTheValue(0, (output: number) =&gt; {
10    getTheValue(output, (output: number) =&gt; {
11      getTheValue(output, (output: number) =&gt; {
12        getTheValue(output, (output: number) =&gt; {
13          getTheValue(output, (output: number) =&gt; {
14            getTheValue(output, (output: number) =&gt; {
15              getTheValue(output, (output: number) =&gt; {
16                getTheValue(output, (output: number) =&gt; {
17                  getTheValue(output, (output: number) =&gt; {
18                    getTheValue(output, () =&gt; {});
19                  });
20                });
21              });
22            });
23          });
24        });
25      });
26    });
27  });
Link to the example: <a href="https://packt.link/VHZJc">https://packt.link/VHZJc</a></pre>
			<p>A sample output of this program is the following:</p>
			<pre>The value is 49
The value is 133
The value is 206
The value is 302
The value is 395
The value is 444
The value is 469
The value is 485
The value is 528
The value is 615</pre>
			<p>Each time we call <code>getTheValue</code>, we wait 1 second, then generate a random number and add it to the value we passed in. In a real-world scenario, we can think of this as a program that completes several asynchronous tasks, using the output from the last one as input to the next. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">As the starting point of the program is a random number, your output would be different from the one presented above.</p>
			<p>Everything in the previous program works correctly; however, the callback nesting isn't very nice to look at and could be challenging to maintain or debug. The next exercise will teach you how you can write more readable and maintainable code using promises.</p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor293"/>Exercise 12.01: Chaining Promises</h2>
			<p>In this exercise, we will refactor the preceding example and chain promises to eliminate nesting and make the code more readable:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/IO8Pz">https://packt.link/IO8Pz</a>.</p>
			<ol>
				<li>Write the following program, which refactors the previous example using promises:<pre>const getTheValue = async (val: number): Promise&lt;number&gt; =&gt; {
  return new Promise(resolve =&gt; {
    setTimeout(() =&gt; {
      const number = Math.floor(Math.random() * 100) + val;
      console.log(`The value is ${number}`);
      resolve(number);
    }, 1000);
  });
};
getTheValue(0)
  .then((result: number) =&gt; getTheValue(result))
  .then((result: number) =&gt; getTheValue(result))
  .then((result: number) =&gt; getTheValue(result))
  .then((result: number) =&gt; getTheValue(result))
  .then((result: number) =&gt; getTheValue(result))
  .then((result: number) =&gt; getTheValue(result))
  .then((result: number) =&gt; getTheValue(result))
  .then((result: number) =&gt; getTheValue(result))
  .then((result: number) =&gt; getTheValue(result));</pre><p>The nesting is gone and the code is a lot more readable. Our <code>getTheValue</code> function now returns a promise instead of using a callback. Because it returns a promise, we can call <code>.then()</code> on the promise, which can be chained into another promise call. </p></li>
				<li>Run the program. The chain of promises will resolve each in turn and we'll get similar output to the previous program:<pre>The value is 50
The value is 140
The value is 203
The value is 234
The value is 255
The value is 300
The value is 355
The value is 395
The value is 432
The value is 451</pre><p>Note that you will get an output that is different from the one shown above because the program uses a random number as the starting point.</p></li>
			</ol>
			<p>Chaining can also be a big help when it comes to error conditions. If my <code>getTheValue</code> function rejects the promise, I'm able to catch the error by chaining a single <code>catch</code> to the end of the chain:</p>
			<pre>Example02.ts
1  const getTheValue = async (val: number): Promise&lt;number&gt; =&gt; {
2   return new Promise((resolve, reject) =&gt; {
3      setTimeout(() =&gt; {
4        const number = Math.floor(Math.random() * 100) + val;
5        if (number % 10 === 0) {
6          reject("Bad modulus!");
7        } else {
8          console.log(`The value is ${number}`);
9          resolve(number);
10        }
11      }, 1000);
12    });
13  };
14  
15  getTheValue(0)
16    .then((result: number) =&gt; getTheValue(result))
17    .then((result: number) =&gt; getTheValue(result))
18    .then((result: number) =&gt; getTheValue(result))
19    .then((result: number) =&gt; getTheValue(result))
20    .then((result: number) =&gt; getTheValue(result))
21    .then((result: number) =&gt; getTheValue(result))
22    .then((result: number) =&gt; getTheValue(result))
23    .then((result: number) =&gt; getTheValue(result))
24    .then((result: number) =&gt; getTheValue(result))
25    .catch(err =&gt; console.error(err));
Link to the example: <a href="https://packt.link/sBTgk">https://packt.link/sBTgk</a></pre>
			<p>We are introducing a 10% chance (the chance our number when divided by 10 will have a remainder of 0) of throwing an error on each iteration. On average, our program will fail more often than it executes successfully now:</p>
			<pre>The value is 25
The value is 63
The value is 111
Bad modulus!</pre>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor294"/>finally</h2>
			<p>In addition to <code>then</code> and <code>catch</code> methods, the <code>Promise</code> object also exposes a <code>finally</code> method. This is a callback function that will be called regardless of whether an error is thrown or caught. It's great for logging, closing a database connection, or simply cleaning up resources, regardless of how the promise is eventually resolved.</p>
			<p>We can add a <code>finally</code> callback to the above promise:</p>
			<pre>Example03.ts
1  const getTheValue = async (val: number) =&gt; {
2    return new Promise&lt;number&gt;((resolve, reject) =&gt; {
3      setTimeout(() =&gt; {
4        const number = Math.floor(Math.random() * 100) + val;
5        if (number % 10 === 0) {
6          reject("Bad modulus!");
7        } else {
8          console.log(`The value is ${number}`);
9          resolve(number);
10      }
11     }, 1000);
12   });
13 };
14 
15 getTheValue(0)
16   .then(result =&gt; getTheValue(result))
17   .then(result =&gt; getTheValue(result))
18   .then(result =&gt; getTheValue(result))
19   .then(result =&gt; getTheValue(result))
20   .then(result =&gt; getTheValue(result))
21   .then(result =&gt; getTheValue(result))
22   .then(result =&gt; getTheValue(result))
23   .then(result =&gt; getTheValue(result))
24   .then(result =&gt; getTheValue(result))
25   .catch(err =&gt; console.error(err))
26   .finally(() =&gt; console.log("We are done!"));
Link to the example: <a href="https://packt.link/izqwS">https://packt.link/izqwS</a></pre>
			<p>Now <code>"We are done!"</code> will be logged regardless of whether or not we trip the <code>"Bad modulus!"</code> error condition:</p>
			<pre>The value is 69
The value is 99
Bad modulus!
We are done!</pre>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor295"/>Promise.all</h2>
			<p><code>Promise.all</code> is one of the most useful utility methods that <code>Promise</code> has to offer. Even code written with async/await syntax (see <em class="italic">Chapter 13, Async/Await</em>) can make good use of <code>Promise.all</code>. This method takes an iterable (likely an array) of promises as an argument and resolves all of them. Let's see how we can change our example promise using <code>Promise.all</code>:</p>
			<pre>Example04.ts
1  const getTheValue = async (val: number = 0) =&gt; {
2    return new Promise&lt;number&gt;((resolve, reject) =&gt; {
3      setTimeout(() =&gt; {
4        const number = Math.floor(Math.random() * 100) + val;
5        if (number % 10 === 0) {
6          reject("Bad modulus!");
7        } else {
8          console.log(`The value is ${number}`);
9          resolve(number);
10       }
11     }, 1000);
12   });
13 };
14
15 Promise.all([
16   getTheValue(),
17   getTheValue(),
18   getTheValue(),
19   getTheValue(),
20   getTheValue(),
21   getTheValue(),
22   getTheValue(),
23   getTheValue(),
24   getTheValue(),
25   getTheValue()
26 ])
27   .then(values =&gt;
28     console.log(
29       `The total is ${values.reduce((prev, current) =&gt; prev + current, 0)}`
30     )
31   )
32   .catch(err =&gt; console.error(err))
33   .finally(() =&gt; console.log("We are done!"));
Link to the example: <a href="https://packt.link/8pzx4">https://packt.link/8pzx4</a></pre>
			<p>The output should be similar to the ones obtained for the preceding examples. In this example, we call the same function 10 times, but imagine these are 10 different API calls we need to reach and then sum the total. Each call takes approximately 1 second. If we chain a series of promises, this operation will take just over 10 seconds. By using <code>Promise.all</code>, we are able to run those operations in parallel and now it takes only 1 second to complete the function.</p>
			<p><code>Promise.all</code> is useful any time you can run two or more asynchronous processes in parallel. It can be useful for persisting data to multiple database tables, letting multiple independent components render in a web browser independently, or making multiple HTTP requests. A good example of making multiple HTTP requests in parallel would be a service that monitors the uptime and ping duration of other services. There's no reason such an operation would need to be synchronous and <code>Promise.all</code> lets us wait on several web requests within the same process.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor296"/>Exercise 12.02: Recursive Promise.all</h2>
			<p>In this exercise, instead of repeating the same function call 10 times, let's optimize the programs from the previous examples to be more DRY (don't repeat yourself). We can load up an array of promises and then use <code>Promise.all</code> to resolve all the promises in parallel and use <code>catch</code> and <code>finally</code> to resolve errors and ensure we return some output:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/KNpqx">https://packt.link/KNpqx</a>.</p>
			<ol>
				<li value="1">The following code will be our starting place for this refactor:<pre>const getTheValue = async (val: number = 0) =&gt; {
  return new Promise&lt;number&gt;((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      const number = Math.floor(Math.random() * 100) + val;
      if (number % 10 === 0) {
        reject('Bad modulus!');
      } else {
        console.log(`The value is ${number}`);
        resolve(number);
      }
    }, 1000);
  });
};
Promise.all([
  getTheValue(),
  getTheValue(),
  getTheValue(),
  getTheValue(),
  getTheValue(),
  getTheValue(),
  getTheValue(),
  getTheValue(),
  getTheValue(),
  getTheValue(),
])
  .then((values) =&gt;
    console.log(
      `The total is ${values.reduce((prev, current) =&gt; prev + current, 0)}`
    )
  )
  .catch((err) =&gt; console.error(err))
  .finally(() =&gt; console.log('We are done!'));</pre><p>In order to catch errors and make the program recursive, we'll need to wrap <code>Promise.all</code> in a function. Recursion is a pattern in which the same function can be called multiple times within the same execution. </p></li>
				<li>To add the recursion, create a new function and make the <code>Promise.all</code> statement the body of that function. Then call the function:<pre>const doIt = () =&gt; {
  Promise.all([
    getTheValue(),
    getTheValue(),
    getTheValue(),
    getTheValue(),
    getTheValue(),
    getTheValue(),
    getTheValue(),
    getTheValue(),
    getTheValue(),
    getTheValue(),
])
  .then((values) =&gt;
      console.log(
        `The total is ${values.reduce((prev, current) =&gt; prev + current, 0)}`
      )
  )
  .catch((err) =&gt; console.error(err))
  .finally(() =&gt; console.log('We are done!'));</pre><p>We can use some functional programming techniques to, rather than having an array in which <code>getTheValue()</code> is repeated 10 times, programmatically construct an array of 10 elements, all of which are that function call. Doing this won't change how our program operates, but it will make it a bit nicer to work with. </p></li>
				<li>Update the code given in the preceding step with the following:<pre>  Promise.all(
  Array(10)
    .fill(null)
    .map(() =&gt; getTheValue())
)</pre><p>The logic here is that <code>Array(10)</code> creates a new array of 10 elements, <code>fill(null)</code> will initialize the array, then <code>map</code> will remap the array elements to be the <code>getTheValue()</code> function call. </p><p>Th above code actually calls the function and returns the pending promise to the array that is already wrapped in <code>Promise.all</code>.</p><p>Now we want to use recursion in the case of an error. We will change our <code>catch()</code> callback from simply logging the error to starting the process over again. In this case, our business rule is we want the entire set of calculations to complete and we will restart if there is an error. The code to do this is very easy as <code>catch()</code> expects a function as its callback so we can just pass our <code>doIt</code> function back to it again.</p></li>
				<li>Pass the <code>doIt</code> function back to <code>catch()</code>:<pre>  .catch(doIt)</pre><p>Note that we do not invoke the callback function here. We want to pass a function and it will be invoked in the case of an error.</p></li>
				<li>We will now want to clean up our error messages a little so we can have a clean run:<pre>const getTheValue = async (val: number = 0) =&gt; {
  return new Promise&lt;number&gt;((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      const number = Math.floor(Math.random() * 100) + val;
      if (number % 10 === 0) {
        reject('Bad modulus!');
      } else {
        // console.log(`The value is ${number}`);
        resolve(number);
      }
    }, 1000);
  });
};
let loopCount = 0;
const doIt = () =&gt; {
  Promise.all(
    Array(10)
      .fill(null)
      .map(() =&gt; getTheValue())
  )
    .then((values) =&gt;
      console.log(
        `The total is ${values.reduce((prev, current) =&gt; prev + current, 0)}`
      )
    )
    .catch(doIt)
    .finally(() =&gt; console.log(`completed loop ${++loopCount}`));
};
doIt();</pre><p>When we run the program, we'll see a few iterations of the program looping. The output may be something like this:</p><pre>completed loop 1
The total is 438
completed loop 2</pre><p>Note that depending on the number of iterations, you might get an output different from the one shown above.</p></li>
			</ol>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor297"/>Promise.allSettled</h2>
			<p>This method is a variation on <code>Promise.all</code>, which is ideal for when it's acceptable for some of our promises to resolve successfully and some of them to be rejected. Let's see how it's different from <code>Promise.all</code>:</p>
			<pre>const getTheValue = async (val: number = 0) =&gt; {
  return new Promise&lt;number&gt;((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      const number = Math.floor(Math.random() * 100) + val;
      // Arbitrary error condition - if the random number is divisible by 10.
      if (number % 10 === 0) {
        reject("Bad modulus!");
      } else {
        console.log(`The value is ${number}`);
        resolve(number);
      }
    }, 1000);
  });
};
const generateTheNumber = (iterations: number): void =&gt; {
  Promise.allSettled(
    // Produces an array of `iterations` length with the pending promises of `getTheValue()`.
    Array(iterations)
      .fill(null)
      .map(() =&gt; getTheValue())
  )
    .then((settledResults) =&gt; {
      // Map all the results into the failed, succeeded and total values.
      const results = settledResults.reduce(
        (prev, current) =&gt; {
          return current.status === "fulfilled"
            ? {
                ...prev,
                succeeded: prev.succeeded + 1,
                total: prev.total + current.value,
              }
            : { ...prev, failed: prev.failed + 1 };
        },
        {
          failed: 0,
          succeeded: 0,
          total: 0,
        }
      );
      console.log(results);
    })
    .finally(() =&gt; console.log("We are done!"));
};
generateTheNumber(10);</pre>
			<p>The program will generate output like this:</p>
			<pre>current { status: 'fulfilled', value: 85 }
current { status: 'fulfilled', value: 25 }
current { status: 'fulfilled', value: 11 }
current { status: 'fulfilled', value: 43 }
current { status: 'rejected', reason: 'Bad modulus!' }
current { status: 'fulfilled', value: 41 }
current { status: 'fulfilled', value: 81 }
current { status: 'rejected', reason: 'Bad modulus!' }
current { status: 'rejected', reason: 'Bad modulus!' }
current { status: 'fulfilled', value: 7 }
{ failed: 3, succeeded: 7, total: 293 } 
We are done!</pre>
			<p>We've made a couple of enhancements here. For one thing, we are now passing the array size into <code>generateTheNumber</code>, which can give a bit more flavor or variation to our program. The main improvement now is the use of <code>Promise.allSettled</code>. Now, <code>Promise.allSettled</code> allows us to have a mix of successes and failures, unlike <code>Promise.all</code>, which will call the <code>then()</code> method if all the promises resolve successfully or call the <code>catch()</code> method if any of them fail. The output of <code>Promise.allSettled</code> could look something like this:</p>
			<pre>settledResults [
  { status: 'fulfilled', value: 85 },
  { status: 'fulfilled', value: 25 },
  { status: 'fulfilled', value: 11 },
  { status: 'fulfilled', value: 43 },
  { status: 'rejected', reason: 'Bad modulus!' },
  { status: 'fulfilled', value: 41 },
  { status: 'fulfilled', value: 81 },
  { status: 'rejected', reason: 'Bad modulus!' },
  { status: 'rejected', reason: 'Bad modulus!' },
  { status: 'fulfilled', value: 7 }
]</pre>
			<p>Each of the resolved promises will have a status containing the string <code>'fulfilled'</code> if the promise resolved successfully or <code>'rejected'</code> if there was an error. Fulfilled promises will have a <code>value</code> property containing the value the promise resolved to and rejected promises will have a <code>reason</code> property containing the error.</p>
			<p>In the example given, we are totaling the rejected promises and summing the values of the fulfilled promises, then returning that as a new object. To perform this operation, we use the built-in array function <code>reduce()</code>. Now, <code>reduce()</code> will iterate over each element of an array and collect transformed results in an accumulator, which is returned by the function. <code>MapReduce</code> functions are common in functional programming paradigms.</p>
			<p>Note that <code>Promise.allSettled</code> is a fairly recent addition to ECMAScript, having landed in Node.js 12.9. In order to use it, you'll need to set your <code>compilerOptions</code> target to <code>es2020</code> or <code>esnext</code> in your <code>tsconfig.json</code> file. Most modern browsers support this method, but it's a good idea to verify support before using this recent feature.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor298"/>Exercise 12.03: Promise.allSettled</h2>
			<p>We've seen an example of using <code>Promise.allSettled</code> to produce a mixed result of fulfilled and rejected promises. Now let's combine <code>Promise.allSettled</code> and <code>Promise.all</code> to aggregate multiple results of our runs of <code>getTheValue()</code>:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/D8jIQ">https://packt.link/D8jIQ</a>.</p>
			<ol>
				<li value="1">Start with the code from the example above. We are going to want to call <code>generateTheNumber()</code> three times. Once we have all the results, we can sort them to print out the highest and lowest results. We can use the same <code>Array().fill().map()</code> technique described above to create a new array of <code>generateTheNumber()</code> calls:<pre>Promise.all(
  Array(3)
    .fill(null)
    .map(() =&gt; generateTheNumber(10))
);</pre></li>
				<li>Now that we can resolve three separate calls, we need to manage the output. First, we can log out the results to see what we need to do next:<pre>Promise.all(
  Array(3)
    .fill(null)
    .map(() =&gt; generateTheNumber(10))
).then((result) =&gt; console.log(result));</pre><p>We log out <code>[undefined, undefined, undefined]</code>. That's not what we wanted. The reason for this is <code>generateTheNumber</code> doesn't actually return its promise – it didn't need to in the prior example. </p></li>
				<li>We can fix that by adding a <code>return</code> statement and removing the <code>void</code> return type. We also need our callback function to return the results instead of simply logging them out. All these changes would help a program like this integrate into a larger application:<pre>const generateTheNumber = (iterations: number) =&gt; {
  return Promise.allSettled(
    Array(iterations)
      .fill(null)
      .map(() =&gt; getTheValue())
  )
    .then((settledResults) =&gt; {
      const results = settledResults.reduce(
        (prev, current) =&gt; {
          return current.status === 'fulfilled'
            ? {
                ...prev,
                succeeded: prev.succeeded + 1,
                total: prev.total + current.value,
              }
            : { ...prev, failed: prev.failed + 1 };
        },
        {
          failed: 0,
          succeeded: 0,
          total: 0,
        }
      );
      return results;
    })
    .finally(() =&gt; console.log('Iteration done!'));
};
With that done we can get our output.
[
  { failed: 0, succeeded: 10, total: 443 },
  { failed: 1, succeeded: 9, total: 424 },
  { failed: 2, succeeded: 8, total: 413 },
]</pre></li>
				<li>The last step to complete this exercise is we only want to output the highest and lowest totals. To accomplish this, we can use the <code>Array.map()</code> function to extract only the totals from the output and the <code>Array.sort()</code> function to order the above output from lowest to highest, then print the totals from the first and last entries:<pre>  const totals = results.map((r) =&gt; r.total).sort();
  console.log(`The highest total is ${totals[totals.length - 1]}.`);
  console.log(`The lowest total is ${totals[0]}.`);</pre><p>You might get an output similar to the following:</p><pre>The value is 62
The value is 77
The value is 75
The value is 61
The value is 61
The value is 61
The value is 15
The value is 83
The value is 4
The value is 23
Iteration done!
.
.
.
The highest total is 522.
The lowest total is 401.</pre><p>Note that only a section of the actual output is displayed for ease of presentation. </p><p>This exercise showed us how we can filter and sort the results of many promises and create data structures that accurately reflect the state of our application.</p></li>
			</ol>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor299"/>Promise.any</h2>
			<p>At the other end of the spectrum from <code>Promise.allSettled</code> lies <code>Promise.any</code>. This method takes an iterable (or array) of promises, but instead of settling all of them, it will resolve to the value of the first promise that resolves successfully. <code>Promise.any</code> is so new it has yet to be implemented in every browser and at the time of writing is not available in the LTS version of Node.js. You should check compatibility and availability before using it.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor300"/>Promise.race</h2>
			<p><code>Promise.race</code> has been around for some time and is similar to <code>Promise.any</code>. Now, <code>Promise.race</code> again takes an iterable of promises and executes them all. The first promise that resolves or rejects will resolve or reject the race. This is in contrast to <code>Promise.any</code> in that if the first promise in <code>Promise.any</code> rejects, the other promises still have an opportunity to resolve successfully:</p>
			<pre>const oneSecond = new Promise((_resolve, reject) =&gt; {
  setTimeout(() =&gt; reject("Too slow!"), 1000);
});
const upToTwoSeconds = new Promise(resolve =&gt; {
  setTimeout(() =&gt; resolve("Made it!"), Math.random() * 2000);
});
Promise.race([oneSecond, upToTwoSeconds])
  .then(result =&gt; console.log(result))
  .catch(err =&gt; console.error(err));</pre>
			<p>In this example, one promise always rejects in 1 second while the other resolves at a random interval between 0 and 2 seconds. If the <code>oneSecond</code> promise wins the race, the entire promise is rejected. If <code>upToTwoSeconds</code> takes less than a second, then the promise resolves successfully with the message <code>"Made It!"</code>.</p>
			<p>A practical example of using <code>Promise.race</code> might be a timeout and fallback feature where if the primary web service can't respond within an expected amount of time, the application either switches to a secondary source for data or exhibits some other behavior. Or perhaps we want to deal with a slow render issue in a web browser where if a screen paint hasn't finished in the expected amount of time, we switch to a simpler view. There are lots of cases where <code>Promise.race</code> can ease the complexity of handling asynchronous operations in TypeScript.</p>
			<h1 id="_idParaDest-252"><a id="_idTextAnchor301"/>Enhancing Promises with Types</h1>
			<p>The example we're working with so far specifies the type of input to the promise, but we have to provide a type for the result in each step of the chain. That's because TypeScript doesn't know what the promise may resolve to so we have to tell it what kind of type we're getting as the result.</p>
			<p>In other words, we're missing out on one of TypeScript's most powerful features: <em class="italic">type inference</em>. Type inference is the ability for TypeScript to know what the type of something should be without having to be told. A very simple example of type inference would be the following:</p>
			<pre>const hello = "hello";</pre>
			<p>No type is specified. This is because TypeScript understands that the variable <code>hello</code> is being assigned a string and cannot be reassigned. If we try to pass this variable as an argument to a function that expects another type, we will get a compilation error, even though we never specified the type. Let's apply type inference to promises.</p>
			<p>First, let's look at the type definition for the <code>Promise</code> object:</p>
			<pre>new &lt;T&gt;(executor: (resolve: (value?: T | PromiseLike&lt;T&gt;) =&gt; void, reject: (reason?: any) =&gt; void) =&gt; void): Promise&lt;T&gt;;</pre>
			<p><code>T</code> is what's known as a generic. It means any type can be specified to take the place of <code>T</code>. Let's say we define a promise like this:</p>
			<pre>new Promise(resolve =&gt; {
  resolve("This resolves!");
});</pre>
			<p>What we're doing here is stating the <code>resolve</code> argument will resolve to an unknown type. The receiving code will need to provide a type for it. This can be improved by adding a type value for <code>T</code>:</p>
			<pre>new Promise&lt;string&gt;(resolve =&gt; {
  resolve("This resolves!");
});</pre>
			<p>Now the promise constructor resolves to a type of <code>Promise&lt;string&gt;</code>. When the promise becomes fulfilled, it is expected to return a type of <code>string</code>.</p>
			<p>Let's examine an example where casting the return type of a promise becomes important:</p>
			<pre>const getPromise = async () =&gt; new Promise(resolve =&gt; resolve(Math.ceil(Math.random() * 100)));
const printResult = (result: number) =&gt; console.log(result);
getPromise().then(result =&gt; printResult(result)); </pre>
			<p>If you put this example into an IDE such as VS Code, you'll see that you have a type error on the <code>result</code> parameter given to <code>printResult</code>. The type that the promise returned by <code>getPromise</code> is unknown but <code>printResult</code> expects <code>number</code>. We can fix this problem by providing a type to the promise when we declare it:</p>
			<pre>const getPromise = async () =&gt; new Promise&lt;number&gt;(resolve =&gt; resolve(Math.ceil(Math.random() * 100)));
const printResult = (result: number) =&gt; console.log(result);
getPromise().then(result =&gt; printResult(result));</pre>
			<p>We have added <code>&lt;number&gt;</code> immediately after our promise declaration and TypeScript knows this promise is expected to resolve to a number. This type-checking will also be applied to the resolution of our promise. For example, if we tried to resolve to a value of <code>"Hello!"</code>, we'd get another type error now that our promise is expected to return a number.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor302"/>Exercise 12.04: Asynchronous Rendering</h2>
			<p>In this exercise, we'll create a simple website with synchronous rendering and refactor it so the rendering is asynchronous: </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/q8rka">https://packt.link/q8rka</a>.</p>
			<ol>
				<li value="1">Clone the project from GitHub (<a href="https://packt.link/q8rka">https://packt.link/q8rka</a>) to begin. Then, install dependencies:<pre>npm i</pre><p>We just installed TypeScript into our project as well as <code>http-server</code>, which is a simple Node.js HTTP server that will allow us to run our website on localhost.</p><p>Now we'll add a few files to get the project started.</p></li>
				<li>In the root of your project, create a file called <code>index.html</code> and add the following lines to it:<pre>&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;The TypeScript Workshop - Exercise 12.03&lt;/title&gt;
    &lt;link href="styles.css" rel="stylesheet"&gt;&lt;/link&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="my-data"&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script type="module" src="img/data-loader.js"&gt;&lt;/script&gt;
&lt;/html&gt;</pre></li>
				<li>Next, optionally add a stylesheet as the default styles are quite an eyesore. Bring your own or use something simple like this:<pre>body {
  font-family: Arial, Helvetica, sans-serif;
  font-size: 12px;
}
input {
  width: 200;
}</pre></li>
				<li>Add a file called <code>data.json</code> to represent the data we are fetching from a remote server:<pre>{ "message": "Hello Promise!" }</pre></li>
				<li>One more to go. Let's add a TypeScript file called <code>data-loader.ts</code>:<pre>const updateUI = (message: any): void =&gt; {
  const item = document.getElementById("my-data");
  if (item) {
    item.innerText = `Here is your data: ${message}`;
  }
};
const message = fetch("http://localhost:8080/data.json");
updateUI(message);</pre><p>That's all you need to run a local service with a TypeScript web application! Later in the book, we'll see some more robust solutions, but for now, this will let us focus on the TypeScript without too many bells or whistles around.</p></li>
				<li>To see our application, we'll need to transpile the TypeScript and start the local server. For the best experience, we'll need two separate Command Prompt windows. In one of them, we'll type a command to transpile the TypeScript and watch for changes:<pre>npx tsc -w data-loader.ts</pre></li>
				<li>And in the other window, we'll start our server with a flag to avoid caching so we can see our changes right away:<pre>npx http-server . -c-1</pre></li>
				<li>If we navigate to <code>http://localhost:8080</code>, we'll see our application load and receive this message:<pre> "Here is your data: [object Promise]". </pre><p>Something hasn't worked correctly. What we want to see is <code>"Here is your data: Hello Promise!"</code>. If we go and look at the TypeScript code, we'll see this line:</p><pre>const message = fetch("http://localhost:8080/data.json");</pre></li>
			</ol>
			<p>This isn't working correctly. <code>fetch</code> is an asynchronous request. We are just seeing the unresolved promise and printing it to the screen.</p>
			<p>Another warning sign is the use of <code>any</code> in the <code>updateUI</code> function. Why is the <code>any</code> type being used there when it should be a string? That's because TypeScript won't allow us to use a string. TypeScript knows we're calling <code>updateUI</code> with an unresolved promise and so we'll get a type error if we try to treat that as a string type. New developers sometimes think they are fixing a problem by using <code>any</code>, but more often than not they will be ignoring valid errors.</p>
			<p>In order to get this code to work correctly, you will need to refactor it so that the promise <code>fetch</code> returns is resolved. When it works correctly, <code>fetch</code> returns a response object that exposes a <code>data</code> method that also returns a promise, so you will need to resolve two promises in order to display the data on your page.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The fetch library is a web API for browsers that is a great improvement on the original <code>XMLHttpRequest</code> specification. It retains all the power of <code>XMLHttpRequest</code> but the API is much more ergonomic and as such is used by many web applications, rather than installing a third-party client library. <code>fetch</code> is not implemented in Node.js natively but there are some libraries that provide the same functionality. We'll take a look at those later in the chapter.</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor303"/>Libraries and Native Promises — Third-Party Libraries, Q, and Bluebird</h1>
			<p>As stated previously, promises became part of the ECMAScript standard in 2015. Up until that point, developers used libraries such as Q or Bluebird to fill the gap in the language. While many developers choose to use native promises, these libraries remain quite popular with weekly downloads still growing. That said, we should carefully consider whether it's a good idea to depend on a third-party library over a native language feature. Unless one of these libraries provides some critical functionality that we can't do without, we should prefer native features over third-party libraries. Third-party libraries can introduce bugs, complexity, and security vulnerabilities and require extra effort to maintain. This isn't an indictment against open source. </p>
			<p>Open source projects (such as TypeScript) are an essential part of today's developer ecosystem. That said, it's still a good idea to carefully choose our dependencies and make sure they are well-maintained libraries that are not redundant with native features.</p>
			<p>It's also worth noting that the APIs of third-party libraries may differ from the native language feature. For example, the Q library borrows a deferred object from the jQuery implementation:</p>
			<pre>import * as Q from "q";
const deferred = Q.defer();
deferred.resolve(123);
deferred.promise.then(val =&gt; console.log(val));</pre>
			<p>This written in a native promise is more like the examples we've seen so far:</p>
			<pre>const p = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  resolve(123);
});
p.then(val =&gt; console.log(val));</pre>
			<p>There's nothing inherently wrong with the Q implementation here, but it's non-standard and this may make our code less readable to other developers or prevent us from learning standard best practices.</p>
			<p>Bluebird is more similar to the native promise. In fact, it could be used as a polyfill.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor304"/>Polyfilling Promises</h2>
			<p>TypeScript will transpile code, but it will <em class="italic">not</em> polyfill native language features that are not present in your target environment. This is critical to understand to avoid frustration and mysterious bugs. What TypeScript will do for us is allow us to specify the target environment. Let's look at a simple example.</p>
			<p>Consider the following <code>tsconfig.json</code> file:</p>
			<pre>{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "outDir": "./public",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true
  }
}</pre>
			<p>Now consider this module in <code>promise.ts</code>:</p>
			<pre>const p = new Promise&lt;number&gt;((resolve, reject) =&gt; {
  resolve(123);
});
p.then(val =&gt; console.log(val));</pre>
			<p>Our code will transpile fine. We enter <code>npx</code> <code>tsc</code> and the transpiled JavaScript output looks very much like our TypeScript code. The only difference is the type has been removed:</p>
			<pre> const p = new Promise((resolve, reject) =&gt; {
    resolve(123);
});
p.then(val =&gt; console.log(val));</pre>
			<p>However, consider if we change the target to <code>es5</code>:</p>
			<pre>{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "outDir": "./public",
    "strict": true,
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true
  }
}</pre>
			<p>Now the project will no longer build:</p>
			<pre>% npx tsc
src/promise.ts:1:15 - error TS2585: 'Promise' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the `lib` compiler option to es2015 or later.
1 const p = new Promise&lt;number&gt;((resolve, reject) =&gt; {
                ~~~~~~~
Found 1 error.</pre>
			<p>TypeScript even warns me that I might want to fix my target. Note that <code>"es2015"</code> and <code>"es6"</code> are the same thing (as are <code>"es2016"</code> and <code>"es7"</code>, and so on). This is a somewhat confusing convention that we simply need to get used to.</p>
			<p>This will be fine if I can build my project for an <code>es6+</code> environment (such as a current version of Node.js or any modern browser), but if I need to support a legacy browser or a very old version of Node.js, then "fixing" this by setting the compilation target higher will only result in a broken application. We'll need to use a polyfill.</p>
			<p>In this case, Bluebird can be a really good choice as it has an API very similar to native promises. In fact, all I will need to do is <code>npm</code> <code>install</code> <code>bluebird</code> and then import the library into my module. The Bluebird library does not include typings so to have full IDE support, you'd need to also <code>install</code> <code>@types/bluebird</code> as a <code>devDependency</code>:</p>
			<pre>import { Promise } from "bluebird";
const p = new Promise&lt;number&gt;(resolve =&gt; {
  resolve(123);
});
p.then(val =&gt; console.log(val));</pre>
			<p>My transpiled code will now run in a very early version of Node.js, such as version 0.10 (released in 2013).</p>
			<p>Note that Bluebird is designed to be a full-featured <code>Promise</code> library. If I'm just looking for a polyfill, I might prefer to use something like <code>es6-promise</code>. Its use is exactly the same. I <code>npm</code> <code>install</code> <code>es6-promise</code> and then import the <code>Promise</code> class into my module:</p>
			<pre>import { Promise } from "es6-promise";
const p = new Promise&lt;number&gt;(resolve =&gt; {
  resolve(123);
});
p.then(val =&gt; console.log(val));</pre>
			<p>If you want to try this yourself, be aware that modern versions of TypeScript won't even run on Node.js 0.10! You'll have to transpile your code in a recent version (such as Node.js 12) and then switch to Node.js 0.10 to execute the code. To do this, it's a good idea to use a version manager such as <code>nvm</code> or <code>n</code>.</p>
			<p>This is actually a great example of the power of TypeScript. We can write and build our code on a modern version but target a legacy runtime. Setting the compilation target will make sure we build code that is suitable for that runtime.</p>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor305"/>Promisify</h1>
			<p>Promisification is the practice of taking an asynchronous function that expects a callback and turning it into a promise. This is essentially a convenience utility that allows you to always write in promises instead of having to use the callbacks of a legacy API. It can be really helpful to promisify legacy APIs so that all our code can use promises uniformly and be easy to read. But it's more than just a convenience to convert callbacks into promises. Some modern APIs will only accept promises as parameters. If we could only work on some code with callbacks, we would have to wrap the callback asynchronous code with promises manually. Promisification saves us the trouble and potentially many lines of code.</p>
			<p>Let's work through an example of <em class="italic">promisifying</em> a function that expects a callback. We have a few options to choose from. Bluebird again provides this functionality with <code>Promise.promisify</code>. This time, we'll try a polyfill, <code>es6-promisify</code>. Let's start with a function that expects a callback:</p>
			<pre>const asyncAdder = (n1: number, n2: number, cb: Function) =&gt; {
  let err: Error;
  if (n1 === n2) {
    cb(Error("Use doubler instead!"));
  } else {
    cb(null, n1 + n2);
  }
};
asyncAdder(3, 4, (err: Error, sum: number) =&gt; {
  if (err) {
    throw err;
  }
  console.log(sum);
});</pre>
			<p>Functions that can be promisified follow a convention where the first argument into the callback is an error object. If the error is null or undefined, then the function is considered to have been invoked successfully. Here, I am calling <code>asyncAdder</code>, giving it two numbers and a callback function. My callback understands that <code>asyncAdder</code> will have an error in the first argument position if an error was thrown or the sum of the two numbers in the second argument position if it was successful. By adhering to this pattern, the function can be promisified. First, we <code>npm install</code> <code>es6-promisify</code> and then we import the module:</p>
			<pre>import { promisify } from "es6-promisify";
const asyncAdder = (n1: number, n2: number, cb: Function) =&gt; {
  let err: Error;
  if (n1 === n2) {
    cb(Error("Use doubler instead!"));
  } else {
    cb(null, n1 + n2);
  }
};
const promiseAdder = promisify(asyncAdder);
promiseAdder(3, 4)
  .then((val: number) =&gt; console.log(val))
  .catch((err: Error) =&gt; console.log(err));</pre>
			<p>We use the <code>promisify</code> import to wrap our function and now we can work exclusively with promises.</p>
			<p>Bluebird gives us exactly the same functionality:</p>
			<pre>import { promisify } from "bluebird";
const asyncAdder = (n1: number, n2: number, cb: Function) =&gt; {
  if (n1 === n2) {
    cb(Error("Use doubler instead!"));
  } else {
    cb(null, n1 + n2);
  }
};
const promiseAdder = promisify(asyncAdder);
promiseAdder(3, 4)
  .then((val: number) =&gt; console.log(val))
  .catch((err: Error) =&gt; console.log(err));</pre>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor306"/>Node.js util.promisify</h2>
			<p>Node.js introduced its own version of <code>promisify</code> as a native feature in version 8 (2017). Instead of using <code>es6-promise</code> or Bluebird, if we are targeting a Node.js 8+ environment, we can leverage the <code>util</code> package. Note that since we are writing TypeScript, we will need to add the <code>@types/node</code> dependency to take advantage of this package. Otherwise, TypeScript will not understand our import. We'll run <code>npm</code> <code>install</code> <code>-D @types/node</code>. The <code>-D</code> flag will install the type as a <code>devDependency</code>, which means it can be excluded from production builds:</p>
			<pre>import { promisify } from "util";
const asyncAdder = (n1: number, n2: number, cb: Function) =&gt; {
  let err: Error;
  if (n1 === n2) {
    cb(Error("Use doubler instead!"));
  } else {
    cb(null, n1 + n2);
  }
};
const promiseAdder = promisify(asyncAdder);
promiseAdder(3, 4)
  .then((val: number) =&gt; console.log(val))
  .catch((err: Error) =&gt; console.log(err));</pre>
			<p>Obviously, if we want our code to run in a browser, this won't work and we should use one of the other libraries, such as Bluebird, to enable this functionality.</p>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor307"/>Asynchronous FileSystem</h1>
			<p>As of Node.js 10 (released 2018), the FileSystem API (<code>fs</code>) comes with promisified async versions of all the functions as well as blocking synchronous versions of them. Let's look at the same operation with all three alternatives.</p>
			<h2 id="_idParaDest-259"><a id="_idTextAnchor308"/>fs.readFile</h2>
			<p>Many Node.js developers have worked with this API. This method will read a file, taking the file path as the first argument and a callback as the second argument. The callback will receive one or two arguments, an error (should one occur) as the first argument and a data buffer object as the second argument, should the read be successful:</p>
			<pre>import { readFile } from "fs";
import { resolve } from "path";
const filePath = resolve(__dirname, "text.txt");
readFile(filePath, (err, data) =&gt; {
  if (err) {
    throw err;
  }
  console.log(data.toString());
});</pre>
			<p>We read the file and log out the contents asynchronously. Anyone who has worked with the Node.js <code>fs</code> library in the past has probably seen code that looks like this. The code is non-blocking, which means even if the file is very large and the read is very slow, it won't prevent the application from performing other operations in the meantime. There's nothing wrong with this code other than it's not as concise and modern as we might like.</p>
			<p>In the example above, we're reading the file and logging to the console – not very useful, but in a real-world scenario, we might be reading a config file on startup, handling the documents of clients, or managing the lifecycle of web assets. There are many reasons you might need to access the local filesystem in a Node.js application.</p>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor309"/>fs.readFileSync</h2>
			<p>The <code>fs</code> library also exposes a fully synchronous API, meaning its operations are blocking and the event loop won't progress until these operations are complete. Such blocking operations are more often used with command-line utilities where taking full advantage of the event loop isn't a priority and instead, simple, clean code is the priority. With this API, we can write some nice, concise code like this:</p>
			<pre>import { readFileSync } from "fs";
import { resolve } from "path";
const filePath = resolve(__dirname, "text.txt");
console.log(readFileSync(filePath).toString());</pre>
			<p>It could be tempting to write code like this and call it a day, but <code>readFileSync</code> is a blocking operation so we must beware. The main execution thread will actually be paused until this work is complete. This may still be appropriate for a command-line utility, but it could be a real disaster to put code like this in a web API.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor310"/>The fs Promises API</h2>
			<p>The <code>fs</code> library exposes the promises API, which can give us the best of both worlds, asynchronous execution and concise code:</p>
			<pre>import { promises } from "fs";
import { resolve } from "path";
const filePath = resolve(__dirname, "text.txt");
promises.readFile(filePath).then(file =&gt; console.log(file.toString()));</pre>
			<p>Using the promises API lets us write nearly as concise code as the synchronous version, but now we are fully asynchronous, making the code suitable for a high-throughput web application or any other process where a blocking operation would be unacceptable.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor311"/>Exercise 12.05: The fs Promises API</h2>
			<p>In this exercise, you will use the <code>fs</code> promises API to concatenate two files into one. Whenever possible, make your code DRY (don't repeat yourself) by using functions. You'll need to use <code>readFile</code> and <code>writeFile</code>. The only dependencies needed for this program are <code>ts-node</code> (for execution), <code>typescript</code>, and <code>@types/node</code> so we have the types for the built-in <code>fs</code> and <code>path</code> libraries in Node.js: </p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/M3MH3">https://packt.link/M3MH3</a>.</p>
			<ol>
				<li value="1">Using the file in the GitHub repo as a basis for this exercise, navigate to the exercise directory and type <code>npm</code> <code>i</code> to install these dependencies.</li>
				<li>We are going to want to read two separate files using <code>readFile</code> and then use <code>writeFile</code> to write our output text file. The sample project already has two text files with some simple text. Feel free to add your own files and text.</li>
				<li>This project could be completed using <code>readFileSync</code> and <code>writeFileSync</code>. That code would look something like this:<pre>import { readFileSync, writeFileSync } from "fs";
import { resolve } from "path";
const file1 = readFileSync(resolve(__dirname, 'file1.txt'));
const file2 = readFileSync(resolve(__dirname, 'file2.txt'));
writeFileSync(resolve(__dirname, 'output.txt'), [file1, file2].join('\n'));</pre><p>The <code>resolve</code> function from the path library resolves paths on your filesystem and is often used alongside the <code>fs</code> library, as depicted above. Both these libraries are part of the Node.js standard library so we need only install typings, not the libraries themselves.</p></li>
				<li>We can execute this program with <code>npx</code> <code>ts-node</code> <code>file-concat.ts</code>. This will produce a file called <code>output.txt</code>, which contains this text:<pre>Text in file 1.
Text in file 2.</pre><p>So this works without promises. And this is probably fine for a command-line utility executed by a single user on a single workstation. However, if this kind of code were put into a web server, we might start to see some blocking issues. Synchronous filesystem calls are <em class="italic">blocking</em> and block the event loop. Doing this in a production application can cause latency or failure.</p></li>
				<li>We could solve this problem using <code>readFile</code> and <code>writeFile</code>, which are both asynchronous functions that take callbacks, but then we'd need to nest the second <code>readFile</code> inside the first. The code would look like this:<pre>import { readFile, writeFile } from 'fs';
import { resolve } from 'path';
readFile(resolve(__dirname, 'file1.txt'), (err, file1) =&gt; {
  if (err) throw err;
  readFile(resolve(__dirname, 'file1.txt'), (err, file2) =&gt; {
    if (err) throw err;
    writeFile(
      resolve(__dirname, 'output.txt'),
      [file1, file2].join('\n'),
      (err) =&gt; {
        if (err) throw err;
      }
    );
  });
});</pre><p>We are now clear of blocking issues, but the code is looking quite ugly. It's not hard to imagine another developer failing to understand the intent of this code and introducing a bug. Additionally, by putting the second <code>readFile</code> as a callback in the first, we are making the function slower than it needs to be. In a perfect world, those calls can be made in parallel. To do that, we can leverage the promises API.</p></li>
				<li>The best way to do things in parallel with promises is <code>Promise.all</code>. We can wrap our two <code>readFile</code> calls in a single <code>Promise.all</code>. To do that, we need to promisify <code>readFile</code>. Lucky for us, the <code>fs</code> library comes with a helper that will do that for us. Instead of importing <code>readFile</code>, we import promises from <code>fs</code> and call the <code>readFile</code> method on that object:<pre>import { promises } from 'fs';
import { resolve } from 'path';
Promise.all([
  promises.readFile(resolve(__dirname, 'file1.txt')),
  promises.readFile(resolve(__dirname, 'file2.txt')),
]);</pre></li>
				<li>These two reads will now run asynchronously in parallel. Now we can handle the output and use the same <code>array.join</code> function from the earlier example along with <code>promises.writeFile</code>:<pre>import { promises } from 'fs';
import { resolve } from 'path';
Promise.all([
  promises.readFile(resolve(__dirname, 'file1.txt')),
  promises.readFile(resolve(__dirname, 'file2.txt')),
]).then((files) =&gt; {
  promises.writeFile(resolve(__dirname, 'output.txt'), files.join('\n'));
});</pre></li>
				<li>This code is looking quite a lot cleaner than the nested code above. When we execute it with <code>npx</code> <code>ts-node</code> <code>file-concat.ts</code>, we get the expected output of <code>output.txt</code> containing the concatenated text:<pre>Text in file 1.
Text in file 2.</pre><p>Now that we have this working, we can certainly imagine much more complicated programs manipulating other types of files, such as a PDF merge function as a web service. Though some of the internals would be a lot more challenging to implement, the principles would be the same.</p></li>
			</ol>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor312"/>Working with Databases</h1>
			<p>It is very common for Node.js applications to work with a backend database such as <code>mysql</code> or <code>postgres</code>. It is critical that queries against a database be made asynchronously. Production-grade Node.js web services may serve thousands of requests per second. If it were necessary to pause the main execution thread for queries made synchronously against a database, these services just wouldn't scale at all. Asynchronous execution is critical to making this work.</p>
			<p>The process of negotiating a database connection, sending a SQL string, and parsing the response is complicated and not a native feature of Node.js and so we will almost always use a third-party library to manage this. These libraries are guaranteed to implement some kind of callback or promise pattern and we'll see it throughout their documentation and examples. Depending on the library you choose, you may have to implement a callback pattern, you may get to work with promises, or you may be presented with <code>async</code>/<code>await</code> (see <em class="italic">Chapter 13 Async/Await</em>). You may even get a choice of any of these as it's definitely possible to provide all of the above as options.</p>
			<p>For these examples, we'll use <code>sqlite</code>. Now, <code>sqlite</code> is a nice library that implements a fairly standard SQL syntax and can operate against a static file as a database or even run in memory. We will use the in-memory option. This means that there is nothing that needs to be done to set up our database. But we will have to run a few scripts to create a table or two and populate it on startup. It would be fairly simple to adapt these exercises to work with <code>mysql</code>, <code>postgres</code>, or even <code>mongodb</code>. All of these databases can be installed on your workstation or run in a Docker container for local development.</p>
			<p>For the first example, let's look at <code>sqlite3</code>. This library has an asynchronous API. Unlike more permanent and robust databases such as <code>mysql</code> or <code>postgres</code>, some <code>sqlite</code> client libraries are actually synchronous, but we won't be looking at those as they aren't very useful for demonstrating how promises work. So <code>sqlite3</code> implements an asynchronous API, but it works entirely with callbacks. Here is an example of creating an in-memory database, adding a table, adding a row to that table, and then querying back the row we added:</p>
			<pre>import { Database } from "sqlite3";
const db = new Database(":memory:", err =&gt; {
  if (err) {
    console.error(err);
    return db.close();
  }
  db.run("CREATE TABLE promise (id int, desc char);", err =&gt; {
    if (err) {
      console.error(err);
      return db.close();
    }
    db.run(
      "INSERT INTO promise VALUES (1, 'I will always lint my code.');",
      () =&gt; {
        db.all("SELECT * FROM promise;", (err, rows) =&gt; {
          if (err) {
            console.error(err);
            return db.close();
          }
          console.log(rows);
          db.close(err =&gt; {
            if (err) {
              return console.error(err);
            }
          });
        });
      }
    );
  });
});</pre>
			<p>This is exactly what developers mean when they complain about "callback hell." Again, this code executes perfectly well, but it is needlessly verbose, becomes deeply nested, and repeats itself, especially in the error-handling department. Of course, the code could be improved by adding abstractions and chaining together methods, but that doesn't change the fact that callbacks aren't a very modern way to think about writing Node.js code.</p>
			<p>Since all of these callbacks follow the pattern of expecting the first argument to be an error object, we could promisify <code>sqlite3</code>, but as is often the case, somebody has already done this work for us and provided a library called simply <code>sqlite</code> that mimics the exact API of <code>sqlite3</code>, but implements a promise API.</p>
			<p>I can rewrite the same code using this library and the result is a good deal more pleasing:</p>
			<pre>import { open } from "sqlite";
import * as sqlite from "sqlite3";
open({ driver: sqlite.Database, filename: ":memory:" }).then((db) =&gt; {  return db
    .run("CREATE TABLE promise (id int, desc char);")
    .then(() =&gt; {
      return db.run(
        "INSERT INTO promise VALUES (1, 'I will always lint my code.');"
      );
    })
    .then(() =&gt; {
      return db.all("SELECT * FROM promise;");
    })
    .then(rows =&gt; {
      console.log(rows);
    })
    .catch(err =&gt; console.error(err))
    .finally(() =&gt; db.close());
});</pre>
			<p>We've dropped nearly half of the lines of code and it's not nested as deeply. This still could be improved, but it's much cleaner now. Best of all, we have a single <code>catch</code> block followed by <code>finally</code>, to make sure the database connection is closed at the end.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor313"/>Developing with REST</h1>
			<p>In the next exercise, we'll build a RESTful API. REST is a very common standard for web traffic. Most websites and web APIs operate using REST. It stands for Representational State Transfer and defines concepts such as operations (sometimes called "methods" or even "verbs") such as <code>GET</code>, <code>DELETE</code>, <code>POST</code>, <code>PUT</code>, and <code>PATCH</code> and resources (the "path" or "noun"). The full scope of REST is beyond this book.</p>
			<p>Developers working on RESTful APIs frequently find it useful to work with some sort of REST client. The REST client can be configured to make different kinds of requests and display the responses. Requests can be saved and run again in the future. Some REST clients allow the creation of scenarios or test suites.</p>
			<p>Postman is a popular and free REST client. If you don't already have a REST client you're comfortable working with, try downloading Postman at <a href="https://www.postman.com/downloads/">https://www.postman.com/downloads/</a> before the next exercise. Once you've installed Postman, check its documentation (<a href="https://learning.postman.com/docs/getting-started/sending-the-first-request/">https://learning.postman.com/docs/getting-started/sending-the-first-request/</a>) and get ready for the next exercise.</p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor314"/>Exercise 12.06: Implementing a RESTful API backed by sqlite</h2>
			<p>In this exercise, you will create a REST API backed by <code>sqlite</code>. In this project, you will implement all CRUD (create, read, update, and delete) operations in the <code>sqlite</code> database and we will expose the corresponding REST verbs (<code>POST</code>, <code>GET</code>, <code>PUT</code>, and <code>DELETE</code>) from our web server:</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The code file for this exercise can also be found here: <a href="https://packt.link/rlX7G">https://packt.link/rlX7G</a>.</p>
			<ol>
				<li value="1">To get started, clone the project from GitHub and change to the directory for this exercise.</li>
				<li>Install the dependencies:<pre>npm i</pre><p>This will install typings for Node.js, as well as <code>ts-node</code> and <code>typescript</code> as development dependencies while <code>sqlite</code> and <code>sqlite3</code> are regular dependencies. All of these dependencies are already specified in the project's <code>package.json</code> file. Some of the dependencies, such as <code>@types/node</code>, <code>ts-node</code>, and <code>typescript</code>, are specified as <code>devDependencies</code> and others are regular dependencies. For the purpose of this exercise, the distinction is not going to matter but it's a common practice to run application builds so that only the necessary dependencies are part of the production build, thus the separation. The way to run this kind of build is <code>npm install --production</code> if you only wish to install the production dependencies or <code>npm prune --production</code> if you've already installed your <code>devDependencies</code> and wish to remove them.</p></li>
				<li>Now let's create a file to hold our <code>sqlite</code> database. Add a file in the root of your project called <code>db.ts</code>. We'll go with an object-oriented approach for the database and create a singleton object to represent our database and access patterns. One reason for doing this is we are going to want to maintain the state of whether or not the database has been initialized. Calling open on an in-memory <code>sqlite</code> database will destroy the database and create another one immediately, thus we only want to open the database connection if it isn't already open:<pre>import { Database } from "sqlite";
import sqlite from "sqlite3";
export interface PromiseModel {
  id: number;
  desc: string;
}
export class PromiseDB {
  private db: Database;
  private initialized = false;
  constructor() {
    this.db = new Database({
      driver: sqlite.Database,
      filename: ":memory:",
    });
  }
}</pre><p>It's always a good idea to create a class or interface to describe our entity, so here we have created <code>PromiseModel</code>. It will be useful to other parts of our application to be able to understand the properties our entity has as well as their types, since the database will only return untyped query results. We export the interface so that it can be used by other modules.</p></li>
				<li>Our database is an object with a constructor that will have a private member representing the actual database connection and a Boolean value to track whether the database has been initialized. Let's add a method for initialization:<pre>  initialize = () =&gt; {
    if (this.initialized) {
      return Promise.resolve(true);
    }
    return this.db
      .open()
      .then(() =&gt;
        this.db
          .run("CREATE TABLE promise (id INTEGER PRIMARY KEY, desc CHAR);")
          .then(() =&gt; (this.initialized = true))
      );
  };</pre><p>First, we check to see if we've already initialized the database. If so, we're done and we resolve the promise. If not, we call <code>open</code>, then once that promise has resolved, run our table creation SQL, and then finally update the state of the database so that we don't accidentally re-initialize it.</p><p>We could try to initialize the database in the constructor. The problem with that approach is that constructors do not resolve promises before returning. Constructor functions may call methods that return promises, but they will not resolve the promise. It's usually cleaner to create the singleton object and then invoke the initialization promise separately. For more information about singleton classes, see <em class="italic">Chapter 8, Dependency Injection in TypeScript</em>.</p></li>
				<li>Now let's add some methods. This will be pretty simple since our table only has two columns:<pre>  create = (payload: PromiseModel) =&gt;
    this.db.run("INSERT INTO promise (desc) VALUES (?);", payload.desc);</pre><p>This method takes an object of type <code>PromiseModel</code> as an argument, sends a prepared statement (a parameterized SQL statement that is safe from SQL injection attacks), and then returns <code>RunResult</code>, which contains some metadata about the operation that took place. Since the <code>sqlite</code> library ships with typings, we're able to infer the return type without needing to specify it. The return type in this case is <code>Promise&lt;ISqlite.RunResult&lt;sqlite.Statement&gt;&gt;</code>. We could paste all of that into our code, but it's much cleaner the way it is. Remember, if a good type can be inferred, it's best to just let TypeScript do the heavy lifting.</p></li>
				<li>In addition to the <code>create</code> method, we will want <code>delete</code>, <code>getAll</code>, <code>getOne</code>, and <code>update</code> methods. The <code>delete</code> method is very straightforward:<pre>  delete = (id: number) =&gt; this.db.run("DELETE FROM promise WHERE id = ?", id);</pre></li>
				<li>Since we're calling <code>db.run</code> again, we're again returning that <code>RunResult</code> type. Let's see what it looks like to return some of your own data:<pre>  getAll = () =&gt; this.db.all&lt;PromiseModel[]&gt;("SELECT * FROM promise;");
  getOne = (id: number) =&gt;
    this.db.get&lt;PromiseModel&gt;("SELECT * FROM promise WHERE id = ?", id);</pre><p>These methods use type parameters to specify the expected return types. If the type parameters were omitted, these methods would return <code>any</code> types, which wouldn't be very helpful to the other parts of our application.</p></li>
				<li>Last of all is the <code>update</code> method. This one will use our <code>PromiseModel</code> again to type check the input:<pre>  update = (payload: PromiseModel) =&gt;
    this.db.run(
      "UPDATE promise SET desc = ? where id = ?",
      payload.desc,
      payload.id
    );</pre></li>
				<li>The final code for the class looks like this:<pre>import { Database } from "sqlite";
import sqlite from "sqlite3";
export interface PromiseModel {
  id: number;
  desc: string;
}
export class PromiseDB {
  private db: Database;
  private initialized = false;
  constructor() {
    this.db = new Database({
      driver: sqlite.Database,
      filename: ":memory:",
    });
  }
  initialize = () =&gt; {
    if (this.initialized) {
      return Promise.resolve(true);
    }
    return this.db
      .open()
      .then(() =&gt;
        this.db
          .run("CREATE TABLE promise (id INTEGER PRIMARY KEY, desc CHAR);")
          .then(() =&gt; (this.initialized = true))
      );
  };
  create = (payload: PromiseModel) =&gt;
    this.db.run("INSERT INTO promise (desc) VALUES (?);", payload.desc);
  delete = (id: number) =&gt; this.db.run("DELETE FROM promise WHERE id = ?", id);
  getAll = () =&gt; this.db.all&lt;PromiseModel[]&gt;("SELECT * FROM promise;");
  getOne = (id: number) =&gt;
    this.db.get&lt;PromiseModel&gt;("SELECT * FROM promise WHERE id = ?", id);
  update = (payload: PromiseModel) =&gt;
    this.db.run(
      "UPDATE promise SET desc = ? where id = ?",
      payload.desc,
      payload.id
    );
}</pre><p>The next step is to build an HTTP server implementing a RESTful interface. Many Node.js developers use frameworks such as Express.js, Fastify, or NestJS, but for this exercise, we're just going to build a basic HTTP server. It won't have all the niceties of those frameworks, but it'll help us focus on asynchronous programming.</p></li>
				<li>To create our server, we'll create a class called <code>App</code> and expose an instance of it. Create a file called <code>app.ts</code> and declare the class:<pre>import { createServer, IncomingMessage, Server, ServerResponse } from "http";
import { PromiseDB } from "./db";
class App {
  public db: PromiseDB;
  private server: Server;
  constructor(private port: number) {
    this.db = new PromiseDB();
    this.server = createServer(this.requestHandler);
  }
}
export const app = new App(3000);</pre></li>
				<li>Our <code>App</code> class takes an argument of the port number we'll run our server on. The class will maintain the state of the running server as well as the database connection. Like our <code>PromiseDB</code> class, the constructor needs to be supplemented by an <code>initialize</code> method to handle the asynchronous setup: <pre>  initialize = () =&gt; {
    return Promise.all([
      this.db.initialize(),
      new Promise((resolve) =&gt; this.server.listen(this.port, () =&gt; resolve(true))),
    ]).then(() =&gt; console.log("Application is ready!"));
  };</pre><p>This method uses <code>Promise.all</code> so that we can initialize our database and server in parallel. When both are ready, it'll log a message letting us know the application is ready to handle requests. We are calling the <code>initialize</code> method on the <code>PromiseDB</code> instance that we've exposed to our <code>App</code> class. Unfortunately, <code>server.listen</code> doesn't return a promise but instead implements a fairly primitive API that requires a callback so we are wrapping it in our own promise. It's tempting to want to wrap <code>server.listen</code> in <code>util.promisify</code>, but even that won't work because <code>util.promisify</code> expects the callback function to expect the first argument to be an error object and the <code>server.listen</code> callback doesn't take any arguments. Sometimes, despite our best efforts, we just have to use a callback, but we can usually wrap them with promises.</p></li>
				<li>We're also going to need to add a <code>requestHandler</code> method. <code>createServer</code> is a method exposed by the <code>http</code> module in Node.js. It takes an argument that should be a function to handle requests and supply a response. Again, the API for the <code>http</code> module is fairly low-level:<pre>requestHandler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "*");
    res.setHeader(
      "Access-Control-Allow-Methods",
      "DELETE, GET, OPTIONS, POST, PUT"
    );
    if (req.method === "OPTIONS") {
      return res.end();
    }
    const urlParts = req.url?.split("/") ?? "/";
    switch (urlParts[1]) {
      case "promise":
        return promiseRouter(req, res);
      default:
        return this.handleError(res, 404, "Not Found.");
    }
  };</pre><p>We want our application to direct all traffic on the <code>/promise</code> resource to our promises API. This will allow us to add more resources (maybe <code>/admin</code> or <code>/users</code>) later on. The request handler's job is to see if we have requested the <code>/promise</code> route and then direct traffic to that specific router. Since we haven't defined any other resources, we'll return a 404 if we request any other route.</p><p>Note that we are handling the <code>OPTIONS</code> HTTP verb differently than any other. If we get a request with that verb, we set the <code>"Access-Control-Allow-Origin"</code> header and return a successful response. This is for development convenience. The topic of CORS is beyond the scope of this book, and readers are encouraged to learn more about it before implementing it in a production environment.</p></li>
				<li>That error handler needs a definition, so let's add one:<pre>  handleError = (
    res: ServerResponse,
    statusCode = 500,
    message = "Internal Server Error."
  ) =&gt; res.writeHead(statusCode).end(message);</pre><p>This is a nice one-liner that by default will throw a 500 status code <code>Internal Server Error</code>, but can take optional parameters to return any error code or message. Our default handler sets the status code to 404 and provides the message <code>"Not Found"</code>.</p></li>
				<li>We add a call to <code>initialize</code> at the end and we're good to go. Let's take another look at the <code>App</code> class:<pre>import { createServer, IncomingMessage, Server, ServerResponse } from "http";
import { PromiseDB } from "./db";
import { promiseRouter } from "./router";
class App {
  public db: PromiseDB;
  private server: Server;
  constructor(private port: number) {
    this.db = new PromiseDB();
    this.server = createServer(this.requestHandler);
  }
  initialize = () =&gt; {
    return Promise.all([
      this.db.initialize(),
      new Promise((resolve) =&gt; this.server.listen(this.port, () =&gt; resolve(true))),
    ]).then(() =&gt; console.log("Application is ready!"));
  };
  handleError = (
    res: ServerResponse,
    statusCode = 500,
    message = "Internal Server Error."
  ) =&gt; res.writeHead(statusCode).end(message);
requestHandler = (req: IncomingMessage, res: ServerResponse) =&gt; {
    res.setHeader("Access-Control-Allow-Origin", "*");
    res.setHeader("Access-Control-Allow-Headers", "*");
    res.setHeader(
      "Access-Control-Allow-Methods",
      "DELETE, GET, OPTIONS, POST, PUT"
    );
    if (req.method === "OPTIONS") {
      return res.end();
    }
    const urlParts = req.url?.split("/") ?? "/";
    switch (urlParts[1]) {
      case "promise":
        return promiseRouter(req, res);
      default:
        return this.handleError(res, 404, "Not Found.");
    }
  };
}
export const app = new App(3000);
app.initialize();</pre><p>If you've implemented all this in code, you're probably still getting an error on <code>promiseRouter</code>. That's because we haven't written that yet.</p></li>
				<li>Add a <code>router.ts</code> file to your project. This will be the last part we need to build this simple API. A more complicated application would hopefully include a more sophisticated directory structure and most likely be based on a leading framework such as Express.js or NestJS.<p>Unlike our database and server modules, the router is stateless. It does not need to be initialized and does not track any variables. We could still create a class for our router, but let's instead use a functional programming style. There's really no right or wrong way to do this. Instead of using classes for our database and server, we could likewise use a functional style.</p><p>We're going to work on creating several handlers, tie them together with a router based on HTTP verbs, and also create a body parser. Let's start with the body parser.</p></li>
				<li>Readers who have some experience with the Express.js framework may have used its powerful <code>bodyParser</code> module. It's normally a good idea to use an off-the-shelf solution for something like that, but in this exercise, you will write your own in order to get a closer look at how we can take the request or <code>IncomingMessage</code> object as a stream and convert it into a typed object:<pre>const parseBody = (req: IncomingMessage): Promise&lt;PromiseModel&gt; =&gt; {
  return new Promise((resolve, reject) =&gt; {
    let body = "";
    req.on("data", (chunk) =&gt; (body += chunk));
    req.on("end", () =&gt; {
      try {
        resolve(JSON.parse(body));
      } catch (e) {
        reject(e);
      }
    });
  });
};</pre><p>The data stream is again a fairly low-level API that we must wrap in a promise. The stream is event-based, as are a lot of the Node.js APIs. In this case, we are listening for two separate events, <code>data</code> and <code>end</code>. Each time we get a <code>data</code> event, we add data to the <code>body</code> string. When we receive the <code>end</code> event, we can finally resolve our promise. Since the data is a string at this point and we want an object, we will use <code>JSON.parse</code> to parse the object. <code>JSON.parse</code> must be wrapped with <code>try/catch</code> to catch any parsing errors.</p><p>By default, <code>JSON.parse</code> returns an <code>any</code> type. This type is too broad to be of any use in checking our application for type correctness. Fortunately, we can add proper type checking by setting the return type of <code>parseBody</code> to <code>Promise&lt;PromiseModel&gt;</code>. This will narrow the type of the object returned by <code>JSON.parse</code> to <code>PromiseModel</code> and the rest of our application can expect that type to have been parsed. Note that this is a compile-time check and does not guarantee the correct data has come from a third-party source such as an end user. It is advisable to combine type checks with validators or type guards to ensure consistency. When in doubt, employ good error handling.</p></li>
				<li>Now that you have a good method for parsing the request body, let's add one to handle the create action:<pre>const handleCreate = (req: IncomingMessage, res: ServerResponse) =&gt;
  parseBody(req)
    .then((body) =&gt; app.db.create(body).then(() =&gt; res.end()))
    .catch((err) =&gt; app.handleError(res, 500, err.message));</pre></li>
				<li>This function parses the body of the request, attempts to insert it into our database, and then responds with a default 200 response if the operation was successful. Note that the chained catch at the end will catch any errors that occur in the promise. If our body parsing fails, the error will be caught here, even though it's placed after <code>db.create</code> in the chain.</li>
				<li>Now let's handle the delete action:<pre>const handleDelete = (requestParam: number, res: ServerResponse) =&gt;
  app.db
    .delete(requestParam)
    .then(() =&gt; res.end())
    .catch((err) =&gt; app.handleError(res, 500, err.message));</pre><p>The HTTP <code>DELETE</code> verb does not use a body. Instead, we will take the ID of the row we want to delete from the URL. We'll see how that routing works in a moment.</p></li>
				<li>The <code>GET</code> operations need to return some data and will use <code>JSON.stringify</code> to serialize their response objects to send them to a client:<pre>const handleGetAll = (res: ServerResponse) =&gt;
  app.db
    .getAll()
    .then((data) =&gt; res.end(JSON.stringify(data)))
    .catch((err) =&gt; app.handleError(res, 500, err.message));
const handleGetOne = (requestParam: number, res: ServerResponse) =&gt;
  app.db
    .getOne(requestParam)
    .then((data) =&gt; res.end(JSON.stringify(data)))
    .catch((err) =&gt; app.handleError(res, 500, err.message));</pre></li>
				<li>The update action looks similar to delete:<pre>const handleUpdate = (req: IncomingMessage, res: ServerResponse) =&gt;
  parseBody(req)
    .then((body) =&gt; app.db.update(body).then(() =&gt; res.end()))
    .catch((err) =&gt; app.handleError(res, 500, err.message));</pre></li>
				<li>Finally, we just need a router. Your router will need to make a decision based on the HTTP verb used as well as any request parameter that may refer to the ID of the row we want to interact with. We will also set the <code>Content-Type</code> header to <code>application/json</code> for all responses. Then we simply need to delegate to the correct handler:<pre>export const promiseRouter = (req: IncomingMessage, res: ServerResponse) =&gt; {
  const urlParts = req.url?.split("/") ?? "/";
  const requestParam = urlParts[2];
  res.setHeader("Content-Type", "application/json");
  switch (req.method) {
    case "DELETE":
      if (requestParam) {
        return handleDelete(Number.parseInt(requestParam), res);
      }
    case "GET":
      if (requestParam) {
        return handleGetOne(Number.parseInt(requestParam), res);
      }
      return handleGetAll(res);
    case "POST":
      return handleCreate(req, res);
    case "PUT":
      return handleUpdate(req, res);
    default:
      app.handleError(res, 404, "Not Found.");
  }
};</pre></li>
				<li>Now it's time to try our application. We installed <code>ts-node</code> earlier. This library allows us to transpile and run our TypeScript program in a single step. It is not necessarily recommended to use <code>ts-node</code> in production, but it makes for a very handy development tool. Let's try it now:<pre> npx ts-node app.ts</pre><p>You should see the following on your console:</p><pre>Application is ready!</pre><p>This implies that your application is ready to start receiving requests. If not, you may have a typo somewhere. Let's try it out. You can either use a REST client or curl. This exercise uses Postman</p></li>
				<li>If you make a <code>GET</code> request to <code>http://localhost:3000/promise</code>, you will get an empty array ([]) back: <div><img src="img/B14508_12_03.jpg" alt="Figure 12.3: Initial GET request&#13;&#10;"/></div><p class="figure-caption">Figure 12.3: Initial GET request</p><p>This is because we haven't created any records yet. </p></li>
				<li>Try a <code>POST</code> with the payload <code>{"desc":"Always lint your code"}</code>: <div><img src="img/B14508_12_04.jpg" alt="Figure 12.4: POST data&#13;&#10;"/></div><p class="figure-caption">Figure 12.4: POST data</p></li>
				<li>Now the <code>GET</code> request returns <code>[{"id":1,"desc":"Always lint your code"}]</code>: <div><img src="img/B14508_12_05.jpg" alt="Figure 12.5: Use GET to retrieve data&#13;&#10;"/></div><p class="figure-caption">Figure 12.5: Use GET to retrieve data</p></li>
				<li>If you do a request to <code>http://localhost:3000/promise/1</code>, you will get a single object back: <div><img src="img/B14508_12_06.jpg" alt="Figure 12.6: Single object&#13;&#10;"/></div><p class="figure-caption">Figure 12.6: Single object</p></li>
				<li>If you request <code>http://localhost:3000/promise/2</code>, you will get nothing: <div><img src="img/B14508_12_07.jpg" alt="Figure 12.7: No items found&#13;&#10;"/></div><p class="figure-caption">Figure 12.7: No items found</p></li>
				<li>If you request <code>http://localhost:3000/something-else</code>, you will get a 404 response: </li>
			</ol>
			<div><div><img src="img/B14508_12_08.jpg" alt="Figure 12.8: 404 response&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.8: 404 response</p>
			<p>Looks like things are working. Experiment with the different HTTP verbs. Try giving invalid input and see how the error handling works. We'll use this API in the next section.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor315"/>Putting It All Together – Building a Promise App</h1>
			<p>We've learned techniques for using promises in web projects as well as Node.js APIs. Let's combine our earlier exercises to build a web application that renders progressively as data is ready and makes use of asynchronous programming on the server to avoid blocking the event loop.</p>
			<h2 id="_idParaDest-267"><a id="_idTextAnchor316"/>Activity 12.01: Building a Promise App</h2>
			<p>In this activity, we're going to build a web application that talks to the API we just built. Although frameworks such as Angular, React, and Vue are very popular, those are covered in later chapters so we will build a very basic TypeScript application with no bells or whistles.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This activity provides a UI application that communicates with the backend API we built in <em class="italic">Exercise 12.06</em>, <em class="italic">Implementing a RESTful API backed by sqlite</em>. In order to get the output shown, you will need to have your API running. Return to that exercise for help if you need it.</p>
			<p>This UI application will connect to our API and allow us to modify the data we store in our database. We will be able to list out the data we've saved (the promises we make), create new items to save, and delete items. Our UI application will need to make <code>GET</code>, <code>POST</code>, and <code>DELETE</code> calls to our backend API. It will need to use an HTTP client to do that. We could install a library such as <code>axios</code> to handle that or we could use the native Fetch API available in all modern web browsers.</p>
			<p>Our web application will also need to be able to dynamically update the UI. Modern view libraries such as <code>react</code> or <code>vue</code> do that for us, but in this case we are framework-free so we'll need to use more DOM (document object model) APIs such as <code>getElementById</code>, <code>createElement</code>, and <code>appendChild</code>. These are natively available in all web browsers with no libraries needed.</p>
			<p>Implementing this application using promises will be critical because all of the API calls will be asynchronous. We will perform an action, such as a click, our application will call the API, then it will respond with data and then and only then will the promise resolve and cause a change in the DOM state.</p>
			<p>Here are some high-level steps that will enable you to create the app:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/RlYli">https://packt.link/RlYli</a>.</p>
			<ol>
				<li value="1">Create a static <code>html</code> page with <code>css</code> to be served via <code>http-server</code> for local development.</li>
				<li>Add an <code>app.ts</code> file to make a web request to the backend using <code>fetch</code> and do the required DOM manipulation based on the response.</li>
				<li>Transpile the <code>app.ts</code> file into <code>app.js</code> and test against the local server using a web browser.</li>
				<li>Make adjustments to <code>app.ts</code> and continue testing until all the scenarios are working.<p>Once you have completed the activity, you should be able to view the form on <code>localhost:8080</code>. An example is shown here:</p></li>
			</ol>
			<div><div><img src="img/B14508_12_09.jpg" alt="Figure 12.9: Completed form&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.9: Completed form</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor441">this link</a>.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor317"/>Summary</h1>
			<p>We have learned how promises came to be a part of the ECMAScript standard, taken a tour of the native implementation, and worked through sample projects using promises to solve real-world problems. We also explored how TypeScript can enhance the promise spec and how we can polyfill promises when targeting environments that don't include native promise support. We contrasted the Bluebird promise library with native promises. We learned about different ways of interacting with the filesystem using Node.js and we also covered managing asynchronous database connections and queries. In the end, we put all of this together into a working application.</p>
			<p>In the next chapter, we will build upon the asynchronous programming paradigm by covering <code>async</code> and <code>await</code>. We'll discuss when to use these over promises and the place promises still have in the TypeScript ecosystem.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>