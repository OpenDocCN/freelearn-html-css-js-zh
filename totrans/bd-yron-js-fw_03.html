<html><head></head><body>
<div id="_idContainer032">
<h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor051"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/><span class="koboSpan" id="kobo.2.1">Internal Framework Architecture</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapters, we learned about the history of the current frameworks and explored the concept of abstractions. </span><span class="koboSpan" id="kobo.3.2">We also looked at how JavaScript frameworks use, combine, and extend different abstractions to make a framework functional. </span><span class="koboSpan" id="kobo.3.3">In this chapter, we will dive into the architectural patterns of JavaScript frameworks. </span><span class="koboSpan" id="kobo.3.4">To go even further and expand our framework knowledge, we will have to closely inspect what goes into making a modern framework and what we can learn from </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">existing patterns.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">As part of this chapter, we will explore </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.7.1">Understanding the core technical architectural patterns of existing frontend and backend frameworks. </span><span class="koboSpan" id="kobo.7.2">We will focus on the design, architecture, and structural patterns that are combined into a </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">single system.</span></span></li>
<li><span class="koboSpan" id="kobo.9.1">Getting a glimpse into framework APIs, packaging configurations, and </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">additional tooling.</span></span></li>
<li><span class="koboSpan" id="kobo.11.1">Understanding additional tools that benefit </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">the framework.</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Exposure to available compiles </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and bundlers.</span></span></li>
</ul>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.15.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.16.1">Similar to the previous chapter, we will be using this book’s repository as an extension of this chapter. </span><span class="koboSpan" id="kobo.16.2">You can find it at </span><a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework"><span class="koboSpan" id="kobo.17.1">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</span></a><span class="koboSpan" id="kobo.18.1">, and the relevant files are in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.19.1">chapter3</span></strong><span class="koboSpan" id="kobo.20.1"> directory. </span><span class="koboSpan" id="kobo.20.2">To run the code in this repository, you can use any environment that supports using a Terminal or a command prompt, running Node.js, such as Windows, macOS, and most varieties </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">of Linux.</span></span></p>
<p><span class="koboSpan" id="kobo.22.1">Most of the code mentioned in this chapter can be found in this book’s repository, so you don’t have to navigate external repositories. </span><span class="koboSpan" id="kobo.22.2">Follow the </span><strong class="source-inline"><span class="koboSpan" id="kobo.23.1">README.md</span></strong><span class="koboSpan" id="kobo.24.1"> instructions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.25.1">chapter3</span></strong><span class="koboSpan" id="kobo.26.1"> directory to get started. </span><span class="koboSpan" id="kobo.26.2">In addition, a lot of framework architecture focuses on the stakeholders or developers who will use the framework to build new projects. </span><span class="koboSpan" id="kobo.26.3">In this chapter, we will refer to them as </span><em class="italic"><span class="koboSpan" id="kobo.27.1">framework users</span></em><span class="koboSpan" id="kobo.28.1">, not to be confused with the end users of applications built with </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">these frameworks.</span></span></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.30.1">Exploring the core architecture</span></h1>
<p><span class="koboSpan" id="kobo.31.1">Let’s explore the </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.32.1">core architectural pieces of building a framework. </span><span class="koboSpan" id="kobo.32.2">When a framework project is created, it is usually partitioned into an organized directory structure consisting of various specialized compartments. </span><span class="koboSpan" id="kobo.32.3">This approach helps separate the concerns of specific modules, scripts, and files. </span><span class="koboSpan" id="kobo.32.4">This organizational pattern is similar to how web application projects are organized. </span><span class="koboSpan" id="kobo.32.5">Except in the case of the framework, the project needs to export public interfaces and scripts to be usable. </span><span class="koboSpan" id="kobo.32.6">In some cases, frameworks can also be split into multiple repositories to allow a different approach to </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">framework development.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">Given that the programming environment for every language is different, the JavaScript and TypeScript frameworks have their own ways of structuring the framework projects, making it easier to generate artifacts and make the frameworks more usable within the projects that utilize them. </span><span class="koboSpan" id="kobo.34.2">A well-organized project makes it easier to maintain, collaborate, and refactor many parts of said project. </span><span class="koboSpan" id="kobo.34.3">For instance, let’s take real-world examples such as Vue.js and Angular. </span><span class="koboSpan" id="kobo.34.4">Angular keeps most of the framework files in a single repository (which can be found at </span><a href="http://github.com/angular/angular"><span class="koboSpan" id="kobo.35.1">github.com/angular/angular</span></a><span class="koboSpan" id="kobo.36.1">), except its command-line tools (located at </span><a href="http://github.com/angular/angular-cli"><span class="koboSpan" id="kobo.37.1">github.com/angular/angular-cli</span></a><span class="koboSpan" id="kobo.38.1">). </span><span class="koboSpan" id="kobo.38.2">However, many packages are published as separate dependencies in the package registry, such as </span><strong class="bold"><span class="koboSpan" id="kobo.39.1">npm</span></strong><span class="koboSpan" id="kobo.40.1"> (which can be found</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.41.1"> at </span><a href="http://npmjs.com/package/@angular/core"><span class="koboSpan" id="kobo.42.1">npmjs.com/package/@angular/core</span></a><span class="koboSpan" id="kobo.43.1">). </span><span class="koboSpan" id="kobo.43.2">The resulting payload for the framework package can be different from a frontend framework. </span><span class="koboSpan" id="kobo.43.3">In the case of Angular, it consists of pre-built files for different versions </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">of JavaScript.</span></span></p>
<p><span class="koboSpan" id="kobo.45.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.46.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.47.1">.1</span></em><span class="koboSpan" id="kobo.48.1">, Angular core is provided as unflattened and flattened versions in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.49.1">esm2020</span></strong><span class="koboSpan" id="kobo.50.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.51.1">fesm2015</span></strong><span class="koboSpan" id="kobo.52.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.53.1">fesm2020</span></strong><span class="koboSpan" id="kobo.54.1"> directories, and these packages also include various </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">source maps:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<span class="koboSpan" id="kobo.56.1"><img alt="Figure 3.1: Angular core files provided as an npm package" src="image/Figure_3.1_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.57.1">Figure 3.1: Angular core files provided as an npm package</span></p>
<p><span class="koboSpan" id="kobo.58.1">Depending on the browser target or the bundler technology used, Angular offers multiple import options. </span><span class="koboSpan" id="kobo.58.2">Vue.js has a similarly packaged export that offers a myriad of options to load the framework in a particular JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">module environment.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">The output directory in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.61.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.62.1">.2</span></em><span class="koboSpan" id="kobo.63.1"> is the result of packaging the Vue.js framework using </span><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">rollup.js</span></strong><span class="koboSpan" id="kobo.65.1"> (</span><a href="http://rollupjs.org"><span class="koboSpan" id="kobo.66.1">rollupjs.org</span></a><span class="koboSpan" id="kobo.67.1">) to create an output configuration for each of the target runtimes. </span><span class="koboSpan" id="kobo.67.2">The source </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.68.1">of this configuration can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">at </span></span><a href="http://github.com/vuejs/core/blob/main/rollup.config.js"><span class="No-Break"><span class="koboSpan" id="kobo.70.1">github.com/vuejs/core/blob/main/rollup.config.js</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.71.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<span class="koboSpan" id="kobo.72.1"><img alt="Figure 3.2: Vue.js distribution as an NPM package" src="image/Figure_3.2_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.73.1">Figure 3.2: Vue.js distribution as an NPM package</span></p>
<p><span class="koboSpan" id="kobo.74.1">The produced files of the targeted configurations slowly evolve with the runtime target as time progresses. </span><span class="koboSpan" id="kobo.74.2">For instance, if the framework is not usually included as a global variable inside of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.76.1"> tag, then it might make sense to get rid of the global variable output or let the framework users convert the resulting output of the framework to suit </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">their needs.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.78.1">Examples of packaged frameworks</span></p>
<p class="callout"><span class="koboSpan" id="kobo.79.1">You can check </span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.80.1">out the examples of the framework bundles by running the </span><strong class="source-inline"><span class="koboSpan" id="kobo.81.1">npm start</span></strong><span class="koboSpan" id="kobo.82.1"> script in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">chapter3</span></strong><span class="koboSpan" id="kobo.84.1"> directory. </span><span class="koboSpan" id="kobo.84.2">Once the packaged framework sources have been downloaded and extracted, you can view several resulting outputs for Angular </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">and Vue.js.</span></span></p>
<p><span class="koboSpan" id="kobo.86.1">Now that a build step </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.87.1">is so widespread in JavaScript projects, these frameworks also provide direct ways to import the framework packages and include them as part of the build process. </span><span class="koboSpan" id="kobo.87.2">The “unflattened” version of the framework would be an example of this, where the framework files are not concatenated. </span><span class="koboSpan" id="kobo.87.3">Instead, the bundler would be combining those files and optimizing them with techniques such as code splitting </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">if possible.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">The applications that use the framework import the dependencies in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.90.1">package.json</span></strong><span class="koboSpan" id="kobo.91.1"> file. </span><span class="koboSpan" id="kobo.91.2">Angular splits the different parts of the framework into </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">different packages:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.93.1">
"dependencies": {
    "@angular/animations": "^15.2.0",
    "@angular/common": "^15.2.0",
    "@angular/compiler": "^15.2.0",
    "@angular/core": "^15.2.0",
    "@angular/forms": "^15.2.0",
    "@angular/platform-browser": "^15.2.0",
    "@angular/router": "^15.2.0",
},</span></pre>
<p><span class="koboSpan" id="kobo.94.1">Splitting these modules into their own packages creates a well-defined boundary between the different modules. </span><span class="koboSpan" id="kobo.94.2">However, extra release tooling is usually required to make it easier to manage and release multiple modules without manually packaging them. </span><span class="koboSpan" id="kobo.94.3">The split packages also benefit framework users as they can pick and choose which modules are required for </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">their applications.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.96.1">Angular core dependencies in action</span></p>
<p class="callout"><span class="koboSpan" id="kobo.97.1">The framework</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.98.1"> showcase from </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.99.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.100.1"> has an existing example of all the Angular dependencies mentioned in this section. </span><span class="koboSpan" id="kobo.100.2">You can find the application in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">chapter1/angular</span></strong><span class="koboSpan" id="kobo.102.1"> directory, run it, and tweak it to your preference. </span><span class="koboSpan" id="kobo.102.2">Many of these core dependencies can be found via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">@angular</span></strong><span class="koboSpan" id="kobo.104.1"> namespace in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">npm</span></strong><span class="koboSpan" id="kobo.106.1"> package list </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">at </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">npmjs.com/search?q=%40angular</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">In the case of Vue.js, the core architecture is divided across many repositories at </span><a href="http://github.com/vuejs"><span class="koboSpan" id="kobo.111.1">github.com/vuejs</span></a><span class="koboSpan" id="kobo.112.1">. </span><span class="koboSpan" id="kobo.112.2">The core, router, developer tools, documentation, and other parts of the framework are split across repositories in the Vue.js organization. </span><span class="koboSpan" id="kobo.112.3">When building a new framework, it </span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.113.1">is often easier to manage most of it in a single repository and even keep everything in a single package. </span><span class="koboSpan" id="kobo.113.2">The structure can still be well separated, and it will avoid the extra friction of managing extra repositories. </span><span class="koboSpan" id="kobo.113.3">As your project grows, it is possible to split it into multiple repositories as you see fit. </span><span class="koboSpan" id="kobo.113.4">By that point, the framework should already have an established release model and infrastructure to support this kind </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">of expansion.</span></span></p>
<p><span class="koboSpan" id="kobo.115.1">To better understand the wider architectural patterns of framework design and maintenance, we are going to explore three important parts that comprise a framework’s </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">technical architecture:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.117.1">Modules</span></strong><span class="koboSpan" id="kobo.118.1">: The isolated </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.119.1">parts of the code base, usually in a single JavaScript file. </span><span class="koboSpan" id="kobo.119.2">These often import or export functions, classes, or other types of structures, which are later utilized as part of a </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">larger system.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.121.1">Packages</span></strong><span class="koboSpan" id="kobo.122.1">: The main source code behind the framework includes interfaces that are exposed to the users and interfaces that are used internally to facilitate </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">certain functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.124.1">Scripts</span></strong><span class="koboSpan" id="kobo.125.1">: Binaries and scripts that are exposed as part of the framework. </span><span class="koboSpan" id="kobo.125.2">Some of the scripts are also used for framework development and extra tooling required for specific </span><span class="No-Break"><span class="koboSpan" id="kobo.126.1">use cases.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.127.1">Compilers</span></strong><span class="koboSpan" id="kobo.128.1">: The programs that are included as part of the framework that either generate the </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.129.1">main JavaScript output from the framework or are used as part of the </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">development process.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.131.1">Not everything in these categories is required for a successful framework, but as authors, we can pick and choose what is important to us for our project and focus on that. </span><span class="koboSpan" id="kobo.131.2">If we look at the existing frameworks of today, we will see similar patterns that work well for JavaScript, frontend, and backend projects – these projects employ all or most of these </span><a id="_idIndexMarker266"/><span class="No-Break"><span class="koboSpan" id="kobo.132.1">architectural categories.</span></span></p>
<p><span class="koboSpan" id="kobo.133.1">In the next section, we will explore two types of technical patterns in framework development – these include architectural and design decisions that affect how the different </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">frameworks function.</span></span></p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.135.1">Patterns</span></h1>
<p><span class="koboSpan" id="kobo.136.1">The focus on framework development requires learning about different types of software patterns, such as architectural, design, and technical patterns. </span><span class="koboSpan" id="kobo.136.2">Knowing about these patterns and what kind of decisions went into implementing them in existing frameworks can assist new framework authors at being successful in </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">their projects.</span></span></p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.138.1">Architectural patterns</span></h2>
<p><span class="koboSpan" id="kobo.139.1">We saw examples of </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.140.1">existing architectural patterns such as MVC and MVVM in </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.141.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.142.1">. </span><span class="koboSpan" id="kobo.142.2">JavaScript frameworks have the freedom to choose any type of architectural model as they see fit for their use cases. </span><span class="koboSpan" id="kobo.142.3">For example, the component-based architecture is highly relevant in modern frontend frameworks and is used in many systems, especially those that extend the React library for their feature set. </span><span class="koboSpan" id="kobo.142.4">In this pattern, each component is encapsulated with its own state, a view, and a particular behavior, and could even consist of </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">nested components.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">In backend frameworks, the middleware architectural pattern is often utilized to manage or mutate incoming requests and outgoing responses. </span><span class="koboSpan" id="kobo.144.2">This type of pattern works well due to the nature of the server requests </span><span class="No-Break"><span class="koboSpan" id="kobo.145.1">and responses.</span></span></p>
<p><span class="koboSpan" id="kobo.146.1">A different approach to architectural patterns can be seen within the Electron.js application framework. </span><span class="koboSpan" id="kobo.146.2">For the most part, Electron.js is designed on top of process communication between the interface renderer process and the main process for the lower-level operations. </span><span class="koboSpan" id="kobo.146.3">This architectural approach does not define a particular name but still directs the architecture toward the separation of concerns. </span><span class="koboSpan" id="kobo.146.4">If you look at some of the code bases of the Electron.js applications, you will notice the organization between the two responsibilities of the interface and the backend operations. </span><span class="koboSpan" id="kobo.146.5">Frameworks can also use a mix of architectural patterns that combine aspects of object-oriented, functional, and reactive programming to enable the most flexibility. </span><span class="koboSpan" id="kobo.146.6">A lot of these concepts can be witnessed within the Nest.js framework, as highlighted in </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.147.1">Chapter 1</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.148.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.149.1">By browsing the design decisions and the code of various open source frameworks, you can find a variety of </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.150.1">implementations of different architectural patterns. </span><span class="koboSpan" id="kobo.150.2">As a future framework author, I encourage you to innovate in this space by creating your original architectural patterns or deriving your own approach to the </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">established patterns.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.152.1">Design patterns</span></h2>
<p><span class="koboSpan" id="kobo.153.1">In terms of design patterns, these</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.154.1"> focus on a much lower level compared to architectural patterns. </span><span class="koboSpan" id="kobo.154.2">These patterns address how a framework can solve frequent challenges of organizing code and techniques to enable a </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">cohesive architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">In </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.157.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.158.1">, we saw an example of a design pattern via the observer pattern. </span><span class="koboSpan" id="kobo.158.2">In addition to the observer technique, frameworks can also utilize a factory pattern, which helps create and manage reusable objects based on some definition. </span><span class="koboSpan" id="kobo.158.3">Depending on the implementation and the environment, additional enhancements may include managing the created objects. </span><span class="koboSpan" id="kobo.158.4">Another design pattern often seen in all types of JavaScript frameworks is the Publish and Subscribe pattern. </span><span class="koboSpan" id="kobo.158.5">This pattern allows both framework internals and components built with the framework abstractions to interact with each other by emitting events and subscribing to those events to create an asynchronous way of communicating between different parts of </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">the system.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Modules and the module design pattern are also universal in all JavaScript software. </span><span class="koboSpan" id="kobo.160.2">You will find module APIs defined by the language itself and abstractions around modules refined by different frameworks. </span><span class="koboSpan" id="kobo.160.3">This pattern mainly concentrates on enforcing encapsulation, standardizing the code base, and preventing large convoluted pieces </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">In the next section, we’ll look at the technical architecture. </span><span class="koboSpan" id="kobo.162.2">It consists of details related to the technical </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.163.1">approach to outlining APIs, defining entry points, and using additional tooling to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">framework behaviors.</span></span></p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.165.1">The technical architecture</span></h1>
<p><span class="koboSpan" id="kobo.166.1">The technical </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.167.1">architecture and patterns mainly deal with technical challenges. </span><span class="koboSpan" id="kobo.167.2">For JavaScript applications, this could mean dealing with rendering a page, responding to a request, interacting with a database, loading an application, and more. </span><span class="koboSpan" id="kobo.167.3">In frameworks, the technical challenges extend beyond solving a particular technical problem. </span><span class="koboSpan" id="kobo.167.4">Instead, it is about creating a well-designed packaged system that can be beneficial for framework users to build </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">their projects.</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">To create this system, framework authors need to combine a set of packaged interfaces and a usable set of scripts and also use additional software to improve the JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.170.1">programming experience.</span></span></p>
<p><span class="koboSpan" id="kobo.171.1">While learning about the technical architecture, we are going to look at the three categories that enable the essential features of the framework. </span><span class="koboSpan" id="kobo.171.2">We are going to explore all the subcategories under these technical topics, as seen in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.172.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.173.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.175.1">Packages</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">Scripts</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.177.1">Compilers</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.178.1">Core APIs</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.179.1">Binaries </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">and executables</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.181.1">Framework compilers </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">and bundlers</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.183.1">Entry points</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.184.1">File generators</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.185.1">Types</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.186.1">Developer tools</span></span></p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.187.1">Source maps</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.188.1">Plugin and </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">extension APIs</span></span></p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.190.1">Figure 3.3: Subcategories of the technical architecture</span></p>
<p><span class="koboSpan" id="kobo.191.1">We will start with</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.192.1"> the core packages of the framework that enable </span><span class="No-Break"><span class="koboSpan" id="kobo.193.1">substantial functionality.</span></span></p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.194.1">Packages</span></h2>
<p><span class="koboSpan" id="kobo.195.1">Packages consist of</span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.196.1"> the core logic of the framework, with public and private APIs. </span><span class="koboSpan" id="kobo.196.2">This directory can include any packages that are necessary for the framework to function. </span><span class="koboSpan" id="kobo.196.3">It consists of internal and public interfaces. </span><span class="koboSpan" id="kobo.196.4">It can also include a compiler or any building tools that are used as part of framework development or developer use cases. </span><span class="koboSpan" id="kobo.196.5">These include the core pieces that make the framework what it is. </span><span class="koboSpan" id="kobo.196.6">Depending on the framework, the packages can be functionally independent or rely on each other to function. </span><span class="koboSpan" id="kobo.196.7">In general, the packages part of the framework can consist of any related code that should be included as part of the framework, but there are several essential types of packages that today’s frameworks include. </span><span class="koboSpan" id="kobo.196.8">We are going to look at these in more detail in </span><span class="No-Break"><span class="koboSpan" id="kobo.197.1">this section.</span></span></p>
<h3><span class="koboSpan" id="kobo.198.1">Core APIs</span></h3>
<p><span class="koboSpan" id="kobo.199.1">Depending </span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.200.1">on the framework, the “core” packages</span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.201.1"> may consist of a variety of modules for providing public user-exposed interfaces and private interfaces to enable frameworks’ features. </span><span class="koboSpan" id="kobo.201.2">In </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.202.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.203.1">, we saw examples of public APIs provided by framework packages, such as router, event-management, template modules, and more. </span><span class="koboSpan" id="kobo.203.2">The core packages are usually structured similarly in both frontend and </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">backend frameworks.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">Frontend frameworks</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.206.1"> enable </span><strong class="bold"><span class="koboSpan" id="kobo.207.1">reactivity</span></strong><span class="koboSpan" id="kobo.208.1"> features as part of their public APIs. </span><span class="koboSpan" id="kobo.208.2">Reactivity enables the components initialized by the framework to update their states as the underlying data changes. </span><span class="koboSpan" id="kobo.208.3">When frameworks implement various forms of data binding, they build upon the forms of reactive programming. </span><span class="koboSpan" id="kobo.208.4">For instance, Vue.js isolates its main reactivity component in </span><strong class="source-inline"><span class="koboSpan" id="kobo.209.1">@vue/reactivity</span></strong><span class="koboSpan" id="kobo.210.1"> (</span><a href="http://npmjs.com/package/@vue/reactivity"><span class="koboSpan" id="kobo.211.1">npmjs.com/package/@vue/reactivity</span></a><span class="koboSpan" id="kobo.212.1">). </span><span class="koboSpan" id="kobo.212.2">Reactivity is an important part of a framework feature set, and we are going to explore it further in </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">later chapters.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.214.1">Dependency injection</span></strong><span class="koboSpan" id="kobo.215.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.216.1">DI</span></strong><span class="koboSpan" id="kobo.217.1">) is at the </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.218.1">core of some frameworks and allows modules within the framework and the application to declare their dependencies and use external interfaces. </span><span class="koboSpan" id="kobo.218.2">As part of DI, frameworks also have interfaces to declare dependency providers. </span><span class="koboSpan" id="kobo.218.3">You will find the use of DI in some frameworks, most famously in Angular. </span><span class="koboSpan" id="kobo.218.4">There is a guide and more details on Angular’s DI at </span><a href="http://angular.io/guide/dependency-injection"><span class="koboSpan" id="kobo.219.1">angular.io/guide/dependency-injection</span></a><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">Due to the lack of interfaces and typing in JavaScript, the DI features are not as popular and are enabled through TypeScript or other compilers. </span><span class="koboSpan" id="kobo.220.3">You will also find injection features in Nest.js on </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">the backend.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">You will find a familiar pattern (as shown in the following code block) for DI in both Angular and Nest.js; the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">@Injectable</span></strong><span class="koboSpan" id="kobo.224.1"> decorator implementation is defined in one of the core </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.225.1">packages</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.226.1"> of the framework </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">at </span></span><a href="http://github.com/angular/angular/blob/main/packages/core/src/di/injectable.ts"><span class="No-Break"><span class="koboSpan" id="kobo.228.1">github.com/angular/angular/blob/main/packages/core/src/di/injectable.ts</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.229.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.230.1">
// service: book.service.ts
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: ‹root›
})
export class BookService {
  constructor() { }
}
// module: book.module.ts
import { BookService } from './book.service';
@NgModule({
  providers: [BookService],
})
export class BookModule {}</span></pre>
<p><span class="koboSpan" id="kobo.231.1">Another common core API is the </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">renderer</span></strong><span class="koboSpan" id="kobo.233.1">, which is responsible for converting the template or the programmatic </span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.234.1">user interface component into a browser or virtual DOM structure that can be later used on the page or the component output. </span><span class="koboSpan" id="kobo.234.2">In Ember.js, rendering is made possible by its internal engine</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.235.1"> called </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Glimmer</span></strong><span class="koboSpan" id="kobo.237.1">. </span><span class="koboSpan" id="kobo.237.2">It is included by internal components in Ember and installed from its own source at </span><a href="http://github.com/glimmerjs/glimmer.js"><span class="koboSpan" id="kobo.238.1">github.com/glimmerjs/glimmer.js</span></a><span class="koboSpan" id="kobo.239.1">. </span><span class="koboSpan" id="kobo.239.2">Frameworks may offer flexible rendering options that allow for browser and server-side rendering of components. </span><span class="koboSpan" id="kobo.239.3">Some frameworks also allow you to extend and define existing renderers for custom behaviors. </span><span class="koboSpan" id="kobo.239.4">Vue.js provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">createRenderer()</span></strong><span class="koboSpan" id="kobo.241.1"> API to do just that – you can learn more about it </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">at </span></span><a href="http://vuejs.org/api/custom-renderer.html"><span class="No-Break"><span class="koboSpan" id="kobo.243.1">vuejs.org/api/custom-renderer.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.244.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.245.1">Full stack and backend frameworks </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.246.1">provide a </span><strong class="bold"><span class="koboSpan" id="kobo.247.1">server interface</span></strong><span class="koboSpan" id="kobo.248.1"> as part of the public APIs. </span><span class="koboSpan" id="kobo.248.2">We saw an example of this interface in </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.249.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.250.1">. </span><span class="koboSpan" id="kobo.250.2">A good architectural example from that chapter was Nest.js with an option to swap out server implementations. </span><span class="koboSpan" id="kobo.250.3">Another good example of a server package is the Next.js server (</span><a href="http://github.com/vercel/next.js/tree/canary/packages/next/src/server"><span class="koboSpan" id="kobo.251.1">github.com/vercel/next.js/tree/canary/packages/next/src/server</span></a><span class="koboSpan" id="kobo.252.1">). </span><span class="koboSpan" id="kobo.252.2">In this case, Next.js uses the server package for a lot of internal functionality. </span><span class="koboSpan" id="kobo.252.3">The framework allows some access to the server internals, but it is quite limited. </span><span class="koboSpan" id="kobo.252.4">For Svelte apps, the SvelteKit framework takes the</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.253.1"> approach of exposing adapters. </span><span class="koboSpan" id="kobo.253.2">These </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.254.1">adapters let the user decide and adapt to their deployment target. </span><span class="koboSpan" id="kobo.254.2">For Node.js server users, there is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">@sveltejs/adapter-node</span></strong><span class="koboSpan" id="kobo.256.1"> adapter. </span><span class="koboSpan" id="kobo.256.2">In addition, the framework provides several official adapters, specified at </span><a href="http://kit.svelte.dev/docs/adapters"><span class="koboSpan" id="kobo.257.1">kit.svelte.dev/docs/adapters</span></a><span class="koboSpan" id="kobo.258.1">, that allow you to define adapters for maximum flexibility and compatibility with the deployment environment. </span><span class="koboSpan" id="kobo.258.2">It can also be the case that a frontend framework only uses a server as part of its internal components to enable development functionality, but in production use cases, developers would need to provide their </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">own server.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.260.1">Source of the Svelte.js node.js adapter</span></p>
<p class="callout"><span class="koboSpan" id="kobo.261.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">chapter3</span></strong><span class="koboSpan" id="kobo.263.1"> directory provides the source of the Svelte.js node.js adapter after it is extracted by the installation script. </span><span class="koboSpan" id="kobo.263.2">The framework uses this to consume code input and produce output in a </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">framework-friendly manner.</span></span></p>
<p><span class="koboSpan" id="kobo.265.1">Often, all types of </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.266.1">frameworks have a </span><strong class="bold"><span class="koboSpan" id="kobo.267.1">shared package</span></strong><span class="koboSpan" id="kobo.268.1"> that could consist of both public and private APIs. </span><span class="koboSpan" id="kobo.268.2">Usually, the most general logic, which is reused across many packages, goes into the shared package. </span><span class="koboSpan" id="kobo.268.3">Some contenders for the shared package could be code that is related to the runtime environment and the fundamentals. </span><span class="koboSpan" id="kobo.268.4">For example, this package can include utility functions, managing and escaping HTML entities, dealing with HTTP status codes, normalizing universal values across the whole framework, and storing constant</span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.269.1"> values usable across </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">the </span></span><span class="No-Break"><a id="_idIndexMarker287"/></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1">framework.</span></span></p>
<p><span class="koboSpan" id="kobo.272.1">In the next section, we are going to look at the entry points of frameworks – that is, the glue that connects the core APIs with the start of </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">framework execution.</span></span></p>
<h3><span class="koboSpan" id="kobo.274.1">Entry points</span></h3>
<p><span class="koboSpan" id="kobo.275.1">The primary way </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.276.1">the framework’s users interact </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.277.1">with the framework is through an </span><em class="italic"><span class="koboSpan" id="kobo.278.1">entry point</span></em><span class="koboSpan" id="kobo.279.1">. </span><span class="koboSpan" id="kobo.279.2">This definition is very similar to an entry point of a simple program, and it is the place where the execution begins when we run a simple computer program. </span><span class="koboSpan" id="kobo.279.3">Depending on the framework’s abstractions and structure, this kind of entry point could be </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">very different.</span></span></p>
<p><span class="koboSpan" id="kobo.281.1">In frontend JavaScript frameworks, the concept of the entry point varies. </span><span class="koboSpan" id="kobo.281.2">These frameworks can be included via a </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.283.1"> tag and later initialized on the page by calling the entry points. </span><span class="koboSpan" id="kobo.283.2">Angular has a root bootstrap module that is called upon to initialize the application, as </span><span class="No-Break"><span class="koboSpan" id="kobo.284.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.285.1">
app.module.ts
@NgModule({
  imports: [
    // ...
</span><span class="koboSpan" id="kobo.285.2">  ],
  declarations: [
    AppComponent,
  ],
  bootstrap: [
    AppComponent
  ]
})
export class AppModule { }</span></pre>
<p><span class="koboSpan" id="kobo.286.1">In the preceding code, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">AppModule</span></strong><span class="koboSpan" id="kobo.288.1"> root module is essential to initialize the application as it loads in the browser. </span><span class="koboSpan" id="kobo.288.2">It also defines the space to include top-level imports and service providers to enable external features in </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">Ember.js uses a similar pattern by defining an instance of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Application</span></strong><span class="koboSpan" id="kobo.292.1"> class to instantiate a new application. </span><span class="koboSpan" id="kobo.292.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">Application</span></strong><span class="koboSpan" id="kobo.294.1"> class extends the </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">Ember.Application</span></strong><span class="koboSpan" id="kobo.296.1"> class and provides an object literal with configuration options. </span><span class="koboSpan" id="kobo.296.2">This object is used to configure the various components and features of the application. </span><span class="koboSpan" id="kobo.296.3">This entry point class is used to hold other classes of the application as developers further expand the features of their project. </span><span class="koboSpan" id="kobo.296.4">To get precise details on this </span><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">Application</span></strong><span class="koboSpan" id="kobo.298.1"> class, check out the API documentation for it </span><span class="No-Break"><span class="koboSpan" id="kobo.299.1">at </span></span><a href="http://api.emberjs.com/ember/release/classes/Application"><span class="No-Break"><span class="koboSpan" id="kobo.300.1">api.emberjs.com/ember/release/classes/Application</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.301.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.302.1">Looking at SvelteKit as a different framework, due to the way it defines its abstractions, it relies on compiler and build tooling to be the initial entry point. </span><span class="koboSpan" id="kobo.302.2">The compiler detects the main </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">page.svelte</span></strong><span class="koboSpan" id="kobo.304.1"> file in the root directory and treats that as an entry point to the index page of the application. </span><span class="koboSpan" id="kobo.304.2">Unlike Angular and Ember.js, this is a much less verbose </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">entry point.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">Another </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.307.1">entry </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.308.1">point example is the configuration file </span><span class="No-Break"><span class="koboSpan" id="kobo.309.1">in Nuxt.js:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.310.1">
nuxt.config.js
export default defineNuxtConfig({
  // My Nuxt config
})</span></pre>
<p><span class="koboSpan" id="kobo.311.1">This file is defined in the root of the project. </span><span class="koboSpan" id="kobo.311.2">It allows for framework configuration and extension and accepts a variety of options. </span><span class="koboSpan" id="kobo.311.3">All these possible options are available </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">at </span></span><a href="http://nuxt.com/docs/api/configuration/nuxt-config"><span class="No-Break"><span class="koboSpan" id="kobo.313.1">nuxt.com/docs/api/configuration/nuxt-config</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.314.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.315.1">In terms of pure backend frameworks, usually, the entry point is the bootstrap file that starts the server. </span><span class="koboSpan" id="kobo.315.2">As the server process boots up, it initializes the server configuration, such as properly binding the process to a particular port. </span><span class="koboSpan" id="kobo.315.3">This process is very well illustrated for </span><em class="italic"><span class="koboSpan" id="kobo.316.1">AdonisJs</span></em><span class="koboSpan" id="kobo.317.1"> as a state-changing machine at </span><a href="http://docs.adonisjs.com/guides/application#boot-lifecycle"><span class="koboSpan" id="kobo.318.1">docs.adonisjs.com/guides/application#boot-lifecycle</span></a><span class="koboSpan" id="kobo.319.1">. </span><span class="koboSpan" id="kobo.319.2">This bootstrap is also similar to </span><em class="italic"><span class="koboSpan" id="kobo.320.1">NestJs</span></em><span class="koboSpan" id="kobo.321.1"> as the framework has a server-side </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">AppModule</span></strong><span class="koboSpan" id="kobo.323.1"> that is used to bootstrap </span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">the server.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">The following source code is for the Nest.js bootstrap script that initializes the application. </span><span class="koboSpan" id="kobo.325.2">It has to import </span><strong class="source-inline"><span class="koboSpan" id="kobo.326.1">NestFactory</span></strong><span class="koboSpan" id="kobo.327.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">AppModule</span></strong><span class="koboSpan" id="kobo.329.1"> as part of this process. </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">await listen</span></strong><span class="koboSpan" id="kobo.331.1"> enables listening to </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">incoming requests:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.333.1">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
async function bootstrap() {
  const application = await NestFactory.create(AppModule);
  await application.listen(process.env.PORT ?
</span><span class="koboSpan" id="kobo.333.2">     parseInt(process.env.PORT) : 8080);
}
bootstrap();</span></pre>
<p><span class="koboSpan" id="kobo.334.1">This entry point file can work with environment variables to bootstrap the application on the desired port. </span><span class="koboSpan" id="kobo.334.2">The included </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">AppModule</span></strong><span class="koboSpan" id="kobo.336.1"> file contains the additional modules defined by the user that </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.337.1">will be loaded as the script starts. </span><span class="koboSpan" id="kobo.337.2">This</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.338.1"> pattern is prevalent in other frameworks too, such as Express.js </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">and Hapi.js.</span></span></p>
<h3><span class="koboSpan" id="kobo.340.1">Developer tools</span></h3>
<p><span class="koboSpan" id="kobo.341.1">You may find </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.342.1">sets </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.343.1">of developer tools that make it easier to interact with the framework while you’re working on applications. </span><span class="koboSpan" id="kobo.343.2">These tools are intended to help with profiling, debugging, and other tasks. </span><span class="koboSpan" id="kobo.343.3">In frontend projects, these tools are often provided as browser extensions or </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">standalone apps.</span></span></p>
<p><span class="koboSpan" id="kobo.345.1">Vue.js provides well-integrated tools as part of its workflows through browser and standalone tooling. </span><span class="koboSpan" id="kobo.345.2">It allows us to quickly understand the application structure and further debug the output of the application. </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.346.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.347.1">.4</span></em><span class="koboSpan" id="kobo.348.1"> shows an example of the tools </span><span class="No-Break"><span class="koboSpan" id="kobo.349.1">in action:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<span class="koboSpan" id="kobo.350.1"><img alt="Figure 3.4: Vue.js browser developer tools" src="image/Figure_3.4_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.351.1">Figure 3.4: Vue.js browser developer tools</span></p>
<p><span class="koboSpan" id="kobo.352.1">Frontend frameworks provide some good examples of developer tooling, mostly as browser </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.353.1">extensions but sometimes as</span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.354.1"> standalone applications to decouple away from </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">browser workflow:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.356.1">Angular DevTools</span></strong><span class="koboSpan" id="kobo.357.1"> (</span><a href="http://angular.io/guide/devtools"><span class="koboSpan" id="kobo.358.1">angular.io/guide/devtools</span></a><span class="koboSpan" id="kobo.359.1">): These</span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.360.1"> tools provide profiling capabilities and debugging features. </span><span class="koboSpan" id="kobo.360.2">It renders the component tree, similar to what’s shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.361.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.362.1">.4</span></em> <span class="No-Break"><span class="koboSpan" id="kobo.363.1">in Vue.js.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.364.1">Vue.js DevTools</span></strong><span class="koboSpan" id="kobo.365.1"> (</span><a href="http://github.com/vuejs/devtools"><span class="koboSpan" id="kobo.366.1">github.com/vuejs/devtools</span></a><span class="koboSpan" id="kobo.367.1">): As</span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.368.1"> shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.369.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.370.1">.4</span></em><span class="koboSpan" id="kobo.371.1">, it provides a detailed component tree with search as well as a route list that helps debug the router configuration. </span><span class="koboSpan" id="kobo.371.2">It also enables the timeline view to show a history of interaction with a </span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">Vue.js application.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.373.1">Ember Inspector</span></strong><span class="koboSpan" id="kobo.374.1"> (</span><a href="http://guides.emberjs.com/release/ember-inspector"><span class="koboSpan" id="kobo.375.1">guides.emberjs.com/release/ember-inspector</span></a><span class="koboSpan" id="kobo.376.1">): This tooling provides </span><a id="_idIndexMarker300"/><span class="koboSpan" id="kobo.377.1">an extensive number of features. </span><span class="koboSpan" id="kobo.377.2">It provides a way to explore Ember objects, the component tree, routing, data views, </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">and more.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.379.1">React Developer Tools</span></strong><span class="koboSpan" id="kobo.380.1"> (</span><a href="http://beta.reactjs.org/learn/react-developer-tools"><span class="koboSpan" id="kobo.381.1">beta.reactjs.org/learn/react-developer-tools</span></a><span class="koboSpan" id="kobo.382.1">): These tools allow you to</span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.383.1"> inspect components, edit live properties of components, and modify </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">the state.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.385.1">SolidJS Developer Tools</span></strong><span class="koboSpan" id="kobo.386.1"> (</span><a href="http://github.com/thetarnav/solid-devtools"><span class="koboSpan" id="kobo.387.1">github.com/thetarnav/solid-devtools</span></a><span class="koboSpan" id="kobo.388.1">): These tools visualize</span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.389.1"> and add the ability to interact with the SolidJS reactivity graph. </span><span class="koboSpan" id="kobo.389.2">Like other tools, it can inspect the component state and navigate </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">the tree.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.391.1">An interesting challenge you can consider while supporting developer tools in your frameworks is keeping up with framework updates. </span><span class="koboSpan" id="kobo.391.2">Vue.js DevTools approaches this problem by targeting the major version of a framework – it defines a package for each version, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">app-backend-vue1</span></strong><span class="koboSpan" id="kobo.393.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">app-backend-vue2</span></strong><span class="koboSpan" id="kobo.395.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">app-backend-vue3</span></strong><span class="koboSpan" id="kobo.397.1">, and so on. </span><span class="koboSpan" id="kobo.397.2">Given that most of the time, these are browser extensions, they have a similar architecture for utilizing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">DevTool</span></strong><span class="koboSpan" id="kobo.399.1"> extension browser </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">APIs (</span></span><a href="http://developer.chrome.com/docs/extensions/mv3/devtools"><span class="No-Break"><span class="koboSpan" id="kobo.401.1">developer.chrome.com/docs/extensions/mv3/devtools</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.402.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">You may notice the lack of additional developer tools for backend frameworks. </span><span class="koboSpan" id="kobo.403.2">In those cases, developers rely on debuggers, such as a text editor or an IDE, as their tools of choice. </span><span class="koboSpan" id="kobo.403.3">We looked at Node.js application and framework debugging in </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.404.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.405.1"> while debugging a </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">Nest.js application.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">In framework development, introducing additional specific developer tools is not a necessary step at </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.408.1">first. </span><span class="koboSpan" id="kobo.408.2">However, it makes the framework much more pleasant to work with and empowers its users. </span><span class="koboSpan" id="kobo.408.3">These days, JavaScript runtime environments generally have great tooling that helps with development no matter what framework </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">you use.</span></span></p>
<h3><span class="koboSpan" id="kobo.410.1">Plugin and extension APIs</span></h3>
<p><span class="koboSpan" id="kobo.411.1">In many instances, the </span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.412.1">packages provided </span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.413.1">by frameworks also enable extensibility. </span><span class="koboSpan" id="kobo.413.2">This kind of extensibility enables plugin and extension development, benefiting the framework in many ways. </span><span class="koboSpan" id="kobo.413.3">The provided API empowers other developers to customize the functionality and add new capabilities focused on the specific needs of the applications. </span><span class="koboSpan" id="kobo.413.4">It also allows the framework to stay focused on delivering the main feature set and not include every potential feature in the </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">framework’s core.</span></span></p>
<p><span class="koboSpan" id="kobo.415.1">This extensibility may be useful as part of internal development, where framework authors can create adapters and interfaces based on the extension interface. </span><span class="koboSpan" id="kobo.415.2">It can also be useful for external use cases, where developers outside of the core development team can create features for specific use cases that plug into the framework. </span><span class="koboSpan" id="kobo.415.3">Let’s take a look at some examples of plugin interfaces that are provided by the frameworks we looked at in </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.416.1">Chapter 1</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.417.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.418.1">Bootstrap</span></strong><span class="koboSpan" id="kobo.419.1"> (</span><a href="https://getbootstrap.com/docs/5.0/extend/approach/"><span class="koboSpan" id="kobo.420.1">https://getbootstrap.com/docs/5.0/extend/approach/</span></a><span class="koboSpan" id="kobo.421.1">) has documentation that</span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.422.1"> consists of the guiding principles to create customizable components that work well with its core functionality. </span><span class="koboSpan" id="kobo.422.2">For this project, developers defined a set of rules that serve as </span><span class="No-Break"><span class="koboSpan" id="kobo.423.1">the guideline.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.424.1">Ember.js</span></strong><span class="koboSpan" id="kobo.425.1"> (</span><a href="http://cli.emberjs.com/release/writing-addons"><span class="koboSpan" id="kobo.426.1">cli.emberjs.com/release/writing-addons</span></a><span class="koboSpan" id="kobo.427.1">) has “add-on” support that can be installed using the CLI with </span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">ember install &lt;addon&gt;</span></strong><span class="koboSpan" id="kobo.429.1">. </span><span class="koboSpan" id="kobo.429.2">It has a full section that supports add-on development as part of its documentation. </span><span class="koboSpan" id="kobo.429.3">For example, must-have functionality for most applications, such as authentication, is provided via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.430.1">Ember Simple Auth</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.431.1">add-on (</span></span><a href="http://ember-simple-auth.com"><span class="No-Break"><span class="koboSpan" id="kobo.432.1">ember-simple-auth.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.433.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.434.1">Vue.js</span></strong><span class="koboSpan" id="kobo.435.1"> (</span><a href="http://vuejs.org/guide/reusability/plugins.html"><span class="koboSpan" id="kobo.436.1">vuejs.org/guide/reusability/plugins.html</span></a><span class="koboSpan" id="kobo.437.1">) enables plugin development, which provides new application-level functionality. </span><span class="koboSpan" id="kobo.437.2">As part of defining a plugin, developers need to export an </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">install</span></strong><span class="koboSpan" id="kobo.439.1"> function that executes the </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">plugin logic.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.441.1">Angular</span></strong><span class="koboSpan" id="kobo.442.1"> (</span><a href="http://angular.io/guide/creating-libraries"><span class="koboSpan" id="kobo.443.1">angular.io/guide/creating-libraries</span></a><span class="koboSpan" id="kobo.444.1">) calls these extensible interfaces “libraries.” </span><span class="koboSpan" id="kobo.444.2">Using</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.445.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">ng</span></strong><span class="koboSpan" id="kobo.447.1"> command-line</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.448.1"> tooling, developers can quickly generate these new libraries. </span><span class="koboSpan" id="kobo.448.2">As part of the library’s workflow, the new modules get published to </span><em class="italic"><span class="koboSpan" id="kobo.449.1">npm</span></em><span class="koboSpan" id="kobo.450.1"> for others </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">to use.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.452.1">Gatsby</span></strong><span class="koboSpan" id="kobo.453.1"> (</span><a href="http://gatsbyjs.com/docs/plugins"><span class="koboSpan" id="kobo.454.1">gatsbyjs.com/docs/plugins</span></a><span class="koboSpan" id="kobo.455.1">) has several plugins and very good documentation that enables their development. </span><span class="koboSpan" id="kobo.455.2">It provides workflows to develop generic plugins for any use, local plugins specific to a single project, and transformer plugins that convert data </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">between types.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.457.1">SolidJS</span></strong><span class="koboSpan" id="kobo.458.1"> (</span><a href="http://solidjs.com/ecosystem"><span class="koboSpan" id="kobo.459.1">solidjs.com/ecosystem</span></a><span class="koboSpan" id="kobo.460.1">) defines an ecosystem of add-ons to fit different purposes. </span><span class="koboSpan" id="kobo.460.2">Developers can choose from a variety of UI, router, data, and general add-on plugin categories. </span><span class="koboSpan" id="kobo.460.3">The most popular category is the user interface additions, which make it easier to approach various web application layouts </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">and widgets.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.462.1">Svelte</span></strong><span class="koboSpan" id="kobo.463.1"> (</span><a href="http://sveltesociety.dev/tools"><span class="koboSpan" id="kobo.464.1">sveltesociety.dev/tools</span></a><span class="koboSpan" id="kobo.465.1">) has a set of tools that are developed to improve the bundling, debugging, and </span><span class="No-Break"><span class="koboSpan" id="kobo.466.1">editor experience.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.467.1">Hapi.js</span></strong><span class="koboSpan" id="kobo.468.1"> (</span><a href="http://hapi.dev/tutorials/plugins"><span class="koboSpan" id="kobo.469.1">hapi.dev/tutorials/plugins</span></a><span class="koboSpan" id="kobo.470.1">) provides a powerful interface to extend the server-side functionality of the framework. </span><span class="koboSpan" id="kobo.470.2">The plugins have a fairly simple interface, where an asynchronous function is used to register and perform any additional </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">extended functionality.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.472.1">AdonisJS</span></strong><span class="koboSpan" id="kobo.473.1"> (</span><a href="http://packages.adonisjs.com"><span class="koboSpan" id="kobo.474.1">packages.adonisjs.com</span></a><span class="koboSpan" id="kobo.475.1">) provides “packages” that extend functionality. </span><span class="koboSpan" id="kobo.475.2">To speed up package development, Adonis uses an </span><strong class="bold"><span class="koboSpan" id="kobo.476.1">MRM</span></strong><span class="koboSpan" id="kobo.477.1"> code modification </span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.478.1">preset, which can be found at </span><a href="http://github.com/adonisjs/mrm-preset"><span class="koboSpan" id="kobo.479.1">github.com/adonisjs/mrm-preset</span></a><span class="koboSpan" id="kobo.480.1">. </span><span class="koboSpan" id="kobo.480.2">It allows you to quickly scaffold packages for </span><span class="No-Break"><span class="koboSpan" id="kobo.481.1">its framework.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.482.1">From the examples we just discussed, you can hopefully see that as part of writing your framework, it is </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.483.1">good to enable this kind of</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.484.1"> extensibility. </span><span class="koboSpan" id="kobo.484.2">It will help the framework grow and benefit all those who are involved in your </span><span class="No-Break"><span class="koboSpan" id="kobo.485.1">framework’s ecosystem.</span></span></p>
<p><span class="koboSpan" id="kobo.486.1">In the next section, we’ll explore the variety of scripts that help administer </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">today’s frameworks.</span></span></p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.488.1">Scripts</span></h2>
<p><span class="koboSpan" id="kobo.489.1">Every framework needs</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.490.1"> to be able to perform tasks on behalf of its users, and for those building the framework as well, this is where the architecture requires the introduction of various scripts and programs that can perform those day-to-day tasks. </span><span class="koboSpan" id="kobo.490.2">These scripts often help developers be more efficient and eliminate redundant tasks. </span><span class="koboSpan" id="kobo.490.3">Well-defined powerful scripts can also make the framework very pleasant to use. </span><span class="koboSpan" id="kobo.490.4">In this section, we are going to take a look at binaries and executables that are shipped with the framework, file generators, and other popular tooling </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">within </span></span><span class="No-Break"><a id="_idIndexMarker313"/></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">frameworks.</span></span></p>
<h3><span class="koboSpan" id="kobo.493.1">Binaries and executables</span></h3>
<p><span class="koboSpan" id="kobo.494.1">Binaries and script</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.495.1"> files help with framework development and sometimes serve as an interface for users of the framework. </span><span class="koboSpan" id="kobo.495.2">These scripts can include build steps, automation, and other JavaScript-related tasks. </span><span class="koboSpan" id="kobo.495.3">In some cases, these can be helper scripts or can be run consistently as part of the coding process. </span><span class="koboSpan" id="kobo.495.4">Often, these are written in JavaScript/TypeScript to ensure cross-platform execution and to keep the workflow consistent with the </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">same language.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">Today’s frameworks have various executable tasks, and you may find short </span><strong class="source-inline"><span class="koboSpan" id="kobo.498.1">npm</span></strong><span class="koboSpan" id="kobo.499.1"> commands or full-fledged script files. </span><span class="koboSpan" id="kobo.499.2">These executables can be used for the </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">following purposes:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.501.1">Building and publishing</span></strong><span class="koboSpan" id="kobo.502.1">: This involves releasing new versions of the framework. </span><span class="koboSpan" id="kobo.502.2">At the beginning of this chapter, in the </span><em class="italic"><span class="koboSpan" id="kobo.503.1">Exploring the core architecture</span></em><span class="koboSpan" id="kobo.504.1"> section, we saw examples of multiple framework versions that are generated based on the same source. </span><span class="koboSpan" id="kobo.504.2">This is where a good build script that also updates the change log file and creates source version tags can be handy. </span><span class="koboSpan" id="kobo.504.3">This workflow can also involve generating static assets and uploading framework artifacts. </span><span class="koboSpan" id="kobo.504.4">A simple example of this can be found in </span><span class="No-Break"><span class="koboSpan" id="kobo.505.1">Ember.js (</span></span><a href="http://github.com/emberjs/ember.js/blob/master/bin/build-for-publishing.js"><span class="No-Break"><span class="koboSpan" id="kobo.506.1">github.com/emberjs/ember.js/blob/master/bin/build-for-publishing.js</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.507.1">).</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.508.1">Full test runner</span></strong><span class="koboSpan" id="kobo.509.1">: An executable to run tests or other test integrations. </span><span class="koboSpan" id="kobo.509.2">Frameworks have many types of tests, and it is often important to create a script that can set up the test environment and swiftly execute all or just the </span><span class="No-Break"><span class="koboSpan" id="kobo.510.1">needed tests.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.511.1">Development workflow</span></strong><span class="koboSpan" id="kobo.512.1">: A script to quickly get started with the development of the framework. </span><span class="koboSpan" id="kobo.512.2">Usually, this includes starting a JavaScript bundler, a file watcher, and sometimes a </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">development server.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.514.1">Managing dependencies</span></strong><span class="koboSpan" id="kobo.515.1">: Here, you can install and rebuild dependencies. </span><span class="koboSpan" id="kobo.515.2">Given that a lot of the parts of the framework can be in separate packages or repositories, it becomes much more efficient to automate the dependency </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">management process.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.517.1">Linting and code coverage</span></strong><span class="koboSpan" id="kobo.518.1">: Similar to the test runner, linting and code coverage ensure good code quality standards. </span><span class="koboSpan" id="kobo.518.2">These tools analyze the source code and track down abnormal usages of the language. </span><span class="koboSpan" id="kobo.518.3">Code coverage tools ensure that tests run through all paths of a </span><span class="No-Break"><span class="koboSpan" id="kobo.519.1">framework’s code.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.520.1">JavaScript frameworks use the scripts field of </span><strong class="source-inline"><span class="koboSpan" id="kobo.521.1">package.json</span></strong><span class="koboSpan" id="kobo.522.1"> (</span><a href="http://docs.npmjs.com/cli/using-npm/scripts"><span class="koboSpan" id="kobo.523.1">docs.npmjs.com/cli/using-npm/scripts</span></a><span class="koboSpan" id="kobo.524.1">) to define a set of common scripts. </span><span class="koboSpan" id="kobo.524.2">In the existing frameworks, you may find that the list of scripts defined in that field can be very large – Vue.js, for example, has over 30 script commands defined in the core package file. </span><span class="koboSpan" id="kobo.524.3">Angular created a tool called </span><strong class="source-inline"><span class="koboSpan" id="kobo.525.1">ng-dev</span></strong><span class="koboSpan" id="kobo.526.1"> (</span><a href="http://github.com/angular/dev-infra/tree/main/ng-dev"><span class="koboSpan" id="kobo.527.1">github.com/angular/dev-infra/tree/main/ng-dev</span></a><span class="koboSpan" id="kobo.528.1">) to manage all </span><span class="No-Break"><span class="koboSpan" id="kobo.529.1">development tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.530.1">AdonisJS (</span><a href="http://github.com/adonisjs/core/blob/develop/package.json"><span class="koboSpan" id="kobo.531.1">github.com/adonisjs/core/blob/develop/package.json</span></a><span class="koboSpan" id="kobo.532.1">) has a fairly short script list that also serves as a good example of possible scripts a framework may require. </span><span class="koboSpan" id="kobo.532.2">Here, we </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.533.1">can see examples of the publishing workflow, testing, linting, </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">and more:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1">
"mrm": "mrm --preset=@adonisjs/mrm-preset",
"pretest": "npm run lint",
"test": "node -r @adonisjs/require-ts/build/
  register bin/test.ts",
"clean": "del-cli build",
"build": "npm run compile",
"commit": "git-cz",
"release": "np --message=\"chore(release): %s\"",
"version": "npm run build",
"prepublishOnly": "npm run build",
"lint": "eslint . </span><span class="koboSpan" id="kobo.535.2">--ext=.ts",
"format": "prettier --write .",</span></pre>
<p><span class="koboSpan" id="kobo.536.1">Some of these scripts are shortcuts, such as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">clean</span></strong><span class="koboSpan" id="kobo.538.1"> task, and call out to another tool to perform </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">the action.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">As part of building your framework, it is a good idea to identify the common tasks you perform while working on the framework and publishing new releases. </span><span class="koboSpan" id="kobo.540.2">Once you do that, create a series of well-defined scripts for those tasks. </span><span class="koboSpan" id="kobo.540.3">This will result in a much more organized</span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.541.1"> and pleasant </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">development workflow.</span></span></p>
<h3><span class="koboSpan" id="kobo.543.1">File generators</span></h3>
<p><span class="koboSpan" id="kobo.544.1">You will often find</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.545.1"> that tools are provided to generate code for common components of a project. </span><span class="koboSpan" id="kobo.545.2">Usually, these “generate” the necessary skeleton files that can be later modified by the developer to add custom business logic. </span><span class="koboSpan" id="kobo.545.3">If you add this kind of scaffolding functionality to your framework, then it will allow developers to reduce the repetition of code written by hand and save time by preventing unexpected errors from being introduced by manually writing parts of the project. </span><span class="koboSpan" id="kobo.545.4">Commonly, the generators also create test files and configure the test runner, which is another time saver. </span><span class="koboSpan" id="kobo.545.5">These generator commands are often bundled with the framework and provided by a </span><span class="No-Break"><span class="koboSpan" id="kobo.546.1">command-line interface.</span></span></p>
<p><span class="koboSpan" id="kobo.547.1">JavaScript frameworks employ this generator pattern by allowing the application to be scaffolded or allowing developers to scaffold additional components as the project progresses. </span><span class="koboSpan" id="kobo.547.2">For example, Angular generates code using schematics (</span><a href="http://angular.io/guide/schematics"><span class="koboSpan" id="kobo.548.1">angular.io/guide/schematics</span></a><span class="koboSpan" id="kobo.549.1">). </span><span class="koboSpan" id="kobo.549.2">It has built-in schematics for its entities but also allows developers to author their own schematics. </span><span class="koboSpan" id="kobo.549.3">With</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.550.1"> this </span><strong class="bold"><span class="koboSpan" id="kobo.551.1">Schematics API</span></strong><span class="koboSpan" id="kobo.552.1">, you can create custom tasks to perform on the application project, including the ability to fully manipulate the files </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">and directories.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">In another instance, Next.js offers an application scaffolding tool called </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">create-next-app</span></strong><span class="koboSpan" id="kobo.556.1"> (</span><a href="http://github.com/vercel/next.js/tree/canary/packages/create-next-app"><span class="koboSpan" id="kobo.557.1">github.com/vercel/next.js/tree/canary/packages/create-next-app</span></a><span class="koboSpan" id="kobo.558.1">), which allows framework users to quickly get started building an application </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">with Next.js:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.560.1">
&gt; npx create-next-app@latest
Need to install the following packages:
  create-next-app@13.1.6
Ok to proceed? </span><span class="koboSpan" id="kobo.560.2">(y) y
✔ What is your project named? </span><span class="koboSpan" id="kobo.560.3">... </span><span class="koboSpan" id="kobo.560.4">framework-architecture
? </span><span class="koboSpan" id="kobo.560.5">Would you like to use TypeScript with this project? </span><span class="koboSpan" id="kobo.560.6">&gt; No / Yes</span></pre>
<p><span class="koboSpan" id="kobo.561.1">The Next.js generator is built using common JavaScript modules and just like many web frameworks, it utilizes Node.js for this type </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">of tooling.</span></span></p>
<p><span class="koboSpan" id="kobo.563.1">Depending on how you intend your framework to be used, you will have to choose what kind of generator functionality you want to provide. </span><span class="koboSpan" id="kobo.563.2">If your framework is part of a large internal project and is often not used to create new application projects, then a schematic-like Angular approach would be </span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">more suitable.</span></span></p>
<p><span class="koboSpan" id="kobo.565.1">In </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.566.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.567.1">, we saw that many of the frameworks, such as Gatsby, are static site generators. </span><span class="koboSpan" id="kobo.567.2">This is another use case where a framework can rely on site generators based on some file </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.568.1">generation tooling. </span><span class="koboSpan" id="kobo.568.2">This pattern can benefit in the same manner as with any generator – abstract away complexity, eliminate repetitive tasks, and </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">reduce maintenance.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.570.1">Compilers</span></h2>
<p><span class="koboSpan" id="kobo.571.1">In general </span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.572.1">computing, a compiler translates some type of source code into another target source code. </span><span class="koboSpan" id="kobo.572.2">JavaScript puts quite a twist on this with a huge number of compiler tools available, with many of these tools approaching the challenges of web development in different ways while adapting to the latest architectural trends. </span><span class="koboSpan" id="kobo.572.3">As years go by, more and more frameworks are using some sort of compiler for development purposes, enabling these projects to cherish the benefits of these tools. </span><span class="koboSpan" id="kobo.572.4">In this section, we are going to cover some examples that are used in </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">frameworks today.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">The development improvements and the workflows that these tools enable vastly benefit framework developers. </span><span class="koboSpan" id="kobo.574.2">When you are creating a new JavaScript framework, you will most certainly appreciate utilizing </span><span class="No-Break"><span class="koboSpan" id="kobo.575.1">these tools.</span></span></p>
<h3><span class="koboSpan" id="kobo.576.1">Framework compiler and builders</span></h3>
<p><span class="koboSpan" id="kobo.577.1">The framework</span><a id="_idIndexMarker321"/><span class="koboSpan" id="kobo.578.1"> structure is usually assembled with a build tool. </span><span class="koboSpan" id="kobo.578.2">The goal of this step is to take all the necessary assets of the framework, perform specific optimizations on them, and output a developer-friendly bundle of code that targets a characteristic runtime environment. </span><span class="koboSpan" id="kobo.578.3">A JavaScript framework often uses such a tool as its build system. </span><span class="koboSpan" id="kobo.578.4">As part of this section, we’ll examine some of the possible compiler and </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">bundler options:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.580.1">tsc</span></strong><span class="koboSpan" id="kobo.581.1">: The compiler</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.582.1"> behind TypeScript, </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">tsc</span></strong><span class="koboSpan" id="kobo.584.1"> is the binary that can be invoked to build and analyze TypeScript files and turn them into </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">JavaScript files.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.586.1">Webpack</span></strong><span class="koboSpan" id="kobo.587.1">: This is a bundler compiler that can multiplex JavaScript and other web development-related files. </span><span class="koboSpan" id="kobo.587.2">Due to its popularity and extensive features, webpack has support for many advanced </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">development features.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.589.1">Turbopack</span></strong><span class="koboSpan" id="kobo.590.1">: A Webpack successor written by its authors in Rust, Go, and TypeScript, Turbopack consists of a bundler and an incremental build system. </span><span class="koboSpan" id="kobo.590.2">Similar to Webpack, the Turbo toolchain focuses on bundling your development assets into an optimized bundle. </span><span class="koboSpan" id="kobo.590.3">Turbo uses the Rust programming language to achieve faster builds, especially for </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">larger projects.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.592.1">esbuild</span></strong><span class="koboSpan" id="kobo.593.1">: Written in the Go programming language, this tool parallelizes the workload to create </span><span class="No-Break"><span class="koboSpan" id="kobo.594.1">JavaScript bundles.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.595.1">Babel</span></strong><span class="koboSpan" id="kobo.596.1">: This is a </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.597.1">toolchain for transforming and generating new JavaScript syntax into compatible old syntax while focusing on cross-browser support and support for various JavaScript environments. </span><span class="koboSpan" id="kobo.597.2">You can include it in the build pipeline of your framework to make it functional and testable in </span><span class="No-Break"><span class="koboSpan" id="kobo.598.1">older browsers.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.599.1">rollup</span></strong><span class="koboSpan" id="kobo.600.1">: A module bundler for creating optimized bundles of JavaScript, it has a large ecosystem of configurations and plugins. </span><span class="koboSpan" id="kobo.600.2">It is very suitable for framework use due to its low overhead and </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">output flexibility.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.602.1">Parcel</span></strong><span class="koboSpan" id="kobo.603.1">: This is a bundler tool that focuses on zero or minimal configuration. </span><span class="koboSpan" id="kobo.603.2">Parcel ships many built-in optimizations and automatically applies transforms for popular source types into JavaScript. </span><span class="koboSpan" id="kobo.603.3">Parcel can be used to produce optimized application bundles consisting of both business logic and </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">framework code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.605.1">Speedy Web Compiler</span></strong><span class="koboSpan" id="kobo.606.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.607.1">SWC</span></strong><span class="koboSpan" id="kobo.608.1">): This is </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.609.1">based on the Rust programming language, and its focus is</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.610.1"> to speed up the TypeScript compiling step. </span><span class="koboSpan" id="kobo.610.2">It’s used by Next.js </span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.611.1">and the </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.612.1">fresh</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.613.1"> framework.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.614.1">Jest  – a testing framework that we mentioned in </span><a href="B19014_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.615.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.616.1"> – uses Babel to build the testing framework itself. </span><span class="koboSpan" id="kobo.616.2">As the framework user, you can also opt-in to specific JavaScript targets by tweaking the Babel environment configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">via </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">babel.config.js</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.620.1">
module.exports = {
 presets: ['module:metro-react-native-babel-preset'],
}</span></pre>
<p><span class="koboSpan" id="kobo.621.1">The preset in the preceding code block allows Jest to run in the React Native environment, which is different from usual JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.622.1">application runtimes.</span></span></p>
<p><span class="koboSpan" id="kobo.623.1">The framework compiler can be the core piece of technology as it enables all the main features of the system. </span><span class="koboSpan" id="kobo.623.2">Svelte-based applications use the Svelte compiler, which takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.624.1">.svelte</span></strong><span class="koboSpan" id="kobo.625.1"> file and outputs </span><span class="No-Break"><span class="koboSpan" id="kobo.626.1">JavaScript files:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.627.1">
App.svelte
&lt;script&gt;
  let bookChapter=3;
  console.log(bookChapter);
&lt;/script&gt;</span></pre>
<p><span class="koboSpan" id="kobo.628.1">Given a basic </span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.629.1">script, the JavaScript output that’s produced includes the required Svelte dependencies and the </span><span class="No-Break"><span class="koboSpan" id="kobo.630.1">initialized </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">SvelteComponent</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.633.1">
import { SvelteComponent, init, safe_not_equal } from
  "svelte/internal";
let bookChapter = 3;
function instance($$self) {
  console.log(bookChapter);
  return [];
}
class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, null, safe_not_equal,
      s{});
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.634.1">The preceding generated code is the compiler output and moves the instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.635.1">console.log</span></strong><span class="koboSpan" id="kobo.636.1"> to the instance function. </span><span class="koboSpan" id="kobo.636.2">After compilation, the script tag is removed, and the code is wrapped into an </span><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">instance</span></strong><span class="koboSpan" id="kobo.638.1"> function, which executes the code as part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.639.1">App</span></strong><span class="koboSpan" id="kobo.640.1"> component. </span><span class="koboSpan" id="kobo.640.2">This becomes the entry point to an application that’s powered by Svelte. </span><span class="koboSpan" id="kobo.640.3">Svelte is capable of parsing CSS styling blocks and HTML-like syntax. </span><span class="koboSpan" id="kobo.640.4">More examples of the compiler in action can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">at </span></span><a href="http://svelte.dev/examples"><span class="No-Break"><span class="koboSpan" id="kobo.642.1">svelte.dev/examples</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.643.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.644.1">If the framework </span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.645.1">uses a compiler that converts from statically typed code, then you may need to define and expose the defined types. </span><span class="koboSpan" id="kobo.645.2">In the next section, we will explore how </span><span class="No-Break"><span class="koboSpan" id="kobo.646.1">that works.</span></span></p>
<h3><span class="koboSpan" id="kobo.647.1">Types</span></h3>
<p><span class="koboSpan" id="kobo.648.1">Exporting and</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.649.1"> building with a type system is another part of framework architecture and has become more and more popular in the modern JavaScript workflow. </span><span class="koboSpan" id="kobo.649.2">We have seen many frameworks utilize TypeScript for their architecture. </span><span class="koboSpan" id="kobo.649.3">TypeScript provides several options to organize these interfaces and types. </span><span class="koboSpan" id="kobo.649.4">It defines the implementation in </span><strong class="source-inline"><span class="koboSpan" id="kobo.650.1">.ts</span></strong><span class="koboSpan" id="kobo.651.1"> files and the declaration files in </span><strong class="source-inline"><span class="koboSpan" id="kobo.652.1">.d.ts</span></strong><span class="koboSpan" id="kobo.653.1"> files. </span><span class="koboSpan" id="kobo.653.2">As part of this architecture, the framework declares its TypeScript types for its internal and external files. </span><span class="koboSpan" id="kobo.653.3">The external types are available for the framework consumers as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.654.1">the documentation.</span></span></p>
<p><span class="koboSpan" id="kobo.655.1">The frameworks provide their type declarations as part of their published package. </span><span class="koboSpan" id="kobo.655.2">For example, the whole of the Solid.js framework is typed (</span><a href="http://solidjs.com/guides/typescript"><span class="koboSpan" id="kobo.656.1">solidjs.com/guides/typescript</span></a><span class="koboSpan" id="kobo.657.1">), just like many other projects, and includes the </span><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">types</span></strong><span class="koboSpan" id="kobo.659.1"> directory when it </span><span class="No-Break"><span class="koboSpan" id="kobo.660.1">is installed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer030">
<span class="koboSpan" id="kobo.661.1"><img alt="Figure 3.5: Provided type declaration in Solid.js" src="image/Figure_3.5_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.662.1">Figure 3.5: Provided type declaration in Solid.js</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.663.1">Solid</span></em><span class="koboSpan" id="kobo.664.1"> distributes the type definitions as part of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.665.1">npm</span></strong><span class="koboSpan" id="kobo.666.1"> package, providing specific definitions for the </span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.667.1">server, renderer, and </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">reactive interface.</span></span></p>
<p><span class="koboSpan" id="kobo.669.1">In the next section, we are going to look at source maps, another type of compiled file that gets distributed with frameworks for the benefit of the </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">development workflow.</span></span></p>
<h3><span class="koboSpan" id="kobo.671.1">Source maps</span></h3>
<p><span class="koboSpan" id="kobo.672.1">The concept </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.673.1">of </span><strong class="bold"><span class="koboSpan" id="kobo.674.1">source maps</span></strong><span class="koboSpan" id="kobo.675.1"> was introduced into</span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.676.1"> JavaScript development more than 10 years ago. </span><span class="koboSpan" id="kobo.676.2">The purpose of source maps is to create a map from the built or generated code and turn it into the unbuilt version of the JavaScript file. </span><span class="koboSpan" id="kobo.676.3">This kind of map makes it easier to debug the minified or pre-built code. </span><span class="koboSpan" id="kobo.676.4">The generated files follow the source map specification (</span><a href="http://sourcemaps.info/spec.html"><span class="koboSpan" id="kobo.677.1">sourcemaps.info/spec.html</span></a><span class="koboSpan" id="kobo.678.1">) and usually end in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.679.1">.map</span></strong><span class="koboSpan" id="kobo.680.1"> file extension. </span><span class="koboSpan" id="kobo.680.2">These maps are often created as part of some compilation or build process, hence why we’ll learn about them in </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">this section.</span></span></p>
<p><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.682.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.683.1">.6</span></em><span class="koboSpan" id="kobo.684.1"> shows a snippet of a generated source map, though much of it is </span><span class="No-Break"><span class="koboSpan" id="kobo.685.1">not humanly-readable:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<span class="koboSpan" id="kobo.686.1"><img alt="Figure 3.6: Generated source map of Angular’s core.js file" src="image/Figure_3.6_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.687.1">Figure 3.6: Generated source map of Angular’s core.js file</span></p>
<p><span class="koboSpan" id="kobo.688.1">Here, we can see that the generated map is using the third version of the specification; the rest of the map is meant to be parsed by web-browser tooling that can process most of </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">this file.</span></span></p>
<p><span class="koboSpan" id="kobo.690.1">As part of the published releases of frontend frameworks, the map files are provided as part of the framework bundle and it is up to developers to decide what to do with these files. </span><span class="koboSpan" id="kobo.690.2">The whole project can make the source maps available when the project is deployed into development environments. </span><span class="koboSpan" id="kobo.690.3">For example, Vue.js uses </span><em class="italic"><span class="koboSpan" id="kobo.691.1">esbuild</span></em><span class="koboSpan" id="kobo.692.1"> to bundle its code in development environments and </span><em class="italic"><span class="koboSpan" id="kobo.693.1">rollup</span></em><span class="koboSpan" id="kobo.694.1"> in production builds. </span><span class="koboSpan" id="kobo.694.2">As part of the build process, it </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.695.1">can</span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.696.1"> pass an option to both of these utilities to generate a source map for the output file. </span><span class="koboSpan" id="kobo.696.2">More about this feature in </span><em class="italic"><span class="koboSpan" id="kobo.697.1">esbuild</span></em><span class="koboSpan" id="kobo.698.1"> can be found at </span><a href="http://esbuild.github.io/api/#sourcemap"><span class="koboSpan" id="kobo.699.1">esbuild.github.io/api/#sourcemap</span></a><span class="koboSpan" id="kobo.700.1">. </span><span class="koboSpan" id="kobo.700.2">Internally, </span><em class="italic"><span class="koboSpan" id="kobo.701.1">esbuild</span></em><span class="koboSpan" id="kobo.702.1"> uses the Go programming language to quickly build JavaScript projects and it has a source map specification implementation in its repository at </span><a href="http://github.com/evanw/esbuild/tree/main/internal/sourcemap"><span class="koboSpan" id="kobo.703.1">github.com/evanw/esbuild/tree/main/internal/sourcemap</span></a><span class="koboSpan" id="kobo.704.1">. </span><span class="koboSpan" id="kobo.704.2">This is just one of the implementations, depending on how you decide to structure your framework. </span><span class="koboSpan" id="kobo.704.3">You will be able to find many ways to generate the source maps for </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">your project.</span></span></p>
<p><span class="koboSpan" id="kobo.706.1">Source maps are utilized in server-side JavaScript as well. </span><span class="koboSpan" id="kobo.706.2">Due to the increased use of abstracted ways of writing JavaScript, the source map feature in Node.js can help you trace back to the original code, which could have been written in ClojureScript, TypeScript, or </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">another language.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">Usually, it is not</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.709.1"> that </span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.710.1">difficult to enable source map support in your framework. </span><span class="koboSpan" id="kobo.710.2">However, you need to make sure you configure it properly, making sure that the web browser tools can actually use the map properly and only expose the source map when it </span><span class="No-Break"><span class="koboSpan" id="kobo.711.1">is applicable.</span></span></p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.712.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.713.1">This chapter focused on the technical architectural structure of JavaScript frameworks. </span><span class="koboSpan" id="kobo.713.2">We focused on the three important parts of framework architecture: packages, scripts, and compilers. </span><span class="koboSpan" id="kobo.713.3">Combining this with the knowledge we gained from </span><em class="italic"><span class="koboSpan" id="kobo.714.1">Chapters 1</span></em><span class="koboSpan" id="kobo.715.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.716.1">2</span></em><span class="koboSpan" id="kobo.717.1">, we can start pinpointing the core differences in how various frameworks have their architectures structured. </span><span class="koboSpan" id="kobo.717.2">Having an overview of architectural patterns helps us understand how existing frameworks are formulated and makes it easier for us to build </span><span class="No-Break"><span class="koboSpan" id="kobo.718.1">new frameworks.</span></span></p>
<p><span class="koboSpan" id="kobo.719.1">Exploring established projects helps us borrow the best ideas from existing open source frameworks. </span><span class="koboSpan" id="kobo.719.2">In addition, learning the internal designs provides insight into how the frameworks fit into complex code bases that utilize a framework. </span><span class="koboSpan" id="kobo.719.3">The next chapter will look at development support techniques and patterns that make framework development and usability </span><span class="No-Break"><span class="koboSpan" id="kobo.720.1">even better.</span></span></p>
</div>
</body></html>