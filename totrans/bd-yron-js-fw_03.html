<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor051"/>3</h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Internal Framework Architecture</h1>
<p>In the previous chapters, we learned about the history of the current frameworks and explored the concept of abstractions. We also looked at how JavaScript frameworks use, combine, and extend different abstractions to make a framework functional. In this chapter, we will dive into the architectural patterns of JavaScript frameworks. To go even further and expand our framework knowledge, we will have to closely inspect what goes into making a modern framework and what we can learn from existing patterns.</p>
<p>As part of this chapter, we will explore the following:</p>
<ul>
<li>Understanding the core technical architectural patterns of existing frontend and backend frameworks. We will focus on the design, architecture, and structural patterns that are combined into a single system.</li>
<li>Getting a glimpse into framework APIs, packaging configurations, and additional tooling.</li>
<li>Understanding additional tools that benefit the framework.</li>
<li>Exposure to available compiles and bundlers.</li>
</ul>
<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Technical requirements</h1>
<p>Similar to the previous chapter, we will be using this book’s repository as an extension of this chapter. You can find it at <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>, and the relevant files are in the <code>chapter3</code> directory. To run the code in this repository, you can use any environment that supports using a Terminal or a command prompt, running Node.js, such as Windows, macOS, and most varieties of Linux.</p>
<p>Most of the code mentioned in this chapter can be found in this book’s repository, so you don’t have to navigate external repositories. Follow the <code>README.md</code> instructions in the <code>chapter3</code> directory to get started. In addition, a lot of framework architecture focuses on the stakeholders or developers who will use the framework to build new projects. In this chapter, we will refer to them as <em class="italic">framework users</em>, not to be confused with the end users of applications built with these frameworks.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor054"/>Exploring the core architecture</h1>
<p>Let’s explore the <a id="_idIndexMarker257"/>core architectural pieces of building a framework. When a framework project is created, it is usually partitioned into an organized directory structure consisting of various specialized compartments. This approach helps separate the concerns of specific modules, scripts, and files. This organizational pattern is similar to how web application projects are organized. Except in the case of the framework, the project needs to export public interfaces and scripts to be usable. In some cases, frameworks can also be split into multiple repositories to allow a different approach to framework development.</p>
<p>Given that the programming environment for every language is different, the JavaScript and TypeScript frameworks have their own ways of structuring the framework projects, making it easier to generate artifacts and make the frameworks more usable within the projects that utilize them. A well-organized project makes it easier to maintain, collaborate, and refactor many parts of said project. For instance, let’s take real-world examples such as Vue.js and Angular. Angular keeps most of the framework files in a single repository (which can be found at <a href="http://github.com/angular/angular">github.com/angular/angular</a>), except its command-line tools (located at <a href="http://github.com/angular/angular-cli">github.com/angular/angular-cli</a>). However, many packages are published as separate dependencies in the package registry, such as <strong class="bold">npm</strong> (which can be found<a id="_idIndexMarker258"/> at <a href="http://npmjs.com/package/@angular/core">npmjs.com/package/@angular/core</a>). The resulting payload for the framework package can be different from a frontend framework. In the case of Angular, it consists of pre-built files for different versions of JavaScript.</p>
<p>In <em class="italic">Figure 3</em><em class="italic">.1</em>, Angular core is provided as unflattened and flattened versions in the <code>esm2020</code>, <code>fesm2015</code>, <code>fesm2020</code> directories, and these packages also include various source maps:</p>
<div><div><img alt="Figure 3.1: Angular core files provided as an npm package" src="img/Figure_3.1_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1: Angular core files provided as an npm package</p>
<p>Depending on the browser target or the bundler technology used, Angular offers multiple import options. Vue.js has a similarly packaged export that offers a myriad of options to load the framework in a particular JavaScript module environment.</p>
<p>The output directory in <em class="italic">Figure 3</em><em class="italic">.2</em> is the result of packaging the Vue.js framework using <code>rollup.js</code> (<a href="http://rollupjs.org">rollupjs.org</a>) to create an output configuration for each of the target runtimes. The source <a id="_idIndexMarker259"/>of this configuration can be found at <a href="http://github.com/vuejs/core/blob/main/rollup.config.js">github.com/vuejs/core/blob/main/rollup.config.js</a>:</p>
<div><div><img alt="Figure 3.2: Vue.js distribution as an NPM package" src="img/Figure_3.2_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2: Vue.js distribution as an NPM package</p>
<p>The produced files of the targeted configurations slowly evolve with the runtime target as time progresses. For instance, if the framework is not usually included as a global variable inside of a <code>&lt;script&gt;</code> tag, then it might make sense to get rid of the global variable output or let the framework users convert the resulting output of the framework to suit their needs.</p>
<p class="callout-heading">Examples of packaged frameworks</p>
<p class="callout">You can check <a id="_idIndexMarker260"/>out the examples of the framework bundles by running the <code>npm start</code> script in the <code>chapter3</code> directory. Once the packaged framework sources have been downloaded and extracted, you can view several resulting outputs for Angular and Vue.js.</p>
<p>Now that a build step <a id="_idIndexMarker261"/>is so widespread in JavaScript projects, these frameworks also provide direct ways to import the framework packages and include them as part of the build process. The “unflattened” version of the framework would be an example of this, where the framework files are not concatenated. Instead, the bundler would be combining those files and optimizing them with techniques such as code splitting if possible.</p>
<p>The applications that use the framework import the dependencies in the <code>package.json</code> file. Angular splits the different parts of the framework into different packages:</p>
<pre class="source-code">
"dependencies": {
    "@angular/animations": "^15.2.0",
    "@angular/common": "^15.2.0",
    "@angular/compiler": "^15.2.0",
    "@angular/core": "^15.2.0",
    "@angular/forms": "^15.2.0",
    "@angular/platform-browser": "^15.2.0",
    "@angular/router": "^15.2.0",
},</pre>
<p>Splitting these modules into their own packages creates a well-defined boundary between the different modules. However, extra release tooling is usually required to make it easier to manage and release multiple modules without manually packaging them. The split packages also benefit framework users as they can pick and choose which modules are required for their applications.</p>
<p class="callout-heading">Angular core dependencies in action</p>
<p class="callout">The framework<a id="_idIndexMarker262"/> showcase from <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> has an existing example of all the Angular dependencies mentioned in this section. You can find the application in the <code>chapter1/angular</code> directory, run it, and tweak it to your preference. Many of these core dependencies can be found via the <code>@angular</code> namespace in the <code>npm</code> package list at <code>npmjs.com/search?q=%40angular</code>.</p>
<p>In the case of Vue.js, the core architecture is divided across many repositories at <a href="http://github.com/vuejs">github.com/vuejs</a>. The core, router, developer tools, documentation, and other parts of the framework are split across repositories in the Vue.js organization. When building a new framework, it <a id="_idIndexMarker263"/>is often easier to manage most of it in a single repository and even keep everything in a single package. The structure can still be well separated, and it will avoid the extra friction of managing extra repositories. As your project grows, it is possible to split it into multiple repositories as you see fit. By that point, the framework should already have an established release model and infrastructure to support this kind of expansion.</p>
<p>To better understand the wider architectural patterns of framework design and maintenance, we are going to explore three important parts that comprise a framework’s technical architecture:</p>
<ul>
<li><strong class="bold">Modules</strong>: The isolated <a id="_idIndexMarker264"/>parts of the code base, usually in a single JavaScript file. These often import or export functions, classes, or other types of structures, which are later utilized as part of a larger system.</li>
<li><strong class="bold">Packages</strong>: The main source code behind the framework includes interfaces that are exposed to the users and interfaces that are used internally to facilitate certain functionality.</li>
<li><strong class="bold">Scripts</strong>: Binaries and scripts that are exposed as part of the framework. Some of the scripts are also used for framework development and extra tooling required for specific use cases.</li>
<li><strong class="bold">Compilers</strong>: The programs that are included as part of the framework that either generate the <a id="_idIndexMarker265"/>main JavaScript output from the framework or are used as part of the development process.</li>
</ul>
<p>Not everything in these categories is required for a successful framework, but as authors, we can pick and choose what is important to us for our project and focus on that. If we look at the existing frameworks of today, we will see similar patterns that work well for JavaScript, frontend, and backend projects – these projects employ all or most of these <a id="_idIndexMarker266"/>architectural categories.</p>
<p>In the next section, we will explore two types of technical patterns in framework development – these include architectural and design decisions that affect how the different frameworks function.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Patterns</h1>
<p>The focus on framework development requires learning about different types of software patterns, such as architectural, design, and technical patterns. Knowing about these patterns and what kind of decisions went into implementing them in existing frameworks can assist new framework authors at being successful in their projects.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Architectural patterns</h2>
<p>We saw examples of <a id="_idIndexMarker267"/>existing architectural patterns such as MVC and MVVM in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>. JavaScript frameworks have the freedom to choose any type of architectural model as they see fit for their use cases. For example, the component-based architecture is highly relevant in modern frontend frameworks and is used in many systems, especially those that extend the React library for their feature set. In this pattern, each component is encapsulated with its own state, a view, and a particular behavior, and could even consist of nested components.</p>
<p>In backend frameworks, the middleware architectural pattern is often utilized to manage or mutate incoming requests and outgoing responses. This type of pattern works well due to the nature of the server requests and responses.</p>
<p>A different approach to architectural patterns can be seen within the Electron.js application framework. For the most part, Electron.js is designed on top of process communication between the interface renderer process and the main process for the lower-level operations. This architectural approach does not define a particular name but still directs the architecture toward the separation of concerns. If you look at some of the code bases of the Electron.js applications, you will notice the organization between the two responsibilities of the interface and the backend operations. Frameworks can also use a mix of architectural patterns that combine aspects of object-oriented, functional, and reactive programming to enable the most flexibility. A lot of these concepts can be witnessed within the Nest.js framework, as highlighted in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>.</p>
<p>By browsing the design decisions and the code of various open source frameworks, you can find a variety of <a id="_idIndexMarker268"/>implementations of different architectural patterns. As a future framework author, I encourage you to innovate in this space by creating your original architectural patterns or deriving your own approach to the established patterns.</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Design patterns</h2>
<p>In terms of design patterns, these<a id="_idIndexMarker269"/> focus on a much lower level compared to architectural patterns. These patterns address how a framework can solve frequent challenges of organizing code and techniques to enable a cohesive architecture.</p>
<p>In <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we saw an example of a design pattern via the observer pattern. In addition to the observer technique, frameworks can also utilize a factory pattern, which helps create and manage reusable objects based on some definition. Depending on the implementation and the environment, additional enhancements may include managing the created objects. Another design pattern often seen in all types of JavaScript frameworks is the Publish and Subscribe pattern. This pattern allows both framework internals and components built with the framework abstractions to interact with each other by emitting events and subscribing to those events to create an asynchronous way of communicating between different parts of the system.</p>
<p>Modules and the module design pattern are also universal in all JavaScript software. You will find module APIs defined by the language itself and abstractions around modules refined by different frameworks. This pattern mainly concentrates on enforcing encapsulation, standardizing the code base, and preventing large convoluted pieces of code.</p>
<p>In the next section, we’ll look at the technical architecture. It consists of details related to the technical <a id="_idIndexMarker270"/>approach to outlining APIs, defining entry points, and using additional tooling to enable framework behaviors.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>The technical architecture</h1>
<p>The technical <a id="_idIndexMarker271"/>architecture and patterns mainly deal with technical challenges. For JavaScript applications, this could mean dealing with rendering a page, responding to a request, interacting with a database, loading an application, and more. In frameworks, the technical challenges extend beyond solving a particular technical problem. Instead, it is about creating a well-designed packaged system that can be beneficial for framework users to build their projects.</p>
<p>To create this system, framework authors need to combine a set of packaged interfaces and a usable set of scripts and also use additional software to improve the JavaScript programming experience.</p>
<p>While learning about the technical architecture, we are going to look at the three categories that enable the essential features of the framework. We are going to explore all the subcategories under these technical topics, as seen in <em class="italic">Figure 3</em><em class="italic">.3</em>:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Packages</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Scripts</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold" lang="en-US" xml:lang="en-US">Compilers</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Core APIs</p>
</td>
<td class="No-Table-Style">
<p>Binaries and executables</p>
</td>
<td class="No-Table-Style">
<p>Framework compilers and bundlers</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Entry points</p>
</td>
<td class="No-Table-Style">
<p>File generators</p>
</td>
<td class="No-Table-Style">
<p>Types</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Developer tools</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style">
<p>Source maps</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Plugin and extension APIs</p>
</td>
<td class="No-Table-Style"/>
<td class="No-Table-Style"/>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3: Subcategories of the technical architecture</p>
<p>We will start with<a id="_idIndexMarker272"/> the core packages of the framework that enable substantial functionality.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Packages</h2>
<p>Packages consist of<a id="_idIndexMarker273"/> the core logic of the framework, with public and private APIs. This directory can include any packages that are necessary for the framework to function. It consists of internal and public interfaces. It can also include a compiler or any building tools that are used as part of framework development or developer use cases. These include the core pieces that make the framework what it is. Depending on the framework, the packages can be functionally independent or rely on each other to function. In general, the packages part of the framework can consist of any related code that should be included as part of the framework, but there are several essential types of packages that today’s frameworks include. We are going to look at these in more detail in this section.</p>
<h3>Core APIs</h3>
<p>Depending <a id="_idIndexMarker274"/>on the framework, the “core” packages<a id="_idIndexMarker275"/> may consist of a variety of modules for providing public user-exposed interfaces and private interfaces to enable frameworks’ features. In <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, we saw examples of public APIs provided by framework packages, such as router, event-management, template modules, and more. The core packages are usually structured similarly in both frontend and backend frameworks.</p>
<p>Frontend frameworks<a id="_idIndexMarker276"/> enable <code>@vue/reactivity</code> (<a href="http://npmjs.com/package/@vue/reactivity">npmjs.com/package/@vue/reactivity</a>). Reactivity is an important part of a framework feature set, and we are going to explore it further in later chapters.</p>
<p><strong class="bold">Dependency injection</strong> (<strong class="bold">DI</strong>) is at the <a id="_idIndexMarker277"/>core of some frameworks and allows modules within the framework and the application to declare their dependencies and use external interfaces. As part of DI, frameworks also have interfaces to declare dependency providers. You will find the use of DI in some frameworks, most famously in Angular. There is a guide and more details on Angular’s DI at <a href="http://angular.io/guide/dependency-injection">angular.io/guide/dependency-injection</a>. Due to the lack of interfaces and typing in JavaScript, the DI features are not as popular and are enabled through TypeScript or other compilers. You will also find injection features in Nest.js on the backend.</p>
<p>You will find a familiar pattern (as shown in the following code block) for DI in both Angular and Nest.js; the <code>@Injectable</code> decorator implementation is defined in one of the core <a id="_idIndexMarker278"/>packages<a id="_idIndexMarker279"/> of the framework at <a href="http://github.com/angular/angular/blob/main/packages/core/src/di/injectable.ts">github.com/angular/angular/blob/main/packages/core/src/di/injectable.ts</a>:</p>
<pre class="source-code">
// service: book.service.ts
import { Injectable } from '@angular/core';
@Injectable({
  providedIn: ‹root›
})
export class BookService {
  constructor() { }
}
// module: book.module.ts
import { BookService } from './book.service';
@NgModule({
  providers: [BookService],
})
export class BookModule {}</pre>
<p>Another common core API is the <code>createRenderer()</code> API to do just that – you can learn more about it at <a href="http://vuejs.org/api/custom-renderer.html">vuejs.org/api/custom-renderer.html</a>.</p>
<p>Full stack and backend frameworks <a id="_idIndexMarker282"/>provide a <code>@sveltejs/adapter-node</code> adapter. In addition, the framework provides several official adapters, specified at <a href="http://kit.svelte.dev/docs/adapters">kit.svelte.dev/docs/adapters</a>, that allow you to define adapters for maximum flexibility and compatibility with the deployment environment. It can also be the case that a frontend framework only uses a server as part of its internal components to enable development functionality, but in production use cases, developers would need to provide their own server.</p>
<p class="callout-heading">Source of the Svelte.js node.js adapter</p>
<p class="callout">The <code>chapter3</code> directory provides the source of the Svelte.js node.js adapter after it is extracted by the installation script. The framework uses this to consume code input and produce output in a framework-friendly manner.</p>
<p>Often, all types of <a id="_idIndexMarker285"/>frameworks have a <strong class="bold">shared package</strong> that could consist of both public and private APIs. Usually, the most general logic, which is reused across many packages, goes into the shared package. Some contenders for the shared package could be code that is related to the runtime environment and the fundamentals. For example, this package can include utility functions, managing and escaping HTML entities, dealing with HTTP status codes, normalizing universal values across the whole framework, and storing constant<a id="_idIndexMarker286"/> values usable across the <a id="_idIndexMarker287"/>framework.</p>
<p>In the next section, we are going to look at the entry points of frameworks – that is, the glue that connects the core APIs with the start of framework execution.</p>
<h3>Entry points</h3>
<p>The primary way <a id="_idIndexMarker288"/>the framework’s users interact <a id="_idIndexMarker289"/>with the framework is through an <em class="italic">entry point</em>. This definition is very similar to an entry point of a simple program, and it is the place where the execution begins when we run a simple computer program. Depending on the framework’s abstractions and structure, this kind of entry point could be very different.</p>
<p>In frontend JavaScript frameworks, the concept of the entry point varies. These frameworks can be included via a <code>&lt;script&gt;</code> tag and later initialized on the page by calling the entry points. Angular has a root bootstrap module that is called upon to initialize the application, as shown here:</p>
<pre class="source-code">
app.module.ts
@NgModule({
  imports: [
    // ...
  ],
  declarations: [
    AppComponent,
  ],
  bootstrap: [
    AppComponent
  ]
})
export class AppModule { }</pre>
<p>In the preceding code, the <code>AppModule</code> root module is essential to initialize the application as it loads in the browser. It also defines the space to include top-level imports and service providers to enable external features in the application.</p>
<p>Ember.js uses a similar pattern by defining an instance of an <code>Application</code> class to instantiate a new application. This <code>Application</code> class extends the <code>Ember.Application</code> class and provides an object literal with configuration options. This object is used to configure the various components and features of the application. This entry point class is used to hold other classes of the application as developers further expand the features of their project. To get precise details on this <code>Application</code> class, check out the API documentation for it at <a href="http://api.emberjs.com/ember/release/classes/Application">api.emberjs.com/ember/release/classes/Application</a>.</p>
<p>Looking at SvelteKit as a different framework, due to the way it defines its abstractions, it relies on compiler and build tooling to be the initial entry point. The compiler detects the main <code>page.svelte</code> file in the root directory and treats that as an entry point to the index page of the application. Unlike Angular and Ember.js, this is a much less verbose entry point.</p>
<p>Another <a id="_idIndexMarker290"/>entry <a id="_idIndexMarker291"/>point example is the configuration file in Nuxt.js:</p>
<pre class="source-code">
nuxt.config.js
export default defineNuxtConfig({
  // My Nuxt config
})</pre>
<p>This file is defined in the root of the project. It allows for framework configuration and extension and accepts a variety of options. All these possible options are available at <a href="http://nuxt.com/docs/api/configuration/nuxt-config">nuxt.com/docs/api/configuration/nuxt-config</a>.</p>
<p>In terms of pure backend frameworks, usually, the entry point is the bootstrap file that starts the server. As the server process boots up, it initializes the server configuration, such as properly binding the process to a particular port. This process is very well illustrated for <em class="italic">AdonisJs</em> as a state-changing machine at <a href="http://docs.adonisjs.com/guides/application#boot-lifecycle">docs.adonisjs.com/guides/application#boot-lifecycle</a>. This bootstrap is also similar to <em class="italic">NestJs</em> as the framework has a server-side <code>AppModule</code> that is used to bootstrap the server.</p>
<p>The following source code is for the Nest.js bootstrap script that initializes the application. It has to import <code>NestFactory</code> and <code>AppModule</code> as part of this process. <code>await listen</code> enables listening to incoming requests:</p>
<pre class="source-code">
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
async function bootstrap() {
  const application = await NestFactory.create(AppModule);
  await application.listen(process.env.PORT ?
     parseInt(process.env.PORT) : 8080);
}
bootstrap();</pre>
<p>This entry point file can work with environment variables to bootstrap the application on the desired port. The included <code>AppModule</code> file contains the additional modules defined by the user that <a id="_idIndexMarker292"/>will be loaded as the script starts. This<a id="_idIndexMarker293"/> pattern is prevalent in other frameworks too, such as Express.js and Hapi.js.</p>
<h3>Developer tools</h3>
<p>You may find <a id="_idIndexMarker294"/>sets <a id="_idIndexMarker295"/>of developer tools that make it easier to interact with the framework while you’re working on applications. These tools are intended to help with profiling, debugging, and other tasks. In frontend projects, these tools are often provided as browser extensions or standalone apps.</p>
<p>Vue.js provides well-integrated tools as part of its workflows through browser and standalone tooling. It allows us to quickly understand the application structure and further debug the output of the application. <em class="italic">Figure 3</em><em class="italic">.4</em> shows an example of the tools in action:</p>
<div><div><img alt="Figure 3.4: Vue.js browser developer tools" src="img/Figure_3.4_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4: Vue.js browser developer tools</p>
<p>Frontend frameworks provide some good examples of developer tooling, mostly as browser <a id="_idIndexMarker296"/>extensions but sometimes as<a id="_idIndexMarker297"/> standalone applications to decouple away from browser workflow:</p>
<ul>
<li><strong class="bold">Angular DevTools</strong> (<a href="http://angular.io/guide/devtools">angular.io/guide/devtools</a>): These<a id="_idIndexMarker298"/> tools provide profiling capabilities and debugging features. It renders the component tree, similar to what’s shown in <em class="italic">Figure 3</em><em class="italic">.4</em> in Vue.js.</li>
<li><strong class="bold">Vue.js DevTools</strong> (<a href="http://github.com/vuejs/devtools">github.com/vuejs/devtools</a>): As<a id="_idIndexMarker299"/> shown in <em class="italic">Figure 3</em><em class="italic">.4</em>, it provides a detailed component tree with search as well as a route list that helps debug the router configuration. It also enables the timeline view to show a history of interaction with a Vue.js application.</li>
<li><strong class="bold">Ember Inspector</strong> (<a href="http://guides.emberjs.com/release/ember-inspector">guides.emberjs.com/release/ember-inspector</a>): This tooling provides <a id="_idIndexMarker300"/>an extensive number of features. It provides a way to explore Ember objects, the component tree, routing, data views, and more.</li>
<li><strong class="bold">React Developer Tools</strong> (<a href="http://beta.reactjs.org/learn/react-developer-tools">beta.reactjs.org/learn/react-developer-tools</a>): These tools allow you to<a id="_idIndexMarker301"/> inspect components, edit live properties of components, and modify the state.</li>
<li><strong class="bold">SolidJS Developer Tools</strong> (<a href="http://github.com/thetarnav/solid-devtools">github.com/thetarnav/solid-devtools</a>): These tools visualize<a id="_idIndexMarker302"/> and add the ability to interact with the SolidJS reactivity graph. Like other tools, it can inspect the component state and navigate the tree.</li>
</ul>
<p>An interesting challenge you can consider while supporting developer tools in your frameworks is keeping up with framework updates. Vue.js DevTools approaches this problem by targeting the major version of a framework – it defines a package for each version, such as <code>app-backend-vue1</code>, <code>app-backend-vue2</code>, <code>app-backend-vue3</code>, and so on. Given that most of the time, these are browser extensions, they have a similar architecture for utilizing the <code>DevTool</code> extension browser APIs (<a href="http://developer.chrome.com/docs/extensions/mv3/devtools">developer.chrome.com/docs/extensions/mv3/devtools</a>).</p>
<p>You may notice the lack of additional developer tools for backend frameworks. In those cases, developers rely on debuggers, such as a text editor or an IDE, as their tools of choice. We looked at Node.js application and framework debugging in <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a> while debugging a Nest.js application.</p>
<p>In framework development, introducing additional specific developer tools is not a necessary step at <a id="_idIndexMarker303"/>first. However, it makes the framework much more pleasant to work with and empowers its users. These days, JavaScript runtime environments generally have great tooling that helps with development no matter what framework you use.</p>
<h3>Plugin and extension APIs</h3>
<p>In many instances, the <a id="_idIndexMarker304"/>packages provided <a id="_idIndexMarker305"/>by frameworks also enable extensibility. This kind of extensibility enables plugin and extension development, benefiting the framework in many ways. The provided API empowers other developers to customize the functionality and add new capabilities focused on the specific needs of the applications. It also allows the framework to stay focused on delivering the main feature set and not include every potential feature in the framework’s core.</p>
<p>This extensibility may be useful as part of internal development, where framework authors can create adapters and interfaces based on the extension interface. It can also be useful for external use cases, where developers outside of the core development team can create features for specific use cases that plug into the framework. Let’s take a look at some examples of plugin interfaces that are provided by the frameworks we looked at in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>:</p>
<ul>
<li><strong class="bold">Bootstrap</strong> (<a href="https://getbootstrap.com/docs/5.0/extend/approach/">https://getbootstrap.com/docs/5.0/extend/approach/</a>) has documentation that<a id="_idIndexMarker306"/> consists of the guiding principles to create customizable components that work well with its core functionality. For this project, developers defined a set of rules that serve as the guideline.</li>
<li><code>ember install &lt;addon&gt;</code>. It has a full section that supports add-on development as part of its documentation. For example, must-have functionality for most applications, such as authentication, is provided via the <code>Ember Simple Auth</code> add-on (<a href="http://ember-simple-auth.com">ember-simple-auth.com</a>).</li>
<li><code>install</code> function that executes the plugin logic.</li>
<li><code>ng</code> command-line<a id="_idIndexMarker308"/> tooling, developers can quickly generate these new libraries. As part of the library’s workflow, the new modules get published to <em class="italic">npm</em> for others to use.</li>
<li><strong class="bold">Gatsby</strong> (<a href="http://gatsbyjs.com/docs/plugins">gatsbyjs.com/docs/plugins</a>) has several plugins and very good documentation that enables their development. It provides workflows to develop generic plugins for any use, local plugins specific to a single project, and transformer plugins that convert data between types.</li>
<li><strong class="bold">SolidJS</strong> (<a href="http://solidjs.com/ecosystem">solidjs.com/ecosystem</a>) defines an ecosystem of add-ons to fit different purposes. Developers can choose from a variety of UI, router, data, and general add-on plugin categories. The most popular category is the user interface additions, which make it easier to approach various web application layouts and widgets.</li>
<li><strong class="bold">Svelte</strong> (<a href="http://sveltesociety.dev/tools">sveltesociety.dev/tools</a>) has a set of tools that are developed to improve the bundling, debugging, and editor experience.</li>
<li><strong class="bold">Hapi.js</strong> (<a href="http://hapi.dev/tutorials/plugins">hapi.dev/tutorials/plugins</a>) provides a powerful interface to extend the server-side functionality of the framework. The plugins have a fairly simple interface, where an asynchronous function is used to register and perform any additional extended functionality.</li>
<li><strong class="bold">AdonisJS</strong> (<a href="http://packages.adonisjs.com">packages.adonisjs.com</a>) provides “packages” that extend functionality. To speed up package development, Adonis uses an <strong class="bold">MRM</strong> code modification <a id="_idIndexMarker309"/>preset, which can be found at <a href="http://github.com/adonisjs/mrm-preset">github.com/adonisjs/mrm-preset</a>. It allows you to quickly scaffold packages for its framework.</li>
</ul>
<p>From the examples we just discussed, you can hopefully see that as part of writing your framework, it is <a id="_idIndexMarker310"/>good to enable this kind of<a id="_idIndexMarker311"/> extensibility. It will help the framework grow and benefit all those who are involved in your framework’s ecosystem.</p>
<p>In the next section, we’ll explore the variety of scripts that help administer today’s frameworks.</p>
<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Scripts</h2>
<p>Every framework needs<a id="_idIndexMarker312"/> to be able to perform tasks on behalf of its users, and for those building the framework as well, this is where the architecture requires the introduction of various scripts and programs that can perform those day-to-day tasks. These scripts often help developers be more efficient and eliminate redundant tasks. Well-defined powerful scripts can also make the framework very pleasant to use. In this section, we are going to take a look at binaries and executables that are shipped with the framework, file generators, and other popular tooling within <a id="_idIndexMarker313"/>frameworks.</p>
<h3>Binaries and executables</h3>
<p>Binaries and script<a id="_idIndexMarker314"/> files help with framework development and sometimes serve as an interface for users of the framework. These scripts can include build steps, automation, and other JavaScript-related tasks. In some cases, these can be helper scripts or can be run consistently as part of the coding process. Often, these are written in JavaScript/TypeScript to ensure cross-platform execution and to keep the workflow consistent with the same language.</p>
<p>Today’s frameworks have various executable tasks, and you may find short <code>npm</code> commands or full-fledged script files. These executables can be used for the following purposes:</p>
<ul>
<li><strong class="bold">Building and publishing</strong>: This involves releasing new versions of the framework. At the beginning of this chapter, in the <em class="italic">Exploring the core architecture</em> section, we saw examples of multiple framework versions that are generated based on the same source. This is where a good build script that also updates the change log file and creates source version tags can be handy. This workflow can also involve generating static assets and uploading framework artifacts. A simple example of this can be found in Ember.js (<a href="http://github.com/emberjs/ember.js/blob/master/bin/build-for-publishing.js">github.com/emberjs/ember.js/blob/master/bin/build-for-publishing.js</a>).</li>
<li><strong class="bold">Full test runner</strong>: An executable to run tests or other test integrations. Frameworks have many types of tests, and it is often important to create a script that can set up the test environment and swiftly execute all or just the needed tests.</li>
<li><strong class="bold">Development workflow</strong>: A script to quickly get started with the development of the framework. Usually, this includes starting a JavaScript bundler, a file watcher, and sometimes a development server.</li>
<li><strong class="bold">Managing dependencies</strong>: Here, you can install and rebuild dependencies. Given that a lot of the parts of the framework can be in separate packages or repositories, it becomes much more efficient to automate the dependency management process.</li>
<li><strong class="bold">Linting and code coverage</strong>: Similar to the test runner, linting and code coverage ensure good code quality standards. These tools analyze the source code and track down abnormal usages of the language. Code coverage tools ensure that tests run through all paths of a framework’s code.</li>
</ul>
<p>JavaScript frameworks use the scripts field of <code>package.json</code> (<a href="http://docs.npmjs.com/cli/using-npm/scripts">docs.npmjs.com/cli/using-npm/scripts</a>) to define a set of common scripts. In the existing frameworks, you may find that the list of scripts defined in that field can be very large – Vue.js, for example, has over 30 script commands defined in the core package file. Angular created a tool called <code>ng-dev</code> (<a href="http://github.com/angular/dev-infra/tree/main/ng-dev">github.com/angular/dev-infra/tree/main/ng-dev</a>) to manage all development tasks.</p>
<p>AdonisJS (<a href="http://github.com/adonisjs/core/blob/develop/package.json">github.com/adonisjs/core/blob/develop/package.json</a>) has a fairly short script list that also serves as a good example of possible scripts a framework may require. Here, we <a id="_idIndexMarker315"/>can see examples of the publishing workflow, testing, linting, and more:</p>
<pre class="source-code">
"mrm": "mrm --preset=@adonisjs/mrm-preset",
"pretest": "npm run lint",
"test": "node -r @adonisjs/require-ts/build/
  register bin/test.ts",
"clean": "del-cli build",
"build": "npm run compile",
"commit": "git-cz",
"release": "np --message=\"chore(release): %s\"",
"version": "npm run build",
"prepublishOnly": "npm run build",
"lint": "eslint . --ext=.ts",
"format": "prettier --write .",</pre>
<p>Some of these scripts are shortcuts, such as the <code>clean</code> task, and call out to another tool to perform the action.</p>
<p>As part of building your framework, it is a good idea to identify the common tasks you perform while working on the framework and publishing new releases. Once you do that, create a series of well-defined scripts for those tasks. This will result in a much more organized<a id="_idIndexMarker316"/> and pleasant development workflow.</p>
<h3>File generators</h3>
<p>You will often find<a id="_idIndexMarker317"/> that tools are provided to generate code for common components of a project. Usually, these “generate” the necessary skeleton files that can be later modified by the developer to add custom business logic. If you add this kind of scaffolding functionality to your framework, then it will allow developers to reduce the repetition of code written by hand and save time by preventing unexpected errors from being introduced by manually writing parts of the project. Commonly, the generators also create test files and configure the test runner, which is another time saver. These generator commands are often bundled with the framework and provided by a command-line interface.</p>
<p>JavaScript frameworks employ this generator pattern by allowing the application to be scaffolded or allowing developers to scaffold additional components as the project progresses. For example, Angular generates code using schematics (<a href="http://angular.io/guide/schematics">angular.io/guide/schematics</a>). It has built-in schematics for its entities but also allows developers to author their own schematics. With<a id="_idIndexMarker318"/> this <strong class="bold">Schematics API</strong>, you can create custom tasks to perform on the application project, including the ability to fully manipulate the files and directories.</p>
<p>In another instance, Next.js offers an application scaffolding tool called <code>create-next-app</code> (<a href="http://github.com/vercel/next.js/tree/canary/packages/create-next-app">github.com/vercel/next.js/tree/canary/packages/create-next-app</a>), which allows framework users to quickly get started building an application with Next.js:</p>
<pre class="source-code">
&gt; npx create-next-app@latest
Need to install the following packages:
  create-next-app@13.1.6
Ok to proceed? (y) y
✔ What is your project named? ... framework-architecture
? Would you like to use TypeScript with this project? &gt; No / Yes</pre>
<p>The Next.js generator is built using common JavaScript modules and just like many web frameworks, it utilizes Node.js for this type of tooling.</p>
<p>Depending on how you intend your framework to be used, you will have to choose what kind of generator functionality you want to provide. If your framework is part of a large internal project and is often not used to create new application projects, then a schematic-like Angular approach would be more suitable.</p>
<p>In <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, we saw that many of the frameworks, such as Gatsby, are static site generators. This is another use case where a framework can rely on site generators based on some file <a id="_idIndexMarker319"/>generation tooling. This pattern can benefit in the same manner as with any generator – abstract away complexity, eliminate repetitive tasks, and reduce maintenance.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Compilers</h2>
<p>In general <a id="_idIndexMarker320"/>computing, a compiler translates some type of source code into another target source code. JavaScript puts quite a twist on this with a huge number of compiler tools available, with many of these tools approaching the challenges of web development in different ways while adapting to the latest architectural trends. As years go by, more and more frameworks are using some sort of compiler for development purposes, enabling these projects to cherish the benefits of these tools. In this section, we are going to cover some examples that are used in frameworks today.</p>
<p>The development improvements and the workflows that these tools enable vastly benefit framework developers. When you are creating a new JavaScript framework, you will most certainly appreciate utilizing these tools.</p>
<h3>Framework compiler and builders</h3>
<p>The framework<a id="_idIndexMarker321"/> structure is usually assembled with a build tool. The goal of this step is to take all the necessary assets of the framework, perform specific optimizations on them, and output a developer-friendly bundle of code that targets a characteristic runtime environment. A JavaScript framework often uses such a tool as its build system. As part of this section, we’ll examine some of the possible compiler and bundler options:</p>
<ul>
<li><code>tsc</code> is the binary that can be invoked to build and analyze TypeScript files and turn them into JavaScript files.</li>
<li><strong class="bold">Webpack</strong>: This is a bundler compiler that can multiplex JavaScript and other web development-related files. Due to its popularity and extensive features, webpack has support for many advanced development features.</li>
<li><strong class="bold">Turbopack</strong>: A Webpack successor written by its authors in Rust, Go, and TypeScript, Turbopack consists of a bundler and an incremental build system. Similar to Webpack, the Turbo toolchain focuses on bundling your development assets into an optimized bundle. Turbo uses the Rust programming language to achieve faster builds, especially for larger projects.</li>
<li><strong class="bold">esbuild</strong>: Written in the Go programming language, this tool parallelizes the workload to create JavaScript bundles.</li>
<li><strong class="bold">Babel</strong>: This is a <a id="_idIndexMarker323"/>toolchain for transforming and generating new JavaScript syntax into compatible old syntax while focusing on cross-browser support and support for various JavaScript environments. You can include it in the build pipeline of your framework to make it functional and testable in older browsers.</li>
<li><strong class="bold">rollup</strong>: A module bundler for creating optimized bundles of JavaScript, it has a large ecosystem of configurations and plugins. It is very suitable for framework use due to its low overhead and output flexibility.</li>
<li><strong class="bold">Parcel</strong>: This is a bundler tool that focuses on zero or minimal configuration. Parcel ships many built-in optimizations and automatically applies transforms for popular source types into JavaScript. Parcel can be used to produce optimized application bundles consisting of both business logic and framework code.</li>
<li><strong class="bold">Speedy Web Compiler</strong> (<strong class="bold">SWC</strong>): This is <a id="_idIndexMarker324"/>based on the Rust programming language, and its focus is<a id="_idIndexMarker325"/> to speed up the TypeScript compiling step. It’s used by Next.js <a id="_idIndexMarker326"/>and the <strong class="bold">fresh</strong> framework.</li>
</ul>
<p>Jest  – a testing framework that we mentioned in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> – uses Babel to build the testing framework itself. As the framework user, you can also opt-in to specific JavaScript targets by tweaking the Babel environment configuration via <code>babel.config.js</code>:</p>
<pre class="source-code">
module.exports = {
 presets: ['module:metro-react-native-babel-preset'],
}</pre>
<p>The preset in the preceding code block allows Jest to run in the React Native environment, which is different from usual JavaScript application runtimes.</p>
<p>The framework compiler can be the core piece of technology as it enables all the main features of the system. Svelte-based applications use the Svelte compiler, which takes a <code>.svelte</code> file and outputs JavaScript files:</p>
<pre class="source-code">
App.svelte
&lt;script&gt;
  let bookChapter=3;
  console.log(bookChapter);
&lt;/script&gt;</pre>
<p>Given a basic <a id="_idIndexMarker327"/>script, the JavaScript output that’s produced includes the required Svelte dependencies and the initialized <code>SvelteComponent</code>:</p>
<pre class="source-code">
import { SvelteComponent, init, safe_not_equal } from
  "svelte/internal";
let bookChapter = 3;
function instance($$self) {
  console.log(bookChapter);
  return [];
}
class App extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, null, safe_not_equal,
      s{});
  }
}</pre>
<p>The preceding generated code is the compiler output and moves the instance of <code>console.log</code> to the instance function. After compilation, the script tag is removed, and the code is wrapped into an <code>instance</code> function, which executes the code as part of the <code>App</code> component. This becomes the entry point to an application that’s powered by Svelte. Svelte is capable of parsing CSS styling blocks and HTML-like syntax. More examples of the compiler in action can be found at <a href="http://svelte.dev/examples">svelte.dev/examples</a>.</p>
<p>If the framework <a id="_idIndexMarker328"/>uses a compiler that converts from statically typed code, then you may need to define and expose the defined types. In the next section, we will explore how that works.</p>
<h3>Types</h3>
<p>Exporting and<a id="_idIndexMarker329"/> building with a type system is another part of framework architecture and has become more and more popular in the modern JavaScript workflow. We have seen many frameworks utilize TypeScript for their architecture. TypeScript provides several options to organize these interfaces and types. It defines the implementation in <code>.ts</code> files and the declaration files in <code>.d.ts</code> files. As part of this architecture, the framework declares its TypeScript types for its internal and external files. The external types are available for the framework consumers as part of the documentation.</p>
<p>The frameworks provide their type declarations as part of their published package. For example, the whole of the Solid.js framework is typed (<a href="http://solidjs.com/guides/typescript">solidjs.com/guides/typescript</a>), just like many other projects, and includes the <code>types</code> directory when it is installed:</p>
<div><div><img alt="Figure 3.5: Provided type declaration in Solid.js" src="img/Figure_3.5_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5: Provided type declaration in Solid.js</p>
<p><em class="italic">Solid</em> distributes the type definitions as part of the <code>npm</code> package, providing specific definitions for the <a id="_idIndexMarker330"/>server, renderer, and reactive interface.</p>
<p>In the next section, we are going to look at source maps, another type of compiled file that gets distributed with frameworks for the benefit of the development workflow.</p>
<h3>Source maps</h3>
<p>The concept <a id="_idIndexMarker331"/>of <code>.map</code> file extension. These maps are often created as part of some compilation or build process, hence why we’ll learn about them in this section.</p>
<p><em class="italic">Figure 3</em><em class="italic">.6</em> shows a snippet of a generated source map, though much of it is not humanly-readable:</p>
<div><div><img alt="Figure 3.6: Generated source map of Angular’s core.js file" src="img/Figure_3.6_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6: Generated source map of Angular’s core.js file</p>
<p>Here, we can see that the generated map is using the third version of the specification; the rest of the map is meant to be parsed by web-browser tooling that can process most of this file.</p>
<p>As part of the published releases of frontend frameworks, the map files are provided as part of the framework bundle and it is up to developers to decide what to do with these files. The whole project can make the source maps available when the project is deployed into development environments. For example, Vue.js uses <em class="italic">esbuild</em> to bundle its code in development environments and <em class="italic">rollup</em> in production builds. As part of the build process, it <a id="_idIndexMarker333"/>can<a id="_idIndexMarker334"/> pass an option to both of these utilities to generate a source map for the output file. More about this feature in <em class="italic">esbuild</em> can be found at <a href="http://esbuild.github.io/api/#sourcemap">esbuild.github.io/api/#sourcemap</a>. Internally, <em class="italic">esbuild</em> uses the Go programming language to quickly build JavaScript projects and it has a source map specification implementation in its repository at <a href="http://github.com/evanw/esbuild/tree/main/internal/sourcemap">github.com/evanw/esbuild/tree/main/internal/sourcemap</a>. This is just one of the implementations, depending on how you decide to structure your framework. You will be able to find many ways to generate the source maps for your project.</p>
<p>Source maps are utilized in server-side JavaScript as well. Due to the increased use of abstracted ways of writing JavaScript, the source map feature in Node.js can help you trace back to the original code, which could have been written in ClojureScript, TypeScript, or another language.</p>
<p>Usually, it is not<a id="_idIndexMarker335"/> that <a id="_idIndexMarker336"/>difficult to enable source map support in your framework. However, you need to make sure you configure it properly, making sure that the web browser tools can actually use the map properly and only expose the source map when it is applicable.</p>
<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Summary</h1>
<p>This chapter focused on the technical architectural structure of JavaScript frameworks. We focused on the three important parts of framework architecture: packages, scripts, and compilers. Combining this with the knowledge we gained from <em class="italic">Chapters 1</em> and <em class="italic">2</em>, we can start pinpointing the core differences in how various frameworks have their architectures structured. Having an overview of architectural patterns helps us understand how existing frameworks are formulated and makes it easier for us to build new frameworks.</p>
<p>Exploring established projects helps us borrow the best ideas from existing open source frameworks. In addition, learning the internal designs provides insight into how the frameworks fit into complex code bases that utilize a framework. The next chapter will look at development support techniques and patterns that make framework development and usability even better.</p>
</div>
</body></html>