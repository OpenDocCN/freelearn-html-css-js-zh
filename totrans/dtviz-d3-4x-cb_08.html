<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Chart Them Up</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a line chart</li><li class="listitem" style="list-style-type: disc">Creating an area chart</li><li class="listitem" style="list-style-type: disc">Creating a scatterplot chart</li><li class="listitem" style="list-style-type: disc">Creating a bubble chart</li><li class="listitem" style="list-style-type: disc">Creating a bar chart</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Introduction</h1></div></div></div><p>In this chapter, we will turn our attention to one of the oldest and well-trusted companions in data visualization-charts. Charts are well-defined and well-understood graphical representation of data; the following definition expresses it in the simplest terms:</p><div><blockquote class="blockquote"><p>
<em>(In charts) the data is represented by symbols, such as bars in a bar chart, lines in a line chart, or slices in a pie chart.</em>
</p></blockquote></div><div><blockquote class="blockquote"><p>
<em>Jensen C. &amp; Anderson L. (1991)</em>
</p></blockquote></div><p>When charts are used in data visualization, their well-understood graphical semantics and syntax relieve the audience of your visualization from the burden of learning the meaning of the graphical metaphor. Hence, they can focus on the data itself and the information generated through visualization. The goal of this chapter is not only to introduce some of the commonly used chart types but also to demonstrate how the various topics and techniques you learned so far can be combined and leveraged in producing sleek, interactive charts using D3.</p><p>Recipes in this chapter are much longer than the recipes we encountered so far since they are designed to implement fully functional and reusable charts. I have tried to break these into different segments and with consistent chart structures to ease your reading experience. However, it is still highly recommended to open the companion code examples in your browser and your text editor while you go through this chapter to minimize potential confusion and maximize the benefit.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec167"/>D3 chart convention</h2></div></div></div><p>Before you dive into creating your first reusable chart in D3, we need to cover some charting conventions commonly accepted in the D3 community; otherwise, you might risk creating charting libraries that might confuse your user instead of helping them.</p><div><div><h3 class="title"><a id="note71"/>Note</h3><p>As you would have imagined, D3 charts are most commonly implemented using SVG instead of HTML; however, the convention we will discuss here would also apply to HTML-based charts albeit the implementation details will be somewhat different.</p></div></div><p>Let's first take a look at the following diagram:</p><p>
</p><div><img src="img/image_08_001.jpg" alt="D3 chart convention"/></div><p>
</p><p>D3 chart convention</p><p>As shown in this diagram, the point of origin <em>(0, 0)</em> in an SVG image is at its top-leftmost corner as expected; however, the most important aspect of this convention pertains to how chart margins are defined and furthermore where the axes are placed.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Margins</strong>: First of all, let's take a look at the most important aspect of this convention-the margins. As you can see, for each chart, there are four different margin settings: left, right, top, and bottom margins. A flexible chart implementation should allow its user to set different values for each of these margins, and we will see in the later recipes how this can be achieved.</li><li class="listitem" style="list-style-type: disc"><strong>Coordinate translation</strong>: Secondly, this convention also suggests that the coordinate reference of the chart body (gray area) should be defined using a SVG translate transformation, <strong>translate(margin.left, margin.top)</strong>. This translation effectively moves the chart body area to the desired point; and one additional benefit of this approach is that by shifting the frame of reference for chart body coordinates, it simplifies the job of creating subelements inside the chart body since the margin size becomes irrelevant. For any subelement inside the chart body, its point of origin <em>(0, 0)</em> is now the top-leftmost corner of the chart body area.</li><li class="listitem" style="list-style-type: disc"><strong>Axes</strong>: Lastly, the final aspect of this convention is regarding how and where chart axes are placed. As shown in the preceding diagram, chart axes are placed inside chart margins instead of being a part of the chart body. This approach has the advantage of treating axes as peripheral elements in a chart, and hence, doesn't convolute the chart body implementation and additionally makes axes rendering logic chart independent and easily reusable.</li></ul></div><p>Now let's create our first reusable D3 chart with all the knowledge and techniques we covered so far.</p><div><div><h3 class="title"><a id="tip72"/>Tip</h3><p>To see this convention as it was explained by the creator of D3, please visit <a class="ulink" href="http://bl.ocks.org/mbostock/3019563">http://bl.ocks.org/mbostock/3019563
</a>.</p></div></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Creating a line chart</h1></div></div></div><p>Line chart is a common, basic chart type that is widely used in many fields. This chart consists of a series of data points connected by straight line segments. A line chart is also typically bordered by two perpendicular axes: the <em>x</em> axis and the <em>y</em> axis. In this recipe, we will take a look at how this basic chart can be implemented using D3 as a reusable JavaScript object that can be configured to display multiple data series on a different scale. Besides that, we will also show the technique of implementing a dynamic multi-data-series update with animation.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec168"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/line-chart.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/line-chart.html
</a>
</p><p>It is highly recommended that you have the companion code example open while reading this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec169"/>How to do it...</h2></div></div></div><p>Let's take a look at the following code that implements this chart type; due the length of the recipe, we will only show the outline of the code here while diving into the details in the <em>How it works...</em> section:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
// First we define the chart object using a functional object 
 
function lineChart() { // &lt;-1A 
    ... 
    // main render function  
    _chart.render = function () { // &lt;-2A 
    ... 
    }; 
 
    // axes rendering function 
    functionrenderAxes(svg) { 
        ... 
    } 
    ... 
 
 
    // function to render chart body 
    function renderBody(svg) { // &lt;-2D         
    ... 
    } 
 
    // function to render lines 
    function renderLines() { 
    ... 
    } 
 
    // function to render data points 
    function renderDots() { 
 
    } 
 
    return _chart; // &lt;-1E 
} 
</pre><p>This recipe generates the following chart:</p><p>
</p><div><img src="img/image_08_002.jpg" alt="How to do it..."/></div><p>
</p><p>Line chart</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec170"/>How it works...</h2></div></div></div><p>As you can see, this recipe is significantly more involved than anything we encountered so far; so now, I will break it into multiple detailed sections with different focuses.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec13"/>Chart object and attributes</h3></div></div></div><p>First, we will take a look at how this chart object is created and how its associated attributes can be retrieved and set on it in the following code:</p><pre class="programlisting">function lineChart() { // &lt;-1A 
        var _chart = {}; 
 
        var _width = 600, _height = 300, // &lt;-1B 
            _margins = {top: 30, left: 30, right: 30, bottom: 30}, 
            _x, _y, 
            _data = [], 
            _colors = d3.scaleOrdinal(d3.schemeCategory10), 
            _svg, 
            _bodyG, 
            _line; 
 
      ... 
 
      _chart.width = function (w) { 
            if (!arguments.length) return _width; 
            _width = w; 
            return _chart; 
        }; 
 
        _chart.height = function (h) { // &lt;-1C 
            if (!arguments.length) return _height; 
            _height = h; 
            return _chart; 
        }; 
 
        _chart.margins = function (m) { 
            if (!arguments.length) return _margins; 
            _margins = m; 
            return _chart; 
        }; 
 
        ... 
 
       _chart.addSeries = function (series) { // &lt;-1D 
            _data.push(series); 
            return _chart; 
        }; 
 
        return _chart; // &lt;-1E 
} 
 
... 
 
var chart = lineChart() 
            .x(d3.scaleLinear().domain([0, 10])) 
            .y(d3.scaleLinear().domain([0, 10])); 
 
data.forEach(function (series) { 
    chart.addSeries(series); 
}); 
 
chart.render(); 
</pre><p>As you can see, the chart object is defined using a function called <code class="literal">lineChart</code> on line 1A, following the functional object pattern we have discussed in the <em>Understanding D3-Style JavaScript</em> recipe in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with D3.js">Chapter 1</a>, <em>Getting Started with D3.js</em>. Leveraging the greater flexibility with information hiding offered by the functional object pattern, we have defined a series of internal attributes all named starting with an underscore (line <code class="literal">1B</code>). Some of these attributes are made public by offering an accessor function (line <code class="literal">1C</code>). Publicly accessible attributes are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">width</code>: Chart SVG total width in pixels</li><li class="listitem" style="list-style-type: disc"><code class="literal">height</code>: Chart SVG total height in pixels</li><li class="listitem" style="list-style-type: disc"><code class="literal">margins</code>: Chart margins</li><li class="listitem" style="list-style-type: disc"><code class="literal">colors</code>: Chart ordinal color scale used to differentiate different data series</li><li class="listitem" style="list-style-type: disc"><code class="literal">x</code>: <em>x</em> axis scale</li><li class="listitem" style="list-style-type: disc"><code class="literal">y</code>: <em>y</em> axis scale</li></ul></div><p>The accessor functions are implemented using the technique we introduced in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with D3.js">Chapter 1</a>, <em>Getting Started with D3.js</em>, effectively combining both getter and setter functions in one function, which behave as a getter when no argument is given and a setter when an argument is present (line <code class="literal">1C</code>). Additionally, both <code class="literal">lineChart</code> function and its accessors return a chart instance, thus allowing function chaining. Finally, the chart object also offers an <code class="literal">addSeries</code> function, which simply pushes a data array (<code class="literal">series</code>) into its internal data storage array (<code class="literal">_data</code>), refer to line <code class="literal">1D</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec14"/>Chart body frame rendering</h3></div></div></div><p>After covering the basic chart object and its attributes, the next aspect of this reusable chart implementation is the chart body <code class="literal">svg:g</code> element rendering and its clip path generation:</p><pre class="programlisting">_chart.render = function () { // &lt;-2A 
  if (!_svg) { 
    _svg = d3.select("body").append("svg") // &lt;-2B 
      .attr("height", _height) 
      .attr("width", _width); 
 
    renderAxes(_svg); 
 
    defineBodyClip(_svg); 
  } 
 
  renderBody(_svg); 
}; 
... 
function defineBodyClip(svg) { // &lt;-2C 
  var padding = 5; 
 
  svg.append("defs") 
    .append("clipPath") 
    .attr("id", "body-clip") 
    .append("rect") 
    .attr("x", 0 - padding) 
    .attr("y", 0) 
    .attr("width", quadrantWidth() + 2 * padding) 
    .attr("height", quadrantHeight()); 
  } 
 
function renderBody(svg) { // &lt;-2D 
  if (!_bodyG) 
    _bodyG = svg.append("g") 
      .attr("class", "body") 
      .attr("transform", "translate("  
        + xStart() + ","  
        + yEnd() + ")") // &lt;-2E 
      .attr("clip-path", "url(#body-clip)");         
 
  renderLines(); 
 
  renderDots(); 
} 
... 
</pre><p>The <code class="literal">render</code> function defined on line 2A is responsible for creating the <code class="literal">svg:svg</code> element and setting its <code class="literal">width</code> and <code class="literal">height</code> (line 2B). After that, it creates an <code class="literal">svg:clipPath</code> element that covers the entire chart body area. The <code class="literal">svg:clipPath</code> element is used to restrict the region where paint can be applied. In our case, we used it to restrict the line and dots that can be painted (only within the chart body area). This code generates the following SVG element structure that defines the chart body:</p><p>
</p><div><img src="img/image_08_003.jpg" alt="Chart body frame rendering"/></div><p>
</p><div><div><h3 class="title"><a id="tip73"/>Tip</h3><p>For more information on clipping and masking, please visit <a class="ulink" href="https://www.w3.org/TR/SVG/masking.html">https://www.w3.org/TR/SVG/masking.html
</a>.</p></div></div><p>The <code class="literal">renderBody</code> function defined on line 2D generates the <code class="literal">svg:g</code> element, which wraps all the chart body content with a translation set according to the chart margin convention we have discussed in the previous section (line <code class="literal">2E</code>).</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec15"/>Render axes</h3></div></div></div><p>Axes are rendered in the <code class="literal">renderAxes</code> function (line <code class="literal">3A</code>):</p><pre class="programlisting">function renderAxes(svg) { // &lt;-3A 
    varaxesG = svg.append("g") 
                   .attr("class", "axes"); 
 
    renderXAxis(axesG); 
 
    renderYAxis(axesG); 
} 
</pre><p>As discussed in the previous chapter, both the <em>x</em> and <em>y</em> axes are rendered inside the chart margin area. We will not go into details of axes rendering since we have discussed this topic in much detail in <a class="link" href="ch05.html" title="Chapter 5. Playing with Axes">Chapter 5</a>, <em>Playing with Axes</em>.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec16"/>Render data series</h3></div></div></div><p>Everything we discussed so far in this recipe is not unique to this chart type alone but rather it is a shared framework among other Cartesian coordinates-based chart types. Finally, now we can discuss the core of this recipe-how the line segments and dots are created for multiple data series. Let's take a look at the following code fragments that are responsible for data series rendering:</p><pre class="programlisting">function renderLines() { 
        _line = d3.line() //&lt;-4A 
                        .x(function (d) { return _x(d.x); }) 
                        .y(function (d) { return _y(d.y); }); 
 
         var pathLines = _bodyG.selectAll("path.line") 
                    .data(_data); 
 
        pathLines 
                .enter() //&lt;-4B 
                    .append("path") 
                .merge(pathLines) 
                    .style("stroke", function (d, i) { 
                        return _colors(i); //&lt;-4C 
                    }) 
                    .attr("class", "line") 
                .transition() //&lt;-4D 
                    .attr("d", function (d) {  
                                return _line(d);  
                    }); 
} 
 
function renderDots() { 
    _data.forEach(function (list, i) { 
        var circle = _bodyG.selectAll("circle._" + i) //&lt;-4E 
                .data(list); 
 
        circle.enter() 
                .append("circle") 
            .merge(circle) 
                .attr("class", "dot _" + i) 
                .style("stroke", function (d) { 
                    return _colors(i); //&lt;-4F 
                }) 
            .transition() //&lt;-4G 
                .attr("cx", function (d) { return _x(d.x); }) 
                .attr("cy", function (d) { return _y(d.y); }) 
                .attr("r", 4.5); 
    }); 
} 
</pre><p>The line segments and dots are generated using techniques we introduced in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>. The <code class="literal">d3.line</code> generator was created on line 4A to create <code class="literal">svg:path</code> that maps the data series. The Enter-and-Update pattern is used to create the data line (line 4B). Line 4C sets a different color for each data line based on its index. Lastly, line 4E sets the transition in the update mode to move the data line smoothly on each update. The <code class="literal">renderDots</code> function performs a similar rendering logic that generates a set of <code class="literal">svg:circle</code> elements representing each data point (line 4E), coordinating its color based on the data series index (line 4F), and finally also initiates a transition on line 4G, so the dots can move with the line whenever the data is updated.</p><p>As illustrated by this recipe, creating a reusable chart component involves actually quite a bit of work. However, more than two-thirds of the code is required to create peripheral graphical elements and accessors methods. Therefore, in a real-world project, you can extract this logic and reuse a large part of this implementation for other charts; though we did not do this in our recipes in order to reduce the complexity, you can quickly grasp all aspects of chart rendering. Due to limited scope in this book, in later recipes, we will omit all peripheral rendering logic and only focus on the core logic related to each chart type.Feel free to jump back to this recipe if you ever need to double-check the peripheral rendering logic while reading the later recipes in this chapter.</p></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Creating an area chart</h1></div></div></div><p>An area chart or an area graph is very similar to a line chart and largely implemented based on the line chart. The main difference between an area chart and a line chart is that in the area chart, the area between the axis and the line will be filled with colors or textures. In this recipe, we will explore techniques of implementing a type of area chart known as <strong>Layered Area Chart</strong>.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec171"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/area-chart.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/area-chart.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec172"/>How to do it...</h2></div></div></div><p>An area chart implementation is largely based on the line chart implementation and shares a lot of common graphical elements, such as the axes and the clip path; therefore, in this recipe, we will only show the code that concerns the area chart implementation specifics:</p><pre class="programlisting">... 
 
function renderBody(svg) { 
        if (!_bodyG) 
            _bodyG = svg.append("g") 
                    .attr("class", "body") 
                    .attr("transform", "translate("  
                        + xStart() + ","  
                        + yEnd() + ")")  
                    .attr("clip-path", "url(#body-clip)");         
 
        renderLines(); 
 
        renderAreas(); 
 
        renderDots(); 
    } 
 
    function renderLines() { 
        _line = d3.line() 
                        .x(function (d) { return _x(d.x); }) 
                        .y(function (d) { return _y(d.y); }); 
 
        var pathLines = _bodyG.selectAll("path.line") 
                .data(_data); 
 
        pathLines.enter() 
                    .append("path") 
                .merge(pathLines) 
                    .style("stroke", function (d, i) { 
                        return _colors(i); 
                    }) 
                    .attr("class", "line") 
                .transition() 
                    .attr("d", function (d) { return _line(d); }); 
    } 
 
    function renderDots() { 
        _data.forEach(function (list, i) { 
            var circle = _bodyG.selectAll("circle._" + i) 
                    .data(list); 
 
            circle.enter() 
                    .append("circle") 
                .merge(circle) 
                    .attr("class", "dot _" + i) 
                    .style("stroke", function (d) { 
                        return _colors(i); 
                    }) 
                .transition() 
                    .attr("cx", function (d) { return _x(d.x); }) 
                    .attr("cy", function (d) { return _y(d.y); }) 
                    .attr("r", 4.5); 
        }); 
    } 
 
    function renderAreas() { 
        var area = d3.area() // &lt;-A 
                    .x(function(d) { return _x(d.x); }) 
                    .y0(yStart()) 
                    .y1(function(d) { return _y(d.y); }); 
 
        var pathAreas = _bodyG.selectAll("path.area") 
                .data(_data); 
 
        pathAreas.enter() // &lt;-B 
                .append("path") 
            .merge(pathAreas) 
                .style("fill", function (d, i) {  
                    return _colors(i);  
                }) 
                .attr("class", "area") 
            .transition() // &lt;-D 
                .attr("d", function (d) {  
                    return area(d); // &lt;-E 
                }); 
    } 
... 
</pre><p>This recipe generates the following layered area chart:</p><p>
</p><div><img src="img/image_08_004.jpg" alt="How to do it..."/></div><p>
</p><p>Layered area chart</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec173"/>How it works...</h2></div></div></div><p>As we mentioned before, since the area chart implementation is based on our line chart implementation, a large part of the implementation is identical to the line chart. In fact, the area chart needs to render the exact line and dots implemented in the line chart. The crucial difference lies in the <code class="literal">renderAreas</code> function. In this recipe, we rely on the area generation technique discussed in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>. The <code class="literal">d3.area</code> generator was created on line <code class="literal">A</code> with its upper line created to match the line while its lower line (<code class="literal">y0</code>) fixed on x axis.</p><pre class="programlisting">var area = d3.area() // &lt;-A 
  .x(function(d) { return _x(d.x); }) 
  .y0(yStart()) 
  .y1(function(d) { return _y(d.y); }); 
</pre><p>Once the area generator is defined, a classic Enter-and-Update pattern is employed to create and update the areas. In the Enter case (line <code class="literal">B</code>), an <code class="literal">svg:path</code> element was created for each data series. On line <code class="literal">B2</code>, we merged the <code class="literal">pathAreas.enter()</code> and <code class="literal">pathAreas</code>; therefore, all following code will be applied to both the enter and update modes; all areas are colored using its series index so it will have matching color with our line and dots (line <code class="literal">C</code>):</p><pre class="programlisting">Var pathAreas = _bodyG.selectAll("path.area") 
                .data(_data); 
 
pathAreas.enter() // &lt;-B 
.append("path") 
.merge(pathAreas) // &lt;-B2 
.style("fill", function (d, i) {  
    return _colors(i); // &lt;-C 
  }) 
  .attr("class", "area") 
.transition() // &lt;-D 
  .attr("d", function (d) {  
       return area(d); // &lt;-E 
  }); 
</pre><p>Whenever the data is updated, as well as for newly created areas, we start a transition (line D) to update the area <code class="literal">svg:path</code> elements' <code class="literal">d</code> attribute to the desired shape (line E).Since we know that the line chart implementation animates both line and dots when updated, our area update transition here effectively allows the areas to be animated and moved in accordance with both lines and dots in our chart.</p><p>Finally, we also add the CSS style for <code class="literal">path.area</code> to decrease its opacity so areas become see-through and<code class="literal"> hence allow the layered effect</code> we want:</p><pre class="programlisting">.area { 
  stroke: none; 
  fill-opacity: .2; 
} 
</pre></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Creating a scatterplot chart</h1></div></div></div><p>A scatterplot or scattergraph is another common type of diagram used to display data points on Cartesian coordinates with two different variables. Scatterplot is especially useful when you're exploring the problem of spreading, clustering, and classification. In this recipe, you will learn how to implement a multi-series scatterplot chart in D3.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec174"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/scatterplot-chart.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/scatterplot-chart.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec175"/>How to do it...</h2></div></div></div><p>A scatterplot is another chart that uses Cartesian coordinates. Thus, a large part of its implementation is very similar to the charts we introduced so far; and therefore, the code concerning peripheral graphical elements are again omitted to save space in this book. Please refer to the companion code for the complete implementation. Now let's take a look the implementation of this recipe:</p><pre class="programlisting">... 
 
_symbolTypes = d3.scaleOrdinal() // &lt;-A 
                  .range([d3.symbolCircle, 
                            d3.symbolCross, 
                            d3.symbolDiamond, 
                            d3.symbolSquare, 
                            d3.symbolStar, 
                            d3.symbolTriangle, 
                            d3.symbolWye 
                ]); 
 
... 
 
function renderBody(svg) { 
    if (!_bodyG) 
        _bodyG = svg.append("g") 
            .attr("class", "body") 
            .attr("transform", "translate(" 
                            + xStart() + "," 
                            + yEnd() + ")") 
            .attr("clip-path", "url(#body-clip)"); 
 
            renderSymbols(); 
} 
 
function renderSymbols() { // &lt;-B 
    _data.forEach(function (list, i) { 
        var symbols = _bodyG.selectAll("path._" + i) 
                        .data(list); 
 
        symbols.enter() 
                .append("path") 
            .merge(symbols) 
                .attr("class", "symbol _" + i) 
                .classed(_symbolTypes(i), true) 
            .transition() // &lt;-C 
                .attr("transform", function(d){ 
                           return "translate(" // &lt;-D 
                                    + _x(d.x) 
                                    + "," 
                                    + _y(d.y) 
                                    + ")"; 
                }) 
                .attr("d", 
                        d3.symbol() // &lt;-E 
                            .type(_symbolTypes(i)) 
                ); 
        }); 
} 
... 
</pre><p>This recipe generates the following scatterplot chart:</p><p>
</p><div><img src="img/image_08_005.jpg" alt="How to do it..."/></div><p>
</p><p>Scatter plot chart</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec176"/>How it works...</h2></div></div></div><p>The content of the scatterplot chart is mainly rendered by the <code class="literal">renderSymbols</code> function on line <code class="literal">B</code>. You probably may have already noticed that the <code class="literal">renderSymbols</code> function implementation is very similar to the <code class="literal">renderDots</code> function we discussed in the <em>Creating a line chart</em> recipe. This is not by accident since both try to plot data points on Cartesian coordinates with two variables (x and y). In the case of plotting dots, the <code class="literal">svg:circle</code> elements were being created, whereas, in scatterplot, you will need to create the <code class="literal">d3.symbol</code> elements. D3 provides a list of predefined symbols that can be generated easily and rendered using an <code class="literal">svg:path</code> element. As shown on line <code class="literal">A</code>, we defined an ordinal scale to allow mapping of data series index to different symbol types:</p><pre class="programlisting">_symbolTypes = d3.scaleOrdinal() // &lt;-A 
                        .range([d3.symbolCircle, 
                            d3.symbolCross, 
                            d3.symbolDiamond, 
                            d3.symbolSquare, 
                            d3.symbolStar, 
                            d3.symbolTriangle, 
                            d3.symbolWye 
                        ]); 
</pre><p>Plotting the data points with symbols is quite straightforward. First, we will loop through the data series array, and for each data series, we will create a set of <code class="literal">svg:path</code> elements representing each data point in the series as follows:</p><pre class="programlisting"> 
_data.forEach(function (list, i) { 
    var symbols = _bodyG.selectAll("path._" + i) 
                        .data(list); 
 
    symbols.enter() 
            .append("path") 
        .merge(symbols) 
            .attr("class", "symbol _" + i) 
            .classed(_symbolTypes(i), true) 
        .transition() // &lt;-C 
            .attr("transform", function(d){ 
                            return "translate(" // &lt;-D 
                                    + _x(d.x) 
                                    + "," 
                                    + _y(d.y) 
                                    + ")"; 
            }) 
            .attr("d",d3.symbol() // &lt;-E 
                                .type(_symbolTypes(i)) 
            ); 
}); 
</pre><p>By merging the <code class="literal">symbols.enter()</code> and <code class="literal">symbols</code> selections, we made sure that whenever data series are updated, as well as for newly created symbols, we apply the update with transition (line <code class="literal">C</code>), placing them on the right coordinates with an SVG translation transformation (line D). Finally, the <code class="literal">d</code> attribute of each <code class="literal">svg:path</code> element is generated using the <code class="literal">d3.svg.symbol</code> generator function as shown on line <code class="literal">E</code>.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Creating a bubble chart</h1></div></div></div><p>A bubble chart is a typical visualization capable of displaying three data dimensions. Every data entity with its three data points is visualized as a bubble (or disk) on Cartesian coordinates, with two different variables represented using <em>x</em> axis and <em>y</em> axis, similar to the <code class="literal">scatterplot</code> chart, while the third dimension is represented using the radius of the bubble (size of the disk). The bubble chart is particularly useful when it's used to facilitate <code class="literal">the understanding of relation</code>ships between data entities.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec177"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bubble-chart.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bubble-chart.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec178"/>How to do it...</h2></div></div></div><p>In this recipe, we will explore techniques and ways of implementing a typical bubble chart using D3. The following code example shows the important implementation aspects of a bubble chart, omitting the accessors and peripheral graphic implementation details:</p><pre class="programlisting">... 
 
var _width = 600, _height = 300, 
                _margins = {top: 30, left: 30, right: 30, bottom: 30}, 
                _x, _y, _r, // &lt;-A 
                _data = [], 
                _colors = d3.scaleOrdinal(d3.schemeCategory10), 
                _svg, 
                _bodyG; 
 
        _chart.render = function () { 
            if (!_svg) { 
                _svg = d3.select("body").append("svg") 
                        .attr("height", _height) 
                        .attr("width", _width); 
 
                renderAxes(_svg); 
 
                defineBodyClip(_svg); 
            } 
 
            renderBody(_svg); 
        }; 
... 
function renderBody(svg) { 
        if (!_bodyG) 
            _bodyG = svg.append("g") 
                    .attr("class", "body") 
                    .attr("transform", "translate(" 
                            + xStart() 
                            + "," 
                            + yEnd() + ")") 
                    .attr("clip-path", "url(#body-clip)"); 
 
           renderBubbles(); 
} 
 
function renderBubbles() { 
        _r.range([0, 50]); // &lt;-B 
 
        _data.forEach(function (list, i) { 
            var bubbles = _bodyG.selectAll("circle._" + i) 
                   .data(list); 
 
            bubbles.enter() 
                        .append("circle") // &lt;-C 
                    .merge(bubbles) 
                        .attr("class", "bubble _" + i) 
                        .style("stroke", function (d, j) { 
                            return _colors(j); 
                        }) 
                        .style("fill", function (d, j) { 
                            return _colors(j); 
                        }) 
                    .transition() 
                        .attr("cx", function (d) { 
                            return _x(d.x); // &lt;-D 
                        }) 
                        .attr("cy", function (d) { 
                            return _y(d.y); // &lt;-E 
                        }) 
                        .attr("r", function (d) { 
                            return _r(d.r); // &lt;-F 
                        }); 
        }); 
} 
... 
</pre><p>This recipe generates the following visualization:</p><p>
</p><div><img src="img/image_08_006.jpg" alt="How to do it..."/></div><p>
</p><p>Bubble chart</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec179"/>How it works...</h2></div></div></div><p>Overall, the bubble chart implementation follows the same pattern as other chart implementations introduced in this chapter so far. However, since we want to visualize three different dimensions (x, y, and radius) instead of two in the bubble chart, a new scale <code class="literal">_r</code> was added in this implementation (line <code class="literal">A</code>) as follows:</p><pre class="programlisting">var _width = 600, _height = 300, 
  _margins = {top: 30, left: 30, right: 30, bottom: 30}, 
  _x, _y, _r, // &lt;-A 
  _data = [], 
  _colors = d3.scale.category10(), 
  _svg, 
  _bodyG; 
</pre><p>Most of the bubble chart-related implementation details are handled by the <code class="literal">renderBubbles</code> function. It starts with setting the range on the radius scale (line <code class="literal">B</code>). Of course, we can also make the radius range configurable in our chart implementation; however, for simplicity, we chose to set it explicitly in the following code:</p><pre class="programlisting"> 
function renderBubbles() { 
        _r.range([0, 50]); // &lt;-B 
 
        _data.forEach(function (list, i) { 
            var bubbles = _bodyG.selectAll("circle._" + i) 
                   .data(list); 
 
            bubbles.enter() 
                        .append("circle") // &lt;-C 
                    .merge(bubbles) 
                        .attr("class", "bubble _" + i) 
                        .style("stroke", function (d, j) { 
                            return _colors(j); 
                        }) 
                        .style("fill", function (d, j) { 
                            return _colors(j); 
                        }) 
                    .transition() 
                        .attr("cx", function (d) { 
                            return _x(d.x); // &lt;-D 
                        }) 
                        .attr("cy", function (d) { 
                            return _y(d.y); // &lt;-E 
                        }) 
                        .attr("r", function (d) { 
                            return _r(d.r); // &lt;-F 
                        }); 
        }); 
} 
</pre><p>Once the range is set, we iterated through our data series, and for each series, we created a set of <code class="literal">svg:circle</code> elements (line <code class="literal">C</code>). Finally, we handled the newly created bubble and its update in the last section, where the <code class="literal">svg:circle</code> elements are colored and placed <code class="literal">to</code> the correct coordinates using its <code class="literal">cx</code> and <code class="literal">cy</code> attributes (lines <code class="literal">D</code> and <code class="literal">E</code>). In the end, the bubble size is controlled using its radius attribute <code class="literal">r </code>mapped using the <code class="literal">_r</code> scale we defined earlier (line F).</p><div><div><h3 class="title"><a id="tip74"/>Tip</h3><p>In some of the bubble chart implementations, the implementer also leverages the color of each bubble to visualize a fourth data dimension, although some believe this kind of visual representation is hard to grasp and superfluous.</p></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Creating a bar chart</h1></div></div></div><p>A bar chart is a visualization that uses either horizontal (row charts) or vertical (column charts) rectangular bars with length proportional to the values that they represent. In this recipe, we will implement a column chart using D3. A column chart is capable of visually representing two variables at the same time with its <em>y </em>axis; in other words, the bar height and its <em>x</em> axis. The <em>x</em> axis values can be either discrete or continuous (for example, a histogram). In our example, we choose to visualize continuous values on the x axis. However, the same technique can be applied when you work with discrete values.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec180"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bar-chart.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter8/bar-chart.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec181"/>How to do it...</h2></div></div></div><p>The following code example shows the important implementation aspects of a histogram, omitting the accessors and peripheral graphic implementation details:</p><pre class="programlisting">... 
 
var _chart = {}; 
 
    var _width = 600, _height = 250, 
            _margins = {top: 30, left: 30, right: 30, bottom: 30}, 
            _x, _y, 
            _data = [], 
            _colors = d3.scaleOrdinal(d3.schemeCategory10), 
            _svg, 
            _bodyG; 
 
    _chart.render = function () { 
        if (!_svg) { 
            _svg = d3.select("body").append("svg") 
                    .attr("height", _height) 
                    .attr("width", _width); 
 
            renderAxes(_svg); 
 
            defineBodyClip(_svg); 
        } 
 
        renderBody(_svg); 
    }; 
... 
function renderBody(svg) { 
        if (!_bodyG) 
            _bodyG = svg.append("g") 
                    .attr("class", "body") 
                    .attr("transform", "translate("  
                            + xStart()  
                            + ","  
                            + yEnd() + ")") 
                    .attr("clip-path", "url(#body-clip)"); 
 
        renderBars(); 
    } 
     
    function renderBars() { 
        var padding = 2; // &lt;-A 
 
        var bars = _bodyG.selectAll("rect.bar") 
                .data(_data); 
        bars.enter() 
                .append("rect") // &lt;-B 
            .merge(bars) 
                .attr("class", "bar") 
            .transition() 
                .attr("x", function (d) {  
                    return _x(d.x); // &lt;-C 
                }) 
                .attr("y", function (d) {  
                    return _y(d.y); // &lt;-D  
                }) 
                .attr("height", function (d) {  
                    return yStart() - _y(d.y);  
                }) 
                .attr("width", function(d){ 
                    return Math.floor(quadrantWidth() /                              
                              _data.length) - padding; 
                }); 
    } 
... 
</pre><p>This recipe generates the following visualization:</p><p>
</p><div><img src="img/image_08_007.jpg" alt="How to do it..."/></div><p>
</p><p>Bar chart (histogram)</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec182"/>How it works...</h2></div></div></div><p>One major difference here is that the bar chart implementation does not support multiple data series. Therefore, instead of using a 2D array storing multiple data series as we did with other charts so far, in this implementation, the <code class="literal">_data</code> array simply stores a single set of data points directly. Main bar chart-related visualization logic resides in the <code class="literal">renderBars</code> function:</p><pre class="programlisting">functionrenderBars() { 
  var padding = 2; // &lt;-A 
  ... 
} 
</pre><p>In the first step, we defined the padding between bars (line <code class="literal">A</code>) so that later on we can automatically calculate the width of each bar. After that, we generated an <code class="literal">svg:rect</code> element (the bars) for each data point (line <code class="literal">B</code>) as follows:</p><pre class="programlisting">var bars = _bodyG.selectAll("rect.bar") 
                .data(_data); 
 
        bars.enter() 
                .append("rect") // &lt;-B 
            .merge(bars) 
                .attr("class", "bar") 
            .transition() 
                .attr("x", function (d) {  
                    return _x(d.x); // &lt;-C 
                }) 
                .attr("y", function (d) {  
                    return _y(d.y); // &lt;-D  
                }) 
                .attr("height", function (d) {  
                    return yStart() - _y(d.y);  
                }) 
                .attr("width", function(d){ 
                    return Math.floor(quadrantWidth() / 
                           _data.length) - padding; 
                }); 
</pre><p>Then, in the update section, we placed each bar at the correct coordinates using its <em>x</em> and <em>y</em> attributes (lines <code class="literal">C</code> and <code class="literal">D</code>) and extended each bar all the way down to touch the <em>x</em> axis with an adaptive <code class="literal">height</code> calculated on line E. Finally, we calculated the optimal width for each bar using the number of bars and the padding value we defined earlier:</p><pre class="programlisting">.attr("width", function(d){ 
    returnMath.floor(quadrantWidth() / _data.length) - padding; 
}); 
</pre><p>Of course, in a more flexible implementation, we can make the padding configurable instead of being fixed to 2 pixels.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec183"/>See also</h2></div></div></div><p>Before planning to implement your own reusable chart for your next visualization project, make sure that you also check out the following open source reusable chart projects based on D3:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">NVD3: <a class="ulink" href="http://nvd3.org/">http://nvd3.org/</a>.</li><li class="listitem" style="list-style-type: disc">Dimensional Charting: <a class="ulink" href="https://dc-js.github.io/dc.js/">https://dc-js.github.io/dc.js/
</a>.</li><li class="listitem" style="list-style-type: disc">Rickshaw: <a class="ulink" href="http://code.shutterstock.com/rickshaw/">http://code.shutterstock.com/rickshaw/</a>.</li></ul></div></div></div></div></div></body></html>