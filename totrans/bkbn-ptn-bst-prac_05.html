<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Routing Best Practices and Subrouting"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Routing Best Practices and Subrouting</h1></div></div></div><p>A router<a id="id195" class="indexterm"/> is one of the most useful objects in Backbone; it is mainly used to route application URLs using hash fragments or standard URLs. In the earlier versions of Backbone, <code class="literal">Backbone.Controller</code> was used to take care of routing as well as default controller tasks, instead of <code class="literal">Backbone.Router</code>. Later, it was changed to <code class="literal">Backbone.Router</code>, because the router is meant to only handle routing client side pages and connect them to events and actions via URLs, while the functional logic must be taken care of by the presenters (that is, Backbone views). The concept of a router is pretty straightforward—it matches the method name to the URL fragment and calls the method. The method then takes care of the events and actions as required.</p><p>In this chapter, we will learn about some best practices, such as how to organize routers for medium- and large-scale applications, and which types of tasks should be handled by a router. The main topics to be covered are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Working with routers</strong></span>: This provides a basic example of how routers work, along with an analysis of what can go wrong while working with routers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Best practices for working with routers</strong></span>: We will look into some good practices that one should follow while working with routers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Subrouting – a key to organize complex apps</strong></span>: Once your application grows, maintaining a single router becomes a mammoth task. Dividing the app router into multiple subrouters is a preferable way to manage it.</li></ul></div><div class="section" title="Working with routers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Working with routers</h1></div></div></div><p>The<a id="id196" class="indexterm"/> Backbone router provides methods to route client-side pages by using hash fragments or standard URLs as per the History API. Routes that use the hash fragments or History API may look like this:</p><div class="informalexample"><pre class="programlisting">// Hash fragment
http://www.foo.com/#user/23

// Standard URL
http://www.foo.com/user/23</pre></div><p>The routes and actions that will be triggered when the URL fragment matches the specific routes are defined in the <code class="literal">routes</code> object of the router:</p><div class="informalexample"><pre class="programlisting">routes: {
  'users' : 'showUsers',
  'user/:id' : 'showUserDetails',
  'user/:id/update' : 'updateUser'
}</pre></div><p>Now, let's <a id="id197" class="indexterm"/>see how we can create a basic router. Assume that we are developing an application with a few modules, among which the <code class="literal">User</code> module is an important one.</p><div class="informalexample"><pre class="programlisting">var AppRouter = Backbone.Router.extend({
  routes: {
    'users': 'showUsers',
    'user/:id': 'showUserDetails',
    'user/:id/update': 'updateUser',
    'user/:id/remove': 'removeUser'
  },

  showUsers: function () {
    // Get all the user details from server and 
    // show the users view 
  },

  showUserDetails: function (userId) {
    // Get the user details for the user id as received
  },

  updateUser: function (userId) {},
  removeUser: function (userId) {}
});</pre></div><p>Quite simple! There are a number of options that modify the routes to get the expected result. For example, you can use "splats" or optional parts in a route; for a detailed overview of routes, refer to the Backbone.js API<a id="id198" class="indexterm"/> at <a class="ulink" href="http://backbonejs.org/#Router">http://backbonejs.org/#Router</a>.</p><p>In the preceding example, all the show methods (<code class="literal">showUsers()</code> and <code class="literal">showUserDetails()</code>) will most likely create the view instances, send AJAX requests to the server to get their details, and then show the views in the DOM. Similarly, the update and delete methods will also send requests to the server for the desired actions to be taken. Now, assume the <code class="literal">User</code> module has multiple other methods in this router along with these CRUD methods. In addition, the entire application has a number of similar modules whose routes will also get added to this router. As a result, the router will soon become a gigantic one with hundreds of lines of code; this is something that is beyond our control.</p><p>We should take care of a few things while working with routers and avoid such situations. We will look at some good practices in the following section that will make our routers simple, flexible, and easy-to-maintain.</p></div></div>
<div class="section" title="Best practices for working with routers"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec32"/>Best practices for working with routers</h1></div></div></div><p>Working <a id="id199" class="indexterm"/>with a Backbone router is fairly easy when the application is of a small size. However, as the complexity increases, maintaining a router becomes difficult unless some rules are followed. In the following section, we will discuss some points that you should take care of while using routers.</p><div class="section" title="Avoiding large functional code in route methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Avoiding large functional code in route methods</h2></div></div></div><p>Though the <a id="id200" class="indexterm"/>basic task of a router is to monitor the routes and trigger functions, it manages some business logics of the app too. In an MVC architecture, the task of a controller is to handle the data request that is sent from the client and work upon the data that comes from the server in response. Similarly for a router, since the URL fragments reflect some part of the application's data, the data communication, calling view methods, or updating model attributes are done using router methods.</p><p>A trend I often see in beginner-level developer code is that they frequently include a large chunk of functional code inside the router methods. On one hand, this increases the size of the router, and on the other hand, it complicates the logic. It is always advisable to keep your router methods as short as possible by pushing the functional logic in views and using events instead of callbacks. In the following section we will see how we can keep our router clean. Also, we will look at event delegation, custom events, and callback methods in more detail in <a class="link" href="ch06.html" title="Chapter 6. Working with Events, Sync, and Storage">Chapter 6</a>, <span class="emphasis"><em>Working with Events, Storage, and Sync</em></span>.</p></div><div class="section" title="Instantiating views in router methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Instantiating views in router methods</h2></div></div></div><p>I have seen <a id="id201" class="indexterm"/>many developers who instantiate their application views inside router methods. While there is no such restriction in instantiating views or modifying DOM elements in router methods, it is a good practice to avoid such operations in routers. This is somewhat related to the first point that I mentioned in this section. In the following code, we have instantiated a <code class="literal">UserView</code> class and rendered it in the DOM inside the router method:</p><div class="informalexample"><pre class="programlisting">Backbone.Router.extend({
  routes: {
    "users": "showUsers"
  },

  showUsers: function () {
    var usersView = new UsersView();
    usersView.render();
    $("#user_list").html(usersView.el);
  }
});</pre></div><p>This looks simple and works perfectly. But will it not clutter the router if there are 20 or more such methods? Why not create a controller or a high-level application object and add the method there? Then you can call this controller method from the router method as follows:</p><div class="informalexample"><pre class="programlisting">Backbone.Router.extend({
  routes: {
    "users": "showUsers"
  },

  showUsers: function() {
    UserController.showUsers();
  }
});

var UserController = {
  showUsers: function() {
    var usersView = new UsersView();
    usersView.render();
    $("#user_list").html(usersView.el);
  }
}</pre></div><p>Now any<a id="id202" class="indexterm"/> change in the <code class="literal">showUsers()</code> method functionality will not force you to touch the router. There's really not much of a visible difference—but personally, as I have used the second pattern several times and benefited from it, I can guarantee you that the separation of concern will produce a much cleaner router along with a maintainable code base.</p><p>Also, in this context, we recommend you check out <code class="literal">Marionette.AppRouter</code> (<a class="ulink" href="https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md">https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.approuter.md</a>) and <code class="literal">Marionette.Controller</code> (<a class="ulink" href="https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md">https://github.com/marionettejs/backbone.marionette/blob/master/docs/marionette.controller.md</a>). Marionette <code class="literal">AppRouter</code> and <code class="literal">Controller</code> work in the same way as our <code class="literal">UserController</code> and the base router. The controller actually does the work (such as assembling the data, instantiating the view, displaying them in regions) and can update the URL to reflect the application's state (for example, displayed content). The router simply triggers the controller action based on the URL that has been entered in the address bar. Both these classes are quite useful, and you can go for either of them if needed.</p></div><div class="section" title="Using regular expressions for selective routing"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Using regular expressions for selective routing</h2></div></div></div><p>If you <a id="id203" class="indexterm"/>want to trigger a router method only when a specific condition is matched, a <span class="strong"><strong>regular expression</strong></span> comes to the rescue. Regular expressions are flexible with routes and Backbone supports them completely. In fact, all of the routes are first converted into <code class="literal">RegExp</code> objects when they are added to the routing table.</p><p>However, JavaScript will not allow you to add a regular expression as a property of the <code class="literal">routes</code> object, unlike the other string URL fragments:</p><div class="informalexample"><pre class="programlisting">// This will give error
routes : {
  /^user\/(\d+)/ : 'showUserDetails' 
}</pre></div><p>The solution is that you can add the regular expression in the <code class="literal">routes</code> object in the <code class="literal">initialize()</code> method of the router:</p><div class="informalexample"><pre class="programlisting">initialize: function () {
  this.route(/^user\/(\d+)/, 'showUserDetails');
},

showUserDetails: function (id) {
  console.log(id);
}</pre></div><p>This is an<a id="id204" class="indexterm"/> example where only numbers are allowed in the URL fragment after <code class="literal">#user</code>. If you try to open a URL ending with <code class="literal">#user/abc</code>, the <code class="literal">showUserDetails()</code> method will not be called, but with the URL fragment <code class="literal">#user/123</code>, the same method will be triggered. So, this is a very generic example of using a regular expression as a route. Regular expressions are very useful for more complex levels of URL fragments in order to provide a level of restriction.</p></div></div>
<div class="section" title="Subrouting &#x2013; a key to organizing complex apps"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec33"/>Subrouting – a key to organizing complex apps</h1></div></div></div><p>Subrouting <a id="id205" class="indexterm"/>is the idea of dividing an application's router into a number of module-specific routers. In a small- or medium-level application, you may never need something like this. However, for an application with multiple modules, a single router that handles all of the routes soon turns into a huge, unmanageable class. So, it is always preferable to split the main router into a set of module-specific routers.</p><p>
<code class="literal">Backbone.Subroute</code> (<a class="ulink" href="https://github.com/ModelN/backbone.subroute">https://github.com/ModelN/backbone.subroute</a>), a wonderful extension developed by Dave Cadwallader, provides the functionality that we are talking about. It lets the base router delegate all of the module-specific routes to the subrouter associated with that module. Let's understand the difference between a router and subrouter<a id="id206" class="indexterm"/> with the two examples that follow.</p><div class="section" title="The all-in-one router"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl4sec05"/>The all-in-one router</h2></div></div></div><p>The <a id="id207" class="indexterm"/>following<a id="id208" class="indexterm"/> is the code for a single router that handles the routes of all the modules of an application:</p><div class="informalexample"><pre class="programlisting">var App = {};

var App.BaseRouter = Backbone.Router.extend({
  routes: {
    // Generic routes
    '': 'showHome',
    'logout': 'doLogout',

    // User specific routes
    'users/view/:id': 'showUserDetails',
    'users/search': 'searchUsers',

    // Company specific routes
    'company/:id': 'showCompanyDetails',
    'company/users': 'showCompanyDetails'
  },

  showHome: function () {},
  doLogout: function () {},

  showUserDetails: function () {},
  searchUsers: function () {},

  showCompanyDetails: function () {},
  showCompanyDetails: function () {},
});</pre></div><p>Now, let's use <code class="literal">Backbone.Subroute</code> and see how to define the base router and module-specific routers. With <code class="literal">Subroute</code>, the base router becomes a tiny router that only takes care of the router redirections.</p></div><div class="section" title="The base router"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl4sec06"/>The base router</h2></div></div></div><p>The<a id="id209" class="indexterm"/> following<a id="id210" class="indexterm"/> is the code for the base router:</p><div class="informalexample"><pre class="programlisting">var App.BaseRouter = Backbone.Router.extend({
  routes: {
    // Generic routes
    '': 'showHome',
    'logout': 'doLogout',

    // Route all users related routes to users subroute
    'users/*subroute': 'redirectToUsersModule',

    // Route all company related routes to company subroute
    'company/*subroute': 'redirectToCompanyModule'
  },

  showHome: function () {},
  doLogout: function () {},

  redirectToUsersModule: function () {
    if (!App.usersRouter) {
      App.usersRouter = new App.UsersRouter('/users');
    }
  },

  redirectToCompanyModule: function () {
    if (!App.companyRouter) {
      App.companyRouter = new App.CompanyRouter('/company');
    }
  },
});</pre></div></div><div class="section" title="The Users module router"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl4sec07"/>The Users module router</h2></div></div></div><p>The <a id="id211" class="indexterm"/>following<a id="id212" class="indexterm"/> is the code for the <code class="literal">Users</code> module router:</p><div class="informalexample"><pre class="programlisting">var App.UsersRouter = Backbone.SubRoute.extend({
  routes: {
    '': 'showUsers',
    'view/:id': 'showUserDetails',
    'search': 'searchUsers'
  },

  showUsers: function () {},
  showUserDetails: function () {},
  searchUsers: function () {}
});</pre></div><p>Look at the base router. What we are doing here is pretty simple—we use a wildcard (or splat) to trigger a method that lazily instantiates a subrouter and passes the initial parameter of the hash. Now, because <code class="literal">Backbone.Subroute</code> extends Backbone's <code class="literal">Router</code> class, we can<a id="id213" class="indexterm"/> expect that anything passed after /<code class="literal">users/</code> or <code class="literal">/company/</code> should be taken care of by the respective subrouter, that is, <code class="literal">App.UsersRouter</code> or <code class="literal">App.CompanyRouter</code>.</p><p>We can add as <a id="id214" class="indexterm"/>many subrouters as we want and the base router won't care about it. Similarly, the subrouters do not know what prefix they have. Any changes in the module name or prefix should be done only in the base router without modifying the related subrouter.</p><p>
<code class="literal">Backbone.Subroute</code> is a small yet excellent plugin that you should always include in your application to keep your base router clean. The more modules get added to your application, the more you will understand the benefit of subrouters.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Summary</h1></div></div></div><p>The functionality of the Backbone router is quite simple and easy to learn. For a simple application, you will not find any problems in maintaining it. The issues will start creeping in once your application grows and your router becomes huge. In this chapter, we discussed the best practices of router management, those that you should always adhere to. We also learned about subrouting, which helps by splitting up the main router into multiple module-specific routers and dividing the tasks among them.</p><p>In the next chapter, we will discuss Backbone events, custom events, storages, and sync.</p></div></body></html>