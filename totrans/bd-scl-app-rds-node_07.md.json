["```js `}`    This class will be our single point from where all types of notifications can be sent. From anywhere in the code, we can simply make a call to this class. Let us add the functionality for sending an email. We already implemented a function in the `**email_util.ts**` class. That function can act as a reference.    For sending an email, we will use a node package, `nodemailer`.    `import * as nodemailer from 'nodemailer';`    Let us add the constructor to the util `**NotificationUtil**` as:    `// Path: src/utils/notification_util.ts`    `import * as nodemailer from 'nodemailer';`    `export class NotificationUtil {`    `// nodemailer transporter instance`    `private static transporter;`    `constructor(config) {`    `if (!config) {`    `throw new Error('Config not provided');`    `}`    `if (!NotificationUtil.transporter) {`    `NotificationUtil.transporter = nodemailer.createTransport({`    `service: 'gmail',`    `auth: {`    `user: config.email_config.user,`    `pass: config.email_config.password`    `}`    `});`    `}`    `}`    `}`    In the preceding code, we have a constructor which takes a config object as the only argument. We will use this config to retrieve the necessary config for sending an email such as SMTP server username, password, and so on.    We have created a transporter object as a private static member of the class. In the context of Node.js and `**nodemailer**`, a transporter is an object which encapsulates the email sending functionality. Simply put, it is a way to send email using Node.js in which we do not have to worry about the low level details of the process. A transporter object is usually created once and reused. Hence, we have the object created at class level. In the constructor, we first check if this is already initialized or not. If the object is not initialized, we do it.    In our case, we are using gmail as a server but other providers and generic SMTP servers can also be used. To know more about the `**nodemailer**`, visit the website [https://nodemailer.com/](https://nodemailer.com/).    Further, we can add our function to send emails. For sending an email, we need the sender email address, recipient email address, subject, email body. Since the sender’s email address is unlikely to be changed for every email, let us add that as a private static variable of the class and we can set that inside the constructor.    `private static from: string;`    In the constructor, we can add the following line after creating the transporter :    `NotificationUtil.from = config.email_config.from;`    Let us define our function to receive these values as arguments.    `public async sendEmail(to: string, subject: string, body: string) {`    `try {`    `const mailOptions = {`    `from: NotificationUtil.from,`    `to: to,`    `subject: subject,`    `html: body`    `};`    `const status = await`    `NotificationUtil.transporter.sendMail(mailOptions);`    `if (status?.messageId) {`    `return status.messageId;`    `} else {`    `return false;`    `}`    `} catch (error) {`    ``console.log(`Error while sendEmail => ${error.message}`);``    `return false;`    `}`    `}`    For the `**sendEmail**` function, we receive just what we need — `**to**` (recipient email address), `**subject**`, and `**body**` of the email. We create an object `**mailOptions**` using these four values and finally send email using `**transporter.sendEmail()**`. If this function successfully sends an email, we will receive a message Id which we can return, otherwise, we will return a `**false**` boolean value indicating that something did not go right.    This completes our email sending feature with the help of `**NotificationUtil**`. We can now use this function instead of the `**sendMail**` function from `**email_util.ts**`.    We are using the `**sendMail**` function from `**email_util**` for the `**forgotPassword**` function in `**UserController**`. Let us change that to use `**NotificationUtil**` by importing the `**util**` in `**UserController**`.    `import { NotificationUtil } from '../../utils/notification_util';`    Now, we can modify the `**forgotPassword**` function to use notification `**util**`. We need to replace the following line:    `const emailStatus = await sendMail(mailOptions.to, mailOptions.subject, mailOptions.html);`    The line replacing would be as follows:    `const emailStatus = await NotificationUtil.sendEmail(mailOptions.to, mailOptions.subject, mailOptions.html);`    Instead of `**sendMail**`, we are using `**NotificationUtil.sendEmail**` function. Rest everything remains the same.    We can also remove the unused `**import**`    `import { sendMail } from '../../utils/email_util';`    We also need to initialize the `**NotificationUtil**` from our `**main.ts**` file.    `new NotificationUtil(config);`    The config can be imported as:    `import * as config from '../server_config.json';`    # [Implementing Queue](toc.xhtml#s220a)    In a large organization there would be a good number of people using project management software. From each user, there would be tons of activities and some of those activities would require an email notification to be sent to other users. If there are a lot of emails to be sent, it is better to handle the communication using a queue. A queue is a mechanism where each call to send email would be added and the queue will be processed separately along with a failure mechanism.    Using a queue in this manner is a good approach for the following reasons:    *   **Improved performance and efficiency**: Sending an email directly can be resource-intensive and may slow down the primary operation. A queue would allow decoupled handling of the email sending process and the response times would be faster. *   **Scalability:** As the number of users grows, activities and number of emails to be sent would grow significantly. A queue can handle the increased load. There can be different strategies to handle a queue, for example, separate notification server, separate worker, and so on. *   **Reliability:** If an email fails to send, we can easily retry after sometime, if this is carried out through a queue. The failure can be due to many reasons such as server issues and network problems. The queue can be designed to handle failures and be equipped with a mechanism to retry. *   **Asynchronous processing:** Queues can be made asynchronous so that the application does not have to wait while email is being sent and we receive a response from the email server.    These are some of the few key reasons why it is a good idea to use queues for sending emails.    There can be incidents when we need immediate response to an email sending call and without that we cannot ensure reliability. One such example is the `**forgotPassword**` function which we implemented. In this case, as soon as the user provides their email, we verify things at the backend and send an email. The user would expect an email immediately in his/her mailbox.    In such cases, we can also use hybrid methods for email notifications. In our application, we will also do the same thing. For actions needing immediate email, we will use the `**sendEmail**` function from `**NotificationUtil**` and for the actions which can wait, such as notifying users about a new comment on the task, or when a new task is created, or when a task is moved in the workflow (for example, `**Backlog → ToDo → Dev-Complete → Ready-to-test → Closed**`), and so on, we will use the queue.    Let us move to implement the queue in our `**NotificationUtil**`. For the queue, we need to store the queued objects somewhere outside of the application so that if for any reason the application fails, we do not lose the objects in the queue. For this purpose, we can use Redis.    # [Using Redis for Queue](toc.xhtml#s221a)    Redis is a powerful in-memory data store that supports necessary data structures and features to implement a basic queue system. The following code snippet shows how a queue can be implemented and used:    `const redis = require('redis');`    `const client = redis.createClient();`    `// Adding a job to the queue`    `client.lpush('emailQueue', JSON.stringify({`    `from: 'pms-support@pms.com',`    `to: 'pmsbook2023@gmail.com',`    `subject: 'Welcome to PMS',`    `text: 'Welcome to PMS. We are happy to have you on board.'`    `}));`    `// Processing jobs from the queue`    `const processJob = () => {`    `client.brpop('emailQueue', 0, (err, reply) => {`    `if (err) {`    `// Handle error`    `} else {`    `const job = JSON.parse(reply[1]);`    `// Process job`    `console.log('Processing job:', job);`    `// Continue processing next job`    `processJob();`    `}`    `});`    `};`    `// Start processing`    `processJob();`    In this code, we created a client using `**redis.createClient()**` at first. This client can be used to push jobs to the queue using `**lpush**`. This call will maintain the records for our processing later. While processing the jobs, we can fetch the items from the same queue using `**brpop**` and process. This can be used in any functionality and not just for sending email. The `**lpush**` and `**brpop**` functions are specific to Redis.    In the preceding code, there is a comment added for handling the error. There can be many ways to handle the error while processing the queue. Once we use `**client.brpop**` it will remove the message from the queue and make it available for processing. If processing of the removed message was a failure, it must be handled in a proper manner.    One way to handle this situation can be to retry the processing again after some time. In this case, we need to save the failed message somewhere so that it can be processed later. Another way can be to simply add a log using console.log and notify the respective stakeholder. If there is an alarm system in place an alert can also be raised.    The approach is simple, we queue something using `**lpush**` and retrieve using `**brpop**` for processing. This implementation helps us to process emails but lacks error handling, retries, maintenance, and much more of what a sophisticated node package such as Bull can provide.    We will use the Bull node package for our implementation. Bull is a popular Node.js library used for handling background jobs and job queues. Bull is built on top of Redis.    Some of the key features of Bull are robustness, job scheduling, concurrency control, retry mechanism, event driven, rate limiting, persistence using redis, and so on. Further information about the package is available at [https://optimalbits.github.io/bull/](https://optimalbits.github.io/bull/) .    For our use case, where we want to queue emails, process the queue, handle failures, and improve efficiency, Bull is an excellent choice. Let us start with the implementation by installing and then adding Bull to our application.    `npm install bull`    After installing Bull, we can import it in the `**NotificationUtil**`.    `import Queue from 'bull';`    We need to create a `**queue**` for emails:    `private static emailQueue = new Queue('emailQueue', 'redis://127.0.0.1:6379');`    We also need to add a function which can be called from other parts of the application to enqueue an email job.    `// Function to enqueue email tasks`    `public static async enqueueEmail(to: string, subject: string, body: string) {`    `// Enqueue the email task`    `await NotificationUtil.emailQueue.add({`    `to,`    `subject,`    `body`    `});`    `}`    This is all for enqueuing an email. We just need to use the `**emailQueue.add()**` function to add the object which contains necessary information we need while sending the email.    We need to add logic to process the queue asynchronously. For smaller applications the logic to handle the queue can be part of the application itself. However, when applications grow bigger it is better to put the queue handling as a separate `**worker/process**`.    Let us add a new file for queue workers as `**queue_worker.ts**` in a new directory workers. File path would be `**src/workers/queue_worker.ts**`.    `import Queue from 'bull';`    `import { NotificationUtil } from '../utils/notification_util';`    `export class QueueWorker {`    `private static emailQueue = new Queue('emailQueue', 'redis://127.0.0.1:6379');`    `constructor() {`    `console.log('Initializing QueueWorker');`    `}`    `public beginProcessing() {`    `QueueWorker.emailQueue.process(async (job) => {`    `try {`    `const { to, subject, body } = job.data;`    `const responseEmail = await NotificationUtil.sendEmail(to, subject, body);`    `if (!responseEmail) {`    `// handle error`    `}`    ``console.log(`Email sent to ${to}`);``    `} catch (error) {`    `// handle error`    ``console.error(`Failed to send email: ${error.message}`);``    `}`    `});`    `}`    `}`    The preceding class defines a function to begin processing of the `**emailQueue**` defined as a static member of the class. In the class, while processing jobs to send email we just make a call to `**NotificationUtil.sendEmail()**` function.    # [Handling Failures](toc.xhtml#s222a)    It can happen that sometimes emails are not sent and we need to retry. The `**QueueWorker**` should be capable of handling such incidents. Let us modify the `**beginProcessing**` function to add support for failed jobs.    `public beginProcessing() {`    `QueueWorker.emailQueue.process(async (job) => {`    `// existing logic ..`    `});`    `QueueWorker.emailQueue.on('failed', async (job, err) => {`    `// Retry the job`    ``console.log(`Retrying job for ${job.data.to}`);``    `await job.retry();`    `});`    `}`    The `**QueueWorker.emailQueue.on**` function call with `'**failed**'` status gets executed whenever there is a failed job. In this case, we can retry the job using `**job.retry()**`.    There can be cases, when a failed job fails many more times. Basically, it is never going to succeed. Such cases should be handled with a check on how many attempts were made to run the same task. To fix this, we first need to define a max attempt count.    `private static MAX_ATTEMPTS = 4;`    Now, we need to modify the function again to check if the number of attempts made by a job exceeds the `**MAX_ATTTEMPTS**` or not.    `QueueWorker.emailQueue.on('failed', async (job, err) => {`    `if (job.attemptsMade >= QueueWorker.MAX_ATTEMPTS) {`    `// Handle the final failure`    ``console.error(`Job permanently failed for ${job.data.to}: ${err.message}`);``    `}else {`    `// Retry the job`    ``console.log(`Retrying job for ${job.data.to}`);``    `await job.retry();`    `}`    `});`    This will retry the failed job for four times and then exit if it does not succeed in four attempts. We should handle the case when the job finally fails. This can be done by some other kind of notification, proper reporting in logs, or recording the incident in a persisted mode, for example, in a database table.    # [Notifying About the New Task](toc.xhtml#s223a)    Till this point, we have a basic implementation of the queue for email notifications. We can now use it for other parts of the application. As an example, let us try to add notifications for all members of a project whenever there is a new task created.    Let us first add the following function in `**ProjectsUtil**` :    `public static async getProjectByProjectId(project_id: string) {`    `const projectService = new ProjectsService();`    `const project = await projectService.findOne(project_id);`    `return project.data;`    `}`    To send a notification, we need to first get the users of the project and we can get it from the project object. After this, let us update the `**addHandler()**` in `**TaskController**` inside `**task_controller.ts**` file.    `public async addHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req?.user?.rights, 'add_task')) {`    `res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });`    `return;`    `}`    `try {`    `// Create an instance of the TaskService`    `const service = new TasksService();`    `// Extract task data from the request body`    `const task = req.body;`    `// Get the project`    `const project = await ProjectsUtil.getProjectByProjectId(task.project_id);`    `//check if the provided project_id is valid`    `const isValidProject = project ? true : false;`    `if (!isValidProject) {`    `// If user_ids are invalid, send an error response`    `res.status(400).json({ statusCode: 400, status: 'error', message: 'Invalid project_id' });`    `return;`    `}`    `// Check if the provided user_id is valid`    `const isValidUser = await UsersUtil.checkValidUserIds([task.user_id]);`    `if (!isValidUser) {`    `// If user_ids are invalid, send an error response`    `res.status(400).json({ statusCode: 400, status: 'error', message: 'Invalid user_id' });`    `return;`    `}`    `// If user_ids are valid, create the task`    `const createdTask = await service.create(task);`    `res.status(201).json(createdTask);`    `// task is created, now send email to the user`    `const userIds = project.user_ids;`    `// for each user_id, enqueue an email task`    `for (const userId of userIds) {`    `const user = await UsersUtil.getUserById(userId);`    `if (user) {`    `await NotificationUtil.enqueueEmail(`    `user.email,`    `'New Task Created',`    `` `A new task has been created with the title ${task.title} and description ${task.description}`); ``    `}`    `}`    `} catch (error) {`    `// Handle errors and send an appropriate response`    ``console.error(`Error while addUser => ${error.message}`);``    `res.status(500).json({ statusCode: 500, status: 'error', message: 'Internal server error' });`    `}`    `}`    The function we need at `UserUtil` to get user by user_id is -    `public static async getUserById(user_id: string) {`    `const userService = new UsersService();`    `const queryResult = await userService.findOne(user_id);`    `if (queryResult.statusCode === 200) {`    `const user = queryResult.data;`    `return user;`    `}`    `return null;`    `}`    The logic of sending email can also be moved to a separate function. We can add a `**utility**` class for Tasks inside `**tasks_controller.ts**` similar to projects and users.    `export class TaskUtil {`    `// Notify the users of the project that a change`    `public static async notifyUsers(project, task) {`    `if (project) {`    `const userIds = project.user_ids;`    `for (const userId of userIds) {`    `const user = await UsersUtil.getUserById(userId);`    `if (user) {`    `await NotificationUtil.enqueueEmail(`    `user.email,`    `'New Task Created',`    `` `A new task has been created with the title ${task.title} and description ${task.description}` ``    `);`    `}`    `}`    `}`    `}`    `}`    The preceding function takes a project and task object and notifies all users. We can make a call to this function from the `**addHandler**`. The updated `**addHandler()**` function would be:    `public async addHandler(req: Request, res: Response): Promise<void> {`    `if (!hasPermission(req?.user?.rights, 'add_task')) {`    `res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });`    `return;`    `}`    `try {`    `// Create an instance of the TaskService`    `const service = new TasksService();`    `// Extract task data from the request body`    `const task = req.body;`    `// Get the project`    `const project = await`    `ProjectsUtil.getProjectByProjectId(task.project_id);`    `//check if the provided project_id is valid`    `const isValidProject = project ? true : false;`    `if (!isValidProject) {`    `// If user_ids are invalid, send an error response`    `res.status(400).json({ statusCode: 400, status: 'error', message: 'Invalid project_id' });`    `return;`    `}`    `// Check if the provided user_id is valid`    `const isValidUser = await UsersUtil.checkValidUserIds([task.user_id]);`    `if (!isValidUser) {`    `// If user_ids are invalid, send an error response`    `res.status(400).json({ statusCode: 400, status: 'error', message: 'Invalid user_id' });`    `return;`    `}`    `// If user_ids are valid, create the task`    `const createdTask = await service.create(task);`    `res.status(201).json(createdTask);`    `// Notify the users of the project that a new task has been created`    `await TaskUtil.notifyUsers(project, task);`    `} catch (error) {`    `// Handle errors and send an appropriate response`    ``console.error(`Error while addUser => ${error.message}`);``    `res.status(500).json({ statusCode: 500, status: 'error', message: 'Internal server error' });`    `}`    `}`    We can re-use the same function for update and delete handlers by a simple modification. We can pass an argument ``**action**`` which takes one value out of `**add**`, `**update**`, `**delete**`. Based on this action, we can modify the subject and content of the email. Following is the updated function:    `public static async notifyUsers(project, task, action) {`    `if (project) {`    `const userIds = project.user_ids;`    `let subject = '';`    `let body = '';`    `if (action === 'add') {`    `subject = 'New Task Created';`    ``body = `A new task has been created with the title ${task.title} and description ${task.description}`;``    `} else if (action === 'update') {`    `subject = 'Task Updated';`    ``body = `A task has been updated with the title ${task.title} and description ${task.description}`;``    `} else if (action === 'delete') {`    `subject = 'Task Deleted';`    ``body = `A task has been deleted with the title ${task.title} and description ${task.description}`;``    `}`    `for (const userId of userIds) {`    `const user = await UsersUtil.getUserById(userId);`    `if (user) {`    `await NotificationUtil.enqueueEmail(`    `user.email,`    `subject,`    `body`    `);`    `}`    `}`    `}`    `}`    Here, we are making the subject and body of the email based on the action provided. We also need to modify the call accordingly:    `// Notify the users of the project that a new task has been created`    `await TaskUtil.notifyUsers(project, task, 'add');`    Similar to `**addHandler**`, we can make call from `**updateHandler()**` and `**deleteHandler()**` `**deleteHandler()**` as:    `await TaskUtil.notifyUsers(project, task, 'update');`    `await TaskUtil.notifyUsers(project, task, 'delete');`    # [Considerations while Implementing Queues](toc.xhtml#s224a)    There is a set of challenges to consider while implementing a queue. Let us discuss a few of those here:    *   **Scalability**          When it comes to handling high volumes of messages, ensuring the smooth handling can be challenging. In such cases, using multiple queues (spread across different machines) to balance the load could be helpful.           *   **Latency and Throughput**          Throughput is the number of messages processed in a given timeframe. When there is a high volume of messages to process and the application flow is critical it becomes vital to ensure that the latency is within permissible limits. Higher latencies can be a bottleneck in real-time applications. To tackle such situations requires optimizations at application, queue and network level to achieve desirable throughput.           *   **Fault Tolerance and Recovery**          There can be cases when due an issue in the application the queue stops processing the messages. The messages must still be processed after the application has recovered from error. There should be a mechanism so that the messages in queue (waiting to be processed) are persisted or kept safe.              There are other considerations, for example, ordering and consistency of delivery of messages, security, monitoring while implementing the queue system. With help of careful design of the application these problems can be avoided, or in worst case, mitigated.    # [Conclusion](toc.xhtml#s225a)    This chapter introduced a new concept `'Queue'` which is very important to handle processing of various types of data. In our case, we used it for email notifications. The `**NotificationUtil**` and `**QueueWorker**` together implemented the queue mechanism with the help of the `Bull`, a `**Node.js**` library built on top of Redis.    In the next chapter, we will learn how an application can be built for production and be deployed on real servers. We will also learn to obfuscate the code so that, if it falls in wrong hands, it will not reveal everything and make the job harder for an outsider to crack.    # [Multiple Choice Questions](toc.xhtml#s226a)    1.  What is the primary purpose of notifications in a project lifecycle?     1.  To provide entertainment.     2.  To inform stakeholders about changes and activities.     3.  To gather feedback.     4.  To schedule meetings. 2.  How does a queue contribute to the scalability of email sending in a project management system?     1.  By limiting the number of users.     2.  By reducing the number of emails sent.     3.  By handling increased load effectively.     4.  By sending all emails immediately. 3.  What is a key advantage of a queue in terms of reliability for email notifications?     1.  It guarantees email delivery on the first attempt.     2.  It simplifies email content.     3.  It allows for retrying failed email sends.     4.  It uses less server resources per email. 4.  Why is Redis chosen for implementing the queue in NotificationUtil?     1.  For its complexity.     2.  Because it is an in-memory data store with suitable features.     3.  Solely for cost-saving purposes.     4.  For its slow processing speed. 5.  What is the purpose of a transporter in Node.js and nodemailer?     1.  To store email templates.     2.  To encapsulate the email sending functionality.     3.  To manage database connections.     4.  To encrypt email content. 6.  How does a timely received notification affect team communication?     1.  It has no significant impact.     2.  It slows down communication.     3.  It speeds up communication.     4.  It complicates communication. 7.  What factors influence the medium of notification?     1.  Developer’s preference.     2.  Time of the day.     3.  Urgency, criticality of communication, nature of the project.     4.  Cost of the notification system. 8.  How is the transporter object typically used in a Node.js application?     1.  Created for each email sent.     2.  Created once and reused.     3.  Only used for receiving emails.     4.  Initialized in every function call.    # [Answers](toc.xhtml#s227a)    1.  b 2.  c 3.  c 4.  b 5.  b 6.  c 7.  c 8.  b    # [Further Readings](toc.xhtml#s228a)    [https://nodemailer.com/](https://nodemailer.com/)    [https://redis.io/](https://redis.io/)    [https://www.npmjs.com/package/redis](https://www.npmjs.com/package/redis)    [https://redis.com/glossary/redis-queue/](https://redis.com/glossary/redis-queue/)    [https://en.wikipedia.org/wiki/Message_queue](https://en.wikipedia.org/wiki/Message_queue) ```"]