<html><head></head><body>
		<div id="_idContainer154">
			<h1 id="_idParaDest-151"><em class="italic"><a id="_idTextAnchor150"/>Chapter 8</em>: Using MongoDB with Node.js</h1>
			<p><strong class="bold">MongoDB</strong> is the<a id="_idIndexMarker567"/> database traditionally associated with Node.js. It is a NoSQL type database, which means that SQL will not be used to access the information it contains.</p>
			<p>MongoDB is a document-oriented database in which <a id="_idIndexMarker568"/>we store so-called <em class="italic">documents</em>; that is, a data structure of any type, such as information written on a sheet of paper (which is then equivalent to a document). Several sheets of paper, thus corresponding to several documents, form what<a id="_idIndexMarker569"/> is called a <em class="italic">collection</em>.</p>
			<p>An example of a document is, for example, the first name, the last name, and the address of a customer. Aggregated information from multiple customers would be called a collection.</p>
			<p>In this chapter, we’ll study how to use MongoDB in conjunction with Node.js in order to store, read, delete, or update information in the database.</p>
			<p>Inserting, searching, updating, or deleting data are the main actions that can be performed in a database. Therefore, in this chapter, we’ll see how to perform these operations with the MongoDB database.</p>
			<p>Here are the topics covered in this chapter:</p>
			<ul>
				<li>Installing MongoDB and the mongoose module</li>
				<li>Connecting to the MongoDB database</li>
				<li>Creating documents</li>
				<li>Searching documents</li>
				<li>Updating documents</li>
				<li>Deleting documents</li>
			</ul>
			<p>Let’s start by installing MongoDB and the <strong class="bold">mongoose</strong> module, which will allow MongoDB to be used in Node.js programs.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%208.zip">https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%208.zip</a>.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Installing MongoDB </h1>
			<p>The<a id="_idIndexMarker570"/> MongoDB database is independent of Node.js, which requires installing it separately. To do <a id="_idIndexMarker571"/>this, go to the site <a href="https://www.mongodb.com/docs/manual/administration/install-community/">https://www.mongodb.com/docs/manual/administration/install-community/</a>. Download the version suitable for your system.</p>
			<p>Once MongoDB is installed, verify that the installation is correct by typing the <strong class="source-inline">mongo -h</strong> command in a command interpreter. The <strong class="source-inline">mongo</strong> command is located in the <strong class="source-inline">Server/x.x/bin</strong> directory of MongoDB, where <strong class="source-inline">x.x</strong> is the version number of MongoDB installed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, the <strong class="source-inline">mongo</strong> utility<a id="_idIndexMarker572"/> is available directly when installing MongoDB. However, it is possible that this utility will soon be available separately and <a id="_idIndexMarker573"/>called <strong class="source-inline">mongosh</strong>. In this case, download this utility from <a href="https://www.mongodb.com/docs/mongodb-shell/install/">https://www.mongodb.com/docs/mongodb-shell/install/</a>.</p>
			<p class="callout">The <strong class="source-inline">mongo</strong> command will simply be replaced by the equivalent <strong class="source-inline">mongosh</strong> command. Both commands work identically.</p>
			<p>After<a id="_idIndexMarker574"/> installing MongoDB, we will look into the mongo (or mongosh) utility. The mongo utility makes it easy to see the contents of database collections, without having to write program lines. It is therefore useful for checking, for example, whether a document has been correctly inserted into a collection, or that its deletion has been successful. Let’s see how to use the mongo utility.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Using the mongo utility</h2>
			<p>The<a id="_idIndexMarker575"/> mongo utility enables you to easily view databases and the collections they contain. The mongo utility is launched by simply typing the <strong class="source-inline">mongo</strong> command in a command interpreter. The program then waits for database access commands, or the <strong class="source-inline">exit</strong> command to exit.</p>
			<p>Here is the list of the main commands available in the mongo utility:</p>
			<ul>
				<li><strong class="source-inline">show dbs</strong>: This <a id="_idIndexMarker576"/>shows a list of existing databases. A database will be visible here only if it contains at least one collection.</li>
				<li><strong class="source-inline">db=connect("mydb_test")</strong>: This is to connect to the database <strong class="source-inline">mydb_test</strong>. The <strong class="source-inline">db</strong> variable will then be used to access the database collections.</li>
				<li><strong class="source-inline">show collections</strong>: This shows the collections of the connected database. A collection will be present if it contains at least one document.</li>
				<li><strong class="source-inline">db.clients.find()</strong>: This shows all documents in the <strong class="source-inline">clients</strong> collection.</li>
				<li><strong class="source-inline">db.clients.find({name:"Clinton"})</strong>: This lists documents in the <strong class="source-inline">clients</strong> collection whose name is <strong class="source-inline">Clinton</strong>.</li>
				<li><strong class="source-inline">db.clients.find().sort({name:1})</strong>: This sorts documents in ascending order of the <strong class="source-inline">name</strong> field. Use <strong class="source-inline">{name:-1}</strong> for descending sort.</li>
				<li><strong class="source-inline">db.clients.count()</strong>: This counts the number of documents found in the <strong class="source-inline">clients</strong> collection.</li>
				<li><strong class="source-inline">db.clients.renameCollection("clients2")</strong>: This renames the <strong class="source-inline">clients</strong> collection to <strong class="source-inline">clients2</strong>.</li>
				<li><strong class="source-inline">db.clients.drop()</strong>: This drops the <strong class="source-inline">clients</strong> collection (all documents are dropped).</li>
				<li><strong class="source-inline">db.dropDatabase()</strong>: This <a id="_idIndexMarker577"/>drops the connected database (all collections are removed).</li>
			</ul>
			<p>Other commands exist, in particular, for inserting, updating, or deleting documents in a collection. But since these actions are performed through the mongoose module instead, we will describe them using the mongoose module.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Installing the mongoose module</h2>
			<p>To establish the <a id="_idIndexMarker578"/>relationship between MongoDB and Node.js, several npm modules have been created. The most widely used one currently is the <strong class="source-inline">mongoose</strong> module. It is installed in the <strong class="source-inline">node_modules</strong> directory of the current directory by typing the <strong class="source-inline">npm install mongoose</strong> command.</p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/Figure_8.01_B17416.jpg" alt="Figure 8.1 – Installing the mongoose module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Installing the mongoose module</p>
			<p>Once mongoose has been downloaded by npm, we check whether it is accessible for our programs. Let’s display the mongoose version for our programs. We write this snippet in the file <strong class="source-inline">test.js</strong>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying mongoose version (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">console.log("mongoose version =", mongoose.version);</pre>
			<p>Let’s use the <strong class="source-inline">node test.js</strong> command to run the previous program:</p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/Figure_8.02_B17416.jpg" alt="Figure 8.2 – Checking that mongoose is accessible&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Checking that mongoose is accessible</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">If you get an error loading the mongoose module, it’s probably because you installed it globally (with the <strong class="source-inline">-g</strong> option). In this case, just type the <strong class="source-inline">npm link mongoose</strong> command in the terminal to get rid of the error.</p>
			<p>The <a id="_idIndexMarker579"/>mongoose module will allow us to use the MongoDB database to create documents, search them, update them, or destroy them. These are the classic operations that can be performed on a database.</p>
			<p>But to be able to perform these operations, it is necessary to first connect to the database.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Connecting to the MongoDB database</h1>
			<p>All <a id="_idIndexMarker580"/>operations to access MongoDB require establishing a connection with it. Now let’s see how to establish a connection with MongoDB.</p>
			<p>The <strong class="source-inline">mongoose.connect(url)</strong> instruction connects the mongoose module to the database specified in the <strong class="source-inline">url</strong> parameter. The <strong class="source-inline">url</strong> parameter is of the form <strong class="source-inline">"mongodb://localhost/mydb_test"</strong> to connect to the <strong class="source-inline">mydb_test</strong> database on the localhost server.</p>
			<p>The database will actually be created (and visible with the execution of the <strong class="source-inline">show dbs</strong> command of the mongo utility) when the first document is inserted into it:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Connecting to the mydb_test database (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code"><strong class="bold">mongoose.connect("mongodb://localhost/mydb_test");</strong></pre>
			<pre class="source-code">console.log("Connecting to mydb_test database in progress...");</pre>
			<p>Let’s run the previous program:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/Figure_8.03_B17416.jpg" alt="Figure 8.3 – Database connection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Database connection</p>
			<p>To know <a id="_idIndexMarker581"/>whether the connection to the database has actually been made, mongoose sends the <strong class="source-inline">open</strong> event (if the connection was successful) or the <strong class="source-inline">error</strong> event (if the connection fails) on the <strong class="source-inline">mongoose.connection</strong> object.</p>
			<p>Next, we will take these two events into account and integrate them into the previous program. This is done using the <strong class="source-inline">on(event, callback)</strong> method defined on the <strong class="source-inline">mongoose.connection</strong> object:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">on(event, callback)</strong> method is used to process the reception of the event and to associate it with the processing described in the callback function.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using open and error events on database connection (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code"><strong class="bold">mongoose.connection.on("error", function() {</strong></pre>
			<pre class="source-code"><strong class="bold"> console.log("mydb_test database connection error")</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code"><strong class="bold">mongoose.connection.on("open", function() {</strong></pre>
			<pre class="source-code"><strong class="bold"> console.log("Successful connection to mydb_test </strong></pre>
			<pre class="source-code"><strong class="bold"> database");</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code">console.log("Connecting to mydb_test database in progress...");</pre>
			<p>Let’s run the<a id="_idIndexMarker582"/> previous program:</p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/Figure_8.04_B17416.jpg" alt="Figure 8.4 – Successful connection to the database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Successful connection to the database</p>
			<p>We have seen how to connect to the database. We will therefore be able to create documents in a collection of the database.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Creating documents in MongoDB</h1>
			<p>Once the <a id="_idIndexMarker583"/>database has<a id="_idIndexMarker584"/> been accessed, you can create documents in it.</p>
			<p>A<a id="_idIndexMarker585"/> document will be inserted into<a id="_idIndexMarker586"/> a <em class="italic">collection</em>. A collection will therefore group together a set of documents. The database will therefore be a set of collections, each containing documents.</p>
			<p>In order to be able to insert documents, mongoose asks us to describe the structure of these documents. For this, we will use schemas and models.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Describing document structure using schemas and models</h2>
			<p>To access the documents in the database, the documents must be described by means of schemas and models.</p>
			<p class="callout-heading">Definitions</p>
			<p class="callout">A <em class="italic">schema</em> allows you to <a id="_idIndexMarker587"/>define the structure of a document that is stored in a collection. The structure is defined according to MongoDB data types.</p>
			<p class="callout">A <em class="italic">model</em> is the<a id="_idIndexMarker588"/> representation of a schema as a JavaScript class. It links a schema to a MongoDB collection.</p>
			<p>Let’s look at how to create a schema and then a model.</p>
			<h3>Creating a schema</h3>
			<p>A schema defines the<a id="_idIndexMarker589"/> fields of a document using Node.js internal object classes. These are the following classes:</p>
			<ul>
				<li><strong class="source-inline">String</strong>: This defines a string of characters.</li>
				<li><strong class="source-inline">Number</strong>: This defines a numeric field.</li>
				<li><strong class="source-inline">Boolean</strong>: This defines a Boolean.</li>
				<li><strong class="source-inline">Array</strong>: This defines an array.</li>
				<li><strong class="source-inline">Buffer</strong>: This defines a buffer of bytes.</li>
				<li><strong class="source-inline">Date</strong>: This defines a date.</li>
				<li><strong class="source-inline">Object</strong>: This defines a JavaScript object.</li>
			</ul>
			<p>The <strong class="source-inline">mongoose.Schema(format)</strong> method is used to define the schema associated with the document. The <strong class="source-inline">format</strong> parameter is a JavaScript object that associates each field in the document with the type (in the above list) that represents it.</p>
			<p>Let’s create<a id="_idIndexMarker590"/> the schema defining a client. A client is characterized by its <strong class="source-inline">lastname</strong>, <strong class="source-inline">firstname</strong>, and <strong class="source-inline">address</strong>. All these fields are of type <strong class="source-inline">String</strong>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Defining the schema associated with a client (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code"><strong class="bold">var clientSchema = mongoose.Schema({</strong></pre>
			<pre class="source-code"><strong class="bold"> lastname : String,</strong></pre>
			<pre class="source-code"><strong class="bold"> firstname : String,</strong></pre>
			<pre class="source-code"><strong class="bold"> address : String</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>Now let’s explain how to create a model from the schema.</p>
			<h3>Creating a model</h3>
			<p>The<a id="_idIndexMarker591"/> schema is then used to define the model associated with the document. The model corresponds to a JavaScript class that will be used to create the documents in a collection.</p>
			<p>The <strong class="source-inline">mongoose.model(collection, schema)</strong> method returns a JavaScript class associated with the schema. This class is called a model.</p>
			<p>Documents created with this class will be inserted into the specified <strong class="source-inline">collection</strong>. The collection may not exist before inserting a document. A collection requires at least one document within it.</p>
			<p class="callout-heading">Summary</p>
			<p class="callout">A schema specifies the format of a document stored in a collection, while a model is a JavaScript class used to create each such document. We associate a document schema with a collection using the <strong class="source-inline">mongoose.model(collection, schema)</strong> method call. This returns a JavaScript class that can then be used to generate individual document instances.</p>
			<p>Let’s <a id="_idIndexMarker592"/>create the <strong class="source-inline">Client</strong> class, which will create the clients that will be stored in the <strong class="source-inline">clients</strong> collection. It is traditional to name the collection based on the name of the model, in lowercase and in plural:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating the Client model from the schema (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code"><strong class="bold">// creation of the Client class associated with the clients </strong></pre>
			<pre class="source-code"><strong class="bold">// collection</strong></pre>
			<pre class="source-code"><strong class="bold">var Client = mongoose.model("clients", clientSchema);</strong></pre>
			<p>The <strong class="source-inline">Client</strong> class is<a id="_idIndexMarker593"/> now available to create the documents that will be inserted into the <strong class="source-inline">clients</strong> collection.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Creating the document</h2>
			<p>There are two methods for creating<a id="_idIndexMarker594"/> the documents in a collection. These are the <strong class="source-inline">doc.save(callback)</strong> instance method and the <strong class="source-inline">create(doc, callback)</strong> class method. Let’s <a id="_idIndexMarker595"/>look at these two ways to create documents in a collection. </p>
			<p>Let’s start by using the <strong class="source-inline">doc.save(callback)</strong> instance method.</p>
			<h3>Using the doc.save(callback) instance method</h3>
			<p>The client document is<a id="_idIndexMarker596"/> created in memory from the previously created class (by means of <strong class="source-inline">var client = new Client()</strong>), then saved in the <strong class="source-inline">clients</strong> collection by means of the <strong class="source-inline">client.save()</strong> method.</p>
			<p>The callback function allows processing when the document has finished being inserted into the collection. This is especially useful if it is necessary to wait for the document to be inserted into the database before continuing processing:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the save() instance method to save document (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">// create the document in memory</strong></pre>
			<pre class="source-code"><strong class="bold">var c = new Client({lastname :"Clinton", firstname:"Bill", address:"Washington"});</strong></pre>
			<pre class="source-code"><strong class="bold">console.log("Before the save() statement");</strong></pre>
			<pre class="source-code"><strong class="bold">// save the document in the database (clients collection)</strong></pre>
			<pre class="source-code"><strong class="bold">c.save(function(err) {</strong></pre>
			<pre class="source-code"><strong class="bold">  if (!err) console.log("The client is inserted into the </strong></pre>
			<pre class="source-code"><strong class="bold">  collection");</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code"><strong class="bold">console.log("After the save() statement");</strong></pre>
			<p>The callback<a id="_idIndexMarker597"/> function takes the <strong class="source-inline">err</strong> parameter, which corresponds to a possible error message (otherwise, it is <strong class="source-inline">null</strong>).</p>
			<p>We get the following result:</p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/Figure_8.05_B17416.jpg" alt="Figure 8.5 – Using the doc.save() instance method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Using the doc.save() instance method</p>
			<p>Using the traces displayed in the console, we can see that the message <strong class="source-inline">The client is inserted into the collection</strong> is displayed after the other messages, which means that inserting a document is not blocking other tasks (i.e., other tasks can be done while waiting for insertion in the database).</p>
			<p>The <strong class="source-inline">save()</strong> method can also be used as a <strong class="source-inline">Promise</strong> object (see <a href="B17416_02_ePub.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring the Advanced Concepts of JavaScript</em>). For this, we use the <strong class="source-inline">then(callback)</strong> method afterward, possibly followed by the <strong class="source-inline">catch(callback)</strong> method to process the cases of error when calling the <strong class="source-inline">save()</strong> method.</p>
			<p>In this case, we write<a id="_idIndexMarker598"/> the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the save() method as a Promise objet</p>
			<pre class="source-code">c.save().then(function(doc) {</pre>
			<pre class="source-code">  console.log(doc);</pre>
			<pre class="source-code">  console.log("The client is inserted into the collection");</pre>
			<pre class="source-code">}).catch(function(err) {</pre>
			<pre class="source-code">  console.log(err);  // display the error</pre>
			<pre class="source-code">});</pre>
			<p>Now let’s see the other method of creating a document with the <strong class="source-inline">create(doc, callback)</strong> class method.</p>
			<h3>Using the create(doc, callback) class method</h3>
			<p>A class method means that we <a id="_idIndexMarker599"/>can use the method without having instantiated an object, unlike an instance method, which requires that the object of the class be created (with <strong class="source-inline">c = new Client()</strong>).</p>
			<p>To create the document associated with the client identified by <strong class="source-inline">{lastname:"Obama", firstname:"Barack", address:"Washington"}</strong>, we would write the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the Client.create(doc, callback) class method to save document (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code">console.log("Before the create() statement");</pre>
			<pre class="source-code">// save the document in the database (clients collection)</pre>
			<pre class="source-code"><strong class="bold">Client.create({lastname:"Obama", firstname:"Barack", address:"Washington"}, function(err, doc) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log("The client is inserted into the collection", </strong></pre>
			<pre class="source-code"><strong class="bold">  doc);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code">console.log("After the create() statement");</pre>
			<p>The <strong class="source-inline">create(doc, callback)</strong> class method is used by prefixing it with the name of the <a id="_idIndexMarker600"/>JavaScript class (here, the <strong class="source-inline">Client</strong> class).</p>
			<p>The document to be saved is written in the form of a JavaScript object (JSON format) but can also be an object instantiated with <strong class="source-inline">c = new Client()</strong>.</p>
			<p>The callback function of the form <strong class="source-inline">callback(err, doc)</strong> is executed at the end of saving the document in the database. This callback function is useful if you want to perform a process while being certain that the document has been saved in the collection.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that the callback function <strong class="source-inline">callback(err, doc)</strong> of the <strong class="source-inline">create(doc, callback)</strong> method has the two parameters <strong class="source-inline">err</strong> and <strong class="source-inline">doc</strong>, which are the possible error and the document saved in the database, respectively.</p>
			<p>Let’s run the <a id="_idIndexMarker601"/>previous program:</p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/Figure_8.06_B17416.jpg" alt="Figure 8.6 – Using the Client.create() class method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Using the Client.create() class method</p>
			<p>The saved document has the fields indicated in the format associated with the model (here, the <strong class="source-inline">lastname</strong>, <strong class="source-inline">firstname</strong>, and <strong class="source-inline">address</strong> fields), but also the <strong class="source-inline">_id</strong> and <strong class="source-inline">__v</strong> fields, added automatically by MongoDB:</p>
			<ul>
				<li>The <strong class="source-inline">_id</strong> field is a field used by MongoDB to give a unique identifier to each document in a collection. It plays the role of a primary key.</li>
				<li>The <strong class="source-inline">__v</strong> field is a field added by mongoose, associated with the document version number. We will not use it here.</li>
			</ul>
			<p>As with the <strong class="source-inline">save()</strong> instance <a id="_idIndexMarker602"/>method, the <strong class="source-inline">create(doc)</strong> class method can be used as a <strong class="source-inline">Promise</strong> object. For this, we do not use the <strong class="source-inline">callback</strong> parameter in the <strong class="source-inline">create(doc)</strong> method and instead use the <strong class="source-inline">then(callback)</strong> and <strong class="source-inline">catch(callback)</strong> methods following the <strong class="source-inline">create(doc)</strong> method call.</p>
			<p>For example, we could also write the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using create() method as a Promise object</p>
			<pre class="source-code">Client.create({lastname:"Obama", firstname:"Barack", address:"Washington"}).then(function(doc) {</pre>
			<pre class="source-code">  console.log("The client is inserted into the collection", </pre>
			<pre class="source-code">  doc);</pre>
			<pre class="source-code">});</pre>
			<p>In the previous <a id="_idIndexMarker603"/>examples, we have inserted two documents into the <strong class="source-inline">clients</strong> collection. Let’s use the mongo utility to display the inserted documents and verify the documents that are present in the collection.</p>
			<h3>Using the mongo utility to view inserted documents</h3>
			<p>To display the <a id="_idIndexMarker604"/>inserted documents, use the <a id="_idIndexMarker605"/>mongo utility and type the following commands:</p>
			<ol>
				<li><strong class="source-inline">db=connect("mydb_test")</strong> to connect to the database</li>
				<li><strong class="source-inline">show collections</strong> to show the collections already present</li>
				<li><strong class="source-inline">db.clients.find()</strong> to display documents from the <strong class="source-inline">clients</strong> collection</li>
			</ol>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/Figure_8.07_B17416.jpg" alt="Figure 8.7 – Using the mongo utility to view documents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Using the mongo utility to view documents</p>
			<p>We thus <a id="_idIndexMarker606"/>check that the two documents of the <strong class="source-inline">clients</strong> collection<a id="_idIndexMarker607"/> are indeed present.</p>
			<p>Let’s see how to search for them with mongoose module methods.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Searching for documents in MongoDB</h1>
			<p>Once the <a id="_idIndexMarker608"/>documents have been inserted into the collection, they <a id="_idIndexMarker609"/>can be searched for using the <strong class="source-inline">find()</strong> class method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">find()</strong> method is a class method, which means that it is used by prefixing it with the class name associated with the model, for example, <strong class="source-inline">Client.find()</strong>.</p>
			<p>The <strong class="source-inline">find(conditions, callback)</strong> method is used to perform a search in the collection associated with the model, then to retrieve the results of the search in the callback function indicated as a parameter.</p>
			<p>Let’s take an in-depth look at the parameters:</p>
			<ul>
				<li>The <strong class="source-inline">conditions</strong> parameter is a JavaScript object used to specify search conditions. If no condition is specified, do not indicate anything (or indicate an empty object <strong class="source-inline">{}</strong>).</li>
				<li>The callback function is of the form <strong class="source-inline">callback(err, results)</strong> where <strong class="source-inline">err</strong> is an error message (<strong class="source-inline">null</strong> otherwise) and <strong class="source-inline">results</strong> is an array containing the search results (empty <strong class="source-inline">[]</strong> if none).</li>
			</ul>
			<p>There is also the <strong class="source-inline">findOne(conditions, callback)</strong> class method, which allows you, on the same principle, to find only the first document that satisfies the search. The callback function is of the form <strong class="source-inline">callback(err, result)</strong> where <strong class="source-inline">result</strong> is the first document found.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">findOne(conditions, callback)</strong> method will be useful if you are looking for a single document, for example, from its identifier <strong class="source-inline">_id</strong>.</p>
			<p>You can also<a id="_idIndexMarker610"/> use the <strong class="source-inline">find(conditions)</strong> and <strong class="source-inline">findOne(conditions)</strong> methods <a id="_idIndexMarker611"/>without specifying the callback function as a parameter. For this, we use the <strong class="source-inline">then(callback)</strong> and <strong class="source-inline">catch(callback)</strong> methods to perform the processing on the documents found or in the event of an error. We can also use the <strong class="source-inline">exec(callback)</strong> method, as explained in the following section.</p>
			<p>Let us now examine how to write the <strong class="source-inline">conditions</strong> parameter used in the two methods <strong class="source-inline">find()</strong> and <strong class="source-inline">findOne()</strong>.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>Writing search conditions</h2>
			<p>In the <strong class="source-inline">conditions</strong> parameter, we <a id="_idIndexMarker612"/>indicate an object whose properties are the fields of the documents in the collection, and the associated values are the values sought for the field, of the form <strong class="source-inline">{field1:value1, field2:value2...}</strong>, for example, <strong class="source-inline">{lastname:"Clinton", firstname:"Bill"}</strong>.</p>
			<p>Other properties can be used as keywords to express conditions. They start with the <strong class="source-inline">$</strong> sign, such as: <strong class="source-inline">$or</strong>, <strong class="source-inline">$exists</strong>, <strong class="source-inline">$type</strong>, <strong class="source-inline">$where</strong>, <strong class="source-inline">$gt</strong>, and <strong class="source-inline">$lt</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A list of possible <a id="_idIndexMarker613"/>keywords can be found here: <a href="https://docs.mongodb.com/manual/reference/operator/query/">https://docs.mongodb.com/manual/reference/operator/query/</a>.</p>
			<p>Here are some <a id="_idIndexMarker614"/>examples of conditions:</p>
			<ul>
				<li><strong class="source-inline">{ }</strong>: All documents in the collection. You can also write <strong class="source-inline">find()</strong>, which is equivalent to <strong class="source-inline">find({})</strong>.</li>
				<li><strong class="source-inline">{ lastname: "Clinton" }</strong>: All documents whose lastname is <strong class="source-inline">Clinton</strong>.</li>
				<li><strong class="source-inline">{ lastname: "Clinton", firstname: "Bill" }</strong>: All documents whose lastname is <strong class="source-inline">Clinton</strong> and first name is <strong class="source-inline">Bill</strong>.</li>
				<li><strong class="source-inline">{ $or: [{ lastname: "Clinton"}, { firstname: "Jimmy" }] }</strong>: All documents whose lastname is <strong class="source-inline">Clinton</strong> or first name is <strong class="source-inline">Jimmy</strong>.</li>
				<li><strong class="source-inline">{ lastname: /obama/i }</strong>: All documents whose lastname contains the string <strong class="source-inline">obama</strong> regardless of case (regular expression).</li>
				<li><strong class="source-inline">{ address: { $exists: true} }</strong>: All documents whose <strong class="source-inline">address</strong> field exists, regardless of its type (String, Object, etc.).</li>
				<li><strong class="source-inline">{ address: { $exists: true, $type: 2 } }</strong>: All documents whose <strong class="source-inline">address</strong> field exists, and which is of type <strong class="source-inline">2</strong> (String).</li>
				<li><strong class="source-inline">{"address.city": "Washington" }</strong>: All documents containing the <strong class="source-inline">address</strong> field that itself has a city field whose value is <strong class="source-inline">Washington</strong>.</li>
				<li><strong class="source-inline">{lastname:{$type:2},   $where:"this.lastname.match(/^Clinton|carter$/i)"}</strong>: All documents whose lastname is a string (type = <strong class="source-inline">2</strong>) and whose lastname begins with <strong class="source-inline">Clinton</strong> or ends with <strong class="source-inline">carter</strong>, regardless of case. You must indicate that the lastname is a character string, otherwise you may have an error with names that are not in this form.</li>
				<li><strong class="source-inline">{lastname: { $gt: "J", $lt: "S" }}</strong>: All documents whose lastname is greater than <strong class="source-inline">"J"</strong> and less than <strong class="source-inline">"S"</strong>.</li>
				<li><strong class="source-inline">{lastname: { $in:["Clinton", "Carter", "Obama"] }}</strong> : All documents<a id="_idIndexMarker615"/> whose lastname is <strong class="source-inline">Clinton</strong>,  <strong class="source-inline">Carter</strong>,  or <strong class="source-inline">Obama</strong>.</li>
			</ul>
			<p>Once the search conditions have been expressed, the results found must be retrieved and displayed. Let’s see how to do it.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Retrieving and displaying the results</h2>
			<p>Whatever the condition expressed, the corresponding results can be retrieved in the callback function associated with the <strong class="source-inline">find()</strong> method, of the form <strong class="source-inline">callback(err, results)</strong>. We will also see that it is possible to use the <strong class="source-inline">exec(callback)</strong> method to retrieve the results.</p>
			<p>Let’s look at these two ways to retrieve search results.</p>
			<h3>Using the callback parameter of the find(conditions, callback) method</h3>
			<p>Let’s find all <a id="_idIndexMarker616"/>clients whose lastname is <strong class="source-inline">Clinton</strong> or firstname is <strong class="source-inline">Barack</strong>. The result will be displayed in the callback function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying clients whose lastname is “Clinton” or firstname is “Barack” (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.find({ $or : [ { lastname : "Clinton" }, { firstname : "Barack"} ] }, function(err, clients) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log(clients);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>We obtain the <a id="_idIndexMarker617"/>result shown in the following figure:</p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/Figure_8.08_B17416.jpg" alt="Figure 8.8 – Displaying search results with find(conditions, callback)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Displaying search results with find(conditions, callback)</p>
			<p>The callback<a id="_idIndexMarker618"/> function can be expressed in the <strong class="source-inline">find()</strong> method as before, or be specified in the <strong class="source-inline">exec()</strong> method used after the <strong class="source-inline">find()</strong> method. Let us now examine this second possibility.</p>
			<h3>Using the exec(callback) method</h3>
			<p>Another way to<a id="_idIndexMarker619"/> retrieve results is to use the <strong class="source-inline">exec(callback)</strong> method following the <strong class="source-inline">find(conditions)</strong> method. The <strong class="source-inline">find(conditions)</strong> method is used here without indicating a callback function in its parameters because the callback function is indicated in the <strong class="source-inline">exec(callback)</strong> method.</p>
			<p>The advantage of this is that we can insert new methods between the <strong class="source-inline">find()</strong> method and the <strong class="source-inline">exec()</strong> method. For example, if we want to add as additional conditions that the <strong class="source-inline">lastname</strong> field must be equal to <strong class="source-inline">Clinton</strong>, we can write the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Adding as search conditions that lastname is “Clinton” (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.find({ $or : [ { lastname : "Clinton" }, { firstname : "Barack"} ] })</strong></pre>
			<pre class="source-code"><strong class="bold">.where("lastname")</strong></pre>
			<pre class="source-code"><strong class="bold">.eq("Clinton")</strong></pre>
			<pre class="source-code"><strong class="bold">.exec(function(err, clients) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log(clients);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Methods such as <strong class="source-inline">where(field)</strong> and <strong class="source-inline">eq(value)</strong> can be chained after the <strong class="source-inline">find()</strong> method. The execution <a id="_idIndexMarker620"/>of the search will be effective when calling the <strong class="source-inline">exec()</strong> method. Other usage possibilities are described here: <a href="https://mongoosejs.com/docs/api/query.html#query_Query-where">https://mongoosejs.com/docs/api/query.html#query_Query-where</a>.</p>
			<p>You can also<a id="_idIndexMarker621"/> use the <strong class="source-inline">exec(callback)</strong> method without specifying the callback function as a parameter. For this, we use the <strong class="source-inline">then(callback)</strong> and <strong class="source-inline">catch(callback)</strong> methods to perform the processing on the documents found or in the event of an error.</p>
			<p>We write the following for this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using exec() method as a Promise object</p>
			<pre class="source-code">Client.find({ $or : [ { lastname : "Clinton" }, { firstname : "Barack"} ] })</pre>
			<pre class="source-code">.where("lastname")</pre>
			<pre class="source-code">.eq("Clinton")</pre>
			<pre class="source-code">.exec()</pre>
			<pre class="source-code">.then(function(clients) {</pre>
			<pre class="source-code">  console.log(clients);  // display the clients</pre>
			<pre class="source-code">})</pre>
			<pre class="source-code">.catch(function(err) {</pre>
			<pre class="source-code">  console.log(err);  // display the error</pre>
			<pre class="source-code">});</pre>
			<p>The result is displayed in the following figure.</p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/Figure_8.09_B17416.jpg" alt="Figure 8.9 – Using the exec(callback) method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Using the exec(callback) method</p>
			<p>We’ve learned how to create documents, then search for them. Now let’s look at how to update them.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Updating documents in MongoDB</h1>
			<p>It is possible to <a id="_idIndexMarker622"/>modify one or more documents of a<a id="_idIndexMarker623"/> collection. The <strong class="source-inline">updateOne()</strong> and <strong class="source-inline">updateMany()</strong> class methods are used respectively to modify the first document found or all of the documents found.</p>
			<p>These two methods have similar parameters:</p>
			<ul>
				<li><strong class="source-inline">updateMany(conditions, update, callback)</strong> indicates modifying the data indicated in the <strong class="source-inline">update</strong> object on the documents specified by the indicated <strong class="source-inline">conditions</strong>. The callback function of the form <strong class="source-inline">callback(err, response)</strong> is called after the update.</li>
				<li><strong class="source-inline">updateOne(conditions, update, callback)</strong> indicates modifying the data indicated in the <strong class="source-inline">update</strong> object on the first document found by the indicated <strong class="source-inline">conditions</strong>. The callback function of the form <strong class="source-inline">callback(err, response)</strong> is called after the update.</li>
				<li>Only the <strong class="source-inline">conditions</strong> and <strong class="source-inline">update</strong> parameters are mandatory in the two methods.<p class="callout-heading">Warning</p><p class="callout">If the callback is not present in the method, you must use the <strong class="source-inline">then()</strong> or <strong class="source-inline">exec()</strong> method afterward, otherwise the update is not done.</p></li>
			</ul>
			<p>Let’s modify the<a id="_idIndexMarker624"/> address of <strong class="source-inline">Clinton</strong>, which will now <a id="_idIndexMarker625"/>be <strong class="source-inline">New York</strong>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using updateOne() to modify the address of “Clinton” (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.updateOne({ lastname : "Clinton" }, { address : "New York" }, function(err, response) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log("response =", response);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>Here, we use the callback function to display the content of the <strong class="source-inline">response</strong> parameter returned by the function. We get the following result:</p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/Figure_8.10_B17416.jpg" alt="Figure 8.10 – Updating a document&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Updating a document</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">response.modifiedCount</strong> field indicates the number of modified documents.</p>
			<p>If you do <a id="_idIndexMarker626"/>not want to perform any processing at the end of the<a id="_idIndexMarker627"/> update, you can omit the callback function, but in this case, you must use the <strong class="source-inline">then()</strong> or <strong class="source-inline">exec()</strong> method afterward, otherwise, the update will not take place.</p>
			<p>Let’s use the <strong class="source-inline">exec()</strong> method to perform the update:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Performing update using exec() method (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.updateOne({ lastname : "Clinton" }, </strong></pre>
			<pre class="source-code"><strong class="bold">                 { address : "New York" })</strong></pre>
			<pre class="source-code"><strong class="bold">.exec();    // exec() mandatory!</strong></pre>
			<p>Once you<a id="_idIndexMarker628"/> know how to create, search for, and then modify <a id="_idIndexMarker629"/>documents, you just have to know how to delete them. Let’s look at how to do it.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>Deleting documents in MongoDB</h1>
			<p>Similar <a id="_idIndexMarker630"/>to <strong class="source-inline">updateOne()</strong> and <strong class="source-inline">updateMany()</strong>, there are the <a id="_idIndexMarker631"/>two class methods, namely <strong class="source-inline">deleteOne(conditions, callback)</strong> and <strong class="source-inline">deleteMany(conditions, callback)</strong> that allow you to delete the first document (<strong class="source-inline">deleteOne()</strong>) or all the documents (<strong class="source-inline">deleteMany()</strong>) that satisfy the conditions expressed.</p>
			<p>In addition, the instance method <strong class="source-inline">doc.remove(callback)</strong> also makes it possible to delete the <strong class="source-inline">doc</strong> document when it is in memory.</p>
			<p>Let’s remove <strong class="source-inline">Clinton</strong> from the collection by using the <strong class="source-inline">deleteOne()</strong> method, then display the new contents of the collection:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using deleteOne() to delete client “Clinton” (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.deleteOne({ lastname : "Clinton" }, function(err, response) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log("After Clinton's removal");</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log("response = ", response);</strong></pre>
			<pre class="source-code"><strong class="bold">  Client.find(function(err, clients) {</strong></pre>
			<pre class="source-code"><strong class="bold">    console.log("clients = ", clients);</strong></pre>
			<pre class="source-code"><strong class="bold">  });</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>In the same <a id="_idIndexMarker632"/>way as for the <strong class="source-inline">updateOne()</strong> and <strong class="source-inline">updateMany()</strong> methods, it is the<a id="_idIndexMarker633"/> presence of the callback function that triggers the update of the database. If you do not indicate a callback function, you must in this case use the <strong class="source-inline">then()</strong> or <strong class="source-inline">exec()</strong> method following the <strong class="source-inline">deleteOne()</strong> or <strong class="source-inline">deleteMany()</strong> method.</p>
			<p>The result is displayed in the following figure:</p>
			<div>
				<div id="_idContainer153" class="IMG---Figure">
					<img src="image/Figure_8.11_B17416.jpg" alt="Figure 8.11 – Deleting the &quot;Clinton&quot; client with deleteOne()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – Deleting the “Clinton” client with deleteOne()</p>
			<p>The <strong class="source-inline">response</strong> object<a id="_idIndexMarker634"/> returned in the callback of the <strong class="source-inline">deleteOne()</strong> (or <strong class="source-inline">deleteMany()</strong>) method indicates the <strong class="source-inline">deletedCount</strong> field, which <a id="_idIndexMarker635"/>contains the number of documents deleted.</p>
			<p>We have successively studied the four possible operations on documents in a MongoDB database, namely inserting, searching, modifying, and deleting documents. And with this, we come to the end of this chapter.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Summary</h1>
			<p>Data management with MongoDB is relatively easy, thanks to the use of external modules such as mongoose. All possible actions on a database are easily achievable.</p>
			<p>The mongo utility, available when installing MongoDB, makes it easy to view collections and the documents they contain. </p>
			<p>Using the MongoDB database is essential for building client-server applications and maintaining user information.</p>
			<p>All that’s left is to see how to interconnect a client side made with Vue.js and a server side made with Node.js. We will see this in the following chapter. We will build a 100% JavaScript application in order to show how simple and efficient it is.</p>
		</div>
	</body></html>