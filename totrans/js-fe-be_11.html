<html><head></head><body>
		<div><h1 id="_idParaDest-151"><em class="italic"><a id="_idTextAnchor150"/>Chapter 8</em>: Using MongoDB with Node.js</h1>
			<p><strong class="bold">MongoDB</strong> is the<a id="_idIndexMarker567"/> database traditionally associated with Node.js. It is a NoSQL type database, which means that SQL will not be used to access the information it contains.</p>
			<p>MongoDB is a document-oriented database in which <a id="_idIndexMarker568"/>we store so-called <em class="italic">documents</em>; that is, a data structure of any type, such as information written on a sheet of paper (which is then equivalent to a document). Several sheets of paper, thus corresponding to several documents, form what<a id="_idIndexMarker569"/> is called a <em class="italic">collection</em>.</p>
			<p>An example of a document is, for example, the first name, the last name, and the address of a customer. Aggregated information from multiple customers would be called a collection.</p>
			<p>In this chapter, we’ll study how to use MongoDB in conjunction with Node.js in order to store, read, delete, or update information in the database.</p>
			<p>Inserting, searching, updating, or deleting data are the main actions that can be performed in a database. Therefore, in this chapter, we’ll see how to perform these operations with the MongoDB database.</p>
			<p>Here are the topics covered in this chapter:</p>
			<ul>
				<li>Installing MongoDB and the mongoose module</li>
				<li>Connecting to the MongoDB database</li>
				<li>Creating documents</li>
				<li>Searching documents</li>
				<li>Updating documents</li>
				<li>Deleting documents</li>
			</ul>
			<p>Let’s start by installing MongoDB and the <strong class="bold">mongoose</strong> module, which will allow MongoDB to be used in Node.js programs.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%208.zip">https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%208.zip</a>.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor152"/>Installing MongoDB </h1>
			<p>The<a id="_idIndexMarker570"/> MongoDB database is independent of Node.js, which requires installing it separately. To do <a id="_idIndexMarker571"/>this, go to the site <a href="https://www.mongodb.com/docs/manual/administration/install-community/">https://www.mongodb.com/docs/manual/administration/install-community/</a>. Download the version suitable for your system.</p>
			<p>Once MongoDB is installed, verify that the installation is correct by typing the <code>mongo -h</code> command in a command interpreter. The <code>mongo</code> command is located in the <code>Server/x.x/bin</code> directory of MongoDB, where <code>x.x</code> is the version number of MongoDB installed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">At the time of writing, the <code>mongo</code> utility<a id="_idIndexMarker572"/> is available directly when installing MongoDB. However, it is possible that this utility will soon be available separately and <a id="_idIndexMarker573"/>called <code>mongosh</code>. In this case, download this utility from <a href="https://www.mongodb.com/docs/mongodb-shell/install/">https://www.mongodb.com/docs/mongodb-shell/install/</a>.</p>
			<p class="callout">The <code>mongo</code> command will simply be replaced by the equivalent <code>mongosh</code> command. Both commands work identically.</p>
			<p>After<a id="_idIndexMarker574"/> installing MongoDB, we will look into the mongo (or mongosh) utility. The mongo utility makes it easy to see the contents of database collections, without having to write program lines. It is therefore useful for checking, for example, whether a document has been correctly inserted into a collection, or that its deletion has been successful. Let’s see how to use the mongo utility.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/>Using the mongo utility</h2>
			<p>The<a id="_idIndexMarker575"/> mongo utility enables you to easily view databases and the collections they contain. The mongo utility is launched by simply typing the <code>mongo</code> command in a command interpreter. The program then waits for database access commands, or the <code>exit</code> command to exit.</p>
			<p>Here is the list of the main commands available in the mongo utility:</p>
			<ul>
				<li><code>show dbs</code>: This <a id="_idIndexMarker576"/>shows a list of existing databases. A database will be visible here only if it contains at least one collection.</li>
				<li><code>db=connect("mydb_test")</code>: This is to connect to the database <code>mydb_test</code>. The <code>db</code> variable will then be used to access the database collections.</li>
				<li><code>show collections</code>: This shows the collections of the connected database. A collection will be present if it contains at least one document.</li>
				<li><code>db.clients.find()</code>: This shows all documents in the <code>clients</code> collection.</li>
				<li><code>db.clients.find({name:"Clinton"})</code>: This lists documents in the <code>clients</code> collection whose name is <code>Clinton</code>.</li>
				<li><code>db.clients.find().sort({name:1})</code>: This sorts documents in ascending order of the <code>name</code> field. Use <code>{name:-1}</code> for descending sort.</li>
				<li><code>db.clients.count()</code>: This counts the number of documents found in the <code>clients</code> collection.</li>
				<li><code>db.clients.renameCollection("clients2")</code>: This renames the <code>clients</code> collection to <code>clients2</code>.</li>
				<li><code>db.clients.drop()</code>: This drops the <code>clients</code> collection (all documents are dropped).</li>
				<li><code>db.dropDatabase()</code>: This <a id="_idIndexMarker577"/>drops the connected database (all collections are removed).</li>
			</ul>
			<p>Other commands exist, in particular, for inserting, updating, or deleting documents in a collection. But since these actions are performed through the mongoose module instead, we will describe them using the mongoose module.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/>Installing the mongoose module</h2>
			<p>To establish the <a id="_idIndexMarker578"/>relationship between MongoDB and Node.js, several npm modules have been created. The most widely used one currently is the <code>mongoose</code> module. It is installed in the <code>node_modules</code> directory of the current directory by typing the <code>npm install mongoose</code> command.</p>
			<div><div><img src="img/Figure_8.01_B17416.jpg" alt="Figure 8.1 – Installing the mongoose module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Installing the mongoose module</p>
			<p>Once mongoose has been downloaded by npm, we check whether it is accessible for our programs. Let’s display the mongoose version for our programs. We write this snippet in the file <code>test.js</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying mongoose version (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">console.log("mongoose version =", mongoose.version);</pre>
			<p>Let’s use the <code>node test.js</code> command to run the previous program:</p>
			<div><div><img src="img/Figure_8.02_B17416.jpg" alt="Figure 8.2 – Checking that mongoose is accessible&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Checking that mongoose is accessible</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">If you get an error loading the mongoose module, it’s probably because you installed it globally (with the <code>-g</code> option). In this case, just type the <code>npm link mongoose</code> command in the terminal to get rid of the error.</p>
			<p>The <a id="_idIndexMarker579"/>mongoose module will allow us to use the MongoDB database to create documents, search them, update them, or destroy them. These are the classic operations that can be performed on a database.</p>
			<p>But to be able to perform these operations, it is necessary to first connect to the database.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/>Connecting to the MongoDB database</h1>
			<p>All <a id="_idIndexMarker580"/>operations to access MongoDB require establishing a connection with it. Now let’s see how to establish a connection with MongoDB.</p>
			<p>The <code>mongoose.connect(url)</code> instruction connects the mongoose module to the database specified in the <code>url</code> parameter. The <code>url</code> parameter is of the form <code>"mongodb://localhost/mydb_test"</code> to connect to the <code>mydb_test</code> database on the localhost server.</p>
			<p>The database will actually be created (and visible with the execution of the <code>show dbs</code> command of the mongo utility) when the first document is inserted into it:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Connecting to the mydb_test database (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code"><strong class="bold">mongoose.connect("mongodb://localhost/mydb_test");</strong></pre>
			<pre class="source-code">console.log("Connecting to mydb_test database in progress...");</pre>
			<p>Let’s run the previous program:</p>
			<div><div><img src="img/Figure_8.03_B17416.jpg" alt="Figure 8.3 – Database connection&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Database connection</p>
			<p>To know <a id="_idIndexMarker581"/>whether the connection to the database has actually been made, mongoose sends the <code>open</code> event (if the connection was successful) or the <code>error</code> event (if the connection fails) on the <code>mongoose.connection</code> object.</p>
			<p>Next, we will take these two events into account and integrate them into the previous program. This is done using the <code>on(event, callback)</code> method defined on the <code>mongoose.connection</code> object:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>on(event, callback)</code> method is used to process the reception of the event and to associate it with the processing described in the callback function.</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using open and error events on database connection (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code"><strong class="bold">mongoose.connection.on("error", function() {</strong></pre>
			<pre class="source-code"><strong class="bold"> console.log("mydb_test database connection error")</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code"><strong class="bold">mongoose.connection.on("open", function() {</strong></pre>
			<pre class="source-code"><strong class="bold"> console.log("Successful connection to mydb_test </strong></pre>
			<pre class="source-code"><strong class="bold"> database");</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code">console.log("Connecting to mydb_test database in progress...");</pre>
			<p>Let’s run the<a id="_idIndexMarker582"/> previous program:</p>
			<div><div><img src="img/Figure_8.04_B17416.jpg" alt="Figure 8.4 – Successful connection to the database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Successful connection to the database</p>
			<p>We have seen how to connect to the database. We will therefore be able to create documents in a collection of the database.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor156"/>Creating documents in MongoDB</h1>
			<p>Once the <a id="_idIndexMarker583"/>database has<a id="_idIndexMarker584"/> been accessed, you can create documents in it.</p>
			<p>A<a id="_idIndexMarker585"/> document will be inserted into<a id="_idIndexMarker586"/> a <em class="italic">collection</em>. A collection will therefore group together a set of documents. The database will therefore be a set of collections, each containing documents.</p>
			<p>In order to be able to insert documents, mongoose asks us to describe the structure of these documents. For this, we will use schemas and models.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/>Describing document structure using schemas and models</h2>
			<p>To access the documents in the database, the documents must be described by means of schemas and models.</p>
			<p class="callout-heading">Definitions</p>
			<p class="callout">A <em class="italic">schema</em> allows you to <a id="_idIndexMarker587"/>define the structure of a document that is stored in a collection. The structure is defined according to MongoDB data types.</p>
			<p class="callout">A <em class="italic">model</em> is the<a id="_idIndexMarker588"/> representation of a schema as a JavaScript class. It links a schema to a MongoDB collection.</p>
			<p>Let’s look at how to create a schema and then a model.</p>
			<h3>Creating a schema</h3>
			<p>A schema defines the<a id="_idIndexMarker589"/> fields of a document using Node.js internal object classes. These are the following classes:</p>
			<ul>
				<li><code>String</code>: This defines a string of characters.</li>
				<li><code>Number</code>: This defines a numeric field.</li>
				<li><code>Boolean</code>: This defines a Boolean.</li>
				<li><code>Array</code>: This defines an array.</li>
				<li><code>Buffer</code>: This defines a buffer of bytes.</li>
				<li><code>Date</code>: This defines a date.</li>
				<li><code>Object</code>: This defines a JavaScript object.</li>
			</ul>
			<p>The <code>mongoose.Schema(format)</code> method is used to define the schema associated with the document. The <code>format</code> parameter is a JavaScript object that associates each field in the document with the type (in the above list) that represents it.</p>
			<p>Let’s create<a id="_idIndexMarker590"/> the schema defining a client. A client is characterized by its <code>lastname</code>, <code>firstname</code>, and <code>address</code>. All these fields are of type <code>String</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Defining the schema associated with a client (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code"><strong class="bold">var clientSchema = mongoose.Schema({</strong></pre>
			<pre class="source-code"><strong class="bold"> lastname : String,</strong></pre>
			<pre class="source-code"><strong class="bold"> firstname : String,</strong></pre>
			<pre class="source-code"><strong class="bold"> address : String</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>Now let’s explain how to create a model from the schema.</p>
			<h3>Creating a model</h3>
			<p>The<a id="_idIndexMarker591"/> schema is then used to define the model associated with the document. The model corresponds to a JavaScript class that will be used to create the documents in a collection.</p>
			<p>The <code>mongoose.model(collection, schema)</code> method returns a JavaScript class associated with the schema. This class is called a model.</p>
			<p>Documents created with this class will be inserted into the specified <code>collection</code>. The collection may not exist before inserting a document. A collection requires at least one document within it.</p>
			<p class="callout-heading">Summary</p>
			<p class="callout">A schema specifies the format of a document stored in a collection, while a model is a JavaScript class used to create each such document. We associate a document schema with a collection using the <code>mongoose.model(collection, schema)</code> method call. This returns a JavaScript class that can then be used to generate individual document instances.</p>
			<p>Let’s <a id="_idIndexMarker592"/>create the <code>Client</code> class, which will create the clients that will be stored in the <code>clients</code> collection. It is traditional to name the collection based on the name of the model, in lowercase and in plural:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Creating the Client model from the schema (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code"><strong class="bold">// creation of the Client class associated with the clients </strong></pre>
			<pre class="source-code"><strong class="bold">// collection</strong></pre>
			<pre class="source-code"><strong class="bold">var Client = mongoose.model("clients", clientSchema);</strong></pre>
			<p>The <code>Client</code> class is<a id="_idIndexMarker593"/> now available to create the documents that will be inserted into the <code>clients</code> collection.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/>Creating the document</h2>
			<p>There are two methods for creating<a id="_idIndexMarker594"/> the documents in a collection. These are the <code>doc.save(callback)</code> instance method and the <code>create(doc, callback)</code> class method. Let’s <a id="_idIndexMarker595"/>look at these two ways to create documents in a collection. </p>
			<p>Let’s start by using the <code>doc.save(callback)</code> instance method.</p>
			<h3>Using the doc.save(callback) instance method</h3>
			<p>The client document is<a id="_idIndexMarker596"/> created in memory from the previously created class (by means of <code>var client = new Client()</code>), then saved in the <code>clients</code> collection by means of the <code>client.save()</code> method.</p>
			<p>The callback function allows processing when the document has finished being inserted into the collection. This is especially useful if it is necessary to wait for the document to be inserted into the database before continuing processing:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the save() instance method to save document (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">// create the document in memory</strong></pre>
			<pre class="source-code"><strong class="bold">var c = new Client({lastname :"Clinton", firstname:"Bill", address:"Washington"});</strong></pre>
			<pre class="source-code"><strong class="bold">console.log("Before the save() statement");</strong></pre>
			<pre class="source-code"><strong class="bold">// save the document in the database (clients collection)</strong></pre>
			<pre class="source-code"><strong class="bold">c.save(function(err) {</strong></pre>
			<pre class="source-code"><strong class="bold">  if (!err) console.log("The client is inserted into the </strong></pre>
			<pre class="source-code"><strong class="bold">  collection");</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code"><strong class="bold">console.log("After the save() statement");</strong></pre>
			<p>The callback<a id="_idIndexMarker597"/> function takes the <code>err</code> parameter, which corresponds to a possible error message (otherwise, it is <code>null</code>).</p>
			<p>We get the following result:</p>
			<div><div><img src="img/Figure_8.05_B17416.jpg" alt="Figure 8.5 – Using the doc.save() instance method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.5 – Using the doc.save() instance method</p>
			<p>Using the traces displayed in the console, we can see that the message <code>The client is inserted into the collection</code> is displayed after the other messages, which means that inserting a document is not blocking other tasks (i.e., other tasks can be done while waiting for insertion in the database).</p>
			<p>The <code>save()</code> method can also be used as a <code>Promise</code> object (see <a href="B17416_02_ePub.xhtml#_idTextAnchor044"><em class="italic">Chapter 2</em></a>, <em class="italic">Exploring the Advanced Concepts of JavaScript</em>). For this, we use the <code>then(callback)</code> method afterward, possibly followed by the <code>catch(callback)</code> method to process the cases of error when calling the <code>save()</code> method.</p>
			<p>In this case, we write<a id="_idIndexMarker598"/> the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the save() method as a Promise objet</p>
			<pre class="source-code">c.save().then(function(doc) {</pre>
			<pre class="source-code">  console.log(doc);</pre>
			<pre class="source-code">  console.log("The client is inserted into the collection");</pre>
			<pre class="source-code">}).catch(function(err) {</pre>
			<pre class="source-code">  console.log(err);  // display the error</pre>
			<pre class="source-code">});</pre>
			<p>Now let’s see the other method of creating a document with the <code>create(doc, callback)</code> class method.</p>
			<h3>Using the create(doc, callback) class method</h3>
			<p>A class method means that we <a id="_idIndexMarker599"/>can use the method without having instantiated an object, unlike an instance method, which requires that the object of the class be created (with <code>c = new Client()</code>).</p>
			<p>To create the document associated with the client identified by <code>{lastname:"Obama", firstname:"Barack", address:"Washington"}</code>, we would write the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the Client.create(doc, callback) class method to save document (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code">console.log("Before the create() statement");</pre>
			<pre class="source-code">// save the document in the database (clients collection)</pre>
			<pre class="source-code"><strong class="bold">Client.create({lastname:"Obama", firstname:"Barack", address:"Washington"}, function(err, doc) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log("The client is inserted into the collection", </strong></pre>
			<pre class="source-code"><strong class="bold">  doc);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code">console.log("After the create() statement");</pre>
			<p>The <code>create(doc, callback)</code> class method is used by prefixing it with the name of the <a id="_idIndexMarker600"/>JavaScript class (here, the <code>Client</code> class).</p>
			<p>The document to be saved is written in the form of a JavaScript object (JSON format) but can also be an object instantiated with <code>c = new Client()</code>.</p>
			<p>The callback function of the form <code>callback(err, doc)</code> is executed at the end of saving the document in the database. This callback function is useful if you want to perform a process while being certain that the document has been saved in the collection.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that the callback function <code>callback(err, doc)</code> of the <code>create(doc, callback)</code> method has the two parameters <code>err</code> and <code>doc</code>, which are the possible error and the document saved in the database, respectively.</p>
			<p>Let’s run the <a id="_idIndexMarker601"/>previous program:</p>
			<div><div><img src="img/Figure_8.06_B17416.jpg" alt="Figure 8.6 – Using the Client.create() class method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.6 – Using the Client.create() class method</p>
			<p>The saved document has the fields indicated in the format associated with the model (here, the <code>lastname</code>, <code>firstname</code>, and <code>address</code> fields), but also the <code>_id</code> and <code>__v</code> fields, added automatically by MongoDB:</p>
			<ul>
				<li>The <code>_id</code> field is a field used by MongoDB to give a unique identifier to each document in a collection. It plays the role of a primary key.</li>
				<li>The <code>__v</code> field is a field added by mongoose, associated with the document version number. We will not use it here.</li>
			</ul>
			<p>As with the <code>save()</code> instance <a id="_idIndexMarker602"/>method, the <code>create(doc)</code> class method can be used as a <code>Promise</code> object. For this, we do not use the <code>callback</code> parameter in the <code>create(doc)</code> method and instead use the <code>then(callback)</code> and <code>catch(callback)</code> methods following the <code>create(doc)</code> method call.</p>
			<p>For example, we could also write the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using create() method as a Promise object</p>
			<pre class="source-code">Client.create({lastname:"Obama", firstname:"Barack", address:"Washington"}).then(function(doc) {</pre>
			<pre class="source-code">  console.log("The client is inserted into the collection", </pre>
			<pre class="source-code">  doc);</pre>
			<pre class="source-code">});</pre>
			<p>In the previous <a id="_idIndexMarker603"/>examples, we have inserted two documents into the <code>clients</code> collection. Let’s use the mongo utility to display the inserted documents and verify the documents that are present in the collection.</p>
			<h3>Using the mongo utility to view inserted documents</h3>
			<p>To display the <a id="_idIndexMarker604"/>inserted documents, use the <a id="_idIndexMarker605"/>mongo utility and type the following commands:</p>
			<ol>
				<li><code>db=connect("mydb_test")</code> to connect to the database</li>
				<li><code>show collections</code> to show the collections already present</li>
				<li><code>db.clients.find()</code> to display documents from the <code>clients</code> collection</li>
			</ol>
			<div><div><img src="img/Figure_8.07_B17416.jpg" alt="Figure 8.7 – Using the mongo utility to view documents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Using the mongo utility to view documents</p>
			<p>We thus <a id="_idIndexMarker606"/>check that the two documents of the <code>clients</code> collection<a id="_idIndexMarker607"/> are indeed present.</p>
			<p>Let’s see how to search for them with mongoose module methods.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor159"/>Searching for documents in MongoDB</h1>
			<p>Once the <a id="_idIndexMarker608"/>documents have been inserted into the collection, they <a id="_idIndexMarker609"/>can be searched for using the <code>find()</code> class method.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>find()</code> method is a class method, which means that it is used by prefixing it with the class name associated with the model, for example, <code>Client.find()</code>.</p>
			<p>The <code>find(conditions, callback)</code> method is used to perform a search in the collection associated with the model, then to retrieve the results of the search in the callback function indicated as a parameter.</p>
			<p>Let’s take an in-depth look at the parameters:</p>
			<ul>
				<li>The <code>conditions</code> parameter is a JavaScript object used to specify search conditions. If no condition is specified, do not indicate anything (or indicate an empty object <code>{}</code>).</li>
				<li>The callback function is of the form <code>callback(err, results)</code> where <code>err</code> is an error message (<code>null</code> otherwise) and <code>results</code> is an array containing the search results (empty <code>[]</code> if none).</li>
			</ul>
			<p>There is also the <code>findOne(conditions, callback)</code> class method, which allows you, on the same principle, to find only the first document that satisfies the search. The callback function is of the form <code>callback(err, result)</code> where <code>result</code> is the first document found.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>findOne(conditions, callback)</code> method will be useful if you are looking for a single document, for example, from its identifier <code>_id</code>.</p>
			<p>You can also<a id="_idIndexMarker610"/> use the <code>find(conditions)</code> and <code>findOne(conditions)</code> methods <a id="_idIndexMarker611"/>without specifying the callback function as a parameter. For this, we use the <code>then(callback)</code> and <code>catch(callback)</code> methods to perform the processing on the documents found or in the event of an error. We can also use the <code>exec(callback)</code> method, as explained in the following section.</p>
			<p>Let us now examine how to write the <code>conditions</code> parameter used in the two methods <code>find()</code> and <code>findOne()</code>.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/>Writing search conditions</h2>
			<p>In the <code>conditions</code> parameter, we <a id="_idIndexMarker612"/>indicate an object whose properties are the fields of the documents in the collection, and the associated values are the values sought for the field, of the form <code>{field1:value1, field2:value2...}</code>, for example, <code>{lastname:"Clinton", firstname:"Bill"}</code>.</p>
			<p>Other properties can be used as keywords to express conditions. They start with the <code>$</code> sign, such as: <code>$or</code>, <code>$exists</code>, <code>$type</code>, <code>$where</code>, <code>$gt</code>, and <code>$lt</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A list of possible <a id="_idIndexMarker613"/>keywords can be found here: <a href="https://docs.mongodb.com/manual/reference/operator/query/">https://docs.mongodb.com/manual/reference/operator/query/</a>.</p>
			<p>Here are some <a id="_idIndexMarker614"/>examples of conditions:</p>
			<ul>
				<li><code>{ }</code>: All documents in the collection. You can also write <code>find()</code>, which is equivalent to <code>find({})</code>.</li>
				<li><code>{ lastname: "Clinton" }</code>: All documents whose lastname is <code>Clinton</code>.</li>
				<li><code>{ lastname: "Clinton", firstname: "Bill" }</code>: All documents whose lastname is <code>Clinton</code> and first name is <code>Bill</code>.</li>
				<li><code>{ $or: [{ lastname: "Clinton"}, { firstname: "Jimmy" }] }</code>: All documents whose lastname is <code>Clinton</code> or first name is <code>Jimmy</code>.</li>
				<li><code>{ lastname: /obama/i }</code>: All documents whose lastname contains the string <code>obama</code> regardless of case (regular expression).</li>
				<li><code>{ address: { $exists: true} }</code>: All documents whose <code>address</code> field exists, regardless of its type (String, Object, etc.).</li>
				<li><code>{ address: { $exists: true, $type: 2 } }</code>: All documents whose <code>address</code> field exists, and which is of type <code>2</code> (String).</li>
				<li><code>{"address.city": "Washington" }</code>: All documents containing the <code>address</code> field that itself has a city field whose value is <code>Washington</code>.</li>
				<li><code>{lastname:{$type:2},   $where:"this.lastname.match(/^Clinton|carter$/i)"}</code>: All documents whose lastname is a string (type = <code>2</code>) and whose lastname begins with <code>Clinton</code> or ends with <code>carter</code>, regardless of case. You must indicate that the lastname is a character string, otherwise you may have an error with names that are not in this form.</li>
				<li><code>{lastname: { $gt: "J", $lt: "S" }}</code>: All documents whose lastname is greater than <code>"J"</code> and less than <code>"S"</code>.</li>
				<li><code>{lastname: { $in:["Clinton", "Carter", "Obama"] }}</code> : All documents<a id="_idIndexMarker615"/> whose lastname is <code>Clinton</code>,  <code>Carter</code>,  or <code>Obama</code>.</li>
			</ul>
			<p>Once the search conditions have been expressed, the results found must be retrieved and displayed. Let’s see how to do it.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor161"/>Retrieving and displaying the results</h2>
			<p>Whatever the condition expressed, the corresponding results can be retrieved in the callback function associated with the <code>find()</code> method, of the form <code>callback(err, results)</code>. We will also see that it is possible to use the <code>exec(callback)</code> method to retrieve the results.</p>
			<p>Let’s look at these two ways to retrieve search results.</p>
			<h3>Using the callback parameter of the find(conditions, callback) method</h3>
			<p>Let’s find all <a id="_idIndexMarker616"/>clients whose lastname is <code>Clinton</code> or firstname is <code>Barack</code>. The result will be displayed in the callback function:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying clients whose lastname is “Clinton” or firstname is “Barack” (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.find({ $or : [ { lastname : "Clinton" }, { firstname : "Barack"} ] }, function(err, clients) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log(clients);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>We obtain the <a id="_idIndexMarker617"/>result shown in the following figure:</p>
			<div><div><img src="img/Figure_8.08_B17416.jpg" alt="Figure 8.8 – Displaying search results with find(conditions, callback)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Displaying search results with find(conditions, callback)</p>
			<p>The callback<a id="_idIndexMarker618"/> function can be expressed in the <code>find()</code> method as before, or be specified in the <code>exec()</code> method used after the <code>find()</code> method. Let us now examine this second possibility.</p>
			<h3>Using the exec(callback) method</h3>
			<p>Another way to<a id="_idIndexMarker619"/> retrieve results is to use the <code>exec(callback)</code> method following the <code>find(conditions)</code> method. The <code>find(conditions)</code> method is used here without indicating a callback function in its parameters because the callback function is indicated in the <code>exec(callback)</code> method.</p>
			<p>The advantage of this is that we can insert new methods between the <code>find()</code> method and the <code>exec()</code> method. For example, if we want to add as additional conditions that the <code>lastname</code> field must be equal to <code>Clinton</code>, we can write the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Adding as search conditions that lastname is “Clinton” (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.find({ $or : [ { lastname : "Clinton" }, { firstname : "Barack"} ] })</strong></pre>
			<pre class="source-code"><strong class="bold">.where("lastname")</strong></pre>
			<pre class="source-code"><strong class="bold">.eq("Clinton")</strong></pre>
			<pre class="source-code"><strong class="bold">.exec(function(err, clients) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log(clients);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Methods such as <code>where(field)</code> and <code>eq(value)</code> can be chained after the <code>find()</code> method. The execution <a id="_idIndexMarker620"/>of the search will be effective when calling the <code>exec()</code> method. Other usage possibilities are described here: <a href="https://mongoosejs.com/docs/api/query.html#query_Query-where">https://mongoosejs.com/docs/api/query.html#query_Query-where</a>.</p>
			<p>You can also<a id="_idIndexMarker621"/> use the <code>exec(callback)</code> method without specifying the callback function as a parameter. For this, we use the <code>then(callback)</code> and <code>catch(callback)</code> methods to perform the processing on the documents found or in the event of an error.</p>
			<p>We write the following for this:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using exec() method as a Promise object</p>
			<pre class="source-code">Client.find({ $or : [ { lastname : "Clinton" }, { firstname : "Barack"} ] })</pre>
			<pre class="source-code">.where("lastname")</pre>
			<pre class="source-code">.eq("Clinton")</pre>
			<pre class="source-code">.exec()</pre>
			<pre class="source-code">.then(function(clients) {</pre>
			<pre class="source-code">  console.log(clients);  // display the clients</pre>
			<pre class="source-code">})</pre>
			<pre class="source-code">.catch(function(err) {</pre>
			<pre class="source-code">  console.log(err);  // display the error</pre>
			<pre class="source-code">});</pre>
			<p>The result is displayed in the following figure.</p>
			<div><div><img src="img/Figure_8.09_B17416.jpg" alt="Figure 8.9 – Using the exec(callback) method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.9 – Using the exec(callback) method</p>
			<p>We’ve learned how to create documents, then search for them. Now let’s look at how to update them.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/>Updating documents in MongoDB</h1>
			<p>It is possible to <a id="_idIndexMarker622"/>modify one or more documents of a<a id="_idIndexMarker623"/> collection. The <code>updateOne()</code> and <code>updateMany()</code> class methods are used respectively to modify the first document found or all of the documents found.</p>
			<p>These two methods have similar parameters:</p>
			<ul>
				<li><code>updateMany(conditions, update, callback)</code> indicates modifying the data indicated in the <code>update</code> object on the documents specified by the indicated <code>conditions</code>. The callback function of the form <code>callback(err, response)</code> is called after the update.</li>
				<li><code>updateOne(conditions, update, callback)</code> indicates modifying the data indicated in the <code>update</code> object on the first document found by the indicated <code>conditions</code>. The callback function of the form <code>callback(err, response)</code> is called after the update.</li>
				<li>Only the <code>conditions</code> and <code>update</code> parameters are mandatory in the two methods.<p class="callout-heading">Warning</p><p class="callout">If the callback is not present in the method, you must use the <code>then()</code> or <code>exec()</code> method afterward, otherwise the update is not done.</p></li>
			</ul>
			<p>Let’s modify the<a id="_idIndexMarker624"/> address of <code>Clinton</code>, which will now <a id="_idIndexMarker625"/>be <code>New York</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using updateOne() to modify the address of “Clinton” (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.updateOne({ lastname : "Clinton" }, { address : "New York" }, function(err, response) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log("response =", response);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>Here, we use the callback function to display the content of the <code>response</code> parameter returned by the function. We get the following result:</p>
			<div><div><img src="img/Figure_8.10_B17416.jpg" alt="Figure 8.10 – Updating a document&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.10 – Updating a document</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>response.modifiedCount</code> field indicates the number of modified documents.</p>
			<p>If you do <a id="_idIndexMarker626"/>not want to perform any processing at the end of the<a id="_idIndexMarker627"/> update, you can omit the callback function, but in this case, you must use the <code>then()</code> or <code>exec()</code> method afterward, otherwise, the update will not take place.</p>
			<p>Let’s use the <code>exec()</code> method to perform the update:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Performing update using exec() method (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.updateOne({ lastname : "Clinton" }, </strong></pre>
			<pre class="source-code"><strong class="bold">                 { address : "New York" })</strong></pre>
			<pre class="source-code"><strong class="bold">.exec();    // exec() mandatory!</strong></pre>
			<p>Once you<a id="_idIndexMarker628"/> know how to create, search for, and then modify <a id="_idIndexMarker629"/>documents, you just have to know how to delete them. Let’s look at how to do it.</p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor163"/>Deleting documents in MongoDB</h1>
			<p>Similar <a id="_idIndexMarker630"/>to <code>updateOne()</code> and <code>updateMany()</code>, there are the <a id="_idIndexMarker631"/>two class methods, namely <code>deleteOne(conditions, callback)</code> and <code>deleteMany(conditions, callback)</code> that allow you to delete the first document (<code>deleteOne()</code>) or all the documents (<code>deleteMany()</code>) that satisfy the conditions expressed.</p>
			<p>In addition, the instance method <code>doc.remove(callback)</code> also makes it possible to delete the <code>doc</code> document when it is in memory.</p>
			<p>Let’s remove <code>Clinton</code> from the collection by using the <code>deleteOne()</code> method, then display the new contents of the collection:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using deleteOne() to delete client “Clinton” (test.js file)</p>
			<pre class="source-code">var mongoose = require("mongoose");</pre>
			<pre class="source-code">mongoose.connect("mongodb://localhost/mydb_test");</pre>
			<pre class="source-code">var clientSchema = mongoose.Schema({</pre>
			<pre class="source-code"> lastname : String,</pre>
			<pre class="source-code"> firstname : String,</pre>
			<pre class="source-code"> address : String</pre>
			<pre class="source-code">});</pre>
			<pre class="source-code">// creation of the Client class associated with the clients </pre>
			<pre class="source-code">// collection</pre>
			<pre class="source-code">var Client = mongoose.model("clients", clientSchema);</pre>
			<pre class="source-code"><strong class="bold">Client.deleteOne({ lastname : "Clinton" }, function(err, response) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log("After Clinton's removal");</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log("response = ", response);</strong></pre>
			<pre class="source-code"><strong class="bold">  Client.find(function(err, clients) {</strong></pre>
			<pre class="source-code"><strong class="bold">    console.log("clients = ", clients);</strong></pre>
			<pre class="source-code"><strong class="bold">  });</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<p>In the same <a id="_idIndexMarker632"/>way as for the <code>updateOne()</code> and <code>updateMany()</code> methods, it is the<a id="_idIndexMarker633"/> presence of the callback function that triggers the update of the database. If you do not indicate a callback function, you must in this case use the <code>then()</code> or <code>exec()</code> method following the <code>deleteOne()</code> or <code>deleteMany()</code> method.</p>
			<p>The result is displayed in the following figure:</p>
			<div><div><img src="img/Figure_8.11_B17416.jpg" alt="Figure 8.11 – Deleting the &quot;Clinton&quot; client with deleteOne()&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.11 – Deleting the “Clinton” client with deleteOne()</p>
			<p>The <code>response</code> object<a id="_idIndexMarker634"/> returned in the callback of the <code>deleteOne()</code> (or <code>deleteMany()</code>) method indicates the <code>deletedCount</code> field, which <a id="_idIndexMarker635"/>contains the number of documents deleted.</p>
			<p>We have successively studied the four possible operations on documents in a MongoDB database, namely inserting, searching, modifying, and deleting documents. And with this, we come to the end of this chapter.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/>Summary</h1>
			<p>Data management with MongoDB is relatively easy, thanks to the use of external modules such as mongoose. All possible actions on a database are easily achievable.</p>
			<p>The mongo utility, available when installing MongoDB, makes it easy to view collections and the documents they contain. </p>
			<p>Using the MongoDB database is essential for building client-server applications and maintaining user information.</p>
			<p>All that’s left is to see how to interconnect a client side made with Vue.js and a server side made with Node.js. We will see this in the following chapter. We will build a 100% JavaScript application in order to show how simple and efficient it is.</p>
		</div>
	</body></html>