- en: The Age of Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decades ago, more specifically in 1974, Intel introduced 8080 to the world,
    which is an 8-bit processor with a 2 MHz clock speed and 64 KB of memory. This
    processor was used in Altair and began the revolution in personal computers.
  prefs: []
  type: TYPE_NORMAL
- en: It was sold pre-assembled or as a kit for hobbyists. It was the first computer
    to have enough power to actually be used for calculations. Even though it had
    some poor design choices and needed an engineering major to be able to use and
    program it, it started the spread of personal computers to the general public.
  prefs: []
  type: TYPE_NORMAL
- en: The technology evolved rapidly and the processor industry followed Moore's law,
    almost doubling speed every two years. Processors were still single core, with
    a low-efficiency ratio (power consumption per clock cycle). Because of this, servers
    usually did one specific job, called a service, like serving HTTP pages or managing
    a **Lightweight Directory Access Protocol** (**LDAP**) directory. Services were
    the monolith, with very few components, and were compiled altogether to be able
    to take the most out of the hardware processor and memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the 90s, the internet was still only available for the few. Hypertext, based
    on HTML and HTTP, was in its infancy. Documents were simple and browsers developed
    language and protocol as they pleased. Competition for market share was ferocious
    between Internet Explorer and Netscape. The latter introduced JavaScript, which
    Microsoft copied as JScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e38df4a8-338d-4077-b40f-ec079f5ad490.png)'
  prefs: []
  type: TYPE_IMG
- en: Simple single-core servers
  prefs: []
  type: TYPE_NORMAL
- en: After the turn of the century, processor speed continued to increase, memory
    grew to generous sizes, and 32-bit became insufficient for allocating memory addresses.
    The all-new 64-bit architecture appeared and personal computer processors hit
    the 100 W consumption mark. Servers gained muscle and were able to handle different
    services. Developers still avoided breaking the service into parts. Interprocess
    communication was considered slow and services were kept in threads, inside a
    single process.
  prefs: []
  type: TYPE_NORMAL
- en: The internet was starting to become largely available. Telcos started offering
    triple play, which included the internet bundled with television and phone services.
    Cellphones became part of the revolution and the age of the smartphone began.
  prefs: []
  type: TYPE_NORMAL
- en: JSON appeared as a subset of the JavaScript language, although it's considered
    a language-independent data format. Some web services began to support the format.
  prefs: []
  type: TYPE_NORMAL
- en: The following is an example of servers with a couple of services running, but
    still having only one processor.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dd8fac4c-1cd8-47af-9711-192faa7cdedf.png)'
  prefs: []
  type: TYPE_IMG
- en: Powerful but single-core servers
  prefs: []
  type: TYPE_NORMAL
- en: Processor evolution then shifted. Instead of the increased speed that we were
    used to, processors started to appear with two cores, and then four cores. Eight
    cores followed, and it seemed the evolution of the computer would follow this
    path for some time.
  prefs: []
  type: TYPE_NORMAL
- en: This also meant a shift in architecture in the development paradigms. Relying
    on the system to take advantage of all processors is unwise. Services started
    to take advantage of this new layout and now it's common to see services having
    at least one processor per core. Just look at any web server or proxy, such as
    Apache or Nginx.
  prefs: []
  type: TYPE_NORMAL
- en: The internet is now widely available. Mobile access to the internet and its
    information corresponds to more or less half of all internet access.
  prefs: []
  type: TYPE_NORMAL
- en: In 2012, the **Internet Engineering Task Force** (**IETF**) began its first
    drafts for the second version of HTTP or HTTP/2, and **World Wide Web Consortium**
    (**W3C**) did the same for HTML/HTML5, as both standards were old and needed a
    remake. Thankfully, browsers agreed on merging new features and specifications
    and developers no longer have the burden of developing and testing their ideas
    on the different browser edge cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of servers with more services running as we reach
    a point where each server has more than one processor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d535ce61-66e6-4f4c-865e-af2ef9e9725b.png)'
  prefs: []
  type: TYPE_IMG
- en: Powerful multi-core servers
  prefs: []
  type: TYPE_NORMAL
- en: Access to information in real time is a growing demand. The **Internet of Things**
    (**IoT**) multiplies the number of devices connected to the internet. People now
    have a couple of devices at home, and the number will just keep rising. Applications
    need to be able to handle this growth.
  prefs: []
  type: TYPE_NORMAL
- en: On the internet, HTTP is the standard protocol for communication. Routers usually
    do not block it, as it is considered a low traffic protocol (in contrast with
    video streams). This is actually not true nowadays, but it's now so widely used
    that changing this behavior would probably cause trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, it's actually so common to have the HTTP serving developer API working
    with JSON that most programming languages that release any version after 2015
    probably support this data format natively.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence of processor evolution, and because of the data-demanding internet
    we now have, it's important to not only be able to scale a service or application
    to the several available cores, but also to scale outside a single hardware machine.
  prefs: []
  type: TYPE_NORMAL
- en: Many developers started using and following the **Service-Oriented Architecture** (**SOA**)
    principle. It's a principle where the architecture is focused on services, and
    each service presents itself to others as an application component and provides
    information to other application components, passing messages over some standard
    communication protocol.
  prefs: []
  type: TYPE_NORMAL
- en: From monolith to microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we described previously, a microservices architecture is based on a loosely
    coupled set of services that work together to achieve a specific target application.
    At the end of the spectrum, there are monolith applications.
  prefs: []
  type: TYPE_NORMAL
- en: A monolith application is composed of a set of components that are tightly coupled.
    These components are usually developed using the same language and the application
    runs as a whole. The first noticeable difference is probably the slow start. Deploying
    might also be slow since you might need a couple of dependencies before having
    anything up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine an event application, a simple one, an application that lets users
    define events and be notified when those events are about to start.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/893a307a-7fcd-4a7d-9639-5341fbfe5906.png)'
  prefs: []
  type: TYPE_IMG
- en: A monolith event application
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s describe what the event application does:'
  prefs: []
  type: TYPE_NORMAL
- en: It allows users to register themselves and add events to a calendar
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few minutes before the event starts (that's what the **Scheduler** component
    is for), the users receive an email with the event information (that's the **SMTP**
    component)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users can use the frontend interface or the **API** interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imagine the preceding application as being a monolith (the greyed out area on
    the right).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that all four parts are part of the same process, even though they could
    be in separate threads. Imagine that the database is accessed directly across
    the application. Sound good?
  prefs: []
  type: TYPE_NORMAL
- en: Well, it sounds terrible, perhaps not for a small application, but for a medium
    one, this would be a representation of chaos. Having a group of developers making
    new features or improvements would be a nightmare, and for new developers entering
    the group, it would take some time before having the base knowledge to make some
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: The first principle that you should follow is the **Don't Repeat Yourself**
    (**DRY**) principle. Avoiding multiple components from accessing a data source
    helps developers in the future. Later on, if there's a need to change the data
    source or part of its structure, it will be easier if only one component manipulates
    it. This is not always possible, but if it is possible, you should keep the data
    source access to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the API should probably have access, and all others should use
    the API.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/debed603-fdb0-4f0b-9c31-5fea32261ec8.png)'
  prefs: []
  type: TYPE_IMG
- en: A single service accessing a data source
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have two services:'
  prefs: []
  type: TYPE_NORMAL
- en: The API, which is the only service accessing the data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The frontend, which is the user's interface to change the data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the frontend is used to manage events, it uses the API service to manipulate
    data sources. Besides having only one service managing data sources, it forces
    you to think of the API for external developers. It's a win-win.
  prefs: []
  type: TYPE_NORMAL
- en: There is still room for improvement. The **Frontend** could be in a separate
    service, allowing you to scale the interface according to user traffic, and have
    the other parts on separate services. **Scheduler** and **SMTP** are both candidates
    for separate services. **SMTP** should be thought of as a reusable service for
    other applications you might develop later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how we could build the same application using the microservices
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/034310f1-1917-4a3e-aa4e-0fba06ef39ea.png)'
  prefs: []
  type: TYPE_IMG
- en: A microservices event application
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks more complex. Well, the architecture is more complex. The difference
    is that now, we have loosely coupled components, and each one of them is easily
    understandable and maintainable. Summing up the changes and advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: The **API** is the only one accessing the database so it can change from SQLite,
    MongoDB, MySQL, or anything else, and no other component is affected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SMTP** can be used from the **Frontend** and **Scheduler**, and if you decide
    to change it from using a local service to using a third-party email sending **API**,
    you can make the change easily'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SMTP** is a candidate for being a reusable service in other applications,
    meaning you can use it in other applications or event share the same service between
    multiple applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can think of these components as capabilities of your application. They
    can be swapped, upgraded, maintained, and scaled, all without affecting other
    components or your application.
  prefs: []
  type: TYPE_NORMAL
- en: A commonly underestimated advantage of using this approach is that your application
    is much more resilient to failures. In a monolith application, any part can bring
    your application offline. In this microservices approach, this application might
    not send emails but can still be running and accessible. Add caching into the
    mixture and the API can restart in moments.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns of microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservices architecture, like other archicectures, has a set of patterns
    that are easily identifiable and form the basis for this application development
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these patterns can make the initial bootstrap a burden and can eventually
    be postponed. Others are essential from the beginning or you will have difficulty,
    later on, in migrating to a full microservice approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following patterns are not an extensive list but they represent a solid
    foundation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c78fda11-0afc-49b7-a839-6acb6be49f58.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of services working together to form an application
  prefs: []
  type: TYPE_NORMAL
- en: Decomposable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main pattern behind a microservice architecture is the ability to have loosely
    coupled services. These services are decomposed, separated into smaller parts.
    This decomposition should create a set of services that implement a set of strongly
    related functions.
  prefs: []
  type: TYPE_NORMAL
- en: Each service should be small but complete, meaning it should run a set of functions
    in a given context. Those functions should represent all the functions you need
    or need to support for that context. What this means is that if you have a service
    that handles meeting events, all meeting event functions should be done using
    that service, whether it's creating an event, changing, removing, or getting information
    about a specific event. This ensures that an implementation change to events will
    affect that service only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Decomposing an application can take one of two main approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: By capability, when a service has a specific power or set of powers, such as
    sending emails, regardless of its content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By subdomain, when a service has the complete knowledge of a subdomain or module
    of your application domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our previous event application, a service that was decomposed by capability
    is, for example, the SMTP service. A service decomposed by the domain could be
    the API service, assuming the application only manages events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/39cd716e-fc18-4160-bc96-9d49f3e99af8.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of services being tested and deployed autonomously, instead of the
    whole application
  prefs: []
  type: TYPE_NORMAL
- en: Autonomous
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a microservice architecture, each service should be autonomous. A small team
    should be able to run it without the other services that make your application.
    That team should also be able to develop autonomously and make changes to implementation
    without affecting the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The development team should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Test, creating business logic and unit tests to ensure the service functions
    work as expected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy, upgrading functionality, without restarting other services in the process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Services should be able to evolve regardless of others, keeping backward compatibility,
    adding new functions, and scaling to several locations, with minimal changes to
    the architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dff5ae6-966b-4dbb-be33-8df99b86f0bb.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of an application with two instances per service, making it fault-tolerant
  prefs: []
  type: TYPE_NORMAL
- en: Scalable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A service should be scalable. At least two instances should be able to run in
    parallel, enabling failure tolerance and maintenance downtime. A service can also,
    later on, scale geographically, be near your customers, and improve apparent performance
    and application response.
  prefs: []
  type: TYPE_NORMAL
- en: For this scaling to be effective, the application platform will need service
    discovery and routing, a service that could be used by other services to register
    themselves and expose their capabilities. Other services could, later on, inquire
    this service directory and know how to reach these capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce complexity for other services, a service router can redirect requests
    to service instances. For example, to send emails, you could have three instances
    and one central router that would redirect requests in a round-robin manner. If
    any of those instances go offline, the router will stop redirecting to it and
    the rest of the application doesn't need to care about it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach could be to use a DNS approach. The name service is capable
    of handling registrations to a subdomain, and then, when another service makes
    simple requests, it will receive one or all of the addresses and connect it as
    if there was only one service operating:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1fac72a0-5c63-4460-b7c0-70e529a6afc7.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of communication between services of an application
  prefs: []
  type: TYPE_NORMAL
- en: Communicable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, services communicate over HTTP using a REST-compliant API. This is
    not a pattern that you must follow, but it's something that comes naturally based
    on how common HTTP is nowadays, making it an obvious choice.
  prefs: []
  type: TYPE_NORMAL
- en: There are plenty of HTTP servers out there, making it easy to expose a non-HTTP
    service with minimum effort.
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP is also a mature communication transport layer. It''s a stateless protocol,
    giving developers and operations many features, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Caching commonly used and often updated resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxying and routing requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing communication over TLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/3a5de26d-a878-480b-b568-3011eb16e22d.png)'
  prefs: []
  type: TYPE_IMG
- en: A complex application with several services and streams of communication
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In conclusion, microservices architecture is a good, clear pattern that helps
    tackle more complex projects. In the long term, it reduces the complexity associated
    with new projects by appealing to service reuse. It helps to structure an application
    into loosely coupled services that can be independently developed and tested by
    small, different teams. It comes at the cost of initial proper planning and a
    more complex deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Before creating your first microservice, let's look at some Node.js tools that
    could eventually help you leverage your next big project. This is what we'll be
    covering in the next chapter.
  prefs: []
  type: TYPE_NORMAL
