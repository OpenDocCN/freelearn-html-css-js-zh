<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Your First Bot</h1></div></div></div><p>Readers will be amazed at how few lines of code are required to get a basic bot up and running in their Slack environment. This chapter will walk the reader through the basics of building a Slack bot:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Preparing your environment</li><li class="listitem" style="list-style-type: disc">Creating a Slack API token</li><li class="listitem" style="list-style-type: disc">Connecting your bot</li><li class="listitem" style="list-style-type: disc">Joining a channel</li><li class="listitem" style="list-style-type: disc">Sending a message to a channel</li><li class="listitem" style="list-style-type: disc">Basic responses</li><li class="listitem" style="list-style-type: disc">Sending a direct message</li><li class="listitem" style="list-style-type: disc">Restricting access</li><li class="listitem" style="list-style-type: disc">Debugging your bot</li></ul></div><p>Although some of the concepts first outlined will be known to a more advanced reader, it is still recommended to read through the first few sections of this chapter to ensure that your environment is up and ready to go.</p><p>In this chapter, we will build a bot that performs the following actions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connects to your Slack team</li><li class="listitem" style="list-style-type: disc">Says hello to all the members of a channel after successfully connecting, distinguishing between real users and bot users</li><li class="listitem" style="list-style-type: disc">Responds to users saying hello</li><li class="listitem" style="list-style-type: disc">Sends a direct message to users who ask for the total amount of time the bot has been running (also known as uptime)</li><li class="listitem" style="list-style-type: disc">Ensures that only administrative users can request the bot's uptime</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Preparing your environment</h1></div></div></div><p>Before we can get <a class="indexterm" id="id10"/>started with the first bot, the programming environment must be set up and configured to run Node.js applications and packages. Let's start at the very beginning with Node.</p><p>In brief, Node.js (also <a class="indexterm" id="id11"/>referred to as Node) is a JavaScript runtime built on Chrome's v8 JavaScript Engine. In practice, this means that JavaScript can be run outside of the usual browser environment, making JavaScript both a frontend and backend language.</p><p>Google Chrome's v8 JavaScript engine ensures that your JavaScript code runs fast and efficiently. Unlike in the world of browsers (and excepting Node versions), Node is maintained by a single open source foundation with hundreds of volunteer developers. This makes developing for Node much simpler than for browsers as you will not run into problems with varying JavaScript implementations across platforms.</p><p>In this book, we will be using major Version 5 (any version starting with 5) of Node. This allows us to use the newly <a class="indexterm" id="id12"/>implemented features of ECMAScript 2015 (better known as <strong>ES2015</strong> or <strong>ES6</strong>). Whenever an ES6 feature is used in this book for the first time, look for the accompanying <a class="indexterm" id="id13"/>code comment for a brief explanation on the feature.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Although many are implemented, not all ES6 features are currently available in Node and some are only <a class="indexterm" id="id14"/>available in <strong>strict</strong> mode. For more information, please visit the Node ES6 guide: <a class="ulink" href="https://nodejs.org/en/docs/es6/">https://nodejs.org/en/docs/es6/</a>.</p></div></div><p>This section will briefly explain how to install Node.js and the Slack API on your development machine.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec06"/>Installing Node.js</h2></div></div></div><p>To install Node.js, head <a class="indexterm" id="id15"/>to the official Node website, <a class="ulink" href="https://nodejs.org/">https://nodejs.org/</a>, download a v5 version and follow the onscreen instructions.</p><p>To test whether the <a class="indexterm" id="id16"/>installation succeeded, open up a terminal, type the following, and then hit <em>Enter</em>:</p><div><pre class="programlisting">
<strong>node</strong>
</pre></div><p>If node installed correctly, you should be able to type JavaScript commands and see the result:</p><div><img alt="Installing Node.js" src="img/B05384_02_01.jpg"/><div><p>Hello World in Node.js</p></div></div><div><div><h3 class="title"><a id="note04"/>Note</h3><p>Hit <em>Ctrl</em> + <em>C</em> <a class="indexterm" id="id17"/>twice to exit Node.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>Installing the development tools using NPM</h2></div></div></div><p>
<strong>Node Package Manager</strong> (<strong>NPM</strong>) is Node.js' package ecosystem and the tool used to install <a class="indexterm" id="id18"/>Node packages. As of the <a class="indexterm" id="id19"/>time of writing, there are more than 240,000 NPM packages available for download, with more being added every day.</p><p>Fortunately, NPM is automatically installed once the Node installation is complete. Let's start by installing a useful <a class="indexterm" id="id20"/>Node development tool called <code class="literal">nodemon</code> (<a class="ulink" href="http://nodemon.io/">http://nodemon.io/</a>). Run the following in your terminal or command prompt:</p><div><pre class="programlisting">
<strong>npm install -g nodemon</strong>
</pre></div><p>This command will install the <code class="literal">nodemon</code> package globally (note the <code class="literal">-g</code> flag), meaning it can be run from any location on your computer. After the <code class="literal">install</code> command, you must specify the package you wish to install and can optionally select some flags that configure how the package is installed. Later on, we'll explore flags such as <code class="literal">--save</code> and <code class="literal">--save-dev</code> and their uses.</p><p>
<code class="literal">nodemon</code> is a Node utility that will monitor any changes in your code and automatically restart your Node process. For our purposes, this will save us from having to stop the Node process and restart it every time we make a change to our code.</p><p>To <a class="indexterm" id="id21"/>demonstrate <code class="literal">nodemon</code>, let's look <a class="indexterm" id="id22"/>at an example. In your code editor of choice, paste the following and save it as <code class="literal">hello-world.js</code>:</p><div><pre class="programlisting">console.log('Hello World!');</pre></div><p>In your terminal, run the following:</p><div><pre class="programlisting">
<strong>nodemon hello-world.js</strong>
</pre></div><p>Your output should look like this:</p><div><img alt="Installing the development tools using NPM" src="img/B05384_02_02.jpg"/><div><p>The same Hello World as before but using nodemon</p></div></div><p>Note how the console command ran and then the program exited. <code class="literal">nodemon</code> then enters "watch mode", where it will wait for any files (indicated by the <code class="literal">*.*</code> wildcard) to change and then <a class="indexterm" id="id23"/>subsequently restart the Node process. <code class="literal">nodemon</code> can be further customized to watch or ignore specific files. Visit the website <a class="ulink" href="http://nodemon.io/">http://nodemon.io/</a> for more information.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>To manually restart the Node process without changing a file that <code class="literal">nodemon</code> watches, type <em>rs</em> followed by the <em>Enter</em> key.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>Creating a new project</h2></div></div></div><p>Now that the <a class="indexterm" id="id24"/>basics of Node and NPM are covered, we will look at creating a new Node project and expanding our knowledge of NPM.</p><p>A Node project can contain dependencies and development dependencies. The former are segments of code (or packages) that are required to run the project whereas the latter are segments of code used solely for development. In our previous example, <code class="literal">nodemon</code> would be considered a development dependency, as it would not be used in a production environment.</p><p>The dependencies of a Node project are stored in a <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) file named <code class="literal">package.json</code>. The JSON file contains information about the Node project, including a <a class="indexterm" id="id25"/>list of dependencies, the versions of the dependencies, and information about the package author(s). This allows easy installation of a project via NPM.</p><p>Let's create <a class="indexterm" id="id26"/>one of our own. Open up a terminal window and create a new folder by typing in the following and hitting <em>Enter</em>:</p><div><pre class="programlisting">
<strong>mkdir helloWorld &amp;&amp; cd helloWorld</strong>
</pre></div><p>This creates a new directory and navigates to said directory. Next, enter the following:</p><div><pre class="programlisting">
<strong>npm init</strong>
</pre></div><p>Follow the onscreen prompts and you will end up with something like this:</p><div><img alt="Creating a new project" src="img/B05384_02_03.jpg"/><div><p>Example of NPM init running successfully</p></div></div><p>Once <a class="indexterm" id="id27"/>completed, you'll find that a <code class="literal">package.json</code> file has been created in your directory; see the preceding screenshot for an example of what that JSON file contains.</p><p>Now that we've created a template for our app, let's create an entry point JavaScript file and install some dependencies:</p><div><pre class="programlisting">
<strong>touch index.js</strong>
<strong>npm install @slack/client –-save</strong>
</pre></div><p>These commands create an empty JavaScript file named <code class="literal">index</code> and install the Slack <strong>Real Time Messaging</strong> (<strong>RTM</strong>) client. Note how <code class="literal">@slack/client</code> now appears under dependencies <a class="indexterm" id="id28"/>in <code class="literal">package.json</code>. This is due to the <code class="literal">--save</code> flag <a class="indexterm" id="id29"/>used in the last command. The save flag indicates that this NPM package is required to run this app.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>As of Version 2, the Slack client API has moved to using NPM organizations. Indicated by the <code class="literal">@</code> character in the package name, this means that Slack (the company) can publish packages under the umbrella organization of <code class="literal">@slack</code>. Other than the additional character, the package does not differ from other, non-organization packages.</p></div></div><p>Should you wish to distribute your bot and allow others to work on or with it, you can easily install all required packages as dictated in <code class="literal">package.json</code> by running <code class="literal">npm install</code> in the project's directory.</p><p>Alternatively to the save flag, you can specify that a package is only required for development by using the <code class="literal">--save-dev</code> flag. This will add the package to the <code class="literal">devDependencies</code> section in <code class="literal">package.json</code>. This allows us to specify that this package only needs to be installed if the user intends to do some development.</p><p>This is particularly useful for servers running your code, where you would want to omit development packages altogether.</p><p>Your <code class="literal">package.json</code> file should now look something like this:</p><div><pre class="programlisting">{
  "name": "helloworld",
  "version": "1.0.0",
  "description": "My first Slack bot!",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "Paul Asjes",
  "license": "ISC",
  "dependencies": {
    "@slack/client": "^2.0.6",
  }
}</pre></div><p>Now that the Slack client is listed as a dependency, it will be automatically installed when the following command is run from within this directory:</p><div><pre class="programlisting">
<strong>npm install</strong>
</pre></div><p>You can <a class="indexterm" id="id30"/>test this by deleting the <code class="literal">node_modules</code> folder and then running the preceding command:</p><div><img alt="Creating a new project" src="img/B05384_02_03a.jpg"/><div><p>All our dependencies are installed</p></div></div><p>Note how the <code class="literal">slack-client</code> package has its own dependencies, which were automatically installed into the <code class="literal">node_modules</code> folder.</p><p>Now, we <a class="indexterm" id="id31"/>will add some code to our entry point JavaScript file. Open up <code class="literal">index.js</code> and enter the following code:</p><div><pre class="programlisting">// Enable strict mode, this allows us to use ES6 specific syntax
// such as 'const' and 'let'
'use strict';

// Import the Real Time Messaging (RTM) client
// from the Slack API in node_modules
const RtmClient = require('@slack/client').RtmClient;

// The memory data store is a collection of useful functions we // can
// include in our RtmClient
const MemoryDataStore = require('@slack/client').MemoryDataStore;

// Import the RTM event constants from the Slack API
const RTM_EVENTS = require('@slack/client').RTM_EVENTS;

// Import the client event constants from the Slack API
const CLIENT_EVENTS = require('@slack/client').CLIENT_EVENTS;

const token = '';

// The Slack constructor takes 2 arguments:
// token - String representation of the Slack token
// opts - Objects with options for our implementation
let slack = new RtmClient(token, {
  // Sets the level of logging we require
  logLevel: 'debug', 
  // Initialize a data store for our client, this will 
  // load additional helper functions for the storing 
  // and retrieval of data
  dataStore: new MemoryDataStore(),
  // Boolean indicating whether Slack should automatically 
  // reconnect after an error response
  autoReconnect: true,
  // Boolean indicating whether each message should be marked as // read 
  // or not after it is processed 
  autoMark: true 
});

// Add an event listener for the RTM_CONNECTION_OPENED 
// event, which is called 
// when the bot connects to a channel. The Slack API can 
// subscribe to events by using the 'on' method
slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () =&gt; {
  // Get the user's name
  let user = slack.dataStore.getUserById(slack.activeUserId);

  // Get the team's name
  let team = slack.dataStore.getTeamById(slack.activeTeamId);

  // Log the slack team name and the bot's name, using ES6's // template
  // string syntax
  console.log(`Connected to ${team.name} as ${user.name}`);
});

// Start the login process
slack.start();</pre></div><p>Save the <a class="indexterm" id="id32"/>file and run the program by executing the following command:</p><div><pre class="programlisting">
<strong>node index.js</strong>
</pre></div><p>You should immediately notice that something is wrong:</p><div><img alt="Creating a new project" src="img/B05384_02_03b.jpg"/><div><p>Debug and error logs are shown</p></div></div><p>Notice how the built-in logger outputs both debug and error messages. The error indicates that Slack cannot connect due to an authentication error. This is because we have not provided a Slack API token. The access token is a unique ID generated for your bot. By using it, you enable your bot to authenticate with Slack's servers and interact with the Slack client.</p><p>In our <a class="indexterm" id="id33"/>example, the token is set to an empty string, which will not work. Let's then retrieve an access token from Slack.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>Detailed steps to download the code bundle are mentioned in the <em>Preface</em> of this book. Please have a look.</p><p>The code bundle for the book is also hosted on GitHub at <a class="ulink" href="https://github.com/PacktPublishing/Building-Slack-Bots">https://github.com/PacktPublishing/Building-Slack-Bots</a>. We also have other code bundles from our rich catalog of books and videos available at <a class="ulink" href="https://github.com/PacktPublishing">https://github.com/PacktPublishing</a>. Check them out!</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Creating a Slack API token</h2></div></div></div><p>Open up a <a class="indexterm" id="id34"/>browser and navigate to <a class="ulink" href="https://my.slack.com/apps/build/custom-integration">https://my.slack.com/apps/build/custom-integration</a>.</p><p>Follow <a class="indexterm" id="id35"/>these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select <strong>Bots</strong> from the list of available custom integrations.<div><img alt="Creating a Slack API token" src="img/B05384_02_04.jpg"/><div><p>Custom integrations list</p></div></div></li><li class="listitem">Select <a class="indexterm" id="id36"/>a name and click on <strong>Add Bot Integration</strong>. The name of your bot can be changed later, so don't worry about <a class="indexterm" id="id37"/>picking a well thought-out name immediately.<div><img alt="Creating a Slack API token" src="img/B05384_02_05.jpg"/><div><p>Adding a bot integration</p></div></div></li><li class="listitem">Copy down the newly generated API token. As an optional step, you can choose to customize the bot further in this screen.<div><img alt="Creating a Slack API token" src="img/B05384_02_06.jpg"/><div><p>Optional settings for your bot</p></div></div><div><div><h3 class="title"><a id="note06"/>Note</h3><p>Although <a class="indexterm" id="id38"/>optional, it is recommended to <a class="indexterm" id="id39"/>choose an icon for your bot. For this example, we will use the <code class="literal">robot_face</code> emoji; however, a good bot should have an icon that represents the purpose of the bot.</p></div></div><p>Although you can give bots duplicate first and last names, the bot's username must be unique to your team. Providing a first name, last name, and description is optional but advisable as it provides information at a glance on what your bot does.</p></li><li class="listitem">Click on <strong>Save </strong><a class="indexterm" id="id40"/><strong>Integration</strong> at the bottom of the page.</li></ol></div><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>If you <a class="indexterm" id="id41"/>wish to remove or disable this bot at a later stage, you can do that from this same page.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Connecting a bot</h2></div></div></div><p>Now that we've <a class="indexterm" id="id42"/>generated an API token, replace the empty string assigned to <code class="literal">token</code> in <code class="literal">index.js</code> and run the program again.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Now is a good time to use <code class="literal">nodemon</code> rather than <code class="literal">node</code> to ensure automatic restarts when code is changed.</p></div></div><p>You will probably see a whole page of debug information show up. While useful, this can also hinder our progress as our own console logs might be difficult to spot. Instead of playing hide and seek, let's first change our logging settings in the client.</p><p>Switch this line:</p><div><pre class="programlisting">logLevel: 'debug',</pre></div><p>Use the following line:</p><div><pre class="programlisting">logLevel: 'error',</pre></div><p>This will instruct the client to only output error messages when the program crashes or a syntax error occurs.</p><p>Restart the program (or just save the file and let <code class="literal">nodemon</code> do the work):</p><div><pre class="programlisting">
<strong>[Thu Jan 07 2016 20:56:07 GMT-0500 (EST)] INFO Connecting...</strong>
<strong>Connected to Building Bots as awesomebot</strong>
</pre></div><p>If you see something similar to the preceding output in your terminal, congratulations! Your first bot is successfully connected to Slack! You will now see your bot in the <strong>Direct Messages</strong> section of your Slack client; click on the bot's name to open a private direct message.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>Throughout this book, you will encounter the title <code class="literal">Building Bots</code>. This is simply the <a class="indexterm" id="id43"/>title of the Slack team the author used and will be different from your own.</p></div></div><div><img alt="Connecting a bot" src="img/B05384_02_08.jpg"/><div><p>A direct message (DM) with your bot</p></div></div><p>Your bot is alive and well. However, it is fairly limited in its abilities. We will remedy that shortly, but first let's ensure that the bot can interact with a wider audience.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Joining a channel</h2></div></div></div><p>Bots <a class="indexterm" id="id44"/>cannot join channels programmatically; this is a design choice as bots should not be allowed to enter private channels without being invited. When a bot <a class="indexterm" id="id45"/>joins a channel, all the channel's activity can be monitored by the bot. A bot could potentially save all channel messages, a potentially nefarious activity that shouldn't be allowed to happen automatically.</p><p>For a complete list of what actions bots can and cannot perform, see the Slack bot user documentation at <a class="ulink" href="https://api.slack.com/bot-users">https://api.slack.com/bot-users</a>.</p><p>Bots are restricted in the actions they can perform themselves. As such, bots need to be invited to channels via the <code class="literal">invite</code> command within the Slack client:</p><div><pre class="programlisting">
<strong>/invite [BOT_NAME]</strong>
</pre></div><p>After this, you'll <a class="indexterm" id="id46"/>get confirmation of the bot entering the <a class="indexterm" id="id47"/>channel like this:</p><div><img alt="Joining a channel" src="img/B05384_02_09.jpg"/><div><p>The bot enters the world</p></div></div><p>Note that when a bot joins a channel, it remains there even if the bot's Node process is stopped. It shows the same characteristics as an offline user. This ensures that invitation needs only to happen once per bot and per channel.</p><p>To remove a bot from a channel, use the remove command within the Slack client:</p><div><pre class="programlisting">
<strong>/remove [BOT_NAME]</strong>
</pre></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Although all users can invite into a channel, only admins can actively remove users and bots from channels.</p></div></div><p>To make testing easier and to not disrupt other users in your team, it is a good idea to create a bot testing channel and invite your bot. For the purposes of this book, the testing channel is named <code class="literal">bot-test</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Sending a message to a channel</h2></div></div></div><p>We now <a class="indexterm" id="id48"/>have a connected bot, but it admittedly is a rather <a class="indexterm" id="id49"/>useless one. Let's remedy that by getting our bot to say "Hello" to every channel that it resides in.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>The slack object</h2></div></div></div><p>You might <a class="indexterm" id="id50"/>have noticed the following on line 18 in the preceding code example:</p><div><pre class="programlisting">let user = slack.dataStore.getUserById(slack.activeUserId);</pre></div><p>Here, we see that the <code class="literal">slack</code> object contains a myriad of information about the bot's current environment. Let's explore the data contained within. Replace line 18 with this modified <code class="literal">console.log</code> method:</p><div><pre class="programlisting">console.log(slack);</pre></div><p>You should see a large object printed out in your terminal. While we won't go through all the values, here <a class="indexterm" id="id51"/>are some of interest:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Function</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">activeUserId</code>
</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>The internal user ID. This can be used to get more information about the current user.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">activeUserId</code>
</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>The internal team ID. Again, it can be used to get more information about the team.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dataStore</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Object</p>
</td><td style="text-align: left" valign="top">
<p>If a data store is initialized, this object contains a myriad of information stored within the Slack API.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">channels</code> (child of <code class="literal">dataStore</code>)</p>
</td><td style="text-align: left" valign="top">
<p>Object</p>
</td><td style="text-align: left" valign="top">
<p>Contains a list of all the channels available in this team.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">channel</code> (child of channels)</p>
</td><td style="text-align: left" valign="top">
<p>Object</p>
</td><td style="text-align: left" valign="top">
<p>Contains further info on the channel. Whether the user requesting this information is a member or not is available through the <code class="literal">is_member</code> property</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dms</code> (child of <code class="literal">dataStore</code>)</p>
</td><td style="text-align: left" valign="top">
<p>Object</p>
</td><td style="text-align: left" valign="top">
<p>A list of all the direct message channels this user is a part of. Note: even if no messages were ever sent the direct message channel is still considered open.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">users</code> (child of <code class="literal">dataStore</code>)</p>
</td><td style="text-align: left" valign="top">
<p>Object</p>
</td><td style="text-align: left" valign="top">
<p>A list <a class="indexterm" id="id52"/>of all users in this team.</p>
</td></tr></tbody></table></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Getting all the channels</h2></div></div></div><p>You'll note <a class="indexterm" id="id53"/>from the preceding table that the <code class="literal">channels</code> object returns all the channels in this team. For our purposes, we only want the channels in which our <a class="indexterm" id="id54"/>bot resides. To achieve this, we can loop through the <code class="literal">channels</code> object and return exactly what we need. Add the following to the end of <code class="literal">index.js</code>:</p><div><pre class="programlisting">// Returns an array of all the channels the bot resides in
function getChannels(allChannels) {
  let channels = [];

  // Loop over all channels
  for (let id in allChannels) {
    // Get an individual channel
    let channel = allChannels[id];

    // Is this user a member of the channel?
    if (channel.is_member) {
      // If so, push it to the array
      channels.push(channel);
    }
  }

  return channels;
}</pre></div><p>Now, replace the Slack <code class="literal">open</code> event listener with this:</p><div><pre class="programlisting">// Add an event listener for the RTM_CONNECTION_OPENED event,
//  which is called when the bot
// connects to a channel. The Slack API can subscribe to 
// events by using the 'on' method
slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () =&gt; {
  // Get the user's name
  let user = slack.dataStore.getUserById(slack.activeUserId);

  // Get the team's name
  let team = slack.dataStore.getTeamById(slack.activeTeamId);

  // Log the slack team name and the bot's name, using ES6's 
  // template string syntax
  console.log(`Connected to ${team.name} as ${user.name}`);

  // Note how the dataStore object contains a list of all 
  // channels available
  let channels = getChannels(slack.dataStore.channels);

  // Use Array.map to loop over every instance and return an 
  // array of the names of each channel. Then chain Array.join 
  // to convert the names array to a string
  let channelNames = channels.map((channel) =&gt; {
    return channel.name;
  }).join(', ');

  console.log(`Currently in: ${channelNames}`)
});</pre></div><p>Switch to <a class="indexterm" id="id55"/>your terminal and you should see the following output:</p><div><img alt="Getting all the channels" src="img/B05384_02_10.jpg"/><div><p>Listing the channels the bot resides in</p></div></div><p>Now that your bot knows which channels it's in, it can start to send messages. We'll start with the bot <a class="indexterm" id="id56"/>sending a simple "Hello" message to everyone in the channel.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Getting all members in a channel</h2></div></div></div><p>We have the <a class="indexterm" id="id57"/>channel object, so getting the members within is <a class="indexterm" id="id58"/>easy. Add this to the <code class="literal">RTM_CONNECTION_OPENED</code> event listener:</p><div><pre class="programlisting">// log the members of the channel
channels.forEach((channel) =&gt; {
  console.log('Members of this channel: ', channel.members);
});</pre></div><p>This is the result:</p><div><img alt="Getting all members in a channel" src="img/B05384_02_11.jpg"/><div><p>A list of user IDs</p></div></div><p>Well that wasn't quite what we expected, perhaps. The Slack API has returned a list of user IDs rather than an array of member objects. This makes sense as a large channel containing several hundred users would result in an unwieldy and large array of member objects. Not to worry, the Slack API provides us with the tools we need to get more information by using these user IDs. Replace the previous snippet with this and then save the file:</p><div><pre class="programlisting">  // log the members of the channel
  channels.forEach((channel) =&gt; {
    // get the members by ID using the data store's 
    //'getUserByID' function
    let members = channel.members.map((id) =&gt; {
      return slack.dataStore.getUserById(id);
    });

    // Each member object has a 'name' property, so let's 
    // get an array of names and join them via Array.join
    let memberNames = members.map((member) =&gt; {
      return member.name;
    }).join(', ');

    console.log('Members of this channel: ', memberNames);
  });</pre></div><p>The output for this code can be seen in the following screenshot:</p><div><img alt="Getting all members in a channel" src="img/B05384_02_12.jpg"/><div><p>The users of the channel using their usernames</p></div></div><p>Notice how the bot is also listed in the channel members list. Our current goal is to say hello to <a class="indexterm" id="id59"/>everyone in the channel; however, we should <a class="indexterm" id="id60"/>try to avoid having the bot talking to itself.</p><p>We can use the <code class="literal">is_bot</code> property on the <code class="literal">member</code> object to determine whether a user is a bot:</p><div><pre class="programlisting">  // log the members of the channel
  channels.forEach((channel) =&gt; {
    // get the members by ID using the data store's 
    // 'getUserByID' function
    let members = channel.members.map((id) =&gt; {
      return slack.dataStore.getUserById(id);
    });

    // Filter out the bots from the member list using Array.filter
    members = members.filter((member) =&gt; {
      return !member.is_bot;
    });

    // Each member object has a 'name' property, so let's 
    // get an array of names and join them via Array.join
    let memberNames = members.map((member) =&gt; {
      return member.name;
    }).join(', ');

    console.log('Members of this channel: ', memberNames);
  });</pre></div><div><img alt="Getting all members in a channel" src="img/B05384_02_13.jpg"/><div><p>The users of the channel, without bots</p></div></div><p>Wonderful! Now <a class="indexterm" id="id61"/>that we are done with this, the next step is <a class="indexterm" id="id62"/>to send a message to the channel.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Sending a message to a channel</h2></div></div></div><p>The channel <a class="indexterm" id="id63"/>object contains all the tools required for bot communication. In the following code, we will build upon the previous code <a class="indexterm" id="id64"/>snippets and send a "Hello" message addressing each person in the channel once the bot connects. All of these actions will happen in the open event listener. Here it is in its entirety:</p><div><pre class="programlisting">// Add an event listener for the RTM_CONNECTION_OPENED event, 
// which is called when the bot connects to a channel. The Slack API 
// can subscribe to events by using the 'on' method
slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () =&gt; {
  // Get the user's name
  let user = slack.dataStore.getUserById(slack.activeUserId);

  // Get the team's name
  let team = slack.dataStore.getTeamById(slack.activeTeamId);

  // Log the slack team name and the bot's name, using ES6's 
  // template string syntax
  console.log(`Connected to ${team.name} as ${user.name}`);

  // Note how the dataStore object contains a list of all 
  // channels available
  let channels = getChannels(slack.dataStore.channels);

  // Use Array.map to loop over every instance and return an 
  // array of the names of each channel. Then chain Array.join 
  // to convert the names array to a string
  let channelNames = channels.map((channel) =&gt; {
    return channel.name;
  }).join(', ');

  console.log(`Currently in: ${channelNames}`)

  // log the members of the channel
  channels.forEach((channel) =&gt; {
    // get the members by ID using the data store's 
    // 'getUserByID' function
    let members = channel.members.map((id) =&gt; {
      return slack.dataStore.getUserById(id);
    });

    // Filter out the bots from the member list using Array.filter
    members = members.filter((member) =&gt; {
      return !member.is_bot;
    });

    // Each member object has a 'name' property, so let's 
    // get an array of names and join them via Array.join
    let memberNames = members.map((member) =&gt; {
      return member.name;
    }).join(', ');

    console.log('Members of this channel: ', memberNames);

    // Send a greeting to everyone in the channel
    slack.sendMessage(`Hello ${memberNames}!`, channel.id);
  });
});</pre></div><p>As soon as you <a class="indexterm" id="id65"/>run the code, you should be greeted by a <a class="indexterm" id="id66"/>notification from the Slack client that you have been mentioned in a message, as shown in the following screenshot:</p><div><img alt="Sending a message to a channel" src="img/B05384_02_14.jpg"/><div><p>Our bot speaks its first words</p></div></div><p>Let's ramp up our bot's complexity by giving it the ability to respond to messages.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Basic responses</h1></div></div></div><p>The Slack API can be <a class="indexterm" id="id67"/>configured to execute methods once certain events are dispatched, as seen earlier with the <code class="literal">RTM_CONNECTION_OPENED</code> event. Now, we will dive into other useful events provided to us.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>The authenticated event</h2></div></div></div><p>So far, we have <a class="indexterm" id="id68"/>seen how to add functionality to Slack's <a class="indexterm" id="id69"/>
<code class="literal">RTM_CONNECTION_OPENED</code> event triggered by the bot entering a channel and an error occurring, respectively. If you wish to execute some code when a bot logs in but before it connects to a channel, you can use the <code class="literal">AUTHENTICATED</code> event:</p><div><pre class="programlisting">slack.on(CLIENT_EVENTS.RTM.AUTHENTICATED, (rtmStartData) =&gt; {
  console.log(`Logged in as ${rtmStartData.self.name} of team ${rtmStartData.team.name}, but not yet connected to a channel`);
});</pre></div><p>This gives the following output:</p><div><pre class="programlisting">
<strong>[Mon Jan 18 2016 21:37:24 GMT-0500 (EST)] INFO Connecting...</strong>
<strong>Logged in as awesomebot of team Building Bots, but not yet connected to a channel</strong>
</pre></div><p>Now, we will <a class="indexterm" id="id70"/>introduce the <em>message</em> event.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Using the message event</h2></div></div></div><p>The message <a class="indexterm" id="id71"/>event will trigger every time a message is sent to a <a class="indexterm" id="id72"/>channel the bot is in or in a direct message to the bot. The message object contains useful data such as the originating user, the originating channel, and the timestamp it was sent.</p><p>Paste the following into <code class="literal">index.js</code> and then send the message "Hello bot!" to a channel that your bot is a member of:</p><div><pre class="programlisting">slack.on(RTM_EVENTS.MESSAGE, (message) =&gt; {
  let user = slack.dataStore.getUserById(message.user)

  if (user &amp;&amp; user.is_bot) {
    return;
  }

  let channel = slack.dataStore.getChannelGroupOrDMById(message.channel);

  if (message.text) {
    let msg = message.text.toLowerCase();

    if (/(hello|hi) (bot|awesomebot)/g.test(msg)) {
      slack.sendMessage(`Hello to you too, ${user.name}!`, channel.id);
    }
  }
});</pre></div><p>This should <a class="indexterm" id="id73"/>result in something like this:</p><div><img alt="Using the message event" src="img/B05384_02_15.jpg"/><div><p>A more personal greeting from the bot</p></div></div><p>Let's look at the <a class="indexterm" id="id74"/>code again in detail, starting from the top:</p><div><pre class="programlisting">slack.on(RTM_EVENTS.MESSAGE, (message) =&gt; {
  let user = slack.dataStore.getUserById(message.user)

  if (user &amp;&amp; user.is_bot) {
    return;
}</pre></div><p>This should be familiar, as it's similar to what we've used before, except we're now using the <code class="literal">MESSAGE</code> event from the <code class="literal">RTM_EVENTS</code> object. We also make sure the message sender isn't a bot:</p><div><pre class="programlisting">  let channel = slack.dataStore.getChannelGroupOrDMById(message.channel);</pre></div><p>The <code class="literal">getChannelGroupOrDMById</code> method lets us grab the channel for every message sent. This is particularly useful if our bot happens to inhabit multiple channels. The code is as follows:</p><div><pre class="programlisting">if (message.text) {
  let msg = message.text.toLowerCase();

  if (/(hello|hi) (bot|awesomebot)/g.test(msg)) {
    slack.sendMessage(`Hello to you too, ${user.name}!`, channel.id);
     }
}</pre></div><p>A message does <a class="indexterm" id="id75"/>not necessarily contain text; it is also possible that the <a class="indexterm" id="id76"/>message is a file, an image, or even an emoji. Therefore, we have to do a little type checking to make sure the message received is indeed text based. Once the text type is confirmed, we use a regular expression to test whether the message received contains certain keywords in a specific order. The <code class="literal">RegExp.test</code> method will return true when the message received contains the words "Hello" or "Hi" followed by either "bot" or "awesomebot." If true, a response is sent back to the channel using the <a class="indexterm" id="id77"/>familiar <code class="literal">slack.sendMessage</code> method.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>When evaluating incoming text, it is almost always a good idea to first convert the body of the text message to lowercase in order to avoid case sensitive errors.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Avoiding spam</h2></div></div></div><p>Infinite loops happen <a class="indexterm" id="id78"/>occasionally when developing; it is entirely possible <a class="indexterm" id="id79"/>that you accidentally program a bot to send a message in an infinite loop, flooding the channel with spam. Observe the following code:</p><div><pre class="programlisting">if (/(hello|hi) (bot|awesomebot)/g.test(msg)) {
  // Infinite loop spamming the channel every 100 milliseconds
  setInterval(() =&gt; {
    slack.sendMessage('Spam!', channel.id);
  }, 100);
}</pre></div><p>Take a look at <a class="indexterm" id="id80"/>the screenshot of the result:</p><div><img alt="Avoiding spam" src="img/B05384_02_16.jpg"/><div><p>A bot spamming the channel</p></div></div><p>In the terminal or command prompt, you should see this:</p><div><img alt="Avoiding spam" src="img/B05384_02_17.jpg"/><div><p>The Slack API deals with the spam</p></div></div><p>Luckily, the Slack API has a built in guard against such unfortunate events. If 20 messages are sent <a class="indexterm" id="id81"/>by a single user in a very short time frame, the Slack server will refuse to post more messages and return an error. This has the added effect of causing our bot to get stuck and eventually crash.</p><p>The Slack platform will guard against spam attacks flooding the channel; however, it is likely that the offending bot will crash.</p><p>To prevent this from happening, it is highly advisable to <em>never</em> place a <code class="literal">slack.sendMessage</code> method call within a loop or within a <code class="literal">setInterval</code> method.</p><p>Channels with many <a class="indexterm" id="id82"/>users and thus high volume could potentially lead to <a class="indexterm" id="id83"/>accidentally triggering the "slow down" response from the Slack platform. To prevent this, keep track of the time difference between messages:</p><div><pre class="programlisting">if (/(hello|hi) (bot|awesomebot)/g.test(msg)) {
  // Get the timestamp when the above message was sent
  let sentTime = Date.now();

  setInterval(() =&gt; {
    // Get the current timestamp
    let currentTime = Date.now();
        
    // Make sure we only allow a message once a full second has // passed 
    if ((currentTime - sentTime) &gt; 1000) {

      slack.sendMesssage('Limiting my messages to 1 per second', channel.id);

      // Set the new sentTime
      sentTime = Date.now();
    }
  }, 100);
}</pre></div><div><img alt="Avoiding spam" src="img/B05384_02_18.jpg"/><div><p>Limiting the bot's messages</p></div></div><p>Every time the <code class="literal">setInterval</code> function is called, we generate a new timestamp called <code class="literal">currentTime</code>. By comparing <code class="literal">currentTime</code> to the timestamp of the message (defined as <code class="literal">sentTime</code>), we can artificially limit the messages being sent on the bot side by making sure the difference between the two is more than 1,000 milliseconds in length.</p><p>The Slack API provides a <a class="indexterm" id="id84"/>timestamp on the channel object accessible via <a class="indexterm" id="id85"/>
<code class="literal">channel.latest.ts</code>; this provides a timestamp for the latest message received in the channel. While still useful, it is recommended to use local timestamps instead, as the Slack API provides information on the latest message received rather than the latest message sent by the bot.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Sending a direct message</h1></div></div></div><p>A <strong>direct </strong><a class="indexterm" id="id86"/>
<strong>message</strong> (<strong>DM</strong>) channel is a channel that only operates between two users. By design, it cannot have more or less than two users and is meant for private communication. Sending a DM is remarkably similar to sending a message to a channel, as the <code class="literal">dm</code> object is almost identical to the <code class="literal">channel</code> object.</p><p>Consider the following snippet:</p><div><pre class="programlisting">slack.on(RTM_EVENTS.MESSAGE, (message) =&gt; {
  let user = slack.dataStore.getUserById(message.user)

  if (user &amp;&amp; user.is_bot) {
    return;
  }

  let channel = slack.dataStore.getChannelGroupOrDMById(message.channel);

  if (message.text) {
    let msg = message.text.toLowerCase();

    if (/uptime/g.test(msg)) {
      let dm = slack.dataStore.getDMByName(user.name);

      let uptime = process.uptime();

      // get the uptime in hours, minutes and seconds
      let minutes = parseInt(uptime / 60, 10),
          hours = parseInt(minutes / 60, 10),
          seconds = parseInt(uptime - (minutes * 60) - ((hours * 60) * 60), 10);

      slack.sendMessage(`I have been running for: ${hours} hours, ${minutes} minutes and ${seconds} seconds.`, dm.id);
  }
});</pre></div><p>In this <a class="indexterm" id="id87"/>example, our bot will send a DM with the current uptime to any user who uses the key phrase <code class="literal">uptime</code>:</p><div><img alt="Sending a direct message" src="img/B05384_02_19.jpg"/><div><p>Uptime can be a very useful statistic</p></div></div><p>Note that the bot will send a DM to the user, regardless of which channel the command <code class="literal">uptime</code> is sent as long as the bot is around to hear the command as a member of that channel or DM. In the preceding image, the command was issued in the DM itself. This is because both <a class="indexterm" id="id88"/>channels and DMs subscribe to the <code class="literal">message</code> event; it is important to remember this when sending responses meant for channels rather than DMs and vice versa.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Restricting access</h1></div></div></div><p>Occasionally, you <a class="indexterm" id="id89"/>might wish to restrict bot commands to administrators of your Slack team. A good example is a bot that controls a project's deploy process. This can be immensely powerful but perhaps not something that you want every user to have access to. Only administrators (also known as admins) should have the authority to access such functions. Admins are special users who have administrative powers over the Slack team. Luckily, restricting such access is easy with the <code class="literal">is_admin</code> property attached to a user object.</p><p>In the following example, we'll restrict the <code class="literal">uptime</code> command demonstrated in the previous topic to admin users, notifying the restricted user that they can't use that command:</p><div><pre class="programlisting">slack.on(RTM_EVENTS.MESSAGE, (message) =&gt; {
  let user = slack.dataStore.getUserById(message.user)

  if (user &amp;&amp; user.is_bot) {
    return;
  }

  let channel = slack.dataStore.getChannelGroupOrDMById(message.channel);

  if (message.text) {
    let msg = message.text.toLowerCase();

    if (/uptime/g.test(msg)) {
      if (!user.is_admin) {        
        slack.sendMessage(`Sorry ${user.name}, but that functionality is only for admins.`, channel.id);
        return;
      }

      let dm = slack.dataStore.getDMByName(user.name);

      let uptime = process.uptime();

      // get the uptime in hours, minutes and seconds
      let minutes = parseInt(uptime / 60, 10),
          hours = parseInt(minutes / 60, 10),
          seconds = parseInt(uptime - (minutes * 60) - ((hours * 60) * 60), 10);

      slack.sendMessage(`I have been running for: ${hours} hours, ${minutes} minutes and ${seconds} seconds.`, dm.id);
  }
});</pre></div><p>Now when non-admin <a class="indexterm" id="id90"/>users issue the <code class="literal">uptime</code> command, they will get the following message:</p><div><img alt="Restricting access" src="img/B05384_02_20.jpg"/><div><p>Restricting the bot to admin users</p></div></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The use of <a class="indexterm" id="id91"/>
<code class="literal">user.is_admin</code> is to determine whether a user is an admin or not.</p></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Adding and removing admins</h2></div></div></div><p>To add or remove admins to your team, visit <a class="ulink" href="https://my.slack.com/admin#active">https://my.slack.com/admin#active</a> and click on a user.</p><p>Admins and owners <a class="indexterm" id="id92"/>have the ability to kick other members from channels and to delete <a class="indexterm" id="id93"/>messages that aren't their own. Although these are the default settings, they can be edited at <a class="ulink" href="https://my.slack.com/admin/settings#channel_management_restrictions">https://my.slack.com/admin/settings#channel_management_restrictions</a>.</p><p>Bots cannot be admins or <a class="indexterm" id="id94"/>owners; for more information on team permissions, visit <a class="ulink" href="https://get.slack.help/hc/en-us/articles/201314026-Understanding-r">https://get.slack.help/hc/en-us/articles/201314026-Understanding-r</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Debugging a bot</h1></div></div></div><p>It is inevitable that <a class="indexterm" id="id95"/>eventually you will encounter a bug in your bot that is difficult to squash. The worst are bugs that don't cause your program to crash and thus don't provide a useful stack trace and line number for where the crash happened. For most issues, the <code class="literal">console.log()</code> method will be enough to help you track down the bug, for the more tenacious bugs however we will need a true debugging environment. This section will introduce you to <a class="indexterm" id="id96"/>
<code class="literal">iron-node</code> (<a class="ulink" href="https://s-a.github.io/iron-node/">https://s-a.github.io/iron-node/</a>), a cross-platform JavaScript debugging environment based on Chrome's dev tools.</p><p>Start by installing <code class="literal">iron-node</code>:</p><div><pre class="programlisting">
<strong>npm install -g iron-node</strong>
</pre></div><p>Note again the use of the <code class="literal">-g</code> flag, which installs the application globally.</p><p>Before we can start debugging, we need to add a breakpoint to our code, which tells the debugger to stop the code and allow for deeper inspection. Add the <code class="literal">debugger</code> statement to our previous code, within the <code class="literal">slack.openDM()</code> code block:</p><div><pre class="programlisting">if (/uptime/g.test(msg)) {
  debugger;
      
  if (!user.is_admin) {        
    slack.sendMessage(`Sorry ${user.name}, but that functionality is only for admins.`, channel.id);
    return;
  } 

  let dm = slack.dataStore.getDMByName(user.name);

  let uptime = process.uptime();

  // get the uptime in hours, minutes and seconds
  let minutes = parseInt(uptime / 60, 10),
      hours = parseInt(minutes / 60, 10),
      seconds = parseInt(uptime - (minutes * 60) - ((hours * 60) * 60), 10);

  slack.sendMessage(`I have been running for: ${hours} hours, ${minutes} minutes and ${seconds} seconds.`, dm.id);
}</pre></div><p>Save the file and then <a class="indexterm" id="id97"/>run the code via <code class="literal">iron-node</code> in your terminal:</p><div><pre class="programlisting">
<strong>iron-node index.js</strong>
</pre></div><p>Immediately, you should see the <code class="literal">iron-node</code> interface pop up:</p><div><img alt="Debugging a bot" src="img/B05384_02_21.jpg"/><div><p>The iron-node interface</p></div></div><p>Chrome users will perhaps notice that this interface is exactly like Chrome's developer tools window. It is advisable to spend some time familiarizing yourself with this interface if you haven't used it before. Let's discuss some basic functionality to get you started.</p><p>You can switch to the console tab to see the node output, or you can also hit <em>Esc</em> to show the console at the bottom of the screen.</p><p>Our debugger was placed within <a class="indexterm" id="id98"/>a message event listener, so send a command to the bot (<code class="literal">uptime</code> in the last example) and watch what happens next.</p><div><img alt="Debugging a bot" src="img/B05384_02_22.jpg"/><div><p>Setting a breakpoint with the "debugger" statement</p></div></div><p>The bot's execution has been paused by the debugger, so you can inspect properties and determine the source of the bug.</p><p>Either click on the <strong>Step </strong><a class="indexterm" id="id99"/>
<strong>over</strong> button in the top-right corner, symbolized by an arrow curving around a dot, or hit <em>F10</em> to step over to the next line.</p><p>Use your mouse to hover over the different objects in this line of code to retrieve more information about them.</p><div><img alt="Debugging a bot" src="img/B05384_02_23.jpg"/><div><p>Inspecting a property in the paused program</p></div></div><p>Keep clicking on the <strong>Step over</strong> button to progress through the code, or click on the <strong>Resume script execution</strong> button to the left of the <strong>Step over</strong> button to allow the program to continue until it <a class="indexterm" id="id100"/>encounters another debugger breakpoint.</p><p>Not only can you inspect variables and properties while the bot is executing, but you can also edit their values, causing different outputs. Observe how we can edit the uptime variable in our code and set it to 1000:</p><div><img alt="Debugging a bot" src="img/B05384_02_24.jpg"/><div><p>
<code class="literal">uptime</code> is set by the program to 40.064</p></div></div><p>In the console area, we can edit JavaScript variables whilst the program is running:</p><div><img alt="Debugging a bot" src="img/B05384_02_25.jpg"/></div><p>In the console, we check the value of uptime again, and then set it to a value of 1000. Now when we look back <a class="indexterm" id="id101"/>at the variables, we should see the updated values:</p><div><img alt="Debugging a bot" src="img/B05384_02_26.jpg"/><div><p>The new value of uptime is reflected in the next few lines</p></div></div><p>When we resume the program, our bot will send its message based on our updated variables:</p><div><img alt="Debugging a bot" src="img/B05384_02_27.jpg"/></div><p>We continue the program and the bot sends the new values to the channel.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>For best debugging practices, either disable your bot's ability to send messages or invite your bot to a private channel to avoid spamming other users.</p></div></div><p>As <code class="literal">iron-node</code> is based on Chrome's developer tools, you can use the previous techniques interchangeably with Chrome.</p><p>To debug and fix memory <a class="indexterm" id="id102"/>issues, you can use the developer tools' profiler and heap snapshot tool. For more information on these topics, please visit the following links:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution">https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en">https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en</a></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Summary</h1></div></div></div><p>In this chapter, we saw how to install the prerequisite technologies, how to obtain a Slack token for a bot, and how to set up a new Slack bot project. As a result, you can reuse the lessons learned to easily scaffold a new bot project. You should now be able to program a bot that can send messages to channels, direct messages as well as craft basic responses. Finally, we discussed how to debug a Node.js-based bot using the <code class="literal">iron-node</code> debugger.</p><p>In the next chapter, we will see how to make our bot more complex by adding third-party API support and by programming our first bot command.</p></div></body></html>