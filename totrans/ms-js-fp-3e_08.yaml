- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Connecting Functions – Pipelining, Composition, and More
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*,
    we looked at ways to build new functions by applying higher-order functions. In
    this chapter, we will go to the core of FP and learn how to create sequences of
    function calls and how to combine them to produce a more complex result out of
    several simpler components. To do this, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pipelining**: A way to join functions, similar to Unix/Linux pipes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chaining**: A variant of pipelining, but restricted to objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Composing**: A classic operation with its origins in basic computer theory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`, `filter`, or `reduce` operations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Along the way, we will be touching on related concepts, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pointfree style**, which is often used with pipelining and composition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging** of composed or piped functions, for which we’ll whip up some
    auxiliary tools'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing** for these functions, which won’t prove to be of high complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Armed with these techniques, you’ll be able to combine small functions to create
    larger ones, which is a characteristic of FP and will help you develop better
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelining
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pipelining and composition are techniques that are used to set up functions
    to work in sequence so that the output of a function becomes the input for the
    following function. There are two ways of looking at this: from a computer point
    of view, and from a mathematical point of view. We’ll look at both in this section.
    Most FP texts start with the latter, but since I assume that most of you will
    prefer computers over math, let’s start with the former instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Piping in Unix/Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Unix/Linux, executing a command and passing its output as input to a second
    command, whose output will yield the input of a third command, and so on, is called
    a pipeline. This is quite a common application of the philosophy of Unix, as explained
    in a Bell Laboratories article written by the creator of the pipelining concept
    himself, Doug McIlroy:'
  prefs: []
  type: TYPE_NORMAL
- en: Make each program do one thing well. To do a new job, build afresh rather than
    complicating old programs by adding new features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expect the output of every program to become the input to another, so far unknown
    program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A bit of history
  prefs: []
  type: TYPE_NORMAL
- en: Given the historical importance of Unix, I’d recommend reading some of the seminal
    articles describing the (then new) operating system in the Bell System Technical
    Journal, July 1978, at [emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf](http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf).
    The two quoted rules are in the *Style* section of the *Foreword* article.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a simple example to get started. Suppose I want to know how
    many LibreOffice text documents there are in a directory. There are many ways
    to do this, but the following example will do. We will execute three commands,
    piping (that’s the meaning of the `|` character) each command’s output as input
    to the next one. Suppose we have `cd /home/fkereki/Documents` and then do the
    following (please ignore the dollar sign, which is just the console prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'What does this mean? How does it work? We have to analyze this process step
    by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the pipeline, `ls -1`, lists all the files in the current
    directory (`/home/fkereki/Documents`, as per our `cd` command) in a single column,
    with one filename per line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The output from the first command is provided as input to `grep "odt$"`, which
    filters (only lets pass) lines that finish with `"odt"`, the standard file extension
    for LibreOffice Writer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filtered output is provided to the counting command, `wc -l`, which counts
    how many lines there are in its input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More on pipelining
  prefs: []
  type: TYPE_NORMAL
- en: You can find out more about pipelines in *Section 6.2*, *Filters*, of *The UNIX
    Time-Sharing System* by Dennis Ritchie and Ken Thompson, also in the issue of
    the Bell Laboratories journal that I mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the point of view of FP, this is a key concept. We want to build more
    complex operations out of simple, single-purpose, shorter functions. Pipelining
    is what the Unix shell uses to apply that concept. It does this by simplifying
    the job of executing a command, taking its output, and providing it as input to
    yet another command. We will apply similar concepts in our own functional style
    in JavaScript later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Pipelines in JavaScript are similar to Unix/Linux pipelines.
    The output of each function becomes the input for the next](img/Figure_8.1_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Pipelines in JavaScript are similar to Unix/Linux pipelines. The
    output of each function becomes the input for the next
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way (and no—rest assured, this isn’t turning into a shell tutorial!),
    you can make pipelines accept parameters. For example, if I happened to want to
    count how many files I had with this or that extension, I could create a function
    such as `cfe`, standing for *count* *for extension*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, I could use `cfe` as a command, giving it the desired extension as an
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`cfe` executes my pipeline and tells me I have four `odt` files (LibreOffice)
    and six `pdf` files; nice! We will also want to write similar parametric pipelines:
    we are not constrained to fixed functions in our flow; we have full liberty regarding
    what we want to include. Having worked in Linux, we can now go back to coding.
    Let’s see how.'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting an example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start tying ends together by revisiting a problem from a previous chapter.
    Remember when we had to calculate the average latitude and longitude for some
    geographic data that we looked at in the *Extracting data from objects* section
    of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*, Programming Declaratively*?
    Basically, we started with some data such as the following, and the problem was
    to calculate the average latitude and longitude of the given points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With what we know, we can write a solution in terms of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Being able to extract the latitude (and afterward, the longitude) from each
    point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using that function to create an array of latitudes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipelining the resulting array to the average function we wrote in the *Calculating
    an average* section of the aforementioned chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do the first task, we can use the `myMap()` function from the *Parameter
    order* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*, Transforming
    Functions*. For the second task, we can make do with the `getField()` function
    from the *Getting a property from an object* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions*. Finally, for the third task, we’ll use the (yet unwritten)
    `pipeline()` function we’ll develop soon! In full, our solution could look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We had to add some casting to `getAllLats` so that TypeScript would know to
    what we would apply that function.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can always yield to the temptation of going for one-liners, but
    would it be much clearer or better?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Whether this makes sense to you will depend on your experience with FP. In any
    case, no matter which solution you take, the fact remains that adding pipelining
    (and later on, composition) to your set of tools can help you write tighter, declarative,
    simpler-to-understand code.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn how to pipeline functions in the right way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to be able to generate a pipeline of several functions. We can do this
    in two ways: by building the pipeline by hand, in a problem-specific way, or by
    using more generic constructs that can be applied with generality. Let’s look
    at both.'
  prefs: []
  type: TYPE_NORMAL
- en: Potential pipeline proposal
  prefs: []
  type: TYPE_NORMAL
- en: A new operator, `|>`, is being considered for JavaScript, but it’s currently
    only at stage 2, which means it may be a while before it’s accepted and available.
    You may read more about the proposal and its varied history at [github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md](http://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md).
  prefs: []
  type: TYPE_NORMAL
- en: Building pipelines by hand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s go with a Node.js example, similar to the command-line pipeline we built
    earlier in this chapter. Here, we’ll build the pipeline we need by hand. We need
    a function to read all the files in a directory. We can do that (although this
    isn’t recommended because of the synchronous call, which is normally not good
    in a server environment) with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting only `odt` files is quite simple. We start with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes an array of strings and filters out elements that do not
    end with the given text, so we can now write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Better still, we can apply currying and go for pointfree style, as shown in
    the *An unnecessary mistake* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, and write this, instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Both versions of the filtering function are equivalent; which one you use comes
    down to your tastes. Finally, we can write the following to count elements in
    an array. Since `length` is not a function, we cannot apply our demethodizing
    trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'With these functions, we could write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are essentially doing the same process as in Linux: getting the files, keeping
    only the `odt` ones, and counting how many files result from this. If you wanted
    to get rid of all the intermediate variables, you could also go for a one-liner
    definition that does precisely the same job in the very same way, albeit with
    fewer lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This gets to the crux of the matter: both implementations of our file-counting
    function have disadvantages. The first definition uses several intermediate variables
    to hold the results and makes a multiline function out of what was a single line
    of code in the Linux shell. On the other hand, the second, much shorter definition
    is harder to understand, insofar as we are writing the steps of the computation
    in seemingly reverse order! Our pipeline has to read files first, then filter
    them, and finally count them, but those functions appear *the other way around*
    in our definition!'
  prefs: []
  type: TYPE_NORMAL
- en: We can undoubtedly implement pipelining by hand, as we have seen, but it would
    be better if we went for a more declarative style.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on and try to build a better pipeline more clearly and more understandably
    by applying some of the concepts we’ve already seen.
  prefs: []
  type: TYPE_NORMAL
- en: Using other constructs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we think in functional terms, what we have is a list of functions and we
    want to apply them sequentially, starting with the first, then applying the second
    to whatever the first function produced as its result, and then applying the third
    to the second function’s results, and so on. If we were fixing a pipeline of two
    functions, we could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the basic definition we provided earlier in this chapter: we evaluate
    the first function, and its output becomes the input for the second function;
    relatively straightforward! Typing is simple: the first function to apply (`f()`)
    may have any number of parameters, but the second function (`g()`) must have a
    single one, the same type that `f()` returns. The return type of the pipeline
    is the return type of `g()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may object, though, that this pipeline of only two functions is a bit too
    limited! This is not as useless as it may seem because we can compose longer pipelines—though
    I’ll admit that it requires too much writing! Suppose we wanted to write our three-function
    pipeline (from the previous section); we could do so in two different, equivalent
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A touch of math
  prefs: []
  type: TYPE_NORMAL
- en: 'We are taking advantage of the fact that piping is an associative operation.
    In mathematics, the associative property is the one that says that we can compute
    1+2+3 either by adding 1+2 first and then adding that result to 3 or by adding
    1 to the result of first adding 2+3: in other terms, 1+2+3 is the same as (1+2)+3
    or 1+(2+3).'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do they work? How is it that they are equivalent? Following the execution
    of a given call will be useful; it’s quite easy to get confused with so many calls!
    The first implementation can be followed step by step until the final result,
    which matches what we already know:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The second implementation also comes to the same final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Both derivations arrived at the same final expression—the same we had written
    by hand earlier, in fact—so we now know that we can make do just with a basic
    *pipe of two* higher-order functions, but we’d really like to be able to work
    in a shorter, more compact way. A first implementation could be along the lines
    of the following, and let’s look at typing later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This does work—and specifying our file-counting pipeline is much clearer since
    the functions are given in their proper order. However, the implementation of
    the `pipeline()` function is not very functional and goes back to old, imperative,
    loop-by-hand methods. We can do better using `reduce()`, as in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to start the evaluation with the first function, pass the result
    to the second, then that result to the third, and so on. By doing this, we can
    pipeline with shorter code, and again we’ll leave typing for later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is more declarative. However, you could have gone one better by writing
    it using our `pipeTwo()` function, which does the same thing but more concisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: (Using an arrow function would make for even shorter code.) You can understand
    this code by realizing that it uses the associative property we mentioned previously
    and pipes the first function to the second; then, it pipes this result to the
    third function, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Which version is better? I would say that the version that refers to the `pipeTwo()`
    function is clearer: if you know how `reduce()` works, you can readily understand
    that our pipeline goes through the functions two at a time, starting from the
    first—and that matches what you know about how pipes work. The other versions
    we wrote are more or less declarative, but not as simple to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: We didn’t look at typing for all our pipelining functions, so let’s do that
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Typing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we pipeline several functions, a function’s output type should be the
    same as the following function’s parameter type. Let’s have an auxiliary `FnsMatchPipe<>`
    type to check whether two types satisfy this condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This works recursively. If we have a single function in the pipeline (the length
    of `FNS` is `1`), then we return `boolean` to signify success. If we have more
    than one function, we take the first and second functions, check that the parameter
    of the latter is the same type as the return type of the former, and apply recursion
    to check types from the second function onward. If there’s no match in types,
    we return `never` to mark a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, what’s the type of the pipeline? The type of its arguments will match
    the first function’s argument type, and the type of the result will match the
    last function’s result type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We first verify that the function’s types are correct, using `FnsMatchPipe<>`.
    If the types match, the type of the whole pipeline is that of a function that
    gets arguments of the same type as the first function in the pipeline and returns
    a value of the same type as the last pipelined function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, our pipelines can be properly written – and we’ll have to use the same
    “overloading” as in the previous chapter to help TypeScript work out types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Before we look at other ways to connect functions, let’s consider how we would
    debug our pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s turn to a practical question: how do you debug your code? With pipelining,
    you can’t see what’s passed on from function to function, so how do you do it?
    We have two answers for that: one (also) comes from the Unix/Linux world, and
    the other (the most appropriate for this book) uses wrappers to provide some logs.'
  prefs: []
  type: TYPE_NORMAL
- en: Using tee
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first solution we’ll use implies adding a function to the pipeline, which
    will just log its input. We want to implement something similar to the `tee` Linux
    command, which can intercept the standard data flow in a pipeline and send a copy
    to an alternate file or device. Remembering that `/dev/tty` is the usual console,
    we could execute something similar to the following and get an onscreen copy of
    everything that passes using the `tee` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We could write a similar function with ease:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Comma power!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are aware of the uses of the comma operator, you can be more concise
    and write `const tee2 = <A>(arg: A) => (console.log(arg), arg)`—do you see why?
    Check out [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)
    for the answer!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our logging function is short and to the point: it will receive a single argument,
    list it, and pass it on to the following function in the pipe. We can see it working
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: It would be even better if our `tee()` function could receive a logger function
    as a parameter, as in the *Logging in a functional way* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions*; it’s just a matter of making the same kind of change we
    managed there. The same good design concepts are applied again!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This function works exactly in the same way as the previous `tee()`, although
    it will allow us to be more flexible when it comes to applying and testing. However,
    in our case, this would just be an extra enhancement to an already easily-testable
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an even more generic tapping function, with more possibilities
    than just doing a bit of logging.
  prefs: []
  type: TYPE_NORMAL
- en: Tapping into a flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you wish, you could write an enhanced `tee()` function to produce more debugging
    information, send the reported data to a file or remote service, and so on—there
    are many possibilities you can explore. You could also explore a more general
    solution, of which `tee()` would be a particular case and allow us to create personalized
    tapping functions. This can be seen in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Tapping allows you to apply a function so that you can inspect
    data as it ﬂows through the pipeline](img/Figure_8.2_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Tapping allows you to apply a function so that you can inspect
    data as it ﬂows through the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with pipelines, you may want to put a logging function in the
    middle of them, or you might want some other kind of *snooping* function—possibly
    for storing data somewhere, calling a service, or some other kind of side effect.
    We could have a generic `tap()` function to allow us to inspect data as it moves
    along our pipeline, which would behave in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a candidate for the *trickiest-looking code-in-the-book* award, so
    let’s explain it. We want to produce a function that, given a function, `fn()`,
    and an argument, `x`, will evaluate `fn(x)` (to produce whatever sort of side
    effect we may be interested in) but return `x` (so the pipeline goes on without
    interference). The comma operator has exactly that behavior: if you write something
    similar to `(a, b, c)`, JavaScript will evaluate the three expressions in order
    and use the last value as the expression’s value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we can use currying to produce several different tapping functions. The
    one we wrote in the previous section, `tee()`, could also be written in the following
    fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'By the way, you could have also written `tap()` without currying, but you’ll
    have to admit it loses some of its mystery! This is demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This does exactly the same job, and you’ll recognize this way of currying from
    the *Currying by hand* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*,
    Transforming Functions*. Now that we have learned how to tap into a pipeline,
    let’s move on to a different way of logging by revisiting some concepts we looked
    at in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using a logging wrapper
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The second idea we mentioned is based on the `addLogging()` function we wrote
    in the *Logging* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions*. The idea was to wrap a function with some logging functionality
    so that, on entry, the arguments would be printed and, on exit, the result of
    the function would be shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can trivially verify that the `pipeline()` function is doing its thing correctly—whatever
    a function produces as a result is given as input to the next function in the
    line, and we can also understand what’s happening with each call. Of course, you
    don’t need to add logging to every function in the pipeline: you would probably
    do so in places where you suspected an error was occurring.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at how to join functions, let’s look at a common way of
    defining functions in FP, *pointfree style*, which you may encounter.
  prefs: []
  type: TYPE_NORMAL
- en: Pointfree style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you join functions together, either in a pipeline or with composition,
    as we’ll see later in this chapter, you don’t need any intermediate variables
    to hold the results that will become arguments to the following function in line:
    they are implicit. Similarly, you can write functions without mentioning their
    parameters; this is called the *pointfree style*.'
  prefs: []
  type: TYPE_NORMAL
- en: (By the way, pointfree style is also called *tacit* programming and *pointless*
    programming by detractors! The term point itself means a function parameter, while
    pointfree refers to not naming those parameters.)
  prefs: []
  type: TYPE_NORMAL
- en: Defining pointfree functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can easily recognize a pointfree function definition because it doesn’t
    need the `function` keyword or the `=>` arrow. Let’s revisit some of the previous
    functions we wrote in this chapter and check them out. For example, the definition
    of our original file-counting functions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code could be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The new definitions don’t reference the parameter for the newly defined functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can deduce this by examining the first function in the pipeline (`getDir()`,
    in this case) and seeing what it receives as arguments. (Using type signatures,
    as we’ll see in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building Better
    Containers*, is of great help in terms of documentation, and complements TypeScript
    types.) In our *Revisiting an example* section, we could have written a `getLat()`
    function to get the `lat` field out of an object in a pointfree fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'What should the equivalent full-style definition be? You’d have to examine
    the `getField()` function (we looked at this in the *Revisiting an example* section)
    to decide that it expects an object as an argument. However, making that need
    explicit by writing the following wouldn’t make much sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were willing to write all this, you might wish to stick with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Then, you simply wouldn’t need to worry about currying!
  prefs: []
  type: TYPE_NORMAL
- en: Converting to pointfree style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the other hand, you had better pause for a minute and try not to write everything
    in pointfree code, at any cost. For example, consider the `isNegativeBalance()`
    function we wrote back in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing
    Functions*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Can we write this in a pointfree style? Yes, we can, and we’ll see how—but
    I’m not sure we’d want to code this way! We can consider building a pipeline of
    two functions: one will extract the balance from the given object, while the other
    will check whether it’s negative. Due to this, we will write our alternative version
    of the balance-checking function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To extract the `balance` attribute from a given object, we can use `getField()`
    and a bit of currying, and write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second function, we could write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'There goes our pointfree goal! Instead, we can use the `binaryOp()` function,
    also from the same chapter we mentioned earlier, plus some more currying, to write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'I wrote the test the other way around (`0>x` instead of `x<0`) just for ease.
    An alternative would have been to use the enhanced functions I mentioned in the
    *A handier implementation* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, which is a bit less complex, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'So, finally, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Is that an improvement? Our new versions of `isNegativeBalance()` don’t make
    a reference to their argument and are fully pointfree, but the idea of using pointfree
    style should be to help improve the clarity and readability of your code and not
    to produce obfuscation and opaqueness! I doubt anybody would look at our new versions
    of the function and consider them to be an advantage over the original.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find that your code is becoming harder to understand due to using pointfree
    programming, stop and roll back your changes. Remember our doctrine for this book:
    we want to do FP, but we don’t want to go overboard with it—and using the pointfree
    style is not a requirement!'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ve learned how to build pipelines of functions—this is
    a powerful technique. For objects and arrays, however, we have another special
    technique that you may have used already: *chaining*. Let’s take a look at this
    now.'
  prefs: []
  type: TYPE_NORMAL
- en: Chaining and fluent interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you work with objects or arrays, there is another way of linking the execution
    of several calls together: by applying *chaining*. For example, when you work
    with arrays, if you apply a `map()` or `filter()` method, the result is a new
    array, to which you can then apply another `map()` or `filter()` function, and
    so forth. We used these methods when we defined the `range()` function back in
    the *Working with ranges* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*,*
    *Programming Declaratively*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: First, we created a new array; then, we applied the `fill()` method to it, which
    updated the array in place (side effect) and returned the updated array, to which
    we finally applied a `map()` method. The latter method generated a new array,
    to which we could have applied further mapping, filtering, or any other available
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at a common example of fluent APIs, which work by chaining,
    and then consider how we can do this on our own.
  prefs: []
  type: TYPE_NORMAL
- en: An example of fluent APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This style of continuous chained operations is also used in fluent APIs or
    interfaces. To give just one example, the graphic `D3.js` library (see [d3js.org](http://d3js.org)
    for more on it) frequently uses this style. The following example, taken from
    [bl.ocks.org/mbostock/4063269](http://bl.ocks.org/mbostock/4063269), shows it
    in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Each method works on the previous object and provides access to a new object
    to which future method calls will be applied (such as the `selectAll()` or `append()`
    methods) or updates the current one (as the `attr()` attribute setting calls do).
    This style is not unique, and several other well-known libraries (jQuery comes
    to mind) also apply it.
  prefs: []
  type: TYPE_NORMAL
- en: Can we automate this? In this case, the answer is “possibly, but I’d rather
    not.” I think using `pipeline()` or `compose()` works just as well and achieves
    the same thing. With object chaining, you are limited to returning new objects
    or arrays or something that methods can be applied to. (Remember, if you are working
    with standard types, such as strings or numbers, you can’t add methods to them
    unless you mess with their prototype, which isn’t recommended!). With composition,
    however, you can return any value; the only restriction is that the next function
    in line must expect the data type you provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you are writing your own API, you can provide a fluent
    interface by just having each method return `this`—unless it needs to return something
    else! If you were working with someone else’s API, you could also do some trickery
    by using a proxy. However, be aware that there may be cases in which your proxied
    code might fail: maybe another proxy is being used, or there are some getters
    or setters that somehow cause problems, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: On proxies
  prefs: []
  type: TYPE_NORMAL
- en: You may want to read up on proxy objects at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
    – they are very powerful and allow for interesting metaprogramming functionalities.
    Still, they can trap you with technicalities and will cause an (albeit slight)
    slowdown in your proxied code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now look at how to chain calls so we can do this with any class.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining method calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go for a basic example. We have a `City` class with `name`, latitude
    (`lat`), and longitude (`long`) attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a common class with a few methods; everything’s quite normal. We could
    use this class as follows and provide details about my native city, Montevideo,
    Uruguay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted the setters to be handled in a fluent manner, we could set up
    a proxy to detect these calls and provide the missing `return this`. How can we
    do that? If the original method doesn’t return anything, JavaScript will include
    a `return undefined` statement by default so that we can detect whether that’s
    what the method returns and substitute `return this` instead. Of course, this
    is a problem: what would we do if we had a method that could legally return `undefined`
    because of its semantics? We could have some kind of exceptions list to tell our
    proxy not to add anything in those cases, but let’s not get into that.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for our handler is as follows. Whenever the method of an object is
    invoked, a `get()` is implicitly called, and we catch it. If we get a function,
    we wrap it with some code of our own that will call the original method and then
    decide whether to return its value or a reference to the proxied object instead.
    If we didn’t get a function, we would return the requested property’s value. Our
    `chainify()` function will take care of assigning the handler to an object and
    creating the needed proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We must check whether the invoked `get()` was for a function or an attribute.
    In the first case, we wrap the method with extra code so that it will execute
    it and then return its results (if any) or a reference to the object itself. In
    the second case, we return the attribute, which is the expected behavior. (For
    the use of `Reflect.get()`, check out [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get).)
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s the type of a “chainified” object? Any property that isn’t a function
    is the same. A property that is a function that returns some non-`void` value
    is also still the same. However, if a function returns `void`, we wrap it, so
    it returns the object itself. The `Chainify<>` type definition does that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, we can chainify any object so that we can inspect any called method.
    As I’m writing this, I’m currently living in Pune, India, so let’s reflect that
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type of `myCity2` (which is chainified) is different from the type of `myCity`.
    For instance, `myCity2.setLong()` is now of the `setLong(newLong: number): Chainify<City>`
    type instead of `setLong(newLong: number): void` as before. (See *Question 8.8*.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We call several setters in a fluent manner, and they are working fine since
    our proxy is taking care of providing the value for the following call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The calls to `getCoords()` and `getName()` are intercepted, but nothing special
    is done because they already return a value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is working in a chained way worth it? That’s up to you—but remember that there
    may be cases in which this approach fails, so be wary! Now, let’s move on to composing,
    the other most common way of joining functions.
  prefs: []
  type: TYPE_NORMAL
- en: Composing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Composing* is quite similar to pipelining, but has its roots in mathematical
    theory. The concept of composition is a sequence of function calls in which the
    output of one function is the input for the next one—but in the opposite order
    to when pipelining. So, if you have a series of functions, from left to right,
    when pipelining, the first function of the series to be applied is the leftmost
    one, but when you use composition, you start with the rightmost one.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s investigate this a bit more. When you define the composition of, say,
    three functions as (`f`∘`g`∘`h`) and apply this composition to `x`, this is equivalent
    to writing `f(g(h(x)))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to note that, as with pipelining, the arity of the first function
    to be applied (actually the last one in the list) can be anything, but all the
    other functions must be unary. Also, besides the difference in the sequence of
    function evaluation, composing is an important tool in FP: it abstracts the implementation
    details (putting your focus on what you need to accomplish rather than on the
    specific details for achieving that), thereby letting you work in a more declarative
    fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip for reading
  prefs: []
  type: TYPE_NORMAL
- en: If it helps, you can read (*f*∘*g*∘*h*) as “*f* after *g* after *h*” so that
    it becomes clear that *h* is the first function to be applied, while *f* is the
    last.
  prefs: []
  type: TYPE_NORMAL
- en: Given its similarity to pipelining, it will be no surprise that implementing
    composition isn’t very hard. However, there are still some important and interesting
    details. Let’s see some examples of composition before moving on to using higher-order
    functions and finishing with some considerations about testing composed functions.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It may not be a surprise to you, but we have already seen several examples of
    composition—or, at the very least, cases in which the solutions we achieved were
    functionally equivalent to using composition. Let’s review some of these and work
    with some new examples too.
  prefs: []
  type: TYPE_NORMAL
- en: Unary operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the *Logically negating a function* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we wrote a `not()` function that, given another function,
    would logically invert its result. We used that function to negate a check for
    negative balances; the sample code for this (and I’m going with plain JavaScript
    here, for clarity) could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In another section (*Turning operations into functions*) of that chapter, I
    left you with the challenge of writing a `unaryOp()` function that would provide
    unary functions equivalent to common JavaScript operators. If you met that challenge,
    you should be able to write something such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the existence of a `compose()` function, you could have also written
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Which one do you prefer? It’s a matter of taste—but I think the second version
    clarifies what we are trying to do better. With the `not()` function, you must
    check what it does to understand the general code. With composition, you still
    need to know what `logicalNot()` is, but the global construct is open to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look at just one more example in the same vein, you could have achieved
    the same results that we got in the *Inverting the results* section in the same
    chapter. Recall that we had a function that could compare strings according to
    the rules of Spanish, but we wanted to invert the result of the comparison so
    that it was sorted in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This code produces the same result that our previous sorting problem did, but
    the logic is expressed more clearly and with less code: a typical FP result! Let’s
    look at some more examples of composing functions by reviewing another task we
    discussed earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: Counting files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also go back to our pipeline. We wrote a single-line function to count
    the `odt` files in a given path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Disregarding (at least for the moment) the observation that this code is not
    as clear as the pipeline version that we developed later, we could have also written
    this function with composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also see this written in a one-liner fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Even if it’s not as clear as the pipeline version (and that’s just my opinion,
    which may be biased due to my liking of Linux!), this declarative implementation
    makes it clear that we depend on combining three distinct functions to get our
    result—this is easy to see and applies the idea of building large solutions out
    of simpler pieces of code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at another example that’s designed to compose as many functions
    as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Finding unique words
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, let’s go for another example, which, I agree, could have also been
    used for pipelining. Suppose you have some text and want to extract all the unique
    words from it: how would you go about doing so? If you think about it in steps
    (instead of trying to create a full solution in one go), you would probably come
    up with a solution similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore all non-alphabetic characters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put everything in uppercase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Split the text into words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a set of words.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: (Why a set? Because it automatically discards repeated values; check out [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set)
    for more on this. By the way, we will use the `Array.from()` method to produce
    an array out of our set; see [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
    for more on this.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, using FP, let’s solve each problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'With these functions, the result can be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Since you don’t get to see the arguments of any of the composed functions, you
    don’t need to show the parameter for `getUniqueWords()` either, so the pointfree
    style is natural in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s test our function. To do this, let’s apply this function to the
    first two sentences of Abraham Lincoln’s address at Gettysburg (which we already
    used in an example back in the *Mapping and flattening – flatMap* section of [*Chapter
    5*](B19301_05.xhtml#_idTextAnchor084)*, Programming Declaratively*) and print
    out the 43 different words (trust me, I counted them!) in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Of course, you could have written `getUniqueWords()` more succinctly, but the
    point I’m making is that by composing your solution out of several shorter steps,
    your code is clearer and easier to grasp. However, if you wish to say that a pipelined
    solution seems better, it’s just a matter of opinion!
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at many examples of function composition at this point, but there’s
    another way to manage this—by using higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: Composing with higher-order functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Evidently, composing by hand can be done similarly to pipelining. For example,
    the unique word-counting function that we wrote previously could be written in
    simple JavaScript style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it could be written more concisely (but more obscurely!) in
    a one-liner style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This works fine, but as when we studied pipelining, let’s look for a more general
    solution that won’t require writing a new particular function every time we want
    to compose some other functions.
  prefs: []
  type: TYPE_NORMAL
- en: Composing two functions is relatively easy and requires making a small change
    to our `pipeTwo()` function, which we looked at earlier in this chapter. We just
    have to exchange `f` and `g` to get the new definition!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference is that, with piping, you apply the leftmost function first,
    while with composing, you start with the rightmost function first. This variation
    suggests that we could have used the `flipTwo()` higher-order function from the
    *Parameter order* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*,
    Transforming Functions*. Is it clearer? Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'In any case, if we want to compose more than two functions, we can take advantage
    of the associative property and write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though this works, let’s go for a better solution—we can provide several.
    We could use a loop like when we wrote our first pipelining function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also note that pipelining and composing work in opposite directions.
    We apply functions from left to right when pipelining, and from right to left
    when composing. Thus, we can achieve the same result we achieved with composition
    by reversing the order of the functions and doing pipelining instead; a very functional
    solution, which I really like! This is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The only tricky part is the usage of the spread operator before calling `pipeline()`.
    After reversing the `fns` array, we must spread its elements to call `pipeline()`
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yet another solution, less declarative, is to use `reduceRight()` so that instead
    of reversing the list of functions, we reverse the order of processing them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Why and how does this work? Let’s look at the inner workings of this call:'
  prefs: []
  type: TYPE_NORMAL
- en: Since no initial value is provided, `f()` is `removeNonAlpha()` and `g()` is
    `toUpperCase()`, so the first intermediate result is a function, `(...args) =>
    toUpperCase(removeNonAlpha(...args))`; let’s call it `step1()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second time, `f()` is `step1()` from the previous step, while `g()` is `splitInWords()`,
    so the new result is a function, `(...args) => splitInWords(step1(...args)))`,
    which we can call `step2()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third time around, in the same fashion, we get `(...args) => arrayToSet(step2(...args))))`,
    which we call `step3()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the result is `(...args) => setToList(step3(...args))`, a function;
    let’s call it `step4()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final result turns out to be a function that receives `(...args)` and starts
    by applying `removeNonAlpha()` to it, then `toUpperCase()`, and so on, before
    finishing by applying `setToList()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may come as a surprise that we can also make this work with `reduce()`—can
    you see why? The reasoning is similar to what we did previously, so we’ll leave
    this as an exercise for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: A symmetric challenge!
  prefs: []
  type: TYPE_NORMAL
- en: After working out how `compose3()` works, you might want to write a version
    of `pipeline()` that uses `reduceRight()`, just for symmetry, to round things
    out!
  prefs: []
  type: TYPE_NORMAL
- en: Data typing for composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given what we did for pipelining, data typing for composition is very much
    the same, and we’ll follow what we did in parallel. First, we’ll have an auxiliary
    type to check whether our functions’ types can be composed correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This is essentially the same as what we wrote for pipelining, except that we
    process functions from right to left. With this done, we can now write our `Compose<>`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This is also what we had for pipelining, except for the type of the result,
    which is symmetrical. Finally, we can apply types to our composing functions;
    let’s see just one example, because (logically!) typing is the same for all the
    versions of our code!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have looked at the important methods we can use to connect functions
    using pipelining, chaining, and composition. All this works very well, but we’ll
    see that there’s a particular case in which the performance of your code can be
    affected and that will require a new way to handle composition: *transducing*.'
  prefs: []
  type: TYPE_NORMAL
- en: Transducing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s consider a performance problem in JavaScript that happens when we’re
    dealing with large arrays and applying several `map()`, `filter()`, or `reduce()`
    operations. If you start with an array and apply these operations (via chaining,
    as we saw earlier in this chapter), you get the desired result. However, many
    intermediate arrays are created, processed, and discarded—and that causes delays.
    If you are dealing with small arrays, the extra time won’t make an impact, but
    with larger arrays (as in a big data process, maybe in Node.js, where you’re working
    with the results of a large database query), then you will probably have to need
    some optimization. We’ll do this by learning about a new tool for composing functions:
    *transducing*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create some functions and data. We’ll make do with a nonsensical
    example since we aren’t focusing on the actual operations but on the general process.
    We’ll start with some filtering functions and some mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s apply those maps and filters to an array. First, we drop the even
    numbers, duplicate the odd numbers, drop results over 50, and end by adding 3
    to all the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows how this sequence of operations works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Chaining map/ﬁlter/reduce operations causes intermediate arrays
    to be created and later discarded](img/Figure_8.3_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Chaining map/ﬁlter/reduce operations causes intermediate arrays
    to be created and later discarded
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can see that chaining together several `map()`, `filter()`, and `reduce()`
    operations causes intermediate arrays (three, in this case) to be created and
    later discarded—and for large arrays, that can become cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we optimize this? The problem here is that processing applies the first
    transformation to the input array; then, the second transformation is applied
    to the resulting array; then the third, and so on. An alternative solution would
    be to take the first element of the input array and apply all the transformations
    in sequence to it. Then, you would need to take the second element of the input
    array and apply all the transformations to it, then take the third, and so on.
    In pseudocode, the difference is between this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And then this approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: With the first logic, we go transformation by transformation, applying it to
    each list and generating a new one. This requires several intermediate lists to
    be produced. With the second logic, we go element by element and apply all the
    transformations to each one in sequence to arrive at the final output list without
    any intermediate lists being created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the problem is being able to transpose the transformations; how can we
    do this? We saw this key concept in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, and we can define `map()` and `filter()` in terms
    of `reduce()`. Using those definitions, instead of a sequence of different functions,
    we will apply the same operation (`reduce()`) at each step, and here is the secret!
    As shown in the following diagram, we change the order of evaluation by composing
    all the transformations so that they can be applied in a single pass with no intermediate
    arrays whatsoever:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – By applying transducers, we will change the order of evaluation
    but get the same result](img/Figure_8.4_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – By applying transducers, we will change the order of evaluation
    but get the same result
  prefs: []
  type: TYPE_NORMAL
- en: Instead of applying a first `reduce()` operation, passing its result to a second,
    its result to a third, and so on, we will compose all the reducing functions into
    a single one! Let’s analyze this.
  prefs: []
  type: TYPE_NORMAL
- en: Composing reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Essentially, what we want is to transform each function (`testOdd()`, `duplicate()`,
    and so on) into a reducing operation that will call the following reducer. A couple
    of higher-order functions will help; one for mapping functions and another for
    filtering ones. With this idea, the result of an operation will be passed to the
    next one, avoiding intermediate arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'These two transforming functions are *transducers*: functions that accept a
    reducing function and return a new reducing function. (Some trivia: the word *transduce*
    comes from Latin, meaning transform, transport, convert, change over, and is applied
    in many different fields, including biology, psychology, machine learning, physics,
    electronics, and more.)'
  prefs: []
  type: TYPE_NORMAL
- en: Typing is not too hard. For mapping, we assume a mapping function that gets
    a value of type `V` and produces a result of type `W`. The generic reducer takes
    an accumulator of type `A` and a value of type `W` and produces a new accumulator,
    also of type `A`. For filtering, the filtering function gets a value of type `V`
    and produces a `Boolean` value, and the reducer gets an accumulator of type `A`
    and a value of type `V`, returning a type `A` result.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we use these transducers? We can write code such as the following, although
    we’ll want a more abstract, generic version later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Each of our original four functions is transformed, so they will calculate their
    result and call a reducer to deal with this further. As an example, `addThreeR()`
    will add three to its input and pass the incremented value to the next reducer,
    which in this case is `addToArray()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will build up the final resulting array. Now, we can write our whole transformation
    in a single step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite a mouthful, but it works! However, we can simplify our code by
    using the `compose()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is the same, but pay particular attention to the `compose(...fns)(addToArray)`
    expression: we compose all the mapping and filtering functions—with the last one
    being `addToArray`—to build up the output. However, this is not as general as
    we may want it to be: why do we have to create an array? Why can’t we have a different
    final reducing function? We can go one better by generalizing a bit more.'
  prefs: []
  type: TYPE_NORMAL
- en: Generalizing for all reducers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To be able to work with all kinds of reducers and produce whatever kind of
    result they build, we’ll need to make a small change. The idea is simple: let’s
    modify our `transduce()` function so that it will accept a final reducer and a
    starting value for the accumulator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this function more usable, we specified our array-building function
    (and an empty array as a starting accumulator value) so that if you skip those
    two parameters, you’ll get a reducer that produces an array. Now, let’s look at
    the other option: instead of an array, let’s calculate the sum of the resulting
    numbers after all the mapping and filtering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: By using transducers, we have been able to optimize a sequence of `map`, `filter`,
    and `reduce` operations so that the input array is processed once and directly
    produces the output result (whether an array or a single value) without creating
    any intermediate arrays; a good gain!
  prefs: []
  type: TYPE_NORMAL
- en: We’ve seen several ways of connecting functions; to round this off, let’s see
    how to write unit tests for connected functions.
  prefs: []
  type: TYPE_NORMAL
- en: Testing connected functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s finish by considering testing for functions connected in all the ways
    we’ve seen in this chapter. Given that the mechanisms for pipelining and composition
    are similar, we will look at examples of both. They won’t differ, other than their
    logical differences due to the left-to-right or right-to-left order of function
    evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Testing pipelined functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to pipelining, we can start by looking at how to test the `pipeTwo()`
    function since the setup will be similar to `pipeline()`. We need to create some
    mocks and check whether they were called the correct number of times and whether
    they received the correct arguments each time. We will set them to provide a known
    answer to a call.
  prefs: []
  type: TYPE_NORMAL
- en: 'By doing this, we can check whether the output of a function becomes the input
    of the next function in the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: There is little to test given that our function always receives two functions
    as parameters. The only difference between the tests is that one shows a pipeline
    applied to a single argument, while the other shows it applied to several arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to `pipeline()`, the tests would be quite similar. However, we can
    add a test for a single-function pipeline (a border case!) and another with four
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Testing composed functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For composition, the style is the same (except that the order of function evaluation
    is reversed), so let’s take a look at a single test—here, I simply changed the
    order of the functions in the preceding test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Testing chained functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test the `chainify()` function, I opted to use the preceding `City` object
    I created—I didn’t want to mess with mocks, stubs, spies, and the like; I wanted
    to ensure that the code worked under normal conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Testing transduced functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We tried several examples earlier in the chapter, and it’s easy to turn them
    into tests. We’ll also add new tests for border cases (for instance, just one
    function, only mapping functions, etc.) for more generality. For simplicity, I
    kept using the same data array and mapping and filtering functions I used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result of all of these tests can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – A successful run of testing for connected functions](img/Figure_8.5_B19301.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – A successful run of testing for connected functions
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, all our tests passed successfully; good!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to create new functions by joining several other
    functions in different ways using pipelining and composition. We also looked at
    fluent interfaces, which apply chaining, and transducing, a way to compose reducers
    to get higher-speed sequences of transformations. With these methods, you’ll be
    able to create new functions out of existing ones and keep programming in the
    declarative way we favor.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*, we
    will move on to function design and study the usage of recursion, which is a basic
    tool in FP and allows for very clean algorithm designs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '8.1 `headline(sentence)` function that will receive a string as an argument
    and return an appropriately capitalized version. Spaces separate words. Build
    this function by connecting smaller functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '8.2 `done===true`) or pending (`done===false`). Your goal is to produce an
    array with the IDs of the pending tasks for a given person, identified by name,
    which should match the responsible field. Solve this by using composition or pipelining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Ensure your code doesn’t throw an exception if, for example, the person you
    are looking for doesn’t appear in the web service result!
  prefs: []
  type: TYPE_NORMAL
- en: '8.3 **Thinking in abstract terms**: Suppose you are looking through somewhat
    old code and find a function that looks like the following one. (I’m keeping the
    names vague and abstract so that you can focus on the structure and not on the
    actual functionality). Can you transform this into pointfree style?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 8.4 `Compose<>` type using the `Pipeline<>` type plus a new `Reverse<>` type.
    What should that new type be?
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 **Empty pipeline?** Do our pipelining functions work with an empty array
    of functions? Can you fix that?
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 `addToArray()` function we wrote is actually impure? (Check out the *Argument
    mutation* section of [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069)*, Behaving
    Properly,* if you aren’t convinced!) Would it be better if we wrote it as follows?
    Should we go for it?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 8.7 `map()` operations? What if you only had `filter()` operations?
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 `myCity2` object was not the same as the type of the original `myCity` one.
    What is its type exactly?
  prefs: []
  type: TYPE_NORMAL
