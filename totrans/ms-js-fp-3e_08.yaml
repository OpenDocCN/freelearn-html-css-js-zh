- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Connecting Functions – Pipelining, Composition, and More
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接函数——流水线、组合以及更多
- en: 'In [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128), *Transforming Functions*,
    we looked at ways to build new functions by applying higher-order functions. In
    this chapter, we will go to the core of FP and learn how to create sequences of
    function calls and how to combine them to produce a more complex result out of
    several simpler components. To do this, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B19301_07.xhtml#_idTextAnchor128) *变换函数*中，我们探讨了通过应用高阶函数构建新函数的方法。在本章中，我们将深入FP的核心，学习如何创建函数调用序列以及如何将它们组合以从几个更简单的组件中产生更复杂的结果。为此，我们将涵盖以下主题：
- en: '**Pipelining**: A way to join functions, similar to Unix/Linux pipes'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流水线**：一种连接函数的方式，类似于Unix/Linux的管道'
- en: '**Chaining**: A variant of pipelining, but restricted to objects'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链式操作**：流水线的一种变体，但仅限于对象'
- en: '**Composing**: A classic operation with its origins in basic computer theory'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合**：一种起源于基本计算机理论的经典操作'
- en: '`map`, `filter`, or `reduce` operations'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`、`filter`或`reduce`操作'
- en: 'Along the way, we will be touching on related concepts, such as the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程中，我们将涉及一些相关概念，例如以下内容：
- en: '**Pointfree style**, which is often used with pipelining and composition'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态风格**，通常与流水线和组合一起使用'
- en: '**Debugging** of composed or piped functions, for which we’ll whip up some
    auxiliary tools'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**组合或流水线函数，我们将准备一些辅助工具'
- en: '**Testing** for these functions, which won’t prove to be of high complexity'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**这些函数，它们不会证明具有高复杂性'
- en: Armed with these techniques, you’ll be able to combine small functions to create
    larger ones, which is a characteristic of FP and will help you develop better
    code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些技术，你将能够将小函数组合成更大的函数，这是FP（函数式编程）的一个特点，并将帮助你编写更好的代码。
- en: Pipelining
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流水线
- en: 'Pipelining and composition are techniques that are used to set up functions
    to work in sequence so that the output of a function becomes the input for the
    following function. There are two ways of looking at this: from a computer point
    of view, and from a mathematical point of view. We’ll look at both in this section.
    Most FP texts start with the latter, but since I assume that most of you will
    prefer computers over math, let’s start with the former instead.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**流水线**和**组合**是用于设置函数按顺序工作的技术，以便一个函数的输出成为下一个函数的输入。看待这个问题有两种方式：从计算机的角度和从数学的角度。在本节中，我们将探讨这两种方式。大多数FP（函数式编程）文本都是从后者开始的，但鉴于我假设你们大多数人更倾向于计算机而不是数学，让我们从前者开始。'
- en: Piping in Unix/Linux
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unix/Linux中的管道
- en: 'In Unix/Linux, executing a command and passing its output as input to a second
    command, whose output will yield the input of a third command, and so on, is called
    a pipeline. This is quite a common application of the philosophy of Unix, as explained
    in a Bell Laboratories article written by the creator of the pipelining concept
    himself, Doug McIlroy:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix/Linux中，执行一个命令并将它的输出作为输入传递给第二个命令，该命令的输出将作为第三个命令的输入，依此类推，这被称为流水线。这是Unix哲学的一种相当常见的应用，正如管道概念创造者、贝尔实验室的Douglas
    McIlroy在贝尔实验室的文章中所解释的：
- en: Make each program do one thing well. To do a new job, build afresh rather than
    complicating old programs by adding new features.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让每个程序只做好一件事。要完成一项新工作，最好是重新构建，而不是通过添加新功能来复杂化旧程序。
- en: Expect the output of every program to become the input to another, so far unknown
    program.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期望每个程序输出都成为另一个尚未知的程序的输入。
- en: A bit of history
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一点历史
- en: Given the historical importance of Unix, I’d recommend reading some of the seminal
    articles describing the (then new) operating system in the Bell System Technical
    Journal, July 1978, at [emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf](http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf).
    The two quoted rules are in the *Style* section of the *Foreword* article.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到Unix的历史重要性，我建议阅读一些在1978年7月的《贝尔系统技术期刊》中描述（当时新）操作系统的开创性文章，可以在[emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf](http://emulator.pdp-11.org.ru/misc/1978.07_-_Bell_System_Technical_Journal.pdf)找到。引用的两个规则在序言文章的*风格*部分。
- en: 'Let’s consider a simple example to get started. Suppose I want to know how
    many LibreOffice text documents there are in a directory. There are many ways
    to do this, but the following example will do. We will execute three commands,
    piping (that’s the meaning of the `|` character) each command’s output as input
    to the next one. Suppose we have `cd /home/fkereki/Documents` and then do the
    following (please ignore the dollar sign, which is just the console prompt):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的例子来开始。假设我想知道目录中有多少个LibreOffice文本文档。有很多种方法可以做到这一点，但以下示例将做到。我们将执行三个命令，将每个命令的输出作为输入传递给下一个命令。假设我们有`cd
    /home/fkereki/Documents`然后执行以下操作（请忽略美元符号，它只是控制台提示符）：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What does this mean? How does it work? We have to analyze this process step
    by step:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么意思？它是如何工作的？我们必须逐步分析这个过程：
- en: The first part of the pipeline, `ls -1`, lists all the files in the current
    directory (`/home/fkereki/Documents`, as per our `cd` command) in a single column,
    with one filename per line
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道的第一个部分，`ls -1`，将当前目录（根据我们的`cd`命令，即`/home/fkereki/Documents`）中的所有文件以单列形式列出，每行一个文件名
- en: The output from the first command is provided as input to `grep "odt$"`, which
    filters (only lets pass) lines that finish with `"odt"`, the standard file extension
    for LibreOffice Writer
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个命令的输出被提供给`grep "odt$"`，它过滤（只允许通过）以`"odt"`结尾的行，这是LibreOffice Writer的标准文件扩展名
- en: The filtered output is provided to the counting command, `wc -l`, which counts
    how many lines there are in its input
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤后的输出提供给计数命令`wc -l`，它计算其输入中的行数
- en: More on pipelining
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于管道（pipelining）的内容
- en: You can find out more about pipelines in *Section 6.2*, *Filters*, of *The UNIX
    Time-Sharing System* by Dennis Ritchie and Ken Thompson, also in the issue of
    the Bell Laboratories journal that I mentioned previously.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Dennis Ritchie和Ken Thompson的《UNIX时间共享系统》的*第6.2节*，*过滤器*中了解更多关于管道的信息，这本书也发表在之前提到的贝尔实验室期刊上。
- en: 'From the point of view of FP, this is a key concept. We want to build more
    complex operations out of simple, single-purpose, shorter functions. Pipelining
    is what the Unix shell uses to apply that concept. It does this by simplifying
    the job of executing a command, taking its output, and providing it as input to
    yet another command. We will apply similar concepts in our own functional style
    in JavaScript later:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从函数式编程（FP）的角度来看，这是一个关键概念。我们希望用简单、单一用途、较短的函数构建更复杂的操作。管道是Unix shell用来应用这个概念的工具。它通过简化执行命令、获取其输出并将其作为输入提供给另一个命令的工作来实现这一点。我们将在JavaScript中稍后应用类似的概念：
- en: '![Figure 8.1 – Pipelines in JavaScript are similar to Unix/Linux pipelines.
    The output of each function becomes the input for the next](img/Figure_8.1_B19301.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – JavaScript中的管道与Unix/Linux中的管道类似。每个函数的输出成为下一个函数的输入](img/Figure_8.1_B19301.jpg)'
- en: Figure 8.1 – Pipelines in JavaScript are similar to Unix/Linux pipelines. The
    output of each function becomes the input for the next
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – JavaScript中的管道与Unix/Linux中的管道类似。每个函数的输出成为下一个函数的输入
- en: 'By the way (and no—rest assured, this isn’t turning into a shell tutorial!),
    you can make pipelines accept parameters. For example, if I happened to want to
    count how many files I had with this or that extension, I could create a function
    such as `cfe`, standing for *count* *for extension*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句（而且——请放心，这不会变成一个shell教程！），你可以使管道接受参数。例如，如果我想计算有多少文件具有这种或那种扩展名，我可以创建一个如`cfe`这样的函数，代表*计数*
    *扩展名*：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, I could use `cfe` as a command, giving it the desired extension as an
    argument:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我可以使用`cfe`作为命令，给它传递所需的扩展名作为参数：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`cfe` executes my pipeline and tells me I have four `odt` files (LibreOffice)
    and six `pdf` files; nice! We will also want to write similar parametric pipelines:
    we are not constrained to fixed functions in our flow; we have full liberty regarding
    what we want to include. Having worked in Linux, we can now go back to coding.
    Let’s see how.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`cfe`执行我的管道并告诉我有四个`odt`文件（LibreOffice）和六个`pdf`文件；太棒了！我们也会想要编写类似的参数化管道：在我们的流程中，我们不受固定函数的限制；我们完全自由地决定要包含什么。在Linux上工作过之后，我们现在可以回到编码。让我们看看如何。'
- en: Revisiting an example
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾一个例子
- en: 'We can start tying ends together by revisiting a problem from a previous chapter.
    Remember when we had to calculate the average latitude and longitude for some
    geographic data that we looked at in the *Extracting data from objects* section
    of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*, Programming Declaratively*?
    Basically, we started with some data such as the following, and the problem was
    to calculate the average latitude and longitude of the given points:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过回顾前一章中的一个问题来开始将两端连接起来。你还记得我们在[*第5章*](B19301_05.xhtml#_idTextAnchor084)*，*从对象中提取数据*部分中计算一些地理数据的平均纬度和经度时的情况吗？基本上，我们开始于以下数据，问题是要计算给定点的平均纬度和经度：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With what we know, we can write a solution in terms of the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们所知，我们可以用以下方式编写解决方案：
- en: Being able to extract the latitude (and afterward, the longitude) from each
    point
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够从每个点中提取纬度（之后，经度）
- en: Using that function to create an array of latitudes
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该函数创建纬度数组
- en: Pipelining the resulting array to the average function we wrote in the *Calculating
    an average* section of the aforementioned chapter
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果数组管道化到我们在本章前面提到的*计算平均值*部分中编写的平均函数
- en: 'To do the first task, we can use the `myMap()` function from the *Parameter
    order* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*, Transforming
    Functions*. For the second task, we can make do with the `getField()` function
    from the *Getting a property from an object* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions*. Finally, for the third task, we’ll use the (yet unwritten)
    `pipeline()` function we’ll develop soon! In full, our solution could look like
    this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成第一个任务，我们可以使用来自[*第7章*](B19301_07.xhtml#_idTextAnchor128)*，*转换函数*部分中的`myMap()`函数。对于第二个任务，我们可以使用来自[*第6章*](B19301_06.xhtml#_idTextAnchor107)*，*从对象获取属性*部分中的`getField()`函数。最后，对于第三个任务，我们将使用我们即将开发的（尚未编写的）`pipeline()`函数！完整地，我们的解决方案可能看起来像这样：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We had to add some casting to `getAllLats` so that TypeScript would know to
    what we would apply that function.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不在`getAllLats`中添加一些类型转换，这样TypeScript就会知道我们将应用该函数。
- en: Of course, you can always yield to the temptation of going for one-liners, but
    would it be much clearer or better?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你总是可以屈服于追求一行代码的诱惑，但这会使代码更清晰或更好吗？
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whether this makes sense to you will depend on your experience with FP. In any
    case, no matter which solution you take, the fact remains that adding pipelining
    (and later on, composition) to your set of tools can help you write tighter, declarative,
    simpler-to-understand code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否对你有意义将取决于你对FP的经验。无论如何，无论你选择哪种解决方案，事实仍然是，将管道化（以及稍后，组合）添加到你的工具集中可以帮助你编写更紧凑、声明性更强、更容易理解的代码。
- en: Now, let’s learn how to pipeline functions in the right way.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何正确地管道化函数。
- en: Creating pipelines
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建管道
- en: 'We want to be able to generate a pipeline of several functions. We can do this
    in two ways: by building the pipeline by hand, in a problem-specific way, or by
    using more generic constructs that can be applied with generality. Let’s look
    at both.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够生成一个包含多个函数的管道。我们可以通过两种方式做到这一点：通过手动以问题特定的方式构建管道，或者使用更通用的结构，这些结构可以普遍应用。让我们看看这两种方法。
- en: Potential pipeline proposal
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的管道提案
- en: A new operator, `|>`, is being considered for JavaScript, but it’s currently
    only at stage 2, which means it may be a while before it’s accepted and available.
    You may read more about the proposal and its varied history at [github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md](http://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的操作符`|>`正在考虑用于JavaScript，但它目前仅处于第2阶段，这意味着它可能还需要一段时间才能被接受并可用。你可以阅读更多关于这个提案及其多变历史的资料，请参阅[github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md](http://github.com/tc39/proposal-pipeline-operator/blob/main/HISTORY.md)。
- en: Building pipelines by hand
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动构建管道
- en: 'Let’s go with a Node.js example, similar to the command-line pipeline we built
    earlier in this chapter. Here, we’ll build the pipeline we need by hand. We need
    a function to read all the files in a directory. We can do that (although this
    isn’t recommended because of the synchronous call, which is normally not good
    in a server environment) with something like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个Node.js的例子来开始，类似于我们在本章早期构建的命令行管道。在这里，我们将手动构建所需的管道。我们需要一个函数来读取目录中的所有文件。我们可以用类似以下的方式做到这一点（尽管这并不推荐，因为在服务器环境中通常不推荐同步调用）：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Selecting only `odt` files is quite simple. We start with the following function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 仅选择`odt`文件相当简单。我们从以下函数开始：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function takes an array of strings and filters out elements that do not
    end with the given text, so we can now write the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个字符串数组，并过滤掉不以给定文本结尾的元素，因此我们现在可以写出以下内容：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Better still, we can apply currying and go for pointfree style, as shown in
    the *An unnecessary mistake* section of [*Chapter 3*](B19301_03.xhtml#_idTextAnchor054),
    *Starting Out with Functions*, and write this, instead:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，我们可以应用柯里化并采用无参数风格，正如在[*第3章*](B19301_03.xhtml#_idTextAnchor054)的*不必要的错误*部分所示，*从函数开始入门*，并写成这样：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Both versions of the filtering function are equivalent; which one you use comes
    down to your tastes. Finally, we can write the following to count elements in
    an array. Since `length` is not a function, we cannot apply our demethodizing
    trick:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤函数的两个版本是等价的；你使用哪个取决于你的喜好。最后，我们可以写出以下内容来计数数组中的元素。由于`length`不是一个函数，我们不能应用我们的去方法技巧：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'With these functions, we could write something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，我们可以写出类似以下的内容：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are essentially doing the same process as in Linux: getting the files, keeping
    only the `odt` ones, and counting how many files result from this. If you wanted
    to get rid of all the intermediate variables, you could also go for a one-liner
    definition that does precisely the same job in the very same way, albeit with
    fewer lines:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在执行与Linux中相同的过程：获取文件，只保留`odt`文件，并计算由此产生的文件数量。如果你想要去除所有中间变量，你也可以选择一个单行定义，它以完全相同的方式执行相同的工作，尽管行数更少：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This gets to the crux of the matter: both implementations of our file-counting
    function have disadvantages. The first definition uses several intermediate variables
    to hold the results and makes a multiline function out of what was a single line
    of code in the Linux shell. On the other hand, the second, much shorter definition
    is harder to understand, insofar as we are writing the steps of the computation
    in seemingly reverse order! Our pipeline has to read files first, then filter
    them, and finally count them, but those functions appear *the other way around*
    in our definition!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这触及了问题的核心：我们文件计数函数的两个实现都有缺点。第一个定义使用几个中间变量来保存结果，并将原本在Linux shell中一行代码的多行函数。另一方面，第二个，更短的定义更难以理解，因为我们在看似相反的顺序中编写计算步骤！我们的流水线必须首先读取文件，然后过滤它们，最后计数，但这些函数在我们的定义中却是*相反的*！
- en: We can undoubtedly implement pipelining by hand, as we have seen, but it would
    be better if we went for a more declarative style.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无疑可以手动实现流水线，就像我们看到的，但如果我们采用更声明式的风格会更好。
- en: Let’s move on and try to build a better pipeline more clearly and more understandably
    by applying some of the concepts we’ve already seen.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，尝试通过应用我们已看到的一些概念，更清晰地构建一个更好的流水线。
- en: Using other constructs
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用其他构造
- en: 'If we think in functional terms, what we have is a list of functions and we
    want to apply them sequentially, starting with the first, then applying the second
    to whatever the first function produced as its result, and then applying the third
    to the second function’s results, and so on. If we were fixing a pipeline of two
    functions, we could use the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从函数的角度思考，我们有一个函数列表，我们想要按顺序应用它们，从第一个开始，然后将第二个应用到第一个函数的结果上，然后将第三个应用到第二个函数的结果上，依此类推。如果我们正在修复两个函数的流水线，我们可以使用以下代码：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the basic definition we provided earlier in this chapter: we evaluate
    the first function, and its output becomes the input for the second function;
    relatively straightforward! Typing is simple: the first function to apply (`f()`)
    may have any number of parameters, but the second function (`g()`) must have a
    single one, the same type that `f()` returns. The return type of the pipeline
    is the return type of `g()`.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在本章早期提供的基本定义：我们评估第一个函数，其输出成为第二个函数的输入；相对简单！输入很简单：要应用的第一个函数（`f()`）可以有任意数量的参数，但第二个函数（`g()`）必须只有一个参数，其类型与`f()`返回的类型相同。流水线的返回类型是`g()`的返回类型。
- en: 'You may object, though, that this pipeline of only two functions is a bit too
    limited! This is not as useless as it may seem because we can compose longer pipelines—though
    I’ll admit that it requires too much writing! Suppose we wanted to write our three-function
    pipeline (from the previous section); we could do so in two different, equivalent
    ways:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会反对，说这个只有两个函数的管道有点太有限了！这并不像看起来那么无用，因为我们可以组合更长的管道——尽管我必须承认这需要太多的编写！假设我们想要编写我们之前章节中的三个函数管道；我们可以以两种不同但等效的方式做到这一点：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: A touch of math
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一点数学
- en: 'We are taking advantage of the fact that piping is an associative operation.
    In mathematics, the associative property is the one that says that we can compute
    1+2+3 either by adding 1+2 first and then adding that result to 3 or by adding
    1 to the result of first adding 2+3: in other terms, 1+2+3 is the same as (1+2)+3
    or 1+(2+3).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在利用管道是一种结合操作的事实。在数学中，结合性质是指我们可以通过先加1+2，然后将其结果加到3上，或者先加2+3，然后将结果加到1上，来计算1+2+3；换句话说，1+2+3等于(1+2)+3或1+(2+3)。
- en: 'How do they work? How is it that they are equivalent? Following the execution
    of a given call will be useful; it’s quite easy to get confused with so many calls!
    The first implementation can be followed step by step until the final result,
    which matches what we already know:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是如何工作的？它们是如何等效的？跟踪给定调用的执行将很有用；在这么多调用中很容易混淆！第一个实现可以一步一步地跟踪，直到最终结果，这与我们已知的结果相匹配：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The second implementation also comes to the same final result:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种实现也得到了相同的结果：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Both derivations arrived at the same final expression—the same we had written
    by hand earlier, in fact—so we now know that we can make do just with a basic
    *pipe of two* higher-order functions, but we’d really like to be able to work
    in a shorter, more compact way. A first implementation could be along the lines
    of the following, and let’s look at typing later:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 两种推导都得到了相同的结果——实际上就是之前我们手写的那个——所以我们现在知道我们只需要两个高级函数的基本“管道”，但我们确实希望能够以更短、更紧凑的方式工作。一个初步的实现可以按照以下方式，稍后再来看代码：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This does work—and specifying our file-counting pipeline is much clearer since
    the functions are given in their proper order. However, the implementation of
    the `pipeline()` function is not very functional and goes back to old, imperative,
    loop-by-hand methods. We can do better using `reduce()`, as in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实有效——并且指定我们的文件计数管道更清晰，因为函数是按照正确的顺序给出的。然而，`pipeline()`函数的实现并不太符合函数式编程，它回到了旧的、命令式的、手动循环的方法。我们可以使用`reduce()`做得更好，就像在[*第五章*](B19301_05.xhtml#_idTextAnchor084)中提到的，*声明式编程*。
- en: 'The idea is to start the evaluation with the first function, pass the result
    to the second, then that result to the third, and so on. By doing this, we can
    pipeline with shorter code, and again we’ll leave typing for later:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是从第一个函数开始评估，将结果传递给第二个函数，然后是第三个函数，依此类推。通过这种方式，我们可以用更短的代码进行管道操作，再次，我们稍后再讨论代码编写：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code is more declarative. However, you could have gone one better by writing
    it using our `pipeTwo()` function, which does the same thing but more concisely:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更具声明性。然而，如果你使用我们的`pipeTwo()`函数来编写它，效果会更好，这个函数做的是同样的事情，但更简洁：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: (Using an arrow function would make for even shorter code.) You can understand
    this code by realizing that it uses the associative property we mentioned previously
    and pipes the first function to the second; then, it pipes this result to the
    third function, and so on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: （使用箭头函数可以使代码更短。）你可以通过意识到它使用了我们之前提到的结合性质，将第一个函数管道到第二个函数；然后，它将这个结果管道到第三个函数，依此类推。
- en: 'Which version is better? I would say that the version that refers to the `pipeTwo()`
    function is clearer: if you know how `reduce()` works, you can readily understand
    that our pipeline goes through the functions two at a time, starting from the
    first—and that matches what you know about how pipes work. The other versions
    we wrote are more or less declarative, but not as simple to understand.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个版本更好？我认为引用`pipeTwo()`函数的版本更清晰：如果你知道`reduce()`是如何工作的，你就可以很容易地理解我们的管道是两个函数一次通过，从第一个开始——这与你对管道工作方式的理解相匹配。我们编写的其他版本或多或少是声明性的，但不是那么容易理解。
- en: We didn’t look at typing for all our pipelining functions, so let’s do that
    now.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有查看所有管道函数的打字，所以现在让我们来做这件事。
- en: Typing
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打字
- en: 'When we pipeline several functions, a function’s output type should be the
    same as the following function’s parameter type. Let’s have an auxiliary `FnsMatchPipe<>`
    type to check whether two types satisfy this condition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们管道化多个函数时，一个函数的输出类型应该与下一个函数的参数类型相同。让我们有一个辅助的 `FnsMatchPipe<>` 类型来检查两个类型是否满足这个条件：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This works recursively. If we have a single function in the pipeline (the length
    of `FNS` is `1`), then we return `boolean` to signify success. If we have more
    than one function, we take the first and second functions, check that the parameter
    of the latter is the same type as the return type of the former, and apply recursion
    to check types from the second function onward. If there’s no match in types,
    we return `never` to mark a failure.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这会递归地进行。如果我们管道中只有一个函数（`FNS` 的长度为 `1`），那么我们返回 `boolean` 来表示成功。如果我们有多个函数，我们取第一个和第二个函数，检查后者的参数是否与前者的返回类型相同，并从第二个函数开始递归检查类型。如果类型不匹配，我们返回
    `never` 来标记失败。
- en: 'Now, what’s the type of the pipeline? The type of its arguments will match
    the first function’s argument type, and the type of the result will match the
    last function’s result type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，管道的类型是什么？其参数的类型将与第一个函数的参数类型匹配，其结果类型将与最后一个函数的结果类型匹配：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We first verify that the function’s types are correct, using `FnsMatchPipe<>`.
    If the types match, the type of the whole pipeline is that of a function that
    gets arguments of the same type as the first function in the pipeline and returns
    a value of the same type as the last pipelined function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用 `FnsMatchPipe<>` 验证函数的类型是否正确。如果类型匹配，整个管道的类型就是一个函数，该函数接收与管道中第一个函数相同类型的参数，并返回与最后一个管道函数相同类型的值。
- en: 'Now, our pipelines can be properly written – and we’ll have to use the same
    “overloading” as in the previous chapter to help TypeScript work out types:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的管道可以正确编写了——我们得使用与上一章相同的“重载”来帮助 TypeScript 确定类型：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Before we look at other ways to connect functions, let’s consider how we would
    debug our pipelines.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看连接函数的其他方法之前，让我们考虑如何调试我们的管道。
- en: Debugging pipelines
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试管道
- en: 'Now, let’s turn to a practical question: how do you debug your code? With pipelining,
    you can’t see what’s passed on from function to function, so how do you do it?
    We have two answers for that: one (also) comes from the Unix/Linux world, and
    the other (the most appropriate for this book) uses wrappers to provide some logs.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向一个实际问题：你如何调试你的代码？使用管道，你无法看到从函数到函数传递的内容，那么你该如何做？对此我们有两个答案：一个（同样）来自 Unix/Linux
    世界，另一个（对于这本书来说最合适）使用包装器来提供一些日志。
- en: Using tee
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 tee
- en: 'The first solution we’ll use implies adding a function to the pipeline, which
    will just log its input. We want to implement something similar to the `tee` Linux
    command, which can intercept the standard data flow in a pipeline and send a copy
    to an alternate file or device. Remembering that `/dev/tty` is the usual console,
    we could execute something similar to the following and get an onscreen copy of
    everything that passes using the `tee` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的第一个解决方案意味着向管道中添加一个函数，该函数仅记录其输入。我们想要实现类似于 Linux 命令 `tee` 的功能，该命令可以拦截管道中的标准数据流并将其副本发送到另一个文件或设备。记住
    `/dev/tty` 是通常的控制台，我们可以执行类似以下操作，并使用 `tee` 命令获取屏幕上的所有内容副本：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We could write a similar function with ease:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地编写一个类似的函数：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Comma power!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号的力量！
- en: 'If you are aware of the uses of the comma operator, you can be more concise
    and write `const tee2 = <A>(arg: A) => (console.log(arg), arg)`—do you see why?
    Check out [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)
    for the answer!'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你了解逗号操作符的用法，你可以更简洁地编写 `const tee2 = <A>(arg: A) => (console.log(arg), arg)`——你看到为什么吗？查看
    [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comma_Operator)
    以获取答案！'
- en: 'Our logging function is short and to the point: it will receive a single argument,
    list it, and pass it on to the following function in the pipe. We can see it working
    in the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的日志函数简短而直接：它将接收一个参数，列出它，并将其传递给管道中的下一个函数。我们可以在以下代码中看到它的工作情况：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It would be even better if our `tee()` function could receive a logger function
    as a parameter, as in the *Logging in a functional way* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions*; it’s just a matter of making the same kind of change we
    managed there. The same good design concepts are applied again!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 `tee()` 函数能够接收一个日志记录函数作为参数，就像在 [*第 6 章*](B19301_06.xhtml#_idTextAnchor107)
    *以函数方式记录日志* 部分中提到的“*产生函数*”；那只是我们成功实现的那种改变。同样的优秀设计理念再次得到应用！
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This function works exactly in the same way as the previous `tee()`, although
    it will allow us to be more flexible when it comes to applying and testing. However,
    in our case, this would just be an extra enhancement to an already easily-testable
    function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数与之前的 `tee()` 函数完全一样，尽管它将使我们能够更灵活地应用和测试。然而，在我们的情况下，这仅仅是对一个已经很容易测试的函数的额外增强。
- en: Let’s consider an even more generic tapping function, with more possibilities
    than just doing a bit of logging.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个更通用的拨号函数，它不仅限于进行一些日志记录。
- en: Tapping into a flow
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拨入流程
- en: 'If you wish, you could write an enhanced `tee()` function to produce more debugging
    information, send the reported data to a file or remote service, and so on—there
    are many possibilities you can explore. You could also explore a more general
    solution, of which `tee()` would be a particular case and allow us to create personalized
    tapping functions. This can be seen in the following diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以编写一个增强的 `tee()` 函数来产生更多的调试信息，将报告的数据发送到文件或远程服务，等等——有许多你可以探索的可能性。你也可以探索一个更通用的解决方案，其中
    `tee()` 只是一个特例，并允许我们创建个性化的拨号函数。这可以在以下图中看到：
- en: '![Figure 8.2 – Tapping allows you to apply a function so that you can inspect
    data as it ﬂows through the pipeline](img/Figure_8.2_B19301.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 拨号允许你在管道中应用一个函数，以便你可以检查数据在管道中流动的情况](img/Figure_8.2_B19301.jpg)'
- en: Figure 8.2 – Tapping allows you to apply a function so that you can inspect
    data as it ﬂows through the pipeline
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 拨号允许你在管道中应用一个函数，以便你可以检查数据在管道中流动的情况
- en: 'When working with pipelines, you may want to put a logging function in the
    middle of them, or you might want some other kind of *snooping* function—possibly
    for storing data somewhere, calling a service, or some other kind of side effect.
    We could have a generic `tap()` function to allow us to inspect data as it moves
    along our pipeline, which would behave in the following way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当与管道一起工作时，你可能想在管道的中间放置一个日志记录函数，或者你可能想要某种其他类型的*窥探*函数——可能是为了将数据存储在某个地方，调用一个服务，或者产生某种副作用。我们可以有一个通用的
    `tap()` 函数，让我们能够检查数据在管道中移动时的状态，它将以以下方式工作：
- en: '[PRE27]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is a candidate for the *trickiest-looking code-in-the-book* award, so
    let’s explain it. We want to produce a function that, given a function, `fn()`,
    and an argument, `x`, will evaluate `fn(x)` (to produce whatever sort of side
    effect we may be interested in) but return `x` (so the pipeline goes on without
    interference). The comma operator has exactly that behavior: if you write something
    similar to `(a, b, c)`, JavaScript will evaluate the three expressions in order
    and use the last value as the expression’s value.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是本书中看起来最复杂的代码之一，所以让我们来解释一下。我们想要产生一个函数，给定一个函数 `fn()` 和一个参数 `x`，将评估 `fn(x)`（以产生我们可能感兴趣的任何类型的副作用），但返回
    `x`（这样管道就可以继续而不会受到干扰）。逗号操作符正好具有这种行为：如果你写类似 `(a, b, c)` 的东西，JavaScript 将按顺序评估三个表达式，并使用最后一个值作为表达式的值。
- en: 'Here, we can use currying to produce several different tapping functions. The
    one we wrote in the previous section, `tee()`, could also be written in the following
    fashion:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以使用柯里化来产生几个不同的拨号函数。我们在上一节中编写的 `tee()` 函数也可以用以下方式编写：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'By the way, you could have also written `tap()` without currying, but you’ll
    have to admit it loses some of its mystery! This is demonstrated here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你也可以不使用柯里化来编写 `tap()`，但你必须承认这失去了一些神秘感！这在这里得到了演示：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This does exactly the same job, and you’ll recognize this way of currying from
    the *Currying by hand* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*,
    Transforming Functions*. Now that we have learned how to tap into a pipeline,
    let’s move on to a different way of logging by revisiting some concepts we looked
    at in previous chapters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实做了完全相同的工作，你将从这个 *手动柯里化* 部分 [*第 7 章*](B19301_07.xhtml#_idTextAnchor128) *转换函数*
    中认出这种柯里化的方式。现在我们已经学会了如何“拨入”管道，让我们通过回顾之前章节中探讨的一些概念，继续探索另一种日志记录方式。
- en: Using a logging wrapper
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用日志包装器
- en: 'The second idea we mentioned is based on the `addLogging()` function we wrote
    in the *Logging* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107)*,
    Producing Functions*. The idea was to wrap a function with some logging functionality
    so that, on entry, the arguments would be printed and, on exit, the result of
    the function would be shown:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的第二个想法是基于我们在[*第6章*](B19301_06.xhtml#_idTextAnchor107)*“日志记录”部分中编写的`addLogging()`函数。想法是将一些日志功能包装在函数中，以便在进入时打印参数，在退出时显示函数的结果：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can trivially verify that the `pipeline()` function is doing its thing correctly—whatever
    a function produces as a result is given as input to the next function in the
    line, and we can also understand what’s happening with each call. Of course, you
    don’t need to add logging to every function in the pipeline: you would probably
    do so in places where you suspected an error was occurring.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻易地验证`pipeline()`函数是否正确执行——无论函数产生什么结果，都会作为输入传递给下一行中的函数，我们也可以理解每次调用发生了什么。当然，你不需要在管道中的每个函数中添加日志：你可能会在怀疑发生错误的地方这样做。
- en: Now that we’ve looked at how to join functions, let’s look at a common way of
    defining functions in FP, *pointfree style*, which you may encounter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何组合函数，让我们看看在FP中定义函数的一种常见方式，*无点风格*，你可能会遇到。
- en: Pointfree style
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无点风格
- en: 'When you join functions together, either in a pipeline or with composition,
    as we’ll see later in this chapter, you don’t need any intermediate variables
    to hold the results that will become arguments to the following function in line:
    they are implicit. Similarly, you can write functions without mentioning their
    parameters; this is called the *pointfree style*.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将函数组合在一起，无论是通过管道还是通过组合，正如我们将在本章后面看到的那样，你不需要任何中间变量来保存将成为后续函数参数的结果：它们是隐式的。同样，你可以编写不提及参数的函数；这被称为*无点风格*。
- en: (By the way, pointfree style is also called *tacit* programming and *pointless*
    programming by detractors! The term point itself means a function parameter, while
    pointfree refers to not naming those parameters.)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: （顺便说一下，无点风格也被批评者称为*隐式编程*和*无意义编程*！术语“点”本身意味着函数参数，而无点则表示不命名这些参数。）
- en: Defining pointfree functions
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义无点函数
- en: 'You can easily recognize a pointfree function definition because it doesn’t
    need the `function` keyword or the `=>` arrow. Let’s revisit some of the previous
    functions we wrote in this chapter and check them out. For example, the definition
    of our original file-counting functions is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以很容易地识别无点函数定义，因为它不需要`function`关键字或`=>`箭头。让我们回顾一下我们在本章中编写的某些先前函数，并检查它们。例如，我们原始的文件计数函数的定义如下：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding code could be rewritten as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以重写如下：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The new definitions don’t reference the parameter for the newly defined functions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 新的定义不引用新定义函数的参数。
- en: 'You can deduce this by examining the first function in the pipeline (`getDir()`,
    in this case) and seeing what it receives as arguments. (Using type signatures,
    as we’ll see in [*Chapter 12*](B19301_12.xhtml#_idTextAnchor221), *Building Better
    Containers*, is of great help in terms of documentation, and complements TypeScript
    types.) In our *Revisiting an example* section, we could have written a `getLat()`
    function to get the `lat` field out of an object in a pointfree fashion:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过检查管道中的第一个函数（在这种情况下是`getDir()`）以及它接收什么参数来推断这一点。（使用类型签名，正如我们将在[*第12章*](B19301_12.xhtml#_idTextAnchor221)*“构建更好的容器”中看到的那样，对于文档来说非常有帮助，并且补充了TypeScript类型。）在我们的*回顾示例*部分，我们可以编写一个`getLat()`函数，以无点方式从对象中获取`lat`字段：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'What should the equivalent full-style definition be? You’d have to examine
    the `getField()` function (we looked at this in the *Revisiting an example* section)
    to decide that it expects an object as an argument. However, making that need
    explicit by writing the following wouldn’t make much sense:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的全风格定义应该是什么？你必须检查`getField()`函数（我们在*回顾示例*部分中看到了这个函数）以确定它期望一个对象作为参数。然而，通过编写以下内容来明确这种需求并没有太多意义：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you were willing to write all this, you might wish to stick with the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意编写所有这些，你可能希望坚持以下做法：
- en: '[PRE35]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then, you simply wouldn’t need to worry about currying!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你就根本不需要担心柯里化！
- en: Converting to pointfree style
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转换为无点风格
- en: 'On the other hand, you had better pause for a minute and try not to write everything
    in pointfree code, at any cost. For example, consider the `isNegativeBalance()`
    function we wrote back in [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107), *Producing
    Functions*:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你最好暂停一分钟，尽量不去编写纯函数式代码，无论如何。例如，考虑我们在[*第6章*](B19301_06.xhtml#_idTextAnchor107)的*生产函数*中编写的`isNegativeBalance()`函数：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Can we write this in a pointfree style? Yes, we can, and we’ll see how—but
    I’m not sure we’d want to code this way! We can consider building a pipeline of
    two functions: one will extract the balance from the given object, while the other
    will check whether it’s negative. Due to this, we will write our alternative version
    of the balance-checking function like so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否以纯函数式风格编写这个？是的，我们可以，我们将看到如何编写——但我不确定我们是否真的想这样编写代码！我们可以考虑构建一个由两个函数组成的管道：一个将提取给定对象的余额，而另一个将检查它是否为负。因此，我们将像这样编写我们的替代版本的余额检查函数：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To extract the `balance` attribute from a given object, we can use `getField()`
    and a bit of currying, and write the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要从一个给定的对象中提取`balance`属性，我们可以使用`getField()`和一些柯里化，并编写以下代码：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For the second function, we could write the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个函数，我们可以编写以下代码：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There goes our pointfree goal! Instead, we can use the `binaryOp()` function,
    also from the same chapter we mentioned earlier, plus some more currying, to write
    the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的纯函数目标就这样消失了！相反，我们可以使用`binaryOp()`函数，这也是我们之前提到的同一章中的函数，再加上一些额外的柯里化，来编写以下代码：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'I wrote the test the other way around (`0>x` instead of `x<0`) just for ease.
    An alternative would have been to use the enhanced functions I mentioned in the
    *A handier implementation* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, which is a bit less complex, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以以相反的方式编写测试（`0>x`而不是`x<0`），只是为了方便。另一种选择是使用我在[*第6章*](B19301_06.xhtml#_idTextAnchor107)的*更方便的实现*部分提到的增强函数，这部分内容稍微简单一些，如下所示：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'So, finally, we could write the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，最终，我们可以编写以下代码：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, we could write the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们还可以编写以下代码：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Is that an improvement? Our new versions of `isNegativeBalance()` don’t make
    a reference to their argument and are fully pointfree, but the idea of using pointfree
    style should be to help improve the clarity and readability of your code and not
    to produce obfuscation and opaqueness! I doubt anybody would look at our new versions
    of the function and consider them to be an advantage over the original.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种改进吗？我们新的`isNegativeBalance()`版本没有引用它们的参数，并且是完全的纯函数式，但使用纯函数式风格的想法应该是帮助提高代码的清晰度和可读性，而不是产生混淆和晦涩！我怀疑没有人会看我们这个函数的新版本，并认为它们比原始版本有优势。
- en: 'If you find that your code is becoming harder to understand due to using pointfree
    programming, stop and roll back your changes. Remember our doctrine for this book:
    we want to do FP, but we don’t want to go overboard with it—and using the pointfree
    style is not a requirement!'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现由于使用纯函数编程，你的代码变得越来越难以理解，请停止并撤销你的更改。记住这本书的教条：我们想要做函数式编程，但我们不想过分追求——使用纯函数式风格并不是强制性的！
- en: 'In this section, we’ve learned how to build pipelines of functions—this is
    a powerful technique. For objects and arrays, however, we have another special
    technique that you may have used already: *chaining*. Let’s take a look at this
    now.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何构建函数管道——这是一个强大的技术。然而，对于对象和数组，我们还有一种你可能已经使用过的特殊技术：*链式调用*。现在让我们来看看这个。
- en: Chaining and fluent interfaces
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链式和流畅接口
- en: 'When you work with objects or arrays, there is another way of linking the execution
    of several calls together: by applying *chaining*. For example, when you work
    with arrays, if you apply a `map()` or `filter()` method, the result is a new
    array, to which you can then apply another `map()` or `filter()` function, and
    so forth. We used these methods when we defined the `range()` function back in
    the *Working with ranges* section of [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084)*,*
    *Programming Declaratively*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与对象或数组一起工作时，还有另一种将多个调用执行链接起来的方法：通过应用*链式调用*。例如，当你与数组一起工作时，如果你应用一个`map()`或`filter()`方法，结果会是一个新的数组，然后你可以对这个新数组应用另一个`map()`或`filter()`函数，依此类推。我们在[*第5章*](B19301_05.xhtml#_idTextAnchor084)的*使用范围*部分定义`range()`函数时使用了这些方法，*声明式编程*：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: First, we created a new array; then, we applied the `fill()` method to it, which
    updated the array in place (side effect) and returned the updated array, to which
    we finally applied a `map()` method. The latter method generated a new array,
    to which we could have applied further mapping, filtering, or any other available
    method.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个新的数组；然后，我们应用了`fill()`方法来更新它（副作用）并返回更新后的数组，最后我们应用了一个`map()`方法。后者方法生成了一个新的数组，我们可以对它进行进一步的映射、过滤或其他任何可用的方法。
- en: Let’s take a look at a common example of fluent APIs, which work by chaining,
    and then consider how we can do this on our own.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看流畅API的一个常见例子，这些API通过链式操作工作，然后考虑我们如何在自己的API上实现这一点。
- en: An example of fluent APIs
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流畅API的示例
- en: 'This style of continuous chained operations is also used in fluent APIs or
    interfaces. To give just one example, the graphic `D3.js` library (see [d3js.org](http://d3js.org)
    for more on it) frequently uses this style. The following example, taken from
    [bl.ocks.org/mbostock/4063269](http://bl.ocks.org/mbostock/4063269), shows it
    in action:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种连续链式操作的风格也用于流畅的API或接口。仅举一个例子，图形`D3.js`库（更多关于它的信息请参阅[d3js.org](http://d3js.org)）经常使用这种风格。以下例子，取自[bl.ocks.org/mbostock/4063269](http://bl.ocks.org/mbostock/4063269)，展示了它的实际应用：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Each method works on the previous object and provides access to a new object
    to which future method calls will be applied (such as the `selectAll()` or `append()`
    methods) or updates the current one (as the `attr()` attribute setting calls do).
    This style is not unique, and several other well-known libraries (jQuery comes
    to mind) also apply it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都作用于前一个对象，并提供对新的对象的访问，未来的方法调用将应用于该对象（例如`selectAll()`或`append()`方法），或者更新当前对象（如`attr()`属性设置调用所做的那样）。这种风格并不独特，其他一些知名的库（比如jQuery）也采用了它。
- en: Can we automate this? In this case, the answer is “possibly, but I’d rather
    not.” I think using `pipeline()` or `compose()` works just as well and achieves
    the same thing. With object chaining, you are limited to returning new objects
    or arrays or something that methods can be applied to. (Remember, if you are working
    with standard types, such as strings or numbers, you can’t add methods to them
    unless you mess with their prototype, which isn’t recommended!). With composition,
    however, you can return any value; the only restriction is that the next function
    in line must expect the data type you provide.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能自动化这一点吗？在这种情况下，答案是“可能，但我宁愿不这么做。”我认为使用`pipeline()`或`compose()`效果一样好，并且可以达到相同的目的。使用对象链式调用，你只能返回新的对象或数组或方法可以应用到的某种东西。（记住，如果你正在处理标准类型，如字符串或数字，除非你修改它们的原型，否则你不能向它们添加方法，这并不推荐！）然而，使用组合，你可以返回任何值；唯一的限制是下一个函数必须期望你提供的数据类型。
- en: 'On the other hand, if you are writing your own API, you can provide a fluent
    interface by just having each method return `this`—unless it needs to return something
    else! If you were working with someone else’s API, you could also do some trickery
    by using a proxy. However, be aware that there may be cases in which your proxied
    code might fail: maybe another proxy is being used, or there are some getters
    or setters that somehow cause problems, and so on.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你正在编写自己的API，你可以通过让每个方法都返回`this`来提供一个流畅的接口——除非它需要返回其他内容！如果你在使用别人的API，你也可以通过使用代理来玩一些小技巧。然而，请注意，可能会有一些情况导致你的代理代码可能失败：可能另一个代理正在使用，或者有一些getter或setter可能会引起问题，等等。
- en: On proxies
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 关于代理
- en: You may want to read up on proxy objects at [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
    – they are very powerful and allow for interesting metaprogramming functionalities.
    Still, they can trap you with technicalities and will cause an (albeit slight)
    slowdown in your proxied code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想了解一下代理对象，请参阅[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
    – 它们非常强大，并允许实现有趣的元编程功能。然而，它们可能会让你陷入技术细节的陷阱，并且会导致代理代码的（尽管是轻微的）性能下降。
- en: Let’s now look at how to chain calls so we can do this with any class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何链式调用，这样我们就可以对任何类进行操作。
- en: Chaining method calls
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链式调用方法
- en: 'Let’s go for a basic example. We have a `City` class with `name`, latitude
    (`lat`), and longitude (`long`) attributes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个基本的例子。我们有一个`City`类，它具有`name`、纬度(`lat`)和经度(`long`)属性：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This is a common class with a few methods; everything’s quite normal. We could
    use this class as follows and provide details about my native city, Montevideo,
    Uruguay:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有几个方法的常见类；一切都很正常。我们可以使用这个类如下，并提供关于我的家乡乌拉圭蒙得维的亚的详细信息：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we wanted the setters to be handled in a fluent manner, we could set up
    a proxy to detect these calls and provide the missing `return this`. How can we
    do that? If the original method doesn’t return anything, JavaScript will include
    a `return undefined` statement by default so that we can detect whether that’s
    what the method returns and substitute `return this` instead. Of course, this
    is a problem: what would we do if we had a method that could legally return `undefined`
    because of its semantics? We could have some kind of exceptions list to tell our
    proxy not to add anything in those cases, but let’s not get into that.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望设置器以流畅的方式处理，我们可以设置一个代理来检测这些调用并提供缺少的 `return this`。我们如何做到这一点？如果原始方法不返回任何内容，JavaScript
    会默认包含一个 `return undefined` 语句，这样我们就可以检测方法返回的是否是 `undefined`，并用 `return this` 来替换它。当然，这是一个问题：如果我们有一个合法返回
    `undefined` 的方法，我们会怎么办？因为它具有语义？我们可以有一个某种异常列表来告诉我们的代理在这些情况下不要添加任何内容，但让我们不要深入这个话题。
- en: 'The code for our handler is as follows. Whenever the method of an object is
    invoked, a `get()` is implicitly called, and we catch it. If we get a function,
    we wrap it with some code of our own that will call the original method and then
    decide whether to return its value or a reference to the proxied object instead.
    If we didn’t get a function, we would return the requested property’s value. Our
    `chainify()` function will take care of assigning the handler to an object and
    creating the needed proxy:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理器的代码如下。每当调用一个对象的某个方法时，都会隐式地调用一个 `get()`，然后我们捕获它。如果我们得到一个函数，我们用一些自己的代码将其包装起来，这样它就会调用原始方法，然后决定是返回其值还是返回代理对象的引用。如果我们没有得到一个函数，我们就返回请求的属性的值。我们的
    `chainify()` 函数将负责将处理器分配给一个对象并创建所需的代理：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We must check whether the invoked `get()` was for a function or an attribute.
    In the first case, we wrap the method with extra code so that it will execute
    it and then return its results (if any) or a reference to the object itself. In
    the second case, we return the attribute, which is the expected behavior. (For
    the use of `Reflect.get()`, check out [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get).)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须检查被调用的 `get()` 是针对函数还是属性。在第一种情况下，我们用额外的代码包装方法，使其执行并返回其结果（如果有）或对象的引用。在第二种情况下，我们返回属性，这是预期的行为。（关于
    `Reflect.get()` 的用法，请参阅 [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect/get)。）
- en: 'What’s the type of a “chainified” object? Any property that isn’t a function
    is the same. A property that is a function that returns some non-`void` value
    is also still the same. However, if a function returns `void`, we wrap it, so
    it returns the object itself. The `Chainify<>` type definition does that:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: “链式化”对象的类型是什么？任何非函数的属性都是相同的。返回某些非 `void` 值的函数属性也是相同的。然而，如果一个函数返回 `void`，我们会将其包装，使其返回对象本身。`Chainify<>`
    类型定义就是这样：
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this, we can chainify any object so that we can inspect any called method.
    As I’m writing this, I’m currently living in Pune, India, so let’s reflect that
    change:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们可以链式化任何对象，以便我们可以检查任何调用的方法。当我写这篇文章的时候，我正在印度浦那生活，所以让我们反映这个变化：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Notice the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下内容：
- en: 'The type of `myCity2` (which is chainified) is different from the type of `myCity`.
    For instance, `myCity2.setLong()` is now of the `setLong(newLong: number): Chainify<City>`
    type instead of `setLong(newLong: number): void` as before. (See *Question 8.8*.)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myCity2`（已链式化）的类型与 `myCity` 的类型不同。例如，`myCity2.setLong()` 现在是 `setLong(newLong:
    number): Chainify<City>` 类型，而不是之前的 `setLong(newLong: number): void`。（参见 *问题 8.8*。）'
- en: We call several setters in a fluent manner, and they are working fine since
    our proxy is taking care of providing the value for the following call.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们以流畅的方式调用几个设置器，它们运行良好，因为我们的代理正在处理为后续调用提供值。
- en: The calls to `getCoords()` and `getName()` are intercepted, but nothing special
    is done because they already return a value.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `getCoords()` 和 `getName()` 被拦截，但由于它们已经返回了值，所以没有进行特殊处理。
- en: Is working in a chained way worth it? That’s up to you—but remember that there
    may be cases in which this approach fails, so be wary! Now, let’s move on to composing,
    the other most common way of joining functions.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以链式方式工作值得吗？这取决于你——但记住，可能会有一些情况下这种方法会失败，所以要保持警惕！现在，让我们继续探讨组合，这是连接函数的另一种最常见的方式。
- en: Composing
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合
- en: '*Composing* is quite similar to pipelining, but has its roots in mathematical
    theory. The concept of composition is a sequence of function calls in which the
    output of one function is the input for the next one—but in the opposite order
    to when pipelining. So, if you have a series of functions, from left to right,
    when pipelining, the first function of the series to be applied is the leftmost
    one, but when you use composition, you start with the rightmost one.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合*与管道化非常相似，但其根源在于数学理论。组合的概念是一系列函数调用的序列，其中一个函数的输出是下一个函数的输入——但顺序与管道化相反。因此，如果你有一系列函数，从左到右，当进行管道化时，要应用系列中的第一个函数是左边的那个，但当你使用组合时，你从最右边的一个开始。'
- en: Let’s investigate this a bit more. When you define the composition of, say,
    three functions as (`f`∘`g`∘`h`) and apply this composition to `x`, this is equivalent
    to writing `f(g(h(x)))`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地研究一下。当你定义了三个函数的组合，比如(`f`∘`g`∘`h`)，并将这个组合应用到`x`上，这相当于写出`f(g(h(x)))`。
- en: 'It’s important to note that, as with pipelining, the arity of the first function
    to be applied (actually the last one in the list) can be anything, but all the
    other functions must be unary. Also, besides the difference in the sequence of
    function evaluation, composing is an important tool in FP: it abstracts the implementation
    details (putting your focus on what you need to accomplish rather than on the
    specific details for achieving that), thereby letting you work in a more declarative
    fashion.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，与管道化一样，要应用的第一（实际上是列表中的最后一个）函数的arity可以是任何值，但所有其他函数都必须是一元的。此外，除了函数评估顺序的差异外，组合是FP中的一个重要工具：它抽象了实现细节（将你的焦点放在你需要完成的事情上，而不是实现它的具体细节），因此让你以更声明性的方式工作。
- en: Tip for reading
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读提示
- en: If it helps, you can read (*f*∘*g*∘*h*) as “*f* after *g* after *h*” so that
    it becomes clear that *h* is the first function to be applied, while *f* is the
    last.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有帮助，你可以将(*f*∘*g*∘*h*)读作“*f*之后*g*之后*h*”，这样就可以清楚地看出*h*是第一个要应用的函数，而*f*是最后一个。
- en: Given its similarity to pipelining, it will be no surprise that implementing
    composition isn’t very hard. However, there are still some important and interesting
    details. Let’s see some examples of composition before moving on to using higher-order
    functions and finishing with some considerations about testing composed functions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其与管道化的相似性，实现组合并不困难。然而，还有一些重要且有趣细节。在继续使用高阶函数和使用一些关于测试组合函数的考虑之后，让我们看看一些组合的例子。
- en: Some examples of composition
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合的一些例子
- en: It may not be a surprise to you, but we have already seen several examples of
    composition—or, at the very least, cases in which the solutions we achieved were
    functionally equivalent to using composition. Let’s review some of these and work
    with some new examples too.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不会让你感到惊讶，但我们已经看到了几个组合的例子——或者至少，我们实现的一些解决方案在功能上等同于使用组合。让我们回顾一些这些例子，并尝试一些新的例子。
- en: Unary operators
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一元运算符
- en: 'In the *Logically negating a function* section of [*Chapter 6*](B19301_06.xhtml#_idTextAnchor107),
    *Producing Functions*, we wrote a `not()` function that, given another function,
    would logically invert its result. We used that function to negate a check for
    negative balances; the sample code for this (and I’m going with plain JavaScript
    here, for clarity) could be as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B19301_06.xhtml#_idTextAnchor107)的*逻辑否定函数*部分，我们编写了一个`not()`函数，它接受另一个函数作为输入，并逻辑上反转其结果。我们使用该函数来否定对负余额的检查；这个示例代码（这里我使用纯JavaScript，以保持清晰）可以是以下这样：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In another section (*Turning operations into functions*) of that chapter, I
    left you with the challenge of writing a `unaryOp()` function that would provide
    unary functions equivalent to common JavaScript operators. If you met that challenge,
    you should be able to write something such as the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在该章节的另一个部分(*将操作转换为函数*)中，我给你留下了一个挑战，即编写一个`unaryOp()`函数，该函数将提供与常见JavaScript运算符等效的一元函数。如果你接受了这个挑战，你应该能够写出以下这样的代码：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Assuming the existence of a `compose()` function, you could have also written
    the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设存在一个`compose()`函数，你也可以写成以下这样：
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Which one do you prefer? It’s a matter of taste—but I think the second version
    clarifies what we are trying to do better. With the `not()` function, you must
    check what it does to understand the general code. With composition, you still
    need to know what `logicalNot()` is, but the global construct is open to see.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你更喜欢哪一个？这是一个口味问题——但我认为第二个版本更好地阐明了我们试图做什么。使用`not()`函数时，你必须检查它做了什么才能理解通用代码。使用组合，你仍然需要知道`logicalNot()`是什么，但全局结构是开放的，可以查看。
- en: 'To look at just one more example in the same vein, you could have achieved
    the same results that we got in the *Inverting the results* section in the same
    chapter. Recall that we had a function that could compare strings according to
    the rules of Spanish, but we wanted to invert the result of the comparison so
    that it was sorted in descending order:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个类似的例子，你可以在同一章节的*结果反转*部分达到我们得到的结果。回想一下，我们有一个可以按照西班牙语规则比较字符串的函数，但我们想反转比较的结果，使其按降序排列：
- en: '[PRE54]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This code produces the same result that our previous sorting problem did, but
    the logic is expressed more clearly and with less code: a typical FP result! Let’s
    look at some more examples of composing functions by reviewing another task we
    discussed earlier.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生了与我们的先前排序问题相同的结果，但逻辑表达得更清晰，代码也更少：这是一个典型的函数式编程结果！让我们通过回顾我们之前讨论的另一个任务来查看一些通过组合函数的更多示例。
- en: Counting files
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件计数
- en: 'We can also go back to our pipeline. We wrote a single-line function to count
    the `odt` files in a given path:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以回到我们的管道。我们编写了一个单行函数来计算给定路径中的`odt`文件数量：
- en: '[PRE55]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Disregarding (at least for the moment) the observation that this code is not
    as clear as the pipeline version that we developed later, we could have also written
    this function with composition:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: （至少暂时）忽略这个观察结果，即这段代码不如我们后来开发的管道版本清晰，我们也可以用组合的方式编写这个函数：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We may also see this written in a one-liner fashion:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其写成一行：
- en: '[PRE57]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Even if it’s not as clear as the pipeline version (and that’s just my opinion,
    which may be biased due to my liking of Linux!), this declarative implementation
    makes it clear that we depend on combining three distinct functions to get our
    result—this is easy to see and applies the idea of building large solutions out
    of simpler pieces of code.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它不如管道版本清晰（这仅是我的个人观点，可能因为我对Linux的喜爱而带有偏见），这种声明式实现清楚地表明我们依赖于组合三个不同的函数来得到我们的结果——这很容易看出，并且应用了从更简单的代码片段构建大型解决方案的理念。
- en: Let’s take a look at another example that’s designed to compose as many functions
    as possible.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个旨在尽可能组合尽可能多函数的例子。
- en: Finding unique words
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找唯一单词
- en: 'Finally, let’s go for another example, which, I agree, could have also been
    used for pipelining. Suppose you have some text and want to extract all the unique
    words from it: how would you go about doing so? If you think about it in steps
    (instead of trying to create a full solution in one go), you would probably come
    up with a solution similar to this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们再举一个例子，我同意，这个例子也可以用于管道。假设你有一些文本，并想从中提取所有唯一的单词：你会如何操作？如果你按步骤思考（而不是一次性创建一个完整的解决方案），你可能会提出一个类似于以下解决方案：
- en: Ignore all non-alphabetic characters.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略所有非字母字符。
- en: Put everything in uppercase.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容转换为大写。
- en: Split the text into words.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本拆分为单词。
- en: Create a set of words.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个单词集合。
- en: (Why a set? Because it automatically discards repeated values; check out [developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set)
    for more on this. By the way, we will use the `Array.from()` method to produce
    an array out of our set; see [developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
    for more on this.)
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: （为什么是集合？因为它会自动丢弃重复的值；有关更多信息，请参阅[developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set](http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set)。顺便说一下，我们将使用`Array.from()`方法将我们的集合转换为数组；有关更多信息，请参阅[developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from](http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)）
- en: 'Now, using FP, let’s solve each problem:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用函数式编程，让我们解决每个问题：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With these functions, the result can be written as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，结果可以写成以下形式：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Since you don’t get to see the arguments of any of the composed functions, you
    don’t need to show the parameter for `getUniqueWords()` either, so the pointfree
    style is natural in this case.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你无法看到任何组合函数的参数，因此你也不需要显示`getUniqueWords()`的参数，所以在这种情况下，无参数风格是自然的。
- en: 'Now, let’s test our function. To do this, let’s apply this function to the
    first two sentences of Abraham Lincoln’s address at Gettysburg (which we already
    used in an example back in the *Mapping and flattening – flatMap* section of [*Chapter
    5*](B19301_05.xhtml#_idTextAnchor084)*, Programming Declaratively*) and print
    out the 43 different words (trust me, I counted them!) in it:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们的函数。为此，让我们将此函数应用于亚伯拉罕·林肯在葛底斯堡演讲的前两句话（我们在*第五章*的*映射和扁平化 – flatMap*部分的一个例子中已经使用过它，[编程声明式](B19301_05.xhtml#_idTextAnchor084)），并打印出其中的43个不同单词（相信我，我已经数过了！）：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Of course, you could have written `getUniqueWords()` more succinctly, but the
    point I’m making is that by composing your solution out of several shorter steps,
    your code is clearer and easier to grasp. However, if you wish to say that a pipelined
    solution seems better, it’s just a matter of opinion!
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以将`getUniqueWords()`编写得更简洁，但我想表达的观点是，通过将解决方案组合成几个更短的步骤，你的代码更清晰，更容易理解。然而，如果你认为流水线解决方案更好，这只是一种观点！
- en: We have looked at many examples of function composition at this point, but there’s
    another way to manage this—by using higher-order functions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了许多函数组合的例子，但还有另一种管理方法——通过使用高阶函数。
- en: Composing with higher-order functions
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用高阶函数进行组合
- en: 'Evidently, composing by hand can be done similarly to pipelining. For example,
    the unique word-counting function that we wrote previously could be written in
    simple JavaScript style:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，手动组合可以与流水线类似进行。例如，我们之前编写的独特单词计数函数可以用简单的JavaScript风格编写：
- en: '[PRE61]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Alternatively, it could be written more concisely (but more obscurely!) in
    a one-liner style:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，它可以用更简洁（但更晦涩！）的一行代码风格编写：
- en: '[PRE62]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This works fine, but as when we studied pipelining, let’s look for a more general
    solution that won’t require writing a new particular function every time we want
    to compose some other functions.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这工作得很好，但就像我们在学习流水线时做的那样，让我们寻找一个更通用的解决方案，这样我们就不需要每次想要组合其他函数时都编写一个新的特定函数。
- en: Composing two functions is relatively easy and requires making a small change
    to our `pipeTwo()` function, which we looked at earlier in this chapter. We just
    have to exchange `f` and `g` to get the new definition!
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 组合两个函数相对简单，只需要对我们的`pipeTwo()`函数进行少量修改，这是我们之前在本章中看到的。我们只需交换`f`和`g`以获得新的定义！
- en: '[PRE63]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The only difference is that, with piping, you apply the leftmost function first,
    while with composing, you start with the rightmost function first. This variation
    suggests that we could have used the `flipTwo()` higher-order function from the
    *Parameter order* section of [*Chapter 7*](B19301_07.xhtml#_idTextAnchor128)*,
    Transforming Functions*. Is it clearer? Here is the code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是，在流水线中，你首先应用最左边的函数，而在组合中，你首先从最右边的函数开始。这种变化表明，我们本可以使用*第七章*的*参数顺序*部分中的`flipTwo()`高阶函数，[变换函数](B19301_07.xhtml#_idTextAnchor128)。这更清晰吗？以下是代码：
- en: '[PRE64]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'In any case, if we want to compose more than two functions, we can take advantage
    of the associative property and write something like the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，如果我们想组合超过两个函数，我们可以利用结合性质，并编写如下内容：
- en: '[PRE65]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Even though this works, let’s go for a better solution—we can provide several.
    We could use a loop like when we wrote our first pipelining function:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这可行，但让我们追求一个更好的解决方案——我们可以提供几个。我们可以使用一个循环，就像我们编写第一个流水线函数时那样：
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'We could also note that pipelining and composing work in opposite directions.
    We apply functions from left to right when pipelining, and from right to left
    when composing. Thus, we can achieve the same result we achieved with composition
    by reversing the order of the functions and doing pipelining instead; a very functional
    solution, which I really like! This is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注意到，流水线和组合是相反方向的。在流水线中，我们从左到右应用函数，而在组合中，我们从右到左应用。因此，我们可以通过反转函数的顺序并执行流水线来达到与组合相同的结果；这是一个非常实用的解决方案，我真的很喜欢！如下所示：
- en: '[PRE67]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The only tricky part is the usage of the spread operator before calling `pipeline()`.
    After reversing the `fns` array, we must spread its elements to call `pipeline()`
    correctly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一棘手的部分是在调用`pipeline()`之前使用扩展运算符。在反转`fns`数组后，我们必须扩展其元素以正确调用`pipeline()`。
- en: 'Yet another solution, less declarative, is to use `reduceRight()` so that instead
    of reversing the list of functions, we reverse the order of processing them:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案，不那么声明式，是使用 `reduceRight()`，这样我们就不需要反转函数列表，而是反转处理它们的顺序：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Why and how does this work? Let’s look at the inner workings of this call:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么以及如何使其工作？让我们看看这个调用的内部工作原理：
- en: Since no initial value is provided, `f()` is `removeNonAlpha()` and `g()` is
    `toUpperCase()`, so the first intermediate result is a function, `(...args) =>
    toUpperCase(removeNonAlpha(...args))`; let’s call it `step1()`.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于没有提供初始值，`f()` 是 `removeNonAlpha()`，而 `g()` 是 `toUpperCase()`，所以第一个中间结果是函数，`(...args)
    => toUpperCase(removeNonAlpha(...args))`；让我们称之为 `step1()`。
- en: The second time, `f()` is `step1()` from the previous step, while `g()` is `splitInWords()`,
    so the new result is a function, `(...args) => splitInWords(step1(...args)))`,
    which we can call `step2()`.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次，`f()` 是前一步的 `step1()`，而 `g()` 是 `splitInWords()`，所以新的结果是函数，`(...args) =>
    splitInWords(step1(...args)))`，我们可以称之为 `step2()`。
- en: The third time around, in the same fashion, we get `(...args) => arrayToSet(step2(...args))))`,
    which we call `step3()`.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三次，以同样的方式，我们得到 `(...args) => arrayToSet(step2(...args))))`，我们称之为 `step3()`。
- en: Finally, the result is `(...args) => setToList(step3(...args))`, a function;
    let’s call it `step4()`.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，结果是 `(...args) => setToList(step3(...args))`，一个函数；让我们称之为 `step4()`。
- en: The final result turns out to be a function that receives `(...args)` and starts
    by applying `removeNonAlpha()` to it, then `toUpperCase()`, and so on, before
    finishing by applying `setToList()`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是一个接收 `(...args)` 的函数，它首先应用 `removeNonAlpha()`，然后是 `toUpperCase()`，依此类推，最后通过应用
    `setToList()` 完成。
- en: 'It may come as a surprise that we can also make this work with `reduce()`—can
    you see why? The reasoning is similar to what we did previously, so we’ll leave
    this as an exercise for you:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶的是，我们也可以用 `reduce()` 使其工作——你能看出为什么吗？推理与之前所做的是相似的，所以我们将这个作为练习留给你：
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: A symmetric challenge!
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对称的挑战！
- en: After working out how `compose3()` works, you might want to write a version
    of `pipeline()` that uses `reduceRight()`, just for symmetry, to round things
    out!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在弄清楚 `compose3()` 的工作原理后，你可能想写一个使用 `reduceRight()` 的 `pipeline()` 版本，只是为了对称，使事情完整！
- en: Data typing for composition
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合的数据类型
- en: 'Given what we did for pipelining, data typing for composition is very much
    the same, and we’ll follow what we did in parallel. First, we’ll have an auxiliary
    type to check whether our functions’ types can be composed correctly:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们为管道化所做的，对于组合的数据类型来说几乎是一样的，我们将遵循并行处理的方式。首先，我们将有一个辅助类型来检查我们的函数类型是否可以正确组合：
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is essentially the same as what we wrote for pipelining, except that we
    process functions from right to left. With this done, we can now write our `Compose<>`
    type:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与我们为管道化所写的是一样的，只不过我们是从右到左处理函数。完成这个步骤后，我们现在可以编写我们的 `Compose<>` 类型：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is also what we had for pipelining, except for the type of the result,
    which is symmetrical. Finally, we can apply types to our composing functions;
    let’s see just one example, because (logically!) typing is the same for all the
    versions of our code!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是管道化中已有的，只是结果的类型是对称的。最后，我们可以将类型应用到我们的组合函数上；让我们看看一个例子，因为（从逻辑上讲！）类型对所有版本的代码都是相同的！
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'So far, we have looked at the important methods we can use to connect functions
    using pipelining, chaining, and composition. All this works very well, but we’ll
    see that there’s a particular case in which the performance of your code can be
    affected and that will require a new way to handle composition: *transducing*.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了我们可以用来使用管道化、链式和组合连接函数的重要方法。所有这些都工作得很好，但我们将看到有一个特殊情况会影响代码的性能，这需要一种新的处理组合的方式：*转换*。
- en: Transducing
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换
- en: 'Let’s consider a performance problem in JavaScript that happens when we’re
    dealing with large arrays and applying several `map()`, `filter()`, or `reduce()`
    operations. If you start with an array and apply these operations (via chaining,
    as we saw earlier in this chapter), you get the desired result. However, many
    intermediate arrays are created, processed, and discarded—and that causes delays.
    If you are dealing with small arrays, the extra time won’t make an impact, but
    with larger arrays (as in a big data process, maybe in Node.js, where you’re working
    with the results of a large database query), then you will probably have to need
    some optimization. We’ll do this by learning about a new tool for composing functions:
    *transducing*.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个在JavaScript中发生性能问题的场景，当我们处理大型数组并应用多个`map()`、`filter()`或`reduce()`操作时。如果你从一个数组开始并应用这些操作（通过链式调用，如我们在本章前面所见），你会得到期望的结果。然而，会创建许多中间数组，处理它们，然后丢弃它们——这会导致延迟。如果你处理的是小型数组，额外的时间不会产生影响，但处理大型数组（如在大数据处理中，也许在Node.js中，你正在处理大型数据库查询的结果），那么你可能需要一些优化。我们将通过学习一个新的用于组合函数的工具来实现这一点：*转换*。
- en: 'First, let’s create some functions and data. We’ll make do with a nonsensical
    example since we aren’t focusing on the actual operations but on the general process.
    We’ll start with some filtering functions and some mapping:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一些函数和数据。我们将使用一个无意义的例子来处理，因为我们不是关注实际的运算，而是关注一般的过程。我们将从一些过滤函数和一些映射函数开始：
- en: '[PRE73]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Now, let’s apply those maps and filters to an array. First, we drop the even
    numbers, duplicate the odd numbers, drop results over 50, and end by adding 3
    to all the results:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些映射和过滤函数应用于一个数组。首先，我们去除偶数，复制奇数，去除超过50的结果，最后将3加到所有结果上：
- en: '[PRE74]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The following diagram shows how this sequence of operations works:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了这一系列操作是如何工作的：
- en: '![Figure 8.3 – Chaining map/ﬁlter/reduce operations causes intermediate arrays
    to be created and later discarded](img/Figure_8.3_B19301.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 连接map/ﬁlter/reduce操作会导致创建并随后丢弃中间数组](img/Figure_8.3_B19301.jpg)'
- en: Figure 8.3 – Chaining map/ﬁlter/reduce operations causes intermediate arrays
    to be created and later discarded
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 连接map/ﬁlter/reduce操作会导致创建并随后丢弃中间数组
- en: Here, we can see that chaining together several `map()`, `filter()`, and `reduce()`
    operations causes intermediate arrays (three, in this case) to be created and
    later discarded—and for large arrays, that can become cumbersome.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到将多个`map()`、`filter()`和`reduce()`操作连接起来会导致创建并随后丢弃中间数组（在这个例子中是三个）——对于大型数组，这可能会变得很麻烦。
- en: 'How can we optimize this? The problem here is that processing applies the first
    transformation to the input array; then, the second transformation is applied
    to the resulting array; then the third, and so on. An alternative solution would
    be to take the first element of the input array and apply all the transformations
    in sequence to it. Then, you would need to take the second element of the input
    array and apply all the transformations to it, then take the third, and so on.
    In pseudocode, the difference is between this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何优化这个问题呢？这里的问题是处理过程将第一个转换应用于输入数组；然后，第二个转换应用于结果数组；然后是第三个，依此类推。一个替代方案是取输入数组的第一个元素，并按顺序对其应用所有转换。然后，你需要取输入数组的第二个元素，并对其应用所有转换，然后取第三个，依此类推。在伪代码中，区别在于这个：
- en: '[PRE75]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'And then this approach:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是这个方法：
- en: '[PRE76]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With the first logic, we go transformation by transformation, applying it to
    each list and generating a new one. This requires several intermediate lists to
    be produced. With the second logic, we go element by element and apply all the
    transformations to each one in sequence to arrive at the final output list without
    any intermediate lists being created.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一种逻辑，我们逐个转换，将其应用于每个列表，并生成一个新的列表。这需要产生几个中间列表。使用第二种逻辑，我们逐个元素地处理，并将所有转换按顺序应用于每个元素，以得到最终输出列表，而不创建任何中间列表。
- en: 'Now, the problem is being able to transpose the transformations; how can we
    do this? We saw this key concept in [*Chapter 5*](B19301_05.xhtml#_idTextAnchor084),
    *Programming Declaratively*, and we can define `map()` and `filter()` in terms
    of `reduce()`. Using those definitions, instead of a sequence of different functions,
    we will apply the same operation (`reduce()`) at each step, and here is the secret!
    As shown in the following diagram, we change the order of evaluation by composing
    all the transformations so that they can be applied in a single pass with no intermediate
    arrays whatsoever:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题在于能够转置转换；我们如何做到这一点？我们在 [*第5章*](B19301_05.xhtml#_idTextAnchor084) 中看到了这个关键概念，*声明式编程*，并且我们可以用
    `reduce()` 来定义 `map()` 和 `filter()`。使用这些定义，而不是一系列不同的函数，我们将在每个步骤应用相同的操作（`reduce()`），这就是秘密！如图所示，我们通过组合所有转换来改变评估顺序，以便它们可以在单次遍历中应用，而无需任何中间数组：
- en: '![Figure 8.4 – By applying transducers, we will change the order of evaluation
    but get the same result](img/Figure_8.4_B19301.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 通过应用转换器，我们将改变评估顺序但得到相同的结果](img/Figure_8.4_B19301.jpg)'
- en: Figure 8.4 – By applying transducers, we will change the order of evaluation
    but get the same result
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 通过应用转换器，我们将改变评估顺序但得到相同的结果
- en: Instead of applying a first `reduce()` operation, passing its result to a second,
    its result to a third, and so on, we will compose all the reducing functions into
    a single one! Let’s analyze this.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是应用第一个 `reduce()` 操作，将其结果传递给第二个，然后传递给第三个，依此类推，我们将所有归约函数组合成一个单一的函数！让我们分析一下。
- en: Composing reducers
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合归约器
- en: 'Essentially, what we want is to transform each function (`testOdd()`, `duplicate()`,
    and so on) into a reducing operation that will call the following reducer. A couple
    of higher-order functions will help; one for mapping functions and another for
    filtering ones. With this idea, the result of an operation will be passed to the
    next one, avoiding intermediate arrays:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们想要的是将每个函数（`testOdd()`、`duplicate()` 等）转换成一个归约操作，该操作将调用以下归约器。几个高阶函数将有所帮助；一个用于映射函数，另一个用于过滤函数。有了这个想法，操作的结果将被传递到下一个操作，避免了中间数组：
- en: '[PRE77]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'These two transforming functions are *transducers*: functions that accept a
    reducing function and return a new reducing function. (Some trivia: the word *transduce*
    comes from Latin, meaning transform, transport, convert, change over, and is applied
    in many different fields, including biology, psychology, machine learning, physics,
    electronics, and more.)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个转换函数是 *转换器*：接受一个归约函数并返回一个新的归约函数的函数。（一些趣闻：单词 *transduce* 来自拉丁语，意为转换、运输、转换、改变、转换，并在许多不同的领域中得到应用，包括生物学、心理学、机器学习、物理学、电子学等。）
- en: Typing is not too hard. For mapping, we assume a mapping function that gets
    a value of type `V` and produces a result of type `W`. The generic reducer takes
    an accumulator of type `A` and a value of type `W` and produces a new accumulator,
    also of type `A`. For filtering, the filtering function gets a value of type `V`
    and produces a `Boolean` value, and the reducer gets an accumulator of type `A`
    and a value of type `V`, returning a type `A` result.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 打字并不太难。对于映射，我们假设一个映射函数，它接收类型为 `V` 的值并产生类型为 `W` 的结果。通用的归约器接收类型为 `A` 的累加器和一个类型为
    `W` 的值，并产生一个新的累加器，也是类型 `A`。对于过滤，过滤函数接收类型为 `V` 的值并产生一个 `Boolean` 值，而归约器接收类型为 `A`
    的累加器和一个类型为 `V` 的值，返回类型 `A` 的结果。
- en: 'How do we use these transducers? We can write code such as the following, although
    we’ll want a more abstract, generic version later:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这些转换器？我们可以编写如下代码，尽管我们稍后会想要一个更抽象、更通用的版本：
- en: '[PRE78]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Each of our original four functions is transformed, so they will calculate their
    result and call a reducer to deal with this further. As an example, `addThreeR()`
    will add three to its input and pass the incremented value to the next reducer,
    which in this case is `addToArray()`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始的四个函数都经过了转换，因此它们将计算结果并调用归约器来处理这些结果。以 `addThreeR()` 为例，它将向其输入值加三，并将增加后的值传递给下一个归约器，在这种情况下是
    `addToArray()`。
- en: 'This will build up the final resulting array. Now, we can write our whole transformation
    in a single step:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建最终的结果数组。现在，我们可以一步完成整个转换：
- en: '[PRE79]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'This is quite a mouthful, but it works! However, we can simplify our code by
    using the `compose()` function:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能有些复杂，但它确实有效！然而，我们可以通过使用 `compose()` 函数来简化我们的代码：
- en: '[PRE80]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The code is the same, but pay particular attention to the `compose(...fns)(addToArray)`
    expression: we compose all the mapping and filtering functions—with the last one
    being `addToArray`—to build up the output. However, this is not as general as
    we may want it to be: why do we have to create an array? Why can’t we have a different
    final reducing function? We can go one better by generalizing a bit more.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是相同的，但请注意`compose(...fns)(addToArray)`表达式：我们将所有映射和过滤函数（最后一个为`addToArray`）组合起来，以构建输出。然而，这并不像我们希望的那样通用：为什么我们必须创建一个数组？为什么我们不能有一个不同的最终reducing函数？我们可以通过进一步泛化做得更好。
- en: Generalizing for all reducers
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为所有reducer进行泛化
- en: 'To be able to work with all kinds of reducers and produce whatever kind of
    result they build, we’ll need to make a small change. The idea is simple: let’s
    modify our `transduce()` function so that it will accept a final reducer and a
    starting value for the accumulator:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够与所有类型的reducer一起工作并产生它们构建的任何类型的输出，我们需要进行一些小的修改。想法很简单：让我们修改我们的`transduce()`函数，使其能够接受一个最终reducer和一个累加器的起始值：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To make this function more usable, we specified our array-building function
    (and an empty array as a starting accumulator value) so that if you skip those
    two parameters, you’ll get a reducer that produces an array. Now, let’s look at
    the other option: instead of an array, let’s calculate the sum of the resulting
    numbers after all the mapping and filtering:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个函数更易于使用，我们指定了我们的数组构建函数（以及一个空数组作为初始累加器值），这样如果你跳过这两个参数，你将得到一个生成数组的reducer。现在，让我们看看另一个选项：不是数组，而是计算所有映射和过滤后的结果数字的总和：
- en: '[PRE82]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: By using transducers, we have been able to optimize a sequence of `map`, `filter`,
    and `reduce` operations so that the input array is processed once and directly
    produces the output result (whether an array or a single value) without creating
    any intermediate arrays; a good gain!
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用transducers，我们已经能够优化一系列`map`、`filter`和`reduce`操作，使得输入数组只处理一次，并直接产生输出结果（无论是数组还是单个值），而不创建任何中间数组；这是一个很好的改进！
- en: We’ve seen several ways of connecting functions; to round this off, let’s see
    how to write unit tests for connected functions.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了几种连接函数的方法；为了圆满结束，让我们看看如何为连接函数编写单元测试。
- en: Testing connected functions
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试连接的函数
- en: Let’s finish by considering testing for functions connected in all the ways
    we’ve seen in this chapter. Given that the mechanisms for pipelining and composition
    are similar, we will look at examples of both. They won’t differ, other than their
    logical differences due to the left-to-right or right-to-left order of function
    evaluation.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过考虑测试本章中我们看到的所有方式连接的函数来完成。由于管道和组合的机制相似，我们将查看两者的示例。除了由于函数评估的左到右或右到左顺序导致的逻辑差异外，它们不会有所不同。
- en: Testing pipelined functions
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试管道函数
- en: When it comes to pipelining, we can start by looking at how to test the `pipeTwo()`
    function since the setup will be similar to `pipeline()`. We need to create some
    mocks and check whether they were called the correct number of times and whether
    they received the correct arguments each time. We will set them to provide a known
    answer to a call.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到管道时，我们可以从如何测试`pipeTwo()`函数开始，因为设置将与`pipeline()`相似。我们需要创建一些模拟并检查它们是否被正确地调用了正确的次数，以及每次调用时是否接收到了正确的参数。我们将它们设置为提供一个已知答案的调用。
- en: 'By doing this, we can check whether the output of a function becomes the input
    of the next function in the pipeline:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以检查函数的输出是否成为管道中下一个函数的输入：
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: There is little to test given that our function always receives two functions
    as parameters. The only difference between the tests is that one shows a pipeline
    applied to a single argument, while the other shows it applied to several arguments.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的函数始终接收两个函数作为参数，所以测试内容很少。测试之间的唯一区别是，一个显示了应用于单个参数的管道，而另一个显示了应用于多个参数的管道。
- en: 'Moving on to `pipeline()`, the tests would be quite similar. However, we can
    add a test for a single-function pipeline (a border case!) and another with four
    functions:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`pipeline()`，测试将非常相似。然而，我们可以添加一个针对单函数管道（一个边界情况！）的测试，以及一个包含四个函数的测试：
- en: '[PRE84]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Testing composed functions
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试组合函数
- en: 'For composition, the style is the same (except that the order of function evaluation
    is reversed), so let’s take a look at a single test—here, I simply changed the
    order of the functions in the preceding test:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组合，风格相同（除了函数评估的顺序相反），所以让我们看看一个单独的测试——在这里，我只是改变了前面测试中函数的顺序：
- en: '[PRE85]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Testing chained functions
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试链式函数
- en: 'To test the `chainify()` function, I opted to use the preceding `City` object
    I created—I didn’t want to mess with mocks, stubs, spies, and the like; I wanted
    to ensure that the code worked under normal conditions:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`chainify()`函数，我选择使用我之前创建的`City`对象——我不想与模拟、存根、间谍等打交道；我想确保代码在正常条件下能够工作：
- en: '[PRE86]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Testing transduced functions
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试转换函数
- en: 'We tried several examples earlier in the chapter, and it’s easy to turn them
    into tests. We’ll also add new tests for border cases (for instance, just one
    function, only mapping functions, etc.) for more generality. For simplicity, I
    kept using the same data array and mapping and filtering functions I used before:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的早期尝试了几个示例，很容易将它们转换为测试。我们还将添加针对边界情况（例如，只有一个函数，只有映射函数等）的新测试，以增加通用性。为了简单起见，我继续使用之前使用的相同数据数组以及映射和过滤函数：
- en: '[PRE87]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The final result of all of these tests can be seen in the following screenshot:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些测试的最终结果可以在以下屏幕截图中看到：
- en: '![Figure 8.5 – A successful run of testing for connected functions](img/Figure_8.5_B19301.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 连接函数测试的成功运行](img/Figure_8.5_B19301.jpg)'
- en: Figure 8.5 – A successful run of testing for connected functions
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 连接函数测试的成功运行
- en: As we can see, all our tests passed successfully; good!
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，所有测试都成功通过；很好！
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to create new functions by joining several other
    functions in different ways using pipelining and composition. We also looked at
    fluent interfaces, which apply chaining, and transducing, a way to compose reducers
    to get higher-speed sequences of transformations. With these methods, you’ll be
    able to create new functions out of existing ones and keep programming in the
    declarative way we favor.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过使用管道和组合以不同的方式连接几个其他函数来创建新函数。我们还探讨了流畅接口，它应用了链式调用，以及转换，这是一种将归约器组合起来以获得更快的转换序列的方法。使用这些方法，你将能够从现有函数中创建新函数，并继续以我们偏爱的声明性方式编程。
- en: In [*Chapter 9*](B19301_09.xhtml#_idTextAnchor172), *Designing Functions*, we
    will move on to function design and study the usage of recursion, which is a basic
    tool in FP and allows for very clean algorithm designs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B19301_09.xhtml#_idTextAnchor172) *设计函数*中，我们将继续学习函数设计，并研究递归的使用，这是函数式编程中的一个基本工具，它允许进行非常干净的算法设计。
- en: Questions
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '8.1 `headline(sentence)` function that will receive a string as an argument
    and return an appropriately capitalized version. Spaces separate words. Build
    this function by connecting smaller functions:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 8.1 `headline(sentence)`函数将接收一个字符串作为参数，并返回一个适当的大写版本。单词之间用空格分隔。通过连接较小的函数来构建这个函数：
- en: '[PRE88]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '8.2 `done===true`) or pending (`done===false`). Your goal is to produce an
    array with the IDs of the pending tasks for a given person, identified by name,
    which should match the responsible field. Solve this by using composition or pipelining:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 8.2 `done===true`) 或挂起 (`done===false`)。你的目标是生成一个包含给定人员ID的数组，该人员通过名称识别，应与责任字段匹配。通过使用组合或管道来解决此问题：
- en: '[PRE89]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Ensure your code doesn’t throw an exception if, for example, the person you
    are looking for doesn’t appear in the web service result!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你的代码在例如，你要找的人没有出现在网络服务结果中时不会抛出异常！
- en: '8.3 **Thinking in abstract terms**: Suppose you are looking through somewhat
    old code and find a function that looks like the following one. (I’m keeping the
    names vague and abstract so that you can focus on the structure and not on the
    actual functionality). Can you transform this into pointfree style?'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 8.3 **抽象思维**：假设你正在查看一些较旧的代码，并发现一个看起来像以下这样的函数。(我保留了模糊和抽象的名称，这样你就可以专注于结构而不是实际的功能)。你能将其转换为无点风格吗？
- en: '[PRE90]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 8.4 `Compose<>` type using the `Pipeline<>` type plus a new `Reverse<>` type.
    What should that new type be?
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 8.4 使用`Pipeline<>`类型加上一个新的`Reverse<>`类型来创建`Compose<>`类型。这个新类型应该是什么？
- en: 8.5 **Empty pipeline?** Do our pipelining functions work with an empty array
    of functions? Can you fix that?
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 8.5 **空管道？** 我们的管道函数是否可以与一个空的函数数组一起工作？你能修复这个问题吗？
- en: 8.6 `addToArray()` function we wrote is actually impure? (Check out the *Argument
    mutation* section of [*Chapter 4*](B19301_04.xhtml#_idTextAnchor069)*, Behaving
    Properly,* if you aren’t convinced!) Would it be better if we wrote it as follows?
    Should we go for it?
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 8.6 我们编写的`addToArray()`函数实际上是不纯的？(如果你还不确定，请查看[*第4章*](B19301_04.xhtml#_idTextAnchor069)
    *行为规范*中的*参数突变*部分！)如果我们按照以下方式编写它会更好吗？我们应该这样做吗？
- en: '[PRE91]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 8.7 `map()` operations? What if you only had `filter()` operations?
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 8.7 `map()`操作？如果你只有`filter()`操作会怎样？
- en: 8.8 `myCity2` object was not the same as the type of the original `myCity` one.
    What is its type exactly?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 8.8 `myCity2` 对象与原始 `myCity` 对象的类型不同。它的确切类型是什么？
