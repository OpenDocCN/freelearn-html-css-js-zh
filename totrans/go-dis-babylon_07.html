<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-141"><a id="_idTextAnchor142"/>7</h1>
<h1 id="_idParaDest-142"><a id="_idTextAnchor143"/>Processing Route Data</h1>
<p>Although we won’t be looking at the transition between route planning and route driving quite yet, in the big picture of where things stand, generating a route is an integral piece of the Space-Truckers gameplay. In this chapter, we’re going to stick with the previous practice of taking a brief detour into a tangential topic – in this case, that topic will be spiffing up the Sun rendering with some Particle Systems. </p>
<p>Following our detour into particle systems, we’ll dive straight into how to capture, crunch, and consolidate the data from route planning into a rich set of encounters based on location, which will then drive player challenges in the next phase. </p>
<p>What makes this all possible is a technique that has its roots in the earliest days of the RPG – when dark Dungeons filled with dangerous Dragons saw players rolling dice against encounter tables that would determine their fate. The encounter tables for Space-Truckers are categorized by zoneand play a similar part in determining a Space-Trucker's fate. Each zone has a list of potential encounters along with a base probability or chance of that encounter happening. Most encounters carry potential hazards the player must act upon to avoid or mitigate, while, more rarely, other encounters may have beneficial effects (if managed correctly). </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>A Detour into Practical Systems</li>
<li>Marking Out the Route</li>
<li>Defining the Encounter Zone</li>
<li>Selecting Encounters</li>
<li>Adding Encounter Visuals</li>
</ul>
<p>By the end of this chapter, we’ll have prettied up the route-planning environment a little, but for the most part, the areas of the application being covered won’t have as much tangible effect on the end user experience. That’s OK – it will end up having a huge effect later! For this to become the case, though, we must build up some logic to process and prepare the route for encounters.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor144"/>Technical requirements</h1>
<p>The technical prerequisites are not a whole lot different in this chapter, but there are some concepts and techniques that may have utility for the topics in this chapter. </p>
<p>Here are some topics to research if you’re feeling lost, overwhelmed by complexity, or having trouble with a particular area:</p>
<ul>
<li>Particle System: <a href="https://doc.babylonjs.com/divingDeeper/particles">https://doc.babylonjs.com/divingDeeper/particles</a></li>
<li>Torus Set Shape: <a href="https://doc.babylonjs.com/divingDeeper/mesh/creation/set/torus">https://doc.babylonjs.com/divingDeeper/mesh/creation/set/torus</a></li>
<li>Torus (maths): <a href="https://www.mathsisfun.com/geometry/torus.xhtml">https://www.mathsisfun.com/geometry/torus.xhtml</a></li>
<li>More torus maths: <a href="https://www.geeksforgeeks.org/calculate-volume-and-surface-area-of-torus/">https://www.geeksforgeeks.org/calculate-volume-and-surface-area-of-torus/</a></li>
</ul>
<p>The source code for this chapter is located at <a href="https://github.com/jelster/space-truckers/tree/ch7">https://github.com/jelster/space-truckers/tree/ch7</a> and contains all the work in this chapter and previous ones. In addition to that, there are several improvements, bug fixes, and tweaks that have been introduced separately from what’s been covered previously in this book. While it would be great if we could include and discuss each of these in greater detail, that’s not possible in the space and time available! Where relevant, though, these changes will be called out. For the most part, however, the changes aren’t introducing any new concepts or techniques, but just refining, fixing, or enhancing what’s already present.  </p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor145"/>A Detour into Particle Systems</h1>
<p>Particle systems <a id="_idIndexMarker478"/>are an area of graphics programming that, like the topic of input processing, can have entire books devoted to covering particle systems from basic theory to concrete implementation. We’re not going to get into that level of detail here, because we’ve got a lot of other things to do in addition to learning about particle systems! Here’s what you need to know about particle systems in general. In a moment, we’ll look at their relationship to Babylon.js and how we can use them for fun and profit.</p>
<p>Think back to the last video game you played. If it was a text-based game, then think of the last game you played that wasn’t text-based. Did the game have explosions? Are there magic fireballs exploding? What about fireworks or campfires? Each of these is an example of where a particle system might be employed by a game developer. </p>
<p>Let’s back up a bit. A particle is a single entity with a discrete life cycle of creation and death. It is usually represented not with a single mesh but with a texture, for most particles are 2D billboard textures or sprites. The texture or image has transparency properties blended into the rest of the scene in a varying number of ways. If “transparency properties” is confusing, it can be helpful to recall that transparency refers to the alpha channel, and the properties of this channel are the instructions to the engine on how to blend or mix that channel with overlapping colors. This means that often, a particle will always be oriented so that it is always directly facing the camera, and that it will have the ability to fade in and out of view.</p>
<p>A particle system is <a id="_idIndexMarker479"/>more than just an aggregation of particles. A particle system is what defines and controls the entire life cycle of its constituent particles. It does this through a few primary mechanisms:</p>
<ul>
<li><strong class="bold">Emitter(s)</strong>: The<a id="_idIndexMarker480"/> mesh or node where a particle begins its life. Different properties of the emitter allow granular control over parts of the mesh and the shape of the emission, as well as the number of particles emitted and the rate of emissions.</li>
<li><strong class="bold">Particle properties</strong>: Both visual and behavioral, these include size, scaling, rotation, color, and speed for the former, and lifetime for the latter. </li>
<li><strong class="bold">Animations, noise, and blending effects</strong>: Adding noise to the system enhances the realism of the particle system, while animations provide a dynamic look and feel to it.</li>
</ul>
<p>If a particle system is comprised of particles, then what about a collection of particle systems? That is what’s called a Particle System Set, and that is also what we will be employing to give the Sun of Space-Truckers a bit of “flare!”</p>
<p class="callout-heading">Important note</p>
<p class="callout">That last sentence may have been a pun too far.</p>
<p>The advantage of using a Particle System Set is that we can use a single consolidated piece of logic to load, start, and stop all the systems at once. Although we’ll be using the Particle System Set in <a id="_idIndexMarker481"/>our imminent future, there are a couple of other different but related means of generating and managing particles in Babylon.js.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor146"/>The Disparate Particle Systems of Babylon.js</h2>
<p>The family tree of <a id="_idIndexMarker482"/>BJS particle systems isn’t nearly as complex as the Greek pantheon, but what it does share with that fabled genealogy is a separation of generations.</p>
<h3>The “Classic” CPU Particle System</h3>
<p>This is what <a id="_idIndexMarker483"/>everyone knows, loves, and is familiar <a id="_idIndexMarker484"/>with. The vanilla flavor of the three, this offers the greatest amount of end developer (that is, you) programmatic control over every aspect of the particle’s behavior. Because it runs on the CPU every frame, it must share time in the frame budget with everything else the game needs to happen between frames. If the target framerate is 60 FPS, then the intra-frame budget is just 1/60s or just under 17 milliseconds. As any middle-child sibling knows, compromise is key!</p>
<h3>The “New Wave” GPU Particle System</h3>
<p>Since graphics <a id="_idIndexMarker485"/>accelerators have become pretty<a id="_idIndexMarker486"/> much ubiquitous in today’s computing environment (evidenced by a certain Web-GPU JavaScript framework…), so have the tools needed to program them to become more powerful. Later, in <a href="B17266_11_Final_AM.xhtml#_idTextAnchor230"><em class="italic">Chapter 11</em></a>, <em class="italic">Scratching the Surface of Shaders</em>, we’ll take a closer look at how we can easily and effectively leverage this power for fun (and profit!), but for the present moment, the relevant fact is that the same particle systems that we used to run on the CPU are now executed and updated directly on the GPU. The biggest effect of this change is that the number of particles available to use has gone up drastically. Instead of worrying about the effect of a few hundred particles on performance, the same concerns only start to appear when particles number in the tens of<a id="_idIndexMarker487"/> thousands – quite <a id="_idIndexMarker488"/>a large improvement!</p>
<h3>The “Hard Core” Solid Particle System</h3>
<p>When the pedal <a id="_idIndexMarker489"/>hits the pavement and things get real, it’s<a id="_idIndexMarker490"/> time to pull out the big guns. A <strong class="bold">Solid Particle System</strong> (<strong class="bold">SPS</strong>) is constructed not from a point-like particle but from a three-dimensional mesh. Each particle instance must share the same material as the other SPS instances, but the other attributes such as position, scale, rotation, and others are all controlled by the developer. SPS particles can be physics-enabled, along with providing support for collisions. The downside of this level of control and detail is that each property must also be set and controlled individually – unlike a regular particle system that evolves according to the various attribute values associated with it. Hard-coding the individual values for a system is tedious, error-prone, and not very fun to maintain. It’s fine to do that for Playgrounds and prototypes, but for our application, we’re going to want to be able to represent our Particle Systems as data that we can manage separately from the behavior of the application.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor147"/>Loading Particle Systems From Saved Data</h2>
<p>When dealing <a id="_idIndexMarker491"/>with CPU or GPU Particle Systems, it can be extremely tedious and error-prone to type and tweak each specific property through code. The almighty Babylon.js Inspector (praise be its crazy good nature!) is probably the quickest way to iterate against different property values to see what they look like in real time, but how to effectively capture the current state of every property for every particle system in a Particle System Set may appear, at first, to be elusive. However, like many things in Babylon.js, there are multiple ways to accomplish the same goal. Fortunately, though, there are multiple ways to get the same result; each of them makes use of different methods of the <strong class="bold">ParticleHelper</strong>. All three are available to use in the Inspector (see <em class="italic">Figure 7.2</em>), which can be used to choose the most appropriate method for the requirements of the project. </p>
<h3>ExportSet/Save to File (Inspector)</h3>
<p>First up <a id="_idIndexMarker492"/>is <a id="_idIndexMarker493"/>the <a id="_idIndexMarker494"/>purely <a id="_idIndexMarker495"/>programmatic approach of calling <code>ParticleHelper.ExportSet(setA, setB,…)</code>. The output of the function is a JSON string, which can then be saved to a file or stored somewhere else. It’s easiest to use this method in the Playground after putting together multiple systems. Using the Inspector, it’s possible to save a single system to JSON by selecting the desired system in the Scene Explorer, then clicking the <strong class="bold">Save…</strong> button under the <strong class="bold">FILE</strong> heading. This is useful for single-system <a id="_idIndexMarker496"/>setups, but <a id="_idIndexMarker497"/>for<a id="_idIndexMarker498"/> saving multiple<a id="_idIndexMarker499"/> systems to file, the <strong class="bold">ExportSet</strong> is the best option. </p>
<h3>Saving a Snippet to the Snippet Server (Inspector)</h3>
<p>With the <a id="_idIndexMarker500"/>Babylon.js Playground <a id="_idIndexMarker501"/>open in a <a id="_idIndexMarker502"/>browser – here’s one for reference: <a href="https://playground.babylonjs.com/%23735KL4%2315">https://playground.babylonjs.com/#735KL4#15</a> – notice how the specific Playground is identified by a unique combination of a hash (the #735KL4 part) and a revision (#15). Well, the idea of making Playground resources referenceable in that fashion worked so well that the concept has been extended to many other areas of Babylon.js. </p>
<p>Want to load up a GUI setup<a id="_idIndexMarker503"/> in the <code>ParticleHelper.CreateFromSnippetAsync</code>. You can read more about the Snippet Server for Particle Systems in the official docs: <a href="https://doc.babylonjs.com/divingDeeper/particles/particle_system/particle_snippets">https://doc.babylonjs.com/divingDeeper/particles/particle_system/particle_snippets</a>.</p>
<h3>Using a Built-In Particle System Set</h3>
<p>Aristotle was an<a id="_idIndexMarker505"/> influential <a id="_idIndexMarker506"/>guy even during his time, and his idea that things are made of four “elements” – air, earth, fire, and water – was widely accepted as being true, mostly due to good marketing. In that spirit, Babylon.js provides a basic “elemental” catalog of particle system sets for you to use. Here are the available effects (see more about them in the docs at <a href="https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper#available-effects">https://doc.babylonjs.com/divingDeeper/particles/particle_system/particleHelper#available-effects</a>):</p>
<ul>
<li><strong class="bold">Explosion</strong>: Good for blowing stuff up.</li>
<li><strong class="bold">Rain</strong>: For that extra bit of melancholy.</li>
<li><strong class="bold">Smoke</strong>: Useful to signal the selection of a new Pope, but also for a lot of other things. Just remember, where there’s smoke, there’s often…</li>
<li><strong class="bold">Fire</strong>: Whether it’s a campfire, a torch, or a good old-fashioned house fire, this is the place to start.</li>
<li><strong class="bold">Sun</strong>: Jackpot! This particle set includes flares, a dynamically evolving surface, and the hazy glare of a coronasphere. There’s just one problem…</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">There was another theory floating around that things are made of these tiny, indivisible particles called (<em class="italic">ἄτομος</em>, or <em class="italic">atomos</em>), but its main proponent, Democritus, wasn’t as popular as Aristotle, so nobody listened to him. Who’s got the last laugh now, Aristotle?</p>
<p>What’s this problem <a id="_idIndexMarker507"/>mentioned? It’s <a id="_idIndexMarker508"/>not a big one. It’s kind of – no, it’s exactly the opposite of a big problem. It’s a small problem, one of scale. The Sun effect is perfect for our needs, but it’s way, way, way too small. We need to be able to scale it up to match our astronomical proportions, but it’s not going to be precise in how or where things are scaled – that will take some experimentation. The Playground at <a href="https://playground.babylonjs.com/%23J9J6CG%239">https://playground.babylonjs.com/#J9J6CG#9</a> shows the tweaks involved that were eventually incorporated into the JSON data committed to the Space-Truckers code repository.</p>
<p class="callout-heading">Note</p>
<p class="callout">Though it would be ideal to include all the various game design aspects and decisions involved in this book, it isn’t possible to anticipate everything ahead of time. There are also pragmatic limits as to how large this book can get. Therefore, where applicable, links will be provided to GitHub Issues that provide details about the feature or part of the game. Issues in GitHub can be linked to other Issues and to Pull Requests (among other things), which makes it easy to quickly assess and evaluate the code associated with a given Issue or feature. Relevant to our current work, this issue – <em class="italic">Star should have occasional flares and activity</em> (<a href="https://github.com/jelster/space-truckers/issues/71">https://github.com/jelster/space-truckers/issues/71</a>) – aggregates links from the Babylon.js docs and from Playground snippets to provide insight into the desired outcome. Comments and linked Pull Requests show the history and evolution of the issue. This isn’t to say that we’re not going to cover the game design or details of it – far from it! Simply put, things in software evolve and change at a vastly disproportionate rate to that of other goods and industries, such as publishing. Those wishing to see how the game has evolved can do so by reading through the Issues documenting that change.</p>
<p>Before we can get into those changes, we must figure out how to load and start the Particle <a id="_idIndexMarker509"/>System Set from a <a id="_idIndexMarker510"/>JSON file. There is friction in attempting this. The <strong class="bold">ParticleHelper</strong> is <a id="_idIndexMarker511"/>designed and built with the focus on removing complexity for developers, certain aspects of which can be obstacles to our goals.</p>
<h3>Parsing From a JSON File</h3>
<p>One of those<a id="_idIndexMarker512"/> convenient features<a id="_idIndexMarker513"/> that ends up becoming a bit of an obstacle is that the <code>CreateAsync</code> method of <code>PracticalHelper</code> takes just a string representing the type of the system to create – that is, “rain,” “smoke,” “Sun,” and so on. This string is then used in conjunction with <code>ParticleHelper.BaseAssetsUrl</code> to construct the full URL for the JSON file. Unless explicitly overridden, <code>BaseAssetsUrl</code> has a value of <a href="https://github.com/BabylonJS/Assets/tree/master/particles/">https://github.com/BabylonJS/Assets/tree/master/particles/</a>. The structure of the folders places the JSON files in a <code>/systems</code> subfolder and textures in the <code>/textures</code> subfolder – a nice consistent convention that works great for most use cases, save ours. The main conflicts with our setup are as follows:</p>
<ul>
<li>Our folder structure is different from what the convention assumes</li>
<li>Multiple assets need to use the same textures</li>
<li>We are using webpack to bundle and manage our assets and dependencies, so our design-time folder structures vary slightly from that of runtime</li>
<li>Relying on external sources for core game assets and data complicates and prevents offline/native/PWA-type scenarios</li>
</ul>
<p>The first and last items can be mitigated, to an extent, by using relative paths and by overriding <code>BaseAssetsUrl</code> and making it something like <code>document.baseURI</code>. The middle two, however, require a bit more thinking to resolve. Examining the <strong class="bold">ParticleHelper</strong> source<a id="_idIndexMarker514"/> code (see <a href="https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Particles/particleHelper.ts">https://github.com/BabylonJS/Babylon.js/blob/master/packages/dev/core/src/Particles/particleHelper.ts</a>) reveals that there’s no practical way to override the conventional logic that computes the URL of the JSON file. However, once past that step, parsing and hydrating the particle system set is very straightforward. The problem here isn’t that we can’t use the conventional approach, it’s that because of webpack, we don’t need to figure out how to load the JSON data – we already have it, while the <strong class="bold">ParticleHelper</strong> expects to have to retrieve the same. It’s time to start thinking like everyone’s favorite field engineer from the mid-1980s, MacGyver. </p>
<p><strong class="bold">What would MacGyver do</strong> (<strong class="bold">WWMD</strong>)? MacGyver’s <a id="_idIndexMarker515"/>greatest strength wasn’t that he was big and brawny, or that he could kick bad-guy butt in a fistfight. It wasn’t even his luxurious mane of hair that would make an Olympian God (or Goddess!) jealous. No, MacGyver’s<a id="_idIndexMarker516"/> greatest strength was that he <a id="_idIndexMarker517"/>could build, hack, or otherwise science his way out of pretty much any situation he found himself stuck in. By paying attention to his surroundings and then applying his (extensive) knowledge of subjects far and wide, he proved that a sharp eye and a clever mind can overcome almost any obstacle. Let’s look at this problem through a MacGyver-tinted lens:</p>
<p>“<em class="italic">We need to get a ParticleSystemSet before the bomb goes off! The JSON data is loaded, but the ParticleHelper needs the URL string, and there’s only one minute left until everything goes boom… What else do we have, let’s see… ah! Pass the object data to ParticleSystemSet.Parse and bypass the ParticleHelper entirely but do it quickly – we’re running out of time!</em>”</p>
<p>So, according to MG up there, we don’t want to use the <code>ParticleSystemSet.Parse</code>, since that’s what the <code>Parse</code> method (<a href="https://doc.babylonjs.com/typedoc/classes/babylon.particlesystemset#parse">https://doc.babylonjs.com/typedoc/classes/babylon.particlesystemset#parse</a>). Knowing that we were starting with a plain old JavaScript object deserialized from the correct definition file, he made the rather obvious (in hindsight, natch) conclusion that since the result (a <code>name</code> property. Thanks to MG, we have the tools we need to be able to<a id="_idIndexMarker519"/> integrate the Sun particle <a id="_idIndexMarker520"/>system set with our application!</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor148"/>Adapting the Sun Particle System Set</h2>
<p>The proof-of-concept <a id="_idIndexMarker521"/>Playground (<a href="https://playground.babylonjs.com/%23J9J6CG%239">https://playground.babylonjs.com/#J9J6CG#9</a>) gave us a general idea of where to scale things in the game, but there’s more to be done to get the Sun system working the way we want it to. The Playground only has one of the three particle systems – the flare system – while there are two others; that is, the Sun and glare systems. These must also be properly scaled and configured. The best way to get it done is by following these steps:</p>
<ol>
<li>Go to the Babylon.js assets repository and save the needed JSON and texture files to the local repository. For example, the Sun set is located at <a href="https://github.com/BabylonJS/Assets/blob/master/particles/systems/sun.json">https://github.com/BabylonJS/Assets/blob/master/particles/systems/sun.json</a>.</li>
<li>Open the <code>sun.json</code> file and change the texture paths to reflect the project’s folder structure. Use relative paths, but make sure to consider the relative path of the consuming script, not the path of the JSON file. In the <code>Star</code> class, add the necessary code to load and start the set (see <a href="https://github.com/jelster/space-truckers/blob/ch7/src/route-planning/star.js#L26">https://github.com/jelster/space-truckers/blob/ch7/src/route-planning/star.js#L26</a>).</li>
<li>With the application running and on the appropriate screen, open the <strong class="bold">Inspector</strong> window by pressing the appropriate key combination (<em class="italic">Shift</em> + <em class="italic">Alt</em> + <em class="italic">I</em> by default). Modify the properties of the systems and wait for the changes to take effect.</li>
<li>Update the properties of the various systems so that they match the desired values.</li>
<li>GOTO (3).</li>
</ol>
<p>The result will be whatever you think looks the coolest, but if you want to start with or just go with the<a id="_idIndexMarker522"/> existing definition, you can find it at <a href="https://github.com/jelster/space-truckers/blob/ch7/src/systems/sun.json">https://github.com/jelster/space-truckers/blob/ch7/src/systems/sun.json</a>:</p>
<div><div><img alt="Figure 7.1 – After the Sun particle system has been adapted to the scale of Space-Truckers. The Inspector window is crucial to being able to see the effect of different values in real time" height="1001" src="img/Figure_7.01_B17266.jpg" width="1658"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – After the Sun particle system has been adapted to the scale of Space-Truckers. The Inspector window is crucial to being able to see the effect of different values in real time</p>
<p>In general, the particle counts may need to be increased for the Sun and glare particles, but whatever the change, make sure to wait a few seconds for it to propagate to newly spawned particles, since some may have lifetimes measured in the low 10s of seconds! </p>
<p>In this section, we’ve learned about the different types of particle systems available in Babylon.js, as well as some techniques to quickly iterate toward finding our desired look and feel. Hopefully, we’ve made ol’ Mac proud by channeling his clever knack for finding solutions to the problem of loading up and adapting the Sun <code>CargoUnit</code> as it traverses the system in its flight.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Marking Out the Route</h1>
<p>A key aspect of the <a id="_idIndexMarker524"/>gameplay of Space-Truckers is how the path taken by <code>CargoUnit</code> in the route planning phase affects the challenges – and the rewards – of the driving phase. We’ve already tackled the ballistic flight mechanics of the route planning, so now, we need to capture that route and data about the environments it traverses. The following diagram shows the primary properties of our route and how they might be represented: </p>
<div><div><img alt="Figure 7.2 – Various pieces of telemetry are captured during the in-flight part of route planning. The Position, rotation, velocity, and a timestamp are all collected for each sample&#13;&#10;" height="1392" src="img/Figure_7.02_B17266.jpg" width="885"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Various pieces of telemetry are captured during the in-flight part of route planning. The Position, rotation, velocity, and a timestamp are all collected for each sample</p>
<p>Here, the idea that <code>CargoUnit</code> is what is responsible for saving its path, which translates out to the <code>CargoUnit</code> class, thus gaining a new <code>routePath[]</code> property along with associated logic in the <code>reset()</code> and <code>update()</code> methods to clear and update the path, respectively. The data itself is simple, though we’ll get into the <code>encounterZone</code> field in a bit:</p>
<pre class="source-code">&#13;
let node = new TransformNode("cargoNode", this.scene, &#13;
    true);&#13;
node.position = this.mesh.position.clone();&#13;
node.rotationQuaternion = this.mesh.rotationQuaternion?.&#13;
    clone() ?? &#13;
    Quaternion.FromEulerVector(this.rotation.clone());&#13;
node.scaling = this.lastVelocity.clone();&#13;
node.velocity = this.lastVelocity.clone();&#13;
node.gravity = this.lastGravity.clone();&#13;
node.time = this.timeInTransit;&#13;
node.encounterZone = this.encounterManager.&#13;
    currentZone?.name;</pre>
<p>A <code>TransformNode</code> is a <a id="_idIndexMarker525"/>non-rendered object in the <code>TransformNode</code> is useful in the <em class="italic">Adding Encounter Visuals</em> section. Because they implement everything needed to calculate and place the node’s position in the world of the Scene, <code>TransformNodes</code> are useful in a lot of different applications. This includes the ability to both be a parent and/or a child to other objects within the Scene. Some examples include a “camera dolly” made by parenting a <code>PhysicsImpostor</code>. </p>
<p>Since this code comes right after we’ve freshly calculated the velocity, gravity, and rotation properties, we’re ensuring that we have the latest and most up-to-date values. Why are we storing the rotation as a <strong class="bold">Quaternion</strong> rather than the <strong class="bold">Vector3</strong> representation we already have? The reason is that we are going to want to perform some mathematical transformations against mesh vertices in a <strong class="bold">local space</strong>, rather than <strong class="bold">world space</strong>, and having the quaternion already computed makes for more simple calculations, as well as being more efficient.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Don’t forget that JavaScript reference types assign by reference, not by value – hence the need to clone the Vector3 property values.</p>
<p>Although that’s all there is to capturing the path telemetry data, there’s still more work to do before this will start to be useful in the game. One of those pieces of work is to implement the concept of an <strong class="bold">Encounter Table</strong> and its concomitant <strong class="bold">Encounter Zones</strong>. After that, we can start to put the two together into the <strong class="bold">SpaceTruckerEncounterManager</strong>. If you want to get more in-depth into the history and linkages <a id="_idIndexMarker526"/>between the different components we’ll be talking about and their high-level design, <a href="https://github.com/jelster/space-truckers/issues/70">https://github.com/jelster/space-truckers/issues/70</a> is a good place to start. </p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor150"/>Defining the Encounter Zone</h1>
<p>An <strong class="bold">Encounter Table</strong> is<a id="_idIndexMarker527"/> what<a id="_idIndexMarker528"/> it says on the box: it’s a tabular format of probabilities for certain events to occur based on a random factor. In tabletop and RPG-style games, the random factor is provided by rolling one or more dice of various numbered sides. In computer-based games, the same thing applies, except that instead of tossing physical dice, we’ll generate encounters based on the output of a random number generator. </p>
<p>Like much of the rest of the game objects, the <strong class="bold">Encounter Zones</strong> (<strong class="bold">EZs</strong>) are updateable game components, while each Encounter serves as a container for data defining that encounter. This allows <a id="_idIndexMarker529"/>the <strong class="bold">EncounterManager</strong> to choose which EZ should be responsible for running encounter checks, simplifying the logic required in the EZ. Easy, right?</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Encounters Overview</h2>
<p>The structure of<a id="_idIndexMarker530"/> an Encounter table is simple. Down each row is a specific event or encounter that the game designer wants to make possible. A probability column in the table indicates the likelihood of that event occurring in the form of a number between 0 (no chance whatsoever) and 1 (guaranteed). This is a good start, but we need to be able to further group encounters by their spatial locations in the world; it wouldn’t make much sense to encounter a solar flare in the dark reaches of the Outer System, would it? That’s where the concept of an Encounter Zone comes in.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Encounter Zones and Encounter Tables</h2>
<p>An Encounter <a id="_idIndexMarker531"/>Zone is <a id="_idIndexMarker532"/>an Encounter Table scoped to a specific spatial location in the game world, as alluded to previously. From the Inner System to the Outer Reaches, each Encounter Zone has a unique set of potential encounters for the player to deal with – or benefit from! The following is a table of encounters grouped by zone that was part of the Space-Truckers game design specifications. Incomplete and purposefully vague on specifics, it still provides a clear picture of how the feature should work and interoperate with other features:</p>
<div><div><img alt="Figure 7.3 – Design for the Space-Truckers encounter. Source: https://github.com/jelster/space-truckers/issues/65" height="1033" src="img/Figure_7.03_B17266.jpg" width="1356"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Design for the Space-Truckers encounter. Source: <a href="https://github.com/jelster/space-truckers/issues/65">https://github.com/jelster/space-truckers/issues/65</a></p>
<p>When implementing encounters, there will be different needs and thus differently structured solutions for each type of encounter. Fortunately, we don’t need to define those <a id="_idIndexMarker533"/>specifics <a id="_idIndexMarker534"/>quite yet, so we’ll park it for the moment and take a step back to look at how the <strong class="bold">Encounter Zone</strong> can track <strong class="bold">CargoUnit</strong>.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Tracking Intersections</h2>
<p>Each EZ needs to register the <a id="_idIndexMarker535"/>intersection exit and enter triggers for the <code>CargoUnit</code> mesh’s Action Manager, but we don’t want to have to write code to do that for each Zone – what if we change the number of <code>EncounterZones</code>, or want to change the way intersections are used? Thankfully, this problem can be solved easily. </p>
<p>When the <code>initialize</code> method of <code>SpaceTruckerEncounterManager</code> is invoked, the list of <code>encounterZones</code> is iterated across in a <code>forEach</code> loop. Among other actions, each zone is passed by <code>cargo.mesh</code> as a parameter to its <code>registerZoneIntersectionTrigger</code> method. This function performs the intersection registration on <code>meshToWatch.actionManager</code>, which hooks up the corresponding <code>OnIntersectionExitTrigger</code> and <code>OnIntersectionEnterTrigger</code> to the EncounterZone’s <code>onExitObservable</code> and <code>onEnterObservable</code>, respectively. </p>
<p class="callout-heading">Note</p>
<p class="callout"><code>SpaceTruckerEncounterManager</code> is a member of <code>CargoUnit</code>.</p>
<p>The primary purpose of <code>SpaceTruckerEncounterManager</code> is to (as the name implies) manage encounters in its constituent Zones but to be able to do that, it needs to know which EZ <code>cargoUnit</code> is currently transiting. You may initially surmise that because <code>EncounterZone</code> has a torus shape, nested (but not overlapping) zones should fire<a id="_idIndexMarker536"/> their intersection triggers only when the mesh is crossed, but that’s not the case in practice. </p>
<p>Performing intersection calculations against a complex mesh is a very computationally expensive process, making it not very suitable for real-time processing applications. Instead, what Babylon.js does is use the much less expensive and computationally efficient bounding box intersection calculations. Though fast, they do not mimic the actual geometries being tested very accurately, resulting in a problem wherein the cargo unit appears to the application as if it is within not just the zone at its location but all other zones that are nested around it! </p>
<p>To resolve this, <code>SpaceTruckerEncounterManager</code> keeps track of all triggered intersections with the <code>inAndOut</code> field. Incremented whenever a zone signals the entrance, and decremented for the converse, it is an integer that represents an index to <code>currentZone</code> that’s offset by the total number of encounter zones:</p>
<pre class="source-code">&#13;
get currentZone() {&#13;
    let zidx = this.encounterZones.length - this.inAndOut;&#13;
    return this.encounterZones[zidx]?.zone;&#13;
}</pre>
<p>This property is used in several areas, from <code>CargoUnit</code> to the Route Planning GUI, but the underlying zones in the encounter manager need to be populated ahead of time with data defining <a id="_idIndexMarker537"/>the boundaries and characteristics of each zone.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor154"/>Encounter Zones and Game Data</h2>
<p>An <strong class="bold">Encounter Zone</strong> (like<a id="_idIndexMarker538"/> most <a id="_idIndexMarker539"/>software components) is defined by its behaviors and data. The data comes from the encounter zone’s definition and looks something like this:</p>
<pre class="source-code">&#13;
asteroidBelt: {&#13;
    id: "asteroid_belt",&#13;
    name: "Asteroid Belt",&#13;
    innerBoundary: 1000,&#13;
    outerBoundary: 1700,&#13;
    encounterRate: 0.2,&#13;
    colorCode: "#ff0000",&#13;
    encounters: [&#13;
        { id: 'rock_hazard', name: 'Rock Hazard', image&#13;
            hazard_icon, probability: 0.90 },&#13;
        { name: '', id: 'no_encounter', probability: 0.1, &#13;
            image: '' }&#13;
    ]&#13;
}</pre>
<p>At construction time, <code>SpaceTruckerEncounterZone</code> uses this structure (passed as a parameter to the constructor) to initialize and configure the EZ. Some properties are self-explanatory, but <code>innerBoundary</code> and <code>outerBoundary</code> warrant explicit definitions, along with <code>encounterRate</code>. Once we’ve covered those, we’ll dive into the encounters array and how it works.</p>
<p>The <code>innerBoundary</code> field is <a id="_idIndexMarker540"/>the <code>outerBoundary</code> is the radius of the outer circle described by the torus. Though this makes sense from a conceptual viewpoint, it is a bit different from how the<a id="_idIndexMarker541"/> Babylon.js <code>createTorus</code> method, the primary “knobs and switches” available to control the size of the mesh are the <code>diameter</code> and <code>thickness</code> parameters. These two values sound like they would work well if we were to pass <code>outerBoundary</code> and <code>(outerBoundary – innerBoundary)</code>, respectively, but closely reading the parameter descriptions tells us a different story. </p>
<p>The best way<a id="_idIndexMarker542"/> to <a id="_idIndexMarker543"/>picture how the various parameters all fit together is by taking a length of wire and forming it into a half-circle of some radius, <code>2 * r</code>. Now, picture taking a small paper coaster of the radius, <code>2 * R</code>. The outer boundary of the torus isn’t the same as the diameter parameter – it’s equal to the diameter plus one-half the thickness. The inner boundary is equal to half of the diameter minus half the thickness. That’s not the best way to picture this, but it is one way to describe it! Here’s something better than a description – a visualization for that analogy, available at the Playground link in the caption:</p>
<div><div><img alt="Figure 7.4 – The properties of a torus. The diameter is depicted by a solid circle with its thickness described by a second smaller circle. This Playground can be found at https://playground.babylonjs.com/#P2YP2E#1&#13;&#10;" height="421" src="img/Figure_7.04_B17266.jpg" width="1066"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – The properties of a torus. The diameter is depicted by a solid circle with its thickness described by a second smaller circle. This Playground can be found at <a href="https://playground.babylonjs.com/%23P2YP2E%231">https://playground.babylonjs.com/#P2YP2E#1</a></p>
<p>Why are we going through these hoops? Because by structuring it in this way, we can quickly and easily compare<a id="_idIndexMarker544"/> and align encounter zones with planetary orbits, as defined in <strong class="bold">gameData</strong>. </p>
<p>Finally, getting back to the EZ data, the <code>encounterRate</code> field is a percentile (0 – 1) number indicating how often encounters happen in general for the zone. Each zone independently keeps its own encounter table, which it then uses to determine what, if any, encounter <a id="_idIndexMarker545"/>might<a id="_idIndexMarker546"/> occur. Since we’re on the topic of encounters and random numbers, we might as well try to gain an understanding of exactly how to go about implementing the logic of picking entries from the<a id="_idIndexMarker547"/> Encounter Table. For that, we need to talk about something called a <strong class="bold">Cumulative Distribution Mass Function</strong>.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor155"/>Selecting Encounters</h1>
<p>A developer implementing <a id="_idIndexMarker548"/>this kind of functionality for the first time might devise a simple function, <code>getEncounter</code>, that picks a random number to serve as a dice roll before searching through an array of encounters for the first one with a probability less than or equal to the dice roll. To that developer’s chagrin, this simple approach would also be incorrect! Though this approach works when rolling to determine the chance of a singular Encounter, it won’t work when there are multiple potential encounters. Here’s what the Asteroid <a id="_idIndexMarker549"/>Belt <strong class="bold">Encounter Table</strong> looks like in simplified form:</p>
<pre class="source-code">&#13;
encounters: [&#13;
            { id: 'rock_hazard', name: 'Rock Hazard',&#13;
                 image: hazard_icon, probability: 0.90 },&#13;
            { name: '', id: 'no_encounter', probability: &#13;
                0.1, image: '' }&#13;
        ]</pre>
<p>Each entry in the encounter table has an associated probability factor, the total of which will usually (but doesn’t have to due to some code we’ll write shortly) equal 1 (100%). When you want to pick a random entry from the table, it’s necessary to consider all the potential other events that might take place. The fancy-pants way of referring to the process of computing<a id="_idIndexMarker550"/> an event output in response to a random number input is a <strong class="bold">Cumulative (Mass) Distribution Function</strong> (<strong class="bold">CMDF</strong>). In the <strong class="bold">EncounterZone</strong> source (see <a href="https://github.com/jelster/space-truckers/blob/ch7/src/encounterZone.js#L44">https://github.com/jelster/space-truckers/blob/ch7/src/encounterZone.js#L44</a>), the CMDF is implemented in the constructor as a two-step process. </p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor156"/>Summing the Probabilities</h2>
<p>In step one, we<a id="_idIndexMarker551"/> take the sum of all the individual encounters’ probabilities. This step is what will allow the application to handle scenarios where the individual probabilities don’t all add up to 1 and is used by step two. While we’re there, the encounter table gets populated from the definition:</p>
<pre class="source-code">&#13;
var total = 0;&#13;
definition.encounters.forEach((e, i) =&gt; {&#13;
    total += e.probability;&#13;
    this.encounterTable.push(e);&#13;
});</pre>
<p>The point of this step is that while we can’t necessarily guarantee that the total of the probabilities will<a id="_idIndexMarker552"/> come to one, we can normalize that sum in the next step so that each entry in the table is correctly and proportionally represented in the CMDF.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor157"/>Populating CMDF Results</h2>
<p>Step two involves <a id="_idIndexMarker553"/>looping through the list of <code>encounters</code> again (after pre-baking the first element of the <code>cumulativeDistribution</code> array) and populating entries into a second array – the aforementioned <code>cumulativeDistribution</code> array. This collection’s entries represent the <strong class="bold">CMDF</strong> over its entire space and can therefore be used as an index to look up values for arbitrary inputs:</p>
<pre class="source-code">&#13;
this.cumulativeDistribution[0] = this.encounterTable[0].&#13;
    Probability / total;&#13;
for (var I = 1; i &lt; definition.encounters.length; i++) {&#13;
    this.cumulativeDistribution[i] = &#13;
        this.cumulativeDistribution[i - 1] + &#13;
            definition.encounters[i].probability / total;&#13;
}</pre>
<p>Note that because the loop looks backward, the first element is calculated outside of the loop, which then starts at the <code>this.cumulativeDistribution[i]</code>) is equal to the previous element’s value added to the current encounter’s share of <code>probability</code> toward <code>total</code>. This only needs to happen once, upon initialization. Once in place, it is now possible to “roll the dice” and implement a more correct form of <code>getEncounter</code>.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor158"/>Rolling an Encounter Check</h2>
<p>Every time <code>update</code> method is called, the logic will evaluate whether an <a id="_idIndexMarker554"/>encounter happens before deciding which encounter is going to take place. It needs to consider how much time has elapsed since the last frame, as it would then tie encounters to a player’s frame rate – not what we want! Once that is considered, and if there is indeed an encounter indicated for the zone, the <code>getEncounter</code> method is called to retrieve a random entry from <code>encounterTable</code>. The encounter retrieved is then passed as the event parameter for <code>onEncounterObservable</code>, letting any subscriber know about <code>encounter</code>:</p>
<pre class="source-code">&#13;
const encounterProbability = this.encounterRate * deltaTime;&#13;
if (Math.random() &lt; encounterProbability) {&#13;
    let encounter = this.getEncounter();&#13;
    console.log('encounter ' + encounter?.name);&#13;
    this.onEncounterObservable.notifyObservers(encounter);&#13;
} </pre>
<p>That’s the update loop in its entirety. If only life could always be as elegant and simple as these solutions, maybe people would get along better, because the <code>getEncounter</code> method boils down to a single line of correct, though slightly esoteric, JavaScript:</p>
<pre class="source-code">&#13;
for (var i = 0; i &lt; this.cumulativeDistribution.length &amp;&amp; (diceRoll &gt; this.cumulativeDistribution[i]); i++) {};  </pre>
<p>The reason this is a bit esoteric is that, as you might have noticed, the <code>for</code> loop has no body! There isn’t a body in the loop because, simply put, there isn’t a need for any. The purpose of the loop is to find the index (<code>i</code>) that conforms to the <code>diceRoll</code> number. Once that condition has been fulfilled, the <code>i</code> value sticks around due to being declared with <code>var</code> rather than with <code>let</code>. The encounter itself is retrieved as an index and returned to the calling method for distribution.</p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor159"/>Listening for Encounters</h2>
<p>Once the <code>SpaceTruckerEncounterManager</code>, which then acts as a broker and aggregator for distributing the news of <code>Encounter</code> throughout the application in its <code>onEncounter</code> observer method. The same observer is subscribed to all the zone’s <code>onEncounterObservable</code>, which is what gives us the aggregation of these events that we need, along with <a id="_idIndexMarker557"/>the <code>lastFlightPoint</code> telemetry package. </p>
<p>Both the encounter and <code>cargoData</code> are then bundled together and pushed into the <code>encounterEvents</code> array for future reference. The index of the newly added element is what is then propagated to observers of <code>onNewEncounterObservable</code>:</p>
<pre class="source-code">&#13;
const cargoData = this.cargo.lastFlightPoint;&#13;
const idx = this.encounterEvents.push({ encounter,&#13;
    cargoData });&#13;
this.onNewEncounterObservable.notifyObservers(idx - 1);</pre>
<p>The reason we are passing an index (or pointer) to the <code>encounterEvents</code> collection is that we want to ensure that we can dispose of those objects cleanly and at any time; if the object were passed in the event, it might not be possible for the system to determine whether memory can be freed up from disposed-of objects – a condition known as a memory leak.</p>
<p>At this point, we have finished inspecting and discussing the underlying infrastructure needed to define, locate, and generate encounters of different types. These encounters will be brought to <a id="_idIndexMarker558"/>life later in this book when we get into the driving phase game logic for each encounter. However, while our understanding of encounters is fresh, let’s look at how encounters might be used and presented within the context of the route planning screen.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Adding Encounter Visuals</h1>
<p>This is where our <a id="_idIndexMarker559"/>previous work in the <em class="italic">Marking Out the Route</em> section comes into play. Recall that as our <code>CargoUnit</code> falls through its trajectory, it is constantly laying down a line of breadcrumbs to mark out its path. This is visualized by the <code>CargoUnit.trailMesh</code> component, which other than needing to be initialized and disposed of during scenario resets, takes care of itself without much need for us to intervene. We need an equivalently hands-off way to similarly render visualizations for encounters when and where they occur along the route, and that’s precisely what the<a id="_idIndexMarker560"/> work we just covered is meant to enable.</p>
<p class="callout-heading">Important note:</p>
<p class="callout">While the following section is ultimately cut from the game, the technique demonstrated is helpful to have in your pocket.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>Putting 2D Labels into 3D Space</h2>
<p>Although there is <a id="_idIndexMarker561"/>a 3D GUI system<a id="_idIndexMarker562"/> in Babylon.js, our<a id="_idIndexMarker563"/> current needs don’t require the use of a full 3D UI. Still, one of the advantages of a 3D GUI is that it is easy to position elements within the World Space – for reasons that should hopefully be obvious. </p>
<p class="callout-heading">Note</p>
<p class="callout">Unlike jokes, there’s no risk of ruining this with an explanation. The obvious reason is that positioning 2D elements concerning a 3D world-space point can get tricky because of the need to combine camera position, world position, and screen position transformations to get the correct coordinates as opposed to a 3D GUI system operating in the same coordinate space.</p>
<p>Much of the complexity inherent in coordinate transformations is, fortunately, hidden away from the developer by the BJS GUI framework – <code>linkWithMesh</code> and <code>moveToVector</code> both allow callers to place a GUI control somewhere in the <strong class="bold">World Space</strong>. That’s good for part of the way, but we still need to have someplace to hang the visuals as well as provide a base for future enhancements and behaviors. </p>
<p>If you’ve come back to this section after a break, you can thank your Past Self for putting all the pieces into place. If you’ve been binging through this chapter (don’t stop – won’t stop – can’t stop!) then take a moment to pat yourself on the back. It’s important to take the time to properly acknowledge yourself and the impact of previous actions on present situations – both good and bad! This is going to be easy, in other words.</p>
<p>Remember how we used a <code>TransformNode</code> to track our cargo’s flight path? This is where that decision is finally justified. Most <code>linkWithMesh</code> function, whose name implies that you must only pass a Mesh. This would be a wrong, though understandable, conclusion to make that can be remedied by studying the method’s documentation and seeing that while the name of the parameter is <code>mesh</code>, the<a id="_idIndexMarker564"/> expected type of the parameter is our old friend <strong class="bold">Transform Node</strong>!</p>
<p class="callout-heading">Note</p>
<p class="callout">The documentation isn’t <a id="_idIndexMarker565"/>wrong, strictly speaking, because <code>TransformNode</code> type.</p>
<p>The <code>PlanningScreenGui</code> component already has access to the <code>encounterManager</code> property of the <code>planningScreen</code> field in its constructor, so we can subscribe to its <code>onNewEncounterObservable</code> to be notified when a new encounter happens. In the observer function, we get the image URL from the encounter itself and use it to create <a id="_idIndexMarker566"/>Babylon.js GUI elements that are then <a id="_idIndexMarker567"/>linked to the associated <code>TransformNode</code> of<a id="_idIndexMarker568"/> the flight path:</p>
<pre class="source-code">&#13;
const encounter = evt.encounter;&#13;
let panel = new Rectangle("panel-" + encounter.name);&#13;
let image = new Image("image-" + encounter.name, &#13;
    encounter.image);&#13;
image.alpha = 0.68;&#13;
panel.addControl(image);&#13;
panel.thickness = 0;&#13;
this.gui.addControl(panel);&#13;
this.encounterPanels.push(panel);&#13;
panel.linkWithMesh(evt.cargoData);</pre>
<p>That’s the visual placed in the correct spot and with the right image, so now, let’s think about what else is involved with displaying an encounter. First, we want there to be a sound effect that plays. This can be done by registering <code>SpaceTruckerPlanningScreen</code> to <code>onNewEncounterObservable</code>, as shown in the following code:</p>
<pre class="source-code">&#13;
this.encounterManager.onNewEncounterObservable.add(enc =&gt; &#13;
        this.soundManager.sound("encounter").play());</pre>
<p>While we’re not currently using the actual encounter index now, this approach allows it to be easily extended in the future – to allow individual encounters to specify their own sound to play, for instance. When an encounter occurs, we don’t want an icon to simply appear, with no fanfare. We want to make sure the player’s attention is called to it, but only momentarily. One way to accomplish that is to initially render the panel so that it’s much larger than its <a id="_idIndexMarker569"/>eventual size and<a id="_idIndexMarker570"/> then <a id="_idIndexMarker571"/>animate the panel so that it’s shrinking to its final size and position. </p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor162"/>Animating the Encounter Panel</h2>
<p>In <a href="B17266_04_Final_AM.xhtml#_idTextAnchor070"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating the Application</em>, we saw how to statically define an <strong class="bold">Animation</strong> that was<a id="_idIndexMarker572"/> later targeted to a specific object as part of <a id="_idIndexMarker573"/>an <strong class="bold">AnimationGroup</strong>. We will use the same technique here to define the animations involved in shrinking the encounter panel.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Even though it may not seem like it, almost any object can be the target of an <code>scaleX</code> and <code>scaleY</code> properties of the <code>GUI.Image</code> component.</p>
<p>Note that there are two separate animations involved – one each for the <em class="italic">X</em> and <em class="italic">Y</em>-axes –  since an <code>AnimationGroup</code> and use <code>addTargetedAnimation</code> along with the target <code>panel</code> and <code>panelShrink</code> Animation, after which the animation is started:</p>
<pre class="source-code">&#13;
let animationGroup = new AnimationGroup("shrinkAnimationGroup-"+ encounter.name, &#13;
    this.scene);&#13;
animationGroup.addTargetedAnimation(panelShrinkX, panel);&#13;
animationGroup.addTargetedAnimation(panelShrinkY, panel);&#13;
animationGroup.start(false, 1.0, 0, 180, true);   </pre>
<p>This gives us a nice presentation for the encounters, leaving just one more use case that we have yet to<a id="_idIndexMarker574"/> cover – resetting the route planning screen.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>Clearing Encounter Panels</h2>
<p>The list that <a id="_idIndexMarker575"/>encounters the GUI elements that are collected in anticipation of just this scenario is the <code>encounterPanels</code> array. Since each GUI control implements a <code>dispose</code> function, we reset the encounters UI by simply looping through the array and calling <code>dispose</code> on each element in turn. To avoid the need to anticipate every single place we need to do this, we can add the logic to the place it makes the most sense – the <code>onScreenStateChange</code> observer function. Whenever it executes logic to transition to the <code>ReadyToLaunch</code> state, the encounter panel is cleared of any elements and all children are disposed of:</p>
<pre class="source-code">&#13;
this.encounterPanels.forEach(panel =&gt; {&#13;
    panel.children.forEach(child =&gt; child.dispose());&#13;
    panel.dispose();&#13;
});</pre>
<p>That’s all there is to it. </p>
<p class="callout-heading">Important note</p>
<p class="callout">Of course, that’s <em class="italic">not</em> all there is to it! There is much, much more that can be done and is being done in the context of Encounter visuals, but by and large, all of this is based on the same concepts presented throughout this section and chapter. If you haven’t already, don’t forget to remind yourself: game development is hard and there are a lot of moving parts! </p>
<p>Although we have only covered how the encounter GUI panels are cleared, this pattern completes the circle of creation and destruction.</p>
<p>Registering to listen for <code>EncounterManager.onNewEncounterObservable</code> informs<a id="_idIndexMarker576"/> components of new encounters, while setting <code>SpaceTruckerPlanningScreen.onStateChangeObservable</code> to the <code>ReadyToLaunch</code> state clears any existing ones.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor164"/>Summary</h1>
<p>Let’s take a step back and review what we’ve covered in this chapter. First, we took another side route to visit the various Babylon.js particle systems, making use of and adapting the Sun Particle System Set for our purposes. </p>
<p>We can look at particle systems in three rough categories of distinction – the “Classic”, “New Wave”, and “Hard Core” monikers. Each references the always-available CPU-bound Particle System, the GPU-bound GPU Particle System, and the mixed <strong class="bold">Solid Particle System</strong> (<strong class="bold">SPS</strong>). While the first two systems are based around 2D billboards and sprites – characteristics that can animate via sprite sheets and the like – an <strong class="bold">SPS</strong> uses a source mesh to generate particles, which can, in turn, be assigned any type of Material desired (we’ll get more into <strong class="bold">Materials</strong>, the different types, their properties, and more in <a href="B17266_10_Final_AM.xhtml#_idTextAnchor207"><em class="italic">Chapter 10</em></a>, <em class="italic">Improving the Environment with Lighting and Materials</em>).</p>
<p>Loading a custom Particle System Set involves capturing a serialized JSON file containing the specific parameters for each Particle System involved in the appropriate structure. This can be done by calling <code>ParticleHelper.ExportSet(setA, setB,…)</code>. Loading saved JSON from a URL is easy but loading it from a local URL gets a bit more complicated. However, by falling back to the <code>ParticleSystemSet.Parse</code> function, we can load data for the <strong class="bold">ParticleSystemSet</strong> in any way we please!</p>
<p>Following our detour into Particles, we examined the telemetry data our <strong class="bold">CargoUnit</strong> captures during its flight, and how we can use <strong class="bold">TransformNodes</strong> to represent spatial locations. This proves to be crucial for making it easy to display visuals without writing a lot of code and provided a good on-ramp to get into how Encounter Zones work.</p>
<p>Each <strong class="bold">Encounter Zone</strong> can be thought of as a unique biome or environment in the world of <em class="italic">Space-Truckers</em>. From the toasty <strong class="bold">Inner System</strong> to the frosty <strong class="bold">Outer System</strong>, each Zone has its own set of potential Encounters players might face. Defined by an inner and outer Boundary, some light math is involved in converting those handy <strong class="bold">gameData</strong> figures into parameter values used to create a set of nested Torus meshes to represent the zones. Not rendered, these meshes’ <strong class="bold">ActionManagers</strong> are used to register <strong class="bold">IntersectionEnter</strong> and <strong class="bold">IntersectionExit</strong> triggers against the <strong class="bold">CargoUnit</strong>. As it traverses the system, the <strong class="bold">SpaceTruckerEncounterManager</strong> keeps track of which Zone the player’s <strong class="bold">CargoUnit</strong> is currently transiting.</p>
<p>While transiting a given zone, the Zone’s <code>update</code> method makes a weighted random check every frame to decide whether there should be an Encounter, selected from the Zone’s Encounter Table. The Encounter Zone’s constructor pre-computes the <strong class="bold">Cumulative Mass Distribution Function</strong> values for every entry in the Table, normalizing the probabilities so that the total adds up to 1. If an encounter is “rolled,” the value of the roll (a number between 0 and 1) is used as an input to the function, which returns an index to the indicated event. <strong class="bold">SpaceTruckerEncounterManager</strong> listens for these Encounter Zone events.</p>
<p>Responsible for aggregating Encounter data with <strong class="bold">CargoUnit</strong> data and informing subscribers of where to find the resulting encounter data, the <strong class="bold">onNewEncounterObservable</strong> is the primary means for components such as the <strong class="bold">PlanningScreenGui</strong> to update themselves without needing to pepper appropriate logic throughout the application’s components. Within the <strong class="bold">PlanningScreenGui</strong>, techniques first perfected during the construction of the Splash Screen come in handy. Here, we can define some Animations that target the Encounter’s Image panel to give it a shrinking effect as an entrance. </p>
<p>Within the <code>linkWithMesh</code> and passing in the <strong class="bold">TransformNode</strong> captured from the flight telemetry. </p>
<p>As usual, the code discussed in this chapter is available at <a href="https://github.com/jelster/space-truckers/tree/ch7">https://github.com/jelster/space-truckers/tree/ch7</a>, and while the game is still incomplete at this point in its history, we can point to concrete and valuable progress through the course of this chapter – never forget to give yourself credit for progress made on a journey! The Discussions board at <a href="https://github.com/jelster/space-truckers/discussions">https://github.com/jelster/space-truckers/discussions</a> is a good place to post questions about the code, book, or application. Want to contribute? Navigate to the Issues at <a href="https://github.com/jelster/space-truckers/issues">https://github.com/jelster/space-truckers/issues</a> and browse for open ones that catch your fancy, or create a new Issue to discuss your enhancement, bug, or new feature. In the next chapter, we’re going to make good use of the route and the encounters generated to build the driving mini-game. Along the way, we’ll learn how to shift camera perspectives to a first-person view, apply decals to meshes, and more!</p>
<p class="callout-heading">Note</p>
<p class="callout">There’s an entire category of Issues aimed at first-time contributors and people lacking experience or familiarity with Babylon.js and/or Space-Truckers – it’s called <strong class="bold">Good First Issue</strong>. Want to make MacGyver proud and fix Issues that nobody else can fix? Check out the <strong class="bold">Help Wanted</strong> label! </p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>Extended Topics</h1>
<p>There is always more content and ideas than there are time and space to implement them, so here are some ways that you can push yourself further with the content from this chapter. Before moving on to the next chapter, or at any time later, think of these as launch pads for you to clarify and fold the lessons learned here in the forge of experience:</p>
<ul>
<li>Add a new particle system based on the Sparks particle sample that is triggered when the cargo collides with something during the route planning’s flight phase. </li>
<li>The world of Space-Truckers is rich and varied, and the game could display more of that richness. Use an animated particle system to bring these areas to life:<ul><li>Orbital manufacturing might look like a series of flashing lights from maneuver thrusters and welding torches clustering around shadowed block structures</li><li>Traffic in the Space-Construction and Space-Highway zones could similarly be approximated with clusters of flashing lights zipping around</li></ul></li>
<li>Add the capability to load encounter lists from external sources other than the <strong class="bold">gameData</strong> file. The source can be a relative or remote path, with CMDFs being recomputed for the new list for each zone. </li>
<li>Make an enhanced random number generator that will weigh or re-roll random values to avoid returning the same value more than <em class="italic">X</em> times in <em class="italic">Y</em> rolls. </li>
<li>Random numbers generated by computers tend to cluster and clump unrealistically – the Asteroids are a great demonstration of that. There are other ways to weigh and generate random series of numbers, though. Sneak to the <code>ch10</code> branch of the Space-Truckers source code on GitHub to see how the <code>randomGenerator</code> module implements <code>getGaussianRandom</code> for one example. </li>
</ul>
</div>
<div><div></div>
</div>
</div></body></html>