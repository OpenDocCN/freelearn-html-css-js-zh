<html><head></head><body><div class="chapter" title="Chapter&#xA0;13.&#xA0;Reactive Programming and React"><div class="titlepage"><div><div><h1 class="title"><a id="ch13"/>Chapter 13. Reactive Programming and React</h1></div></div></div><p>Along with ES6, several new ideas are emerging. These are powerful ideas and can help you build powerful systems with more streamlined code and design. In this chapter, we will introduce you to two such ideas-reactive programming and react. Although they sound similar, they are very different. This chapter does not go into practical details of these ideas but gives you necessary information to become aware of what these ideas are capable of. With that information, you can start incorporating these ideas and frameworks into your projects. We will discuss the basic idea of reactive programming and take a bit more detailed look at react.</p><div class="section" title="Reactive programming"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec91"/>Reactive programming</h1></div></div></div><p>Reactive programming is getting a lot of focus lately. This idea is relatively new and, like many new ideas, has lots of confusing, and sometimes contradictory information floating around. We discussed asynchronous programming earlier in this book. JavaScript takes asynchronous programming to new heights by providing first class language constructs that support it.</p><p>Reactive programming is essentially programming with asynchronous event streams. An event stream is a sequence of events happening over time. Consider the following diagram:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_001.jpg" alt="Reactive programming"/></div><p>
</p><p>In the preceding diagram, time passes from left to right and different events occur over time. As the event happens over time, we can add an event listener to this whole sequence. Whenever an event happens, we can react to it by doing something.</p><p>Another type of sequence in JavaScript is an array. For example, consider the following lines of code:</p><pre class="programlisting">    var arr = [1,1,13,'Rx',0,0]; &#13;
    console.log(arr); &#13;
    &gt;&gt;&gt; [1, 1, 13, "Rx", 0, 0] &#13;
</pre><p>In this case, the entire sequence lives in memory at the same time. However, in case of event stream, events happen over time and there is no state at this point of time. Consider the following lines of code:</p><pre class="programlisting">    var arr = Rx.Observable.interval(500).take(9).map(&#13;
      a=&gt;[1,1,13,'Rx',0,0][a]); &#13;
    var result = arr; &#13;
    result.subscribe(x=&gt;console.log(x)); &#13;
</pre><p>Don't worry too much about what is going on in this example just yet. Here, events are happening over time. Instead of having a fixed bunch of elements in an array, here they are happening over time, after 500 ms.</p><p>We will add an event listener to the <code class="literal">arr</code> event stream, and when an event happens, we will print the element on console. You can see a similarity between the methods in arrays and the event streams. Now, to expand on this similarity, let's say, you want to filter all non-numbers from this list. You can use the <code class="literal">map</code> function to this event stream, just like you would use it on an array, and then you would want to filter the results to show only integers. Consider the following lines of code:</p><pre class="programlisting">    var arr = [1,1,13,'Rx',0,0]; &#13;
    var result = arr.map(x =&gt; parseInt(x)).filter(x =&gt; !isNan(x)); &#13;
    console.log(result); &#13;
</pre><p>Interestingly, the same methods work for event streams as well. Take a look at the following code example:</p><pre class="programlisting">    var arr = Rx.Observable.interval(500).take(9).map(&#13;
      a=&gt;[1,1,13,'Rx',0,0][a]); &#13;
    var result = arr.map(x =&gt; parseInt(x)).filter(x =&gt; !isNaN(x)); &#13;
    result.subscribe(x=&gt;console.log(x)); &#13;
</pre><p>These are simpler examples just to make sure you start seeing how event streams flow over time. Please don't bother about the syntax and construct just yet. Before we can look at them, we will need to make sure we understand how to think in reactive programming. Event streams are fundamental to reactive programming; they allow you to define the dynamic behavior of a value at declaration time (definition taken from Andre Staltz's blog).</p><p>Let's say you have an <code class="literal">a</code> variable, which has initially the value <code class="literal">3</code>. Then, you have a <code class="literal">b</code> variable, which is <code class="literal">10 * a</code>. If we console log out <code class="literal">b</code>, we will see <code class="literal">30</code>. Consider the following lines of code:</p><pre class="programlisting">    let a = 3; &#13;
    let b = a * 10; &#13;
    console.log(b); //30 &#13;
    a = 4; &#13;
    console.log(b); // Still 30 &#13;
</pre><p>We know the result is very straightforward. When we change the value of <code class="literal">a</code> to <code class="literal">4</code>, the value of <code class="literal">b</code> will not change. This is how static declaration works. When we talk about reactive programming and event streams, this is the area where people find difficulty in understanding how events flow. Ideally, we want to create a formula, <span class="emphasis"><em>b=a*10</em></span>, and over time, whenever the value of <code class="literal">a</code> changes, the changed value is reflected in the formula.</p><p>That is what we can accomplish with event streams. Let's say <code class="literal">a</code> is an event stream of just the value <code class="literal">3</code>. Then, we have <code class="literal">streamB</code>, which is <code class="literal">streamA</code> mapped. Each of these <code class="literal">a</code> values will be mapped to <code class="literal">10 * a</code>.</p><p>If we add an event listener to that <code class="literal">streamB</code>, and we console log, we will see <code class="literal">b</code> being <code class="literal">30</code>. Take a look at the following example:</p><pre class="programlisting">    var streamA = Rx.Observable.of(3, 4); &#13;
    var streamB = streamA.map(a =&gt; 10 * a); &#13;
    streamB.subscribe(b =&gt; console.log(b)); &#13;
</pre><p>If we do this, we have an event stream that simply has just two events. It has event <code class="literal">3</code>, and then it has event <code class="literal">4</code>, and <code class="literal">b</code> will change accordingly whenever <code class="literal">a</code> changes. If we run this, we see <code class="literal">b</code> being <code class="literal">30</code> and <code class="literal">40</code>.</p><p>Now that we have spent some time in getting the basics of reactive programming sorted, you may ask the following question.</p><div class="section" title="Why should you consider reactive programming?"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec167"/>Why should you consider reactive programming?</h2></div></div></div><p>As we write highly responsive and interactive UI applications on modern web and mobile, there is a strong need to find a way to deal with real-time events without stopping the user interactions on the UI. When you are dealing with multiple UI and server events being fired, you will be spending most of your time writing code to deal with these events. This is tedious. Reactive programming gives you a structured framework to deal with asynchronous events with minimal code while you focus on the business logic for your application.</p><p>Reactive programming is not limited to JavaScript. Reactive extensions are available in many platforms and languages, such as Java, Scala, Clojure, Ruby, Python, and Object C/Cocoa. <code class="literal">Rx.js</code> and <code class="literal">Bacon.js</code> are popular JavaScript libraries that provide reactive programming support.</p><p>A deep dive into <code class="literal">Rx.js</code> is not the intention of this chapter. The idea was to introduce you to the idea of reactive programming. If you are keen on adopting reactive programming for your projects, you should take look at Andre Staltz's excellent introduction (<a class="ulink" href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">https://gist.github.com/staltz/868e7e9bc2a7b8c1f754</a>).</p></div></div></div>
<div class="section" title="React"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec92"/>React</h1></div></div></div><p>React is taking the JavaScript world by storm. Facebook created the react framework to solve an age-old problem-how to deal efficiently with the view part of the traditional <span class="strong"><strong>Model-View-Controller</strong></span> applications.</p><p>React provides a declarative and flexible way to build user interfaces. The most important thing to remember about react is that it deals with only one thing-the view, or the UI. React does not deal with data, data bindings, or anything else. There are complete frameworks, such as Angular, that deal with data, bindings, and UI; React is not that.</p><p>React gives a template language and a small set of functions to render HTML. React components can store their own state in memory. To build a full-fledged application, you will need other pieces as well; React is just to handle the view part of that application.</p><p>A big challenge when writing complex UI is to manage state of the UI elements when the model changes. React provides a declarative API so that you don't have to worry about exactly what changes on every update. This makes writing applications a lot easier. React uses <span class="strong"><strong>Virtual DOM</strong></span> and <span class="strong"><strong>diffing</strong></span> algorithm, so that component updates are predictable while being fast enough for high-performance apps.</p></div>
<div class="section" title="Virtual DOM"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec93"/>Virtual DOM</h1></div></div></div><p>Let's take a moment to understand what is a Virtual DOM. We discussed <span class="strong"><strong>DOM</strong></span> (<span class="strong"><strong>document object model</strong></span>), a tree structure of HTML element on a web page. DOM is de facto, and the primary rendering mechanism of the web. The DOM APIs, such as <code class="literal">getElementById()</code>, allow traversing and modification of the elements in the DOM tree. DOM is a tree and this structure works pretty well with traversal and updating of elements. However, both the traversing and updating of DOM is not very quick. For a large page, the DOM tree can be pretty big. When you want a complex UI that has bunch of user interactions, updating DOM elements can be tedious and slow. We have tried jQuery and other libraries to reduce the tedious syntax for frequent DOM modifications, but DOM as a structure itself is quite limited.</p><p>What if we don't have to traverse the DOM over and over again to modify elements? What if you just declare how a component should look like and let someone handle the logic of how to render that component? react does exactly that. React lets you declare how you want your UI element to look like and abstracts out low-level DOM manipulation APIs. Apart from this very useful abstraction, react does something pretty smart to solve the performance problem as well.</p><p>React uses something called a Virtual DOM. A virtual DOM is a lightweight abstraction of the HTML DOM. You can think of it as a local in-memory copy of the HTML DOM. React uses it to do all computations necessary to render the state of a UI component.</p><p>You can find more details of this optimization at <a class="ulink" href="https://facebook.github.io/react/docs/reconciliation.html">https://facebook.github.io/react/docs/reconciliation.html</a>.</p><p>React's primary strength, however, is not just Virtual DOM. React is a fantastic abstraction that makes composition, unidirectional dataflow, and static modeling easier while developing large applications.</p></div>
<div class="section" title="Installing and running react"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec94"/>Installing and running react</h1></div></div></div><p>First, let's install react. Earlier, installing and getting react set up on your machine needed a bunch of dependencies to be taken care of. However, we will use a relatively faster way to get react up and running. We will use <code class="literal">create-react-app</code> to which we can install react without any build configuration. Installation is done via <code class="literal">npm</code> which is as follows:</p><pre class="programlisting">    npm install -g create-react-app &#13;
</pre><p>Here, we are installing the <code class="literal">create-react-app</code> node module globally. Once <code class="literal">create-react-app</code> is installed, you can set up the directory for your application. Consider the following commands:</p><pre class="programlisting">    create-react-app react-app &#13;
    cd react-app/ &#13;
    npm start &#13;
</pre><p>Then, open <code class="literal">http://localhost:3000/</code> to see your app. You should see something like the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_002.jpg" alt="Installing and running react"/></div><p>
</p><p>If you open the directory in an editor, you will see several files created for you, as you can see in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_003.jpg" alt="Installing and running react"/></div><p>
</p><p>In this project, <code class="literal">node_modules</code> are the dependencies required to run this project and dependencies of react itself. The important directory is <code class="literal">src</code>, where the source code is kept. For this example, let's keep only two files-<code class="literal">App.js</code> and <code class="literal">index.js</code>. The <code class="literal">/public/index.html</code> file should contain just the root <code class="literal">div</code>, which will be used as a target for our react components. Consider the following code snippet:</p><pre class="programlisting">    &lt;!doctype html&gt; &#13;
    &lt;html lang="en"&gt; &#13;
      &lt;head&gt; &#13;
        &lt;title&gt;React App&lt;/title&gt; &#13;
      &lt;/head&gt; &#13;
      &lt;body&gt; &#13;
<span class="strong"><strong>        &lt;div id="root"&gt;&lt;/div&gt;    </strong></span> &#13;
      &lt;/body&gt; &#13;
    &lt;/html&gt; &#13;
</pre><p>The moment you make this change, you will see the following error:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_004.jpg" alt="Installing and running react"/></div><p>
</p><p>Beauty of developing with react is that the code changes are live-reloaded, and you can get immediate feedback.</p><p>Next, clear off all content of <code class="literal">App.js</code>, and replace it with the following lines of code:</p><pre class="programlisting">    import React from 'react'; &#13;
    const App = () =&gt; &lt;h1&gt;Hello React&lt;/h1&gt; &#13;
    export default App &#13;
</pre><p>Now, go to <code class="literal">index.js</code> and remove the <code class="literal">import ./index.css;</code> line. Without you doing anything, such as restarting server and refreshing browser, you will see the modified page on the browser. Consider the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_005.jpg" alt="Installing and running react"/></div><p>
</p><p>Before we create a <code class="literal">HelloWorld</code> react component, a couple of important things to notice so far.</p><p>In <code class="literal">App.js</code> and <code class="literal">index.js</code>, we are importing two libraries necessary to create react components. Consider the following lines of code:</p><pre class="programlisting">    import React from 'react'; &#13;
    import ReactDOM from 'react-dom'; &#13;
</pre><p>Here, we're importing <code class="literal">React</code>, which is the library that allows us to build react components. We're also importing <code class="literal">ReactDOM</code>, which is the library that allows us to place our components and work with them in the context of the DOM. Then, we're importing the component that we just worked on-the App component.</p><p>We also created our first component in <code class="literal">App.js</code>. Consider the following line of code:</p><pre class="programlisting">    const App = () =&gt; &lt;h1&gt;Hello React&lt;/h1&gt; &#13;
</pre><p>This is a stateless function component. The other way to create a component is to create a class component. We can replace the preceding component with the following class component:</p><pre class="programlisting">    class App extends React.Component { &#13;
      render(){ &#13;
        return &lt;h1&gt;Hello World&lt;/h1&gt; &#13;
      } &#13;
    } &#13;
</pre><p>There are a bunch of interesting things going on here. First, we are creating a class component with the <code class="literal">class</code> keyword that extends from the superclass <code class="literal">React.Component</code>.</p><p>Our component <code class="literal">App</code> is a react component class or react component type. A component takes in parameters, also called <code class="literal">props</code>, and returns a hierarchy of views to display via the <code class="literal">render</code> function.</p><p>The <code class="literal">render</code> method returns a description of what you want to render, and then react takes that description and renders it to the screen. In particular, <code class="literal">render</code> returns a react element, which is a lightweight description of what to render. Most react developers use a special syntax called JSX, which makes it easier to write these structures. The <code class="literal">&lt;div /&gt;</code> syntax is transformed at build time to <code class="literal">React.createElement</code>(<code class="literal">'div'</code>). The JSX expression, <code class="literal">&lt;h1&gt;Hello World&lt;/h1&gt;</code>, is transformed at build time into the following:</p><pre class="programlisting">    return React.createElement('h1', null, 'Hello World'); &#13;
</pre><p>The difference between the class component and stateless function component is that the class component can contain a state while the stateless (hence the name) function component cannot.</p><p>The <code class="literal">render</code> method of the react component is allowed to return only a single node. If you do something like the following:</p><pre class="programlisting">    return &lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;React Rocks&lt;/p&gt; &#13;
</pre><p>You will get the following error:</p><pre class="programlisting">    Error in ./src/App.js &#13;
    Syntax error: Adjacent JSX elements must be wrapped in &#13;
      an enclosing tag (4:31) &#13;
</pre><p>This is because you are essentially returning two <code class="literal">React.createElement</code> functions, and that is not valid JavaScript. While this may seem like a deal breaker, this is easy to solve. We can wrap our nodes into a parent node and return that parent node from the <code class="literal">render</code> function. We can create a parent <code class="literal">div</code> and wrap other nodes under it. Consider the following example:</p><pre class="programlisting">    render(){ &#13;
        return ( &#13;
          &lt;div&gt; &#13;
            &lt;h1&gt;Hello World&lt;/h1&gt; &#13;
            &lt;p&gt;React Rocks&lt;/p&gt; &#13;
          &lt;/div&gt; &#13;
          ) &#13;
    } &#13;
</pre><div class="section" title="Components and props"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec168"/>Components and props</h2></div></div></div><p>Components can be conceptually considered as JavaScript functions. They take arbitrary number of inputs like normal functions. These inputs are called props. To illustrate this, let's consider the following function:</p><pre class="programlisting">    function Greet(props) { &#13;
      return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;; &#13;
    } &#13;
</pre><p>This is a normal function and also a valid react component. It takes an input called <code class="literal">props</code> and returns a valid JSX. We can use the <code class="literal">props</code> inside JSX using curly braces and properties such as <code class="literal">name</code> using a standard object notation. Now that <code class="literal">Greet</code> is a first class react component, let's use it in the <code class="literal">render()</code> function as follows:</p><pre class="programlisting">    render(){ &#13;
      return ( &#13;
       return &lt;Greet name="Joe"/&gt; &#13;
      ) &#13;
    } &#13;
</pre><p>We are calling <code class="literal">Greet()</code> as a normal component and passing <code class="literal">this.props</code> to it. It is required to capitalize your own components. React considers component names starting with a lowercase as standard HTML tags and expects custom component names to start with a capital letter. As we saw earlier, we can create a class component using ES6 class. This component is a subclass of <code class="literal">React.component</code>. An equivalent component to our <code class="literal">Greet</code> function is as follows:</p><pre class="programlisting">    class Greet extends React.Component { &#13;
      render(){ &#13;
          return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt; &#13;
      } &#13;
    } &#13;
</pre><p>For all practical purposes, we will use this method of creating components. We will soon know why.</p><p>One important point to note is that a component cannot modify its own props. This may seem like a limitation because, in almost all non-trivial applications, you will want user interactions where the UI component state is changed in react, for example, update date of birth in a form, <code class="literal">props</code> are read-only but there is a much robust mechanism to handle UI updates.</p></div><div class="section" title="State"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec169"/>State</h2></div></div></div><p>State is similar to props, but it is private and fully controlled by the component. As we saw earlier that both functional and class components are equivalent in react, one important distinction is that the state is available only in class components. Hence, for all practical purposes, we will use class components.</p><p>We can change our existing greeting example to use state, and whenever the state changes, we will update our <code class="literal">Greet</code> component to reflect the changed value.</p><p>First, we will set up the state inside our <code class="literal">App.js</code>, as follows:</p><pre class="programlisting">    class Greet extends React.Component { &#13;
<span class="strong"><strong>        constructor(props) {</strong></span>
<span class="strong"><strong>    super(props);&#13;
</strong></span>
<span class="strong"><strong>        this.state = { </strong></span>
<span class="strong"><strong>greeting: "this is default greeting text" </strong></span>
<span class="strong"><strong>}&#13;
</strong></span>
<span class="strong"><strong>        }</strong></span> &#13;
      render(){ &#13;
          return &lt;h1&gt;{this.state.greeting}, {this.props.name} &lt;/h1&gt; &#13;
      } &#13;
    } &#13;
</pre><p>There are a few important things to notice in this example. First, we are calling class <code class="literal">constructor</code> to initialize <code class="literal">this.state</code>. We also call the base class constructor, <code class="literal">super()</code>, and pass <code class="literal">props</code> to it. After calling <code class="literal">super()</code>, we initialize our default state by setting <code class="literal">this.state</code> to an object. For example, we assign a <code class="literal">greeting</code> property with a value here. In the <code class="literal">render</code> method, we will use this property using <code class="literal">{this.state.greeting}</code>. Having setup our initial state, we can add UI elements to update this state. Let's add an input box, and on change of that input box, we will update our state and the <code class="literal">greeting</code> element. Consider the following lines of code:</p><pre class="programlisting">    class Greet extends React.Component { &#13;
      constructor(props) { &#13;
        super(props); &#13;
        this.state = { &#13;
          greeting: "this is default greeting text" &#13;
        } &#13;
      } &#13;
<span class="strong"><strong>    updateGreeting(event){ </strong></span>
<span class="strong"><strong>this.setState({ </strong></span>
<span class="strong"><strong>greeting:&#13;
      event.target.value,</strong></span>
<span class="strong"><strong>    })</strong></span>
<span class="strong"><strong>  }</strong></span> &#13;
      render(){ &#13;
          return ( &#13;
          &lt;div&gt;   &#13;
<span class="strong"><strong>            &lt;input type="text" onChange={this.updateGreeting.bind(this)}/&gt;</strong></span> &#13;
            &lt;h1&gt;{this.state.greeting}, {this.props.name} &lt;/h1&gt; &#13;
           &lt;/div&gt;  &#13;
          ) &#13;
        } &#13;
    } &#13;
</pre><p>Here, we add an input box and update the state of the component when the <code class="literal">onChange</code> method of the input box is invoked. We use a custom <code class="literal">updateGreeting()</code> method to update the state by calling <code class="literal">this.setState</code> and updating the property. When you run this example, you will notice that as you type something on the text box, only the <code class="literal">greeting</code> element is updated and not the <code class="literal">name</code>. Take a look at the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_006.jpg" alt="State"/></div><p>
</p><p>An important feature of react is the fact that a react component can output or render other react components. We've got a very simple component here. It has a state with a value of text. It's got an <code class="literal">update</code> method which will update that value of text from an event. What we'll do is create a new component. This will be a stateless function component. We'll call it widget. It will take in <code class="literal">props</code>. We'll return this JSX input right here. Consider the following code snippet:</p><pre class="programlisting">    render(){ &#13;
        return ( &#13;
          &lt;div&gt;   &#13;
<span class="strong"><strong>          &lt;Widget update={this.updateGreeting.bind(this)} /&gt;&#13;
</strong></span>
<span class="strong"><strong>          &lt;Widget update={this.updateGreeting.bind(this)} /&gt;&#13;
</strong></span>
<span class="strong"><strong>          &lt;Widget update={this.updateGreeting.bind(this)} /&gt;</strong></span> &#13;
          &lt;h1&gt;{this.state.greeting}, {this.props.name} &lt;/h1&gt; &#13;
          &lt;/div&gt;  &#13;
        ) &#13;
      } &#13;
    } &#13;
    const Widget = (props) =&gt; &lt;input type="text" &#13;
      onChange={props.update}/&gt; &#13;
</pre><p>First, we extract our input element into a stateless function component and call it a <code class="literal">Widget</code>. We pass <code class="literal">props</code> to this component. Then, we change <code class="literal">onChange</code> to use <code class="literal">props.update</code>. Now, inside our <code class="literal">render</code> method, we use the <code class="literal">Widget</code> component and pass a prop <code class="literal">update</code> that binds the <code class="literal">updateGreeting()</code> method. Now that <code class="literal">Widget</code> is a component, we can reuse it anywhere in the <code class="literal">Greet</code> component. We are creating three instances of the <code class="literal">Widget</code>, and when any of the <code class="literal">Widget</code> is updated, the greeting text is updated, as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_007.jpg" alt="State"/></div><p>
</p></div><div class="section" title="Life cycle events"><div class="titlepage"><div><div><h2 class="title"><a id="ch13lvl2sec170"/>Life cycle events</h2></div></div></div><p>When you have a bunch of components with several state changes and events, the housekeeping becomes important. React provides you with several component life cycle hooks to handle life cycle events of components. Understanding the component life cycle will enable you to perform certain actions when a component is created or destroyed. Furthermore, it gives you the opportunity to decide if a component should be updated in the first place, and to react to <code class="literal">props</code> or state changes accordingly.</p><p>There are three phases that the component goes through-mounting, updating, and unmouting. For each of these stages, we have hooks. Take a look at the following diagram:</p><p>
</p><div class="mediaobject"><img src="graphics/image_13_008.jpg" alt="Life cycle events"/></div><p>
</p><p>Two methods are called when a component is initially rendered, <code class="literal">getDefaultProps</code> and <code class="literal">getInitialState</code>, and, as their names suggest, we can set default <code class="literal">props</code> and initial state of a component in these methods.</p><p>The <code class="literal">componentWillMount</code> is called before the <code class="literal">render</code> method is executed. We already know <code class="literal">render</code> to be the place where we return the component to be rendered. As soon as the <code class="literal">render</code> method finishes, the <code class="literal">componentDidMount</code> method is invoked. You can access DOM in this method, and it is recommended to perform any DOM interactions in this method.</p><p>State changes invoke a few methods. The <code class="literal">shouldComponentUpdate</code> method is invoked before the <code class="literal">render</code> method, and it lets us decide if we should allow rerendering or skip it. This method is never called on the initial rendering. The <code class="literal">componentWillUpdate</code> method gets called immediately once the <code class="literal">shouldComponentUpdate</code> method returns <code class="literal">true</code>. The <code class="literal">componentDidUpdate</code> method is rendered after <code class="literal">render</code> finishes.</p><p>Any change to the <code class="literal">props</code> object triggers similar methods as a state change. One additional method called is <code class="literal">componentWillReceiveProps</code>; it is called only when the <code class="literal">props</code> have changed, and it is not initial rendering. You can update state based on new and old props in this method.</p><p>When a component is removed from DOM, <code class="literal">componentWillUnmount</code> is called. This is a useful method to perform cleanups.</p><p>Great thing about react is that when you start using it, the framework feels very natural to you. There are very few moving parts you will need to learn, and the abstraction is just right.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch13lvl1sec95"/>Summary</h1></div></div></div><p>This chapter was aimed at some of the important new ideas that are gaining a lot of prominence lately. Both reactive programming and react can significantly boost programmer productivity. React is definitely one of the most important emerging technologies backed by the likes of Facebook and Netflix.</p><p>This chapter was intended to give you an introduction to both these technologies and help you start exploring them in more detail.</p></div></body></html>