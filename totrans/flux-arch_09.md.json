["```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { TOGGLE } from '../actions/toggle';\n\nclass Button extends EventEmitter {\n  constructor() {\n    super();\n\n    // The default state is to show the button\n    // as enabled and to process click events.\n    this.state = {\n      text: 'Enabled',\n      disabled: false\n    };\n\n    this.id = dispatcher.register((e) => {\n      let { state } = this;\n\n      switch(e.type) {\n\n        // When the \"TOGGLE\" action is dispatched,\n        // the next state of the button depends on\n        // the current state of the \"disabled\"\n        // property.\n        case TOGGLE:\n          state.text = state.disabled ?\n            'Enabled' : 'Disabled';\n          state.disabled = !state.disabled;\n\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n}\n\nexport default new Button();\n```", "```js\nimport React from 'react';\nimport button from '../stores/button';\nimport { toggle } from '../actions/toggle';\n\nfunction onClick() {\n\n  // Oh snap! This just totally broke Flux...\n  button.state.disabled = !button.state.disabled;\n\n  // Call the action creator as we should...\n  toggle();\n}\n\n// Renders your typical HTML button, complete\n// with properties and a callback handler for\n// click events.\nexport default ({ text, disabled }) => (\n  <button\n    onClick={onClick}\n    disabled={disabled}>{text}</button>\n);\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\n\n// The state of this store is encapsulated\n// within the module.\nvar state = {\n  first: 1,\n  second: 2,\n};\n\nclass Copy extends EventEmitter {\n  constructor() {\n    super();\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        case MY_ACTION:\n\n          // Mutates \"state\" with new properties...\n          Object.assign(state, e.payload);\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n\n  // Returns a new copy of \"state\", not a reference\n  // to the original.\n  get state() {\n    return Object.assign({}, state);\n  }\n}\n\nexport default new Copy();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\n\n// The state of this store is encapsulated\n// within this module. It's also stored as\n// a constant.\nconst state = {\n  first: 1,\n  second: 2,\n};\n\nclass Constant extends EventEmitter {\n  constructor() {\n    super();\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        case MY_ACTION:\n          // Mutates \"state\" with new properties...\n          Object.assign(state, e.payload);\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n\n  // Returns a reference to the \"state\" constant...\n  get state() {\n    return state;\n  }\n}\n\nexport default new Constant();\n```", "```js\nimport { EventEmitter } from 'events';\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\n\n// The store state is encapsulated within\n// this module...\nvar state;\n\n// Merges new values with current values, freezes\n// the new state, and assigns it to \"state\".\nfunction change(newState) {\n  let changedState = Object.assign({}, state, newState);\n  state = Object.freeze(changedState);\n}\n\n// Sets the initial state and freezes it...\nchange({\n  first: 1,\n  second: 2,\n});\n\nclass Frozen extends EventEmitter {\n  constructor() {\n    super();\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        case MY_ACTION:\n\n          // Calls \"change()\" to update the \"state\"\n          // value and re-freeze it.\n          change(e.payload);\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n\n  // Returns a reference to the frozen \"state\"...\n  get state() {\n    return state;\n  }\n}\n\nexport default new Frozen();\n```", "```js\nimport copy from './stores/copy';\nimport constant from './stores/constant';\nimport frozen from './stores/frozen';\n\nvar copyState = copy.state;\nvar constantState = constant.state;\nvar frozenState = frozen.state;\n\ncopyState.second++;\nconstantState.second++;\n\ntry {\n  frozenState.second++;\n} catch (err) {\n  console.error(err);\n  // →\n  // TypeError: Cannot assign to read only property\n  // 'second' of object\n}\n\nconsole.assert(\n  copy.state.second !== copyState.second,\n  'copy.second mutated'\n);\n\nconsole.assert(\n  constant.state.second !== constantState.second,\n  'constant.second mutated'\n);\n// → Assertion failed: constant.second mutated\n```", "```js\ncopyState.third = 3;\nconstantState.third = 3;\n\ntry {\n  frozenState.third = 3;\n} catch (err) {\n  console.error(err);\n  // →\n  // TypeError: Can't add property third, object is\n  // not extensible\n}\n```", "```js\ncopy.on('change', (state) => {\n  console.assert(state !== copyState, 'copy same');\n  console.assert(state.fourth, 'copy missing fourth');\n});\n\nconstant.on('change', (state) => {\n  console.assert(state !== constantState, 'constant same');\n  // → Assertion failed: constant same\n\n  console.assert(state.fourth, 'constant missing fourth');\n});\n\nfrozen.on('change', (state) => {\n  console.assert(state !== frozenState, 'frozen same');\n  console.assert(state.fourth, 'frozen missing fourth');\n});\n\nmyAction({ fourth: 4 });\n```", "```js\nimport { EventEmitter } from 'events';\nimport Immutable from 'Immutable';\n\nimport dispatcher from '../dispatcher';\nimport { LIST_PUSH, LIST_CAPS } from '../actions/list';\n\n// The state of this store is an \"Immutable.List\"\n// instance...\nvar state = Immutable.List();\n\nclass List extends EventEmitter {\n  constructor() {\n    super();\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // When the \"LIST_PUSH\" action is dispatched,\n        // we create a new List instance by calling\n        // \"push()\". The new list is assigned to \"state\".\n        case LIST_PUSH:\n          this.emit('change',\n            (state = state.push(...e.payload)));\n          break;\n\n        // When the \"LIST_CAPS\" action is dispatched,\n        // we created a new List instance by calling\n        // \"map()\". The new list is assigned to \"state\".\n        case LIST_CAPS:\n          this.emit('change',\n            (state = state.map(x => x.toUpperCase())));\n          break;\n      }\n    });\n  }\n\n  get state() {\n    return state;\n  }\n}\n\nexport default new List();\n```", "```js\nimport { EventEmitter } from 'events';\nimport Immutable from 'Immutable';\n\nimport dispatcher from '../dispatcher';\nimport { MAP_MERGE, MAP_INCR } from '../actions/map';\n\n// The state of this store is an \"Immutable.Map\"\n// instance...\nvar state = Immutable.Map();\n\nclass MapStore extends EventEmitter {\n  constructor() {\n    super();\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // When the \"MAP_MERGE\" action is dispatched,\n        // we create a new Map instance by calling\n        // \"merge()\". The new map is assigned to \"state\".\n        case MAP_MERGE:\n          this.emit('change',\n            (state = state.merge(e.payload)));\n          break;\n\n        // When the \"MAP_INCR\" action is dispatched,\n        // we create a new Map instance by calling\n        // \"map()\". The new map is assigned to \"state\".\n        case MAP_INCR:\n          this.emit('change',\n            (state = state.map(x => x + 1)));\n      }\n    });\n  }\n\n  get state() {\n    return state;\n  }\n}\n\nexport default new MapStore();\n```", "```js\nimport list from './stores/list';\nimport map from './stores/map';\nimport { listPush, listCaps } from './actions/list';\nimport { mapMerge, mapIncr } from './actions/map';\n\n// Logs the items in the \"list\" store when\n// it's state changes.\nlist.on('change', (state) => {\n  for (let item of state) {\n    console.log('  list item', item);\n  }\n});\n\n// Logs the items in the \"map\" store when\n// it's state changes.\nmap.on('change', (state) => {\n  for (let [key, item] of state) {\n    console.log(`  ${key}`, item);\n  }\n});\n\nconsole.log('List push...');\nlistPush('First', 'Second', 'Third');\n// → List push...\n//     list item First\n//     list item Second\n//     list item Third\n\nconsole.log('List caps...');\nlistCaps();\n// → List caps...\n//     list item FIRST\n//     list item SECOND\n//     list item THIRD\n\nconsole.log('Map merge...');\nmapMerge({ first: 1, second: 2 });\n// → Map merge...\n//     first 1\n//     second 2\n\nconsole.log('Map increment...');\nmapIncr();\n// → Map increment...\n//     first 2\n//     second 3\n```", "```js\nimport { EventEmitter } from 'events';\nimport Immutable from 'Immutable';\n\nimport dispatcher from '../dispatcher';\nimport { SORT_NAMES } from '../actions/sort-names';\n\n// The state is an object with two immutable\n// list instances. The first is a list of user\n// maps. The second is a list of user names and\n// is empty by default.\nconst state = {\n  users: Immutable.List([\n    Immutable.Map({ id: 33, name: 'tHiRd' }),\n    Immutable.Map({ id: 22, name: 'sEcoNd' }),\n    Immutable.Map({ id: 11, name: 'firsT' })\n  ]),\n  names: Immutable.List()\n};\n\nclass Users extends EventEmitter {\n  constructor() {\n    super();\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // The \"SORT_NAMES\" action was dispatched...\n        case SORT_NAMES:\n\n          // Determines the \"sort\" multiplier that's passed\n          // to \"sortBy()\" to sort in ascending or\n          // descending direction.\n          let sort = e.payload === 'desc' ? -1 : 1;\n\n          // Assigns the sorted list to \"users\" after\n          // performing a series of transforms. The\n          // \"toSeq()\" and \"toList()\" calls aren't strictly\n          // necessary. Any calls in between them, however,\n          // don't result in new structures being created.\n          state.names = state.users\n            .sortBy(x => x.get('id') * sort)\n            .toSeq()\n            .map(x => x.get('name'))\n            .map(x => `${x[0].toUpperCase()}${x.slice(1)}`)\n            .map(x => `${x[0]}${x.slice(1).toLowerCase()}`)\n            .toList();\n\n          this.emit('change', state);\n          break;\n      }\n    });\n  }\n\n  get state() {\n    return state;\n  }\n}\n\nexport default new Users();\n```", "```js\nimport users from './stores/users';\nimport { sortNames } from './actions/sort-names';\n\n// Logs the user names...\nusers.on('change', ({names}) => {\n  for (let item of names) {\n    console.log('  name', item);\n  }\n});\n\nconsole.log('Ascending...');\nsortNames();\n// → Ascending...\n//     name First\n//     name Second\n//     name Third\n\nconsole.log('Descending...');\nsortNames(true);\n// → Descending...\n//     name Third\n//     name Second\n//     name First\n```", "```js\nimport { EventEmitter } from 'events';\nimport Immutable from 'Immutable';\n\nimport dispatcher from '../dispatcher';\nimport { MY_ACTION } from '../actions/my-action';\n\n// The store state is an Immutable.js Map instance.\nvar state = Immutable.Map({\n  text: 'off'\n});\n\nclass MyStore extends EventEmitter {\n  constructor() {\n    super();\n\n    this.id = dispatcher.register((e) => {\n      switch(e.type) {\n\n        // When \"MY_ACTION\" is dispatched, we set\n        // the \"text\" property of \"state\" as the\n        // \"payload\". If the value has change, \"state\"\n        // \"set()\" returns a new instance. If there's\n        // no change, it returns the same instance.\n        case MY_ACTION:\n          this.emit('change',\n            (state = state.set('text', e.payload)));\n          break;\n      }\n    });\n  }\n\n  get state() {\n    return state;\n  }\n}\n\nexport default new MyStore();\n```", "```js\nimport { default as React, Component } from 'react';\n\nexport default class MyView extendsComponent {\n\n  render() {\n\n    // Logs the fact that we're rendering because\n    // \"shouldComponentUpdate()\" will prevent it\n    // if the store state hasn't changed.\n    console.log('Rendering...');\n\n    let { state } = this.props;\n\n    return (\n      <p>{state.get('text')}</p>\n    );\n  }\n\n  // Since we're using an Immutable.js Map as\n  // the store state, we know that if the\n  // instances are equal, nothing has changed\n  // and there's no need to render.\n  shouldComponentUpdate(nextProps) {\n    return nextProps.state !== this.props.state;\n  }\n}\n```", "```js\nimport React from 'react';\nimport { render } from 'react-dom';\n\nimport myStore from './stores/my-store';\nimport MyView from './views/my-view';\nimport { myAction } from './actions/my-action';\n\n// The container DOM element for our React component.\nconst container = document.getElementById('app');\n\n// The payload that's sent to \"myAction()\"...\nvar payload = 'off';\n\n// Renders the React components using the\n// \"myStore\" state...\nfunction renderApp(state=myStore.state) {\n  render(\n    <MyView state={myStore.state} />,\n    container\n  );\n}\n\n// Re-render the app when the store changes...\nmyStore.on('change', renderApp);\n\n// Performs the initial rendering...\nrenderApp();\n\n// Dispatches \"MY_ACTION\" every 0.5 seconds. This\n// causes the store to change state and the app\n// to re-render.\nsetInterval(() => {\n  myAction(payload);\n}, 500);\n\n// After 5 seconds, change the payload that's\n// dispatched with \"MY_ACTION\" so that the store\n// state is actually different.\nsetTimeout(() => {\n  payload = 'on';\n}, 5000);\n```"]