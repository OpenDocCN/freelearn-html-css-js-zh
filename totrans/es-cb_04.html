<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Working with async/await and Functions</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Creating promises with an async function</li>
<li>Awaiting the result of an async function</li>
<li>Using async results in a Promise chain</li>
<li>Awaiting multiple results in a series</li>
<li>Awaiting multiple results concurrently</li>
<li>Using Promise.all to collect an array of async results</li>
<li>Handling errors when awaiting an async function</li>
<li>Handling errors thrown inside of Promise.all</li>
<li>Using finally to ensure an operation is performed</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we saw how Promises are a huge improvement over the callback pattern. But we also saw that there were still some rough edges around composition. Creating promises directly takes different shape functions that are placed later in the chain. Errors and successful results were provided in different ways depending on how the Promise was created. And there is still be a bit of inconvenient nesting.</p>
<p>The <kbd>async</kbd> and <kbd>await</kbd> operators were introduced with ES8. These build on top of the Promise to make working with and creating Promises more seamless. In this chapter, we'll see how <kbd>async</kbd> and <kbd>await</kbd> can be used to create and work with promises in a more elegant way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating promises with an async function</h1>
                </header>
            
            <article>
                
<p>The <kbd>async</kbd> functions are an easy way to create and work with promises. In this recipe, we'll see a basic form of this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>04-01-creating-Promise-with-async</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create a <kbd>main.js</kbd> with an <kbd>async</kbd> function named <kbd>someTask</kbd>:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
async function someTask () { 
   console.log('Performing some task'); 
} </pre>
<ol start="5">
<li>Create a <kbd>main</kbd> that calls <kbd>someTask</kbd> and logs messages before and after <kbd>someTask</kbd> is executed:</li>
</ol>
<pre style="padding-left: 90px">export function main () { 
  console.log('before task'); 
  someTask(); 
  console.log('after task created'); 
}  </pre>
<ol start="6">
<li>Chain a <kbd>then</kbd> call off of <kbd>someTask</kbd> and log a message in the callback function:</li>
</ol>
<pre style="padding-left: 90px">export function main () { 
  console.log('Before Promise created'); 
  someTask().then(function () { 
    console.log('After Task completed'); 
  }); 
  console.log('After Promise created');}  </pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser: <span class="URLPACKT"><kbd>http://localhost:8000/</kbd>.</span></li>
<li>You should see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/22b26618-1518-41a1-901a-f71d2a01e0c3.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>async</kbd> keyword instructs the run-time that this function returns a Promise, rather than a result directly. By looking at the log messages, you can clearly see the order of operations. The first message is logged before the <kbd>async</kbd> function call is made. Next, the message inside of the <kbd>async</kbd> function is logged. Then the message after the <kbd>async</kbd> function is called. And finally, the message inside of the <kbd>then</kbd> callback is logged. This order is the same order of execution that can be seen in code using the Promise API directly.</p>
<p>The preceding code is already an improvement over code that creates promises directly. In upcoming recipes, we'll see how to take advantage of <kbd>await</kbd> to retrieve results from these functions without the use of the Promise API. We'll also be looking at other situations where <kbd>async</kbd> functions provide an advantage over direct use of the Promise API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Awaiting the result of async functions</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we saw how to use <kbd>async</kbd> to create functions that resolve promises. However, we used the Promise API <kbd>then</kbd> callback to wait for the result. In many situations, we can use the <kbd>await</kbd> key word to wait for these values. It gets the job done, but there is a cleaner way to retrieve results from asynchronous functions.</p>
<p>This recipe demonstrates how to use <kbd>await</kbd> in order to return the result of a long-running operation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>4-02-await-async-results</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create a <kbd>main.js</kbd> with an <kbd>async</kbd> function named <kbd>getRandomNumber</kbd> that returns a random number:</li>
</ol>
<pre style="padding-left: 90px">// main.js 
async function getRandomNumber () { 
   return Math.random(); 
} </pre>
<ol start="5">
<li>Create an <kbd>async</kbd> function, <kbd>main</kbd>, that calls <kbd>getRandomNumber</kbd>, waits for the result, and logs out the value:</li>
</ol>
<pre style="padding-left: 90px">export async function main () { 
  console.log('before task'); 
  const result = await getRandomNumber(); 
  console.log('Received the value: %s', result); 
  console.log('after task completed'); 
}  </pre>
<ol start="6">
<li>Start you Python web server and open the following link in your browser:<br/>
<span class="URLPACKT"><kbd>http://localhost:8000/</kbd>.</span></li>
<li>You should see the following output:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/316680de-d8e2-445a-bd82-cc268ebe4367.png" style="width:43.25em;height:27.00em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Using <kbd>await</kbd> within an <kbd>async</kbd> function is equivalent to using <kbd>then</kbd> in a Promise chain. The difference is that instead of the result being passed as an argument to the callback function, it is resolved as an expression. This expression can be assigned to the constant <kbd>result</kbd>. The value is then available for the rest of the block, and not limited to the body of a callback function.</p>
<p>This is pretty cool! Previously getting results from asynchronous code required the use of callbacks and methods in the Promise API. Now, with the <kbd>async</kbd> and <kbd>await</kbd> keywords, we can write code without nesting, making it easier to read and understand, while maintaining compatibility with the Promise API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using async results in a Promise chain</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we saw how to use <kbd>async</kbd> and <kbd>await</kbd> to replace portions of the Promise API. However, there will still be cases where it is preferable to use the Promise API, either for clarity, structure, or incremental replacement.</p>
<p>In this recipe, we'll see how the <kbd>async</kbd> functions integrate seamlessly into Promise chains.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>04-03-async-function-Promise-chain</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
</ol>
<ol start="4">
<li>Create an <kbd>async</kbd> function, <kbd>getRandomNumber</kbd>, that returns a random number:</li>
</ol>
<pre style="padding-left: 90px">async function getRandomNumber() { 
  console.log('Getting random number.'); 
  return Math.random(); 
} </pre>
<ol start="5">
<li>Create an <kbd>async</kbd> function, <kbd>determinReadyToLaunch</kbd>, that returns <kbd>true</kbd> if its first argument is greater than <kbd>0.5</kbd>:</li>
</ol>
<pre style="padding-left: 90px">async function deteremineReadyToLaunch(percentage) { 
  console.log('Determining Ready to launch.'); 
  return Math.random() &gt; 0.5; 
}  </pre>
<ol start="6">
<li>Create a third <kbd>async</kbd> function, <kbd>reportResults</kbd>, that logs out different results if its first argument is <kbd>true</kbd> or <kbd>false</kbd>:</li>
</ol>
<pre style="padding-left: 90px">async function reportResults(isReadyToLaunch) { 
  if (isReadyToLaunch) { 
    console.log('Rocket ready to launch. Initiate countdown: <img src="assets/dfbb335c-7153-4edc-994e-b0f24f5a884f.png" style="width:1.17em;height:1.17em;"/>'); 
  } else { 
    console.error('Rocket not ready. Abort mission: <img src="assets/9f66e62d-5abe-4b2d-bdd8-2c507d2e1199.png" style="width:1.08em;height:1.08em;"/>'); 
  } 
}  </pre>
<ol start="7">
<li>Create a <kbd>main</kbd> function that calls <kbd>getRandomNumber</kbd>, and a chain of the Promise it creates to call <kbd>determineReadyToLaunch</kbd> and <kbd>reportResults</kbd> in succession:</li>
</ol>
<pre style="padding-left: 90px">export function main() { 
  console.log('Before Promise created'); 
  getRandomNumber() 
    .then(deteremineReadyToLaunch) 
    .then(reportResults) 
  console.log('After Promise created'); 
}   </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser: <kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="9">
<li>You should see the following output:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/1f0928d4-cf2d-4296-9348-e8766f941f55.png" style="color: black;font-size: 1em;width:51.92em;height:32.50em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As mentioned previously, <kbd>async</kbd> functions resolve their results with a Promise, rather than directly returning a value. This means that whether an <kbd>async</kbd> function is used to start or continue a Promise chain, the shape can be the same.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>In fact, because the results are always resolved with a Promise, <kbd>async</kbd> functions can be resolved as a group using <kbd>Promise.all</kbd>. You can see an example of <kbd>async</kbd> functions with their results joined with a <kbd>Promise.all</kbd>:</p>
<pre>async function checkEngines(threshold = 0.9) { 
  return Math.random() &lt; threshold; 
} 
 
async function checkFlightPlan(threshold = 0.9) { 
  return Math.random() &lt; threshold; 
} 
 
async function checkNavigationSystem(threshold = 0.9) { 
  return Math.random() &lt; threshold; 
} 
 
Promise.all([ 
    checkEngines(), 
    checkFlightPlan(0.5), 
    checkNavigationSystem(0.75) 
]).then(function([enginesOk, flighPlanOk, navigationOk]) { 
  if (enginesOk) { 
    console.log('engines ready to go'); 
  } else { 
    console.error('engines not ready'); 
  } 
 
  if (flighPlanOk) { 
    console.log('flight plan good to go'); 
  } else { 
    console.error('error found in flight plan'); 
  } 
 
  if (navigationOk) { 
    console.log('navigation systems good to go'); 
  } else { 
    console.error('error found in navigation systems'); 
  } 
}) </pre>
<p>The preceding code works as expected. The functions can even be called directly with an argument, without needing to wrap them in a call to <kbd>Promise.resolve</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Awaiting multiple results in a series</h1>
                </header>
            
            <article>
                
<p>Sometimes it's necessary to arrange asynchronous operations in a series. In previous recipes, we've seen how to do this with <kbd>Promise.then</kbd>. In this recipe, we'll see how to do the same thing with the <kbd>await</kbd> operator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>04-03-async-function-Promise-chain</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create an <kbd>async</kbd> function, <kbd>getRandomNumber</kbd>, that returns a random number:</li>
</ol>
<pre style="padding-left: 90px">async function getRandomNumber() { 
  console.log('Getting random number.'); 
  return Math.random(); 
} </pre>
<ol start="5">
<li>Create an <kbd>async</kbd> function, <kbd>determineReadyToLaunch</kbd>, that returns <kbd>true</kbd> if its first argument is greater than <kbd>0.5</kbd>:</li>
</ol>
<pre style="padding-left: 90px">async function deteremineReadyToLaunch(percentage) { 
  console.log('Determining Ready to launch.'); 
  return Math.random() &gt; 0.5; 
} </pre>
<ol start="6">
<li>Create a third <kbd>async</kbd> function, <kbd>reportResults</kbd>, that logs out different results if it's first argument is <kbd>true</kbd> or <kbd>false</kbd>:</li>
</ol>
<pre style="padding-left: 90px">async function reportResults(isReadyToLaunch) { 
  if (isReadyToLaunch) { 
    console.log('Rocket ready to launch. Initiate countdown: <img src="assets/df8946fa-43b1-485f-a193-4b133aa3f94c.png" style="width:1.42em;height:1.42em;"/>'); 
  } else { 
    console.error('Rocket not ready. Abort mission: <img src="assets/c783817f-8a9f-4b57-9101-7fee9d8ca64b.png" style="width:1.17em;height:1.17em;"/>'); 
  } 
}  </pre>
<ol start="7">
<li>Create a <kbd>main</kbd> function that calls <kbd>getRandomNumber</kbd>, awaits the result, passes it on to <kbd>determineReadyToLaunch</kbd>, and calls <kbd>reportResults</kbd> after awaiting ready to launch:</li>
</ol>
<pre style="padding-left: 90px">export async function main() { 
  const randomNumber = await getRandomNumber();
  const ready = await deteremineReadyToLaunch(randomNumber);
  await reportResults(ready); 
}  </pre>
<ol start="8">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b4a7e7dc-eb69-46b8-953a-31dee014ba29.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Because our <kbd>main</kbd> function is marked as <kbd>async</kbd>, we are able to use the <kbd>await</kbd> operator in its body. This operator causes the function to wait for the result of the expression to be resolved. In our case, this means the Promise created by the <kbd>async</kbd> function we called is fulfilled.</p>
<p>Once the result is fulfilled, the control flow continues to the next statement. If we did not use the <kbd>await</kbd> operator, the value of <kbd>randomNumber</kbd> would be a promise that would resolve to the returned value. We could handle this with the promise interface, but because we used <kbd>await</kbd> , we are able to write something that looks more like synchronous code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li><em>Awaiting multiple results concurrently</em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Awaiting multiple results concurrently</h1>
                </header>
            
            <article>
                
<p>Sometimes it's possible to initiate multiple asynchronous operations at the same time. This can be desirable, for example, if multiple network requests are necessary in order to fetch all the data for a given page. Waiting for each request to finish before starting the next one wastes time.</p>
<p>In this recipe, we'll see how to use <kbd>await</kbd> to initiate and wait for multiple results concurrently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>04-05-await-concurrently</kbd>.</li>
<li>Create three functions, <kbd>checkEngines</kbd>, <kbd>checkFlightPlan</kbd>, and<kbd>checkNavigationSystem</kbd> that log a message when they start and return a <kbd>Promise</kbd> that resolves to <kbd>true</kbd> if a random number is higher than a threshold after some timeout:</li>
</ol>
<pre style="padding-left: 90px">function checkEngines() { 
  console.log('checking engine'); 
 
  return new Promise(function (resolve) { 
    setTimeout(function() { 
      console.log('engine check completed'); 
      resolve(Math.random() &lt; 0.9) 
    }, 250) 
  }); 
} 
 
function checkFlightPlan() { 
  console.log('checking flight plan'); 
 
  return new Promise(function (resolve) { 
    setTimeout(function() { 
      console.log('flight plan check completed'); 
      resolve(Math.random() &lt; 0.9) 
    }, 350) 
  }); 
} 
 
function checkNavigationSystem() { 
  console.log('checking navigation system'); 
 
  return new Promise(function (resolve) { 
    setTimeout(function() { 
      console.log('navigation system check completed'); 
      resolve(Math.random() &lt; 0.9) 
    }, 450) 
  }); 
}  </pre>
<ol start="4">
<li>Create an <kbd>async</kbd> as the <kbd>main</kbd> function that calls each of the functions created in the previous step. Assign the returned value from each to a local variable. Then await the result of the Promise, and log out the results:</li>
</ol>
<pre style="padding-left: 90px">  export async function main() { 
  const enginePromise = checkEngines(); 
  const flighPlanPromise = checkFlightPlan(0.5); 
  const navSystemPromise = checkNavigationSystem(0.75); 
   
  const enginesOk = await enginePromise; 
  const flighPlanOk = await flighPlanPromise; 
  const navigationOk = await navSystemPromise; 
 
  if (enginesOk &amp;&amp; flighPlanOk &amp;&amp; navigationOk) { 
    console.log('All systems go, ready to launch: <img src="assets/1fa0f789-994e-4743-b297-fc0fa84e4ad3.png" style="width:1.08em;height:1.08em;"/>'); 
  } else { 
    console.error('Abort the launch: <img src="assets/ee18cd64-82fd-4ac7-a542-60ec1451c50d.png" style="width:1.17em;height:1.17em;"/>'); 
     
    if (!enginesOk) { 
      console.error('engines not ready'); 
    } 
     
    if (flighPlanOk) { 
      console.error('error found in flight plan'); 
    } 
 
    if (navigationOk) { 
      console.error('error found in navigation systems'); 
    } 
  } 
} </pre>
<ol start="5">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/313c004a-ba9a-47f8-bac6-3dfe596750b3.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>You'll see in the output that the <kbd>checking</kbd> messages are logged immediately. Because all of the functions are called before the first <kbd>await</kbd> usage, the operations are initiated right await. This allows all the timeouts to start before any have completed.</p>
<p>Once <kbd>await</kbd> is used, the <kbd>main</kbd> function will block until the result is resolved. The code synchronizes again. The results of each function are resolved in sequence, but the long-running portions of the code (<kbd>setTimeout</kbd>) are concurrent.</p>
<p>The three check functions had to return Promises manually, because we are using <kbd>setTimeout</kbd>. Because this function uses a callback, we can't use <kbd>async</kbd>/<kbd>await</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Promise.all to collect an array of async results</h1>
                </header>
            
            <article>
                
<p>In the previous recipe, we saw how to trigger multiple asynchronous functions before awaiting their results. We've also seen how well the Promise API and <kbd>asyc</kbd>/<kbd>await</kbd> operators work together. There are some situations where it is preferable to use the Promise API.</p>
<p>In this recipe, we'll see how to use <kbd>Promise.all</kbd> to collect the result of multiple asynchronous operations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>04-06-Promise-all-collect-concurrently</kbd>.</li>
<li>Create three functions, <kbd>checkEngines</kbd>, <kbd>checkFlightPlan</kbd>, and <kbd>checkNavigationSystem</kbd> that log a message when they start and return a <kbd>Promise</kbd> that resolves to <kbd>true</kbd> if a random number is higher than a threshold after some timeout:</li>
</ol>
<pre style="padding-left: 90px">function checkEngines() { 
  console.log('checking engine'); 
 
  return new Promise(function (resolve) { 
    setTimeout(function() { 
      console.log('engine check completed'); 
      resolve(Math.random() &lt; 0.9) 
    }, 250) 
  }); 
} 
 
function checkFlightPlan() { 
  console.log('checking flight plan'); 
 
  return new Promise(function (resolve) { 
    setTimeout(function() { 
      console.log('flight plan check completed'); 
      resolve(Math.random() &lt; 0.9) 
    }, 350) 
  }); 
} 
 
function checkNavigationSystem() { 
  console.log('checking navigation system'); 
 
  return new Promise(function (resolve) { 
    setTimeout(function() { 
      console.log('navigation system check completed'); 
      resolve(Math.random() &lt; 0.9) 
    }, 450) 
  }); 
}  </pre>
<ol start="4">
<li>Create an <kbd>async</kbd> as the <kbd>main</kbd> function that calls each of the functions created in the previous step. Collect the results with <kbd>Promise.all</kbd>, reduce the results into a single ok to launch value, and log the result:</li>
</ol>
<pre style="padding-left: 90px">export async function main() { 
  const prelaunchChecks = [ 
    checkEngines(), 
    checkFlightPlan(0.5), 
    checkNavigationSystem(0.75) 
  ]; 
 
  const checkResults = await Promise.all(prelaunchChecks); 
  const readyToLaunch = checkResults.reduce((acc, curr) =&gt; acc &amp;&amp; <br/>  curr); 
 
  if (readyToLaunch) { 
    console.log('All systems go, ready to launch: <img src="assets/8948381e-dbeb-48e5-b00e-c8183100d1db.png" style="width:1.25em;height:1.25em;"/>'); 
  } else { 
    console.error('Something went wrong, abort the launch: <img src="assets/420be2cd-22c6-4e1e-94e6-02e6143b8931.png" style="width:1.08em;height:1.08em;"/>'); 
  } 
} </pre>
<ol start="5">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/42bd12c8-bdfb-48ea-90b8-cec76ebf4224.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p><kbd>Promise.all</kbd> returns a Promise that resolves to an array of values resolved from multiple values. In our case, those are the asynchronous functions we created in <em>Step 3</em>. Once that Promise is created, we can await the result.</p>
<p>Once we have this result, we can use the <kbd>Array.prototype.reduce</kbd> method in order to create a single Boolean value that can be used in a conditional.</p>
<p>If we compare this recipe to the prior recipe, we can see an advantage. Adding another pre-launch check is as simple as adding another asynchronous function to the array of functions. In fact, we don't need to know ahead of time how may pre-launch checks have to be performed. If they all resolve to a Boolean value, they will work with <kbd>Promise.all</kbd>. We lose information about which step failed, but we'll see in future recipes how to regain this information with error handling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>It's possible to refactor the <kbd>main</kbd> function so that the pre-check functions are executed implicitly. We can use the <kbd>Array.prototype.map</kbd> function to do this:</p>
<pre> export async function main() { 
  const prelaunchChecks = [ 
    checkEngines, 
    checkFlightPlan, 
    checkNavigationSystem 
  ]; 
<strong>  const checkResults = await Promise.all(prelaunchChecks.map((check) =&gt; <br/>  check());</strong> 
  const readyToLaunch = checkResults.reduce((acc, curr) =&gt; acc &amp;&amp; <br/>  curr); 
 
  if (readyToLaunch) { 
    console.log('All systems go, ready to launch: <img src="assets/6dd39ddc-344f-4062-ab97-09ba1a028f37.png" style="width:1.33em;height:1.33em;"/>'); 
  } else { 
    console.error('Something went wrong, abort the launch: <img src="assets/f61fc35f-c444-4c5e-a334-c905f205eb5f.png" style="width:1.33em;height:1.33em;"/>'); 
  } 
 </pre>
<p>The highlighted section shows that the asynchronous functions are called within a map.</p>
<p> </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<ul>
<li>Using <kbd>Array.reduce</kbd> to transform data</li>
<li><em>Handling errors thrown inside of <kbd>Promise.all</kbd></em></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling errors when awaiting an async function</h1>
                </header>
            
            <article>
                
<p>So far in this chapter, we've seen how to work with <kbd>async</kbd> functions that fulfill successfully. But, as we know, this is not always the case. We need to be able to handle errors that are thrown by asynchronous functions, or any functions they call.</p>
<p>In this recipe, we'll see how <kbd>try-catch</kbd> blocks can handle errors that are thrown by <kbd>async</kbd> functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>4-07- async-errors-try-catch</kbd>.</li>
<li>Copy or create an <kbd>index.html</kbd> that loads and runs a <kbd>main</kbd> function from <kbd>main.js</kbd>.</li>
<li>Create an <kbd>async</kbd> function, <kbd>addBoosters</kbd>, that throws some error:</li>
</ol>
<pre style="padding-left: 90px">async function addBoosters() { 
  throw new Error('Unable to add Boosters'); 
} </pre>
<ol start="5">
<li>Create an <kbd>async</kbd> function, <kbd>performGuidanceDiagnostic</kbd>, that also throws an error:</li>
</ol>
<pre style="padding-left: 90px">async function performGuidanceDiagnostic (rocket) { 
  throw new Error('Unable to finish guidance diagnostic')); 
} </pre>
<ol start="6">
<li>Create an <kbd>async</kbd> as the <kbd>main</kbd> function that calls <kbd>addBosters</kbd> and <kbd>performGuidanceDiagnostic</kbd> <span>and handles the error:</span></li>
</ol>
<pre style="padding-left: 90px"> export async function main() { 
    console.log('Before Check'); 
 
  try { 
    await addBosters(); 
    await performGuidanceDiagnostic(); 
  } catch (e) { 
    console.error(e); 
  } 
} 
 
  console.log('After Check'); </pre>
<ol start="7">
<li>Start your Python web server and open the following link in your browser: <kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="8">
<li>You should see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/08491a5b-c85b-41c0-b6ea-540737741ec8.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>When we <kbd>await</kbd> a result from an asynchronous function that fulfills with an error state, an error is thrown. To continue with the program, we need to catch this error. In the preceding recipe, the first asynchronous function throws so the second operation isn't performed, then we log the error to the console before exiting the <kbd>try-catch</kbd> block.</p>
<p>This compares favorably with Promise chain error handling, which uses the same <kbd>try-catch</kbd> mechanism for error handling as synchronous code. We don't need to wrap synchronous code with promises so that they can work with <kbd>Promise.catch</kbd>; we can use the language level <kbd>try-catch</kbd> blocks.</p>
<p>In the next recipe, we'll see how <kbd>try-catch</kbd> works with multiple asynchronous operations operating concurrently.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling errors thrown inside of Promise.all</h1>
                </header>
            
            <article>
                
<p>In a prior recipe, we saw how to use <kbd>Promise.all</kbd> to collect the results of multiple asynchronous functions. In an error state, <kbd>Promise.all</kbd> is even more interesting. Often, when dealing with multiple possible error conditions, we have to write a log of Boolean logic if we want to display multiple error messages. But, in this recipe, we'll see how we can use <kbd>Promise.all</kbd> and <kbd>try-catch</kbd> blocks to handle multiple error conditions concurrently, without complicated Boolean logic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes  you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>04-06-Promise-all-collect-concurrently</kbd>.</li>
<li>Create three <kbd>async</kbd> functions, <kbd>checkEngines</kbd>, <kbd>checkFlightPlan</kbd>, and <kbd>checkNavigationSystem</kbd> that log a message when they start and return a <kbd>Promise</kbd> that rejects an error if a random number is higher than a threshold or resolve, after some timeout:</li>
</ol>
<pre style="padding-left: 90px">function checkEngines() { 
  console.log('checking engine'); 
 
  return new Promise(function (resolve, reject) { 
    setTimeout(function () { 
      if (Math.random() &gt; 0.5) { 
        reject(new Error('Engine check failed')); 
      } else { 
        console.log('Engine check completed'); 
        resolve(); 
      } 
    }, 250) 
  }); 
} 
 
 
function checkFlightPlan() { 
  console.log('checking flight plan'); 
 
  return new Promise(function (resolve, reject) { 
    setTimeout(function () { 
      if (Math.random() &gt; 0.5) { 
        reject(new Error('Flight plan check failed')); 
      } else { 
        console.log('Flight plan check completed'); 
        resolve(); 
      } 
    }, 350) 
  }); 
} 
 
<br/>function checkNavigationSystem() { 
  console.log('checking navigation system'); 
 
  return new Promise(function (resolve, reject) { 
    setTimeout(function () { 
      if (Math.random() &gt; 0.5) { 
        reject(new Error('Navigation system check failed')); 
      } else { 
        console.log('Navigation system check completed'); 
        resolve(); 
      } 
    }, 450) 
  }); 
} 
 </pre>
<ol start="4">
<li>Create an <kbd>async</kbd> as the <kbd>main</kbd> function that calls each of the functions created in the previous step. Await the results, and catch and log any errors that are thrown. Log success if no error is thrown:</li>
</ol>
<pre style="padding-left: 90px"> export async function main() { 
  try { 
    const prelaunchChecks = [ 
      checkEngines, 
      checkFlightPlan, 
      checkNavigationSystem 
    ]; 
    await Promise.all(prelauchCheck.map((check) =&gt; check()); 
; 
    console.log('All systems go, ready to launch: <img src="assets/10628aed-f395-4282-8c34-275276ef562d.png" style="width:1.33em;height:1.33em;"/>'); 
  } catch (e) { 
    console.error('Aborting launch: <img src="assets/4810721b-ed8b-4d5d-8cf8-ee550bf9fe54.png" style="width:1.42em;height:1.42em;"/>'); 
    console.error(e); 
  } 
   }    </pre>
<ol start="5">
<li>Start your Python web server and open the following link in your browser: <kbd>http://localhost:8000/</kbd>.</li>
<li>You should see the following output:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/5ffc6a77-7e4c-4f9f-a268-f5b7af850a1b.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As we have seen before, <kbd>Promise.all</kbd> returns a Promise that resolves to an array of values resolved from multiple values, and we can <kbd>await</kbd> those values when they are fulfilled. When we <kbd>await</kbd> a Promise that is resolved in an error state, an exception is thrown.</p>
<p>What is interesting about the preceding code is that three asynchronous promises are executing concurrently. If one or more of them is fulfilled with an error, then one or more errors will be thrown.</p>
<p>You'll notice that only one error is ever caught and logged. As with synchronous code, we may potentially have multiple errors thrown by our code, but only one will be caught and logged by the <kbd>catch</kbd> block<span class="URLPACKT">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using finally to ensure an operation is performed</h1>
                </header>
            
            <article>
                
<p>Error handling can get fairly complicated. There may be cases where you want to allow an error to continue bubbling up the call stack to be handled at a higher level. In those cases, you may also need to perform some cleanup tasks. Often this can mean resetting some shared resource, but it could also simply be logging the current state of the application.</p>
<p>In this recipe, we'll see how to use <kbd>finally</kbd> to ensure that some code is executed, regardless of the error state.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>This recipe assumes you already have a workspace that allows you to create and run ES modules in your browser. If you don't, please see the first two chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open your command-line application and navigate to your workspace.</li>
<li>Create a new folder named <kbd>04-06-Promise-all-collect-concurrently</kbd>.</li>
<li>Create three <kbd>async</kbd> functions, <kbd>checkEngines</kbd>, <kbd>checkFlightPlan</kbd>, and <kbd>checkNavigationSystem</kbd> that log a message when they start and return a <kbd>Promise</kbd> that rejects an error if a random number is higher than a threshold, or resolve after some timeout:</li>
</ol>
<pre style="padding-left: 90px"> function checkEngines() { 
  console.log('checking engine'); 
 
  return new Promise(function (resolve, reject) { 
    setTimeout(function () { 
      if (Math.random() &gt; 0.5) { 
        reject(new Error('Engine check failed')); 
      } else { 
        console.log('Engine check completed'); 
        resolve(); 
      } 
    }, 250) 
  }); 
} 
 
 
function checkFlightPlan() { 
  console.log('checking flight plan'); 
 
  return new Promise(function (resolve, reject) { 
    setTimeout(function () { 
      if (Math.random() &gt; 0.5) { 
        reject(new Error('Flight plan check failed')); 
      } else { 
        console.log('Flight plan check completed'); 
        resolve(); 
      } 
    }, 350) 
  }); 
} 
 
 
function checkNavigationSystem() { 
  console.log('checking navigation system'); 
 
  return new Promise(function (resolve, reject) { 
    setTimeout(function () { 
      if (Math.random() &gt; 0.5) { 
        reject(new Error('Navigation system check failed')); 
      } else { 
        console.log('Navigation system check completed'); 
        resolve(); 
      } 
    }, 450) 
  }); 
}  </pre>
<ol start="4">
<li>Create an <kbd>asyncperformCheck</kbd> function that calls each of the functions created in the previous step. Await the results, and use <kbd>finally</kbd> to log a complete message:</li>
</ol>
<pre style="padding-left: 90px">async function performChecks() { 
  console.log('Starting Pre-Launch Checks'); 
  try { 
    const prelaunchChecks = [ 
      checkEngines, 
      checkFlightPlan, 
      checkNavigationSystem 
    ]; 
 
    return Promise.all(prelauchCheck.map((check) =&gt; check()); 
 
  } finally { 
    console.log('Completed Pre-Launch Checks'); 
  } 
   }  </pre>
<ol start="5">
<li>Create an <kbd>async</kbd> as the <kbd>main</kbd> function that calls the <kbd>performCheck</kbd> function. Await the results, use <kbd>try-catch</kbd> to handle any errors, and log out whether the launch can continue or not:</li>
</ol>
<pre style="padding-left: 90px">export async function main() { 
  try { 
    await performChecks(); 
    console.log('All systems go, ready to launch: <img src="assets/04a555f7-85e7-478d-91e3-ffd7a3aa51cd.png" style="width:1.08em;height:1.08em;"/>'); 
  } catch (e) { 
    console.error('Aborting launch: <img src="assets/8bd559d9-0670-4122-b3fe-e9e6e445d7b5.png" style="width:1.17em;height:1.17em;"/>'); 
    console.error(e); 
  } 
   }  </pre>
<ol start="6">
<li>Start your Python web server and open the following link in your browser:<br/>
<kbd>http://localhost:8000/</kbd>.</li>
</ol>
<ol start="7">
<li>You should see the following output:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f3881018-0282-402c-963c-93b9a73dcdb1.png" style="width:44.00em;height:28.92em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>As in the preceding recipe, the errors are caught by the <kbd>main</kbd> function, and the launch continue or abort message is displayed<span class="URLPACKT">. In this recipe, we've grouped the <kbd>check</kbd> function into a single asynchronous function, <kbd>performChecks</kbd>, that lets us know when they have all finished.</span></p>
<p><span class="URLPACKT">Because <kbd>performChecks</kbd> does not have a <kbd>catch</kbd> block on the awaited Promise result, the errors thrown lower in the call stack bubble up to the <kbd>main</kbd> function. However, the <kbd>finally</kbd> block ensures that there is a message to let us know that the <kbd>performChecks</kbd> has completed.</span></p>
<p><span class="URLPACKT">You can imagine that this organization could be expanded to include multiple layers, and other branches of operations. Handling errors is an important task in large programs, and <kbd>async</kbd>/<kbd>await</kbd> allows us to use the <kbd>try-catch</kbd> blocks to handle errors from asynchronous and synchronous code in the same way. </span></p>


            </article>

            
        </section>
    </body></html>