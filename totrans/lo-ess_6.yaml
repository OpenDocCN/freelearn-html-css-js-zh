- en: Chapter 6. Application Building Blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter addressed a key capability of Lo-Dash—wrapping values and
    executing chained function calls. One benefit of this style of coding is the ability
    to construct larger units of functionality that are generic and portable. We saw
    glimpses of both generality and portability when working with wrapper instances
    in the last chapter. The goal of this chapter is to implement these ideas. Writing
    an application is more than throwing together filters and maps that give you the
    data you need. Your code would grow messy in no time if you kept writing the same
    thing over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll learn how to write generic functions that internally
    utilize the Lo-Dash API. We'll also take chained function calls a step further
    by exploring the various ways they fit together, like puzzle pieces, and ultimately
    result in a robust foundation for your application. There comes a point when the
    functions you write for your application belong in the Lo-Dash infrastructure.
    That is, you need to mix your own generic code with the Lo-Dash API. We'll tackle
    that too.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic wrappers and chains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Composing functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating generic functions can make all the difference in the size and comprehensibility
    of our code. A generic function is useful in more than one context. It is loosely
    coupled to the application. That's what higher-level building blocks are all about;
    whether we're using a functional programming model, a more object-oriented approach,
    or a hybrid of the two, the key lies in generic components. As with most other
    aspects of programming, Lo-Dash provides many avenues to construct generic components.
    We'll address many of them throughout the course of this chapter. Let's start
    off by looking at functions that aren't so generic and how they compare with their
    more fluid cousins.
  prefs: []
  type: TYPE_NORMAL
- en: Specific functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whether a function is fit for one purpose or not, and whether it is fit for
    only one purpose, isn''t always clear-cut. Depending on your perspective, there
    are degrees of specificity. Consider the following functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each of these four functions yields the same result, yet their implementations
    have their own unique consequences in our application. We can evaluate two generic
    properties of each function. First, we look at the collection that's being transformed—the
    main operand. Also, there are the secondary arguments passed in that affect the
    outcome.
  prefs: []
  type: TYPE_NORMAL
- en: The `collectionNames()` function is fairly specific, in that it expects a `collection`
    variable in its scope and hardcodes the `name` argument that is passed to `map()`.
    The `indirectionNames()` function is the opposite—it's completely generic because
    it accepts collection and property arguments, but it's also completely pointless
    since it's just a proxy and we might as well call `map()` directly. The `genericCollNames()`
    function is interesting; the collection we're mapping with this function is generic
    since it is passed as an argument, while the `name` argument is hardcoded. Lastly,
    the `genericPropNames()` function uses a generic argument when hardcoding the
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to consider each extreme—from indirection to fully hardcoding—when
    defining your functions. Either of these extremes is hardly worthwhile and the
    middle ground is somewhere to aim for. As for what you hardcode and what you keep
    generic, each has trade-offs that are unique to what you're building. You'll often
    find yourself changing these around as your application evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Generic function arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript gives us some freedom in defining our functions. Not all arguments
    need to be statically declared ahead of time, as is the case in other languages.
    The `arguments` object is available to help us out, especially when we''re trying
    to keep something generic. For example, certain callers may not pass all arguments.
    That''s fine, our functions can cope and we can utilize this capability to define
    functions that are better equipped to generically interact with the Lo-Dash API,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `insert()` function accepts a `coll` and a `callback` argument. The collection
    is always required but the callback is optional. If no callback is provided, it
    defaults to the `identity()` function.
  prefs: []
  type: TYPE_NORMAL
- en: There's some additional trickery involved here as well, since any other arguments
    supplied to the function are the targets to be inserted into the collection. We
    use the `slice()` function to stick these in the `toInsert` variable and we slice
    them differently depending on whether or not a callback function was supplied.
    Then it's just a matter of iterating through each argument value to insert and
    passing our callback to `sortedIndex()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting the callback value to `identity()` isn't strictly necessary here. That's
    the default behavior of most Lo-Dash functions that take callbacks. Being explicit
    doesn't hurt either, especially if we don't want the same default function.
  prefs: []
  type: TYPE_NORMAL
- en: Using partials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A handy pattern to solve the generic argument issues that arise is to use partials,
    that is, partially apply function arguments using the `partial()` function. This
    lets us build functions at runtime that can be used repeatedly, without having
    to always apply the same arguments. Sometimes it''s not even feasible to provide
    function arguments. The following is an example of using partials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our `flattenProp()` function is a composition of `flatten()` and `prop()`. The
    result that is returned is a flattened array. So, if any of these property values
    were themselves arrays, they just get added to the single array.
  prefs: []
  type: TYPE_NORMAL
- en: There's no need to always supply the name of the property we need flattened,
    especially when the data model used in our application shares many properties
    between entities. This is the perfect case for the use of partial functions. Remember,
    partials aren't entirely static—they do return functions after all. Our code defines
    two partial functions with the `prop` argument preapplied. Later on, we can use
    this function with specific collections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating partial functions out of generic functions is a form of function composition
    and a critical tool in building high-level application components.
  prefs: []
  type: TYPE_NORMAL
- en: Generic callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s one thing to design a function that''s called manually in your code or
    in someone else''s code. However, callbacks are essential to Lo-Dash. So it''s
    always worthwhile to consider the fact that our functions are likely to be used
    as callbacks, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Our first callback defined in this code is `validItem()`, and this is an incredibly
    useful function because there are bound to be lots of scenarios where you might
    be interested only in valid items. This function takes a generic `item` argument
    and returns `true` if that argument meets a certain criteria. This is the ideal
    format for callbacks that are iteratively applied to collections. The second callback
    is `computed()`, and this too takes a generic `item` argument. This callback is
    useful in mapping scenarios since it returns an extended version of the item,
    with computed properties. There's a third callback here too—`invalidItem()`. This
    is the inverse of the `validItem()` function and we're able to create it using
    `negate()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that a lot of our callback functions use `item` as the
    first named argument. This is good practice as it gives the readers of your code
    a good indication that a given function is likely used as a callback somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Generic wrappers and chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With generic functions under our belts, it's time to turn our attention to Lo-Dash
    wrapper instances and create generic function call chains. Chains are useful when
    you're stuck and you need a quick way out of a tricky programming situation, but
    they're also useful in the generic sense. That is, you can compose chains of functionality
    that are general enough to apply in a variety of contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Generic filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by taking a look at generic filters and how they can be utilized
    in our functions. Filters are especially suitable for chained function calls since
    they can be stitched together by applying a filter after a preceding filter. There
    are often some kinds of sorting or other constraints that take place at the end
    of a filter, such as limiting the number of results returned, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our `byName()` function wraps the passed-in collection and applies a `filter()`
    and a `take()` operation. It also accepts a couple of arguments. The `name` argument
    is the name we're filtering the collection on. The `take` argument is optional,
    and if supplied, specifies the number of items to return. If the `take` argument
    is missing, we default to `100`.
  prefs: []
  type: TYPE_NORMAL
- en: There are three different invocations of `byName()` demonstrated in the preceding
    code. The first invocation is the most straightforward. We're simply passing the
    name, `Leslie`, since this is the name we want to filter the collection by. The
    next invocation performs a `filter()` operation on the collection, then passes
    its result to `byName()`. The last invocation gets the same result as the second.
    However, you'll notice that we've already wrapped the collection, and since the
    `filter()` function is **chainable**, the wrapper instance gets passed as the
    `coll` argument.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Rewrapping a Lo-Dash wrapper is safe. The constructor recognizes this and knows
    how to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: This function constructs a somewhat generic chain. We can pass in the collection
    at runtime along with the name value we would like to filter by. We can even pass
    the number of results we'd like to take, and the function doesn't care if it gets
    a wrapped value. This latter point is especially useful since it allows us to
    use other functions we've developed that perform chained function calls, return
    these chains, and use them. The limiting factor of `byName()` is that it calls
    `value()`, and returns the unwrapped collection.
  prefs: []
  type: TYPE_NORMAL
- en: Returning chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s almost always a good idea to have our functions that construct wrappers
    return those same wrapper instances. In the previous section, our function unwrapped
    the value after the call chain had completed and returned it. The problem with
    this approach is that the caller may have more operations to apply on the chain.
    To do this, the value would need to be wrapped again. Lo-Dash wrapper instances
    should have the freedom to move about your code and be passed around from function
    to function, as if it were a plain array, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `sort()` function is quite straightforward and doesn't seem to do all that
    much. On the face of it, it just takes in a collection, sorts it, and returns
    it. Yes, that's the goal at a high level. First, you'll notice that the `coll`
    argument is wrapped in the Lo-Dash constructor function—the argument value can
    be either a wrapper instance or an unwrapped value. The function also accepts
    a property name or a function callback to sort the collection by. The `desc` argument
    is optional and it reverses the sort order if `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between this function and the `byName()` function we implemented
    earlier is that `sort()` will always return a wrapper instance. This means that
    we don't have to rewrap the returned value, should the caller need to add more
    function calls to the chain. You can see this in action with the last invocation
    of `sort()` in the preceding code. Here we're adding a `takeRight()` and a `pluck()`
    call to the chain. Designing functions in this way gives us great flexibility
    in how we're able to use wrappers throughout our code. The general rule would
    be to let your functions be wrapper friendly, both in what they accept as arguments
    and in what they return.
  prefs: []
  type: TYPE_NORMAL
- en: The trade-off, it would appear, is that the caller needs to call not only your
    function, but also the `value()` function. Sometimes, this can be a pain if all
    you want is the actual value so that you can start working with it, but remember
    that the chain itself isn't executed until the `value()` function is called. This
    has implications for lazy evaluation, which simply means that the return values
    aren't computed until `value()` is called. So this could actually be a desired
    trait—the ability to build chains without executing them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should always document in one form or another that your function does indeed
    return a Lo-Dash wrapper and that the caller needs to call `value()`.
  prefs: []
  type: TYPE_NORMAL
- en: Composing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether our functions are called manually, used as a callback by another function,
    or used in some other context that involves chains, function composition helps
    construct larger pieces of functionality. For example, we may have two smaller
    functions that serve niche purposes on their own. When we're in scenarios where
    these functions may come in handy, we can use the functional tools in Lo-Dash
    to compose a new function that utilizes them, rather than roll out our own.
  prefs: []
  type: TYPE_NORMAL
- en: Composing generic functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in the chapter, we emphasized the idea that functions need to be generic
    if they''re to be of any service in more than one context. The same idea holds
    true when composing larger components of smaller functions. The smaller functions
    need to be generic if we''re going to use them to compose anything larger. Likewise,
    the composite should also be as generic as possible so that we can use it as an
    ingredient in a larger piece of the application. This is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This code has two generic utility functions. The `indexByName()` function takes
    a collection and returns an object where the keys are the `name` property for
    every item in the collection. The `enabledIndex()` function takes an object and
    converts each property value to a Boolean value, based on its `enabled` property.
    Perhaps, each of these functions is used on its own elsewhere in your application,
    but now, while developing a new component, we've come up with a use case that
    warrants using them together.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than having to call each function independently and feed the output of
    the first function to the second, we decide to compose an `enabled()` function.
    This way, we can use a simple invocation any time we need the object structure
    that maps the name to the `enabled` Boolean value. This is done by partially applying
    the collection argument to the function we're creating, using `flow()`. The `flow()`
    function passes the first argument to the first function, and the next, and so
    on, returning the result.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This code makes the assumption that the `name` property is unique for each object.
    Otherwise, it wouldn't be worth indexing like this.
  prefs: []
  type: TYPE_NORMAL
- en: Composing callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `enabled()` function we just composed in the preceding section was intended
    to be directly called by our code somewhere. Callbacks, on the other hand, are
    generally passed to a Lo-Dash function. Passing inline anonymous functions works
    fine, except when you find yourself writing the same callback functions over and
    over again, or at least, similar functions with little variance. There''s no reason
    that our application can''t compose generic callbacks and make them available
    throughout the application to encourage reuse over duplication. Let''s take a
    look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: A common problem faced by callback functions is that they have no control over
    how they're invoked. One function may invoke each of its callbacks using a single
    argument, while the next uses three arguments. This prevents us from doing certain
    things we'd otherwise like to, such as composing callbacks using Lo-Dash functions
    that are already built and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: The `minimal()` function defined in this code is used to pick only the essential
    object properties from the passed-in argument. Let's say we want to pass this
    callback to `map()`. Well, `map()` invokes its callbacks with three arguments,
    the first one being the actual item we're interested in. This means that it's
    nearly impossible for us to use Lo-Dash functions with partially applied arguments
    as callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The workaround we've employed with the `minimal()` callback is to use `flow()`
    to compose the callback. You'll notice that the first function is `identity()`.
    This does nothing more than returning whatever value is passed to it. So in other
    words, it returns the first argument. Next in the flow is our partial function
    that uses `pick()`. And guess what? It'll only get one argument passed to it,
    as we need, even if used in a `map()` callback, which is called with three arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Composing chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we''ll look at composing functions that work with chains. As we''ve seen
    throughout this chapter, it''s beneficial for you and anyone else who uses your
    functions to be flexible in what your functions accept as arguments, and what
    they return. For example, a function that accepts a wrapper and returns a wrapper
    means that it can be passed just about anything and that the caller is free to
    extend the call chain. Just as we can compose plain functions and callback functions,
    we can also compose functions whose main focus is working with chains. Take a
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `rejectOdd()` function here takes either a collection or a wrapper instance
    as the first argument and filters out the odd numbers. Notice that it returns
    a wrapper instead of the unwrapped value. We use this wrapper-friendly function
    to compose two new functions. The first is `sortedEvens()`, which uses our `sorted()`
    function to sort the collection. This returns a wrapper instance, which is then
    fed to the `rejectOdd()` function. The `evensSorted()` function does something
    similar but in a different order. It rejects the odd numbers before sorting them,
    and then it uses `partialRight()` to unwrap the value using `result()`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that when we call the `sortedEvens()` function, it returns a wrapper
    instance because we're extending the function call chain with `reverse()`, and
    then we get the value. However, we don't perform this extension with our composed
    `evensSorted()` function because it unwraps the value for us.
  prefs: []
  type: TYPE_NORMAL
- en: Method composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, it makes sense to attach functions to a specific object scope or
    implement methods. If the function requires instance-specific values in order
    to operate, then it''s probably a good idea to implement the function as a property
    of the prototype so that it is always available to instances. So we can use the
    techniques we''ve looked at so far in this chapter to assist us with building
    object methods, which are yet another building block in our application''s structure.
    Take a look at the following example of object methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our `User` constructor accepts three arguments, and all of these are set as
    instance values. We've also implemented a `valid()` method. We're utilizing a
    function call chain here to validate each of the instance attributes. Note that
    we've enabled explicit chaining here. This means the functions in the chain that
    would normally return unwrapped values, won't. We're doing this because we need
    to pass primitive values through the chain.
  prefs: []
  type: TYPE_NORMAL
- en: The `first` property is wrapped, and we validate that it is a string using the
    `isString()` function. Next, we use `thru()`. We're using our `validThru()` function
    here as a callback to `thru()`. Basically, if the value returned by `isString()`,
    the previous call, is `true`, then return the next value. In this case, it's partially
    applied as the `last` property. The same steps are performed with the `age` property.
  prefs: []
  type: TYPE_NORMAL
- en: What's nice about this approach is that the chain requires access to several
    properties and all enclosed within the method. We can then construct a readable
    chain that validates all of these properties and doesn't require several control
    flow statements, which can be more difficult to maintain than two lines in a chain.
  prefs: []
  type: TYPE_NORMAL
- en: Creating mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last major building block we'll visit in this chapter is the mixin. Lo-Dash
    has a `mixin()` function that lets us extend the API by providing our own functions.
    There are two reasons you'd want to do such a thing. The first is that by placing
    your generic toolset in the Lo-Dash object, you can have access to them wherever
    the `_` symbol is accessible. The second reason is that once you've mixed in your
    own function, it can be used as a piece in a function call chain.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an average() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s only so many utilities a library such as Lo-Dash can feasibly ship.
    The ones that are viewed as most applicable to common users are the ones we get
    out of the box. This doesn''t mean that the application you''re working on doesn''t
    have a high-value use case you wish Lo-Dash implemented. For example, assume your
    application computes averages all over the place. While the library doesn''t ship
    with an `average` function, that doesn''t mean we can''t add this function to
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The computation that takes place in our `average()` mixin is really straightforward—division
    of the items by the length of the collection. It's the mapping of these items
    we need to consider. If you look at the arguments accepted by the `average()`
    mixin, you'll notice that it takes a collection, which is always required, and
    a callback. The callback is optional and can be anything that's accepted as a
    `map()` callback. Our chain then reduces these items to a sum before they're divided
    by the collection size.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the `average()` function is now part of the Lo-Dash object
    and that we're able to pass a string argument or a function callback. You can
    also see that the function is chainable, as demonstrated in the last invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a distance() function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a more involved mixin function called `distance`. It''ll use
    the Levenshtein distance algorithm to measure the edit distance between two strings.
    We''ll create another mixin that uses `distance()`. This function will sort collections
    by the shortest distance from the target string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We won't fixate on the details of the Levenshtein distance algorithm; there
    are plenty of online resources available for that. The `distance()` mixin we just
    implemented accepts a `source` string and a `target` string with which to compare
    it. The return value represents the number of edits needed to make the target
    match the source. For example, the call to `distance()`in the preceding code yields
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The `closest()` mixin function uses `distance()` as a `sortBy()` callback. This
    is a useful function because it's often a collection of the target strings we're
    comparing the source string to. Further, since it's a mixin function, we're able
    to use it in a chain. The last call to `closest()` does this and then uses `first()`
    to grab the closest value.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned some useful approaches to building higher-level
    application components. Functions are the fundamental unit of Lo-Dash programming,
    so it's important that we properly utilize all that they have to offer. We addressed
    some common issues faced when thinking about how to design reusable functions.
    For example, the specificity of a function and the arguments it accepts can impact
    where and how the function can be used in your Lo-Dash code.
  prefs: []
  type: TYPE_NORMAL
- en: Generic wrappers and the chained function calls they implement are powerful
    tools, and there are many implementation options that come with them. We walked
    through several examples of how different aspects of chains work, and how these
    wrappers interact with the various functions in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition is an essential part of functional programming and we learned
    how to exploit the functional tools Lo-Dash provides to compose larger pieces
    of our application code. These include the generic functions we call manually,
    and callback functions. This chapter closed with a look at the mixin functions
    that are used to extend the Lo-Dash API. The next chapter will show you how to
    take these application-level Lo-Dash components, and make sure they play nicely
    alongside other libraries.
  prefs: []
  type: TYPE_NORMAL
