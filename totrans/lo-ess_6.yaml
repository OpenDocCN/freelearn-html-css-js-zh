- en: Chapter 6. Application Building Blocks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 应用构建块
- en: The previous chapter addressed a key capability of Lo-Dash—wrapping values and
    executing chained function calls. One benefit of this style of coding is the ability
    to construct larger units of functionality that are generic and portable. We saw
    glimpses of both generality and portability when working with wrapper instances
    in the last chapter. The goal of this chapter is to implement these ideas. Writing
    an application is more than throwing together filters and maps that give you the
    data you need. Your code would grow messy in no time if you kept writing the same
    thing over and over again.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章讨论了Lo-Dash的关键功能——包装值和执行链式函数调用。这种编程风格的一个好处是能够构建更大的功能单元，这些单元是通用和可移植的。我们在上一章处理包装实例时看到了通用性和可移植性的影子。本章的目标是实现这些想法。编写一个应用程序不仅仅是抛出过滤器和映射，以获得你需要的数据。如果你反复写相同的内容，你的代码很快就会变得混乱。
- en: In this chapter, we'll learn how to write generic functions that internally
    utilize the Lo-Dash API. We'll also take chained function calls a step further
    by exploring the various ways they fit together, like puzzle pieces, and ultimately
    result in a robust foundation for your application. There comes a point when the
    functions you write for your application belong in the Lo-Dash infrastructure.
    That is, you need to mix your own generic code with the Lo-Dash API. We'll tackle
    that too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何编写内部使用Lo-Dash API的通用函数。我们还将通过探索它们如何像拼图一样组合在一起，以及最终为你的应用程序提供一个坚实的基础，将链式函数调用进一步推进。当你为你的应用程序编写的函数属于Lo-Dash基础设施时，就到了这一点。也就是说，你需要将你自己的通用代码与Lo-Dash
    API混合。我们也将处理这一点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generic functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用函数
- en: Generic wrappers and chains
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用包装器和链
- en: Composing functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数组合
- en: Creating mixins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建混入
- en: Generic functions
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用函数
- en: Creating generic functions can make all the difference in the size and comprehensibility
    of our code. A generic function is useful in more than one context. It is loosely
    coupled to the application. That's what higher-level building blocks are all about;
    whether we're using a functional programming model, a more object-oriented approach,
    or a hybrid of the two, the key lies in generic components. As with most other
    aspects of programming, Lo-Dash provides many avenues to construct generic components.
    We'll address many of them throughout the course of this chapter. Let's start
    off by looking at functions that aren't so generic and how they compare with their
    more fluid cousins.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建通用函数可以在我们代码的大小和可理解性方面产生重大差异。通用函数在多个上下文中都很有用。它与应用程序松散耦合。这就是高级构建块的全部内容；无论我们是在使用函数式编程模型、更面向对象的方法，还是两者的混合，关键在于通用组件。与编程的许多其他方面一样，Lo-Dash提供了许多构建通用组件的途径。我们将在本章的整个过程中探讨其中许多途径。让我们从查看不那么通用的函数以及它们与更灵活的表亲如何比较开始。
- en: Specific functions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定函数
- en: 'Whether a function is fit for one purpose or not, and whether it is fit for
    only one purpose, isn''t always clear-cut. Depending on your perspective, there
    are degrees of specificity. Consider the following functions:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个函数是否适合单一目的，以及它是否只适合单一目的，并不总是那么明确。根据你的视角，存在不同程度的特定性。考虑以下函数：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Each of these four functions yields the same result, yet their implementations
    have their own unique consequences in our application. We can evaluate two generic
    properties of each function. First, we look at the collection that's being transformed—the
    main operand. Also, there are the secondary arguments passed in that affect the
    outcome.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个函数都产生相同的结果，但它们在我们的应用中的实现方式各有其独特的后果。我们可以评估每个函数的两个通用属性。首先，我们看看正在转换的集合——主要操作数。此外，还有传递的次要参数，它们会影响结果。
- en: The `collectionNames()` function is fairly specific, in that it expects a `collection`
    variable in its scope and hardcodes the `name` argument that is passed to `map()`.
    The `indirectionNames()` function is the opposite—it's completely generic because
    it accepts collection and property arguments, but it's also completely pointless
    since it's just a proxy and we might as well call `map()` directly. The `genericCollNames()`
    function is interesting; the collection we're mapping with this function is generic
    since it is passed as an argument, while the `name` argument is hardcoded. Lastly,
    the `genericPropNames()` function uses a generic argument when hardcoding the
    collection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectionNames()`函数相当具体，因为它期望在其作用域中有一个`collection`变量，并且将`name`参数硬编码为传递给`map()`的参数。`indirectionNames()`函数则相反——它是完全通用的，因为它接受集合和属性参数，但它也是完全无意义的，因为它只是一个代理，我们直接调用`map()`也行。`genericCollNames()`函数很有趣；我们用这个函数映射的集合是通用的，因为它作为参数传递，而`name`参数是硬编码的。最后，`genericPropNames()`函数在硬编码集合时使用了一个通用参数。'
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to consider each extreme—from indirection to fully hardcoding—when
    defining your functions. Either of these extremes is hardly worthwhile and the
    middle ground is somewhere to aim for. As for what you hardcode and what you keep
    generic, each has trade-offs that are unique to what you're building. You'll often
    find yourself changing these around as your application evolves.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，要记住考虑每个极端——从间接到完全硬编码——。这两种极端都几乎不值得追求，而中间地带则是我们应努力达到的目标。至于你硬编码什么，保持什么通用，每个都有独特的权衡，取决于你正在构建的内容。随着应用程序的发展，你经常会发现自己需要调整这些设置。
- en: Generic function arguments
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用函数参数
- en: 'JavaScript gives us some freedom in defining our functions. Not all arguments
    need to be statically declared ahead of time, as is the case in other languages.
    The `arguments` object is available to help us out, especially when we''re trying
    to keep something generic. For example, certain callers may not pass all arguments.
    That''s fine, our functions can cope and we can utilize this capability to define
    functions that are better equipped to generically interact with the Lo-Dash API,
    as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript允许我们在定义函数时有一定的自由度。并非所有参数都需要在事先静态声明，就像在其他语言中那样。`arguments`对象可以帮助我们，尤其是在我们试图保持通用性时。例如，某些调用者可能不会传递所有参数。这没关系，我们的函数可以应对这种情况，我们可以利用这种能力来定义更好的函数，这些函数可以更通用地与Lo-Dash
    API交互，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `insert()` function accepts a `coll` and a `callback` argument. The collection
    is always required but the callback is optional. If no callback is provided, it
    defaults to the `identity()` function.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()`函数接受`coll`和`callback`参数。集合总是必需的，但回调是可选的。如果没有提供回调，它默认为`identity()`函数。'
- en: There's some additional trickery involved here as well, since any other arguments
    supplied to the function are the targets to be inserted into the collection. We
    use the `slice()` function to stick these in the `toInsert` variable and we slice
    them differently depending on whether or not a callback function was supplied.
    Then it's just a matter of iterating through each argument value to insert and
    passing our callback to `sortedIndex()`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里还有一些额外的技巧，因为函数中提供的任何其他参数都是要插入到集合中的目标。我们使用`slice()`函数将这些参数放入`toInsert`变量中，并且根据是否提供了回调函数，我们以不同的方式切片它们。然后，只需遍历每个要插入的参数值，并将我们的回调传递给`sortedIndex()`函数。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Setting the callback value to `identity()` isn't strictly necessary here. That's
    the default behavior of most Lo-Dash functions that take callbacks. Being explicit
    doesn't hurt either, especially if we don't want the same default function.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将回调值设置为`identity()`在这里并不是严格必要的。这是大多数接受回调的Lo-Dash函数的默认行为。明确指定也不会有害，尤其是如果我们不想使用相同的默认函数。
- en: Using partials
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用部分应用
- en: 'A handy pattern to solve the generic argument issues that arise is to use partials,
    that is, partially apply function arguments using the `partial()` function. This
    lets us build functions at runtime that can be used repeatedly, without having
    to always apply the same arguments. Sometimes it''s not even feasible to provide
    function arguments. The following is an example of using partials:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 解决出现的一般参数问题的便捷模式是使用部分应用，即使用`partial()`函数部分应用函数参数。这让我们可以在运行时构建可以重复使用的函数，而无需始终应用相同的参数。有时甚至无法提供函数参数。以下是一个使用部分应用的示例：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our `flattenProp()` function is a composition of `flatten()` and `prop()`. The
    result that is returned is a flattened array. So, if any of these property values
    were themselves arrays, they just get added to the single array.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`flattenProp()`函数是`flatten()`和`prop()`的组合。返回的结果是一个扁平化的数组。因此，如果这些属性值本身是数组，它们就会被添加到单个数组中。
- en: There's no need to always supply the name of the property we need flattened,
    especially when the data model used in our application shares many properties
    between entities. This is the perfect case for the use of partial functions. Remember,
    partials aren't entirely static—they do return functions after all. Our code defines
    two partial functions with the `prop` argument preapplied. Later on, we can use
    this function with specific collections.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用中，当使用的数据模型在实体之间共享许多属性时，没有必要总是提供需要扁平化的属性名称。这正是使用部分函数的完美案例。记住，部分函数并非完全静态——它们最终还是会返回函数。我们的代码定义了两个带有预应用`prop`参数的部分函数。稍后，我们可以使用这个函数与特定的集合一起使用。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Creating partial functions out of generic functions is a form of function composition
    and a critical tool in building high-level application components.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从通用函数创建部分函数是一种函数组合的形式，是构建高级应用组件的关键工具。
- en: Generic callbacks
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用回调
- en: 'It''s one thing to design a function that''s called manually in your code or
    in someone else''s code. However, callbacks are essential to Lo-Dash. So it''s
    always worthwhile to consider the fact that our functions are likely to be used
    as callbacks, as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个在代码中手动调用的函数是一回事。然而，回调对于Lo-Dash来说至关重要。因此，始终考虑我们的函数可能被用作回调的事实是值得的，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Our first callback defined in this code is `validItem()`, and this is an incredibly
    useful function because there are bound to be lots of scenarios where you might
    be interested only in valid items. This function takes a generic `item` argument
    and returns `true` if that argument meets a certain criteria. This is the ideal
    format for callbacks that are iteratively applied to collections. The second callback
    is `computed()`, and this too takes a generic `item` argument. This callback is
    useful in mapping scenarios since it returns an extended version of the item,
    with computed properties. There's a third callback here too—`invalidItem()`. This
    is the inverse of the `validItem()` function and we're able to create it using
    `negate()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中定义的第一个回调是`validItem()`，这是一个极其有用的函数，因为在很多情况下，你可能只对有效的项目感兴趣。这个函数接受一个通用的`item`参数，如果该参数满足某些条件，则返回`true`。这是对集合迭代应用回调的理想格式。第二个回调是`computed()`，它也接受一个通用的`item`参数。这个回调在映射场景中很有用，因为它返回一个包含计算属性的项目的扩展版本。这里还有一个第三个回调——`invalidItem()`。这是`validItem()`函数的逆函数，我们可以使用`negate()`来创建它。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that a lot of our callback functions use `item` as the
    first named argument. This is good practice as it gives the readers of your code
    a good indication that a given function is likely used as a callback somewhere.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们很多回调函数都使用`item`作为第一个命名参数。这是一个好的实践，因为它给代码的读者一个很好的提示，即给定的函数可能被用作某个地方的回调。
- en: Generic wrappers and chains
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用包装器和链
- en: With generic functions under our belts, it's time to turn our attention to Lo-Dash
    wrapper instances and create generic function call chains. Chains are useful when
    you're stuck and you need a quick way out of a tricky programming situation, but
    they're also useful in the generic sense. That is, you can compose chains of functionality
    that are general enough to apply in a variety of contexts.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在掌握了通用函数之后，我们现在可以将注意力转向Lo-Dash包装器实例，并创建通用函数调用链。链在陷入困境且需要快速摆脱复杂编程情况时很有用，但它们在通用意义上也很有用。也就是说，你可以组合足够通用的功能链，以便在多种上下文中应用。
- en: Generic filters
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用过滤器
- en: 'Let''s start by taking a look at generic filters and how they can be utilized
    in our functions. Filters are especially suitable for chained function calls since
    they can be stitched together by applying a filter after a preceding filter. There
    are often some kinds of sorting or other constraints that take place at the end
    of a filter, such as limiting the number of results returned, as shown in the
    following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看通用过滤器以及它们如何在我们的函数中发挥作用。过滤器特别适合链式函数调用，因为它们可以通过在先前的过滤器之后应用另一个过滤器来连接起来。在过滤器的末尾通常会有一些排序或其他约束，例如限制返回的结果数量，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our `byName()` function wraps the passed-in collection and applies a `filter()`
    and a `take()` operation. It also accepts a couple of arguments. The `name` argument
    is the name we're filtering the collection on. The `take` argument is optional,
    and if supplied, specifies the number of items to return. If the `take` argument
    is missing, we default to `100`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `byName()` 函数包装了传入的集合，并应用了一个 `filter()` 和一个 `take()` 操作。它还接受一些参数。`name`
    参数是我们过滤集合的名称。`take` 参数是可选的，如果提供，则指定要返回的项目数量。如果 `take` 参数缺失，我们默认为 `100`。
- en: There are three different invocations of `byName()` demonstrated in the preceding
    code. The first invocation is the most straightforward. We're simply passing the
    name, `Leslie`, since this is the name we want to filter the collection by. The
    next invocation performs a `filter()` operation on the collection, then passes
    its result to `byName()`. The last invocation gets the same result as the second.
    However, you'll notice that we've already wrapped the collection, and since the
    `filter()` function is **chainable**, the wrapper instance gets passed as the
    `coll` argument.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中演示了三种不同的 `byName()` 调用。第一次调用是最直接的。我们只是传递了名称 `Leslie`，因为这是我们想要过滤集合的名称。接下来的调用在集合上执行了一个
    `filter()` 操作，然后将结果传递给 `byName()`。最后的调用与第二个调用得到相同的结果。然而，你会注意到我们已经包装了集合，由于 `filter()`
    函数是可链式的，包装器实例被作为 `coll` 参数传递。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Rewrapping a Lo-Dash wrapper is safe. The constructor recognizes this and knows
    how to handle it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重新包装 Lo-Dash 包装器是安全的。构造函数能够识别这一点，并知道如何处理它。
- en: This function constructs a somewhat generic chain. We can pass in the collection
    at runtime along with the name value we would like to filter by. We can even pass
    the number of results we'd like to take, and the function doesn't care if it gets
    a wrapped value. This latter point is especially useful since it allows us to
    use other functions we've developed that perform chained function calls, return
    these chains, and use them. The limiting factor of `byName()` is that it calls
    `value()`, and returns the unwrapped collection.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数构建了一个相对通用的链。我们可以在运行时传入集合以及我们想要过滤的名称值。我们甚至可以传入我们想要获取的结果数量，而函数并不关心它是否得到一个包装的值。这一点尤其有用，因为它允许我们使用我们开发的执行链式函数调用的其他函数，返回这些链，并使用它们。`byName()`
    函数的限制因素在于它调用 `value()`，并返回未包装的集合。
- en: Returning chains
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回链
- en: 'It''s almost always a good idea to have our functions that construct wrappers
    return those same wrapper instances. In the previous section, our function unwrapped
    the value after the call chain had completed and returned it. The problem with
    this approach is that the caller may have more operations to apply on the chain.
    To do this, the value would need to be wrapped again. Lo-Dash wrapper instances
    should have the freedom to move about your code and be passed around from function
    to function, as if it were a plain array, as in the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 总是让我们的构造包装器的函数返回相同的包装器实例几乎总是一个好主意。在上一节中，我们的函数在调用链完成之后解包了值，并返回了它。这种方法的缺点是调用者可能还有更多操作要应用在链上。为了做到这一点，值需要再次被包装。Lo-Dash
    包装器实例应该有自由在你的代码中移动，并从函数传递到函数，就像它是一个普通的数组一样，如下面的示例所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `sort()` function is quite straightforward and doesn't seem to do all that
    much. On the face of it, it just takes in a collection, sorts it, and returns
    it. Yes, that's the goal at a high level. First, you'll notice that the `coll`
    argument is wrapped in the Lo-Dash constructor function—the argument value can
    be either a wrapper instance or an unwrapped value. The function also accepts
    a property name or a function callback to sort the collection by. The `desc` argument
    is optional and it reverses the sort order if `true`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()` 函数相当简单，看起来并没有做太多。表面上，它只是接收一个集合，对其进行排序，然后返回它。是的，这是高层次的目标。首先，你会注意到 `coll`
    参数被包装在 Lo-Dash 构造函数中——参数值可以是包装器实例或未包装的值。该函数还接受一个属性名称或一个用于排序集合的函数回调。`desc` 参数是可选的，如果为
    `true`，则反转排序顺序。'
- en: The major difference between this function and the `byName()` function we implemented
    earlier is that `sort()` will always return a wrapper instance. This means that
    we don't have to rewrap the returned value, should the caller need to add more
    function calls to the chain. You can see this in action with the last invocation
    of `sort()` in the preceding code. Here we're adding a `takeRight()` and a `pluck()`
    call to the chain. Designing functions in this way gives us great flexibility
    in how we're able to use wrappers throughout our code. The general rule would
    be to let your functions be wrapper friendly, both in what they accept as arguments
    and in what they return.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前实现的 `byName()` 函数相比，这个函数的主要区别在于 `sort()` 总是返回一个包装实例。这意味着如果调用者需要向链中添加更多函数调用，我们不需要重新包装返回的值。你可以在前面的代码中看到这一点，即
    `sort()` 的最后调用。在这里，我们向链中添加了 `takeRight()` 和 `pluck()` 调用。以这种方式设计函数使我们能够在整个代码中使用包装器具有很大的灵活性。一般规则是让你的函数对包装器友好，无论是它们接受的参数还是它们返回的内容。
- en: The trade-off, it would appear, is that the caller needs to call not only your
    function, but also the `value()` function. Sometimes, this can be a pain if all
    you want is the actual value so that you can start working with it, but remember
    that the chain itself isn't executed until the `value()` function is called. This
    has implications for lazy evaluation, which simply means that the return values
    aren't computed until `value()` is called. So this could actually be a desired
    trait—the ability to build chains without executing them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，这种权衡是调用者不仅需要调用你的函数，还需要调用 `value()` 函数。有时，如果你只想获取实际值以便开始工作，这可能会很麻烦，但请记住，直到调用
    `value()` 函数，链本身并不会执行。这涉及到延迟求值，简单来说就是返回值不会在调用 `value()` 之前计算。所以这实际上可能是一个期望的特性——能够在不执行它们的情况下构建链。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You should always document in one form or another that your function does indeed
    return a Lo-Dash wrapper and that the caller needs to call `value()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终以某种形式记录你的函数确实返回一个 Lo-Dash 包装器，并且调用者需要调用 `value()`。
- en: Composing functions
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合
- en: Whether our functions are called manually, used as a callback by another function,
    or used in some other context that involves chains, function composition helps
    construct larger pieces of functionality. For example, we may have two smaller
    functions that serve niche purposes on their own. When we're in scenarios where
    these functions may come in handy, we can use the functional tools in Lo-Dash
    to compose a new function that utilizes them, rather than roll out our own.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不论我们的函数是手动调用，还是作为另一个函数的回调使用，或者在涉及链的其他上下文中使用，函数组合有助于构建更大的功能块。例如，我们可能有两个较小的函数，它们各自服务于特定的目的。当我们处于可能需要这些函数的场景时，我们可以使用
    Lo-Dash 中的函数工具来组合一个新的函数，利用它们，而不是自己从头开始编写。
- en: Composing generic functions
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合泛型函数
- en: 'Earlier in the chapter, we emphasized the idea that functions need to be generic
    if they''re to be of any service in more than one context. The same idea holds
    true when composing larger components of smaller functions. The smaller functions
    need to be generic if we''re going to use them to compose anything larger. Likewise,
    the composite should also be as generic as possible so that we can use it as an
    ingredient in a larger piece of the application. This is shown in the following
    code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，我们强调了函数需要是通用的，如果它们要在多个上下文中提供帮助。当组合较小的函数的较大组件时，这个想法同样适用。如果我们要用它们来组合任何更大的东西，较小的函数需要是通用的。同样，组合也应该尽可能通用，这样我们就可以将其用作应用程序更大块的一部分的成分。以下代码展示了这一点：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code has two generic utility functions. The `indexByName()` function takes
    a collection and returns an object where the keys are the `name` property for
    every item in the collection. The `enabledIndex()` function takes an object and
    converts each property value to a Boolean value, based on its `enabled` property.
    Perhaps, each of these functions is used on its own elsewhere in your application,
    but now, while developing a new component, we've come up with a use case that
    warrants using them together.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有两个泛型实用函数。`indexByName()` 函数接受一个集合，并返回一个对象，其中键是集合中每个项目的 `name` 属性。`enabledIndex()`
    函数接受一个对象，并根据其 `enabled` 属性将每个属性值转换为布尔值。也许，这些函数在其他地方的应用中单独使用，但现在，在开发新组件的过程中，我们找到了一个需要将它们一起使用的用例。
- en: Rather than having to call each function independently and feed the output of
    the first function to the second, we decide to compose an `enabled()` function.
    This way, we can use a simple invocation any time we need the object structure
    that maps the name to the `enabled` Boolean value. This is done by partially applying
    the collection argument to the function we're creating, using `flow()`. The `flow()`
    function passes the first argument to the first function, and the next, and so
    on, returning the result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是必须独立地调用每个函数并将第一个函数的输出传递给第二个函数，我们决定编写一个`enabled()`函数。这样，每次我们需要将名称映射到`enabled`布尔值的对象结构时，都可以使用简单的调用。这是通过使用`flow()`函数部分应用集合参数到我们创建的函数来实现的。`flow()`函数将第一个参数传递给第一个函数，然后传递下一个，依此类推，并返回结果。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code makes the assumption that the `name` property is unique for each object.
    Otherwise, it wouldn't be worth indexing like this.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码假设每个对象的`name`属性是唯一的。否则，这种索引方式就没有意义了。
- en: Composing callbacks
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合回调
- en: 'The `enabled()` function we just composed in the preceding section was intended
    to be directly called by our code somewhere. Callbacks, on the other hand, are
    generally passed to a Lo-Dash function. Passing inline anonymous functions works
    fine, except when you find yourself writing the same callback functions over and
    over again, or at least, similar functions with little variance. There''s no reason
    that our application can''t compose generic callbacks and make them available
    throughout the application to encourage reuse over duplication. Let''s take a
    look at this example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一节中编写的`enabled()`函数旨在直接由我们的代码在某个地方调用。另一方面，回调通常传递给Lo-Dash函数。传递内联匿名函数效果很好，除非你发现自己一次又一次地编写相同的回调函数，或者至少是略有差异的类似函数。没有理由我们的应用程序不能组合通用回调并在整个应用程序中使它们可用，以鼓励重用而不是复制。让我们看看这个例子：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A common problem faced by callback functions is that they have no control over
    how they're invoked. One function may invoke each of its callbacks using a single
    argument, while the next uses three arguments. This prevents us from doing certain
    things we'd otherwise like to, such as composing callbacks using Lo-Dash functions
    that are already built and ready to go.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数面临的一个常见问题是它们无法控制自己的调用方式。一个函数可能使用单个参数调用其每个回调，而下一个则使用三个参数。这阻止了我们做某些我们本来想做的事情，例如使用已经构建并准备就绪的Lo-Dash函数组合回调。
- en: The `minimal()` function defined in this code is used to pick only the essential
    object properties from the passed-in argument. Let's say we want to pass this
    callback to `map()`. Well, `map()` invokes its callbacks with three arguments,
    the first one being the actual item we're interested in. This means that it's
    nearly impossible for us to use Lo-Dash functions with partially applied arguments
    as callbacks.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中定义的`minimal()`函数用于从传入的参数中仅选择必要对象属性。假设我们想将此回调传递给`map()`。嗯，`map()`使用三个参数调用其回调，第一个参数是我们真正感兴趣的实际项。这意味着我们几乎不可能使用部分应用参数作为回调的Lo-Dash函数。
- en: The workaround we've employed with the `minimal()` callback is to use `flow()`
    to compose the callback. You'll notice that the first function is `identity()`.
    This does nothing more than returning whatever value is passed to it. So in other
    words, it returns the first argument. Next in the flow is our partial function
    that uses `pick()`. And guess what? It'll only get one argument passed to it,
    as we need, even if used in a `map()` callback, which is called with three arguments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`minimal()`回调采用的解决方案是使用`flow()`来组合回调。你会注意到第一个函数是`identity()`。这个函数除了返回传递给它的任何值外，什么都不做。换句话说，它返回第一个参数。在流中下一个是我们的部分函数，它使用`pick()`。而且你知道吗？它只会收到一个参数，正如我们所需要的，即使在使用带有三个参数的`map()`回调时。
- en: Composing chains
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合链
- en: 'Now we''ll look at composing functions that work with chains. As we''ve seen
    throughout this chapter, it''s beneficial for you and anyone else who uses your
    functions to be flexible in what your functions accept as arguments, and what
    they return. For example, a function that accepts a wrapper and returns a wrapper
    means that it can be passed just about anything and that the caller is free to
    extend the call chain. Just as we can compose plain functions and callback functions,
    we can also compose functions whose main focus is working with chains. Take a
    look at the following example:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨如何组合与链一起工作的函数。正如我们在本章中看到的，对于您和任何使用您函数的人来说，使函数接受的参数和返回值灵活是有益的。例如，接受包装实例并返回包装实例的函数意味着它可以传递几乎所有内容，调用者可以自由地扩展调用链。就像我们可以组合普通函数和回调函数一样，我们也可以组合主要关注与链一起工作的函数。请看以下示例：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `rejectOdd()` function here takes either a collection or a wrapper instance
    as the first argument and filters out the odd numbers. Notice that it returns
    a wrapper instead of the unwrapped value. We use this wrapper-friendly function
    to compose two new functions. The first is `sortedEvens()`, which uses our `sorted()`
    function to sort the collection. This returns a wrapper instance, which is then
    fed to the `rejectOdd()` function. The `evensSorted()` function does something
    similar but in a different order. It rejects the odd numbers before sorting them,
    and then it uses `partialRight()` to unwrap the value using `result()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `rejectOdd()` 函数接受一个集合或包装实例作为第一个参数，并过滤掉奇数。请注意，它返回一个包装实例而不是未展开的值。我们使用这个对包装友好的函数来组合两个新的函数。第一个是
    `sortedEvens()`，它使用我们的 `sorted()` 函数对集合进行排序。这返回一个包装实例，然后将其传递给 `rejectOdd()` 函数。`evensSorted()`
    函数执行类似操作，但顺序不同。它在排序之前拒绝奇数，然后使用 `partialRight()` 通过 `result()` 函数展开值。
- en: You can see that when we call the `sortedEvens()` function, it returns a wrapper
    instance because we're extending the function call chain with `reverse()`, and
    then we get the value. However, we don't perform this extension with our composed
    `evensSorted()` function because it unwraps the value for us.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，当我们调用 `sortedEvens()` 函数时，它返回一个包装实例，因为我们通过 `reverse()` 扩展了函数调用链，然后我们获取值。然而，我们不会用我们的组合
    `evensSorted()` 函数执行这种扩展，因为它为我们展开了值。
- en: Method composition
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法组合
- en: 'Sometimes, it makes sense to attach functions to a specific object scope or
    implement methods. If the function requires instance-specific values in order
    to operate, then it''s probably a good idea to implement the function as a property
    of the prototype so that it is always available to instances. So we can use the
    techniques we''ve looked at so far in this chapter to assist us with building
    object methods, which are yet another building block in our application''s structure.
    Take a look at the following example of object methods:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，将函数附加到特定对象作用域或实现方法是有意义的。如果函数需要特定实例的值才能操作，那么将其作为原型的属性实现可能是个好主意，这样它就始终可用于实例。因此，我们可以使用本章中讨论的技术来帮助我们构建对象方法，这些方法是我们应用程序结构中的另一个构建块。请看以下对象方法的示例：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our `User` constructor accepts three arguments, and all of these are set as
    instance values. We've also implemented a `valid()` method. We're utilizing a
    function call chain here to validate each of the instance attributes. Note that
    we've enabled explicit chaining here. This means the functions in the chain that
    would normally return unwrapped values, won't. We're doing this because we need
    to pass primitive values through the chain.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `User` 构造函数接受三个参数，并且所有这些都被设置为实例值。我们还实现了一个 `valid()` 方法。在这里，我们正在使用函数调用链来验证每个实例属性。请注意，我们在这里启用了显式链式调用。这意味着链中的函数通常返回未展开的值，但不会这样做。我们这样做是因为我们需要通过链传递原始值。
- en: The `first` property is wrapped, and we validate that it is a string using the
    `isString()` function. Next, we use `thru()`. We're using our `validThru()` function
    here as a callback to `thru()`. Basically, if the value returned by `isString()`,
    the previous call, is `true`, then return the next value. In this case, it's partially
    applied as the `last` property. The same steps are performed with the `age` property.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`first` 属性被包装，我们使用 `isString()` 函数验证它是否为字符串。接下来，我们使用 `thru()`。在这里，我们使用我们的 `validThru()`
    函数作为 `thru()` 的回调。基本上，如果 `isString()` 返回的值（上一个调用）是 `true`，则返回下一个值。在这种情况下，它部分应用为
    `last` 属性。对 `age` 属性执行相同的步骤。'
- en: What's nice about this approach is that the chain requires access to several
    properties and all enclosed within the method. We can then construct a readable
    chain that validates all of these properties and doesn't require several control
    flow statements, which can be more difficult to maintain than two lines in a chain.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于，链式调用需要访问几个属性，并且所有这些属性都包含在方法内部。然后我们可以构建一个可读的链式调用，验证所有这些属性，而不需要多个控制流语句，这比链式调用中的两行代码更难维护。
- en: Creating mixins
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 mixins
- en: The last major building block we'll visit in this chapter is the mixin. Lo-Dash
    has a `mixin()` function that lets us extend the API by providing our own functions.
    There are two reasons you'd want to do such a thing. The first is that by placing
    your generic toolset in the Lo-Dash object, you can have access to them wherever
    the `_` symbol is accessible. The second reason is that once you've mixed in your
    own function, it can be used as a piece in a function call chain.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将要访问的最后一个主要构建块是 mixin。Lo-Dash 有一个 `mixin()` 函数，允许我们通过提供自己的函数来扩展 API。你想要这样做有两个原因。第一个原因是通过将你的通用工具集放在
    Lo-Dash 对象中，你可以在 `_` 符号可访问的地方使用它们。第二个原因是，一旦你混合了自己的函数，它就可以作为函数调用链的一部分使用。
- en: Creating an average() function
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 average() 函数
- en: 'There''s only so many utilities a library such as Lo-Dash can feasibly ship.
    The ones that are viewed as most applicable to common users are the ones we get
    out of the box. This doesn''t mean that the application you''re working on doesn''t
    have a high-value use case you wish Lo-Dash implemented. For example, assume your
    application computes averages all over the place. While the library doesn''t ship
    with an `average` function, that doesn''t mean we can''t add this function to
    the code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个库如 Lo-Dash 能够实际提供的实用工具是有限的。那些被认为对普通用户最有用的工具是我们默认提供的。这并不意味着你正在开发的应用程序没有高价值的使用案例，你希望
    Lo-Dash 实现这个功能。例如，假设你的应用程序到处都在计算平均值。虽然库中没有提供 `average` 函数，但这并不意味着我们不能将这个函数添加到代码中：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The computation that takes place in our `average()` mixin is really straightforward—division
    of the items by the length of the collection. It's the mapping of these items
    we need to consider. If you look at the arguments accepted by the `average()`
    mixin, you'll notice that it takes a collection, which is always required, and
    a callback. The callback is optional and can be anything that's accepted as a
    `map()` callback. Our chain then reduces these items to a sum before they're divided
    by the collection size.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `average()` mixin 中进行的计算非常简单——将项目除以集合的长度。我们需要考虑的是这些项目的映射。如果你查看 `average()`
    mixin 接受的参数，你会注意到它需要一个集合，这是必需的，还有一个回调函数。回调函数是可选的，可以是任何作为 `map()` 回调接受的函数。然后我们的链式调用在除以集合大小时，将这些项目减少到总和。
- en: You can see that the `average()` function is now part of the Lo-Dash object
    and that we're able to pass a string argument or a function callback. You can
    also see that the function is chainable, as demonstrated in the last invocation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，`average()` 函数现在是 Lo-Dash 对象的一部分，并且我们可以传递一个字符串参数或一个函数回调。你还可以看到，该函数是链式可用的，如最后调用所示。
- en: Creating a distance() function
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 distance() 函数
- en: 'Let''s create a more involved mixin function called `distance`. It''ll use
    the Levenshtein distance algorithm to measure the edit distance between two strings.
    We''ll create another mixin that uses `distance()`. This function will sort collections
    by the shortest distance from the target string:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个更复杂的 mixin 函数，称为 `distance`。它将使用 Levenshtein 距离算法来测量两个字符串之间的编辑距离。我们将创建另一个使用
    `distance()` 的 mixin。这个函数将根据与目标字符串的最短距离对集合进行排序：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We won't fixate on the details of the Levenshtein distance algorithm; there
    are plenty of online resources available for that. The `distance()` mixin we just
    implemented accepts a `source` string and a `target` string with which to compare
    it. The return value represents the number of edits needed to make the target
    match the source. For example, the call to `distance()`in the preceding code yields
    `1`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会专注于 Levenshtein 距离算法的细节；关于这一点，网上有大量的资源。我们刚刚实现的 `distance()` mixin 接受一个 `source`
    字符串和一个 `target` 字符串，用于进行比较。返回值表示使目标匹配源所需的编辑次数。例如，前面代码中 `distance()` 的调用结果为 `1`。
- en: The `closest()` mixin function uses `distance()` as a `sortBy()` callback. This
    is a useful function because it's often a collection of the target strings we're
    comparing the source string to. Further, since it's a mixin function, we're able
    to use it in a chain. The last call to `closest()` does this and then uses `first()`
    to grab the closest value.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`closest()` 混合函数使用 `distance()` 作为 `sortBy()` 回调函数。这是一个有用的函数，因为它通常是我们比较源字符串的目标字符串集合。此外，由于它是一个混合函数，我们能够将其用于链式调用。`closest()`
    的最后调用执行此操作，然后使用 `first()` 获取最接近的值。'
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned some useful approaches to building higher-level
    application components. Functions are the fundamental unit of Lo-Dash programming,
    so it's important that we properly utilize all that they have to offer. We addressed
    some common issues faced when thinking about how to design reusable functions.
    For example, the specificity of a function and the arguments it accepts can impact
    where and how the function can be used in your Lo-Dash code.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了一些构建高级应用程序组件的有用方法。函数是 Lo-Dash 编程的基本单元，因此正确利用它们提供的一切非常重要。我们讨论了在设计可重用函数时遇到的一些常见问题。例如，函数的特异性和它接受的参数可以影响函数在
    Lo-Dash 代码中的使用位置和方式。
- en: Generic wrappers and the chained function calls they implement are powerful
    tools, and there are many implementation options that come with them. We walked
    through several examples of how different aspects of chains work, and how these
    wrappers interact with the various functions in our application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通用包装器和它们实现的链式函数调用是强大的工具，并且它们附带了许多实现选项。我们探讨了链的不同方面的几个示例，以及这些包装器如何与我们的应用程序中的各种函数交互。
- en: Function composition is an essential part of functional programming and we learned
    how to exploit the functional tools Lo-Dash provides to compose larger pieces
    of our application code. These include the generic functions we call manually,
    and callback functions. This chapter closed with a look at the mixin functions
    that are used to extend the Lo-Dash API. The next chapter will show you how to
    take these application-level Lo-Dash components, and make sure they play nicely
    alongside other libraries.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 函数组合是函数式编程的一个基本组成部分，我们学习了如何利用 Lo-Dash 提供的函数式工具来组合更大的应用程序代码片段。这包括我们手动调用的通用函数和回调函数。本章以查看用于扩展
    Lo-Dash API 的混合函数结束。下一章将向您展示如何使用这些应用程序级别的 Lo-Dash 组件，并确保它们与其他库良好地协同工作。
