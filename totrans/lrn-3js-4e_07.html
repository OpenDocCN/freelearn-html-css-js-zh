<html><head></head><body>
		<div><h1 id="_idParaDest-123" class="chapter-number"><a id="_idTextAnchor122"/>7</h1>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Points and Sprites</h1>
			<p>In the previous chapters, we discussed the most important concepts, objects, and APIs that Three.js has to offer. In this chapter, we’ll look into the only concepts we’ve skipped until now: points and sprites. With <code>THREE.Points</code> (sometimes also called sprites), it is very easy to create many small rectangles that always face the camera and you can use to simulate rain, snow, smoke, and other interesting effects. For instance, you can render individual geometries as a set of points and control these points separately. In this chapter, we’ll explore the various point- and sprite-related features provided by Three.js.</p>
			<p>To be more specific, we’ll look at the following topics in this chapter:</p>
			<ul>
				<li>Creating and styling particles using <code>THREE.SpriteMaterial</code> and <code>THREE.PointsMaterial</code></li>
				<li>Using <code>THREE.Points</code> to create a group of points</li>
				<li>Using the canvas to style each point individually</li>
				<li>Using a texture to style the individual points</li>
				<li>Animating <code>THREE.Points</code> objects</li>
				<li>Creating a <code>THREE.Points</code> object from existing geometries</li>
			</ul>
			<p class="callout-heading">A quick note on some of the names used in this chapter</p>
			<p class="callout">In newer versions of Three.js, the names of the objects related to points have changed several times. The <code>THREE.Points</code> object was previously named <code>THREE.PointCloud</code> and, in even older versions, it was called <code>THREE.ParticleSystem</code>. <code>THREE.Sprite</code> used to be called <code>THREE.Particle</code>, and the materials have also undergone several name changes. So, if you see online examples using these old names, remember that they are talking about the same concepts.</p>
			<p>Let’s start by exploring what a particle is and how you can create one.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Understanding points and sprites</h1>
			<p>As we do <a id="_idIndexMarker596"/>with most new concepts, we’ll start with an example. In the sources for this chapter, you’ll find an <a id="_idIndexMarker597"/>example called <code>sprite.html</code>. Upon opening this example, you’ll see a minimalistic scene, containing a simple colored square:</p>
			<div><div><img src="img/Figure_7.01_B18726.jpg" alt="Figure 7.1 – A single rendered sprite"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A single rendered sprite</p>
			<p>You can <a id="_idIndexMarker598"/>use your mouse to rotate around this scene. One thing you’ll notice is that no matter how you look at the square, it will always look the same. For instance, the following screenshot shows a view of the same scene from a different position:</p>
			<div><div><img src="img/Figure_7.02_B18726.jpg" alt="Figure 7.2 – A single rendered sprite will always be facing the camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – A single rendered sprite will always be facing the camera</p>
			<p>As you <a id="_idIndexMarker599"/>can see, the sprite is still angled toward the camera, and you can’t look behind it. You can think of a sprite as a 2D plane that always faces the camera. If you create a sprite without any properties, they are rendered as small, white, two-dimensional squares. To create a sprite, we only need to provide a material:</p>
			<pre class="source-code">
const material = new THREE.SpriteMaterial({ size: 0.1,
  color: 0xff0000 })
const sprite = new THREE.Sprite(material)
sprite.position.copy(new THREE.Vector3(1,1,1))</pre>
			<p>You can <a id="_idIndexMarker600"/>configure how the sprite appears using <code>THREE.SpriteMaterial</code>:</p>
			<ul>
				<li><code>color</code>: This is the color of the sprite. The default color is white.</li>
				<li><code>sizeAttenuation</code>: If this is set to <code>false</code>, the sprite will have the same size, regardless of how far from the camera it is positioned. If this is set to <code>true</code>, the size is based on the distance from the camera. The default value is <code>true</code>. Note that this only has an effect when using <code>THREE.PerspectiveCamera</code>. For <code>THREE.OrthographicCamera</code>, it always acts if set to <code>false</code>.</li>
				<li><code>map</code>: With this property, you can apply a texture to the sprite. You can, for instance, make them look like snowflakes. This property isn’t shown in this example but is explained in the <em class="italic">Styling particles using textures</em> section in this chapter.</li>
				<li><code>opacity</code>: This, together with the <code>transparent</code> property, sets the opacity of the sprite. The default value is <code>1</code> (fully opaque).</li>
				<li><code>transparent</code>: If this is set to <code>true</code>, the sprite will be rendered with the opacity set by the <code>opacity</code> property. The default value is <code>false</code>.</li>
				<li><code>blending</code>: This is the blend mode to use when rendering the sprite.</li>
			</ul>
			<p>Note that <code>THREE.SpriteMaterial</code> extends from the base <code>THREE.Material</code> object, so all the properties from that object also can be used on <code>THREE.SpriteMaterial</code>.</p>
			<p>Before we move <a id="_idIndexMarker601"/>on to more interesting <code>THREE.Points</code> objects, let’s look a bit closer at the <code>THREE.Sprite</code> object. A <code>THREE.Sprite</code> object extends from the <code>THREE.Object3D</code> object just as <code>THREE.Mesh</code> does. This means that most of the properties and functions you know from <code>THREE.Mesh</code> can be used on <code>THREE.Sprite</code>. You can set its position using the <code>position</code> attribute, scale it using the <code>scale</code> property, and move it along its axes using the <code>translate</code> property.</p>
			<p>With <code>THREE.Sprite</code>, you can very easily create a set of objects and move them around the scene. This works well when you’re working with a small number of objects, but you’ll quickly <a id="_idIndexMarker602"/>run into performance issues when you want to work with a high number of <code>THREE.Sprite</code> objects. This is because each of the objects needs to be managed separately by Three.js. Three.js provides an alternative way of handling a large number of sprites using a <code>THREE.Points</code> object. With <code>THREE.Points</code>, Three.js doesn’t have to manage many individual <code>THREE.Sprite</code> objects, just the <code>THREE.Points</code> instance. This will allow Three.js to optimize how it draws the sprites and will result in better performance. The following screenshot shows several sprites rendered with the <code>THREE.Points</code> object:</p>
			<div><div><img src="img/Figure_7.03_B18726.jpg" alt="Figure 7.3 – Multiple points rendered from ﻿THREE.BufferGeometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Multiple points rendered from THREE.BufferGeometry</p>
			<p>To create a <code>THREE.Points</code> object, we need to provide it with <code>THREE.BufferGeometry</code>. For the <a id="_idIndexMarker603"/>previous screenshot, we can create a <code>THREE.BufferGeometry</code> like this:</p>
			<pre class="source-code">
const createPoints = () =&gt; {
  const points = []
  for (let x = -15; x &lt; 15; x++) {
    for (let y = -10; y &lt; 10; y++) {
      let point = new THREE.Vector3(x / 4, y / 4, 0)
      points.push(point)
    }
  }
  const colors = new Float32Array(points.length * 3)
  points.forEach((e, i) =&gt; {
    const c = new THREE.Color(Math.random() * 0xffffff)
    colors[i * 3] = c.r
    colors[i * 3 + 1] = c.g
    colors[i * 3 + 2] = c.b
  })
  const geom = new THREE.BufferGeometry().setFromPoints(points)
  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true))
  return geom
}
const material = new THREE.PointsMaterial({ size: 0.1,
  vertexColors: true, color: 0xffffff })
const points = new THREE.Points(createPoint(), material)</pre>
			<p>As you can <a id="_idIndexMarker604"/>see from this code fragment, first, we create an array of <code>THREE.Vector3</code> objects – one for each position where we want to create a sprite. Additionally, we set the <code>color</code> attribute on <code>THREE.BufferGeometry</code>, which is used to color each sprite. With <code>THREE.BufferGeometry</code> and an instance of <code>THREE.PointsMaterial</code>, we can create the <code>THREE.Points</code> object. The properties of <code>THREE.PointsMaterial</code> are pretty <a id="_idIndexMarker605"/>much the same as they are for <code>THREE.SpriteMaterial</code>:</p>
			<ul>
				<li><code>color</code>: This is the color of the point. The default color is <code>0xffffff</code>.</li>
				<li><code>sizeAttenuation</code> If this is set to <code>false</code>, all the points will have the same size, regardless of how far from the camera they are positioned. If this is set to <code>true</code>, the size is based on the distance from the camera. The default value is <code>true</code>.</li>
				<li><code>map</code>: With this property, you can apply a texture to the point. You can, for instance, make them look like snowflakes. This property isn’t shown in this example but is explained in the <em class="italic">Styling particles using textures</em> section later in this chapter.</li>
				<li><code>opacity</code>: This, together with the <code>transparent</code> property, sets the opacity of the sprites. The default value is <code>1</code> (no opacity).</li>
				<li><code>transparent</code>: If this is set to <code>true</code>, the sprites will be rendered with the opacity set by the <code>opacity</code> property. The default value is <code>false</code>.</li>
				<li><code>blending</code>: This is the blend mode to use when rendering the sprites.</li>
				<li><code>vertexColors</code>: Normally, all the points in <code>THREE.Points</code> have the same color. If this property is set to <code>true</code> and the color’s buffer attribute has been set on the geometry, each point will take the color from that array. The default value is <code>false</code>.</li>
			</ul>
			<p>As always, you can play around with these properties using the menu on the right in each of the examples.</p>
			<p>So far, we’ve only rendered the particles as small squares, which is the default behavior. There are, however, two additional ways you can style particles, which we’ll show in the next section.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Styling particles using textures</h1>
			<p>In this <a id="_idIndexMarker606"/>section, we’ll look at the following two ways <a id="_idIndexMarker607"/>of changing what the sprite looks like:</p>
			<ul>
				<li>Use an HTML canvas to draw an image and show that for each sprite</li>
				<li>Load an external image file to define what each sprite looks like</li>
			</ul>
			<p>Let’s start by drawing the image ourselves.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Drawing an image on the canvas</h2>
			<p>In the <a id="_idIndexMarker608"/>attributes for <code>THREE.PointsMaterial</code>, we mentioned the <code>map</code> property. With the <code>map</code> property, we can load a texture for the individual points. With Three.js, this texture can also be the output from an HTML5 canvas. Before we look at the code, let’s look at an example (<code>canvastexture.js</code>):</p>
			<div><div><img src="img/Figure_7.04_B18726.jpg" alt="Figure 7.4 – Creating sprites using a canvas-based texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Creating sprites using a canvas-based texture</p>
			<p>Here, you can <a id="_idIndexMarker609"/>see that we’ve got a large set of Pac-Man-like ghosts on the screen. This uses the same approach that we saw in the <em class="italic">Understanding points and sprites</em> section earlier. This time, though, we aren’t showing a simple square but an image. To create this texture, we can use the following code:</p>
			<pre class="source-code">
const createGhostTexture = () =&gt; {
  const canvas = document.createElement('canvas')
  canvas.width = 32
  canvas.height = 32
  const ctx = canvas.getContext('2d')
  // the body
  ctx.translate(-81, -84)
  ctx.fillStyle = 'orange'
  ctx.beginPath()
  ctx.moveTo(83, 116)
  ctx.lineTo(83, 102)
  ctx.bezierCurveTo(83, 94, 89, 88, 97, 88)
  // some code removed for clarity
  ctx.fill()
  // the eyes
  ctx.fillStyle = 'white'
  ctx.beginPath()
  ctx.moveTo(91, 96)
  ctx.bezierCurveTo(88, 96, 87, 99, 87, 101)
  ctx.bezierCurveTo(87, 103, 88, 106, 91, 106)
  // some code removed for clarity
  ctx.fill()
  // the pupils
  ctx.fillStyle = 'blue'
  ctx.beginPath()
  ctx.arc(101, 102, 2, 0, Math.PI * 2, true)
  ctx.fill()
  ctx.beginPath()
  ctx.arc(89, 102, 2, 0, Math.PI * 2, true)
  ctx.fill()
  const texture = new THREE.Texture(canvas)
  texture.needsUpdate = true
  return texture
}</pre>
			<p>As you can see, first, we create an HTML canvas, on which we start drawing using the various <code>ctx.</code> functions. In the end, we convert this canvas into a <code>THREE.Texture</code> by calling <code>new THREE.Texture(canvas)</code>, which results in a <code>texture</code> we can use for our sprites. Remember to set <code>texture.needsUpdate</code> to <code>true</code>, which triggers Three.js to load the actual canvas data into the texture.</p>
			<p>Now that <a id="_idIndexMarker610"/>we’ve got a texture, we can use it to create a <code>THREE.PointsMaterial</code>, just like we did in the <em class="italic">Understanding points and </em><em class="italic">sprites</em> section:</p>
			<pre class="source-code">
const createPoints = () =&gt; {
  const points = []
  const range = 15
  for (let i = 0; i &lt; 15000; i++) {
    let particle = new THREE.Vector3(
      Math.random() * range - range / 2,
      Math.random() * range - range / 2,
      Math.random() * range - range / 2
    )
    points.push(particle)
  }
  const colors = new Float32Array(points.length * 3)
  points.forEach((e, i) =&gt; {
    const c = new THREE.Color(Math.random() * 0xffffff)
    colors[i * 3] = c.r
    colors[i * 3 + 1] = c.g
    colors[i * 3 + 2] = c.b
  })
  const geom = new THREE.BufferGeometry().setFromPoints(points)
  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true))
  return geom
}
const material = new THREE.PointsMaterial({ size: 0.1,
  vertexColors: true, color: 0xffffff, map:
    createGhostTexture() })
const points = new THREE.Points(createPoint(), material)</pre>
			<p>As you <a id="_idIndexMarker611"/>can see, we create <code>15000</code> points for this example and position them randomly in the specified range. What you might notice is that even if you turn on <code>transparency</code>, some sprites seem to overlap other sprites. This is because Three.js doesn’t sort sprites based on their z-index, so during rendering, it can’t correctly determine which one is before another one. There are two ways you can work around this: you can turn off <code>depthWrite</code>, or you can play around with the <code>alphaTest</code> property (starting with 0.5 is a good starting point).</p>
			<p>If you zoom out, you will see the 15,000 individual sprites:</p>
			<div><div><img src="img/Figure_7.05_B18726.jpg" alt="Figure 7.5 – Showing 15,000 sprites all at once"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Showing 15,000 sprites all at once</p>
			<p>The amazing <a id="_idIndexMarker612"/>thing is that even with 1 million points, everything is still rendered very smoothly (of course, this depends on the hardware you’re running these examples on):</p>
			<div><div><img src="img/Figure_7.06_B18726.jpg" alt="Figure 7.6 – Showing 1 million sprites all at once"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Showing 1 million sprites all at once</p>
			<p>In the <a id="_idIndexMarker613"/>next section, we’ll load some textures from external images and use those instead of drawing the texture ourselves.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Using textures to style particles</h2>
			<p>In the <a id="_idIndexMarker614"/>example shown in the <em class="italic">Drawing an image on the canvas</em> section, we saw how to style <code>THREE.Points</code> using an HTML canvas. Since you can draw<a id="_idIndexMarker615"/> anything you want and even load external images, you can use this approach to add all kinds of styles to the particle system. There is, however, a more direct way to use an image to style your particles: you can use the <code>THREE.TextureLoader().load()</code> function to load an image as a <code>THREE.Texture</code> object. This <code>THREE.Texture</code> object can then be assigned to the <code>map</code> property of a material.</p>
			<p>In this section, we’ll show you two examples and explain how to create them. Both these examples use an image as a texture for your particles. In the first example, we’ll create a simulation of rain (<code>rain.html</code>):</p>
			<div><div><img src="img/Figure_7.07_B18726.jpg" alt="Figure 7.7 – Simulating rain falling down"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Simulating rain falling down</p>
			<p>The first <a id="_idIndexMarker616"/>thing we need to do is get a texture that will represent our <a id="_idIndexMarker617"/>raindrop. You can find a couple of examples in the <code>assets/textures/particles</code> folder. In the upcoming chapters, we will explain all the details and requirements for textures. For now, all you need to know is that the texture should be square and preferably a power of 2 (for example, 64 x 64, 128 x 128, or 256 x 256). For this example, we’ll use this texture:</p>
			<div><div><img src="img/Figure_7.08_B18726.jpg" alt="Figure 7.8 – Raindrop texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Raindrop texture</p>
			<p>This texture is a simple transparent image and shows the shape and color of a raindrop. Before we can use this texture in <code>THREE.PointsMaterial</code>, we need to load it. This can be done with the following line of code:</p>
			<pre class="source-code">
const texture = new THREE.TextureLoader().load("../../assets/textures/particles/raindrop-3t.png");</pre>
			<p>With this <a id="_idIndexMarker618"/>line of code, Three.js will load the texture, and we <a id="_idIndexMarker619"/>can use it in our material. For this example, we defined the material as follows:</p>
			<pre class="source-code">
const material = new THREE.PointsMaterial({
    size: 0.1,
    vertexColors: false,
    color: 0xffffff,
    map: texture,
    transparent: true,
    opacity: 0.8,
    alphaTest: 0.01
  }),</pre>
			<p>In this chapter, we’ve discussed all of these properties. The main thing to understand here is that the <code>map</code> property points to the texture we loaded with the <code>THREE.TextureLoader.load</code> function. Note that we used the <code>alphaTest</code> property again to make sure there are no weird artifacts when two sprites are moving in front of one another.</p>
			<p>That takes <a id="_idIndexMarker620"/>care of styling the <code>THREE.Points</code> object. What <a id="_idIndexMarker621"/>you’ll also see when you open this example is that the points themselves are moving. Doing this is very simple. Each point is represented as a vertex that makes up the geometry that was used to create the <code>THREE.Points</code> object. Let’s look at how we can add the points for this <code>THREE.Points</code> object:</p>
			<pre class="source-code">
const count = 25000
const range = 20
const createPoints = () =&gt; {
  const points = []
  for (let i = 0; i &lt; count; i++) {
    let particle = new THREE.Vector3(
      Math.random() * range - range / 2,
      Math.random() * range - range / 2,
      Math.random() * range - range / 1.5
    )
    points.push(particle)
  }
  const velocityArray = new Float32Array(count * 2)
  for (let i = 0; i &lt; count * 2; i += 2) {
    velocityArray[i] = ((Math.random() - 0.5) / 5) * 0.1
    velocityArray[i + 1] = (Math.random() / 5) * 0.1 + 0.01
  }
  const geom = new THREE.BufferGeometry().setFromPoints(points)
  geom.setAttribute('velocity', new THREE.BufferAttribute(velocityArray, 2))
  return geom
}
const points = new THREE.Points(geom, material);</pre>
			<p>This isn’t that different than the previous examples we saw in this chapter. Here, we added <a id="_idIndexMarker622"/>another property to each particle called <code>velocity</code>. This property <a id="_idIndexMarker623"/>consists of two values: <code>velocityX</code> and <code>velocityY</code>. The first one defines how a particle (a raindrop) moves horizontally, while the second one defines how fast the raindrop falls. Now that each raindrop has its own speed, we can move the individual particles inside the render loop:</p>
			<pre class="source-code">
const positionArray = points.geometry.attributes.position.array
const velocityArray = points.geometry.attributes.velocity.array
for (let i = 0; i &lt; points.geometry.attributes.position.count; i++) {
  const velocityX = velocityArray[i * 2]
  const velocityY = velocityArray[i * 2 + 1]
  positionArray[i * 3] += velocityX
  positionArray[i * 3 + 1] -= velocityY
  if (positionArray[i * 3] &lt;= -(range / 2) || positionArray[i * 3] &gt;= range / 2)
    positionArray[i * 3] = positionArray[i * 3] * -1
  if (positionArray[i * 3 + 1] &lt;= -(range / 2) || positionArray[i * 3 + 1] &gt;= range / 2)
    positionArray[i * 3 + 1] = positionArray[i * 3 + 1] * -1
}
points.geometry.attributes.position.needsUpdate = true</pre>
			<p>In this <a id="_idIndexMarker624"/>piece of code, we get all the vertices (particles) from the geometry that was used to create <code>THREE.Points</code>. For each of the particles, we take <code>velocityX</code> and <code>velocityY</code> and use them to change the current position of the particle. Then, we make sure the particles stay within the range we’ve defined. If the <code>v.y</code> position<a id="_idIndexMarker625"/> drops below <code>0</code>, we add the raindrop back to the top, and if the <code>v.x</code> position reaches any of the edges, we make it bounce back by inverting the horizontal velocity. Finally, we need to tell Three.js we’ve changed some things in <code>bufferGeometry</code> so that it knows the correct values next time we’re rendering.</p>
			<p>Let’s look at another example. This time, we won’t make rain; instead, we’ll make snow. Additionally, we won’t be using just a single texture – we’ll use three separate images (taken from the Three.js examples). Let’s start by looking at the result first (<code>snow.html</code>):</p>
			<div><div><img src="img/Figure_7.09_B18726.jpg" alt="Figure 7.9 – Snowy scene based on multiple textures"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Snowy scene based on multiple textures</p>
			<p>In the <a id="_idIndexMarker626"/>preceding screenshot, if you look closely, you can see that instead of using just a single image as a texture, we’ve used multiple images that have transparent backgrounds. You might be wondering how we did this. As you probably<a id="_idIndexMarker627"/> remember, we can only have a single material for a <code>THREE.Points</code> object. If we want to have multiple materials, we just have to make multiple <code>THREE.Points</code> instances, as follows:</p>
			<pre class="source-code">
const texture1 = new THREE.TextureLoader().load
  ('/assets/textures/particles/snowflake4_t.png')
const texture2 = new THREE.TextureLoader().load
  ('/assets/textures/particles/snowflake2_t.png')
const texture3 = new  THREE.TextureLoader().load
  ('/assets/textures/particles/snowflake3_t.png')
const baseProps = {
  size: 0.1,
  color: 0xffffff,
  transparent: true,
  opacity: 0.5,
  blending: THREE.AdditiveBlending,
  depthTest: false,
  alphaTest: 0.01
}
const material1 = new THREE.PointsMaterial({
  ...baseProps,
  map: texture1
})
const material2 = new THREE.PointsMaterial({
  ...baseProps,
  map: texture2
})
const material3 = new THREE.PointsMaterial({
  ...baseProps,
  map: texture3
})
const points1 = new THREE.Points(createPoints(), material1)
const points2 = new THREE.Points(createPoints(), material2)
const points3 = new THREE.Points(createPoints(), material3)</pre>
			<p>In this code fragment, you can see that we create three different <code>THREE.Points</code> instances, each with its own materials. To move the snowflakes around, we use the same approach <a id="_idIndexMarker628"/>as for the rain, so we don’t show the details of <code>createPoint</code> and the render loop here. One thing to note here is that it is possible to have a single <code>THREE.Points</code> instance, where the individual sprites have different<a id="_idIndexMarker629"/> textures. However, this would require a custom <code>fragment-shader</code> and your own instance of <code>THREE.ShaderMaterial</code>.</p>
			<p>Before we move on to the next section, note that using <code>THREE.Points</code> is a great way to add visual effects to an existing scene. For instance, the snow we saw in the previous example can quickly turn a standard scene into a snowy one:</p>
			<div><div><img src="img/Figure_7.10_B18726.jpg" alt="Figure 7.10 – THREE.Points together with a cube map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – THREE.Points together with a cube map</p>
			<p>Another way <a id="_idIndexMarker630"/>we can use sprites is to create a simple 2D <strong class="bold">heads-up display</strong> (<strong class="bold">HUD</strong>) on top of an existing scene. We’ll explore how to do this in the next section.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Working with sprite maps</h1>
			<p>At the beginning of this chapter, we used a <code>THREE.Sprite</code> object to render single points. These sprites <a id="_idIndexMarker631"/>were positioned somewhere in the 3D world, and their size was based on the distance from the camera (this is also sometimes <a id="_idIndexMarker632"/>called <code>THREE.Sprite</code> object: we’ll show you how you can use <code>THREE.Sprite</code> to create a layer similar to a HUD for your 3D content using an extra <code>THREE.OrthographicCamera</code> instance and an additional <code>THREE.Scene</code>. We will also show you how to select the image for a <code>THREE.Sprite</code> object using a sprite map.</p>
			<p>As an example, we’re going to create a simple <code>THREE.Sprite</code> object that moves from left to right over the screen. In the background, we’ll render a 3D scene with a camera, which you can move to illustrate that the <code>THREE.Sprite</code> object moves independently of the camera. The following screenshot shows what we’ll be creating for the first example (<code>spritemap.html</code>):</p>
			<div><div><img src="img/Figure_7.11_B18726.jpg" alt="Figure 7.11 – Using two scenes and cameras to create a HUD"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Using two scenes and cameras to create a HUD</p>
			<p>If you open this example in your browser, you’ll see a Pac-Man ghost-like sprite moving across the <a id="_idIndexMarker633"/>screen that changes color and form whenever it hits the right edge. The first thing we’ll do is look at how we can create <code>THREE.OrthographicCamera</code> and a separate scene to render this <code>THREE.Sprite</code>:</p>
			<pre class="source-code">
const sceneOrtho = new THREE.Scene()
sceneOrtho.backgroundColor = new THREE.Color(0x000000)
const cameraOrtho = new THREE.OrthographicCamera(0, window.innerWidth, window.innerHeight, 0, -10, 10)</pre>
			<p>Next, let’s look at the construction of the <code>THREE.Sprite</code> object and how the various shapes the <a id="_idIndexMarker634"/>sprite can take are loaded:</p>
			<pre class="source-code">
const getTexture = () =&gt; {
  const texture = new THREE.TextureLoader().load
   ('/assets/textures/particles/sprite-sheet.png')
  return texture
}
const createSprite = (size, transparent, opacity, spriteNumber) =&gt; {
  const spriteMaterial = new THREE.SpriteMaterial({
    opacity: opacity,
    color: 0xffffff,
    transparent: transparent,
    map: getTexture()
  })
  // we have 1 row, with five sprites
  spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0)
  spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1)
  // make sure the object is always rendered at the front
  spriteMaterial.depthTest = false
  const sprite = new THREE.Sprite(spriteMaterial)
  sprite.scale.set(size, size, size)
  sprite.position.set(100, 50, -10)
  sprite.velocityX = 5
  sprite.name = 'Sprite'
  sceneOrtho.add(sprite)
}</pre>
			<p>In the <code>getTexture()</code> function, we load a texture. However, instead of loading five different images for each ghost, we load a single texture that contains all the sprites (also called a sprite map). The image we have as a texture looks like this:</p>
			<div><div><img src="img/Figure_7.12_B18726.jpg" alt="Figure 7.12 – Input sprite sheet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Input sprite sheet</p>
			<p>With the <code>map.offset</code> and <code>map.repeat</code> properties, we can select the correct sprite to show on the screen. With the <code>map.offset</code> property, we determine the offset for the <em class="italic">x a</em>xis (<code>u</code>) and the <em class="italic">y a</em>xis (<code>v</code>) for the texture we loaded. The scale for these properties runs from <code>0</code> to <code>1</code>. In our example, if we want to select the third ghost, we must set the <code>u</code>-offset (<em class="italic">x a</em>xis) to <code>0.4</code>, and, because we’ve only got one row, we don’t need to <a id="_idIndexMarker635"/>change the <code>v</code>-offset (<em class="italic">y a</em>xis). If we only set this property, the texture shows the third, fourth, and fifth ghosts compressed together on screen. To only show one ghost, we need to zoom in. We can do this by setting the <code>map.repeat</code> property for the <code>u</code>-value to <code>1/5</code>. This means that we zoom in (only for the <em class="italic">x a</em>xis) to only show 20% of the texture, which is exactly one ghost.</p>
			<p>Finally, we need to update the <code>render</code> function:</p>
			<pre class="source-code">
  renderer.render(scene, camera)
  renderer.autoClear = false
  renderer.render(sceneOrtho, cameraOrtho)</pre>
			<p>First, we render the scene with the normal camera and the two meshes; after that, we render the scene containing our sprite. In the render loop, we also switch some properties to show the next sprite when it hits the right wall and change the sprite’s direction (code not shown).</p>
			<p>So far in <a id="_idIndexMarker636"/>this chapter, we’ve mainly looked at creating sprites and point clouds from scratch. An interesting option, though, is to create <code>THREE.Points</code> from an existing geometry.</p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Creating THREE.Points from existing geometry</h1>
			<p>As you <a id="_idIndexMarker637"/>may recall, <code>THREE.Points</code> renders each point based on the vertices from the supplied <code>THREE.BufferGeometry</code>. This means that if we provide a complex geometry (for example, a torus knot or a tube), we can create <code>THREE.Points</code> based on the vertices from that specific geometry. In this final section of this chapter, we’ll create a torus knot, like the one we saw in <a href="B18726_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring Advanced Geometries</em>, and render it as a <code>THREE.Points</code> object.</p>
			<p>We explained the torus knot in <a href="B18726_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, so we won’t go into much detail here. The following screenshot shows the example (<code>points-from-geom.html</code>):</p>
			<div><div><img src="img/Figure_7.13_B18726.jpg" alt="Figure 7.13 – Torus knot rendered as points with a small animation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Torus knot rendered as points with a small animation</p>
			<p>As you <a id="_idIndexMarker638"/>can see from the preceding screenshot, every vertex used to generate the torus knot is used as a point. We can set this up like this:</p>
			<pre class="source-code">
const texture = new THREE.TextureLoader().load('/assets/textures/particles/glow.png')
const geometry = new THREE.TorusKnotGeometry(2, 0.5, 100, 30, 2, 3)
const material = new THREE.PointsMaterial({
    size: 0.2,
    vertexColors: false,
    color: 0xffffff,
    map: texture,
    depthWrite: false,
    opacity: 0.1,
    transparent: true,
    blending: THREE.AdditiveBlending
  })
const points = new THREE.Points(geometry, material)</pre>
			<p>As you <a id="_idIndexMarker639"/>can see, we simply create a geometry and use that as input for the <code>THREE.Points</code> object. This way, we can render every geometry as a points object.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you load external models using a Three.js model loader (for example, a glTF model), you’ll often end up with a hierarchy of objects – often grouped in <code>THREE.Group</code> or <code>THREE.Object3D</code> objects. In those cases, you’ll have to convert each geometry in each group into a <code>THREE.Points</code> object.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Summary</h1>
			<p>That’s a wrap for this chapter. We’ve explained what sprites and points are and how you can style these objects with the materials available. In this chapter, you saw how you can use <code>THREE.Sprite</code> directly, and that if you want to create a large number of particles, you should use a <code>THREE.Points</code> object. With <code>THREE.Points</code>, all the elements share the same material, and the only property you can change for an individual particle is its color by setting the <code>vertexColors</code> property of the material to <code>true</code> and providing a color value in the <code>colors</code> array of <code>THREE.BufferGeometry</code>, which is used to create <code>THREE.Points</code>. We also showed how you can easily animate particles by changing their position. This works the same for an individual <code>THREE.Sprite</code> instance and the vertices from the geometry used to create <code>THREE.Points</code> objects.</p>
			<p>So far, we have created meshes based on geometries provided by Three.js. This works well for simple models, such as spheres and cubes, but isn’t the best approach when you want to create complex 3D models. For those models, you’d usually use a 3D modeling application, such as Blender or 3D Studio Max. In the next chapter, you’ll learn how you can load and display models created by such 3D modeling applications.</p>
		</div>
	

		<div><h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Part 3: Particle Clouds, Loading and Animating Models</h1>
			<p>In this third part, we’ll show you how you can load data from external models and how Three.js supports animations. We’ll also dive into the different types of textures that are supported by Three.js and how you can use them to enhance your models.</p>
			<p>In this part, there are the following chapters:</p>
			<ul>
				<li><a href="B18726_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating and Loading Advanced Meshes and Geometries</em></li>
				<li><a href="B18726_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Animations and Moving the Camera</em></li>
				<li><a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working with Textures</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
	</body></html>