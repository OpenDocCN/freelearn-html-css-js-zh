<html><head></head><body>
		<div id="_idContainer153">
			<h1 id="_idParaDest-123" class="chapter-number"><a id="_idTextAnchor122"/>7</h1>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor123"/>Points and Sprites</h1>
			<p>In the previous chapters, we discussed the most important concepts, objects, and APIs that Three.js has to offer. In this chapter, we’ll look into the only concepts we’ve skipped until now: points and sprites. With <strong class="source-inline">THREE.Points</strong> (sometimes also called sprites), it is very easy to create many small rectangles that always face the camera and you can use to simulate rain, snow, smoke, and other interesting effects. For instance, you can render individual geometries as a set of points and control these points separately. In this chapter, we’ll explore the various point- and sprite-related features provided <span class="No-Break">by Three.js.</span></p>
			<p>To be more specific, we’ll look at the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Creating and styling particles using <strong class="source-inline">THREE.SpriteMaterial</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">THREE.PointsMaterial</strong></span></li>
				<li>Using <strong class="source-inline">THREE.Points</strong> to create a group <span class="No-Break">of points</span></li>
				<li>Using the canvas to style each <span class="No-Break">point individually</span></li>
				<li>Using a texture to style the <span class="No-Break">individual points</span></li>
				<li>Animating <span class="No-Break"><strong class="source-inline">THREE.Points</strong></span><span class="No-Break"> objects</span></li>
				<li>Creating a <strong class="source-inline">THREE.Points</strong> object from <span class="No-Break">existing geometries</span></li>
			</ul>
			<p class="callout-heading">A quick note on some of the names used in this chapter</p>
			<p class="callout">In newer versions of Three.js, the names of the objects related to points have changed several times. The <strong class="source-inline">THREE.Points</strong> object was previously named <strong class="source-inline">THREE.PointCloud</strong> and, in even older versions, it was called <strong class="source-inline">THREE.ParticleSystem</strong>. <strong class="source-inline">THREE.Sprite</strong> used to be called <strong class="source-inline">THREE.Particle</strong>, and the materials have also undergone several name changes. So, if you see online examples using these old names, remember that they are talking about the <span class="No-Break">same concepts.</span></p>
			<p>Let’s start by exploring what a particle is and how you can <span class="No-Break">create one.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Understanding points and sprites</h1>
			<p>As we do <a id="_idIndexMarker596"/>with most new concepts, we’ll start with an example. In the sources for this chapter, you’ll find an <a id="_idIndexMarker597"/>example called <strong class="source-inline">sprite.html</strong>. Upon opening this example, you’ll see a minimalistic scene, containing a simple <span class="No-Break">colored square:</span></p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/Figure_7.01_B18726.jpg" alt="Figure 7.1 – A single rendered sprite"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A single rendered sprite</p>
			<p>You can <a id="_idIndexMarker598"/>use your mouse to rotate around this scene. One thing you’ll notice is that no matter how you look at the square, it will always look the same. For instance, the following screenshot shows a view of the same scene from a <span class="No-Break">different position:</span></p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/Figure_7.02_B18726.jpg" alt="Figure 7.2 – A single rendered sprite will always be facing the camera"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – A single rendered sprite will always be facing the camera</p>
			<p>As you <a id="_idIndexMarker599"/>can see, the sprite is still angled toward the camera, and you can’t look behind it. You can think of a sprite as a 2D plane that always faces the camera. If you create a sprite without any properties, they are rendered as small, white, two-dimensional squares. To create a sprite, we only need to provide <span class="No-Break">a material:</span></p>
			<pre class="source-code">
const material = new THREE.SpriteMaterial({ size: 0.1,
  color: 0xff0000 })
const sprite = new THREE.Sprite(material)
sprite.position.copy(new THREE.Vector3(1,1,1))</pre>
			<p>You can <a id="_idIndexMarker600"/>configure how the sprite appears <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">THREE.SpriteMaterial</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">color</strong>: This is the color of the sprite. The default color <span class="No-Break">is white.</span></li>
				<li><strong class="source-inline">sizeAttenuation</strong>: If this is set to <strong class="source-inline">false</strong>, the sprite will have the same size, regardless of how far from the camera it is positioned. If this is set to <strong class="source-inline">true</strong>, the size is based on the distance from the camera. The default value is <strong class="source-inline">true</strong>. Note that this only has an effect when using <strong class="source-inline">THREE.PerspectiveCamera</strong>. For <strong class="source-inline">THREE.OrthographicCamera</strong>, it always acts if set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">map</strong>: With this property, you can apply a texture to the sprite. You can, for instance, make them look like snowflakes. This property isn’t shown in this example but is explained in the <em class="italic">Styling particles using textures</em> section in <span class="No-Break">this chapter.</span></li>
				<li><strong class="source-inline">opacity</strong>: This, together with the <strong class="source-inline">transparent</strong> property, sets the opacity of the sprite. The default value is <strong class="source-inline">1</strong> (<span class="No-Break">fully opaque).</span></li>
				<li><strong class="source-inline">transparent</strong>: If this is set to <strong class="source-inline">true</strong>, the sprite will be rendered with the opacity set by the <strong class="source-inline">opacity</strong> property. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">blending</strong>: This is the blend mode to use when rendering <span class="No-Break">the sprite.</span></li>
			</ul>
			<p>Note that <strong class="source-inline">THREE.SpriteMaterial</strong> extends from the base <strong class="source-inline">THREE.Material</strong> object, so all the properties from that object also can be used <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">THREE.SpriteMaterial</strong></span><span class="No-Break">.</span></p>
			<p>Before we move <a id="_idIndexMarker601"/>on to more interesting <strong class="source-inline">THREE.Points</strong> objects, let’s look a bit closer at the <strong class="source-inline">THREE.Sprite</strong> object. A <strong class="source-inline">THREE.Sprite</strong> object extends from the <strong class="source-inline">THREE.Object3D</strong> object just as <strong class="source-inline">THREE.Mesh</strong> does. This means that most of the properties and functions you know from <strong class="source-inline">THREE.Mesh</strong> can be used on <strong class="source-inline">THREE.Sprite</strong>. You can set its position using the <strong class="source-inline">position</strong> attribute, scale it using the <strong class="source-inline">scale</strong> property, and move it along its axes using the <span class="No-Break"><strong class="source-inline">translate</strong></span><span class="No-Break"> property.</span></p>
			<p>With <strong class="source-inline">THREE.Sprite</strong>, you can very easily create a set of objects and move them around the scene. This works well when you’re working with a small number of objects, but you’ll quickly <a id="_idIndexMarker602"/>run into performance issues when you want to work with a high number of <strong class="source-inline">THREE.Sprite</strong> objects. This is because each of the objects needs to be managed separately by Three.js. Three.js provides an alternative way of handling a large number of sprites using a <strong class="source-inline">THREE.Points</strong> object. With <strong class="source-inline">THREE.Points</strong>, Three.js doesn’t have to manage many individual <strong class="source-inline">THREE.Sprite</strong> objects, just the <strong class="source-inline">THREE.Points</strong> instance. This will allow Three.js to optimize how it draws the sprites and will result in better performance. The following screenshot shows several sprites rendered with the <span class="No-Break"><strong class="source-inline">THREE.Points</strong></span><span class="No-Break"> object:</span></p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/Figure_7.03_B18726.jpg" alt="Figure 7.3 – Multiple points rendered from ﻿THREE.BufferGeometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Multiple points rendered from THREE.BufferGeometry</p>
			<p>To create a <strong class="source-inline">THREE.Points</strong> object, we need to provide it with <strong class="source-inline">THREE.BufferGeometry</strong>. For the <a id="_idIndexMarker603"/>previous screenshot, we can create a <strong class="source-inline">THREE.BufferGeometry</strong> <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const createPoints = () =&gt; {
  const points = []
  for (let x = -15; x &lt; 15; x++) {
    for (let y = -10; y &lt; 10; y++) {
      let point = new THREE.Vector3(x / 4, y / 4, 0)
      points.push(point)
    }
  }
  const colors = new Float32Array(points.length * 3)
  points.forEach((e, i) =&gt; {
    const c = new THREE.Color(Math.random() * 0xffffff)
    colors[i * 3] = c.r
    colors[i * 3 + 1] = c.g
    colors[i * 3 + 2] = c.b
  })
  const geom = new THREE.BufferGeometry().setFromPoints(points)
  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true))
  return geom
}
const material = new THREE.PointsMaterial({ size: 0.1,
  vertexColors: true, color: 0xffffff })
const points = new THREE.Points(createPoint(), material)</pre>
			<p>As you can <a id="_idIndexMarker604"/>see from this code fragment, first, we create an array of <strong class="source-inline">THREE.Vector3</strong> objects – one for each position where we want to create a sprite. Additionally, we set the <strong class="source-inline">color</strong> attribute on <strong class="source-inline">THREE.BufferGeometry</strong>, which is used to color each sprite. With <strong class="source-inline">THREE.BufferGeometry</strong> and an instance of <strong class="source-inline">THREE.PointsMaterial</strong>, we can create the <strong class="source-inline">THREE.Points</strong> object. The properties of <strong class="source-inline">THREE.PointsMaterial</strong> are pretty <a id="_idIndexMarker605"/>much the same as they are <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">THREE.SpriteMaterial</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">color</strong>: This is the color of the point. The default color <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0xffffff</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">sizeAttenuation</strong> If this is set to <strong class="source-inline">false</strong>, all the points will have the same size, regardless of how far from the camera they are positioned. If this is set to <strong class="source-inline">true</strong>, the size is based on the distance from the camera. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">map</strong>: With this property, you can apply a texture to the point. You can, for instance, make them look like snowflakes. This property isn’t shown in this example but is explained in the <em class="italic">Styling particles using textures</em> section later in <span class="No-Break">this chapter.</span></li>
				<li><strong class="source-inline">opacity</strong>: This, together with the <strong class="source-inline">transparent</strong> property, sets the opacity of the sprites. The default value is <strong class="source-inline">1</strong> (<span class="No-Break">no opacity).</span></li>
				<li><strong class="source-inline">transparent</strong>: If this is set to <strong class="source-inline">true</strong>, the sprites will be rendered with the opacity set by the <strong class="source-inline">opacity</strong> property. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">blending</strong>: This is the blend mode to use when rendering <span class="No-Break">the sprites.</span></li>
				<li><strong class="source-inline">vertexColors</strong>: Normally, all the points in <strong class="source-inline">THREE.Points</strong> have the same color. If this property is set to <strong class="source-inline">true</strong> and the color’s buffer attribute has been set on the geometry, each point will take the color from that array. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>As always, you can play around with these properties using the menu on the right in each of <span class="No-Break">the examples.</span></p>
			<p>So far, we’ve only rendered the particles as small squares, which is the default behavior. There are, however, two additional ways you can style particles, which we’ll show in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Styling particles using textures</h1>
			<p>In this <a id="_idIndexMarker606"/>section, we’ll look at the following two ways <a id="_idIndexMarker607"/>of changing what the sprite <span class="No-Break">looks like:</span></p>
			<ul>
				<li>Use an HTML canvas to draw an image and show that for <span class="No-Break">each sprite</span></li>
				<li>Load an external image file to define what each sprite <span class="No-Break">looks like</span></li>
			</ul>
			<p>Let’s start by drawing the <span class="No-Break">image ourselves.</span></p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Drawing an image on the canvas</h2>
			<p>In the <a id="_idIndexMarker608"/>attributes for <strong class="source-inline">THREE.PointsMaterial</strong>, we mentioned the <strong class="source-inline">map</strong> property. With the <strong class="source-inline">map</strong> property, we can load a texture for the individual points. With Three.js, this texture can also be the output from an HTML5 canvas. Before we look at the code, let’s look at an <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">canvastexture.js</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/Figure_7.04_B18726.jpg" alt="Figure 7.4 – Creating sprites using a canvas-based texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Creating sprites using a canvas-based texture</p>
			<p>Here, you can <a id="_idIndexMarker609"/>see that we’ve got a large set of Pac-Man-like ghosts on the screen. This uses the same approach that we saw in the <em class="italic">Understanding points and sprites</em> section earlier. This time, though, we aren’t showing a simple square but an image. To create this texture, we can use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const createGhostTexture = () =&gt; {
  const canvas = document.createElement('canvas')
  canvas.width = 32
  canvas.height = 32
  const ctx = canvas.getContext('2d')
  // the body
  ctx.translate(-81, -84)
  ctx.fillStyle = 'orange'
  ctx.beginPath()
  ctx.moveTo(83, 116)
  ctx.lineTo(83, 102)
  ctx.bezierCurveTo(83, 94, 89, 88, 97, 88)
  // some code removed for clarity
  ctx.fill()
  // the eyes
  ctx.fillStyle = 'white'
  ctx.beginPath()
  ctx.moveTo(91, 96)
  ctx.bezierCurveTo(88, 96, 87, 99, 87, 101)
  ctx.bezierCurveTo(87, 103, 88, 106, 91, 106)
  // some code removed for clarity
  ctx.fill()
  // the pupils
  ctx.fillStyle = 'blue'
  ctx.beginPath()
  ctx.arc(101, 102, 2, 0, Math.PI * 2, true)
  ctx.fill()
  ctx.beginPath()
  ctx.arc(89, 102, 2, 0, Math.PI * 2, true)
  ctx.fill()
  const texture = new THREE.Texture(canvas)
  texture.needsUpdate = true
  return texture
}</pre>
			<p>As you can see, first, we create an HTML canvas, on which we start drawing using the various <strong class="source-inline">ctx.</strong> functions. In the end, we convert this canvas into a <strong class="source-inline">THREE.Texture</strong> by calling <strong class="source-inline">new THREE.Texture(canvas)</strong>, which results in a <strong class="source-inline">texture</strong> we can use for our sprites. Remember to set <strong class="source-inline">texture.needsUpdate</strong> to <strong class="source-inline">true</strong>, which triggers Three.js to load the actual canvas data into <span class="No-Break">the texture.</span></p>
			<p>Now that <a id="_idIndexMarker610"/>we’ve got a texture, we can use it to create a <strong class="source-inline">THREE.PointsMaterial</strong>, just like we did in the <em class="italic">Understanding points and </em><span class="No-Break"><em class="italic">sprites</em></span><span class="No-Break"> section:</span></p>
			<pre class="source-code">
const createPoints = () =&gt; {
  const points = []
  const range = 15
  for (let i = 0; i &lt; 15000; i++) {
    let particle = new THREE.Vector3(
      Math.random() * range - range / 2,
      Math.random() * range - range / 2,
      Math.random() * range - range / 2
    )
    points.push(particle)
  }
  const colors = new Float32Array(points.length * 3)
  points.forEach((e, i) =&gt; {
    const c = new THREE.Color(Math.random() * 0xffffff)
    colors[i * 3] = c.r
    colors[i * 3 + 1] = c.g
    colors[i * 3 + 2] = c.b
  })
  const geom = new THREE.BufferGeometry().setFromPoints(points)
  geom.setAttribute('color', new THREE.BufferAttribute(colors, 3, true))
  return geom
}
const material = new THREE.PointsMaterial({ size: 0.1,
  vertexColors: true, color: 0xffffff, map:
    createGhostTexture() })
const points = new THREE.Points(createPoint(), material)</pre>
			<p>As you <a id="_idIndexMarker611"/>can see, we create <strong class="source-inline">15000</strong> points for this example and position them randomly in the specified range. What you might notice is that even if you turn on <strong class="source-inline">transparency</strong>, some sprites seem to overlap other sprites. This is because Three.js doesn’t sort sprites based on their z-index, so during rendering, it can’t correctly determine which one is before another one. There are two ways you can work around this: you can turn off <strong class="source-inline">depthWrite</strong>, or you can play around with the <strong class="source-inline">alphaTest</strong> property (starting with 0.5 is a good <span class="No-Break">starting point).</span></p>
			<p>If you zoom out, you will see the 15,000 <span class="No-Break">individual sprites:</span></p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/Figure_7.05_B18726.jpg" alt="Figure 7.5 – Showing 15,000 sprites all at once"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Showing 15,000 sprites all at once</p>
			<p>The amazing <a id="_idIndexMarker612"/>thing is that even with 1 million points, everything is still rendered very smoothly (of course, this depends on the hardware you’re running these <span class="No-Break">examples on):</span></p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/Figure_7.06_B18726.jpg" alt="Figure 7.6 – Showing 1 million sprites all at once"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Showing 1 million sprites all at once</p>
			<p>In the <a id="_idIndexMarker613"/>next section, we’ll load some textures from external images and use those instead of drawing the <span class="No-Break">texture ourselves.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Using textures to style particles</h2>
			<p>In the <a id="_idIndexMarker614"/>example shown in the <em class="italic">Drawing an image on the canvas</em> section, we saw how to style <strong class="source-inline">THREE.Points</strong> using an HTML canvas. Since you can draw<a id="_idIndexMarker615"/> anything you want and even load external images, you can use this approach to add all kinds of styles to the particle system. There is, however, a more direct way to use an image to style your particles: you can use the <strong class="source-inline">THREE.TextureLoader().load()</strong> function to load an image as a <strong class="source-inline">THREE.Texture</strong> object. This <strong class="source-inline">THREE.Texture</strong> object can then be assigned to the <strong class="source-inline">map</strong> property of <span class="No-Break">a material.</span></p>
			<p>In this section, we’ll show you two examples and explain how to create them. Both these examples use an image as a texture for your particles. In the first example, we’ll create a simulation of <span class="No-Break">rain (</span><span class="No-Break"><strong class="source-inline">rain.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer146" class="IMG---Figure">
					<img src="image/Figure_7.07_B18726.jpg" alt="Figure 7.7 – Simulating rain falling down"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Simulating rain falling down</p>
			<p>The first <a id="_idIndexMarker616"/>thing we need to do is get a texture that will represent our <a id="_idIndexMarker617"/>raindrop. You can find a couple of examples in the <strong class="source-inline">assets/textures/particles</strong> folder. In the upcoming chapters, we will explain all the details and requirements for textures. For now, all you need to know is that the texture should be square and preferably a power of 2 (for example, 64 x 64, 128 x 128, or 256 x 256). For this example, we’ll use <span class="No-Break">this texture:</span></p>
			<div>
				<div id="_idContainer147" class="IMG---Figure">
					<img src="image/Figure_7.08_B18726.jpg" alt="Figure 7.8 – Raindrop texture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Raindrop texture</p>
			<p>This texture is a simple transparent image and shows the shape and color of a raindrop. Before we can use this texture in <strong class="source-inline">THREE.PointsMaterial</strong>, we need to load it. This can be done with the following line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
const texture = new THREE.TextureLoader().load("../../assets/textures/particles/raindrop-3t.png");</pre>
			<p>With this <a id="_idIndexMarker618"/>line of code, Three.js will load the texture, and we <a id="_idIndexMarker619"/>can use it in our material. For this example, we defined the material <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const material = new THREE.PointsMaterial({
    size: 0.1,
    vertexColors: false,
    color: 0xffffff,
    map: texture,
    transparent: true,
    opacity: 0.8,
    alphaTest: 0.01
  }),</pre>
			<p>In this chapter, we’ve discussed all of these properties. The main thing to understand here is that the <strong class="source-inline">map</strong> property points to the texture we loaded with the <strong class="source-inline">THREE.TextureLoader.load</strong> function. Note that we used the <strong class="source-inline">alphaTest</strong> property again to make sure there are no weird artifacts when two sprites are moving in front of <span class="No-Break">one another.</span></p>
			<p>That takes <a id="_idIndexMarker620"/>care of styling the <strong class="source-inline">THREE.Points</strong> object. What <a id="_idIndexMarker621"/>you’ll also see when you open this example is that the points themselves are moving. Doing this is very simple. Each point is represented as a vertex that makes up the geometry that was used to create the <strong class="source-inline">THREE.Points</strong> object. Let’s look at how we can add the points for this <span class="No-Break"><strong class="source-inline">THREE.Points</strong></span><span class="No-Break"> object:</span></p>
			<pre class="source-code">
const count = 25000
const range = 20
const createPoints = () =&gt; {
  const points = []
  for (let i = 0; i &lt; count; i++) {
    let particle = new THREE.Vector3(
      Math.random() * range - range / 2,
      Math.random() * range - range / 2,
      Math.random() * range - range / 1.5
    )
    points.push(particle)
  }
  const velocityArray = new Float32Array(count * 2)
  for (let i = 0; i &lt; count * 2; i += 2) {
    velocityArray[i] = ((Math.random() - 0.5) / 5) * 0.1
    velocityArray[i + 1] = (Math.random() / 5) * 0.1 + 0.01
  }
  const geom = new THREE.BufferGeometry().setFromPoints(points)
  geom.setAttribute('velocity', new THREE.BufferAttribute(velocityArray, 2))
  return geom
}
const points = new THREE.Points(geom, material);</pre>
			<p>This isn’t that different than the previous examples we saw in this chapter. Here, we added <a id="_idIndexMarker622"/>another property to each particle called <strong class="source-inline">velocity</strong>. This property <a id="_idIndexMarker623"/>consists of two values: <strong class="source-inline">velocityX</strong> and <strong class="source-inline">velocityY</strong>. The first one defines how a particle (a raindrop) moves horizontally, while the second one defines how fast the raindrop falls. Now that each raindrop has its own speed, we can move the individual particles inside the <span class="No-Break">render loop:</span></p>
			<pre class="source-code">
const positionArray = points.geometry.attributes.position.array
const velocityArray = points.geometry.attributes.velocity.array
for (let i = 0; i &lt; points.geometry.attributes.position.count; i++) {
  const velocityX = velocityArray[i * 2]
  const velocityY = velocityArray[i * 2 + 1]
  positionArray[i * 3] += velocityX
  positionArray[i * 3 + 1] -= velocityY
  if (positionArray[i * 3] &lt;= -(range / 2) || positionArray[i * 3] &gt;= range / 2)
    positionArray[i * 3] = positionArray[i * 3] * -1
  if (positionArray[i * 3 + 1] &lt;= -(range / 2) || positionArray[i * 3 + 1] &gt;= range / 2)
    positionArray[i * 3 + 1] = positionArray[i * 3 + 1] * -1
}
points.geometry.attributes.position.needsUpdate = true</pre>
			<p>In this <a id="_idIndexMarker624"/>piece of code, we get all the vertices (particles) from the geometry that was used to create <strong class="source-inline">THREE.Points</strong>. For each of the particles, we take <strong class="source-inline">velocityX</strong> and <strong class="source-inline">velocityY</strong> and use them to change the current position of the particle. Then, we make sure the particles stay within the range we’ve defined. If the <strong class="source-inline">v.y</strong> position<a id="_idIndexMarker625"/> drops below <strong class="source-inline">0</strong>, we add the raindrop back to the top, and if the <strong class="source-inline">v.x</strong> position reaches any of the edges, we make it bounce back by inverting the horizontal velocity. Finally, we need to tell Three.js we’ve changed some things in <strong class="source-inline">bufferGeometry</strong> so that it knows the correct values next time <span class="No-Break">we’re rendering.</span></p>
			<p>Let’s look at another example. This time, we won’t make rain; instead, we’ll make snow. Additionally, we won’t be using just a single texture – we’ll use three separate images (taken from the Three.js examples). Let’s start by looking at the result <span class="No-Break">first (</span><span class="No-Break"><strong class="source-inline">snow.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer148" class="IMG---Figure">
					<img src="image/Figure_7.09_B18726.jpg" alt="Figure 7.9 – Snowy scene based on multiple textures"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.9 – Snowy scene based on multiple textures</p>
			<p>In the <a id="_idIndexMarker626"/>preceding screenshot, if you look closely, you can see that instead of using just a single image as a texture, we’ve used multiple images that have transparent backgrounds. You might be wondering how we did this. As you probably<a id="_idIndexMarker627"/> remember, we can only have a single material for a <strong class="source-inline">THREE.Points</strong> object. If we want to have multiple materials, we just have to make multiple <strong class="source-inline">THREE.Points</strong> instances, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const texture1 = new THREE.TextureLoader().load
  ('/assets/textures/particles/snowflake4_t.png')
const texture2 = new THREE.TextureLoader().load
  ('/assets/textures/particles/snowflake2_t.png')
const texture3 = new  THREE.TextureLoader().load
  ('/assets/textures/particles/snowflake3_t.png')
const baseProps = {
  size: 0.1,
  color: 0xffffff,
  transparent: true,
  opacity: 0.5,
  blending: THREE.AdditiveBlending,
  depthTest: false,
  alphaTest: 0.01
}
const material1 = new THREE.PointsMaterial({
  ...baseProps,
  map: texture1
})
const material2 = new THREE.PointsMaterial({
  ...baseProps,
  map: texture2
})
const material3 = new THREE.PointsMaterial({
  ...baseProps,
  map: texture3
})
const points1 = new THREE.Points(createPoints(), material1)
const points2 = new THREE.Points(createPoints(), material2)
const points3 = new THREE.Points(createPoints(), material3)</pre>
			<p>In this code fragment, you can see that we create three different <strong class="source-inline">THREE.Points</strong> instances, each with its own materials. To move the snowflakes around, we use the same approach <a id="_idIndexMarker628"/>as for the rain, so we don’t show the details of <strong class="source-inline">createPoint</strong> and the render loop here. One thing to note here is that it is possible to have a single <strong class="source-inline">THREE.Points</strong> instance, where the individual sprites have different<a id="_idIndexMarker629"/> textures. However, this would require a custom <strong class="source-inline">fragment-shader</strong> and your own instance <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">THREE.ShaderMaterial</strong></span><span class="No-Break">.</span></p>
			<p>Before we move on to the next section, note that using <strong class="source-inline">THREE.Points</strong> is a great way to add visual effects to an existing scene. For instance, the snow we saw in the previous example can quickly turn a standard scene into a <span class="No-Break">snowy one:</span></p>
			<div>
				<div id="_idContainer149" class="IMG---Figure">
					<img src="image/Figure_7.10_B18726.jpg" alt="Figure 7.10 – THREE.Points together with a cube map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.10 – THREE.Points together with a cube map</p>
			<p>Another way <a id="_idIndexMarker630"/>we can use sprites is to create a simple 2D <strong class="bold">heads-up display</strong> (<strong class="bold">HUD</strong>) on top of an existing scene. We’ll explore how to do this in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor128"/>Working with sprite maps</h1>
			<p>At the beginning of this chapter, we used a <strong class="source-inline">THREE.Sprite</strong> object to render single points. These sprites <a id="_idIndexMarker631"/>were positioned somewhere in the 3D world, and their size was based on the distance from the camera (this is also sometimes <a id="_idIndexMarker632"/>called <strong class="bold">billboarding</strong>). In this section, we’ll show an alternative use of the <strong class="source-inline">THREE.Sprite</strong> object: we’ll show you how you can use <strong class="source-inline">THREE.Sprite</strong> to create a layer similar to a HUD for your 3D content using an extra <strong class="source-inline">THREE.OrthographicCamera</strong> instance and an additional <strong class="source-inline">THREE.Scene</strong>. We will also show you how to select the image for a <strong class="source-inline">THREE.Sprite</strong> object using a <span class="No-Break">sprite map.</span></p>
			<p>As an example, we’re going to create a simple <strong class="source-inline">THREE.Sprite</strong> object that moves from left to right over the screen. In the background, we’ll render a 3D scene with a camera, which you can move to illustrate that the <strong class="source-inline">THREE.Sprite</strong> object moves independently of the camera. The following screenshot shows what we’ll be creating for the first <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">spritemap.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer150" class="IMG---Figure">
					<img src="image/Figure_7.11_B18726.jpg" alt="Figure 7.11 – Using two scenes and cameras to create a HUD"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.11 – Using two scenes and cameras to create a HUD</p>
			<p>If you open this example in your browser, you’ll see a Pac-Man ghost-like sprite moving across the <a id="_idIndexMarker633"/>screen that changes color and form whenever it hits the right edge. The first thing we’ll do is look at how we can create <strong class="source-inline">THREE.OrthographicCamera</strong> and a separate scene to render <span class="No-Break">this </span><span class="No-Break"><strong class="source-inline">THREE.Sprite</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const sceneOrtho = new THREE.Scene()
sceneOrtho.backgroundColor = new THREE.Color(0x000000)
const cameraOrtho = new THREE.OrthographicCamera(0, window.innerWidth, window.innerHeight, 0, -10, 10)</pre>
			<p>Next, let’s look at the construction of the <strong class="source-inline">THREE.Sprite</strong> object and how the various shapes the <a id="_idIndexMarker634"/>sprite can take <span class="No-Break">are loaded:</span></p>
			<pre class="source-code">
const getTexture = () =&gt; {
  const texture = new THREE.TextureLoader().load
   ('/assets/textures/particles/sprite-sheet.png')
  return texture
}
const createSprite = (size, transparent, opacity, spriteNumber) =&gt; {
  const spriteMaterial = new THREE.SpriteMaterial({
    opacity: opacity,
    color: 0xffffff,
    transparent: transparent,
    map: getTexture()
  })
  // we have 1 row, with five sprites
  spriteMaterial.map.offset = new THREE.Vector2(0.2 * spriteNumber, 0)
  spriteMaterial.map.repeat = new THREE.Vector2(1 / 5, 1)
  // make sure the object is always rendered at the front
  spriteMaterial.depthTest = false
  const sprite = new THREE.Sprite(spriteMaterial)
  sprite.scale.set(size, size, size)
  sprite.position.set(100, 50, -10)
  sprite.velocityX = 5
  sprite.name = 'Sprite'
  sceneOrtho.add(sprite)
}</pre>
			<p>In the <strong class="source-inline">getTexture()</strong> function, we load a texture. However, instead of loading five different images for each ghost, we load a single texture that contains all the sprites (also called a sprite map). The image we have as a texture looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer151" class="IMG---Figure">
					<img src="image/Figure_7.12_B18726.jpg" alt="Figure 7.12 – Input sprite sheet"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.12 – Input sprite sheet</p>
			<p>With the <strong class="source-inline">map.offset</strong> and <strong class="source-inline">map.repeat</strong> properties, we can select the correct sprite to show on the screen. With the <strong class="source-inline">map.offset</strong> property, we determine the offset for the <em class="italic">x a</em>xis (<strong class="source-inline">u</strong>) and the <em class="italic">y a</em>xis (<strong class="source-inline">v</strong>) for the texture we loaded. The scale for these properties runs from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>. In our example, if we want to select the third ghost, we must set the <strong class="source-inline">u</strong>-offset (<em class="italic">x a</em>xis) to <strong class="source-inline">0.4</strong>, and, because we’ve only got one row, we don’t need to <a id="_idIndexMarker635"/>change the <strong class="source-inline">v</strong>-offset (<em class="italic">y a</em>xis). If we only set this property, the texture shows the third, fourth, and fifth ghosts compressed together on screen. To only show one ghost, we need to zoom in. We can do this by setting the <strong class="source-inline">map.repeat</strong> property for the <strong class="source-inline">u</strong>-value to <strong class="source-inline">1/5</strong>. This means that we zoom in (only for the <em class="italic">x a</em>xis) to only show 20% of the texture, which is exactly <span class="No-Break">one ghost.</span></p>
			<p>Finally, we need to update the <span class="No-Break"><strong class="source-inline">render</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
  renderer.render(scene, camera)
  renderer.autoClear = false
  renderer.render(sceneOrtho, cameraOrtho)</pre>
			<p>First, we render the scene with the normal camera and the two meshes; after that, we render the scene containing our sprite. In the render loop, we also switch some properties to show the next sprite when it hits the right wall and change the sprite’s direction (code <span class="No-Break">not shown).</span></p>
			<p>So far in <a id="_idIndexMarker636"/>this chapter, we’ve mainly looked at creating sprites and point clouds from scratch. An interesting option, though, is to create <strong class="source-inline">THREE.Points</strong> from an <span class="No-Break">existing geometry.</span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor129"/>Creating THREE.Points from existing geometry</h1>
			<p>As you <a id="_idIndexMarker637"/>may recall, <strong class="source-inline">THREE.Points</strong> renders each point based on the vertices from the supplied <strong class="source-inline">THREE.BufferGeometry</strong>. This means that if we provide a complex geometry (for example, a torus knot or a tube), we can create <strong class="source-inline">THREE.Points</strong> based on the vertices from that specific geometry. In this final section of this chapter, we’ll create a torus knot, like the one we saw in <a href="B18726_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Exploring Advanced Geometries</em>, and render it as a <span class="No-Break"><strong class="source-inline">THREE.Points</strong></span><span class="No-Break"> object.</span></p>
			<p>We explained the torus knot in <a href="B18726_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, so we won’t go into much detail here. The following screenshot shows the <span class="No-Break">example (</span><span class="No-Break"><strong class="source-inline">points-from-geom.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer152" class="IMG---Figure">
					<img src="image/Figure_7.13_B18726.jpg" alt="Figure 7.13 – Torus knot rendered as points with a small animation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.13 – Torus knot rendered as points with a small animation</p>
			<p>As you <a id="_idIndexMarker638"/>can see from the preceding screenshot, every vertex used to generate the torus knot is used as a point. We can set this up <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const texture = new THREE.TextureLoader().load('/assets/textures/particles/glow.png')
const geometry = new THREE.TorusKnotGeometry(2, 0.5, 100, 30, 2, 3)
const material = new THREE.PointsMaterial({
    size: 0.2,
    vertexColors: false,
    color: 0xffffff,
    map: texture,
    depthWrite: false,
    opacity: 0.1,
    transparent: true,
    blending: THREE.AdditiveBlending
  })
const points = new THREE.Points(geometry, material)</pre>
			<p>As you <a id="_idIndexMarker639"/>can see, we simply create a geometry and use that as input for the <strong class="source-inline">THREE.Points</strong> object. This way, we can render every geometry as a <span class="No-Break">points object.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you load external models using a Three.js model loader (for example, a glTF model), you’ll often end up with a hierarchy of objects – often grouped in <strong class="source-inline">THREE.Group</strong> or <strong class="source-inline">THREE.Object3D</strong> objects. In those cases, you’ll have to convert each geometry in each group into a <span class="No-Break"><strong class="source-inline">THREE.Points</strong></span><span class="No-Break"> object.</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Summary</h1>
			<p>That’s a wrap for this chapter. We’ve explained what sprites and points are and how you can style these objects with the materials available. In this chapter, you saw how you can use <strong class="source-inline">THREE.Sprite</strong> directly, and that if you want to create a large number of particles, you should use a <strong class="source-inline">THREE.Points</strong> object. With <strong class="source-inline">THREE.Points</strong>, all the elements share the same material, and the only property you can change for an individual particle is its color by setting the <strong class="source-inline">vertexColors</strong> property of the material to <strong class="source-inline">true</strong> and providing a color value in the <strong class="source-inline">colors</strong> array of <strong class="source-inline">THREE.BufferGeometry</strong>, which is used to create <strong class="source-inline">THREE.Points</strong>. We also showed how you can easily animate particles by changing their position. This works the same for an individual <strong class="source-inline">THREE.Sprite</strong> instance and the vertices from the geometry used to create <span class="No-Break"><strong class="source-inline">THREE.Points</strong></span><span class="No-Break"> objects.</span></p>
			<p>So far, we have created meshes based on geometries provided by Three.js. This works well for simple models, such as spheres and cubes, but isn’t the best approach when you want to create complex 3D models. For those models, you’d usually use a 3D modeling application, such as Blender or 3D Studio Max. In the next chapter, you’ll learn how you can load and display models created by such 3D <span class="No-Break">modeling applications.</span></p>
		</div>
	

		<div id="_idContainer154" class="Content">
			<h1 id="_idParaDest-132"><a id="_idTextAnchor131"/>Part 3: Particle Clouds, Loading and Animating Models</h1>
			<p>In this third part, we’ll show you how you can load data from external models and how Three.js supports animations. We’ll also dive into the different types of textures that are supported by Three.js and how you can use them to enhance <span class="No-Break">your models.</span></p>
			<p>In this part, there are the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18726_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating and Loading Advanced Meshes and Geometries</em></li>
				<li><a href="B18726_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Animations and Moving the Camera</em></li>
				<li><a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working with Textures</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer155">
			</div>
		</div>
	</body></html>