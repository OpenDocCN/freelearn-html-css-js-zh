<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-69">
    <a id="_idTextAnchor068">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-70">
    <a id="_idTextAnchor069">
    </a>
    
     Working with Streams
    
   </h1>
   <p>
    
     Streams are one of the key features of Node.js.
    
    
     Most Node.js applications rely on the underlying Node.js streams implementation, be it for reading/writing files, handling HTTP requests, or other network communications.
    
    
     Streams provide a mechanism to read input and write
    
    
     
      output sequentially.
     
    
   </p>
   <p>
    
     By reading chunks of data sequentially, we can work with very large files (or other data input) that would generally be too large to read into memory and process as a whole.
    
    
     Streams are fundamental to big data applications or media streaming services, where the data is too large to consume
    
    
     
      at once.
     
    
   </p>
   <p>
    
     There are four main types of streams
    
    
     
      in Node.js:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Readable streams
      
     </strong>
     
      : Used for reading data, such as reading a file, or reading data from
     
     
      
       a request.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Writable streams
      
     </strong>
     
      : Used for writing data, such as writing a file, or sending data to
     
     
      
       a response.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Duplex streams
      
     </strong>
     
      : Used for both reading and writing data, such as a
     
     
      
       TCP socket.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Transform streams
      
     </strong>
     
      : A type of duplex stream that transforms the data input, and then outputs the transformed data.
     
     
      A common example would be a
     
     
      
       compression stream.
      
     
    </li>
   </ul>
   <p>
    
     This chapter will demonstrate how we can create these various types of streams, as well as how we can chain these types of streams together to form
    
    
     
      stream pipelines.
     
    
   </p>
   <p>
    
     This chapter will cover the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Creating readable and
     
     
      
       writable streams
      
     
    </li>
    <li>
     
      Interacting with
     
     
      
       paused streams
      
     
    </li>
    <li>
     
      
       Piping streams
      
     
    </li>
    <li>
     
      Creating
     
     
      
       transform streams
      
     
    </li>
    <li>
     
      Building
     
     
      
       stream pipelines
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The recipes in this chapter will focus on the streams implementations provided by the Node.js core
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     module in Node.js 22.
    
    
     Because of this, we will not use the
    
    <strong class="source-inline">
     
      readable-stream
     
    </strong>
    
     module (
    
    <a href="https://github.com/nodejs/readable-stream">
     
      https://github.com/nodejs/readable-stream
     
    </a>
    
     ).
    
    
     The
    
    <strong class="source-inline">
     
      readable-stream
     
    </strong>
    
     module aims to mitigate any inconsistencies in the streams implementations across Node.js versions by providing an external mirror of the streams implementations as an independently installable module.
    
    
     At the time of writing, the latest major version of
    
    <strong class="source-inline">
     
      readable-stream
     
    </strong>
    
     is version 4, which aligns with the Node.js 18
    
    
     
      streams implementations.
     
    
   </p>
   <h1 id="_idParaDest-71">
    <a id="_idTextAnchor070">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     For this chapter, you should have Node.js 22 installed, preferably the latest version of Node.js 22.
    
    
     You’ll also need access to a terminal, editor, and
    
    
     
      the internet.
     
    
   </p>
   <p>
    
     The code samples for this chapter are available in this book’s GitHub repository (
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     ) in the
    
    
     <strong class="source-inline">
      
       Chapter03
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor071">
    </a>
    
     Creating readable and writable streams
    
   </h1>
   <p>
    
     The Node.js
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     core module provides the Node.js stream API.
    
    
     This recipe will introduce using streams in Node.js.
    
    
     It will cover how to create both a readable stream and a writable
    
    <a id="_idIndexMarker106">
    </a>
    
     stream to interact with
    
    <a id="_idIndexMarker107">
    </a>
    
     files using the Node.js core
    
    
     <strong class="source-inline">
      
       fs
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <h2 id="_idParaDest-73">
    <a id="_idTextAnchor072">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before diving into this recipe, we must set up our workspace by creating a directory
    
    
     
      and files:
     
    
   </p>
   <ol>
    <li>
     
      First, let’s create a directory to
     
     
      
       work in:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir learning-streams</strong>
<strong class="bold">$ cd learning-streams</strong></pre>
    </li>
    <li>
     
      Create the following
     
     
      
       two files:
      
     
     <pre class="source-code">
<strong class="bold">$ touch write-stream.js</strong>
<strong class="bold">$ touch read-stream.js</strong></pre>
    </li>
   </ol>
   <p>
    
     Now, we’re ready to start
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-74">
    <a id="_idTextAnchor073">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll learn
    
    <a id="_idIndexMarker108">
    </a>
    
     how to create both a readable stream and a writeable
    
    <a id="_idIndexMarker109">
    </a>
    
     stream.
    
    
     First, we’ll create a writable stream so that we can write a large file.
    
    
     After, we’ll read that large file using a
    
    
     
      readable stream:
     
    
   </p>
   <ol>
    <li>
     
      Start by importing the Node.js core
     
     <strong class="bold">
      
       File system
      
     </strong>
     
      module
     
     
      
       into
      
     
     
      <strong class="source-inline">
       
        write-stream.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const fs = require('node:fs');</pre>
    </li>
    <li>
     
      Next, we will create the writable stream using the
     
     <strong class="source-inline">
      
       createWriteStream()
      
     </strong>
     
      method that’s available on the
     
     
      <strong class="source-inline">
       
        fs
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const file = fs.createWriteStream('./file.txt');</pre>
    </li>
    <li>
     
      At this point, we can start writing content into our file.
     
     
      Let’s write a random string to the file
     
     
      
       multiple times:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const file = fs.createWriteStream('./file.txt');
for (let i = 0; i &lt;= 100000; i++) {
  file.write(
    'Node.js is a JavaScript runtime built on Google
    Chrome\'s V8 JavaScript engine.\n'
  );
}</pre>
    </li>
    <li>
     
      Now, we can run the script with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node write-stream.js</strong></pre>
    </li>
    <li>
     
      This will create a file
     
     <a id="_idIndexMarker110">
     </a>
     
      named
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      in your current directory.
     
     
      The file will be
     
     <a id="_idIndexMarker111">
     </a>
     
      approximately
     
     <strong class="source-inline">
      
       7.5M
      
     </strong>
     
      in size.
     
     
      To check that the file exists, enter the following command in
     
     
      
       your terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ ls -lh file.txt</strong>
-rw-r--r--  1 bgriggs  staff   7.5M  8 Nov 16:30 file.txt</pre>
    </li>
    <li>
     
      Next, we’ll create a script that will create a readable stream to read the contents of the file.
     
     
      Start the
     
     <strong class="source-inline">
      
       read-stream.js
      
     </strong>
     
      file by importing the
     
     <strong class="source-inline">
      
       fs
      
     </strong>
     
      
       core module:
      
     
     <pre class="source-code">
const fs = require('node:fs');</pre>
    </li>
    <li>
     
      Now, we can create our readable stream using the
     
     
      <strong class="source-inline">
       
        createReadStream()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
const rs = fs.createReadStream('./file.txt');</pre>
    </li>
    <li>
     
      Next, we can register a
     
     <strong class="source-inline">
      
       data
      
     </strong>
     
      event handler, which will execute each time a chunk of data has
     
     
      
       been read:
      
     
     <pre class="source-code">
rs.on('data', (data) =&gt; {
  console.log('Read chunk:', data);
});</pre>
    </li>
    <li>
     
      We will also add an
     
     <strong class="source-inline">
      
       end
      
     </strong>
     
      event handler, which will be fired when there is no more data left to be consumed from
     
     
      
       the stream:
      
     
     <pre class="source-code">
rs.on('end', () =&gt; {
  console.log('No more data.');
});</pre>
    </li>
    <li>
     
      Run the program with
     
     <a id="_idIndexMarker112">
     </a>
     
      the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node read-stream.js</strong></pre>
     <p class="list-inset">
      
       Expect to see the
      
      <a id="_idIndexMarker113">
      </a>
      
       data chunks as
      
      <strong class="source-inline">
       
        Buffer
       
      </strong>
      
       data that’s logged as
      
      
       
        they’re read:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 3.1 – A snippet of data chunks read by the stream" src="img/B19212_03_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.1 – A snippet of data chunks read by the stream
    
   </p>
   <ol>
    <li value="11">
     
      If we call
     
     <strong class="source-inline">
      
       toString()
      
     </strong>
     
      on the individual chunks of data within the
     
     <strong class="source-inline">
      
       data
      
     </strong>
     
      event handler function, we’ll see the
     
     <strong class="source-inline">
      
       String
      
     </strong>
     
      content output as it is processed.
     
     
      Change the
     
     <strong class="source-inline">
      
       data
      
     </strong>
     
      event handler function to
     
     
      
       the following:
      
     
     <pre class="source-code">
rs.on('data', (data) =&gt; {
  console.log('Read chunk:', data.toString());
});</pre>
    </li>
    <li>
     
      Rerun the script
     
     <a id="_idIndexMarker114">
     </a>
     
      using the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node read-stream.js</strong></pre>
     <p class="list-inset">
      
       Expect to see the
      
      <a id="_idIndexMarker115">
      </a>
      
       
        following output:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 3.2 – A snippet of the data chunks read by the stream, in string form" src="img/B19212_03_02.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.2 – A snippet of the data chunks read by the stream, in string form
    
   </p>
   <p>
    
     With that, we’ve created a file using
    
    <strong class="source-inline">
     
      createWriteStream()
     
    </strong>
    
     , and then read that file
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       createReadStream()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-75">
    <a id="_idTextAnchor074">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we wrote and read a file sequentially using the
    
    <strong class="source-inline">
     
      createReadStream()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      createWriteStream()
     
    </strong>
    
     core
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     methods.
    
    
     The Node.js core
    
    <strong class="source-inline">
     
      fs
     
    </strong>
    
     module relies on the underlying Node.js
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     core module.
    
    
     Generally, the Node.js
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     core module is not interacted with directly.
    
    
     You’d typically only interact with the Node.js
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     implementation via higher-level APIs, such as those exposed by the
    
    
     <strong class="source-inline">
      
       fs
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     For more information about the underlying Node.js streams implementations and API, please refer to the Node.js
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     module documentation
    
    
     
      at
     
    
    <a href="https://nodejs.org/docs/latest-v22.x/api/stream.html">
     
      
       https://nodejs.org/docs/latest-v22.x/api/stream.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     We created a writable
    
    <a id="_idIndexMarker116">
    </a>
    
     stream, via the
    
    <strong class="source-inline">
     
      fs.createWriteStream()
     
    </strong>
    
     method, to write our file contents sequentially.
    
    
     The
    
    <strong class="source-inline">
     
      fs.createWriteStream()
     
    </strong>
    
     method accepts two parameters.
    
    
     The first is the path of the file to write to, while
    
    <a id="_idIndexMarker117">
    </a>
    
     the second is an
    
    <strong class="source-inline">
     
      options
     
    </strong>
    
     object that can be used to supply configuration to
    
    
     
      the stream.
     
    
   </p>
   <p>
    
     The following table details the configuration that we can supply to the
    
    <strong class="source-inline">
     
      fs.createWriteStream()
     
    </strong>
    
     method via an
    
    
     <strong class="source-inline">
      
       options
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-1">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Option
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Default Value
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           flags
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Defines
        
        <strong class="bold">
         
          File
         
        </strong>
        
         <strong class="bold">
          
           System
          
         </strong>
        
        
         
          flags.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          w
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           encoding
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The encoding of
        
        
         
          the file.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           utf8
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           fd
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The
        
        <strong class="source-inline">
         
          fd
         
        </strong>
        
         value is expected to be a file descriptor.
        
        
         When this value is supplied, the
        
        <strong class="source-inline">
         
          path
         
        </strong>
        
         argument will
        
        
         
          be ignored.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           null
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           mode
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Sets the
        
        
         
          file permissions.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           0o666
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           autoClose
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         When
        
        <strong class="source-inline">
         
          autoClose
         
        </strong>
        
         is set to
        
        <strong class="source-inline">
         
          true
         
        </strong>
        
         , the file descriptor will be closed automatically.
        
        
         When
        
        <strong class="source-inline">
         
          false
         
        </strong>
        
         , the file descriptor will need to be
        
        
         
          closed manually.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           true
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           emitClose
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Controls whether the stream emits a
        
        <strong class="source-inline">
         
          close
         
        </strong>
        
         event after it has
        
        
         
          been destroyed.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           false
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           start
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Can be used to specify, as an integer, the position to start
        
        
         
          writing data.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          0
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           fs
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Used to override
        
        
         <strong class="source-inline">
          
           fs
          
         </strong>
        
        
         
          implementations.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           null
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           signal
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Used to specify an
        
        <strong class="source-inline">
         
          AbortSignal
         
        </strong>
        
         object to programmatically cancel the writing of
        
        
         
          the stream.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           null
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           highWaterMark
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Used to specify the maximum number of bytes that can be buffered before backpressure
        
        
         
          is applied.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           16384
          
         </strong>
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 3.1 – The configurations that can be passed to the createWriteStream() method
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     For more information on
    
    <strong class="bold">
     
      File System
     
    </strong>
    
     flags, please refer
    
    
     
      to
     
    
    <a href="https://nodejs.org/api/fs.html#fs_file_system_flags">
     
      
       https://nodejs.org/api/fs.html#fs_file_system_flags
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Then, we created a readable stream to
    
    <a id="_idIndexMarker118">
    </a>
    
     read the contents of our file sequentially.
    
    
     The
    
    <strong class="source-inline">
     
      createReadStream()
     
    </strong>
    
     method is
    
    <a id="_idIndexMarker119">
    </a>
    
     an abstraction of a readable stream.
    
    
     Again, this method expects two parameters – the first being the path to the contents to read, and the second being an
    
    <strong class="source-inline">
     
      options
     
    </strong>
    
     object.
    
    
     The following table details the options we can pass to the
    
    <strong class="source-inline">
     
      createReadStream()
     
    </strong>
    
     method via an
    
    
     <strong class="source-inline">
      
       options
      
     </strong>
    
    
     
      object:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table002">
    <colgroup>
     <col/>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Option
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Description
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Default Value
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           flags
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Defines
        
        <strong class="bold">
         
          File
         
        </strong>
        
         <strong class="bold">
          
           System
          
         </strong>
        
        
         
          flags.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          r
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           encoding
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The encoding of
        
        
         
          the file.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           null
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           fd
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         The
        
        <strong class="source-inline">
         
          fd
         
        </strong>
        
         value is expected to be a file descriptor.
        
        
         When this value is supplied, the
        
        <strong class="source-inline">
         
          path
         
        </strong>
        
         argument will
        
        
         
          be ignored.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           null
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           mode
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Sets the file permissions, but only when the file
        
        
         
          is created.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           0o666
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           autoClose
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         When
        
        <strong class="source-inline">
         
          autoClose
         
        </strong>
        
         is set to
        
        <strong class="source-inline">
         
          true
         
        </strong>
        
         , the file descriptor will be closed automatically.
        
        
         When
        
        <strong class="source-inline">
         
          false
         
        </strong>
        
         , the file descriptor will need to be
        
        
         
          closed manually.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           true
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           emitClose
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Controls whether the stream emits a
        
        <strong class="source-inline">
         
          close
         
        </strong>
        
         event after it has
        
        
         
          been destroyed.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           false
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           start
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Can be used to specify, as an integer, which position to start
        
        
         
          reading data.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        <strong class="source-inline">
         
          0
         
        </strong>
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           end
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Can be used to specify, as an integer, the position to stop
        
        
         
          reading data.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           Infinity
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           highWaterMark
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Dictates the maximum number of bytes that are stored in the internal buffer before the stream stops reading
        
        
         
          the input.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          64 KiB
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           fs
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Used to override
        
        
         <strong class="source-inline">
          
           fs
          
         </strong>
        
        
         
          implementations.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           null
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           signal
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         Used to specify an
        
        <strong class="source-inline">
         
          AbortSignal
         
        </strong>
        
         object to programmatically cancel the reading of
        
        
         
          the stream.
         
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           null
          
         </strong>
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 3.2 – The configurations that can be passed to the createReadStream() method
    
   </p>
   <p>
    
     In
    
    <strong class="source-inline">
     
      read-stream.js
     
    </strong>
    
     , we
    
    <a id="_idIndexMarker120">
    </a>
    
     registered a
    
    <strong class="source-inline">
     
      data
     
    </strong>
    
     event handler that executed each time our
    
    <a id="_idIndexMarker121">
    </a>
    
     readable stream read a chunk of data.
    
    
     We could see the individual chunks’ outputs on the screen as they
    
    
     
      were read:
     
    
   </p>
   <pre class="console">
Read chunk: &lt;Buffer 20 62 75 69 6c 74 20 6f 6e 20 47 6f 6f 67 6c 65 20 43 68 72 6f 6d 65 27 73 20 56 38 20 4a 61 76 61 53 63 72 69 70 74 20 65 6e 67 69 6e 65 2e 0a 4e 6f ... 29149 more bytes&gt;</pre>
   <p>
    
     Once all the file data was read, our
    
    <strong class="source-inline">
     
      end
     
    </strong>
    
     event handler triggered – resulting in the
    
    <strong class="bold">
     
      No more
     
    </strong>
    
     <strong class="bold">
      
       data
      
     </strong>
    
    
     
      message.
     
    
   </p>
   <p>
    
     All Node.js streams are instances
    
    <a id="_idIndexMarker122">
    </a>
    
     of the
    
    <strong class="source-inline">
     
      EventEmitter
     
    </strong>
    
     class (
    
    <a href="https://nodejs.org/api/events.html#events_class_eventemitter">
     
      https://nodejs.org/api/events.html#events_class_eventemitter
     
    </a>
    
     ).
    
    
     Streams emit a series of
    
    
     
      different events.
     
    
   </p>
   <p>
    
     The following events are
    
    <a id="_idIndexMarker123">
    </a>
    
     emitted on
    
    
     
      readable streams:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       close
      
     </strong>
     
      : Emitted when the stream and any of the stream’s resources have been closed.
     
     
      No further events will
     
     
      
       be emitted.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       data
      
     </strong>
     
      : Emitted when new data is read from
     
     
      
       the stream.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       end
      
     </strong>
     
      : Emitted when all available data has
     
     
      
       been read.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       error
      
     </strong>
     
      : Emitted when the readable stream experiences
     
     
      
       an error.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       pause
      
     </strong>
     
      : Emitted when the readable stream
     
     
      
       is paused.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       readable
      
     </strong>
     
      : Emitted when there is data available to
     
     
      
       be read.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       resume
      
     </strong>
     
      : Emitted when a readable stream resumes after being in a
     
     
      
       paused state.
      
     
    </li>
   </ul>
   <p>
    
     The following events are emitted on
    
    
     
      writable streams:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       close
      
     </strong>
     
      : Emitted when the stream and any of its resources have been closed.
     
     
      No further events will
     
     
      
       be emitted.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       drain
      
     </strong>
     
      : Emitted when the writable stream can resume
     
     
      
       writing data.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       error
      
     </strong>
     
      : Emitted when the writeable stream experiences
     
     
      
       an error.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       finish
      
     </strong>
     
      : Emitted when the writeable stream has ended, and all writes have
     
     
      
       been completed.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       pipe
      
     </strong>
     
      : Emitted when the
     
     <strong class="source-inline">
      
       stream.pipe()
      
     </strong>
     
      method is called on a
     
     
      
       readable stream.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       unpipe
      
     </strong>
     
      : Emitted when the
     
     <strong class="source-inline">
      
       stream.unpipe()
      
     </strong>
     
      method is called on a
     
     
      
       readable stream.
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-76">
    <a id="_idTextAnchor075">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Let’s dive deeper into readable
    
    <a id="_idIndexMarker124">
    </a>
    
     streams, including how to read from infinite data
    
    <a id="_idIndexMarker125">
    </a>
    
     sources.
    
    
     We’ll also learn how to use the more modern asynchronous iterator syntax with
    
    
     
      readable streams.
     
    
   </p>
   <h3>
    
     Interacting with infinite data
    
   </h3>
   <p>
    
     Streams make it possible to interact
    
    <a id="_idIndexMarker126">
    </a>
    
     with infinite amounts of data.
    
    
     Let’s write a script that will process data
    
    
     
      sequentially, indefinitely:
     
    
   </p>
   <ol>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       learning-streams
      
     </strong>
     
      directory, create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        infinite-read.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch infinite-read.js</strong></pre>
    </li>
    <li>
     
      We need an infinite data source.
     
     
      We will use the
     
     <strong class="source-inline">
      
       /dev/urandom
      
     </strong>
     
      file, which is available on Unix-like operating systems.
     
     
      This file is a pseudo-random number generator.
     
     
      Add the following to
     
     <strong class="source-inline">
      
       infinite-read.js
      
     </strong>
     
      to calculate the ongoing size
     
     
      
       of
      
     
     
      <strong class="source-inline">
       
        /dev/urandom
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const fs = require('node:fs');
const rs = fs.createReadStream('/dev/urandom');
let size = 0;
rs.on('data', (data) =&gt; {
  size += data.length;
  console.log('File size:', size);
});</pre>
    </li>
    <li>
     
      Run the script with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node infinite-read.js</strong></pre>
     <p class="list-inset">
      
       Expect to see an output
      
      <a id="_idIndexMarker127">
      </a>
      
       similar to the following, showing the ever-growing size of the
      
      <strong class="source-inline">
       
        /
       
      </strong>
      
       <strong class="source-inline">
        
         dev/urandom
        
       </strong>
      
      
       
        file:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 3.3 – Output showing the ever-growing size of /dev/urandom" src="img/B19212_03_03.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.3 – Output showing the ever-growing size of /dev/urandom
    
   </p>
   <p>
    
     This example demonstrates how we can use streams to process infinite amounts
    
    
     
      of data.
     
    
   </p>
   <h3>
    
     Readable streams with async iterators
    
   </h3>
   <p>
    
     Readable streams are
    
    <strong class="bold">
     
      asynchronous iterables
     
    </strong>
    
     .
    
    
     This means
    
    <a id="_idIndexMarker128">
    </a>
    
     we can use the
    
    <strong class="source-inline">
     
      for await...of
     
    </strong>
    
     syntax to
    
    <a id="_idIndexMarker129">
    </a>
    
     loop over the stream data.
    
    
     In the following steps, we will implement the same functionality as in the main recipe but using the
    
    <strong class="source-inline">
     
      for
     
    </strong>
    
     <strong class="source-inline">
      
       await...of
      
     </strong>
    
    
     
      syntax:
     
    
   </p>
   <ol>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        for-await-read-stream.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch for-await-read-stream.js</strong></pre>
    </li>
    <li>
     
      To implement the
     
     <strong class="source-inline">
      
       read-stream.js
      
     </strong>
     
      logic from this recipe using asynchronous iterables, use
     
     <a id="_idIndexMarker130">
     </a>
     
      the
     
     
      
       following code:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const rs = fs.createReadStream('./file.txt');
async function run () {
  for await (const chunk of rs) {
    console.log('Read chunk:', chunk.toString());
  }
  console.log('No more data.');
}
run();</pre>
    </li>
    <li>
     
      Run the file with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node for-await-read-stream.js</strong></pre>
    </li>
   </ol>
   <p>
    
     For more information on the
    
    <strong class="source-inline">
     
      for await...of
     
    </strong>
    
     syntax, please refer to the MDN web
    
    
     
      docs (
     
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of">
     
      
       https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Generally, developers should opt to use one of the Node.js streams API styles as using a combination of
    
    <strong class="source-inline">
     
      on('data')
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      on('readable')
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     , and/or async iterators could lead to
    
    
     
      unclear behavior.
     
    
   </p>
   <h3>
    
     Generating readable streams with Readable.from()
    
   </h3>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Readable.from()
     
    </strong>
    
     method is exposed by the Node.js core
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     module.
    
    
     This method is used to construct readable
    
    <a id="_idIndexMarker131">
    </a>
    
     streams with iterators.
    
    
     Let’s
    
    <a id="_idIndexMarker132">
    </a>
    
     take a
    
    
     
      closer look:
     
    
   </p>
   <ol>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        async-generator.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch async-generator.js</strong></pre>
    </li>
    <li>
     
      Import the
     
     <strong class="source-inline">
      
       Readable
      
     </strong>
     
      class from the
     
     
      <strong class="source-inline">
       
        stream
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const { Readable } = require('node:stream');</pre>
    </li>
    <li>
     
      Define the asynchronous generator function.
     
     
      This will form the content of our
     
     
      
       readable stream:
      
     
     <pre class="source-code">
async function * generate () {
  yield 'Node.js';
  yield 'is';
  yield 'a';
  yield 'JavaScript';
  yield 'Runtime';
}</pre>
     <p class="list-inset">
      
       Note the use of the
      
      <strong class="source-inline">
       
        function*
       
      </strong>
      
       syntax.
      
      
       This syntax defines a generator function.
      
      
       For more details on generator syntax, please refer to the MDN web
      
      
       
        docs (
       
      
      <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">
       
        
         https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*
        
       
      </a>
      
       
        ).
       
      
     </p>
    </li>
    <li>
     
      Create the readable stream using the
     
     <strong class="source-inline">
      
       Readable.from()
      
     </strong>
     
      method, passing the
     
     <strong class="source-inline">
      
       generate()
      
     </strong>
     
      function as
     
     
      
       the argument:
      
     
     <pre class="source-code">
const readable = Readable.from(generate());</pre>
    </li>
    <li>
     
      To output the content of our readable stream, register a
     
     <strong class="source-inline">
      
       data
      
     </strong>
     
      event handler that prints
     
     
      
       the chunks:
      
     
     <pre class="source-code">
readable.on('data', (chunk) =&gt; {
  console.log(chunk);
});</pre>
    </li>
    <li>
     
      Run the program
     
     <a id="_idIndexMarker133">
     </a>
     
      by entering the following command in
     
     <a id="_idIndexMarker134">
     </a>
     
      
       your terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ node async-generator.js</strong></pre>
     <p class="list-inset">
      
       Expect to see the following generated values
      
      
       
        as output:
       
      
     </p>
     <pre class="source-code">Node.js
is
a
JavaScript
Runtime</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-77">
    <a id="_idTextAnchor076">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <a href="B19212_02.xhtml#_idTextAnchor041">
      
       <em class="italic">
        
         Chapter 2
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Interacting with paused streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Piping streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Creating transform streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Building stream pipelines
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-78">
    <a id="_idTextAnchor077">
    </a>
    
     Interacting with paused streams
    
   </h1>
   <p>
    
     A Node.js stream can be in either flowing or paused mode.
    
    
     In flowing mode, data chunks are read automatically, whereas in paused mode, the
    
    <strong class="source-inline">
     
      stream.read()
     
    </strong>
    
     method must be called to read the chunks
    
    
     
      of data.
     
    
   </p>
   <p>
    
     In this recipe, we’ll learn how to
    
    <a id="_idIndexMarker135">
    </a>
    
     interact with a readable stream that is in paused mode, which is its default
    
    
     
      upon creation.
     
    
   </p>
   <h2 id="_idParaDest-79">
    <a id="_idTextAnchor078">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     In the
    
    <strong class="source-inline">
     
      learning-streams
     
    </strong>
    
     directory that we created in the previous recipe, create the
    
    
     
      following file:
     
    
   </p>
   <pre class="source-code">
<strong class="bold">$ touch paused-stream.js</strong></pre>
   <p>
    
     We’re now ready to start
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-80">
    <a id="_idTextAnchor079">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll learn how to interact with a readable stream that is in
    
    
     
      paused mode:
     
    
   </p>
   <ol>
    <li>
     
      First, import the
     
     <strong class="source-inline">
      
       fs
      
     </strong>
     
      module
     
     
      
       into
      
     
     
      <strong class="source-inline">
       
        paused-stream.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const fs = require('node:fs');</pre>
    </li>
    <li>
     
      Next, create a readable stream to read the
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      file using the
     
     
      <strong class="source-inline">
       
        createReadStream()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
const rs = fs.createReadStream('./file.txt');</pre>
    </li>
    <li>
     
      Next, we need to register a
     
     <strong class="source-inline">
      
       readable
      
     </strong>
     
      event handler on the
     
     
      
       readable stream:
      
     
     <pre class="source-code">
rs.on('readable', () =&gt; {
  // Read data
});</pre>
    </li>
    <li>
     
      Now, we can add the manual logic to read the data chunks within our
     
     <strong class="source-inline">
      
       readable
      
     </strong>
     
      handler.
     
     
      Add the following logic to read the data, until there is no data left
     
     
      
       to consume:
      
     
     <pre class="source-code">
  // Read data
  let data = rs.read();
  while (data !== null) {
    console.log('Read chunk:', data.toString());
    data = rs.read();
  }</pre>
    </li>
    <li>
     
      Now, we can register an
     
     <strong class="source-inline">
      
       end
      
     </strong>
     
      event handler for our readable stream that will print a message
     
     <a id="_idIndexMarker136">
     </a>
     
      stating
     
     <strong class="bold">
      
       No more data.
      
     </strong>
     
      once all the data has
     
     
      
       been read:
      
     
     <pre class="source-code">
rs.on('end', () =&gt; {
  console.log('No more data.');
});</pre>
    </li>
    <li>
     
      Run the script with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node paused-stream.js</strong></pre>
     <p class="list-inset">
      
       Expect to see the following output, indicating that the chunks of the readable stream are
      
      
       
        being read:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 3.4 – Overview of the readable stream chunks as they are being read" src="img/B19212_03_04.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.4 – Overview of the readable stream chunks as they are being read
    
   </p>
   <p>
    
     With that, we’ve learned
    
    <a id="_idIndexMarker137">
    </a>
    
     how to interact with a readable stream in paused mode.
    
    
     We did this by listening for the readable event and manually calling the
    
    
     <strong class="source-inline">
      
       read()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-81">
    <a id="_idTextAnchor080">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we learned how to interact with a readable stream that was in
    
    
     
      paused mode.
     
    
   </p>
   <p>
    
     By default, a readable stream is in paused mode.
    
    
     However, a readable stream will switch to flowing mode in the
    
    
     
      following instances:
     
    
   </p>
   <ul>
    <li>
     
      When a
     
     <strong class="source-inline">
      
       data
      
     </strong>
     
      event handler
     
     
      
       is registered
      
     
    </li>
    <li>
     
      When the
     
     <strong class="source-inline">
      
       pipe()
      
     </strong>
     
      method
     
     
      
       is called
      
     
    </li>
    <li>
     
      When the
     
     <strong class="source-inline">
      
       resume()
      
     </strong>
     
      method
     
     
      
       is called
      
     
    </li>
   </ul>
   <p>
    
     Since our program in this recipe did none of these, our stream remained in
    
    
     
      paused mode.
     
    
   </p>
   <p>
    
     If a readable stream was in flowing mode, it would switch back to paused mode in the
    
    
     
      following instances:
     
    
   </p>
   <ul>
    <li>
     
      When the
     
     <strong class="source-inline">
      
       pause()
      
     </strong>
     
      method is called and there are no
     
     
      
       pipe destinations
      
     
    </li>
    <li>
     
      When the
     
     <strong class="source-inline">
      
       unpipe()
      
     </strong>
     
      method is called on all
     
     
      
       pipe destinations
      
     
    </li>
   </ul>
   <p>
    
     We added a
    
    <strong class="source-inline">
     
      readable
     
    </strong>
    
     event handler to our readable stream.
    
    
     If the readable stream was already in flowing mode, a readable event handler being registered would stop the stream from flowing (it’s switched to
    
    <a id="_idIndexMarker138">
    </a>
    
     
      paused mode).
     
    
   </p>
   <p>
    
     When the readable stream is in paused mode, it is necessary to manually call the
    
    <strong class="source-inline">
     
      readableStream.read()
     
    </strong>
    
     method to consume the stream data.
    
    
     In this recipe, we added logic within our
    
    <strong class="source-inline">
     
      readable
     
    </strong>
    
     event handler that continued to read the stream data until the data value was
    
    <strong class="source-inline">
     
      null
     
    </strong>
    
     .
    
    
     The data value being
    
    <strong class="source-inline">
     
      null
     
    </strong>
    
     indicates that the stream has ended (all currently available data has been read).
    
    
     The
    
    <strong class="source-inline">
     
      readable
     
    </strong>
    
     event can be emitted multiple times, indicating that more data has
    
    
     
      become available.
     
    
   </p>
   <p>
    
     When a stream is in paused mode, we can have more control over when the data is being read.
    
    
     Essentially, we’re pulling the data from the stream, rather than it being
    
    
     
      pushed automatically.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Generally, if possible, it’s worthwhile using the
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method to handle the consumption data of a readable stream as memory management is handled automatically.
    
    
     The following recipe,
    
    <em class="italic">
     
      Piping streams
     
    </em>
    
     , will go into more detail about the
    
    
     <strong class="source-inline">
      
       pipe()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-82">
    <a id="_idTextAnchor081">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <a href="B19212_02.xhtml#_idTextAnchor041">
      
       <em class="italic">
        
         Chapter 2
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Creating readable and writable streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Piping streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Creating transform streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Building stream pipelines
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-83">
    <a id="_idTextAnchor082">
    </a>
    
     Piping streams
    
   </h1>
   <p>
    
     A pipe is a form of one-way redirection.
    
    
     In our terminal (DOS or Unix-like), we often utilize the pipe operator (
    
    <strong class="source-inline">
     
      |
     
    </strong>
    
     ) to pipe the
    
    <a id="_idIndexMarker139">
    </a>
    
     output of one program as the input to another program.
    
    
     For example, we can enter
    
    <strong class="source-inline">
     
      $ ls | head -3
     
    </strong>
    
     to pipe the output of the
    
    <strong class="source-inline">
     
      ls
     
    </strong>
    
     command to the
    
    <strong class="source-inline">
     
      head -3
     
    </strong>
    
     command, resulting in the first three files in our directory
    
    
     
      being returned.
     
    
   </p>
   <p>
    
     Like how we can use the pipe operator in our shells to pipe output between programs, we can use the Node.js
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method to pipe data
    
    
     
      between streams.
     
    
   </p>
   <p>
    
     In this recipe, we’ll learn how
    
    <a id="_idIndexMarker140">
    </a>
    
     to use the
    
    
     <strong class="source-inline">
      
       pipe()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-84">
    <a id="_idTextAnchor083">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a directory to
     
     
      
       work in:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir piping-streams</strong>
<strong class="bold">$ cd piping-streams</strong></pre>
    </li>
    <li>
     
      Start by creating a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        file.txt
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch file.txt</strong></pre>
    </li>
    <li>
     
      Add some dummy data to
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      , such as
     
     
      
       the following:
      
     
     <pre class="source-code">
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.</pre>
    </li>
   </ol>
   <p>
    
     Now, we’re ready to start
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-85">
    <a id="_idTextAnchor084">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll learn how to pipe a readable stream to a
    
    
     
      writable stream:
     
    
   </p>
   <ol>
    <li>
     
      Create a file
     
     <a id="_idIndexMarker141">
     </a>
     
      
       named
      
     
     
      <strong class="source-inline">
       
        pipe-stream.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch pipe-stream.js</strong></pre>
    </li>
    <li>
     
      Next, start the
     
     <strong class="source-inline">
      
       pipe-stream.js
      
     </strong>
     
      file by
     
     <a id="_idIndexMarker142">
     </a>
     
      importing the
     
     
      <strong class="source-inline">
       
        fs
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const fs = require('node:fs');</pre>
    </li>
    <li>
     
      Create a readable stream to read
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      using the
     
     
      <strong class="source-inline">
       
        createReadStream()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
const rs = fs.createReadStream('file.txt');</pre>
    </li>
    <li>
     
      Now, we need to pipe our readable stream to
     
     <strong class="source-inline">
      
       process.stdout
      
     </strong>
     
      , which returns a writable stream connected
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        STDOUT
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
rs.pipe(process.stdout);</pre>
    </li>
    <li>
     
      Run the program with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node pipe-stream.js</strong></pre>
     <p class="list-inset">
      
       Expect to see the
      
      
       
        following output:
       
      
     </p>
     <pre class="source-code">Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.</pre>
    </li>
   </ol>
   <p>
    
     With that, we’ve piped a readable stream to a writeable stream using the
    
    
     <strong class="source-inline">
      
       pipe()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-86">
    <a id="_idTextAnchor085">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we created a readable stream to read our
    
    <strong class="source-inline">
     
      file.txt
     
    </strong>
    
     file using the
    
    <strong class="source-inline">
     
      createReadStream()
     
    </strong>
    
     method.
    
    
     Then, we
    
    <a id="_idIndexMarker143">
    </a>
    
     piped the output of this readable stream to
    
    <strong class="source-inline">
     
      process.stdout
     
    </strong>
    
     (a writable
    
    <a id="_idIndexMarker144">
    </a>
    
     stream) using the
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method.
    
    
     The
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method attaches a data event handler to the source stream, which writes the incoming data to the
    
    
     
      destination stream.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method is used to direct data through a flow of streams.
    
    
     Under the hood, the
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method manages the flow of data to ensure that the destination writable stream is not overwhelmed by a faster
    
    
     
      readable stream.
     
    
   </p>
   <p>
    
     The in-built management provided by the
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method helps resolve the issue of backpressure.
    
    
     Backpressure occurs when an input overwhelms a system’s capacity.
    
    
     For streams, this could occur when we’re consuming a stream that is rapidly reading data, and the writable stream can’t keep up.
    
    
     This can result in a large amount of memory being kept in a process before being written by the writable stream.
    
    
     The mass amount of data being stored in memory can degrade our Node.js process performance, or in the worst cases, cause the process
    
    
     
      to crash.
     
    
   </p>
   <p>
    
     By default, when using the
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method,
    
    <strong class="source-inline">
     
      stream.end()
     
    </strong>
    
     is called on the destination writable stream when the source readable stream emits an
    
    <strong class="source-inline">
     
      end
     
    </strong>
    
     event.
    
    
     This means that the destination is no
    
    
     
      longer writable.
     
    
   </p>
   <p>
    
     To disable this default behavior, we can supply
    
    <strong class="source-inline">
     
      { end: false }
     
    </strong>
    
     to the
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method via an
    
    
     <strong class="source-inline">
      
       options
      
     </strong>
    
    
     
      argument:
     
    
   </p>
   <pre class="source-code">
sourceStream.pipe(destinationStream, {end: false});</pre>
   <p>
    
     This configuration instructs the destination stream to remain open even after the
    
    <strong class="source-inline">
     
      end
     
    </strong>
    
     event has been emitted by the
    
    
     
      source stream.
     
    
   </p>
   <h2 id="_idParaDest-87">
    <a id="_idTextAnchor086">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Stream chaining in Node.js allows for efficient data processing by linking together multiple streams.
    
    
     This method enables data transformations with minimal memory overhead, which is ideal for operations such as compression.
    
    
     In the following example, we’ll demonstrate the process of reading a file, compressing its contents, and writing the compressed data to a new file to highlight the use of
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     for
    
    
     
      chaining streams:
     
    
   </p>
   <pre class="source-code">
const fs = require('node:fs');
const zlib = require('node:zlib');
const readStream = fs.createReadStream('input.txt');
const writeStream = fs.createWriteStream('output.txt.gz');
// Chain the streams: read -&gt; compress -&gt; write
readStream.pipe(zlib.createGzip()).pipe(writeStream);</pre>
   <p>
    
     In this example,
    
    <strong class="source-inline">
     
      readStream.pipe(zlib.createGzip()).pipe(writeStream);
     
    </strong>
    
     reads data from
    
    <strong class="source-inline">
     
      input.txt
     
    </strong>
    
     , compresses
    
    <a id="_idIndexMarker145">
    </a>
    
     it on-the-fly, and writes the compressed data to
    
    <strong class="source-inline">
     
      output.txt.gz
     
    </strong>
    
     .
    
    
     This chain
    
    <a id="_idIndexMarker146">
    </a>
    
     of operations is executed with efficiency, showcasing the elegance and power of stream chaining in Node.js for data
    
    
     
      processing tasks.
     
    
   </p>
   <p>
    
     In the example provided, error handling is not explicitly shown, but it’s crucial in a real-world application.
    
    
     In Node.js, when chaining streams, errors can be propagated through the chain.
    
    
     When using
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     , errors should be listened for on each stream by attaching an
    
    <strong class="source-inline">
     
      error
     
    </strong>
    
     event listener to each stream involved.
    
    
     This ensures that errors are caught and managed where
    
    
     
      they occur.
     
    
   </p>
   <h2 id="_idParaDest-88">
    <a id="_idTextAnchor087">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Creating readable and writable streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Creating transform streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Building stream pipelines
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-89">
    <a id="_idTextAnchor088">
    </a>
    
     Creating transform streams
    
   </h1>
   <p>
    
     Transform streams allow us to
    
    <a id="_idIndexMarker147">
    </a>
    
     consume input data, process that data, and then output the data in its processed form.
    
    
     We can use transform streams to handle data manipulation functionally and asynchronously.
    
    
     It’s possible to pipe many transform streams together, allowing us to break complex processing down into
    
    
     
      sequential tasks.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to create a transform stream using the Node.js core
    
    
     <strong class="source-inline">
      
       stream
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     The
    
    <strong class="source-inline">
     
      through2
     
    </strong>
    
     module (
    
    <a href="https://www.npmjs.com/package/through2">
     
      https://www.npmjs.com/package/through2
     
    </a>
    
     ) is very popular and provides a wrapper for creating Node.js transform
    
    <a id="_idIndexMarker148">
    </a>
    
     streams.
    
    
     However, over the past few years, there have been many simplifications and improvements to the Node.js core stream implementation.
    
    
     Today, the Node.js stream API provides simplified construction, as demonstrated in this recipe, which means we can achieve equivalent syntax using Node.js core directly, without the need
    
    
     
      for
     
    
    
     <strong class="source-inline">
      
       through2
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-90">
    <a id="_idTextAnchor089">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Follow
    
    
     
      these
     
    
    
     <a id="_idIndexMarker149">
     </a>
    
    
     
      steps:
     
    
   </p>
   <ol>
    <li>
     
      Create a directory to
     
     
      
       work in:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir transform-streams</strong>
<strong class="bold">$ cd transform-streams</strong></pre>
    </li>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        transform-stream.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch transform-stream.js</strong></pre>
    </li>
    <li>
     
      We’ll also need some sample data to transform.
     
     
      So, create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        file.txt
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch file.txt</strong></pre>
    </li>
    <li>
     
      Add some dummy text data to the
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      file, such as
     
     
      
       the following:
      
     
     <pre class="source-code">
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.</pre>
    </li>
   </ol>
   <p>
    
     Now, we’re ready to start
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-91">
    <a id="_idTextAnchor090">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll learn how to create a transform stream using the Node.js core
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     module.
    
    
     The transform
    
    <a id="_idIndexMarker150">
    </a>
    
     stream we will create will convert all the text from our file
    
    
     
      into uppercase:
     
    
   </p>
   <ol>
    <li>
     
      Start by importing the Node.js core
     
     <strong class="bold">
      
       File system
      
     </strong>
     
      module
     
     
      
       into
      
     
     
      <strong class="source-inline">
       
        transform-stream.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const fs = require('node:fs');</pre>
    </li>
    <li>
     
      Next, we need to import the
     
     <strong class="source-inline">
      
       Transform
      
     </strong>
     
      class from the Node.js core
     
     
      <strong class="source-inline">
       
        stream
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const { Transform } = require('node:stream');</pre>
    </li>
    <li>
     
      Create a readable stream to read the
     
     
      <strong class="source-inline">
       
        file.txt
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
const rs = fs.createReadStream('./file.txt');</pre>
    </li>
    <li>
     
      Once our file content has been processed by our transform stream, we will write it to a new file named
     
     <strong class="source-inline">
      
       newFile.txt
      
     </strong>
     
      .
     
     
      Create a writable stream to write this file using the
     
     
      <strong class="source-inline">
       
        createWriteStream()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
const newFile = fs.createWriteStream('./newFile.txt');</pre>
    </li>
    <li>
     
      Next, we need to define our transform stream.
     
     
      We’ll name our transform
     
     
      
       stream
      
     
     
      <strong class="source-inline">
       
        uppercase()
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const uppercase = new Transform({
  transform (chunk, encoding, callback) {
    // Data processing
  }
});</pre>
    </li>
    <li>
     
      Now, within our transform stream, we will add the logic to transform the chunk into an uppercase string.
     
     
      Below the
     
     <strong class="source-inline">
      
       // Data processing
      
     </strong>
     
      comment, add the
     
     
      
       following line:
      
     
     <pre class="source-code">
    callback(null, chunk.toString().toUpperCase());</pre>
     <p class="list-inset">
      
       This calls the transform
      
      <a id="_idIndexMarker151">
      </a>
      
       stream callback function with the
      
      
       
        transformed chunk.
       
      
     </p>
    </li>
    <li>
     
      At this point, we need to chain all our streams together.
     
     
      We will do this using the
     
     <strong class="source-inline">
      
       pipe()
      
     </strong>
     
      method.
     
     
      Add the following line to the bottom of
     
     
      
       the file:
      
     
     <pre class="source-code">
rs.pipe(uppercase).pipe(newFile);</pre>
    </li>
    <li>
     
      Enter the following command in your terminal to run
     
     
      
       the program:
      
     
     <pre class="source-code">
<strong class="bold">$ node transform-stream.js</strong></pre>
    </li>
    <li>
     
      Expect
     
     <strong class="source-inline">
      
       newFile.txt
      
     </strong>
     
      to have been created by our program.
     
     
      You can confirm this by running the
     
     <strong class="source-inline">
      
       cat
      
     </strong>
     
      command, followed by the new file’s name, in
     
     
      
       the terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ cat newFile.txt</strong>
NODE.JS IS A JAVASCRIPT RUNTIME BUILT ON GOOGLE CHROME'S V8 JAVASCRIPT ENGINE.
NODE.JS IS A JAVASCRIPT RUNTIME BUILT ON GOOGLE CHROME'S V8 JAVASCRIPT ENGINE.
NODE.JS IS A JAVASCRIPT RUNTIME BUILT ON GOOGLE CHROME'S V8 JAVASCRIPT ENGINE.</pre>
     <p class="list-inset">
      
       Note that the contents are now in uppercase, indicating that the data has passed through the
      
      
       
        transform stream.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     With that, we’ve learned how to create a transform stream to manipulate data.
    
    
     Our transform stream converted the input data into uppercase strings.
    
    
     After, we piped our readable stream to the transform stream and piped the transform stream to our
    
    
     
      writable stream.
     
    
   </p>
   <h2 id="_idParaDest-92">
    <a id="_idTextAnchor091">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     Transform streams are duplex streams, which means they implement both readable and writable stream interfaces.
    
    
     Transform streams are used to process (or transform) the input and then pass it
    
    
     
      as output.
     
    
   </p>
   <p>
    
     To create a transform stream, we
    
    <a id="_idIndexMarker152">
    </a>
    
     must import the
    
    <strong class="source-inline">
     
      Transform
     
    </strong>
    
     class from the Node.js core
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     module.
    
    
     The transform stream constructor accepts the following
    
    
     
      two arguments:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       transform
      
     </strong>
     
      : The function that implements the data
     
     
      
       processing/transformation logic.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       flush
      
     </strong>
     
      : If the transform process emits additional data, the
     
     <strong class="source-inline">
      
       flush
      
     </strong>
     
      method is used to flush the data.
     
     
      This argument
     
     
      
       is optional.
      
     
    </li>
   </ul>
   <p>
    
     It is the
    
    <strong class="source-inline">
     
      transform()
     
    </strong>
    
     function that processes the stream input and produces the output.
    
    
     Note that it is not necessary for the number of chunks that are supplied via the input stream to be equal to the number output by the transform stream – some chunks could be omitted during
    
    
     
      the transformation/processing.
     
    
   </p>
   <p>
    
     Under the hood, the
    
    <strong class="source-inline">
     
      transform()
     
    </strong>
    
     function gets attached to the
    
    <strong class="source-inline">
     
      _transform()
     
    </strong>
    
     method of the transform stream.
    
    
     The
    
    <strong class="source-inline">
     
      _transform()
     
    </strong>
    
     method is an internal method on the
    
    <strong class="source-inline">
     
      Transform
     
    </strong>
    
     class that is not intended to be called directly (hence the
    
    
     
      underscore prefix).
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      _transform()
     
    </strong>
    
     method accepts the following
    
    
     
      three arguments:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       chunk
      
     </strong>
     
      : The data to
     
     
      
       be transformed.
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       encoding
      
     </strong>
     
      : If the input is of the
     
     <strong class="source-inline">
      
       String
      
     </strong>
     
      type, the encoding will be of the
     
     <strong class="source-inline">
      
       String
      
     </strong>
     
      type.
     
     
      If it is of the
     
     <strong class="source-inline">
      
       Buffer
      
     </strong>
     
      type, this value is set
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        buffer
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       callback(err, transformedChunk)
      
     </strong>
     
      : The callback function to be called once the chunk has been processed.
     
     
      The callback function is expected to have two arguments – the first an error and the second the
     
     
      
       transformed chunk.
      
     
    </li>
   </ul>
   <p>
    
     In this recipe, our
    
    <strong class="source-inline">
     
      transform()
     
    </strong>
    
     function called the
    
    <strong class="source-inline">
     
      callback()
     
    </strong>
    
     function with our processed data (where our processed data was
    
    <strong class="source-inline">
     
      chunk.toString().toUpperCase()
     
    </strong>
    
     to convert the input into an
    
    
     
      uppercase string).
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Node.js comes with some built-in transform streams.
    
    
     Both the Node.js core
    
    <strong class="source-inline">
     
      crypto
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      zlib
     
    </strong>
    
     modules expose transform streams.
    
    
     As an example, the
    
    <strong class="source-inline">
     
      zlib.createGzip()
     
    </strong>
    
     method is a transform stream that’s exposed by the
    
    <strong class="source-inline">
     
      zlib
     
    </strong>
    
     module that compresses the file that’s been piped
    
    
     
      to it.
     
    
   </p>
   <h2 id="_idParaDest-93">
    <a id="_idTextAnchor092">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In this section, we’ll learn how
    
    <a id="_idIndexMarker153">
    </a>
    
     to create transform streams in
    
    <strong class="bold">
     
      ECMAScript 6
     
    </strong>
    
     (
    
    <strong class="bold">
     
      ES6
     
    </strong>
    
     ) syntax and
    
    <a id="_idIndexMarker154">
    </a>
    
     how we can create an object mode
    
    
     
      transform stream.
     
    
   </p>
   <h3>
    
     Adopting ES6 syntax
    
   </h3>
   <p>
    
     In this recipe, we implemented a
    
    <a id="_idIndexMarker155">
    </a>
    
     transform stream using the simplified constructor approach.
    
    
     It is also possible to implement these using the
    
    <a id="_idIndexMarker156">
    </a>
    
     ES6 class syntax.
    
    
     The following steps will
    
    
     
      demonstrate this:
     
    
   </p>
   <ol>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        transform-stream-es6.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch transform-stream-es6.js</strong></pre>
    </li>
    <li>
     
      The transform stream from this recipe can be implemented
     
     
      
       as follows:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const { Transform } = require('node:stream');
const rs = fs.createReadStream('./file.txt');
const newFile = fs.createWriteStream('./newFile.txt');
class Uppercase extends Transform {
  _transform (chunk, encoding, callback) {
    this.push(chunk.toString().toUpperCase());
    callback();
  }
}
rs.pipe(new Uppercase()).pipe(newFile);</pre>
     <p class="list-inset">
      
       With this code, it is clearer that we’re overriding the
      
      <strong class="source-inline">
       
        _transform()
       
      </strong>
      
       method with our
      
      
       
        transformation logic.
       
      
     </p>
    </li>
   </ol>
   <p>
    
     This example uses ES6
    
    <a id="_idIndexMarker157">
    </a>
    
     syntax to create a custom transform stream that reads from
    
    <strong class="source-inline">
     
      file.txt
     
    </strong>
    
     , converts the content into uppercase, and writes it to
    
    <strong class="source-inline">
     
      newFile.txt
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      Uppercase
     
    </strong>
    
     class, extending the
    
    <strong class="source-inline">
     
      Transform
     
    </strong>
    
     class, overrides the
    
    <strong class="source-inline">
     
      _transform
     
    </strong>
    
     method to process data chunks, converting them into
    
    <a id="_idIndexMarker158">
    </a>
    
     uppercase with
    
    <strong class="source-inline">
     
      chunk.toString().toUpperCase()
     
    </strong>
    
     before pushing them to the write stream.
    
    
     The callback function,
    
    <strong class="source-inline">
     
      callback()
     
    </strong>
    
     , is invoked to indicate the completion of the current chunk’s processing, allowing the stream to handle the next chunk and maintain a regulated flow
    
    
     
      of data.
     
    
   </p>
   <h3>
    
     Creating object mode transform streams
    
   </h3>
   <p>
    
     By default, Node.js streams operate on
    
    <strong class="source-inline">
     
      String
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Buffer
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      Uint8Array
     
    </strong>
    
     objects.
    
    
     However, it is also possible
    
    <a id="_idIndexMarker159">
    </a>
    
     to work with Node.js streams in
    
    <strong class="bold">
     
      object mode
     
    </strong>
    
     .
    
    
     This allows us to work with other JavaScript values (except the
    
    <strong class="source-inline">
     
      null
     
    </strong>
    
     value).
    
    
     In object mode, the values that are returned
    
    <a id="_idIndexMarker160">
    </a>
    
     from the stream are generic JavaScript objects.
    
    
     An example use case for object mode streaming could be implementing an application that queries a database for a large set of user records and then processes each user
    
    
     
      record individually.
     
    
   </p>
   <p>
    
     The main difference with object mode is that the
    
    <strong class="source-inline">
     
      highWaterMark
     
    </strong>
    
     value refers to the number of objects, rather than bytes.
    
    
     In previous recipes, we learned that the
    
    <strong class="source-inline">
     
      highWaterMark
     
    </strong>
    
     value dictates the maximum number of bytes that are stored in the internal buffer before the stream stops reading the input.
    
    
     For object mode streams, this value is set to
    
    <strong class="source-inline">
     
      16
     
    </strong>
    
     – meaning 16 objects are buffered at
    
    
     
      a time.
     
    
   </p>
   <p>
    
     To set a stream in object mode, we must pass
    
    <strong class="source-inline">
     
      { objectMode: true }
     
    </strong>
    
     via the
    
    
     <strong class="source-inline">
      
       options
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     Let’s demonstrate how to create
    
    <a id="_idIndexMarker161">
    </a>
    
     a transform stream in
    
    
     
      object mode:
     
    
   </p>
   <ol>
    <li>
     
      Let’s create a folder called
     
     <strong class="source-inline">
      
       object-streams
      
     </strong>
     
      containing a file named
     
     <strong class="source-inline">
      
       object-stream.js
      
     </strong>
     
      and initialize the project
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        npm
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir object-streams</strong>
<strong class="bold">$ cd object-streams</strong>
<strong class="bold">$ npm init --yes</strong>
<strong class="bold">$ touch object-stream.js</strong></pre>
    </li>
    <li>
     
      Install the
     
     
      <strong class="source-inline">
       
        ndjson
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install ndjson</strong></pre>
    </li>
    <li>
     
      In
     
     <strong class="source-inline">
      
       object-stream.js
      
     </strong>
     
      , import the
     
     <strong class="source-inline">
      
       Transform
      
     </strong>
     
      class from the Node.js core
     
     
      <strong class="source-inline">
       
        stream
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const { Transform } = require('node:stream');</pre>
    </li>
    <li>
     
      Next, import the
     
     <strong class="source-inline">
      
       stringify()
      
     </strong>
     
      method
     
     <a id="_idIndexMarker162">
     </a>
     
      from the
     
     
      <strong class="source-inline">
       
        ndjson
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const { stringify } = require('ndjson');</pre>
    </li>
    <li>
     
      Create the transform stream, specifying
     
     <strong class="source-inline">
      
       { objectMode:
      
     </strong>
     
      <strong class="source-inline">
       
        true }
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const Name = Transform({
  objectMode: true,
  transform: ({ forename, surname }, encoding,
    callback) =&gt; {
      callback(null, { name: forename + ' ' + surname
    });
  }
});</pre>
    </li>
    <li>
     
      Now, we can create our chain of streams.
     
     
      We will pipe the
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      transform stream to the
     
     <strong class="source-inline">
      
       stringify()
      
     </strong>
     
      method (from
     
     <strong class="source-inline">
      
       ndjson
      
     </strong>
     
      ), and then pipe the result
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        process.stdout
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
Name.pipe(stringify()).pipe(process.stdout);</pre>
    </li>
    <li>
     
      Finally, still in
     
     <strong class="source-inline">
      
       object-stream.js
      
     </strong>
     
      , we’ll write some data to the
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      transform stream
     
     <a id="_idIndexMarker163">
     </a>
     
      using the
     
     
      <strong class="source-inline">
       
        write()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
Name.write({ forename: 'John', surname: 'Doe' });
Name.write({ forename: 'Jane', surname: 'Doe' });</pre>
    </li>
    <li>
     
      Run the program
     
     <a id="_idIndexMarker164">
     </a>
     
      with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node object-stream.js</strong></pre>
     <p class="list-inset">
      
       This will output
      
      
       
        the following:
       
      
     </p>
     <pre class="source-code">{"name":"John Doe"}
{"name":"Jane Doe"}</pre>
    </li>
   </ol>
   <p>
    
     In this example, we created a transform stream called
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     that aggregates the value of two JSON properties (
    
    <strong class="source-inline">
     
      forename
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      surname
     
    </strong>
    
     ) and returns a new property (
    
    <strong class="source-inline">
     
      name
     
    </strong>
    
     ) with the aggregated value.
    
    
     The
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     transform stream is in object mode and both reads and
    
    
     
      writes objects.
     
    
   </p>
   <p>
    
     We pipe our
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     transform stream to the
    
    <strong class="source-inline">
     
      stringify()
     
    </strong>
    
     function provided by the
    
    <strong class="source-inline">
     
      ndjson
     
    </strong>
    
     module.
    
    
     The
    
    <strong class="source-inline">
     
      stringify()
     
    </strong>
    
     function converts the streamed JSON objects into newline-delimited JSON.
    
    
     The
    
    <strong class="source-inline">
     
      stringify()
     
    </strong>
    
     stream is a transform stream where the writable side is in object mode, but the readable
    
    
     
      side isn’t.
     
    
   </p>
   <p>
    
     With transform streams (and
    
    <a id="_idIndexMarker165">
    </a>
    
     duplex streams), you can independently specify whether the readable or writable side of the stream is in object mode by supplying the following
    
    
     
      configuration options:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       readableObjectMode
      
     </strong>
     
      : When
     
     <strong class="source-inline">
      
       true
      
     </strong>
     
      , the readable side of the duplex stream is in
     
     
      
       object mode
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       writableObjectMode
      
     </strong>
     
      : When
     
     <strong class="source-inline">
      
       true
      
     </strong>
     
      , the writable side of the duplex stream is in
     
     
      
       object mode
      
     
    </li>
   </ul>
   <p>
    
     Note that it is also possible to set different
    
    <strong class="source-inline">
     
      highWaterMark
     
    </strong>
    
     values for the readable or writable side of a duplex
    
    <a id="_idIndexMarker166">
    </a>
    
     stream using the following
    
    
     
      configuration options:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       readableHighWaterMark
      
     </strong>
     
      : Configures the
     
     <strong class="source-inline">
      
       highWaterMark
      
     </strong>
     
      value for the readable side of
     
     
      
       the stream
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       writableHighWaterMark
      
     </strong>
     
      : Configures the
     
     <strong class="source-inline">
      
       highWaterMark
      
     </strong>
     
      value for the writable side of
     
     
      
       the stream
      
     
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      readableHighWaterMark
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      writableHighWaterMark
     
    </strong>
    
     configuration values have no effect if a
    
    <strong class="source-inline">
     
      highWaterMark
     
    </strong>
    
     value is supplied because the
    
    <strong class="source-inline">
     
      highWaterMark
     
    </strong>
    
     value
    
    
     
      takes precedence.
     
    
   </p>
   <h3>
    
     Using map and filter functions
    
   </h3>
   <p>
    
     More recent versions of Node.js, later than version 16.4.0, provide
    
    <strong class="bold">
     
      Experimental
     
    </strong>
    
     array-like methods fo
    
    <a id="_idIndexMarker167">
    </a>
    
     r readable streams.
    
    
     These methods can be used similarly to the array methods – for example, the
    
    <strong class="source-inline">
     
      Readable.map()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Readable.filter()
     
    </strong>
    
     methods provide similar functionality to
    
    <strong class="source-inline">
     
      Array.prototype.map()
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       Array.prototype.filter()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      map()
     
    </strong>
    
     method can be used to
    
    <a id="_idIndexMarker168">
    </a>
    
     map over the stream.
    
    
     For every chunk in the stream, the specified function will be called.
    
    
     The
    
    <strong class="bold">
     
      transform stream
     
    </strong>
    
     we created in
    
    <a id="_idIndexMarker169">
    </a>
    
     this recipe could be rewritten using the
    
    <strong class="source-inline">
     
      map()
     
    </strong>
    
     method
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
const fs = require('node:fs');
const rs = fs.createReadStream('./file.txt');
const newFile = fs.createWriteStream('./newFile.txt');
<strong class="bold">rs.map((chunk) =&gt;</strong>
<strong class="bold">  chunk.toString().toUpperCase()).pipe(newFile);</strong></pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Readable.filter()
     
    </strong>
    
     method can be used to filter a
    
    
     
      readable stream:
     
    
   </p>
   <pre class="source-code">
const { Readable } = require('node:stream');
async function* generate() {
    yield 'Java';
    yield 'JavaScript';
    yield 'Rust';
}
// Filter the stream for words with 5 or more characters
Readable.from(generate()).filter((word) =&gt; word.length &gt;=
  5).pipe(process.stdout);</pre>
   <p>
    
     These are two recent
    
    <a id="_idIndexMarker170">
    </a>
    
     function additions that provide array-like methods on readable streams.
    
    
     Many more array-like methods are now available
    
    
     
      on streams:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        drop()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        every()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        filter()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        find()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        flatMap()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        forEach()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        map()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        reduce()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        some()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        take()
       
      </strong>
     
    </li>
    <li>
     <strong class="source-inline">
      
       .
      
     </strong>
     
      <strong class="source-inline">
       
        toArray()
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     More information, including the usage and parameters of these methods, can be found in the Node.js Stream API
    
    <a id="_idIndexMarker171">
    </a>
    
     
      documentation:
     
    
    <a href="https://nodejs.org/docs/latest-v22.x/api/stream.html">
     
      
       https://nodejs.org/docs/latest-v22.x/api/stream.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     At the time of writing, the array-like stream methods are designated with an
    
    
     <strong class="bold">
      
       Experimental
      
     </strong>
    
    
     
      status.
     
    
   </p>
   <h2 id="_idParaDest-94">
    <a id="_idTextAnchor093">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Creating readable and writable streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Piping streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Building stream pipelines
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-95">
    <a id="_idTextAnchor094">
    </a>
    
     Building stream pipelines
    
   </h1>
   <p>
    
     The Node.js core
    
    <strong class="source-inline">
     
      stream
     
    </strong>
    
     module provides a
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method.
    
    
     Similar to how we can use the Node.js core stream
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method to pipe one stream to another, we can also use the
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method to chain multiple
    
    
     
      streams together.
     
    
   </p>
   <p>
    
     Unlike the
    
    <strong class="source-inline">
     
      pipe()
     
    </strong>
    
     method, the
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method also forwards errors, making it easier to handle errors in the
    
    
     
      stream’s flow.
     
    
   </p>
   <p>
    
     This recipe builds upon
    
    <a id="_idIndexMarker172">
    </a>
    
     many of the stream concepts that were covered in the other recipes in this chapter.
    
    
     Here, we’ll create a stream pipeline using the
    
    
     <strong class="source-inline">
      
       pipeline()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <h2 id="_idParaDest-96">
    <a id="_idTextAnchor095">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before diving into this recipe, let’s set up our workspace by creating a directory
    
    
     
      and files:
     
    
   </p>
   <ol>
    <li>
     
      First, create a directory to work in
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        stream-pipelines
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir stream-pipelines</strong>
<strong class="bold">$ cd stream-pipelines</strong></pre>
    </li>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        pipeline.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch pipeline.js</strong></pre>
    </li>
    <li>
     
      We’ll also need
     
     <a id="_idIndexMarker173">
     </a>
     
      some sample data to transform.
     
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        file.txt
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch file.txt</strong></pre>
    </li>
    <li>
     
      Add some dummy text data to the
     
     
      <strong class="source-inline">
       
        file.txt
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.
Node.js is a JavaScript runtime built on Google Chrome's V8 JavaScript engine.</pre>
    </li>
   </ol>
   <p>
    
     Now, we’re ready to start
    
    
     
      this recipe.
     
    
   </p>
   <h2 id="_idParaDest-97">
    <a id="_idTextAnchor096">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’ll create a stream pipeline using the
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method.
    
    
     Our pipeline will read the
    
    <strong class="source-inline">
     
      file.txt
     
    </strong>
    
     file, convert the file’s contents into uppercase using a transform stream, and then write the new contents to a
    
    
     
      new file:
     
    
   </p>
   <ol>
    <li>
     
      Start by importing the Node.js core
     
     <strong class="source-inline">
      
       fs
      
     </strong>
     
      module
     
     
      
       into
      
     
     
      <strong class="source-inline">
       
        pipeline.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const fs = require('node:fs');</pre>
    </li>
    <li>
     
      Next, we need to import the
     
     <strong class="source-inline">
      
       pipeline()
      
     </strong>
     
      method and the
     
     <strong class="source-inline">
      
       Transform
      
     </strong>
     
      class from the Node.js core
     
     
      <strong class="source-inline">
       
        stream
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const { pipeline, Transform } = require('node:stream');</pre>
    </li>
    <li>
     
      Next, we’ll create our transform stream (refer to the
     
     <em class="italic">
      
       Creating transform streams
      
     </em>
     
      recipe in this chapter for more information on transform streams).
     
     
      This will convert the input into
     
     <a id="_idIndexMarker174">
     </a>
     
      
       uppercase strings:
      
     
     <pre class="source-code">
const uppercase = new Transform({
  transform (chunk, encoding, callback) {
    // Data processing
    callback(null, chunk.toString().toUpperCase());
  }
});</pre>
    </li>
    <li>
     
      Now, we can start to create the stream pipeline.
     
     
      First, let’s call the
     
     
      <strong class="source-inline">
       
        pipeline()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
pipeline();</pre>
    </li>
    <li>
     
      The
     
     <strong class="source-inline">
      
       pipeline()
      
     </strong>
     
      method expects the first argument to be a readable stream.
     
     
      Our first argument will be a readable stream that will read the
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      file, using the
     
     
      <strong class="source-inline">
       
        createReadStream()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
pipeline(
<strong class="bold">  fs.createReadStream('./file.txt')</strong>
);</pre>
    </li>
    <li>
     
      Next, we need to add our transform stream as the second argument to the
     
     
      <strong class="source-inline">
       
        pipeline()
       
      </strong>
     
     
      
       method:
      
     
     <pre class="source-code">
pipeline(
  fs.createReadStream('./file.txt'),
<strong class="bold">  uppercase,</strong>
);</pre>
    </li>
    <li>
     
      Then, we can add our writable stream to write the
     
     <strong class="source-inline">
      
       newFile.txt
      
     </strong>
     
      file to
     
     
      
       the pipeline:
      
     
     <pre class="source-code">
pipeline(
  fs.createReadStream('./file.txt'),
  uppercase,
<strong class="bold">  fs.createWriteStream('./newFile.txt'),</strong>
);</pre>
    </li>
    <li>
     
      Finally, the last argument to our pipeline is a callback function that will execute once the pipeline has
     
     <a id="_idIndexMarker175">
     </a>
     
      finished running.
     
     
      This callback function will handle any errors in
     
     
      
       our pipeline:
      
     
     <pre class="source-code">
pipeline(
  fs.createReadStream('./file.txt'),
  uppercase,
  fs.createWriteStream('./newFile.txt'),
  <strong class="bold">(err) =&gt; {</strong>
<strong class="bold">    if (err) {</strong>
<strong class="bold">      console.error('Pipeline failed.', err);</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">      console.log('Pipeline succeeded.');</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong>
);</pre>
    </li>
    <li>
     
      In your terminal, run the program with the following command.
     
     
      You should expect to see a message stating
     
     
      <strong class="bold">
       
        Pipeline succeeded.
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ node pipeline.js</strong>
Pipeline succeeded.</pre>
    </li>
    <li>
     
      To confirm that the stream pipeline was successful, verify that the
     
     <strong class="source-inline">
      
       newFile.txt
      
     </strong>
     
      file
     
     <a id="_idIndexMarker176">
     </a>
     
      contains the contents of
     
     <strong class="source-inline">
      
       file.txt
      
     </strong>
     
      , but
     
     
      
       in uppercase:
      
     
     <pre class="source-code">
<strong class="bold">$ cat newFile.txt</strong>
NODE.JS IS A JAVASCRIPT RUNTIME BUILT ON GOOGLE CHROME'S V8 JAVASCRIPT ENGINE.
NODE.JS IS A JAVASCRIPT RUNTIME BUILT ON GOOGLE CHROME'S V8 JAVASCRIPT ENGINE.
NODE.JS IS A JAVASCRIPT RUNTIME BUILT ON GOOGLE CHROME'S V8 JAVASCRIPT ENGINE.</pre>
    </li>
   </ol>
   <p>
    
     With that, we’ve created a stream pipeline using the
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method that’s exposed by the Node.js core
    
    
     <strong class="source-inline">
      
       stream
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <h2 id="_idParaDest-98">
    <a id="_idTextAnchor097">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method allows us to pipe streams to one another – forming a flow
    
    
     
      of streams.
     
    
   </p>
   <p>
    
     We can pass the following arguments to the stream’s
    
    
     <strong class="source-inline">
      
       pipeline()
      
     </strong>
    
    
     
      method:
     
    
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      
       source
      
     </strong>
     
      : A source stream from which to
     
     
      
       read data
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       ...transforms
      
     </strong>
     
      : Any number of transform streams to process data (
     
     
      
       including
      
     
     
      <strong class="source-inline">
       
        0
       
      </strong>
     
     
      
       )
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       destination
      
     </strong>
     
      : A destination stream to write the processed
     
     
      
       data to
      
     
    </li>
    <li>
     <strong class="source-inline">
      
       callback
      
     </strong>
     
      : The function to be called when the pipeline
     
     
      
       is complete
      
     
    </li>
   </ul>
   <p>
    
     We pass the
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method to our series of streams, in the order they need to run, followed by using a callback function that executes once the pipeline
    
    
     
      is complete.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method elegantly forwards errors that occur in the streams onto the callback.
    
    
     This is one of the benefits of using the
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method over the
    
    
     <strong class="source-inline">
      
       pipe()
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method also cleans up any unterminated streams by
    
    
     
      calling
     
    
    
     <strong class="source-inline">
      
       stream.destroy()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-99">
    <a id="_idTextAnchor098">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In Node.js version 15 and later, there
    
    <a id="_idIndexMarker177">
    </a>
    
     is a suite of asynchronous utility functions for streams that utilize
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     objects instead of callbacks.
    
    
     These functions can be found in the
    
    <strong class="source-inline">
     
      stream/promises
     
    </strong>
    
     core module.
    
    
     This module includes versions of
    
    <strong class="source-inline">
     
      stream.pipeline()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      stream.finished()
     
    </strong>
    
     that are compatible with promises, providing a more modern and promise-friendly approach to
    
    
     
      stream handling.
     
    
   </p>
   <p>
    
     Let’s convert the stream pipeline from the main recipe so that it uses the
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     version
    
    
     
      of
     
    
    
     <strong class="source-inline">
      
       stream.pipeline()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <ol>
    <li>
     
      Create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        promise-pipeline.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch promise-pipeline.js</strong></pre>
    </li>
    <li>
     
      Add the following to import the Node.js core
     
     <strong class="source-inline">
      
       fs
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        stream/promises
       
      </strong>
     
     
      
       modules:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const { Transform } = require('node:stream');
const { pipeline } = require('node:stream/promises');</pre>
    </li>
    <li>
     
      Add the
     
     
      
       transform stream:
      
     
     <pre class="source-code">
const uppercase = new Transform({
  transform(chunk, encoding, callback) {
    // Data processing
    callback(null, chunk.toString().toUpperCase());
  },
});</pre>
    </li>
    <li>
     
      Since we’ll be awaiting
     
     <strong class="source-inline">
      
       pipeline()
      
     </strong>
     
      , we’ll need to wrap the
     
     <strong class="source-inline">
      
       pipeline()
      
     </strong>
     
      logic in an
     
     
      
       asynchronous function:
      
     
     <pre class="source-code">
async function run() {
  await pipeline(
    fs.createReadStream('./file.txt'),
    uppercase,
    fs.createWriteStream('./newFile.txt')
  );
  console.log('Pipeline succeeded.');
}</pre>
    </li>
    <li>
     
      Finally, we can call our
     
     <strong class="source-inline">
      
       run()
      
     </strong>
     
      function, catching
     
     
      
       any errors:
      
     
     <pre class="source-code">
run().catch((err) =&gt; {
  console.error('Pipeline failed.', err);
});</pre>
    </li>
    <li>
     
      Run the program by
     
     <a id="_idIndexMarker178">
     </a>
     
      using the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node promise-pipeline.js</strong>
Pipeline Succeeded.</pre>
    </li>
   </ol>
   <p>
    
     With that, we’ve demonstrated how to use the stream
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method with Promises by using the Streams
    
    
     
      Promises API.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Previously, the
    
    <strong class="source-inline">
     
      pipeline()
     
    </strong>
    
     method may have been converted into
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     form using the
    
    <strong class="source-inline">
     
      util.promisify()
     
    </strong>
    
     utility method.
    
    
     The
    
    <strong class="source-inline">
     
      util.promisify()
     
    </strong>
    
     method is used to convert a callback-style method
    
    <a id="_idIndexMarker179">
    </a>
    
     into
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     form.
    
    
     The Streams Promises API replaces the need to
    
    
     
      use this.
     
    
   </p>
   <h2 id="_idParaDest-100">
    <a id="_idTextAnchor099">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Creating readable and writable streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Piping streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Creating transform streams
      
     </em>
     
      recipe of
     
     
      
       this chapter
      
     
    </li>
   </ul>
  </div>
 </body></html>