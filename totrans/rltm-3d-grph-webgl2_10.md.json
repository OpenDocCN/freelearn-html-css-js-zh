["```js\nconst { width, height } = canvas;\n\n// 1\\. Init Color Texture\nconst texture = gl.createTexture();\ngl.bindTexture(gl.TEXTURE_2D, texture);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\ngl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\ngl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n// 2\\. Init Renderbuffer\nconst renderbuffer = gl.createRenderbuffer();\ngl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\ngl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, width, height);\n\n// 3\\. Init Framebuffer\nconst framebuffer = gl.createFramebuffer();\ngl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\ngl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\ngl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n// 4\\. Clean up\ngl.bindTexture(gl.TEXTURE_2D, null);\ngl.bindRenderbuffer(gl.RENDERBUFFER, null);\ngl.bindFramebuffer(gl.FRAMEBUFFER, null);\n```", "```js\n// 1\\. Define the geometry for the full-screen quad\nconst vertices = [\n  -1, -1,\n   1, -1,\n  -1,  1,\n\n  -1,  1,\n   1, -1,\n   1,  1\n];\n\nconst textureCoords = [\n  0, 0,\n  1, 0,\n  0, 1,\n\n  0, 1,\n  1, 0,\n  1, 1\n];\n\n// 2\\. Create and bind VAO\nconst vao = gl.createVertexArray();\ngl.bindVertexArray(vao);\n\n// 3\\. Init the buffers\nconst vertexBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), \n// Configure instructions for VAO\ngl.STATIC_DRAW);gl.enableVertexAttribArray(program.aVertexPosition);\ngl.vertexAttribPointer(program.aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n\nconst textureBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);\n// Configure instructions for VAO\ngl.enableVertexAttribArray(program.aVertexTextureCoords);\ngl.vertexAttribPointer(program.aVertexTextureCoords, 2, gl.FLOAT, false, 0, 0);\n\n// 4\\. Clean up\ngl.bindVertexArray(null);\ngl.bindBuffer(gl.ARRAY_BUFFER, null);\n```", "```js\n#version 300 es\nprecision mediump float;\n\nin vec2 aVertexPosition;\nin vec2 aVertexTextureCoords;\n\nout vec2 vTextureCoords;\n\nvoid main(void) {\n  vTextureCoords = aVertexTextureCoords;\n  gl_Position = vec4(aVertexPosition, 0.0, 1.0);\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform sampler2D uSampler;\n\nin vec2 vTextureCoords;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec4 frameColor = texture(uSampler, vTextureCoords);\n  float luminance = frameColor.r * 0.3 + frameColor.g * 0.59 + frameColor.b \n   * 0.11;\n  fragColor = vec4(luminance, luminance, luminance, frameColor.a);\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform sampler2D uSampler;\n\nin vec2 vTextureCoords;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec4 frameColor = texture(uSampler, vTextureCoords);\n  fragColor = vec4(vec3(1.0) - frameColor.rgb, frameColor.a);\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nconst float speed = 15.0;\nconst float magnitude = 0.015;\n\nuniform sampler2D uSampler;\nuniform float uTime;\n\nin vec2 vTextureCoords;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec2 wavyCoord;\n  wavyCoord.s = vTextureCoords.s + sin(uTime + vTextureCoords.t * \n   speed) * magnitude;\n  wavyCoord.t = vTextureCoords.t + cos(uTime + vTextureCoords.s * \n   speed) * magnitude;\n  fragColor = texture(uSampler, wavyCoord);\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform sampler2D uSampler;\nuniform vec2 uInverseTextureSize;\n\nin vec2 vTextureCoords;\n\nout vec4 fragColor;\n\nvec4 offsetLookup(float xOff, float yOff) {\n  return texture(\n    uSampler, \n    vec2(\n      vTextureCoords.x + xOff * uInverseTextureSize.x, \n      vTextureCoords.y + yOff * uInverseTextureSize.y\n    )\n  );\n}\n\nvoid main(void) {\n  vec4 frameColor = offsetLookup(-4.0, 0.0) * 0.05;\n  frameColor += offsetLookup(-3.0, 0.0) * 0.09;\n  frameColor += offsetLookup(-2.0, 0.0) * 0.12;\n  frameColor += offsetLookup(-1.0, 0.0) * 0.15;\n  frameColor += offsetLookup(0.0, 0.0) * 0.16;\n  frameColor += offsetLookup(1.0, 0.0) * 0.15;\n  frameColor += offsetLookup(2.0, 0.0) * 0.12;\n  frameColor += offsetLookup(3.0, 0.0) * 0.09;\n  frameColor += offsetLookup(4.0, 0.0) * 0.05;\n  fragColor = frameColor;\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nconst float grainIntensity = 0.1;\nconst float scrollSpeed = 4000.0;\n\nuniform sampler2D uSampler;\nuniform sampler2D uNoiseSampler;\nuniform vec2 uInverseTextureSize;\nuniform float uTime;\n\nin vec2 vTextureCoords;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec4 frameColor = texture(uSampler, vTextureCoords);\n  vec4 grain = texture(\n    uNoiseSampler,\n    vTextureCoords * 2.0 + uTime * scrollSpeed * \n     uInverseTextureSize\n  );\n  fragColor = frameColor - (grain * grainIntensity);\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform float uPointSize;\n\nin vec4 aParticle;\n\nout float vLifespan;\n\nvoid main(void) {\n  gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aParticle.xyz, \n   1.0);\n  vLifespan = aParticle.w;\n  gl_PointSize = uPointSize * vLifespan;\n}\n```", "```js\n#version 300 es\nprecision mediump float;\n\nuniform sampler2D uSampler;\n\nin float vLifespan;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  vec4 texColor = texture(uSampler, gl_PointCoord);\n  fragColor = vec4(texColor.rgb, texColor.a * vLifespan);\n}\n```", "```js\ngl.drawArrays(gl.POINTS, 0, vertexCount);\n```", "```js\nfunction resetParticle(particle) {\n  particle.position = [0, 0, 0];\n\n  particle.velocity = [\n    Math.random() * 20 - 10,\n    Math.random() * 20,\n    Math.random() * 20 - 10,\n  ];\n\n  particle.lifespan = Math.random() * particleLifespan;\n  particle.remainingLife = particle.lifespan;\n}\n```", "```js\nfunction updateParticles(elapsed) {\n  // Loop through all the particles in the array\n  particles.forEach((particle, i) => {\n    // Track the particles lifespan\n    particle.remainingLife -= elapsed;\n\n    if (particle.remainingLife <= 0) {\n      // Once the particle expires, reset it to the origin with a \n      // new velocity\n      resetParticle(particle);\n    }\n\n    // Update the particle position\n    particle.position[0] += particle.velocity[0] * elapsed;\n    particle.position[1] += particle.velocity[1] * elapsed;\n    particle.position[2] += particle.velocity[2] * elapsed;\n\n    // Apply gravity to the velocity\n    particle.velocity[1] -= 9.8 * elapsed;\n\n    if (particle.position[1] < 0) {\n      // Allow particles to bounce off the floor\n      particle.velocity[1] *= -0.75;\n      particle.position[1] = 0;\n    }\n\n    // Update the corresponding values in the array\n    const index = i * 4;\n    particleArray[index] = particle.position[0];\n    particleArray[index + 1] = particle.position[1];\n    particleArray[index + 2] = particle.position[2];\n    particleArray[index + 3] = particle.remainingLife / \n     particle.lifespan;\n  });\n\n  // Once we are done looping through all the particles, update the \n  // buffer once\n  gl.bindBuffer(gl.ARRAY_BUFFER, particleBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, particleArray, gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, null);\n}\n```", "```js\nconst tangentBufferObject = gl.createBuffer();\n\ngl.bindBuffer(gl.ARRAY_BUFFER, tangentBufferObject);\n\ngl.bufferData(\n  gl.ARRAY_BUFFER,\n  new Float32Array(utils.calculateTangents(\n    object.vertices,\n    object.textureCoords,\n    object.indices\n  )),\n  gl.STATIC_DRAW\n);\n```", "```js\n// Transformed normal position\nvec3 normal = vec3(uNormalMatrix * vec4(aVertexNormal, 1.0));\nvec3 tangent = vec3(uNormalMatrix * vec4(aVertexTangent, 1.0));\nvec3 bitangent = cross(normal, tangent);\n```", "```js\nmat3 tbnMatrix = mat3(\n  tangent.x, bitangent.x, normal.x,\n  tangent.y, bitangent.y, normal.y,\n  tangent.z, bitangent.z, normal.z\n);\n```", "```js\n// Light direction, from light position to vertex\nvec3 lightDirection = uLightPosition - vertex.xyz;\n\nvTangentEyeDir = eyeDirection * tbnMatrix;\n```", "```js\n// Unpack tangent-space normal from texture\nvec3 normal = normalize(2.0 * (texture(uNormalSampler, vTextureCoords).rgb - 0.5));\n```", "```js\n// Normalize the light direction and determine how much light is hitting this point\nvec3 lightDirection = normalize(vTangentLightDir);\nfloat lambertTerm = max(dot(normal, lightDirection), 0.20);\n\n// Calculate Specular level\nvec3 eyeDirection = normalize(vTangentEyeDir);\nvec3 reflectDir = reflect(-lightDirection, normal);\nfloat Is = pow(clamp(dot(reflectDir, eyeDirection), 0.0, 1.0), 8.0);\n\n// Combine lighting and material colors\nvec4 Ia = uLightAmbient * uMaterialAmbient;\nvec4 Id = uLightDiffuse * uMaterialDiffuse * texture(uSampler, vTextureCoords) * lambertTerm;\n\nfragColor = Ia + Id + Is;\n```", "```js\nfunction draw() {\n  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n  // Checks to see if the framebuffer needs to be re-sized to match\n  // the canvas\n  post.validateSize();\n  post.bind();\n\n  // Render the fullscreen quad\n  post.draw();\n}\n```", "```js\n// ro is the ray origin.\n// rd is the ray direction.\n// s is the sphere\nfloat sphereIntersection(vec3 ro, vec3 rd, vec4 s) {\n  // Transform the ray into object space\n  vec3 oro = ro - s.xyz;\n\n  float a = dot(rd, rd);\n  float b = 2.0 * dot(oro, rd);\n  // w is the sphere radius\n  float c = dot(oro, oro) - s.w * s.w;\n\n  float d = b * b - 4.0 * a * c;\n\n  // No intersection\n  if (d < 0.0) return d;\n\n  return (-b - sqrt(d)) / 2.0;\n}\n\nvec3 sphereNormaml(vec3 pt, vec4 s) {\n  return (pt - s.xyz) / s.w;\n}\n```", "```js\nvec4 sphere = vec4(1.0);\nvec3 sphereColor = vec3(0.9, 0.8, 0.6);\nfloat maxDistance = 1024.0;\n\nfloat intersect(vec3 ro, vec3 rd, out vec3 norm, out vec3 color) {\n  float distance = maxDistance;\n\n  // If we wanted multiple objects in the scene you would loop \n  // through them here and return the normal and color with the\n  // closest intersection point (lowest distance).\n\n float intersectionDistance = sphereIntersection(ro, rd, sphere);\n\n  if (intersectionDistance > 0.0 && intersectionDistance < \n   distance) {\n    distance = intersectionDistance;\n    // Point of intersection\n    vec3 pt = ro + distance * rd;\n    // Get normal for that point\n    norm = sphereNormaml(pt, sphere);\n    // Get color for the sphere\n    color = sphereColor;\n  }\n\n  return distance;\n}\n```", "```js\n// Pixel coordinate of the fragment being rendered\nvec2 uv = gl_FragCoord.xy * uInverseTextureSize;\nfloat aspectRatio = uInverseTextureSize.y / uInverseTextureSize.x;\n\n// Cast a ray out from the eye position into the scene\nvec3 ro = eyePos;\n\n// The ray we cast is tilted slightly downward to give a better\n// view of the scene\nvec3 rd = normalize(vec3(-0.5 + uv * vec2(aspectRatio, 1.0), -1.0));\n```", "```js\n// Default color if we don't intersect with anything\nvec3 rayColor = backgroundColor;\n\n// See if the ray intersects with any objects.\n// Provides the normal of the nearest intersection point and color\nvec3 objectNormal, objectColor;\nfloat t = intersect(ro, rd, objectNormal, objectColor);\n\nif (t < maxDistance) {\n  // Diffuse factor\n  float diffuse = clamp(dot(objectNormal, lightDirection), 0.0,\n   1.0);\n  rayColor = objectColor * diffuse + ambient;\n}\n\nfragColor = vec4(rayColor, 1.0);\n```", "```js\n// Wiggle the sphere back and forth a bit\nsphere.x = 1.5 * sin(uTime);\nsphere.z = 0.5 * cos(uTime * 3.0);\n```"]