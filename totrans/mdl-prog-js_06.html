<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Cloning, Inheritance, and Submodules</h1></div></div></div><p>In the previous chapter, we looked at how we can extend and modify modules using loose and tight augmentation.</p><p>In this chapter, we are going to explore some other techniques that may come handy when we are working with modules, which can help us extend and modify the functionality of our modules. Depending on the requirements of your applications, as well as your personal preferences, some or all of these techniques may be of use to you.</p><p>The beginning of the chapter will provide an overview of some of the approaches for creating object based on other objects which you may already be familiar with. Then, we will look at how object cloning can be used to create objects that are replicas of other objects.</p><p>We will also create another one of the core modules for our application, which will be utilized to clone objects as needed.</p><p>In this chapter we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Module cloning and when to use it</li><li class="listitem" style="list-style-type: disc">Different methods for cloning objects</li><li class="listitem" style="list-style-type: disc">Using inheritance to extend modules</li><li class="listitem" style="list-style-type: disc">Adding functionality to already created modules using submodules</li><li class="listitem" style="list-style-type: disc">Internal private state and how it is affected when extending modules</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Cloning modules</h1></div></div></div><p>Cloning objects in <a id="id237" class="indexterm"/>general, and cloning modules in particular, is about creating an exact replica of the original object or module.</p><p>But before we talk about cloning, let's consider some of the ways that we can create new objects based on other objects.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec35"/>Creating instances of a constructor function</h2></div></div></div><p>One way of creating objects based on another object is by creating instances of a constructor function.</p><p>As you know, when<a id="id238" class="indexterm"/> we create an instance of an object using a constructor function in JavaScript, we use the <code class="literal">new</code> keyword. The created instance resides in a different memory address than the constructor function. When we assign properties to the <code class="literal">prototype</code> property of the constructor function, all the instances of the constructor function will share these properties of the <code class="literal">prototype</code> object.</p><p>Let's have a look at a simple example and review creating objects based on constructor functions.</p><p>Consider the following code snippet:</p><div><pre class="programlisting">function testConstructor (){

    this.someValue = "Value in the constructor function";

}

testConstructor.prototype.testFunc = function(){
    
    console.log(this.someValue);
};</pre></div><p>As you can see, we have added a property to the <code class="literal">prototype</code> object of our constructor function, which logs the value of the <code class="literal">this.someValue</code> property to the console.</p><p>Now, we create two instances of our constructor function as follows:</p><div><pre class="programlisting">var firstInstance = new testConstructor();
var secondInstance = new testConstructor();</pre></div><p>Next, we run the following code in the console:</p><div><pre class="programlisting">// displays "Value in the constructor function"
console.log(firstInstance.someValue);
// displays "Value in the constructor function"
console.log(secondInstance.someValue);</pre></div><p>We can see that the same value for <code class="literal">someValue</code> property will be displayed for both of the instances. Of course, if we change the value of <code class="literal">someValue</code> property for each instance as follows:</p><div><pre class="programlisting">firstInstance.someValue = "value for the firstInstance";
secondInstance.someValue = "value for the secondInstance";</pre></div><p>And log the values of the properties:</p><div><pre class="programlisting">// displays "Value for the firstInstance"
firstInstance.testFunc();

// displays "Value for the secondInstance"
secondInstance.testFunc();</pre></div><p>The value of <code class="literal">someValue</code> property for each instance will be different. Here, each instance has its own copy of <code class="literal">someValue</code> property, but they both share the same method, (<code class="literal">testFunc</code>) since all the properties that are residing on the <code class="literal">prototype</code> object are shared among all the instances of the constructor function.</p><p>There is also <a id="id239" class="indexterm"/>one more thing that we should keep in mind. After creating instances of the constructor function, if we add new properties to the constructor function, the instances will not have access to these new properties.</p><p>Consider the following code:</p><div><pre class="programlisting">testConstructor.newProperty = "this is a new property but not shared";

// displays undefined
console.log(firstInstance.newProperty);

// displays undefined
console.log(secondInstance.newProperty);</pre></div><p>As you see, none of the instances have access to this new property which was added to the constructor function <strong>after</strong> the instances were created.</p><p>If you are thinking that alternatively, we could have defined properties defined on the <code class="literal">prototype</code> object directly on the constructor function itself (<code class="literal">testFunc</code> in our example), you are correct but with a caveat!</p><p>Doing so would mean that every time we make an instance of the object, we would be making unnecessary copies of the properties, which are identical for all the instances of the object. Thus, we would be creating an unnecessary overhead for our code.</p><p>It is a good practice that, when we have properties which are identical for all the instances of constructor function (in most cases, this applies to methods), they should be defined on the <code class="literal">prototype</code> object and be shared among all the instances. We did this in our example by adding <code class="literal">testFunc</code> method to the <code class="literal">prototype</code> object instead of defining it on the constructor function itself.</p><p>When it comes to constructor functions and creating other objects (instances) based on these objects, there is one other thing that we need to consider. What happens to private properties in the constructor function?</p><p>Let's consider the following code snippet:</p><div><pre class="programlisting">function testConstructor (){
    this.someValue = "Value in the constructor function";
    var privateValue = "no instances will have a copy of me";
}</pre></div><p>The private variable <code class="literal">privateValue</code> will not be copied to the instances of the object and will not be shared.</p><p>We can test this as follows:</p><div><pre class="programlisting">var firstInstance = new testConstructor();
// displays undefined.
console.log(firstInstance.privateValue);</pre></div><p>So how can we access these private properties from an object which is created based on this object?</p><p>We'll talk about how <a id="id240" class="indexterm"/>we can provide access to such private members when we talk about cloning modules.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec36"/>Using the assignment operator for copying objects</h2></div></div></div><p>When we are using <a id="id241" class="indexterm"/>primitive types in JavaScript, we can easily use the assignment operator to copy the value of one variable to another, as shown:</p><div><pre class="programlisting">var testVar1 = "This is to be copied";
var testVar2 = testVar1;</pre></div><p>In the preceding code we are simply assigning the sting value of one variable to another variable, and there is no mystery here, but how would that work for two objects? </p><p>Let's put that to the test as follows:</p><div><pre class="programlisting">var testObj1 = { testValue : 5};
var testObj2 = testObj1;

testObj1.newValue  = "this is a new value";

// displays "this is a new value"
console.log(testObj2.newValue);</pre></div><p>Here, we are assigning <code class="literal">testObj1</code> to <code class="literal">testObj2</code> using the assignment operator, which might appear as creating a new object based on another object.</p><p>However, as you can see, when we create a new property for <code class="literal">testObj1</code>, even after the assignment of <code class="literal">testObj1</code> to <code class="literal">testObj2</code> has taken place, the new property is available to <code class="literal">testObj2</code> as well.</p><p>The reason is that when we use the assignment operator to assign the value of a variable which holds a reference to an object to another variable, we are in fact assigning the memory address of the object to another variable. This results in both variables referencing the same object. So, in the code above, both <code class="literal">testObj1</code> and <code class="literal">testObj2</code> are referencing the same object.</p><p>While this result might be desirable at times, there are occasions when we need to create an object that is an<a id="id242" class="indexterm"/> exact copy (replica) of another object, but we want the new object to be a completely independent object from the original one. So how do we do that?</p><p>One way to achieve that is to create a clone of the original object.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec37"/>Creating a clone of an object</h2></div></div></div><p>When we create a clone of an object, our objective is to create an exact replica of the original object, without the newly created object having any ties to the original object.</p><p>Cloning objects in<a id="id243" class="indexterm"/> JavaScript (as with some other languages) is not as straightforward as you might think. While there are different ways of implementing cloning, each approach has its own pros and cons.</p><p>If we consider cloning<a id="id244" class="indexterm"/> as copying all the properties of an object to another object, we can categorize cloning into two types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Shallow cloning</li><li class="listitem" style="list-style-type: disc">Deep cloning</li></ul></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec18"/>Shallow cloning and deep cloning</h3></div></div></div><p>
<strong>Shallow cloning</strong> copies all the top-level properties of the original object, but if this object contains other reference<a id="id245" class="indexterm"/> types, only the <em>references</em> of these reference types are copied to the newly created clone, as opposed to the actual reference types. This type of cloning is used when we want to have separate copies of the primitive types in the<a id="id246" class="indexterm"/> new object but we want the original object, and the newly cloned object, to share the same reference types.</p><p>
<strong>Deep Cloning</strong> on the<a id="id247" class="indexterm"/> other hand, copies all the primitive type properties of the original object into the new object as well as making new copies of all the reference types of the original object in the new object. </p><p>The important distinction is that true<a id="id248" class="indexterm"/> copies of the reference types are created in the new object and not just the references (the memory addresses) of the reference types. This type of cloning is desirable if we want to have two distinct objects with no ties between them of any kind. Deep cloning is generally considered slower than shallow cloning and consumes more resources.</p><p>To implement either of the cloning types, we can leverage one of the following approaches:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use a third-party<a id="id249" class="indexterm"/> library such as jQuery or lodash</li><li class="listitem" style="list-style-type: disc">Use the JSON exploit hack</li><li class="listitem" style="list-style-type: disc">Create our own custom clone method</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec19"/>Using external libraries for cloning</h3></div></div></div><p>
<strong>jQuery</strong><a id="id250" class="indexterm"/> provides the <code class="literal">extend</code> method which enables us to create<a id="id251" class="indexterm"/> both shallow and deep cloning of objects.</p><p>The general format for the <code class="literal">extend</code> method is as follows:</p><div><pre class="programlisting">jQuery.extend( target [, object1 ] [, objectN ] );</pre></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>While this approach is generally a good option for cloning objects, it does have some limitations, such as when dealing with built-in JavaScript types. For complete information regarding this<a id="id252" class="indexterm"/> method, please refer to the jQuery documentation at the following URL:</p><p>
<a class="ulink" href="http://api.jquery.com/jQuery.extend/">http://api.jquery.com/jQuery.extend/</a>
</p></div></div><p>Another good library that can be used for cloning of objects is<a id="id253" class="indexterm"/> <strong>lodash</strong>, which also provides functionality for both shallow and deep cloning. The cloning functionality that lodash provides seems to be ideal for most cases.</p><p>The general format for creating deep clones of an object in lodash is:</p><div><pre class="programlisting">var deep = _.cloneDeep(objects);</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>There are however some<a id="id254" class="indexterm"/> limitations when using lodash for deep cloning, such as dealing with maps and sets. Please refer to the loadash documentation online at:</p><p>
<a class="ulink" href="https://lodash.com/docs#cloneDeep">https://lodash.com/docs#cloneDeep</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec20"/>Using JSON exploit for cloning</h3></div></div></div><p>A simple but effective<a id="id255" class="indexterm"/> way of cloning objects is to use a technique (hack) known as JSON exploit.</p><p>The idea is to stringify the original object and then parse the string into a new object, using JSON methods. This is shown as follows:</p><div><pre class="programlisting">var cloneObj = (JSON.parse(JSON.stringify(originalObj)));</pre></div><div><div><h3 class="title"><a id="note18"/>Note</h3><p>This approach is simple to use, however it has limited capabilities, especially when it comes to copying function properties.</p><p>To view a good<a id="id256" class="indexterm"/> discussion on using this<a id="id257" class="indexterm"/> technique, please refer to the following URL:</p><p>
<a class="ulink" href="https://esdiscuss.org/topic/deep-cloning-objects-defined-by-json">https://esdiscuss.org/topic/deep-cloning-objects-defined-by-json</a>
</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec21"/>Creating a custom clone method</h3></div></div></div><p>When it comes to<a id="id258" class="indexterm"/> relatively simple cloning of objects, we can create our own custom cloning method. This method satisfies most of our needs, most of the time.</p><p>Consider the following:</p><div><pre class="programlisting">function clone(deep) {
    var newClonedObj = new this.constructor();
    for (var property in this){
        if (!deep){
            newClonedObj[property] = this[property];
        }else if (typeof this[property] == 'object'){
            newClonedObj[property] = this[property].clone(deep);
        }else{
            newClonedObj[property] = this[property];
        }
    }
    return newClonedObj;
}</pre></div><p>This function takes a Boolean parameter to perform either a shallow clone or a deep clone of an object.</p><p>When a deep clone is required, a recursive call to the function is made to copy the properties of an object property (a reference type) of the original object. Notice the following snippet in the cloning function:</p><div><pre class="programlisting">else if (typeof this[property] == 'object'){
      newClonedObj[property] = this[property].clone(deep);
}</pre></div><p>Of course, as with the approaches discussed previously, this approach also has its own limitations, for instance, when dealing with closures. However, it does a pretty good job in most cases.</p><p>In the next section, we will be adding this function to one of our application's core modules so it can be <a id="id259" class="indexterm"/>used in our application, when needed.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Creating ImagesInc_Utilites module</h1></div></div></div><p>Since a utilities <a id="id260" class="indexterm"/>module is a good place to implement our <a id="id261" class="indexterm"/>object cloning code, let's create our <code class="literal">ImagesInc_Utilites</code> module as follows:</p><div><pre class="programlisting">var ImagesInc_Utilitizes = (function(){
 
    var clone = function clone(deep) {
        
        // create an instance of the object
        var newClonedObj = new this.constructor();
    
        //copy all properties from the original object
        for (var property in this){
            // if deep flag is not set, just do a shallow copy of properties
            if (!deep){ 
                if(this.hasOwnProperty(property)){
                    newClonedObj[property] = this[property];
                }
            // to make a deep copy, call the function recursively
            }else if (typeof this[property] == 'object' &amp;&amp; this.hasOwnProperty(property)){
                newClonedObj[property] = this[property].clone(deep);
            }else if(this.hasOwnProperty(property)){
                //Just copy properties for non objects
                newClonedObj[property] = this[property];
            }
        }

        return newClonedObj;
    };
    
    // attach the clone function to Object prototype
    var initialize  = (function(){
        Object.prototype.clone = clone;
    })();
    
})();</pre></div><p>In this module, we have<a id="id262" class="indexterm"/> implemented our cloning function which takes care of copying an object's properties into a new object. I have also modified this function a little from its previous version that you saw earlier. This is so it will only copy the properties of the object itself and not its parent's properties (if there is one). We can do this by using JavaScript's native <code class="literal">hasOwnProperty</code> method.</p><p>We have assigned the cloning function as a property to <code class="literal">Object.prototype</code> object, so all the objects in the application can have access to this method.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec38"/>Testing our custom cloning method in ImagesInc_Utilites module</h2></div></div></div><p>Let's create a test module to<a id="id263" class="indexterm"/> see how our cloning mechanism works. Consider the following code:</p><div><pre class="programlisting">var TestModule = (function(){
    
    var privateTestValue = "Test for cloning, this property is hidden";
    
    return {
        publicTestValue: privateTestValue + " but now showing it publicly",
        
        testFunc : function(){
        
            var anotherTest= "This property will be cloned";
            return anotherTest;
        },
        
        getPrivteValue : function(){
            
            return privateTestValue;
        },
        
        changePrivateVar : function(){
            privateTestValue = "the private value has been changed";
        
            return privateTestValue;
        
        },
        
        testArray : [1,2,3]
    };
    
})();</pre></div><p>Here we have created a simple module which exposes a public interface with controlled access to its private variable.</p><p>Now, if we run the following code:</p><div><pre class="programlisting">// creating a clone object
CloneModule = TestModule.clone(true);</pre></div><p>We can create a clone of the original module, <code class="literal">TestModule</code>.</p><p>We can run a simple test as follows:</p><div><pre class="programlisting">// displays "This property will be cloned"
console.log(CloneModule.testFunc());</pre></div><p>As you can see, the expected output is displayed.</p><p>To verify that all the properties have been copied from our original module to our new module, we can <a id="id264" class="indexterm"/>examine all the properties in both modules, using our browser's debugger (I'm using Chrome's debugger) as shown here:</p><div><img src="img/B04910_06_01.jpg" alt="Testing our custom cloning method in ImagesInc_Utilites module"/></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec39"/>An important aspect of our cloning method</h2></div></div></div><p>There is also another interesting aspect of this cloning method that you need to be mindful of. </p><p>Remember<a id="id265" class="indexterm"/> that our <code class="literal">TestModule</code> has a hidden property by design, which is <code class="literal">privateTestValue</code>. What happens to this property when we do our cloning?</p><p>Well, the best way to find out is by running a test.</p><p>In our <code class="literal">TestModule</code>, we have a method property (<code class="literal">changePrivateVar</code>) which modifies this hidden property. So if we run the following:</p><div><pre class="programlisting">// displays "the private value has been changed"
console.log(TestModule.changePrivateVar());</pre></div><p>We can change the value of this property to <code class="literal">the private value has been changed</code>, in our <code class="literal">TestModule</code>. Now, let's see if our <code class="literal">CloneModule</code> has access to this value and if so, does it hold on to the old value of this property or will the value will be changed for our <code class="literal">CloneModule</code> as well?</p><p>If we run the following code snippet:</p><div><pre class="programlisting">// displays "the private value has been changed"
console.log(CloneModule.getPrivteValue());</pre></div><p>We see that not only our <code class="literal">CloneModule</code> has access to this property but also that the value has been changed for this module.</p><p>This shows us that because of the closure in our original <code class="literal">TestModule</code> module, our <code class="literal">CloneModule</code> also has access to the private scope of this module and it also retains the state of the scope that is provided by the closure.</p><p>This may, or may not, be a desirable result for us, depending on how we want to clone our modules. However, it is very important to keep in mind that, because of the closure in our original module, our <a id="id266" class="indexterm"/>cloning outcome is a little different than when we clone objects which do not have embedded closures.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>
<strong>Running more tests on our cloning method</strong>
</p><p>I have included a few tests for module cloning in the accompanying code for this chapter. You can see these tests in the <code class="literal">AppTester.js</code> file. Please have a look, read the comments and modify the code to see how the results can be affected.</p></div></div><p>As you can see, cloning can be used when we want to create a replica of our original module with access to the original module's closure context. This in turn can provide us with access to the private members of the original module.</p><p>Most of the time, when we clone a module, we use it as the base module for a new module. We can then add more functionality or modify the existing functionality of the new module, using one of the other techniques that we discussed previously, such as loose or tight augmentation.</p><p>This approach allows us to extend the clone of a module instead of the original module, thus shielding the original module from all the changes, while having access to all the functionality of the original module.</p><p>Of course, cloning is not the only way that we can achieve this, but nonetheless, it is another valuable tool to have in our toolbox.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Inheritance in modules</h1></div></div></div><p>In <a class="link" href="ch02.html" title="Chapter 2. Review of Important JavaScript OOP Concepts">Chapter 2</a>, <em>Review of Important JavaScript OOP Concepts</em>, we talked about what inheritance is and looked at<a id="id267" class="indexterm"/> different approaches to creating inheritance relationship <a id="id268" class="indexterm"/>among objects. Here, we will leverage the techniques that we learned in that chapter to create inheritance among modules.</p><p>Generally, we use inheritance to utilize our base module's functionality and then either add new functionality or modify the existing functionality in our child modules.</p><p>There are various ways of creating inheritance among modules and we will examine two of these approaches in this section.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Module inheritance using __proto__ object</h2></div></div></div><p>In this type <a id="id269" class="indexterm"/>of inheritance implementation, we use the child module's <code class="literal">__proto__</code> object to inherit properties from the parent <a id="id270" class="indexterm"/>module.</p><p>Let's consider the following:</p><div><pre class="programlisting">var Polygon_Module = (function() {

    var sides = 6;
    var name = "Polygon";
    var type = "2D";
    
    function getSides() {
    
        return sides;
    };

    function getName() {
        
        return name;    
    };
    
    function getType(){
        
        return type;
    };

    return {
        getSides: getSides,
        getName: getName,
        getType: getType
    };
})();

var Rectangle_Module = (function() {
    var Rectangle = {};
    var sides = 4;
    var name = "Rectangle";
    var color = "blue";

    Rectangle.__proto__ = Polygon_Module;
    
    Rectangle.getName = function(){
      return name;
    };
    
    Rectangle.getSides = function(){
      return sides;
    };
    
    Rectangle.getColor = function(){
        return color;
    };
    
    
  return {
      getName: Rectangle.getName,
      getSides: Rectangle.getSides,
      getType: Rectangle.getType
  };

})();</pre></div><p>As you can see, we have created two modules here: <code class="literal">Polygon_Module,</code> which is the parent module in our<a id="id271" class="indexterm"/> inheritance relationship, and <code class="literal">Rectangle_Module</code>, which is<a id="id272" class="indexterm"/> the child module.</p><p>In our <code class="literal">Polygon_Module</code>, we have created private variables and functions, which are not accessible to the external code, except through the module's interface.</p><p>
<code class="literal">Rectangle_Module</code> is designed in a way that it inherits some of its functionality from its parent module (<code class="literal">Polygon_Module</code>). It then modifies some of the inherited functionality as well as adding new functionality of its own.</p><p>The following line of code is the essential piece that creates the inheritance relationship between the two modules:</p><div><pre class="programlisting">Rectangle.__proto__ = Polygon_Module;</pre></div><p>As shown, we have passed a reference from <code class="literal">Polygon_Module</code> to the <code class="literal">__proto__</code> object of <code class="literal">Rectangle</code> object. This allows the <code class="literal">Rectangle</code> object to have access to all the properties that <a id="id273" class="indexterm"/>were exposed in the parent module, through the parent module's interface.</p><p>Let's see what we get when we run the following tests on our modules:</p><div><pre class="programlisting">console.log(Polygon_Module.getName()); //displays "Polygon"
console.log(Polygon_Module.getSides()); // displays 6
console.log(Rectangle_Module.getName()); // displays "Rectangle"
console.log(Rectangle_Module.getSides()); // displays 4
console.log(Rectangle_Module.getType()); // displays "2D"</pre></div><p>The above tests demonstrate that the child module, <code class="literal">Rectangle_Module</code>, has all the methods that were inherited from the parent module; additionally, it has overridden some of these inherited properties.</p><p>Notice <code class="literal">Rectangle_Module.getType()</code> method, which was not defined or overridden in the<a id="id274" class="indexterm"/> child module, but was accessed by the child module through the parent module's interface.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Module inheritance using parasitic combination</h2></div></div></div><p>Another approach to<a id="id275" class="indexterm"/> creating inheritance among objects, which you are probably familiar with and have seen an example of in <a class="link" href="ch02.html" title="Chapter 2. Review of Important JavaScript OOP Concepts">Chapter 2</a>, <em>Review of Important JavaScript OOP Concepts</em>, is <strong>parasitic combination</strong> inheritance.</p><p>As you may recall, the idea is that we use the base<a id="id276" class="indexterm"/> class's constructor function in the child's constructor to create an instance of the child object. We also use the base class's <code class="literal">prototype</code> object to get a reference to all the properties that are exposed on the base class's <code class="literal">prototype</code> object.</p><p>To refresh your<a id="id277" class="indexterm"/> memory, let's have a look at the following example:</p><div><pre class="programlisting">var Polygon_Module2 = (function() {

    var sides = 6;
    var name = "Polygon";
    var type = "2D";
    
    function Polygon(){
        
        this.sides = sides;
        this.name = name;
        this.type = type;
    }
    
    Polygon.prototype.getSides = function(){
        
        return this.sides;
    };
    
    Polygon.prototype.getName = function(){
        
        return this.name;
    };
    
    Polygon.prototype.getType = function(){
        
        return this.type;
    };

    return {
        Polygon: Polygon,
    };
})();


var Rectangle_Module2 = (function(){
    var sides = 4;
    var name = "Rectangle";
    
    function Rectangle(){
        
        Polygon_Module2.Polygon.apply(this);
        this.sides = sides;
        this.name = name;
    }
    
    Rectangle.prototype = Polygon_Module2.Polygon.prototype;
    Rectangle.prototype.constructor = Rectangle;
    
    var RectangleInstance = new Rectangle();
    
    return {
        
        Rectangle: RectangleInstance
    };
    
})();</pre></div><p>In this version of <a id="id278" class="indexterm"/>our modules, <code class="literal">Polygon_Module2</code> has a constructor function  called <code class="literal">Polygon</code>. All of our methods are also defined on the <code class="literal">prototype</code> object of the <code class="literal">Polygon</code> class (object).</p><p>
<code class="literal">Polygon_Module2</code> module also has an anonymous object as an interface, which holds a reference to<a id="id279" class="indexterm"/> <code class="literal">Polygon</code> class (object).</p><p>In our child module, we have created another constructor function <code class="literal">Rectangle</code>, which uses the available interface in <code class="literal">Polygon_Module2</code> to borrow the <code class="literal">Polygon</code> constructor, as shown:</p><div><pre class="programlisting">Polygon_Module2.Polygon.apply(this);</pre></div><p>We have also set the <code class="literal">prototype</code> object of <code class="literal">Rectangle</code> object to point to <code class="literal">Polygon.prototype</code> object so we can have access to all the methods defined in this object, as shown:</p><div><pre class="programlisting">Rectangle.prototype = Polygon_Module2.Polygon.prototype;
Rectangle.prototype.constructor = Rectangle;</pre></div><p>And of course, since we have completely overwritten the <code class="literal">prototype</code> object of our <code class="literal">Rectangle</code> class, we need to reset its <code class="literal">constructor</code> property so that it points to the correct object, which in this case is <code class="literal">Rectangle</code>.</p><p>Notice that we have created an instance of <code class="literal">Rectangle</code> object to start the inheritance relationship between the two objects and set the objects' contexts properly.</p><p>Let's run a few<a id="id280" class="indexterm"/> tests to verify the inheritance relationship, as follows:</p><div><pre class="programlisting">console.log(Rectangle_Module2.Rectangle.getName()); // displays "Rectangle"
console.log(Rectangle_Module2.Rectangle.getSides()); // displays 4
console.log(Rectangle_Module2.Rectangle.getType()); // displays "2D"</pre></div><p>As you can see, the <a id="id281" class="indexterm"/>tests produce the results that were expected.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec42"/>Deciding on the module inheritance approach</h2></div></div></div><p>If you are wondering which approach to take (<strong>__proto__ inheritance</strong> or <strong>parasitic inheritance</strong>) when you <a id="id282" class="indexterm"/>need to create an inheritance relationship among your application modules, in my opinion it will be a matter of taste for the most part.</p><p>However, consider that in our first <a id="id283" class="indexterm"/>approach (using <code class="literal">__proto__</code> inheritance), we did not need to create an instance of the child module to create the inheritance<a id="id284" class="indexterm"/> relationship. This means one less function call and probably a little less memory consumption as no instances of the object are held in memory.</p><p>On the other hand, keep in mind that older browsers may not support setting the <code class="literal">__proto__</code> property of an object.</p><div><div><h3 class="title"><a id="note20"/>Note</h3><p>
<strong>More information about inheritance</strong>
</p><p>If you would like to get a little more information regarding inheritance among JavaScript objects in general, please refer to <a class="link" href="ch02.html" title="Chapter 2. Review of Important JavaScript OOP Concepts">Chapter 2</a>, <em>Review of Important JavaScript OOP Concepts</em>.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Submodules</h1></div></div></div><p>The last technique that we<a id="id285" class="indexterm"/> consider in this chapter, which also allows us to extend our modules, is using <strong>submodules</strong>.</p><p>Submodules are essentially independent modules, which can be added to another module as properties of the hosting module. There are various ways of adding submodules to other modules and we will cover two of these approaches in this section.</p><p>Let's stay with the shape theme that we have been using so far and create a <code class="literal">Shape</code> module. We will consider this module as our hosting module. This module is the parent module for all 2D and 3D shapes and we will add our <code class="literal">Polygon</code> module to it.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Adding submodules using dynamic properties</h2></div></div></div><p>Adding a submodule to<a id="id286" class="indexterm"/> a module as a dynamic property is straightforward, and as we can add dynamic properties to any JavaScript object, we can add a property to a hosting module which points to a submodule.</p><p>Consider the following:</p><div><pre class="programlisting">var Shape = (function(){
    
        var type = "Any 2D and 3D shape";
    
        function getType(){
            return type;  
        }
    
        return {
            
            getType: getType 
        };
    
})();

Shape.Polygon = (function() {

    var sides = 6;
    var name = "Polygon";
    var type = "2D";
    
    function getSides() {
    
        return sides;
    }

    function getName() {
        
        return name;    
    }
    
    function getType(){
        
        return type;
    }

    return {
        getSides: getSides,
        getName: getName,
        getType: getType
    };
})();</pre></div><p>Here, we have created a submodule <code class="literal">Shape.Polygon</code> and have added it to our main module <code class="literal">Shape</code> as a property.</p><p>Of course, we<a id="id287" class="indexterm"/> can access the main module and the submodule as follows:</p><div><pre class="programlisting">console.log(Shape.getType()); // displays "Any 2D and 3D shape"
console.log(Shape.Polygon.getName()); // displays "Polygon"</pre></div><p>This is the simplest way of adding a submodule to a main module but it does require the main module to be present in the scope, before we can add the submodule to it.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Adding submodules using asynchronous properties</h2></div></div></div><p>Adding submodules to a<a id="id288" class="indexterm"/> hosting module using asynchronous properties has the advantage of being more flexible, in the sense that the hosting module does not need to be loaded before the submodule can be added to it.</p><p>Therefore, the submodule can potentially reside in a different file, and can be loaded and added to the hosting module at different times (either before or after the hosting module is loaded), in an asynchronous fashion.</p><p>Let's have a<a id="id289" class="indexterm"/> look at the following code snippet:</p><div><pre class="programlisting">var Polygon_Module;

var Shape = (function(mainModule, subModule){
    
    var Polygon = mainModule.Polygon = mainModule.Polygon || subModule;
    
    Polygon.description = function(){
        
        return "submodule has been added to shape module";
    };
    
   return mainModule;
    
})(Shape || {}, Polygon_Module ||{});

console.log(Shape.Polygon.description());</pre></div><p>This code is responsible for adding our submodule <code class="literal">Polygon_Module</code>, to our main module <code class="literal">Shape</code>.</p><p>As you can see, we are passing two parameters to our IIFE, one for the main module and the other for the submodule. When any of them does not yet exist in the execution context, we are passing an empty object to our IIFE.</p><p>Inside of the IIFE, we check to see if our <code class="literal">mainModule</code> has the property <code class="literal">Polygon</code>, which is in fact our submodule. If the property does exist, we just use it and add a new property to this submodule, called <code class="literal">description</code>.</p><p>If the property <code class="literal">Polygon</code> (the submodule) does not exist in our code execution context, we use the passed-in submodule and then add the new property <code class="literal">description</code> to it.</p><p>Let's check to see if we can access this new property on the submodule, as follows:</p><div><pre class="programlisting">console.log(Shape.Polygon.description()); // displays "submodule has been added to shape module"</pre></div><p>Now, even if we add our <code class="literal">Shape</code> module (the hosting module) after our submodule to our execution context, we can still add our submodule to this module. We can also provide access to<a id="id290" class="indexterm"/> our submodule's properties, through the main (hosting) module.</p><p>Consider the code below:</p><div><pre class="programlisting">var Shape = (function(module){
    
        var type = "Any 2D and 3D shape";
    
        module.getType= function(){
            return type;  
        };
    
        return module;
    
})(Shape || {});</pre></div><p>This implementation of our <code class="literal">Shape</code> module accepts one parameter, which can be either an empty object or a reference to an already existing <code class="literal">Shape</code> module. This means that, even if our <code class="literal">Shape</code> module was already created in our previous IIFE, which was responsible for adding our <code class="literal">Polygon_Module</code> to our <code class="literal">Shape</code> module, we are still able to re-define it.</p><p>To test this, we can run the following:</p><div><pre class="programlisting">console.log(Shape.getType()); // displays "any 2D and 3D shape"

console.log(Shape.Polygon.description()); // displays "submodule has been added to shape module"</pre></div><p>The result confirms that we are able to access properties of the <code class="literal">Shape</code> module as well as our submodule, no matter which one is loaded first in our application.</p><p>You might also notice that the implementation above is very similar to our loose augmentation pattern that we discussed previously. The only real difference is that we are adding our submodule as a completely independent module to our main module, as opposed to just augmenting the main module with new properties.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Summary</h1></div></div></div><p>In this chapter, we looked at a few more techniques which enable us to extend and modify our modules.</p><p>We considered how we can use various cloning approaches to create replicas of our modules and talked about the pros and cons of each approach. We also examined how we can use inheritance among modules so that a child module can utilize the functionality of its parent module as well as override its parent module's functionality, as needed.</p><p>In the last section of this chapter, we talked about submodules and looked at a couple of different techniques for adding submodules to our main (hosting) modules.</p><p>The next chapter will be more focused on the design of our application as a whole. We'll see how a flexible ecosystem can be created for our modules, which allows them to interact and work together, without being dependent on each other.</p></div></body></html>