- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Custom Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve into the world of custom transitions in Svelte.
    So far, we have explored Svelte’s built-in transitions and how they can be used
    to create engaging and dynamic user interfaces. However, there may be situations
    where the built-in transitions don’t quite meet your requirements and you want
    to create something more unique. This is where custom transitions come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Custom transitions allow you to take full control over the animations and effects
    that you want to achieve in your Svelte application. This chapter will guide you
    through the process of creating your own custom transitions, whether they are
    CSS- or JavaScript-based. We will explore the transition contract, which serves
    as the foundation for creating custom transitions, and provide practical examples
    to help you get started.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a solid understanding of how to create
    custom transitions in Svelte, and you will be equipped with the knowledge to implement
    them in your own projects, taking your user interfaces to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes sections on the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The transition contract
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom CSS transition using the `css` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom JavaScript transition using the `tick` function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will be somewhat code-heavy, but don’t worry—you can find all the
    code samples used in this chapter on GitHub at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: The transition contract
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we dive into creating custom transitions, it’s essential to understand
    the foundation upon which they are built: the transition contract.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve read [*Chapter 9*](B18887_09.xhtml#_idTextAnchor135), you’ll be familiar
    with the concept of a store contract. Just as a store is an object that adheres
    to a specific store contract, a transition is a function that follows a transition
    contract. By understanding and adhering to these contracts, you can create custom
    transitions that integrate seamlessly with Svelte’s built-in transition system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The transition contract consists of a single function that is responsible for
    the transition. This function accepts two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`node`: The target DOM element that the transition will be applied to'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: An object containing configuration options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function should return an object that describes how the transition should
    be executed. We will delve into the details of this returned object later in the
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a custom transition that adheres to the transition contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, we have created a custom transition named `customTransition`.
    We did this by declaring a `customTransition` function that takes in two parameters:
    `node` and `params`. This function then returns an object—which we’ll refer to
    as `config`—that describes the transition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To relate the custom transition we’ve just created back to the usage of a transition
    in Svelte, here, we see how the `customTransition` function is applied to a `<``div>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `<div>` element is inserted or about to be removed from the DOM, Svelte
    will attempt to play the transition. Svelte does this by calling the `customTransition`
    function with a reference to the `<div>` element and the `config` object passed
    to the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This `config` object returned by `customTransition` will determine how the transition
    is played out.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s focus on the requirements for the `config` object returned by the
    custom transition function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `config` object returned from a custom transition should include at least
    one of the following properties or methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`delay`: A number specified in milliseconds. This specifies how long to wait
    before the transition begins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`duration`: A number specified in milliseconds. The duration that the transition
    will play. This determines how fast or slow the animation appears to the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`easing`: A function for easing the transition. This function determines the
    rate of change in the transition’s progress over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`css`: A function that is called with two parameters: `progress` and `remaining`.
    Here, `progress` is a value between `0` and `1` representing the progress of the
    transition, and the value of the `remaining` parameter is equal to `1 -` `progress`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function should return a string containing the CSS styles to be applied
    to the target DOM element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`tick`: A function that is called repeatedly during the transition with two
    parameters: `progress` and `remaining`. Here, `progress` is a value between `0`
    and `1` indicating the progress of the transition, and the value of the `remaining`
    parameter is equal to `1 -` `progress`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This function can be used to update the DOM element’s styles based on the current
    progress.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Here is a more complete sample of a custom transition that follows the transition
    contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, our custom transition, named `customTransition`,
    returns an object that describes the transition’s `duration`, `delay`, `easing`,
    and `css` styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw `delay`, `duration`, and `easing` in the previous chapter when applying
    transitions to an element. Since the behavior of these properties remains the
    same in this context, let us focus on something new: the `css` and `tick` functions.'
  prefs: []
  type: TYPE_NORMAL
- en: The css function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you might remember from the last section of the previous chapter, *How Svelte
    transitions work under the hood*, Svelte animates transitions using a combination
    of CSS and JavaScript. It leverages CSS `@keyframe` rules along with the `animation`
    property for CSS animations and the `requestAnimationFrame` function for JavaScript
    animations.
  prefs: []
  type: TYPE_NORMAL
- en: The `css` function is used to generate CSS `@keyframe` rules for custom transitions.
    If the `css` function is defined in the returned object of a custom transition,
    Svelte will call this function when an element is inserted into the DOM or about
    to be removed from the DOM. Svelte will call the `css` function as many times
    as necessary, depending on the duration and easing of the transition, in order
    to generate the appropriate `@``keyframe` rules.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter of the `css` function relates to the progress of the transition.
    `progress` is a number between `0` and `1`, where `0` represents the element being
    out of view, and 1 represents the element being in its final position on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when transitioning an element in after it has been inserted into
    the DOM, the value of `progress` starts at `0` and moves toward `1`. Conversely,
    when transitioning an element out before it is removed from the DOM, the value
    of `progress` starts at `1` and moves toward `0`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `progress` to calculate the CSS styles necessary to create your
    custom transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to create a transition that fades an element from transparent
    to fully visible, we can use `progress` to calculate the opacity value throughout
    the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: When the element is out of view (value of `progress` is `0`), we want the element
    to be transparent (value of `opacity` should be `0`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the element is in view (value of `progress` is `1`), we want the element
    to be fully visible (value of `opacity` should be `1`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The relationship between `progress` and `opacity` can be represented by the
    diagram shown in *Figure 14**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.1: Relationship between progress and opacity'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to derive the value of `opacity` from the value of `progress`
    in the `css` function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Applying the transition in the preceding code will give you an element that
    fades from transparent to visible when inserted into the DOM and fades back to
    transparent when removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take another example. Let us create a transition that flies the element
    from the right to its final position. Here, the translation of the element changes
    throughout the transition, and we can use `progress` to calculate the translation:'
  prefs: []
  type: TYPE_NORMAL
- en: When the element is out of view (value of `progress` is `0`), we want the element
    to be on the right (value of `translateX` is `100px`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the element is in view (value of `progress` is `1`), we want the element
    to be at its final position (value of `translateX` is `0px`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s a diagram depicting the relationship between `progress` and `translateX`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.2: Relationship between progress and translateX'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the previous example, the value of `translateX` is the inverse of `progress`:
    when `progress` is `0`, `translateX` has a nonzero value; when `progress` is 1,
    `translateX` becomes `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to calculate the `translateX` value, we use `1 – progress` times a value,
    as you can see in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When applying the `customTransition` function in the preceding code snippet
    to an element, as the element is added to the DOM, the element will fly in from
    the right to its final position. And because calculating the inverse of `progress`
    (`1 – progress`) is so commonly done, the value is provided as a second argument
    of the `css` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is our custom transition again, but using the second argument instead
    to calculate the translation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `css` function returns a CSS string that can consist of multiple CSS declarations.
    You separate each CSS declaration with a semicolon, just as you would in a `style`
    attribute of an element. For example, let’s create a transition that combines
    fading in and translating from the right simultaneously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we combine both fading in and translating from
    the right simultaneously. The returned CSS string contains multiple CSS declarations
    separated by semicolons, one for `opacity` and another for `transform`, that will
    be applied during the transition.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered the `css` function, let us look at the `tick` function.
  prefs: []
  type: TYPE_NORMAL
- en: The tick function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `tick` function serves as an alternative to the `css` function for creating
    custom transitions. Unlike the `css` function, which is used to generate CSS `@keyframe`
    rules for the animation, the `tick` function allows you to animate a transition
    using JavaScript. This can provide more fine-grained control over the transition,
    enabling the creation of more complex animations that may not be easily achieved
    with CSS alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tick` function is called repeatedly during the transition through `requestAnimationFrame`.
    Similar to the `css` function, the `tick` function accepts two parameters: `progress`
    and `remaining`. The `progress` parameter is a value between `0` and `1`, where
    `0` represents the element being out of view, and 1 represents the element being
    in its final position on the screen, while the `remaining` parameter is equal
    to `1 – progress`. These parameters can be used to modify the DOM element the
    transition is applied to, based on the current progress of the transition.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to create a fade-in transition using the `tick` function,
    you can update the element’s opacity based on the progress value, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Based on the preceding code snippet, Svelte triggers the `tick` function during
    every animation frame throughout the transition.
  prefs: []
  type: TYPE_NORMAL
- en: When the element starts to appear, the `progress` value is `0`, and we use this
    `progress` value to set the initial `opacity` value of the element to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: As the transition continues, the `tick` function is called with `progress` values
    between `0` and `1`, and we update the element’s `opacity` value based on the
    `progress` value.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the transition, the `tick` function is called one last time with
    a `progress` value of 1\. At this point, we set the element’s `opacity` value
    to its final value of 1.
  prefs: []
  type: TYPE_NORMAL
- en: The `tick` function in the preceding code snippet operates similarly to the
    custom fade-in transition we created using the `css` function. Both approaches
    modify the element’s `opacity` value throughout the transition. The key difference
    lies in how they are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Svelte calls the `css` function multiple times with different progress values
    at the beginning of the transition to construct the CSS `@keyframe` rules. Once
    this is done, the `css` function is not called again during the transition. The
    newly created CSS `@keyframe` rule is then applied to the element through the
    CSS `animation` property. The element’s `opacity` value is then updated through
    CSS.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `tick` function is called multiple times by Svelte during
    each animation frame throughout the transition. On every tick call, the element’s
    `opacity` value is modified by JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about the transition contract, let us use this knowledge
    to create a few more custom transitions.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom CSS transition using the css function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first custom transition we will be attempting to write together is an effect
    often witnessed in presentations, commonly referred to as the “color swipe.” This
    effect stands out due to its dynamic sweep of color that flows across the screen,
    creating a sense of energy that captivates the viewer’s attention.
  prefs: []
  type: TYPE_NORMAL
- en: The color swipe transition, as its name suggests, involves a sweeping change
    in color that takes place over an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Picture this: you’re looking at a static screen, possibly a section of a website.
    Suddenly, a new color begins to surface from one edge of the screen. Like a wave,
    this color spreads across the screen, enveloping it. As soon as the color completely
    covers the screen, it starts to recede from the edge of origin, revealing new
    content. When the color entirely withdraws, the new content is fully unveiled:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.3: The color swipe transition'
  prefs: []
  type: TYPE_NORMAL
- en: The *swipe* can move in from any direction—it can move horizontally from left
    to right, vertically from top to bottom, or even diagonally.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to modify the color swipe transition to apply to paragraph (`<p>`)
    elements. When a `<p>` element is added to the DOM, a wave of color will sweep
    over it, unveiling the text within the `<p>` element upon completion of the transition.
    When the `<p>` element is removed from the DOM, the reverse of the transition
    is played, concealing the text upon completion of the transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A visualization of the transition can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.4: The color swipe transition on paragraphs'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will walk through step by step how to create this captivating
    color swipe transition using Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Since the transition that conceals the text when the `<p>` element is being
    removed from the DOM is the same as the transition that reveals the text when
    the `<p>` element is being added but played backward, we will focus on the transition
    played when a `<p>` element is added to the DOM. This is because when a transition
    is applied to an element, Svelte will play the same transition when the element
    is removed, but in reverse. Therefore, by focusing on the transition played when
    an element is added to the DOM, we effectively cover both scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: So, let us get started on creating a transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, let us create the structure of our custom transition. Recall the transition
    contract—a transition is a function that returns an object describing the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we create a `colourSwipe` transition and apply
    it to the `<p>` element. Our current task is to implement the `colourSwipe` transition
    by populating the `config` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two fields that we are going to add to the `config` object are `duration`
    and `delay`. As shown in the following code snippet, we set the duration of the
    transition to 1 second, and the transition will have no delay to start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: However, often when creating a custom transition, you may want to allow the
    user of the transition to customize the duration and delay based on where the
    transition is being applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a user of the transition may want to have a delay of 200 milliseconds
    and a duration of 2 seconds by specifying them in the `transition:` directive,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These custom delays and durations specified in the `transition:` directive
    will be passed into the `colourSwipe` transition as the second argument, which
    will use them in the `config` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we use the values of `params.duration` and `params.delay`
    in the `config` object and provide a default value when these parameters aren’t
    explicitly stated.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have specified the `delay` and the `duration` fields of the transition,
    let’s turn our attention to the next field—`easing`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use a `linear` easing, making the transition move at a constant
    speed, without any acceleration or deceleration. As we did with `duration` or
    `delay`, we are going to make `easing` customizable by the user. So, in the following
    code snippet, we set the value of `easing` based on the user-specified easing.
    If it is left unspecified, we fall back on our default easing—`linear` easing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Typically, in the process of creating a custom transition, the `duration`, `delay`,
    and `easing` fields are the simplest to set up. More often than not, we determine
    default `duration`, `delay`, and `easing` values, and then offer the user the
    flexibility to tweak these to their liking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having figured out the `duration`, `delay`, and `easing` values, we now delve
    into the crux of the transition: coming up with the CSS for the transitioning
    element.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you observe the transition carefully, you will notice that the transition
    can be divided into two distinct stages: the initial half involves the color block
    expanding to envelop the entire `<p>` element, and the latter half corresponds
    to the color block retracting to unveil the text within the `<``p>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.5: The color swipe transition split into two halves, separated by
    dotted lines'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore how we can create these CSS rules to effectively bring to life
    these stages of the transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let us create a `css` function in our `colourSwipe` transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We are going to fill in the `css` function in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: It’s key to note that the `progress` value begins at `0` at the start of the
    transition and goes to 1 at the end of the transition. As we are splitting the
    transition into two stages, the first stage will see the `progress` value moving
    from `0` to `0.5`, while the second stage advances from `0.5` to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, in our `css` function, we will implement different CSS rules for different
    stages of the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, you can see that we have added an `if` block
    in the `css` function, which uses the `progress` value to determine which sets
    of CSS rules to apply. For the first half of the transition (`progress` <= 0.5),
    the first set of CSS rules is implemented. For the latter half (`progress` > 0.5),
    the second set of rules is used. This way, we can customize the element’s appearance
    in distinct ways throughout the two stages of the transition.
  prefs: []
  type: TYPE_NORMAL
- en: In the first half of our transition, we need to create a growing color block.
    To create this, we will apply a linear gradient on the background of the element.
    The gradient will transition from a solid color to a transparent color. By aligning
    the color stop point of the solid color and the transparent color at the same
    location, we can create a sharp hard line in the gradient transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want a solid red color block that occupies the left 25%
    of an element, we could apply the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we have a linear gradient moving from left to right,
    with the red and transparent colors sharing the same color stops at the 25% point.
    This creates a solid red block on the leftmost 25% of the gradient, while the
    remaining 75% is transparent.
  prefs: []
  type: TYPE_NORMAL
- en: Our choice to use a linear gradient to achieve this color block, as opposed
    to superimposing another element, shows the simplicity of this approach. It eliminates
    the necessity of creating an additional element.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of setting a linear gradient on the background, instead of resizing
    the element, is to have a resizing color block effect without actually resizing
    an element, which would cause re-layout and layout shifts in the DOM. This way,
    the element with the applied CSS remains static in its original position and size
    throughout the transition.
  prefs: []
  type: TYPE_NORMAL
- en: So, now we’ve figured out the CSS to use, let’s incorporate it into our transition’s
    `css` function.
  prefs: []
  type: TYPE_NORMAL
- en: Before that, we need to do some math. We intend to use the value of `progress`
    to calculate the percentage of the element to be covered by the solid color block.
  prefs: []
  type: TYPE_NORMAL
- en: In the first half of the transition, the value of `progress` goes from `0` to
    `0.5`.
  prefs: []
  type: TYPE_NORMAL
- en: Within this phase of the transition, the percentage of the element that needs
    to be covered should range from 0% to 100%.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, by performing arithmetic calculations, we can conclude that the
    percentage value is 200 times the value of `progress`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s now integrate this into our `css` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we use the calculated percentage to control the
    size of the solid color block, making it grow from the left from 0% to 100% through
    the first half of the transition.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s turn our attention to the second half of the transition, where the
    solid color block contracts from full width toward the right edge of the element.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate way to envision this is by considering the expansion of the transparent
    portion from the left edge, covering from 0% to 100% of the element. This mirrors
    the first half of the transition, with the key difference being that it’s now
    the transparent color, not the solid one, that grows to fully envelop the element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The formula for calculating the `percentage` value remains the same, but since
    the `progress` value now ranges from `0.5` to `1`, we need to subtract `0.5` from
    the `progress` value before multiplying it by 200\. So, the equation becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'With this modification, our `css` function now becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this updated function, the solid color block and transparent areas dynamically
    resize according to the calculated percentage during the transition, effectively
    creating the visual illusion of a color swipe.
  prefs: []
  type: TYPE_NORMAL
- en: Applying the transition to an element now, you might notice that although we
    have a functional solid color swipe transition effect, there are a few elements
    that could be refined for a smoother visual experience.
  prefs: []
  type: TYPE_NORMAL
- en: One prominent aspect is that the text within the element remains visible throughout
    the entire transition. Ideally, it should stay hidden in the first half of the
    transition, when the solid color block is expanding, and only be revealed in the
    second half as the color block shrinks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.6: The text is not hidden in the first half of the transition'
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, we can set the text color to transparent during the first
    half of the transition, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Another issue is that the solid color block remains red, regardless of the text
    color. Because we are using the CSS `background` property to create a swipe effect,
    the text remains at the forefront, while the solid color block is in the background.
  prefs: []
  type: TYPE_NORMAL
- en: This affects the text-revealing effect from the color block since the full text
    content becomes fully visible in the second half of the transition. If the solid
    color block shared the same color as the text, the text would blend with the background.
    This would create a visual illusion, giving the appearance that the text is being
    revealed as the color block contracts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.7: The text and block color do not match'
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this, we need to find a way to obtain the color of the text and incorporate
    it into our linear gradient background.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `window.getComputedStyle()` function allows us to fetch the styles applied
    to an element. We can use this function to get the color of the text at the beginning
    of the transition and use that color for our gradient background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding revised code snippet, we replace `red` with the text color
    we fetched from the `node` element’s computed style.
  prefs: []
  type: TYPE_NORMAL
- en: And there you have it—a customized color swipe effect, implemented as a Svelte
    transition. The complete code can be found at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition).
  prefs: []
  type: TYPE_NORMAL
- en: We went step by step through creating a custom Svelte transition using CSS.
    Throughout the process, we learned how to implement user-customizable attributes
    into our transition, such as `duration`, `delay`, and `easing`. In our color swipe
    transition, we learned how to craft a multi-staged transition and how to segment
    the `progress` parameter into various stages, utilize its value to compute the
    CSS rules, and apply it to the element.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you are now equipped to create your own custom Svelte transition
    using CSS.
  prefs: []
  type: TYPE_NORMAL
- en: At the start of this chapter, we learned that a transition contract can include
    not only a `css` function but also a `tick` function. The `tick` function allows
    us to modify elements during the transition. We’ve explored how to use the `css`
    function to create a color swipe transition; in the next section, we’ll delve
    into creating another custom transition, this time using the `tick` function.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a custom JavaScript transition using the tick function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The custom transition we will attempt to write in this section is a flipboard
    transition. The transition emulates the mechanics of vintage airport departure
    boards. During this transition, each letter of the text *flips*, cycling through
    characters until it finally lands on the correct one. The transition ends when
    all the letters have settled into the right character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how the flipboard transition works to reveal
    the phrase *Hello Svelte*, with the vertical axis representing the flow of time
    from top to bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.8: Flipboard transition visualized'
  prefs: []
  type: TYPE_NORMAL
- en: At the onset of the transition, letters begin to appear from left to right,
    starting as a dash (`-`) and then flipping through random characters before settling
    on the correct one. This flipping motion continues from left to right until all
    letters have aligned with their corresponding characters, unveiling the intended
    phrase.
  prefs: []
  type: TYPE_NORMAL
- en: The entire transition process involves modifying characters within the element,
    transitioning from a blank state through jumbled characters, and finally to the
    correct text. Since there are no style or layout changes needed, we are not using
    the `css` function to implement this transition. The `tick` function is the perfect
    candidate to implement this transition in Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve defined how the flipboard transition would look, let us start
    implementing this transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Building on what we learned with the color swipe transition in the previous
    section, the flipboard transition begins in a similar way. Here is the basic code
    structure for our flipboard transition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we have defined a `flipboard` function that adheres
    to the transition contract. It takes in two arguments, `node` and `params`, and
    returns a transition configuration—an object that describes the transition. As
    such, we are able to apply the `flipboard` function as a transition using the
    `transition:` directive on a `<``div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: Within the flipboard transition, we’ve set up the basic parameters, such as
    defining the `duration`, `delay`, and `easing` values, while leaving a placeholder
    for the `tick` function, where we will implement the transition.
  prefs: []
  type: TYPE_NORMAL
- en: To create a flipboard transition, we start by obtaining the text content of
    the element that will be transitioning. Then, each time the `tick` function is
    called, we determine the text to display based on the `progress` value and update
    the element accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the text of an element using the following API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to set the text content of an element, we assign it through the
    same property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Incorporating these into the flipboard transition, here’s what we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, we retrieve the text content of the element at
    the beginning of the `flipboard` function, right before the transition starts
    to play on the element. The `tick` function, called repeatedly on every animation
    frame, computes the new `text` value for the element, based on the original `text`
    value and current `progress` value.
  prefs: []
  type: TYPE_NORMAL
- en: The `tick` function’s task is to determine how each letter should be displayed,
    based on the `progress` value. Some letters might appear as a dash, some as random
    characters, some as their original value, and others might be hidden.
  prefs: []
  type: TYPE_NORMAL
- en: For each letter, its display depends on its position relative to the full text’s
    length and the current `progress` value. For instance, if a letter is positioned
    at 30% from the left, and the current `progress` value is `0.5` (or 50%), then
    that letter should be displayed as is.
  prefs: []
  type: TYPE_NORMAL
- en: How do we determine these rules? What leads us to the conclusions just drawn?
  prefs: []
  type: TYPE_NORMAL
- en: We want the element to reveal all its original characters at the end of the
    transition. This means that when the `progress` value reaches 1 (or 100%), all
    letters should display their original character. At the midpoint, with a `progress`
    value of `0.5` (or 50%), 50% of the letters from the left should show their original
    character, while the remaining 50% on the right should show either a dash, a random
    character, or nothing at all.
  prefs: []
  type: TYPE_NORMAL
- en: To generalize, if a letter’s position from the left is less than the `progress`
    value, it should display its original character. Otherwise, it may display a dash,
    a random character, or nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how the `progress` value and the displayed
    text are related:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.9: The red box shows which letters are displaying the original character
    at each progress value'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram illustrates how the original characters are revealed at
    different values of `progress`. As the `progress` value increases, more letters
    in the word display their original characters.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the flipboard effect just described, we will loop through each
    character, determine its relative position, and then decide whether it should
    be displayed. For characters whose position is beyond the current `progress` value,
    we will display a blank space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the updated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With this code, the flipboard transition now either shows the original characters
    or a blank space based on the progress value. When playing the transition, you
    will see the characters appear one by one from left to right.
  prefs: []
  type: TYPE_NORMAL
- en: Having figured out when to show up the original characters, let us continue
    to determine when the text should display dashes or random characters.
  prefs: []
  type: TYPE_NORMAL
- en: Using a similar idea, we can determine whether a letter should display a random
    character, a dash, or nothing at all. We will introduce a constant number to manage
    the timing of these changes. If the letter’s position is beyond this constant
    multiplied by the `progress` value, it will show up as nothing. I’ve chosen a
    value of 2 for this constant, based on trial and error. It’s a value greater than
    1 but not too large, to create the effect of characters appearing gradually from
    the left.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we could also introduce another constant to manage the display of
    dashes or random characters. If the letter’s relative position is greater than
    this new constant times the progress value, but less than 2, the letter will appear
    as a dash. Otherwise, it will be a random character. For this purpose, I have
    chosen 1.5, positioning it midway between 1 and 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram visually represents these two constants and their effect
    on the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'igure 14.10: Relationship between the new text and the original text'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can observe how the characters change during the
    transition. When the `progress` value is `0.4`, for example, letters at the 40%
    position are showing original characters, letters at 40% - 60% (`progress` * 1.5)
    are showing random characters, letters at 60% - 80% (`progress` * 2) are showing
    dashes, and anything beyond is not shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the updated code for our flipboard transition looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, I’ve added two additional conditions to determine
    when to display dashes or random characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `randomCharacter()` function returns a randomly selected character, implemented
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With this code, you have a flipboard transition! Try it out with an element
    and observe the effect. The characters slowly appear one by one from left to right,
    starting as a dash, flipping through characters, and finally settling with the
    correct character.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice one small issue: not all characters are the same width, so the
    overall width of the text grows and shrinks. Since each letter is not aligned
    with its previous position, the flipping effect may not be immediately obvious.'
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, you can use a monospace font. Monospace fonts, also known as fixed-width
    fonts, ensure that each letter occupies the same horizontal space. Applying a
    monospace font to an element enhances the flipping effect, making it more visually
    distinct.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can set the font as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we’ve explored how to create a flipboard transition, emulating
    the appearance of vintage airport departure boards. We’ve learned how to control
    the appearance of characters based on the progress of the transition, using random
    characters, dashes, and original text. And through modifying the text of an element,
    we created a transition that is visually engaging.
  prefs: []
  type: TYPE_NORMAL
- en: The complete code for this section can be found at here:[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have explored how to create custom transitions in Svelte.
    We went through two detailed examples that utilize the `css` function and the
    `tick` function.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you now feel well equipped to write your own custom transition in
    Svelte, enabling you to craft a more engaging and unique user experience in Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: In our next and final chapter, we will delve into how transitions can impact
    the accessibility of your Svelte application, guiding you in the creation of an
    engaging and inclusive experience for all users.
  prefs: []
  type: TYPE_NORMAL
