<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Building and Testing</h1></div></div></div><p>Perfect code is a unicorn; what good developers do is introduce the smallest amount of bad code. Any code is, therefore, somewhat flawed, so errors and inefficiency are an inescapable pathology in software development. Accordingly, <strong>technical debt</strong> naturally compounds as<a id="id694" class="indexterm"/> more code is written. Some of the more expensive technical realities of modern application development are listed here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">There are<a id="id695" class="indexterm"/> rigidly coupled components that do not easily allow change at either the technical level or the business level. Allowing such unprincipled interpenetration leads to complex capillary networks growing throughout the body of your code. The edges of these networks are nearly impossible to trace, concretizing entanglements that obscure how a change in one function might affect other functions.</li><li class="listitem" style="list-style-type: disc">Poor gatekeeping allows untested code to enter production, often leading to quick fixes, which, in turn, can lead to intractable patches and bridge code as well as relentless bugs that regularly resurface.</li><li class="listitem" style="list-style-type: disc">There are code units built in isolation in parallel without objective <em>big picture</em> guidelines that are merged into a single codebase sloppily and joined together by undocumented, ad hoc bindings.</li><li class="listitem" style="list-style-type: disc">The need for refactoring reaches a critical point, and further development, in any sense, becomes nearly impossible. Scaling ceilings typify this situation, and wholesale rewrites are inevitable and nearly always doomed.</li></ul></div><p>Debt accumulates interest. Software, like many long-term pursuits, requires constant debt management. It is in your interest to reduce debt. In the previous chapter, we learned how to profile <em>deployed </em>applications at a level of detail sufficient to expose errors, weaknesses, and other unwanted characteristics. In this chapter, we will explore strategies that help software developers and teams catch errors before the membranes of their applications are breached. We will also explore workflows to manage the integration of independently written programs.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec32"/>Building with Gulp, Browserify, and Handlebars</h1></div></div></div><p>The JavaScript <a id="id696" class="indexterm"/>you are working on will likely be transformed and augmented before it makes it to production. At the very least, it will be checked <a id="id697" class="indexterm"/>for errors, minified, packaged, and so<a id="id698" class="indexterm"/> on. It will be deployed only after that. Deployment, therefore, follows a build step and how each step in the build is<a id="id699" class="indexterm"/> instrumented must be clearly defined.</p><p>Over time, certain <a id="id700" class="indexterm"/>patterns of development have emerged within the Node community. Many of these patterns map to other environments, while others are unique to <a id="id701" class="indexterm"/>the <em>full-stack JavaScript</em> Node.js world. The ability to run identical code on the client and server is perhaps the most prominent example. Because deployed codebases often contain the end result of transpilation (for example, CoffeeScript, and SASS), deployment workflows are assembled to run preprocessors, concatenate files, create source maps, compress images, and so on.</p><p>In this section, we will look at three technologies that are regularly seen in the Node build/deploy process. We'll use <strong>Gulp</strong> to create a <a id="id702" class="indexterm"/>build system, using <strong>Browserify</strong> to bundle application code and <strong>Handlebars</strong> as a templating language for compiling static pages. Finally, we'll look at how to improve our development experience by using <strong>BrowserSync</strong>
</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec59"/>Using Gulp</h2></div></div></div><p>Create a <a id="id703" class="indexterm"/>new folder and initialize a <code class="literal">package.json</code> file in that folder with <code class="literal">npm init</code>. When this is done, you'll end up with a <code class="literal">package.json</code> file that looks somewhat like the following:</p><div><pre class="programlisting">{
  "name": "building",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "",
  "license": "ISC"
}</pre></div><p>This basic scaffold will be fleshed out and explained as we proceed. The point is simply that you will now hang the modules and other dependencies of your application on this scaffold, using npm, neatly describing dependencies, test harnesses, and more. Since we'll use the Gulp build system, it is reasonable to install the Gulp module first and to assert that it is<a id="id704" class="indexterm"/> a dependency of this package. Run these two commands:</p><div><pre class="programlisting">
<strong>npm install gulp --global</strong>
<strong>npm install gulp --save-dev</strong>
</pre></div><p>The first command installs Gulp globally, meaning that you can now use the <code class="literal">gulp</code> command directly from the command line (you can also abbreviate <code class="literal">--global</code> with <code class="literal">-g</code>). The next command installs Gulp locally, adding the following new property to the <code class="literal">package.json</code> file:</p><div><pre class="programlisting">  "devDependencies": {
    "gulp": "^3.8.10"
  }</pre></div><p>Gulp has been installed and saved as a dependency. We are prepared to construct a build system.</p><p>One goal of a build system is the instrumentation of your development environment such that you can work naturally with uncompressed, unminified code while developing and, later, issue commands to convert your <em>raw</em> code and assets into an optimized state suitable for staging environments, production environments, and so on. Providing developers with an expressive and simple syntax for describing how to convert source code into deployable code is what Gulp aims to provide.</p><p>Create two new folders in your working directory: a <code class="literal">/source</code> folder and a <code class="literal">/build</code> folder. We're going to create a set of instructions for transforming the files in <code class="literal">source/</code> into files in <code class="literal">/build</code>. This set of instructions is stored in a file that is specifically called <code class="literal">gulpfile.js</code>. Create that file and insert the following code:</p><div><pre class="programlisting">"use strict";
var fs = require('fs');
var gulp = require('gulp');
var buildDirectory = './build';
gulp.task('default', function(cb) {
  fs.exists(buildDirectory, function(yes) {
    if(yes) {
      return cb();
    }
    fs.mkdirSync(buildDirectory);
    cb();
  });
});</pre></div><p>Gulp works on the idea of running a number of tasks in a certain order. The general format is <code class="literal">gulp.task(&lt;task name&gt;, &lt;task runner&gt;)</code>. A Gulpfile is typically extended with several such task definitions. As we'll see, tasks can be named anything you'd like, but<a id="id705" class="indexterm"/> there must always be a default task named <em>default</em>, and the preceding code establishes such a task to do one simple thing: ensure that a <code class="literal">/build</code> folder exists, and, if not, to create one.</p><p>One thing to notice is the first argument a task runner function receives: a callback function, here named <code class="literal">cb</code>. Because Node programs customarily run asynchronous code, it is important to have a mechanism to <em>tell</em> <code class="literal">gulp</code> that a task is finished. We're running asynchronous code to check for the existence of a folder, so we use this callback system, but note that, if your code either runs synchronously or if the moment of task completion is irrelevant to subsequent tasks, you can skip running a callback, and Gulp will simply continue with the next task as soon as the task runner exits.</p><p>Go ahead and run the <code class="literal">gulp</code> command in the folder containing your Gulpfile. You should see something like the following:</p><div><pre class="programlisting">
<strong>Using gulpfile ~/building/gulpfile.js</strong>
<strong>Starting 'default'...</strong>
<strong>Finished 'default' after 720 μs</strong>
</pre></div><p>To check that the task is doing its job correctly, delete the <code class="literal">/build</code> folder and run <code class="literal">gulp</code> again. You'll see that the folder is recreated.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>Given that Gulp expects its Gulpfile to contain a <em>default</em> task, the <code class="literal">gulp</code> command is simply a shortcut for <code class="literal">gulp default</code>. You can execute a specific task by running <code class="literal">gulp &lt;taskname&gt;</code>.</p></div></div><p>In a typical build, many tasks will be run. Each task should be as simple and specific as possible, and the Gulpfile should neatly organize them so that they execute in a certain order. For this reason, the default task, typically, doesn't do much on its own but is used as a way to hint at the list of tasks that will be run. Let's rewrite the preceding code in a more directed way:</p><div><pre class="programlisting">gulp.task('initialize',function(cb) {
  fs.exists(buildDirectory, function(yes) {
    ...
    cb();
  });
});

gulp.task('default', ['initialize'], function() {
  console.log('Build is complete');
});</pre></div><p>Here, we see <a id="id706" class="indexterm"/>more clearly how <code class="literal">gulp</code> works. A second array argument is passed to the <code class="literal">gulp</code> task's definition, listing other tasks on which the current task depends—a task will not run until all of its dependencies have completed. Let's add another task to this execution chain that copies files in the <code class="literal">/source</code> folder to the <code class="literal">/build</code> folder. Add the following to your Gulpfile:</p><div><pre class="programlisting">gulp.task('move', function() {
  gulp
  .src('./source/**')
  .pipe(gulp.dest('./build'))
});</pre></div><p>Now, tell <code class="literal">gulp</code> about this new task:</p><div><pre class="programlisting">gulp.task('default', ['initialize', 'move'], function() ...)</pre></div><p>In addition to <code class="literal">task</code>, you will use the <code class="literal">src</code>, <code class="literal">pipe</code>, and <code class="literal">dest</code> Gulp commands frequently. Gulp is a <em>streaming</em> build system—within a task, you will normally identify a collection of files, run a chain of transformations against them, and put the transformed files somewhere useful, typically the folder containing a deployable application. The <code class="literal">src</code> command is used to identify this collection and convert the contained files into streamable objects such that <code class="literal">pipe</code> can be used on them to gulp plugins. We will provide more information on this later.</p><div><div><h3 class="title"><a id="note38"/>Note</h3><p>Arguments to Gulp's <a id="id707" class="indexterm"/>
<code class="literal">src</code> command often contain <em>globs</em> (for example, <code class="literal">/source/**</code>), flavors<a id="id708" class="indexterm"/> of pattern matching that are useful when we target files within folders. More on how they work<a id="id709" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/isaacs/node-glob#glob-primer">https://github.com/isaacs/node-glob#glob-primer</a>.</p></div></div><p>The preceding code creates a collection of files in the <code class="literal">/source</code> directory and pipes them to the (built-in) <code class="literal">dest</code> gulp plugin, which writes them to <code class="literal">/build</code>. Run gulp again. You will see something like the following:</p><div><pre class="programlisting">Starting 'initialize'...
Starting 'move'...
Finished 'move' after 3.66 ms
Finished 'initialize' after 4.64 ms
Starting 'default'...
Build is complete
Finished 'default' after 19 μs</pre></div><p>Did you see<a id="id710" class="indexterm"/> anything problematic? The <code class="literal">move</code> task ran prior to the completion of <code class="literal">initialize</code>, which creates a race condition—will the <code class="literal">/build</code> directory be created before <code class="literal">move</code> tries to add files to it? A build should be as fast as possible, and, to that end, Gulp aims for maximum concurrency—unless you specify otherwise, Gulp will run all of its tasks concurrently. As illustrated in the preceding code, <code class="literal">initialize</code> and <code class="literal">move</code> start simultaneously. How can a specific ordering be enforced?</p><p>The ordering of the dependency list passed to <code class="literal">default</code> does <em>not </em>reflect their execution order. However, it does represent a list of tasks that must complete prior to the execution of <code class="literal">default</code>. To ensure that <code class="literal">move</code> follows <code class="literal">initialize</code>, simply make <code class="literal">initialize</code> a dependency of <code class="literal">move</code>:</p><div><pre class="programlisting">gulp.task('move', ['initialize'], function() {
  ...
});</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Erecting a build scaffold</h2></div></div></div><p>Now that <a id="id711" class="indexterm"/>you have an idea of how Gulp works, let's build a representative build process. We'll develop a Gulpfile step by step. To start with, use the following code:</p><div><pre class="programlisting">"use strict";

//  npm install coffee-script -&gt; this is used for test task
require('coffee-script/register');

var path = require('path');
var mkdirp = require('mkdirp');
var del  = require('del');
var source = require('vinyl-source-stream');
var buffer = require('vinyl-buffer');
var browserSync = require('browser-sync');
var gulp = require('gulp');
var coffee = require('gulp-coffee');
var coffeelint = require('gulp-coffeelint');
var sourcemaps = require('gulp-sourcemaps');
var changed = require('gulp-changed');
var concat = require('gulp-concat');
var handlebars = require('gulp-handlebars');
var browserify = require('browserify');
var sass = require('gulp-sass');
var wrap = require('gulp-wrap');
var mocha = require('gulp-mocha');
var uglify = require('gulp-uglify');
var minifyHTML = require('gulp-minify-html');

//  A map of relevant source/build folders
var buildDir     = './build';
var sourceDir     = './source';
var s_scriptsDir   = './source/scripts';
var b_scriptsDir   = './build/js';
var s_stylesDir   = './source/styles';
var b_stylesDir   = './build/css';
var s_templatesDir   = './source/templates';
var b_templatesDir   = './build/templates';
var s_testsDir    = './source/tests';

//  Clean out build directories before each build
gulp.task('clean', function(cb) {
  del([
    path.join(b_scriptsDir, '**/*.js'),
    path.join(b_stylesDir, '**/*.css'),
    path.join(b_templatesDir, '*.js'),
    path.join(buildDir, '*.html')
  ], cb);
});
gulp.task('scaffold', ['clean'], function() {
  mkdirp.sync(s_scriptsDir);
  mkdirp.sync(b_scriptsDir);
  mkdirp.sync(s_stylesDir);
  mkdirp.sync(b_stylesDir);
  mkdirp.sync(s_templatesDir);
  mkdirp.sync(b_templatesDir);
  mkdirp.sync(s_testsDir);
});

...

gulp.task('default', [
  'clean',
  'scaffold',
  'lint',
  'scripts',
  'styles',
  'templates',
  'browserify',
  'views',
  'test',
  'watch',
  'server'
]);</pre></div><p>At the head of this file, you'll see a lot of require statements. Excepting <code class="literal">path</code>, they will all be <a id="id712" class="indexterm"/>used as either Gulp plugins or helpers. You can just copy the <code class="literal">package.json</code> file found in the <code class="literal">/building</code> folder of you code bundle for this chapter, or go ahead and install them using the <code class="literal">--save-dev</code> directive: <code class="literal">npm install --save-dev gulp-coffee gulp-changed [...]</code>.</p><p>Also, install the <code class="literal">jquery</code> and <code class="literal">handlebars</code> npm modules as dependencies using <code class="literal">npm install --save jquery handlebars</code>. We will provide more information on why we do this when we discuss Browserify.</p><p>The <code class="literal">clean</code> and <code class="literal">scaffold</code> tasks exist to build a folder structure for your app and to clean the relevant build directories whenever a new build happens (making room for newly built files without leaving the residue of old ones). Take a look at those tasks; they ultimately ensure the following folder structure:</p><div><pre class="programlisting">build
  css
  js
  templates
source
  scripts
  styles
  templates
tests</pre></div><p>In the following <a id="id713" class="indexterm"/>demonstration, we'll write our JavaScript in <strong>CoffeeScript</strong>, storing <code class="literal">.coffee</code> files in the <code class="literal">source/scripts</code> directory, which will be<a id="id714" class="indexterm"/> compiled and moved to the <code class="literal">build/js</code> directory. The <code class="literal">build/css</code> directory will receive transformed <code class="literal">.scss</code> files contained in <code class="literal">source/styles</code>. Handlebars templates will be precompiled and moved from <code class="literal">source/templates</code> to <code class="literal">build/templates</code>. Finally, the <code class="literal">.html</code> files forming the main "pages" of our application will be located in <code class="literal">/source</code> and moved to the root <code class="literal">/build</code> folder. Later on, we will add tasks to expose these HTML views via a web server.</p><p>At the bottom of the snippet, you will see the list of tasks that we'll define bound as dependencies of the default Gulp task. Let's go over those one by one.</p><p>Linting files involves running a syntax checker on your scripts, enforcing various rules, such as indentation, whether or not certain constructs are allowed, whether to force the use of the semicolon, and so on. We'll use CoffeeScript exclusively, so we implement a lint task using the <code class="literal">gulp-coffeelint</code> plugin:</p><div><pre class="programlisting">gulp.task('lint', ['scaffold'], function() {
  return gulp.src(path.join(s_scriptsDir, '**/*.coffee'))
  .pipe(coffeelint('./coffeelint.json'))
  .pipe(coffeelint.reporter('default'))
});</pre></div><p>We're simply checking the syntax of the CoffeeScript files that will be transpiled into JavaScript files residing in the <code class="literal">/js</code> build folder. Any discrepancies will be reported to <code class="literal">stdout</code> but will not stop<a id="id715" class="indexterm"/> the build. A <code class="literal">coffeelint.json</code> file containing syntax rules is applied. You should investigate this file and modify it to<a id="id716" class="indexterm"/> fit your needs—more information can be found at <a class="ulink" href="http://www.coffeelint.org">http://www.coffeelint.org</a>.</p><p>The next step is to build these newly linted scripts:</p><div><pre class="programlisting">gulp.task('scripts', ['lint'], function() {
  return gulp.src(path.join(s_scriptsDir, '**/*.coffee'))
  .pipe(changed(b_scriptsDir, {extension: '.js'}))
  .pipe(sourcemaps.init())
  .pipe(coffee({bare: true}))
  .pipe(sourcemaps.write())
  .pipe(gulp.dest(b_scriptsDir))
});</pre></div><p>There are several build steps happening here. We could simply transform CoffeeScript files to JavaScript files and copy them to the <code class="literal">build/scripts</code> folder. However, as the transpiled JavaScript file is not the original <a id="id717" class="indexterm"/>source file, we need to create a <strong>sourcemap</strong>—an essential tool that will map errors in JavaScript to <em>the original CoffeeScript source</em> that generated the<a id="id718" class="indexterm"/> said JavaScript. This is invaluable when we are debugging in a browser. As you saw in the code, we simply use the <code class="literal">gulp-sourcemaps</code> plugin to track the compilation step, and it automatically appends a sourcemap to the generated JavaScript file, which looks somewhat like the following:</p><div><pre class="programlisting">//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInNhbXBsZS5jb2ZmZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsSUFBQSxJQUFBOztBQUFBLElBQUEsR0FBTyxxQkFBUCxDQUFBIiwiZmlsZSI6InNhbXBsZS5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyIsInNvdXJjZXNDb250ZW50IjpbImRheXMgPSBbMS4uN11cbiJdfQ==</pre></div><p>The <code class="literal">gulp-changed</code> plugin intelligently tracks whether any targeted files have changed, and, if they have not, the plugin removes them from processing. This plugin can drastically reduce the execution time of any task processing a large numbers of files. Note that we set the extension argument to <code class="literal">.js</code> as an option as the original file extension (<code class="literal">.coffeescript</code>) will be changed and the plugin must be told about this naming change.</p><p>We will create styles in our <a id="id719" class="indexterm"/>system using the<strong> Sass</strong> CSS preprocessor (<a class="ulink" href="http://sass-lang.com/">http://sass-lang.com/</a>) denoted by their <code class="literal">.scss</code> extension. In the following task <a id="id720" class="indexterm"/>definition, they are converted to standard CSS. In addition, they are bundled up into a single output file (<code class="literal">app.css</code>) using the <code class="literal">gulp-concat</code> plugin:</p><div><pre class="programlisting">gulp.task('styles', function() {
  return gulp.src(path.join(s_stylesDir, '**/*.scss'))
  .pipe(sass())
  .pipe(concat('app.css'))
  .pipe(gulp.dest(b_stylesDir));
});</pre></div><p>Bundled into a single file at the build step, global styles can be added to any view with a single <code class="literal">&lt;link&gt;</code> tag, while maintaining the necessary separation of style documents during development.</p><p>The next step is slightly more complicated. We are going to use Handlebars templates, which (might) look like this:</p><div><pre class="programlisting">&lt;ul&gt;
  {{#each days}}
    &lt;li&gt;{{this}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p>For Handlebars to feed the preceding iterator some JSON to process, the template must be compiled into a JavaScript function via the <code class="literal">Handlebars.template</code> method. While this could be <a id="id721" class="indexterm"/>done on the client side, it is much more efficient to simply precompile our templates at the build step. So, what we're going to do is export each template as an individual Node module such that they can be used as one normally uses modules. To accomplish this, we'll use the <code class="literal">gulp-wrap</code> plugin:</p><div><pre class="programlisting">gulp.task('templates', function () {
  return gulp.src(path.join(s_templatesDir, '/**/*.hbs'))
  .pipe(handlebars())
  .pipe(wrap('var Handlebars = require("handlebars/runtime")["default"];module.exports = Handlebars.template(&lt;%= contents %&gt;);'))
  .pipe(gulp.dest(b_templatesDir));
});</pre></div><p>This task wraps each source file in code that will use the Handlebars runtime to compile the source code into an exportable JavaScript function. Now, the template can be used in your client code without the overhead of loading Handlebars at runtime or using it for compilation. For example, use the following code:</p><div><pre class="programlisting">var myTemplate = require("build/templates/myTemplate.js");
$(document.body).append(myTemplate({days: ['mon','tue','wed'...]}));</pre></div><p>You might be saying to yourself, "But wait...client-side JavaScript doesn't have a <code class="literal">require</code> statement!"...and you'd be right! Enter the power of Browserify:</p><div><pre class="programlisting">gulp.task('browserify', ['scripts', 'templates', 'views'], function() {
  return browserify(b_scriptsDir + '/app.js')
  .bundle()
  // Converts browserify out to streaming vinyl file object
  .pipe(source('app.js'))
  // uglify needs conversion from streaming to buffered vinyl file object
  .pipe(buffer())
  .pipe(uglify())
  .pipe(gulp.dest(b_scriptsDir));
});</pre></div><p>As mentioned <a id="id722" class="indexterm"/>at <a class="ulink" href="http://browserify.org/">http://browserify.org/</a>:</p><div><blockquote class="blockquote"><p><em>"With Browserify, you can write code that uses require in the same way that you would use it in Node."</em></p></blockquote></div><p>This allows <a id="id723" class="indexterm"/>us to write our client application code as if it was running within Node, with a DOM document thrown in. In the preceding task, Browserify automatically fetches all <code class="literal">app.js</code> dependencies (instances of <code class="literal">require</code>), bundles them <a id="id724" class="indexterm"/>up into a file that will run on the client, runs the <code class="literal">gulp-uglify</code> plugin to minify the resulting JavaScript, and replaces the old file with the Browserified bundle. The <code class="literal">app.js</code> file can contain all of the code we need, in one file, thus simplifying and standardizing client integration.</p><p>Browserify isn't just about concatenation, however. The point is that, with Browserify, we can use npm modules on both the client and the server, <em>normalizing</em> our process, and, therefore, leveraging intelligent package management for client-side JavaScript. This is new and important: we have gained the power of package management and its standardized loading system on the client side. While some client frameworks provide something resembling module management systems, none of these <em>hacks</em> can replace the solid npm system. Consider this example <code class="literal">source/scripts/app.coffee</code> file:</p><div><pre class="programlisting">$ = require("jquery")
days = require("../../build/js/sample.js")
complimentTemplate = require("../../build/templates/compliment.js")
helloTemplate = require("../../build/templates/hello.js")
daysTemplate = require("../../build/templates/days.js")
$ -&gt;
  $("#hello").html helloTemplate(name: "Dave")
  $("#compliment").html complimentTemplate(compliment: "You're great!")
  $("#days").html daysTemplate(days: days)</pre></div><p>If you check your code bundle, you will find this file. Notice how we <code class="literal">require</code> the npm module version of jQuery, as well as the precompiled templates we created previously from Handlebars templates. Yet, we are running in the client, so we can use jQuery operations to add HTML to the DOM—the best of both worlds.</p><p>The task for <code class="literal">views</code> is very simple:</p><div><pre class="programlisting">gulp.task('views', ['scaffold'], function() {
  return gulp.src(path.join(sourceDir, '*.html'))
  .pipe(minifyHTML({
    empty: true
  }))
  .pipe(gulp.dest(buildDir))
});</pre></div><p>We're just <a id="id725" class="indexterm"/>compressing HTML and moving the file, with no further changes, to the build directory.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Running and testing your build</h2></div></div></div><p>At this <a id="id726" class="indexterm"/>point, we have all the tasks set up to manage the key files for <a id="id727" class="indexterm"/>our repository. Let's use <code class="literal">browser-sync</code> to automatically spawn a server and a browser window that will load the <code class="literal">index.html</code> file from our build directory:</p><div><pre class="programlisting">gulp.task('server', ['test','watch'], function() {
  browserSync({
    notify: false,
    port: 8080,
    server: {
      baseDir: buildDir
    }
  });
});</pre></div><p>The <code class="literal">test</code> and <code class="literal">watch</code> tasks will be explained next. For now, notice how easy it is to add a server to your build process. This task starts a server on the provided port and automatically loads <code class="literal">index.html</code> found in <code class="literal">baseDir</code> onto an automatically spawned browser window. The <code class="literal">notify</code> option tell BrowserSync not to display debugging notifications in connected browsers. Now, every time we run Gulp, our app will load up in a browser. Your terminal should display information similar to the following:</p><div><img src="img/1403OS_06_01.jpg" alt="Running and testing your build"/></div><p>BrowserSync allows <a id="id728" class="indexterm"/>multiple clients to view your build, so an external access <a id="id729" class="indexterm"/>URL is provided. Additionally, they will see your interactions. For example, if you scroll the page, the pages of connected clients will also scroll. Additionally, the UI URL will expose a sort of dashboard for your build, allowing you to control connected clients, reload their views, and so on. This is a great tool when you are <a id="id730" class="indexterm"/>doing demonstrations for your team or for a client. To learn more <a id="id731" class="indexterm"/>about BrowserSync and its configuration, visit <a class="ulink" href="http://www.browsersync.io/">http://www.browsersync.io/</a>.</p><p>A good build system should provide a testing harness as the final arbiter of whether the build should be certified. We'll do <a id="id732" class="indexterm"/>a deep dive into testing with <strong>Mocha</strong>, <strong>Chai</strong>, and <strong>Sinon</strong> later <a id="id733" class="indexterm"/>in this chapter, so here we'll just demonstrate a very simple <a id="id734" class="indexterm"/>testing stub that you can build on when designing your Gulp workflow:</p><div><pre class="programlisting">gulp.task('test', ['browserify'], function() {
  return gulp.src(path.join(s_testsDir, '**/*.coffee'), {
    read: false
  })
  .pipe(coffee({bare: true}))
  .pipe(mocha({
  reporter: 'spec'
  }));
});</pre></div><p>There is a test file written in CoffeeScript within the tests directory:</p><div><pre class="programlisting">days = require('../../build/js/sample.js')
assert = require("assert")
describe "days() data", -&gt;
  it "should have a length of 7", -&gt;
    assert.equal days().length, 7</pre></div><p>This test will load one of our template modules, which exports an array with seven members—the <a id="id735" class="indexterm"/>days of the week. The test uses Node's core <code class="literal">assert</code> library (discussed in detail later in this chapter) to test whether this array has the correct length<a id="id736" class="indexterm"/> of seven characters. Mocha provides the testing harness, via <code class="literal">describe</code> and <code class="literal">it</code>, allowing you to design tests that read like a natural language. When you run through Gulp, you should see something like this (if everything goes right):</p><div><img src="img/1403OS_06_02.jpg" alt="Running and testing your build"/></div><p>The final task is provided by another native Gulp method: <code class="literal">watch</code>. The purpose of <code class="literal">watch</code> is to bind file watchers to certain directories such that any file change will automatically trigger a rerun of the relevant build tasks. For example, you might want to run the <code class="literal">scripts</code> task again if any file in <code class="literal">source/scripts</code> changes. The following code demonstrates how (changes in) certain folders automatically trigger a number of build tasks:</p><div><pre class="programlisting">gulp.task('watch', ['scaffold'], function() {
  gulp.watch(path.join(s_scriptsDir, '**/*'), [
    'browserify', browserSync.reload
  ]);
  gulp.watch(path.join(s_templatesDir, '**/*'), [
    'browserify', browserSync.reload
  ]);
  gulp.watch(path.join(s_stylesDir, '**/*'), [
    'styles', browserSync.reload
  ]);
  gulp.watch(path.join(sourceDir, '*.html'), [
    'views', browserSync.reload
  ]);
});</pre></div><p>You will notice that BrowserSync is bound to changes as well, thus creating a very natural development process. Once you have a running build displayed in a browser, any change you make to, for example, <code class="literal">index.html</code>, will be <em>automatically</em> reflected in that view. As you <a id="id737" class="indexterm"/>change the CSS, you will see the change immediately, and<a id="id738" class="indexterm"/> so on. There will be no more constant reloading when you are developing; BrowserSync pushes changes for you.</p><p>There are many other things you might need to do. For example, you might want to compress images before pushing them to production. As a practice, create the relevant image<a id="id739" class="indexterm"/> folders in your source and build directory and implement an <code class="literal">images</code> task <a id="id740" class="indexterm"/>using <code class="literal">gulp-imagemin</code> (<a class="ulink" href="https://github.com/sindresorhus/gulp-imagemin">https://github.com/sindresorhus/gulp-imagemin</a>).</p><div><div><h3 class="title"><a id="note39"/>Note</h3><p>The people behind Gulp provide a good collection of suggested patterns to implement <a id="id741" class="indexterm"/>common build tasks at <a class="ulink" href="https://github.com/gulpjs/gulp/tree/master/docs/recipes">https://github.com/gulpjs/gulp/tree/master/docs/recipes</a>.</p></div></div><p>Here's a final note: you will regularly <em>hand-code</em> these sorts of build systems, typically reusing the same patterns. For this reason, certain automated tools have been created that can often <a id="id742" class="indexterm"/>reduce the creation of boilerplate build code to a few commands. A popular one is <strong>Yeoman</strong> (<a class="ulink" href="http://yeoman.io/">http://yeoman.io/</a>), which makes it easy to construct common "stacks" of build steps, databases, servers, and frameworks. Other notable <a id="id743" class="indexterm"/>solutions <a id="id744" class="indexterm"/>are <strong>Brunch </strong>(<a class="ulink" href="http://brunch.io/">http://brunch.io/</a>) and <strong>Mimosa</strong> (<a class="ulink" href="http://mimosa.io/">http://mimosa.io/</a>).</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec33"/>Using Node's native testing tools</h1></div></div></div><p>Testing is <a id="id745" class="indexterm"/>simply the act of checking whether your assumptions about the state of something are false. In this way, testing software follows the scientific method in that you will express a theory, make a prediction, and run an experiment to see whether the data matches your prediction.</p><p>Unlike scientists, software developers can change reality—Einstein's joke about changing the facts if they don't fit the theory actually applies, without irony, to the testing process. In fact, it is required! When your tests (theories) fail, you must change "the world" until the tests do not fail.</p><p>In this section, you will learn how to use Node's native debugger for <em>live</em> code testing and how to use the <code class="literal">assert</code> module to make predictions, run experiments, and test results.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec62"/>The Node debugger</h2></div></div></div><p>Most developers have used an IDE for development. A key feature of all good development<a id="id746" class="indexterm"/> environments is access to a debugger, which allows breakpoints to be set in a program in places where the state or other aspects of the runtime <a id="id747" class="indexterm"/>need to be checked.</p><p>V8 is distributed with a powerful debugger (commonly seen powering the Google Chrome browser's developer tools panel), and this is accessible to Node. It is invoked using the <code class="literal">debug</code> directive, as shown here:</p><div><pre class="programlisting">
<strong>&gt; node debug somescript.js</strong>
</pre></div><p>Simple stepthrough and inspection debugging can now be achieved within a Node program. Consider the following program:</p><div><pre class="programlisting">myVar = 123;
setTimeout(function () {
  debugger;
  console.log("world");
}, 1000);
console.log("hello");</pre></div><p>Note the <code class="literal">debugger</code> directive. Executing this program <em>without</em> using the <code class="literal">debug</code> directive will result in <code class="literal">"hello"</code> being displayed, followed by <code class="literal">"world"</code> one second later. When using the directive, you will see this:</p><div><pre class="programlisting">
<strong>&gt; node debug somescript.js</strong>
<strong>&lt; debugger listening on port 5858</strong>
<strong>connecting... ok</strong>
<strong>break in debug-sample.js:1</strong>
<strong>  1 myVar = 123;</strong>
<strong>  2 setTimeout(function () {</strong>
<strong>  3   debugger;</strong>
<strong>debug&gt;</strong>
</pre></div><p>Once a breakpoint is hit, we are presented with a CLI to the debugger itself, from within which we can execute<a id="id748" class="indexterm"/> standard debugging and other commands:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">cont, c</code>: This continues execution from the last breakpoint until the next breakpoint</li><li class="listitem" style="list-style-type: disc"><code class="literal">step, s</code>: Step in—this keeps running until a new source line (or breakpoint) is hit; after that, return control to the debugger</li><li class="listitem" style="list-style-type: disc"><code class="literal">next, n</code>: This is like the preceding command, but function calls made on the new source line are executed without stopping</li><li class="listitem" style="list-style-type: disc"><code class="literal">out, o</code>: Step out—this executes the remainder of the current function and back out to the parent function</li><li class="listitem" style="list-style-type: disc"><code class="literal">backtrace, bt</code>: This traces the steps to the current execution frame in a manner similar to the <a id="id749" class="indexterm"/>following:<div><pre class="programlisting">...
#3 Module._compile module.js:456:26
#4 Module._extensions..js module.js:474:10
#5 Module.load module.js:356:32
... etc.</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">setBreakpoint(), sb()</code>: This sets a breakpoint on the current line</li><li class="listitem" style="list-style-type: disc"><code class="literal">setBreakpoint(Integer), sb(Integer)</code>: This sets a breakpoint on the specified line</li><li class="listitem" style="list-style-type: disc"><code class="literal">clearBreakpoint(), cb()</code>: This clears a breakpoint on the current line</li><li class="listitem" style="list-style-type: disc"><code class="literal">clearBreakpoint(Integer), cb(Integer)</code>: This clears a breakpoint on the specified line</li><li class="listitem" style="list-style-type: disc"><code class="literal">run</code>: If the debugger's script has terminated, this will start it again</li><li class="listitem" style="list-style-type: disc"><code class="literal">restart</code>: This terminates and restarts the script</li><li class="listitem" style="list-style-type: disc"><code class="literal">pause, p</code>: This pauses the running code</li><li class="listitem" style="list-style-type: disc"><code class="literal">kill</code>: This kills the running script</li><li class="listitem" style="list-style-type: disc"><code class="literal">quit</code>: This exits the debugger</li><li class="listitem" style="list-style-type: disc"><code class="literal">version</code>: This displays the V8 version</li><li class="listitem" style="list-style-type: disc"><code class="literal">scripts</code>: This lists all loaded scripts<div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>To repeat the last debugger command, simply hit <em>Enter</em> on your keyboard.</p></div></div></li></ul></div><p>Returning to <a id="id750" class="indexterm"/>the script we are debugging, entering <code class="literal">cont</code> in the <a id="id751" class="indexterm"/>debugger results in the following output:</p><div><pre class="programlisting">
<strong>debug&gt; cont</strong>
<strong>&lt; hello // ... a pause of 1000 ms will now occur, then...</strong>
<strong>break in debug-sample.js:3</strong>
<strong>  1 myVar = 123;</strong>
<strong>  2 setTimeout(function () {</strong>
<strong>  3   debugger;</strong>
<strong>  4   console.log("world");</strong>
<strong>  5 }, 1000);</strong>
<strong>debug&gt;</strong>
</pre></div><p>Notice how <code class="literal">"hello"</code> was not printed when we started the debugger even though you would expect the <code class="literal">console.log('hello')</code> command to execute prior to the breakpoint being reached in the <code class="literal">setTimeout</code> callback. The debugger does not execute at runtime; it is evaluating at compile time <em>as well as at run time</em>, giving you deep visibility into how the bytecode for your program is being assembled and, eventually, will be executed, not simply a postcompilation printout, which <code class="literal">console.log</code> gives.</p><p>It is normally<a id="id752" class="indexterm"/> useful at a breakpoint to do some inspection, such as<a id="id753" class="indexterm"/> of the value of variables. There is an additional command available to the debugger, <code class="literal">repl</code>, which enables this. Currently, our debugger has stopped after having successfully parsed the script and executed <code class="literal">console.log('hello')</code>, the first function pushed into the event loop. What if we wanted to check the value of <code class="literal">myVar</code>? Use <code class="literal">repl</code>:</p><div><pre class="programlisting">
<strong>debug&gt; repl</strong>
<strong>Press Ctrl + C to leave debug repl</strong>
<strong>&gt; myVar</strong>
<strong>123</strong>
</pre></div><p>Play around with REPL here, experimenting with how it might be used.</p><p>At this point, our program has a single remaining instruction to execute—printing <code class="literal">"world"</code>. An immediate <code class="literal">cont </code>command will execute this last command, the event loop will have nothing further to do, and our script will terminate:</p><div><pre class="programlisting">
<strong>debug&gt; cont</strong>
<strong>&lt; world</strong>
<strong>program terminated</strong>
<strong>debug&gt;</strong>
</pre></div><p>As an experiment, <code class="literal">run</code> the script again, using <code class="literal">next</code> instead of <code class="literal">cont</code> just before the execution of this final context. Keep hitting <em>Enter</em> and try to follow the code that is being executed. You will see that, after <code class="literal">"world"</code> is printed, the <code class="literal">timers.js</code> script will be introduced into this execution context as Node cleans up after firing a timeout. Run the <code class="literal">scripts</code> command in the debugger at this point. You will see something like this:</p><div><pre class="programlisting">
<strong>debug&gt; next</strong>
<strong>break in timers.js:125</strong>
<strong> 123</strong>
<strong> 124   debug(msecs + ' list empty');</strong>
<strong> 125   assert(L.isEmpty(list));</strong>
<strong> 126   list.close();</strong>
<strong> 127   delete lists[msecs];</strong>
<strong>debug&gt; scripts</strong>
<strong>* 37: timers.js</strong>
<strong>  46: debug-sample.js</strong>
<strong>debug&gt;</strong>
</pre></div><p>It will be <a id="id754" class="indexterm"/>useful to experiment with various methods, learning <a id="id755" class="indexterm"/>about what happens when Node executes scripts at a deep level as well as about Node helping with your debugging needs.</p><div><div><h3 class="title"><a id="note40"/>Note</h3><p>It can be useful to read the following document, describing how the Google Chrome <a id="id756" class="indexterm"/>debugger interface is used: <a class="ulink" href="https://developers.google.com/chrome-developer-tools/docs/javascript-debugging#breakpoints">https://developers.google.com/chrome-developer-tools/docs/javascript-debugging#breakpoints</a>.</p><p>Miroslav Bajtos's <strong>node-inspector</strong> <a id="id757" class="indexterm"/>module is strongly recommended for debugging, allowing a developer to remotely debug a Node<a id="id758" class="indexterm"/> application from the Chrome browser. You can find more information on this at <a class="ulink" href="https://github.com/node-inspector/node-inspector">https://github.com/node-inspector/node-inspector</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec63"/>The 'assert' module</h2></div></div></div><p>Node's assert module<a id="id759" class="indexterm"/> is used for simple unit testing. In many <a id="id760" class="indexterm"/>cases, it suffices as a basic scaffolding for tests or is used as the assertion library for testing frameworks (such as Mocha, as we'll see later). Its usage is straightforward; we want to assert the truth of something and throw an error if our assertion is not true. For example, use the following commands:</p><div><pre class="programlisting">
<strong>&gt; require('assert').equal(1,2,"Not equal!")</strong>
<strong>AssertionError: Not equal!</strong>
<strong>    at repl:1:20</strong>
<strong>  ...</strong>
</pre></div><p>If the assertion was <code class="literal">true</code> (both values are equal), nothing would be returned:</p><div><pre class="programlisting">
<strong>&gt; require('assert').equal(1,1,"Not equal!")</strong>
<strong>undefined</strong>
</pre></div><p>Following the UNIX Rule of Silence, <em>when a program has nothing surprising, interesting, or useful to say, it should say nothing</em>, assertions only return a value when the assertion fails. The value returned can be customized by using an optional message argument, as<a id="id761" class="indexterm"/> seen in the preceding code.</p><p>The <code class="literal">assert</code> module API is composed of a set of comparison operations with identical call signatures—the actual value, the expected value, and an optional message to display when comparison fails. Alternate methods functioning as shortcuts or handlers for special cases are also<a id="id762" class="indexterm"/> provided.</p><p>A distinction must be<a id="id763" class="indexterm"/> made between <strong>identity comparison (===)</strong> and <a id="id764" class="indexterm"/>
<strong>equality comparison (==)</strong>; the former is often referred to as <em>strict equality comparison</em> (as is the case of the <code class="literal">assert</code> API). Because JavaScript employs dynamic typing, when two values of different types are compared using the equality operator ==, an attempt is made to coerce (or cast) one value into the other—a sort of <em>common denominator</em> operation. For example, use the following code:</p><div><pre class="programlisting">1 == "1" // true
false == "0" // true
false == null // false</pre></div><p>As you might expect, these sorts of comparisons can lead to surprising results. Notice the more predictable results when identity comparison is used:</p><div><pre class="programlisting">1 === "1" // false
false === "0" // false
false === null // false</pre></div><p>The thing to remember is that the === operator <em>does not perform type coercion</em> prior to the comparison, while the equality operator compares <em>after type coercion</em>. Additionally, because objects in JavaScript are passed by reference, the identity of two objects with the same values is distinct—for objects, identity requires that both operands <em>refer to the same object</em>:</p><div><pre class="programlisting">var a = function(){};
var b = new a;
var c = new a;
var d = b;
console.log(a == function(){}) // false
console.log(b == c) // false
console.log(b == d) // true
console.log(b.constructor === c.constructor); // true</pre></div><p>Finally, the concept of <em>deep equality</em> is used for object comparisons where identity need not be exact. Two objects are deeply equal if they both posses the same number of owned properties, the same prototype, the same set of keys (though not necessarily in the same order), and equivalent (not identical) values for each of their properties:</p><div><pre class="programlisting">var a = [1,2,3];
var b = [1,2,3];
assert.deepEqual(a, b);  // passes
assert.strictEqual(a, b);  // throws AssertionError: [1,2,3] === [1,2,3]</pre></div><p>It is useful to test your assumptions about how values are understood in comparison to each other by <a id="id765" class="indexterm"/>designing assertion tests. The results may<a id="id766" class="indexterm"/> surprise you.</p><p>The following <a id="id767" class="indexterm"/>rounds out the assertions you can make using this module:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">assert.equal(actual, expected, [message])</code>: This is used to test coerced equality with ==.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.notEqual(actual, expected, [message])</code>: This is used to test coerced equality with !=.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.deepEqual(actual, expected, [message])</code>: This is used to test for deep equality.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.notDeepEqual(actual, expected, [message])</code>: This is used to test for deep inequality.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.strictEqual(actual, expected, [message])</code>: This is used to test identity equivalence ===.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.notStrictEqual(actual, expected, [message])</code>: This is used to test for identity mismatch !==.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert(value, [message])</code>: This throws an error if the sent value is not truthy.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.ok(value, [message])</code>: This is identical to <code class="literal">assert(value)</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.ifError(value)</code>: This throws an error if the value is truthy.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.throws(block, [error], [message])</code>: This is used to test whether or not the supplied code block throws. The optional error value can be an error constructor, regular expression, or a validation function returning a Boolean value.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.doesNotThrow(block, [error], [message])</code>: This is used to test whether the supplied code block does not throw an error.</li><li class="listitem" style="list-style-type: disc"><code class="literal">assert.fail(actual, expected, message, operator)</code>: This throws an exception. This is <a id="id768" class="indexterm"/>most useful when the exception is trapped by a try/catch block.</li></ul></div><p>A shortcut method to log assertion results is available in the <code class="literal">console</code> API:</p><div><pre class="programlisting">
<strong>&gt; console.assert(1 == 2, "Nope!")</strong>
<strong>AssertionError: Nope!</strong>
</pre></div><div><div><h3 class="title"><a id="note41"/>Note</h3><p>For a more <a id="id769" class="indexterm"/>detailed explanation of how comparison is done in JavaScript, consult <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators</a>.</p></div></div><p>Now, let's <a id="id770" class="indexterm"/>look at testing with more advanced testing frameworks<a id="id771" class="indexterm"/> and tools.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Testing with Mocha, Chai, Sinon, and npm</h1></div></div></div><p>One of the <a id="id772" class="indexterm"/>great<a id="id773" class="indexterm"/> benefits of writing tests <a id="id774" class="indexterm"/>for<a id="id775" class="indexterm"/> your code is that you will be <a id="id776" class="indexterm"/>forced to <a id="id777" class="indexterm"/>think through how what you've written <a id="id778" class="indexterm"/>works. A test that is difficult to write might indicate code that is difficult to<a id="id779" class="indexterm"/> understand. On the other hand, comprehensive coverage with good tests helps others (and you) understand how an application works.</p><p>There are at least three notions to consider when setting up your test environment.</p><p>The purpose of testing is to make comparisons between the value of what is received and what is expected by your application code. As we saw earlier, Node's <code class="literal">assert</code> module is designed for this purpose, but its functionality is limited to individual, isolated assertions. We'll use the<a id="id780" class="indexterm"/> Chai library (<a class="ulink" href="http://chaijs.com">http://chaijs.com</a>), which provides you with a richer choice of languages and idioms to make assertions with.</p><p>It is not unusual for an application to be covered by several hundred tests. When assertions are grouped, say by feature or business unit, these groups can provide a clearer picture of your application's state. Designing and instrumenting tools to do this grouping, especially with asynchronous code, is difficult. Thankfully, several well-known, well-designed test runners exist for you to use. We'll <a id="id781" class="indexterm"/>use Mocha (<a class="ulink" href="http://mochajs.org">http://mochajs.org</a>), which makes it easier to organize, control, and display the results of your tests.</p><p>Testing is normally done on development boxes and not in live production environments. How can you write tests for code that does not run in a real environment? For example, how do I test my code's ability to handle responses from a network endpoint that I cannot connect to locally? How do I check the arguments a function is being sent without rewriting the function? We'll use <a id="id782" class="indexterm"/>Sinon (<a class="ulink" href="http://sinonjs.org/">http://sinonjs.org/</a>), which lets you create synthetic methods and other simulations.</p><div><div><h3 class="title"><a id="note42"/>Note</h3><p>Other popular test runners<a id="id783" class="indexterm"/> are Jasmine (<a class="ulink" href="https://github.com/jasmine/jasmine">https://github.com/jasmine/jasmine</a>) and <a id="id784" class="indexterm"/>Vows (<a class="ulink" href="https://github.com/vowsjs/vows">https://github.com/vowsjs/vows</a>). Should (<a class="ulink" href="https://github.com/shouldjs/should.js">https://github.com/shouldjs/should.js</a>) is a<a id="id785" class="indexterm"/> popular assertion library.</p></div></div><p>To start <a id="id786" class="indexterm"/>with, set <a id="id787" class="indexterm"/>up a folder containing<a id="id788" class="indexterm"/> the<a id="id789" class="indexterm"/> following structure:</p><div><pre class="programlisting">scripts
spec
  helpers</pre></div><p>The <code class="literal">/scripts</code> folder <a id="id790" class="indexterm"/>contains<a id="id791" class="indexterm"/> the JavaScript we'll<a id="id792" class="indexterm"/> test. The <code class="literal">/spec</code> folder <a id="id793" class="indexterm"/>contains configuration and test files.</p><p>Now, initialize a <code class="literal">package.json</code> file with <code class="literal">npm init</code>. You can just hit <em>Enter</em> at the prompts, but when you are asked for a test command, enter the following:</p><div><pre class="programlisting">
<strong>mocha ./spec --require ./spec/helpers/chai.js --reporter spec</strong>
</pre></div><p>This will make more sense as we move forward. For now, recognize that this assignation to npm's <code class="literal">test</code> attribute asserts that we will use Mocha for testing. Mocha's test report will be of the <code class="literal">spec</code> type and that test will exist in the <code class="literal">/spec</code> directory. We will also require a configuration file for Chai, which will be explained in one of the following sections. Importantly, this has now created a script declaration in npm that will allow you to run your test suite with the <code class="literal">npm test</code> command. Use that command whenever you need to run the Mocha tests we'll be developing in the following section.</p><p>If you haven't already, install Mocha globally with <code class="literal">npm install mocha -g</code>. Also, install the local modules that we'll need for testing using the <code class="literal">npm install mocha chai sinon redis --save-dev</code> command.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec64"/>Mocha</h2></div></div></div><p>Mocha is <a id="id794" class="indexterm"/>a test runner that does not concern itself with test assertions <a id="id795" class="indexterm"/>themselves. Mocha is used to organize and run your tests, primarily through the use of the <code class="literal">describe</code> and <code class="literal">it</code>. operators. The following code shows this:</p><div><pre class="programlisting"> describe("Test of Utility Class", function() {
  it("Running #date should return a date", function(){
    // Test date function
  });
  it("Running #parse should return JSON", function() {
    // Run some string through #parse
  });
});</pre></div><p>As illustrated, the Mocha harness leaves open how the tests are described and organized and makes no assumptions about how test assertions are designed.</p><p>You can set up tests that run synchronously, as described in the preceding code, or asynchronously, using the completion handler passed to all <code class="literal">it</code> callbacks:</p><div><pre class="programlisting">describe("An asynchronous test", function() {
  it("Runs an async function", function(done) {
    // Run async test, and when finished call...
    done();
  });
});</pre></div><p>Blocks can also be nested:</p><div><pre class="programlisting">describe("Main block", function() {
  describe("Sub block", function() {
    it("Runs an async function", function() {
      // A test running in sub block
    });
  });
  it("Runs an async function", function() {
    // A test running in main block
  });
});</pre></div><p>Finally, Mocha offers <a id="id796" class="indexterm"/>
<em>hooks</em> that enable you to run code before and/or after tests:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">beforeEach()</code> runs before each test in a <code class="literal">describe</code> block</li><li class="listitem" style="list-style-type: disc"><code class="literal">afterEach()</code> runs <a id="id797" class="indexterm"/>after each test in a <code class="literal">describe</code> block</li><li class="listitem" style="list-style-type: disc"><code class="literal">before()</code> runs code once prior to any test—prior to any run of <code class="literal">beforeEach</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">after()</code> runs code once after all tests have run—after any run of <code class="literal">afterEach</code></li></ul></div><p>Usually, these are <a id="id798" class="indexterm"/>used to set up test contexts, such as creating variables before certain tests and cleaning those up prior to certain other tests.</p><p>This simple collection of tools is expressive enough to handle most testing needs. Additionally, Mocha provides various test reporters that offer differently formatted results. We'll see those in action later as we build realistic test scenarios.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec65"/>Chai</h2></div></div></div><p>As we saw<a id="id799" class="indexterm"/> earlier with Node's native <code class="literal">assert</code> module, at its base, testing involves <a id="id800" class="indexterm"/>asserting what we expect a chunk of code to do, executing that code, and checking whether our expectations were met. Chai is an assertion library with a <a id="id801" class="indexterm"/>more expressive syntax, offering<a id="id802" class="indexterm"/> three assertion styles: <strong>expect</strong>, <strong>should</strong>, and <strong>assert</strong>. We <a id="id803" class="indexterm"/>will use Chai to provide the assertions (tests) to be wrapped within Mocha <code class="literal">it</code> statements, favoring the <em>expect</em> style of assertion.</p><div><div><h3 class="title"><a id="note43"/>Note</h3><p>Note that while <code class="literal">Chai.assert</code> is modeled after the core Node <code class="literal">assert</code> syntax, Chai augments the object with additional methods.</p></div></div><p>To begin with, we are going to create a configuration file called <code class="literal">chai.js</code>:</p><div><pre class="programlisting">var chai = require('chai');
chai.config.includeStack = true;
global.sinon = require('sinon');
global.expect = chai.expect;
global.AssertionError = chai.AssertionError;
global.Assertion = chai.Assertion;</pre></div><p>Place this file in the <code class="literal">/spec/helpers</code> folder. This will tell Chai to display the full-stack trace of any errors and to expose the <code class="literal">expect</code> assertion style as a <code class="literal">global</code> variable. Similarly, Sinon is also exposed as a <code class="literal">global</code> variable. This file will augment the Mocha test run context such that we can use these tools without having to redeclare them in each test file.</p><p>The <code class="literal">expect</code> style of assertion reads like a sentence, with <em>sentences</em> composed from words like <em>to</em>, <em>be</em>, <em>is</em>, and more. Take the following code as an example:</p><div><pre class="programlisting">expect('hello').to.be.a('string')
expect({ foo: 'bar' }).to.have.property('foo')
expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });
expect(true).to.not.be.false
expect(1).to.not.be.true
expect(5).to.be.at.least(10) // fails</pre></div><p>To explore the<a id="id804" class="indexterm"/> extensive list of <em>words</em> available when you are creating <code class="literal">expect </code>test chains, consult <a id="id805" class="indexterm"/>the full documentation at <a class="ulink" href="http://chaijs.com/api/bdd/">http://chaijs.com/api/bdd/</a>.</p><p>As stated earlier, Mocha does not have an opinion on how you create assertions. We will use <code class="literal">expect</code> to create assertions in the tests that follow.</p><p>Consider testing the <code class="literal">capitalize</code> function in the following object:</p><div><pre class="programlisting">var Utils = function() {
  this.capitalize = function(str) {
    return str.split('').map(function(char) {
      return char.toUpperCase();
    }).join('');
  };
};</pre></div><p>We might do something like this:</p><div><pre class="programlisting">describe('Testing Utils', function() {
  var utils = new Utils();
  it('capitalizes a string', function() {
    var result = utils.capitalize('foobar');
    expect(result).to.be.a('string').and.equal('FOOBAR');
  });
});</pre></div><p>This Chai assertion will be <code class="literal">true</code> and Mocha will report the same results. This is shown in the following screenshot:</p><div><img src="img/1403OS_06_05.jpg" alt="Chai"/></div><p>Next, we'll look <a id="id806" class="indexterm"/>at how to add Sinon to our test process.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Sinon</h2></div></div></div><p>Within a testing <a id="id807" class="indexterm"/>environment, you typically emulate the realities of a production <a id="id808" class="indexterm"/>environment as access to real users, data, or other live systems is unsafe or otherwise undesirable. Being able to simulate environments is, therefore, an important part of testing. Also, you will often want to inspect more than just call results—you might want to test whether a given function is being called in the right context or with the right examples. Sinon is a tool that helps you to simulate external services, emulate functions, track function calls, and so on.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>The <code class="literal">sinon-chai</code> module <a id="id809" class="indexterm"/>extends Chai with Sinon assertions. For <a id="id810" class="indexterm"/>more information on <code class="literal">sinon-chai</code>, visit <a class="ulink" href="https://github.com/domenic/sinon-chai">https://github.com/domenic/sinon-chai</a>.</p></div></div><p>The key<a id="id811" class="indexterm"/> Sinon <a id="id812" class="indexterm"/>technologies are <strong>spies</strong>, <strong>stubs</strong>, and <strong>mocks</strong>. Additionally, you <a id="id813" class="indexterm"/>can set fake timers, create fake servers, and more (see <a class="ulink" href="http://sinonjs.org/">http://sinonjs.org/</a>). This section focuses on the first three. Let's go <a id="id814" class="indexterm"/>over examples of each.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec34"/>Spies</h3></div></div></div><p>Take a look at this<a id="id815" class="indexterm"/> text from the <a id="id816" class="indexterm"/>Sinon documentation that defines a test spy:</p><div><blockquote class="blockquote"><p><em>"A test spy is a function that records arguments, return value, the value of this and exception thrown (if any) for all its calls. A test spy can be an anonymous function or it can wrap an existing function."</em></p></blockquote></div><p>A spy gathers information on the function it is tracking. For example:</p><div><pre class="programlisting">var sinon = require('sinon');
var argA = "foo";
var argB = "bar";
var callback = sinon.spy();

callback(argA);
callback(argB);

console.log(
  callback.called,
  callback.callCount,
  callback.calledWith(argA),
  callback.calledWith(argB),
  callback.calledWith('baz')
);</pre></div><p>This will log the following:</p><div><pre class="programlisting">
<strong>true 2 true true false</strong>
</pre></div><p>The spy was<a id="id817" class="indexterm"/> called <a id="id818" class="indexterm"/>twice, once with <code class="literal">foo</code>, once with <code class="literal">bar</code>, and never with <code class="literal">baz</code>.</p><p>Let's suppose we wanted to test whether our code properly connects to the pub/sub functionality of Redis:</p><div><pre class="programlisting">var redis = require("redis");
var client1 = redis.createClient();
var client2 = redis.createClient();

//  Testing this
function nowPublish(channel, msg) {
  client2.publish(channel, msg);
};
describe('Testing pub/sub', function() {
  before(function() {
    sinon.spy(client1, "subscribe");
  });
  after(function() {
    client1.subscribe.restore();
  });
  it('tests that #subscribe works', function() {
    client1.subscribe("channel");
    expect(client1.subscribe.calledOnce);
  });
  it('tests that #nowPublish works', function(done) {
    var callback = sinon.spy();
    client1.subscribe('channel', callback);
    client1.on('subscribe', function() {
      nowPublish('channel', 'message');
      expect(callback.calledWith('message'));
      expect(client1.subscribe.calledTwice);
      done();
    });
  });
});</pre></div><p>In this example, we <a id="id819" class="indexterm"/>do more with spy and with Mocha. We deploy spy to proxy the<a id="id820" class="indexterm"/> native <code class="literal">subscribe</code> method of <code class="literal">client1</code>, importantly setting up and tearing down the spy proxy (restoring original functionality) within Mocha's <code class="literal">before</code> and <code class="literal">after</code> methods. The Chai assertions prove that both <code class="literal">subscribe</code> and <code class="literal">nowPublish</code> are functioning correctly and receiving the right arguments.</p><div><div><h3 class="title"><a id="note44"/>Note</h3><p>More information on <a id="id821" class="indexterm"/>spies can be found at <a class="ulink" href="http://sinonjs.org/docs/#spies">http://sinonjs.org/docs/#spies</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec35"/>Stubs</h3></div></div></div><p>A stub, when <a id="id822" class="indexterm"/>used as a spy, can be wrapped around an existing function such that it can fake the behavior of that function (rather than simply recording function execution as we saw earlier). Take a look at this definition of test stubs taken from the<a id="id823" class="indexterm"/> Sinon <a id="id824" class="indexterm"/>documentation:</p><div><blockquote class="blockquote"><p><em>"Test stubs are functions (spies) with pre-programmed behavior. They support the full test spy API in addition to methods which can be used to alter the stub's behavior."</em></p></blockquote></div><p>Let's assume that you have a functionality in your application that makes calls to an HTTP endpoint. The code may be something like the following:</p><div><pre class="programlisting">http.get("http://www.example.org", function(res) {
  console.log("Got status: " + res.statusCode);
}).on('error', function(e) {
  console.log("Got error: " + e.message);
});</pre></div><p>When it's successful, the call will log <code class="literal">Got status: 200</code>. Should the endpoint be unavailable, you'll see something like <code class="literal">Got error: getaddrinfo ENOTFOUND</code>.</p><p>It is likely that <a id="id825" class="indexterm"/>you will need to test the ability of your application to handle alternate <a id="id826" class="indexterm"/>status codes, and, of course, explicit errors. It may not be in your power to force endpoints to emit these, yet you must prepare for them should they occur. Stubs are useful here to create synthetic responses such that your response handlers can be comprehensively tested.</p><p>We can use stubs to emulate a response without actually calling the <code class="literal">http.get</code> method:</p><div><pre class="programlisting">var http = require('http');
var sinon = require('sinon');
sinon.stub(http, 'get').yields({
  statusCode: 404
});
// This URL is never actually called
http.get("http://www.example.org", function(res) {
  console.log("Got response: " + res.statusCode);
  http.get.restore();
});</pre></div><p>This stub yields a simulated response by wrapping the original method, which is never called, resulting in a <code class="literal">404</code> error being returned from a call that would normally return a status code of <code class="literal">200</code>. Importantly, note how we <code class="literal">restore</code> the stubbed method to its original state when we are done with it.</p><p>For example, the following <em>pseudo</em> code describes a module that makes HTTP calls, parses the response, and responds with <code class="literal">'handled'</code> if everything went OK and <code class="literal">'not handled'</code> if the HTTP response was unexpected:</p><div><pre class="programlisting">var http = require('http');
module.exports = function() {
  this.makeCall = function(url, cb) {
    http.get(url, function(res) {
      cb(this.parseResponse(res));
    }.bind(this))
  }
  this.parseResponse = function(res) {
    if(!res.statusCode) {
      throw new Error('No status code present');
    }
    switch(res.statusCode) {
      case 200:
      return 'handled';
      break;
      case 404:
      return 'handled';
      break;
      default:
      return 'not handled';
      break;
    }
  }
}</pre></div><p>The following Mocha test ensures that the <code class="literal">Caller.parseReponse</code> method can handle all response <a id="id827" class="indexterm"/>codes <a id="id828" class="indexterm"/>we need handled using stubs to simulate the entire expected response range:</p><div><pre class="programlisting">var Caller = require('../scripts/Caller.js');

describe('Testing endpoint responses', function() {
  var caller = new Caller();
  function setTestForCode(code) {
    return function(done) {
      sinon.stub(caller, 'makeCall').yields(caller.parseResponse({
        statusCode: code
      }));
      caller.makeCall('anyURLWillDo', function(h) {
        expect(h).to.be.a('string').and.equal('handled');
        done();
      });
    }
  }
  afterEach(function() {
    caller.makeCall.restore();
  });
  it('Tests 200 handling', setTestForCode(200));
  it('Tests 404 handling', setTestForCode(404));
  it('Tests 403 handling', setTestForCode(403));
});</pre></div><p>By proxying the original <code class="literal">makeCall</code> method, we can test <code class="literal">parseResponse</code> against a range of status codes without the difficulty of forcing remote network behavior. Noting that the preceding test should fail (there is no handler for 403 codes), the output of this test should look something like the following:</p><div><img src="img/1403OS_06_03.jpg" alt="Stubs"/></div><p>The full API<a id="id829" class="indexterm"/> for stubs<a id="id830" class="indexterm"/> can be seen at <a class="ulink" href="http://sinonjs.org/docs/#stubs">http://sinonjs.org/docs/#stubs</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec36"/>Mocks</h3></div></div></div><p>Rather than <a id="id831" class="indexterm"/>checking expectations <em>after the fact</em>, mocks can be used to check whether<a id="id832" class="indexterm"/> the unit under test is being used correctly—they enforce implementation details. Take a look at this definition of mocks taken from the Sinon documentation:</p><div><blockquote class="blockquote"><p><em>"Mocks (and mock expectations) are fake methods (like spies) with pre-programmed behavior (like stubs) as well as pre-programmed expectations. A mock will fail your test if it is not used as expected."</em></p></blockquote></div><p>In the following example, we check not only the number of times a specific function is called (easy with spies) but also whether it is called with specific, expected arguments. Specifically, we again test the <code class="literal">capitalize</code> method of<code class="literal"> Utils</code>, this time using mocks:</p><div><pre class="programlisting">var sinon = require('sinon');
var Utils = require('./Utils.js');
var utils = new Utils();
var arr = ['a','b','c','d','e'];
var mock = sinon.mock(utils);

// Expectations
mock.expects("capitalize").exactly(5).withArgs.apply(sinon,arr);

arr.map(utils.capitalize);
console.log(mock.verify());</pre></div><p>After setting up a mock on <code class="literal">utils</code>, we map a five-element array to <code class="literal">capitalize</code>, expecting <code class="literal">capitalize</code> to be called exactly five times, with the array's elements as arguments (using <code class="literal">apply</code> to spread the array into individual arguments). The well-named <code class="literal">mock.verify</code> function is then checked to see whether our expectations were satisfied. As usual, when we are done with it, we unwrap the <code class="literal">utils</code> object with <code class="literal">mock.restore</code>. You should see <code class="literal">true</code> logged to your terminal.</p><p>Now, remove <a id="id833" class="indexterm"/>one element from the tested array, frustrating expectations. When <a id="id834" class="indexterm"/>you run the test again, you should see the following near the top of the output:</p><div><pre class="programlisting">
<strong>ExpectationError: Expected capitalize([...]) 5 times (called 4 times)</strong>
</pre></div><p>This should clarify the type of test results that mocks are designed to produce.</p><div><div><h3 class="title"><a id="note45"/>Note</h3><p>Note that mocked functions do not execute—<code class="literal">mock</code> overrides its target. In the preceding example, no array members are ever run through <code class="literal">capitalize</code>.</p></div></div><p>Let's revisit our earlier example, this time testing Redis pub/sub using mocks:</p><div><pre class="programlisting">var redis = require("redis");
var client = redis.createClient();

describe('Mocking pub/sub', function() {
  var mock = sinon.mock(client);
  mock.expects('subscribe').withExactArgs('channel').once();
  it('tests that #subscribe is being called correctly', function() {
    client.subscribe('channel');
    expect(mock.verify()).to.be.true;
  });
});</pre></div><p>Rather than checking for conclusions, here we assert our expectation that the mocked <code class="literal">subscribe </code>method will receive the exact argument <code class="literal">channel</code> only <code class="literal">once</code>. Mocha expects <code class="literal">mock.verify</code> to return <code class="literal">true</code>. To make this test fail, add one more <code class="literal">client.subscribe('channel')</code> line, producing something like the following:</p><div><pre class="programlisting">
<strong>ExpectationError: Unexpected call: subscribe(channel)</strong>
</pre></div><div><div><h3 class="title"><a id="note46"/>Note</h3><p>More information on <a id="id835" class="indexterm"/>how to use mocks can be found at <a class="ulink" href="http://sinonjs.org/docs/#mocks">http://sinonjs.org/docs/#mocks</a>.</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Automated browser testing with PhantomJS and CasperJS</h1></div></div></div><p>One way to test <a id="id836" class="indexterm"/>whether a UI is working is to <a id="id837" class="indexterm"/>pay several people to interact with <a id="id838" class="indexterm"/>a website via a browser and report any errors they find. This can become a very expensive and ultimately unreliable <a id="id839" class="indexterm"/>process. Also, it requires putting potentially failing code into production in order to test it. It is better to test whether application views are rendering correctly from within the build process itself prior to releasing any views "into the wild". PhantomJS was created to address this need, among others.</p><p>A browser, stripped of its buttons and other controls, is, at its heart, a program that validates and runs JavaScript, HTML, and CSS. That the validated HTML is rendered visually on your screen is simply a consequence of humans being able to see only with their eyes. A server can interpret the logic of compiled code and see the results of interactions with that code without a visual component. Perhaps because eyes are usually found in one's head, a browser running on a server is typically referred to as a headless browser. PhantomJS provides a headless version of the WebKit engine that is scriptable via a JavaScript API.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec67"/>Headless testing with PhantomJS</h2></div></div></div><p>PhantomJS (<a class="ulink" href="http://phantomjs.org/build.html">http://phantomjs.org/build.html</a>) allows<a id="id840" class="indexterm"/> you to create <a id="id841" class="indexterm"/>scripts that can be executed in a headless browser context. It allows<a id="id842" class="indexterm"/> you to capture a browser context within a scriptable environment, enabling various operations, such as loading an HTML page into that context. This allows you to perform operations on that browser context, such as manipulating the DOM of a loaded page.</p><p>For example, fetching a Twitter user's recent tweets can be accomplished by hitting the following endpoint in your browser: <code class="literal">http://mobile.twitter.com/&lt;twitter user&gt;</code>. We can also use PhantomJS to do the same thing within a headless, scriptable environment and then write code to fetch those tweets. Create a <code class="literal">phantom-twitter.js</code> file containing the following code:</p><div><pre class="programlisting">var page = require('webpage').create();
var system = require('system');
var fs = require('fs');
var twitterId = system.args[1];

page.open(encodeURI("http://mobile.twitter.com/" + twitterId), function(status) {
  if(!status) {
    throw new Error("Can't connect to Twitter!");
  }
  var tweets = page.evaluate(function() {
    var _tweets = [];
    var coll = Array.prototype.slice.call(document.querySelectorAll('div.tweet-text'))
    coll.forEach(function(tweet) {
      _tweets.push(tweet.innerText);
    });
    return _tweets
  });
  fs.write(twitterId + '.json', JSON.stringify(tweets));
  phantom.exit();
});</pre></div><p>Now, use the<a id="id843" class="indexterm"/> CLI to pass that script to PhantomJS, sending<a id="id844" class="indexterm"/> the Twitter handle of the person you'd like to read as an argument:</p><div><pre class="programlisting">
<strong>phantomjs phantom-twitter.js kanyewest</strong>
</pre></div><p>A new file called <code class="literal">kanyewest.json</code> will be created, containing recent tweets in the JSON format. Let's examine the code.</p><p>We first require some of PhantomJS's core modules, importantly the <code class="literal">page</code> library that allows us to load pages, and the <code class="literal">system</code> and<code class="literal"> fs</code> modules (which resemble Node's <code class="literal">process </code>and <code class="literal">fs</code> modules, respectively). We'll use <code class="literal">system</code> to fetch command-line arguments and <code class="literal">fs</code> to write fetched tweets to the filesystem.</p><p>The <code class="literal">page.open</code> command does what you would expect—loading a web page into the PhantomJS context. We can now perform operations on the rendered DOM. In this case, we are going to use <code class="literal">evaluate</code> on JavaScript within the context of that page, fetching the elements containing tweets identified by the <code class="literal">div.tweet-text</code> CSS selector and stripping out <code class="literal">innerText</code>. Because <code class="literal">evaluate</code> is running in the context of a headless WebKit, there is no way for us to access the outer PhantomJS scope, so we simply return what we find within the evaluation scope to the outer scope, where a file can be generated using <code class="literal">fs</code>.</p><p>PhantomJS offers <a id="id845" class="indexterm"/>an extensive API to interact with WebKit (<a class="ulink" href="http://phantomjs.org/api/">http://phantomjs.org/api/</a>), allowing script injection, creating screen captures, navigating rendered pages, and so on. A whole range of client tests can be created using these tools.</p><p>When <a id="id846" class="indexterm"/>writing server tests, you will probably <a id="id847" class="indexterm"/>not want to use PhantomJS from the CLI. For this reason, various Node-PhantomJS bridges have been written that let you interact with PhantomJS via a Node module. A good one is <code class="literal">phantomjs</code> (<a class="ulink" href="https://github.com/sgentle/phantomjs-node">https://github.com/sgentle/phantomjs-node</a>). For example, the following will load a page, as shown <a id="id848" class="indexterm"/>earlier, and execute JavaScript to fetch the page's title attribute:</p><div><pre class="programlisting">var phantom = require('phantom');
phantom.create(function(ph) {
  ph.createPage(function(page) {
    page.open("http://www.example.org", function(status) {
      page.evaluate(function() {
        return document.title;
      }, function(title) {
        console.log('Page title: ' + title);
        ph.exit();
      });
    });
  });
});</pre></div><p>Running the preceding code should result in something like the following being logged:</p><div><pre class="programlisting">
<strong>Page title: Example Domain</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Navigation scenarios with CasperJS</h2></div></div></div><p>Because PhantomJS is not specifically designed to be a test runner, others have created tools to <a id="id849" class="indexterm"/>simplify<a id="id850" class="indexterm"/> testing with PhantomJS. <strong>CasperJS</strong> (<a class="ulink" href="http://casperjs.org/">http://casperjs.org/</a>) is a navigation and testing utility for PhantomJS <a id="id851" class="indexterm"/>and<strong> SlimerJS</strong> (which uses the Gecko engine that <a id="id852" class="indexterm"/>powers Firefox).</p><p>CasperJS offers an extensive toolkit to create complex chains of interactions using an expressive Promises-like interface. Describing page interaction tests with CasperJS requires much less code and is clearer. For example, the earlier <code class="literal">phantom</code> example demonstrating how to fetch a page title can be simplified:</p><div><pre class="programlisting">casper.start('http://example.org/', function() {
  this.echo('Page title: ' + this.getTitle());
});
casper.run();</pre></div><p>If the preceding code were saved as a file called <code class="literal">pagetitle.js</code> and run with the <code class="literal">casperjs test pagefile.js</code> command, you would see the following logged:</p><div><pre class="programlisting">
<strong>Page title: Example Domain</strong>
</pre></div><p>A much terser syntax produces identical results. Let's look at another example that demonstrates <a id="id853" class="indexterm"/>how to fetch one page, click on a link on that page, and read some information from the resulting page:</p><div><pre class="programlisting">casper.start('http://google.com/', function() {
  this
  .thenEvaluate(function(term) {
    document.querySelector('input[name="q"]').setAttribute('value', term);
    document.querySelector('form[name="f"]').submit();
  }, 'node.js')
  .then(function() {
    this.click('h3.r a');
  })
  .then(function() {
    this.echo('New location: ' + this.getCurrentUrl());
  });
});
casper.run();</pre></div><p>Here, we can see how a Promise-like chaining of interactions results in clear and expressive code. After fetching Google's search page, we will evaluate a piece of JavaScript that inserts the <code class="literal">node.js</code> string into its famous search box and submit the search form. Then, CasperJS is asked to click on the first result link (<code class="literal">h3.r a</code>) and to finally display the current URL:</p><div><pre class="programlisting">
<strong>New location: http://nodejs.org/</strong>
</pre></div><p>This demonstrates that a full-page navigation has occurred, at which point we can chain even more interaction steps.</p><p>Finally, let's use some of the CasperJS test assertions and demonstrate how to take snapshots of web pages while testing Google's translation service:</p><div><pre class="programlisting">casper.start('http://translate.google.com/', function() {
  this
  .sendKeys('#source', 'Ciao')
  .waitForText('Hello')
  .then(function() {
    this.test.assertSelectorHasText('#result_box', 'Hello');
  })
  .then(function() {
    this.capture('snapshot.png');
  });
});
casper.run();</pre></div><p>Google's translation page is dynamic. As you type into the translation box, the service detects keyboard<a id="id854" class="indexterm"/> events, attempts to infer the language you are using based on any available text, and, in "real time", provides a translation, all without refreshing the page. In other words, we are not submitting a form and waiting for the resulting page.</p><p>Therefore, once we have the page loaded, we send keystrokes (<code class="literal">sendKeys</code>) into the <code class="literal">#source</code> input box with the Italian word <code class="literal">"Ciao"</code>. Testing that this results in the correct translation, we wait for <code class="literal">"Hello"</code> to arrive—<code class="literal">waitForText</code> fires when the text passed appears on a page. To ensure that the text has arrived in the right place, we assert that the element with the <code class="literal">#result_box</code> selector contains <code class="literal">"Hello"</code>. If all is well, you will see the following logged:</p><div><pre class="programlisting">
<strong>PASS Find "Hello" within the selector "#result_box"</strong>
</pre></div><p>Additionally, within the same folder, you will find the <code class="literal">snapshot.png</code> image visualizing the DOM-based interactions just executed:</p><div><img src="img/1403OS_06_04.jpg" alt="Navigation scenarios with CasperJS"/></div><p>Hopefully, this <a id="id855" class="indexterm"/>demonstrates how CasperJS can be used to harness the power of PhantomJS when you're writing client tests. If you'd like to use CasperJS as a Node module, give <a id="id856" class="indexterm"/>SpookyJS (<a class="ulink" href="https://github.com/SpookyJS/SpookyJS">https://github.com/SpookyJS/SpookyJS</a>) a try.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Summary</h1></div></div></div><p>In this chapter, we took a look at testing and building your application such that you can get a good sense of its ability to <em>stand up</em> in production. We worked through a representative build system that used Gulp and Browserify, along with some other tools, to show how a codebase can be optimized and packaged for deployment. Also, you learned about Node's native debugging tools and assertion library.</p><p>The Node community has embraced testing from the beginning, and many testing frameworks and native tools are made available to developers. You learned how to set up a proper test system using Gulp, Mocha, Chai, and Sinon, in the process experimenting with headless browser testing.</p><p>The next chapter will be focused on taking the builds you have tested and deploying them to production servers. You'll learn about setting up local development environments on virtual machines, provisioning remote servers, setting up continuous integration with webhooks and Jenkins, maintaining your application dependencies and, generally, keeping your applications running smoothly as changes are made.</p></div></body></html>