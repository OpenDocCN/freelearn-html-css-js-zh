<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Alternative View Components</h1></div></div></div><p>The Flux documentation doesn't have a whole lot to say about view components. And yet, views are an essential part of any Flux architecture. Perhaps what the Flux authors really mean is that Flux doesn't really care about the mechanisms used to render our views—just as long as they're rendered somehow.</p><p>It's no secret that Flux was designed with React in mind. Facebook had already built React for their view components—Flux was the missing piece that allows them to formulate a full-fledged, frontend architecture. We'll start this chapter off with a discussion on what makes React such a good fit for Flux architectures. Then we'll weigh these benefits against the downsides of React.</p><p>Next, we'll spend some time building views using jQuery and the Handlebars template engine. These are two popular technologies that have likely crossed the path of any given developer at some point. We'll then close the chapter by thinking about views that don't require specific rendering technology, allowing us to be nimble about our views and adopt the new hotness when it arrives.</p><div><div><div><div><h1 class="title"><a id="ch11lvl1sec65"/>ReactJS is a good fit for Flux</h1></div></div></div><p>It's no surprise that React is a good<a id="id397" class="indexterm"/> fit for Flux architectures. Both technologies were created by the<a id="id398" class="indexterm"/> same company, and they both solve complimentary problems. In this section, we'll dive into some of the details of what it is <a id="id399" class="indexterm"/>about React that makes it work so well with Flux. We'll start by looking at the unidirectional flows found in both Flux and React. Next, we'll discuss the idea that re-rendering DOM structures is easier than manipulating specific DOM nodes, and why this is a good fit for store change event handlers. Finally, we'll talk about the relatively small code footprint of React components.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec133"/>ReactJS is unidirectional</h2></div></div></div><p>The data-flow in a Flux<a id="id400" class="indexterm"/> architecture is unidirectional. It starts with an action and ends with view updates—there's no other way for data to get into a view component. React itself shares this same unidirectional philosophy with Flux. Data flows into a root React component and trickles down into any components used to compose the root. This process is recursive down the component hierarchy.</p><p>Data flows into Flux stores<a id="id401" class="indexterm"/> through actions, and flows out as change events. React components keep this unidirectional flow going. Once the React component has re-rendered itself based on the store state, the flow is done. The only option is to start all over again by dispatching a new action. The flow between Flux and React components is illustrated here:</p><div><img src="img/B05419_11_01.jpg" alt="ReactJS is unidirectional"/></div><p>The first three items in our data flow are Flux entities. Any given data flow is kicked off when an action is dispatched. The action itself then enters the dispatcher and is sent to every store. Then the store makes any state changes as appropriate. From here, the data-flow is handed off to the React component. This is where we've specified the structure of the markup we want to render, using JSX. The component then consults with the virtual DOM to figure out what changes, if any, should be made in the actual DOM. Once these changes are made, the end of the data-flow has been reached.</p><p>The flow that we've outlined here for React components wouldn't look any different even if they weren't part of a Flux architecture. The Flux components just add predictable state changes in a<a id="id402" class="indexterm"/> synchronous way, before handing the data off to components for rendering. Without Flux, React would still need to start from the top and pass data down so that the re-rendering process can start. This fits nicely with the change events that are emitted by the Flux stores.</p><p>What doesn't fit so well with React is the idea of two-way data binding. Some people love the idea and have found ways to make it work with React, but I digress. For two-way binding to be effective, our view components need to be in close proximity to mutable data. Then, the view can listen directly to this data in order to re-render itself. We're not setup to handle this with Flux architectures, let alone React. The idea that we can directly mutate the state of something without first entering a work-flow that manages the synchronous update of application-wide state, goes against every idea of Flux. Put simply, Flux architectures favor unidirectional data-flows with predictable outcomes and React helps with this mission.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec134"/>Re-rendering new data is easy</h2></div></div></div><p>One thing about ReactJS<a id="id403" class="indexterm"/> that really stands out is it's ability to re-render entire DOM trees. Well, any JavaScript code can replace an existing DOM tree by building it again. React uses what's called a virtual DOM to compare the existing elements that the user is currently looking at, against the new elements that we've just rendered. Instead of replacing the entire tree, React will only touch the DOM in places where the two trees differ. Aside from the heuristics React has built into it, the fundamental performance edge comes from the fact that the virtual DOM is in JavaScript memory—we don't have to query the real DOM for elements. It's querying the DOM that can have negative performance implications.</p><p>To get around these performance issues, our view code can issue specific queries that are efficient to run, and only fetch the exact elements we need. Our view code can also cache the specific elements that it needs. The problem with this approach is that it feels fragmented once we have more than a few view components. It's difficult for components to share code when they're all tailored for their own specific performance requirements, and this is highly dependent on the DOM structure of the component.</p><p>It's more natural for programmers to be able to say <em>here's a snapshot of what these view elements should look like at this point in time</em>. We shouldn't have to pick apart the DOM structure and say that this <code class="literal">div</code> should look like this while this <code class="literal">span</code> should be hidden and so on. This is why JSX works; we can more easily visualize what the output of our component is going to look like,<a id="id404" class="indexterm"/> because it's structured like the elements are structured.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec135"/>Small code footprint</h2></div></div></div><p>React components generally<a id="id405" class="indexterm"/> have less code than view components that have lots of imperative DOM manipulation code. React doesn't have this type of code because it just needs to express the structure of the DOM through JSX. However, without Flux as the architecture, an application that uses React will probably find that the React components contain much more data transformation code.</p><p>For example, when React components are mounted into the DOM, we might need to perform some kind of transformation on data that comes from some source, perhaps an AJAX response. With Flux, the source is always the state of the store, so we know that the data transforms have already happened by the time they're handed off to the React views. Remember, it's the views that drive the structure of our store state, not the stores that drive how our views must be structured.</p><p>Event-handling code is another area where React components can have a small code footprint. Well, there's really two dimensions to this. First, event handlers in React are declared right in the JSX, so they're as much a part of the DOM tree structure as any other element properties—there's no need to insert the elements into the DOM and then look them up again later so we can attach an event handler function to them. The second dimension isn't actually specific to React, but more of a Flux phenomenon. The event handlers themselves are usually just action creator functions. All the logic that would have been in our views is now part of our stores.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec66"/>The downsides of ReactJS</h1></div></div></div><p>Now that you have <a id="id406" class="indexterm"/>a good handle on the benefits of using ReactJS as the view layer<a id="id407" class="indexterm"/> in a Flux architecture, it's time to look at some of the downsides. Everything has negative tradeoffs—there's no such thing as a perfect technology. So these things are worth considering in the context of a Flux architecture for your application.</p><p>First, we'll consider memory consumption. React is a fairly big library and has a noticeable impact on application load time. However, this is of minor concern compared to the amount of memory consumed by the virtual DOM. Next, we'll look at introducing JSX syntax into our JavaScript modules and the problems that might introduce for those not accustomed to blending other languages into their JavaScript modules.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec136"/>Virtual DOM and memory</h2></div></div></div><p>JavaScript applications should strive to be as memory-efficient as possible. Those that don't feel bloated and <a id="id408" class="indexterm"/>unresponsive to the user. Applications that use a lot of memory are inherently slower than those that use less memory because they<a id="id409" class="indexterm"/> need to perform more work. For example, if we need to look something up in a collection, it's obviously going to take more compute resources if the collection has a ton of objects in it, as opposed to a collection that's much smaller. Another place this can hurt application performance is during garbage collection. This is less of an issue if we have huge collections that are allocated and never freed (possibly due to other problems like leaks). But the more common behavior is to allocate large amounts of memory in response to a user action, then to deallocate that memory when the user moves on. This behavior will trigger frequent garbage collection runs, which translates to pauses in responsiveness.</p><p>The architecture of React requires more memory than alternative approaches to memory. This is due to the virtual DOM that React maintains. This in-memory structure is meant to reflect the structure of the real DOM. It doesn't track every single piece of data about every element that the real DOM has. It only tracks the data that's necessary to compute diffs. Here's an illustration of the mapping between our component, the virtual DOM, and the real DOM:</p><div><img src="img/B05419_11_02.jpg" alt="Virtual DOM and memory"/></div><p>The elements in our React component aren't necessarily occupying much memory, because they're just the declarative part of the component that specify which elements to use and which property values they should have. The virtual DOM reflects the structure and properties as specified in our JSX; these elements actually do occupy memory. Finally, we have the real DOM elements that the user sees and interacts with. These occupy a significant amount of memory too.</p><p>The main challenge with this approach is that we're doubling-up on anything that's rendered in the DOM. Put another way, the virtual DOM adds to the total memory consumed by our DOM elements out of necessity. Without the virtual DOM, React and JSX is just another template engine. The virtual DOM solves performance issues in other places. The main area where React excels performance-wise is efficient DOM API interactions, because the virtual DOM eliminates the need for many of these calls.</p><p>Is the memory consumed by your typical React application a showstopper? Absolutely not. Memory is quickly <a id="id410" class="indexterm"/>becoming a commodity, even in the mobile space. So if we <a id="id411" class="indexterm"/>can allocate more memory to solve real performance issues, we should by all means do so. However, there are cases where excessive memory allocation can become a problem with React applications. For instance, what if we simply need to render lots of elements? When and if this becomes a performance issue, your best bet is to probably design for fewer elements.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec137"/>JSX and markup</h2></div></div></div><p>JSX is essentially HTML (well, XML technically) mixed in with JavaScript code. If your initial response to this<a id="id412" class="indexterm"/> approach wasn't favorable, you're not alone. Over a long period of time, decades actually, we've been conditioned to separate our concerns. Something<a id="id413" class="indexterm"/> like HTML should never be in the same module as the JavaScript logic that controls when and how that markup is displayed. If we've been living through the separation-of-concerns principle for so many years, it's only natural to balk at the notion of combining to concerns into a single module.</p><p>It's quite possible that the last project you worked on involved specifying markup in template files. These templates are then fed into the view layer for rendering. Coming to Flux from this setting might be a little too much to take in all at once. On one hand, we have a whole new unidirectional data-flow to think about. On the other hand, we're talking about throwing out everything we've worked so hard to build into separate layers.</p><p>Let's not forget the fact that the separation of concerns principle does serve a purpose. If two concerns are implemented in two different places, there's less chance that a change in one concern will impact the other. Think of having templates as a way to compartmentalize the visual aspect of any given component. We can, in theory at least, give the design team free reign over the templates and not have to worry about them breaking the JavaScript implementation of the component.</p><p>If you've learned anything so far in this book, it's probably that there's a lot more to the complexities of UI components than the sum of their parts. Flux tries to acknowledge these complexities by explicitly modeling them in stores. There's a strict ordering and synchronicity to updating the UI in Flux for a reason: predictability despite all the complexity involved. What does this have to do with JSX, you might ask? Well, before discounting it as something that violates the separation of concerns principle, think about how well it fits with Flux stores. Also consider the idea that markup and the logic that renders it might be the same concern after all.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec138"/>Vendor lock-in</h2></div></div></div><p>Have you ever heard someone say something along the lines of <em>I'm using library x because I don't want to be locked into library y?</em> Vendor lock-in is a tricky area to navigate. Although these <a id="id414" class="indexterm"/>days, where most projects rely on open source projects, it's more like <em>technology approach lock-in</em>. I would be remiss if I didn't at least mention the subject here with regard to Flux and React.</p><p>Once we start using React and JSX, we've pretty much rolled the dice. It's a safe bet for more reasons than it's an unsafe one. Nonetheless, we've started down a path that's very difficult to get off, which is essentially the point of these past three sections. Even if your mind is 95% made up on choosing React, you'll sleep better at night knowing that you've weighed the tradeoffs.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec67"/>Using jQuery and Handlebars</h1></div></div></div><p>Both jQuery and Handlebars<a id="id415" class="indexterm"/> are pervasive technologies in modern web applications. There's a high probability<a id="id416" class="indexterm"/> that someone new to Flux has used one or both of these technologies, so we'll spend this section implementing some views that use both jQuery and Handlebars.</p><p>We'll start with a discussion on what makes jQuery and Handlebars a good fit for implementing view components. Then, we'll implement a basic view that uses these technologies to render the state of Flux stores. After this, we'll think about the various ways that we can compose larger views out of smaller parts and how to best handle user events.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec139"/>Why jQuery and Handlebars?</h2></div></div></div><p>Before there were <a id="id417" class="indexterm"/>JavaScript frameworks, there was jQuery. This small library set out to solve cross-browser issues prevalent in frontend development, and in <a id="id418" class="indexterm"/>general to make development more pleasant. Today, jQuery is still a dominant player in the JavaScript library game. Many larger frameworks depend on jQuery, because it's so effective and the barrier to learn how it works is so low.</p><p>One thing that jQuery isn't so great at is specifying the layout of UI components using HTML. For example, we can use jQuery to construct new elements and insert them into the DOM on the fly. However, something about this approach feels cumbersome and unnatural. It's often clearer to be able to write the HTML using the same structure as it would appear on the page. This removes a layer of indirection and makes it easier for us to map the markup to the rendered output.</p><p>Enter Handlebars. This library adds a sophisticated template engine to our frontend. Writing Handlebars templates means that we can write HTML, along with some specific Handlebars syntax for the dynamic bits, and avoid the mess of trying to assemble elements using jQuery. Both libraries are complimentary to one another. We have Handlebars templates that declare the structure of our application, and we use the Handlebars rendering engine to<a id="id419" class="indexterm"/> render this structure. Then, jQuery can handle every <a id="id420" class="indexterm"/>other aspect of the view components, such as selecting DOM elements and handling events. Let's see how this looks in the context of a Flux architecture by implementing a view that renders a Handlebars template.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec140"/>Rendering templates</h2></div></div></div><p>Let's start by covering the<a id="id421" class="indexterm"/> most basic usage scenario—rendering a Handlebars template into a DOM element using jQuery. Let's first start by looking at the Handlebars template file itself:</p><div><pre class="programlisting">&lt;p&gt;&lt;strong&gt;First: &lt;/strong&gt;{{first}}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Last: &lt;/strong&gt;{{last}}&lt;/p&gt;</pre></div><p>As you can see, this is essentially basic HTML with a bit of specialized Handlebars syntax mixed in for the dynamic parts. This template is stored inside of a <code class="literal">.hbs</code> file (short for <em>handlebars</em>—some people use the full <code class="literal">.handlebars</code> extension). We can update our Webpack configuration to add the Handlebars loader. This parses and compiles the <code class="literal">.hbs</code> templates for us, meaning that our code that uses these templates can import them just like regular JavaScript modules. Let's take a look at what this looks like in our view component:</p><div><pre class="programlisting">// Imports the compiled Handlebars "template"
// function just like a regular JavaScript module.
import template from './my-view.hbs';
import myStore from '../stores/my-store';

export default class MyView {
  constructor(element) {

    // Sets the container element that
    // we'll use to place the rendered template
    // content. Expected to be a jQuery object.
    this.element = element;

    // When the store state changes, we can
    // re-render the view.
    myStore.on('change', (state) =&gt; {
      this.render(state);
    });
  }

  // Renders the view. The default state is
  // the initial "myStore.state". We use the
  // "element" property of the view to set the
  // HTML to the rendered output of the Handlebars
  // "template()".
  render(state = myStore.state) {
    this.element.html(template(state));
    return this;
  }
}</pre></div><p>The <code class="literal">template()</code> function that this view module imports is created as the result of the Webpack plugin compiling<a id="id422" class="indexterm"/> the template into a function for us. The runtime for Handlebars is included as part of the bundle that Webpack creates. The <code class="literal">render()</code> method of our view component calls the <code class="literal">template()</code> function, passing it a context and using the return value as the new content for the view's element. The context is just the state of the store, and each time the store state changes, the <code class="literal">html()</code> jQuery function is used to replace the existing element content.</p><div><div><h3 class="title"><a id="note28"/>Note</h3><p>The fundamental difference between ReactJS and an approach such as this one that uses the Handlebars templating engine, is that React attempts to make small updates. With Handlebars, we could end up replacing a lot of DOM content, and the performance issues could become noticeable by users. To combat these sorts of problems, we have to change the way our application is composed. This in and of itself could put us at a disadvantage compared to using something like React where we can re-render large DOM structures and still be efficient.</p></div></div><p>Now, let's take a look at the store that drives the content of this view:</p><div><pre class="programlisting">import { EventEmitter } from 'events';

import dispatcher from '../dispatcher';
import { MY_ACTION } from '../actions/my-action';

// The initial state of the store. Instead of
// empty strings, this state uses labels that
// indicate that there's still data to come.
var state = {
  first: 'loading...',
  last: 'loading...'
};

class MyStore extends EventEmitter {
  constructor() {
    super();

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {

        // When the "MY_ACTION" action is
        // dispatched, we extend the state
        // with the value of "payload",
        // overriding any existing property values.
        case MY_ACTION:
          this.emit('change',
            (state = Object.assign(
              {},
              state,
              e.payload
            ))
          );
          break;
      }
    });
  }

  get state() {
    return state;
  }
}

export default new MyStore();</pre></div><p>This is a fairly typical store—not unlike most stores that we've seen so far in this book. The payload that's<a id="id423" class="indexterm"/> dispatched as part of the <code class="literal">MY_ACTION</code> action is used to extend the state of the store and will override existing property names, if any. Let's take a look at the main program now:</p><div><pre class="programlisting">import $ from 'jquery';

import { myAction } from './actions/my-action';
import MyView from './views/my-view';

// Constructs the new view and performs the
// initial render by calling "render()". Note
// that there's now stored reference to this view,
// because we don't actually need to. If we
// did, "render()" returns the view instance.
new MyView($('#app')).render();

// After 1 second, dispatch "MY_ACTION", which
// will replace the "loading..." labels.
setTimeout(() =&gt; {
  myAction({
    first: 'Face',
    last: 'Book'
  });
}, 1000);</pre></div><p>This is where we initialize the instance of our view component, passing it a jQuery instance. This jQuery object represents the <code class="literal">#app</code> element, and is used by the view to hold the rendered Handlebars<a id="id424" class="indexterm"/> template content. After a one second delay, we call <code class="literal">myAction()</code>, which causes the <code class="literal">myStore</code> state to change and the handlebars template to re-render.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Generally, what happens when our Handlebars templates start getting bigger, we'll start adding specialized handlers that only respond to specific store properties. The reason is that the properties change too frequently and they only impact a tiny section of the visible UI. These micro-handlers then proliferate, and we start to lose predictability because we're introducing more paths into the rendering code. With ReactJS, this is less likely to happen, because we seldom have to decompose our view updates like this.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec141"/>Composing views</h2></div></div></div><p>If we're using Handlebars templates as the main ingredient of our view components, we probably need the ability to <a id="id425" class="indexterm"/>decompose our templates into smaller chunks. Think about the way we decompose our React components—we end up with smaller components that can usually be shared across features. Using Handlebars templates, we can achieve something similar using partial templates. The partial is a smaller part that fits into a larger whole to form the template that gets rendered by the view component.</p><p>Let's start by looking at a Handlebars template that serves as the list view for a store that has an array of user data:</p><div><pre class="programlisting">&lt;ul&gt;
  {{#each users}}
  &lt;li&gt;{{&gt; item-view}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p>This template is iterating over the <code class="literal">users</code> property of our store, which is an array. However, instead of directly rendering each item, it's simply referring to a partial template using special syntax. Let's look at this partial template now, so we can get a sense of what's being passed to it:</p><div><pre class="programlisting">&lt;span style="text-transform: capitalize"&gt;{{first}}&lt;/span&gt;
&lt;span style="text-transform: capitalize"&gt;{{last}}&lt;/span&gt;</pre></div><p>In this template, we don't have to qualify the properties that are used in this case: <code class="literal">first</code> and <code class="literal">last</code>. The context in the<a id="id426" class="indexterm"/> parent template is passed to the partial template, in this case the user object. So it's kind of like passing in props to a child React component from a parent component. Once again, however, the difference is that every Handlebars component we use to compose the structure of the DOM elements is re-rendered as there's no virtual DOM to speak of. Let's look at the store that was used to populate this view with data:</p><div><pre class="programlisting">import { EventEmitter } from 'events';

import dispatcher from '../dispatcher';
import { REVERSE } from '../actions/reverse';

// The initial state is a list of
// user objects.
var state = {
  users: [
    { first: 'first 1', last: 'last 1' },
    { first: 'first 2', last: 'last 2' },
    { first: 'first 3', last: 'last 3' }
  ]
};

class MyStore extends EventEmitter {
  constructor() {
    super();

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {

        // When the "REVERSE" action is dispatched,
        // the "state.users" array is reversed by
        // calling "reverse()".
        case REVERSE:
          this.emit('change',
            (state = Object.assign(
              {},
              state,
              { users: state.users.reverse() }
            ))
          );
          break;
      }
    });
  }

  get state() {
    return state;
  }
}

export default new MyStore();</pre></div><p>And finally, the main program. Here, we'll setup an interval timer that keeps dispatching the <code class="literal">REVERSE</code> action. This <a id="id427" class="indexterm"/>causes the whole UI to re-render with every dispatch:</p><div><pre class="programlisting">import $ from 'jquery';

import { reverse } from './actions/reverse';
import ListView from './views/list-view';

// Performs the initial rendering of
// the list view, after initializing
// the view using the "#app" element.
new ListView($('#app')).render();

// Every second, toggle the sort
// order of the list by re-rendering
// the main template and it's partial
// templates.
setInterval(reverse, 1000);</pre></div><div><div><h3 class="title"><a id="note30"/>Note</h3><p>Generally speaking, Flux architectures should have as few stores as possible. However, if we're using Handlebars in the view layer, we might be influenced to design our stores differently. For example, we might want to split the collective application state in such a way that results in less DOM structure being re-inserted into the document.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec142"/>Handling events</h2></div></div></div><p>Long before any modern web frameworks came into existence, jQuery was addressing cross-browser event-handling issues. Though the API has changed over the years, the powerful capabilities <a id="id428" class="indexterm"/>of jQuery's event handling remain intact. This is something that's obviously relevant if we're building views that are powered by jQuery and Handlebars.</p><p>The most pressing challenge with event handling in this context is the fact that we're re-rendering elements every time a Handlebars template needs updating. What we don't want is to have to re-attach event handlers to DOM elements every time they're inserted into the DOM. ReactJS utilizes a strategy that doesn't actually bind event handlers directly to the element we want to listen to. Instead, the handler is bound to the <code class="literal">body</code> element and as events bubble up, the appropriate handler is invoked. It turns out that this approach has a performance advantage, because it avoids having to bind the same handler function to the same element, over and over. Here's an illustration of the idea:</p><div><img src="img/B05419_11_03.jpg" alt="Handling events"/></div><p>We can achieve something similar to this using jQuery. Let's first look at the Handlebars template files so that we can get a feel for the type of UI we're dealing with here. We'll extend the preceding example by adding a reverse button and selection capabilities. Here's the new item view template:</p><div><pre class="programlisting">&lt;a href="#{{@index}}" style="font-weight: {{fontWeight}}"
  &lt;span style="text-transform: capitalize"&gt;{{first}}&lt;/span&gt;
  &lt;span style="text-transform: capitalize"&gt;{{last}}&lt;/span&gt;
&lt;/a&gt;</pre></div><p>The item is now a link. Note that we're able to use the <code class="literal">@index</code> Handlebars syntax, which allows access to the index of the current item in the collection we're iterating over. Even though the iteration happens in another template, this special value is still accessible. Now let's see what we have in the main list view Handlebars template:</p><div><pre class="programlisting">&lt;button&gt;Reverse&lt;/button&gt;
&lt;ul&gt;
  {{#each users}}
  &lt;li&gt;{{&gt; item-view}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p>The <code class="literal">ul</code> that builds the list is the same as it was previously. Now we have a new button to reverse the sort order of the<a id="id429" class="indexterm"/> list, instead of an interval timer. Let's now take a look at the event handling capabilities of the view component:</p><div><pre class="programlisting">import template from './list-view.hbs';
import { reverse } from '../actions/reverse';
import { select } from '../actions/select';
import myStore from '../stores/my-store';

export default class ListView {
  constructor(element) {

    this.element = element;

    // When the store state changes, re-render
    // the view.
    myStore.on('change', (state) =&gt; {
      this.render(state);
    });

    this.element

      // Binds the click event to "#app", but
      // is only handled if a "button" element
      // generated the event. The "reverse()"
      // action creator is used as the handler.
      .on('click', 'button', reverse)

      // Binds the click event to "#app", but
      // is only handled if an "a" element
      // generated the event. The index is parsed
      // from the "href" attribute, and this is
      // passed as the payload to the "select()"
      // action creator.
      .on('click', 'a', (e) =&gt; {
        e.preventDefault();

        let index = +(/(\d+)$/)
          .exec(e.currentTarget.href)[1];

        select(index);
      });
  }

  // Sets the HTML of "element" to the rendered
  // Handlebars "template()". The context of
  // the template is always the Flux store state.
  render(state = myStore.state) {
    this.element.html(template(state));
    return this;
  }
}</pre></div><p>We're following the pattern of React where the handler is never directly attached to something that's going to<a id="id430" class="indexterm"/> be re-rendered frequently. In fact, you can see that the event handlers are setup in the constructor of the view component, long before anything has ever been rendered by this view. This works because the <code class="literal">#app</code> element is already in place, and this is the element we're interested in.</p><p>The first handler is for the reverse button, and it uses the <code class="literal">reverse()</code> action creator function. It's the second parameter to <code class="literal">on()</code> that provides the element context, so that we know this handler is for <code class="literal">button</code> elements. The same principle is applied with our second handler, which is called when the user clicks a link. Here, we're simply preventing the default browser behavior and dispatching the <code class="literal">select</code> event. Now, let's take a look at some of the changes we had to make to our store to support this new event behavior:</p><div><pre class="programlisting">import { EventEmitter } from 'events';

import dispatcher from '../dispatcher';
import { REVERSE } from '../actions/reverse';
import { SELECT } from '../actions/select';

// The initial state is a list of
// user objects. They each have a
// "fontWeight" property which is
// translated to a CSS value when
// rendered.
var state = {
  users: [
    {
      first: 'first 1',
      last: 'last 1',
      fontWeight: 'normal'
    },
    {
      first: 'first 2',
      last: 'last 2',
      fontWeight: 'normal'
    },
    {
      first: 'first 3',
      last: 'last 3',
      fontWeight: 'normal'
    }
  ]
};

class MyStore extends EventEmitter {
  constructor() {
    super();

    this.id = dispatcher.register((e) =&gt; {
      switch(e.type) {

        // When the "REVERSE" action is dispatched,
        // the "state.users" array is reversed by
        // calling "reverse()".
        case REVERSE:
          this.emit('change',
            (state = Object.assign(
              {},
              state,
              { users: state.users.reverse() }
            ))
          );
          break;

        // When the "SELECT" action is dispatched, we
        // need to find the appropriate item based on
        // the "payload" index and mark it as selected.
        case SELECT:
          this.emit('change',
            (state = Object.assign(
              {},
              state,
              { users: state.users.map((v, i) =&gt; {

                // If the current index is the selected
                // item, change the "fontWeight" property.
                if (i === e.payload) {
                  return Object.assign({}, v,
                    { fontWeight: 'bold' });

                // Otherwise, set the "fontWeight" back
                // to "normal" so that any previously
                // selected items are reset.
                } else {
                  return Object.assign({}, v,
                    { fontWeight: 'normal' });
                }
              })}
            ))
          );
          break;
      }
    });
  }

  get state() {
    return state;
  }
}

export default new MyStore();</pre></div><p>There are two important changes here that are worth pointing out. The first change is that our <code class="literal">users</code> array now<a id="id431" class="indexterm"/> has a new <code class="literal">fontWeight</code> property for each item within it. This is necessary because it controls the display of our links to indicate that something has been selected. Everything defaults to <code class="literal">normal</code> since nothing has been selected yet.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>We could put some code in our view component that looks for a <code class="literal">fontWeight</code> property, and when it can't find one, it defaults to normal. The problem with this tactic is that it introduces unnecessary logic into the view component. We're trying to keep everything in the store, even seemingly trivial things like this. Even if that means adding default values in a store that are also default in the browser.</p></div></div><p>The second change to the store is the addition of the <code class="literal">SELECT</code> handling logic. When this action is dispatched, we match up the item index with the payload index and change the font weight. Everything else that doesn't match gets reverted back to a normal <code class="literal">font-weight</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec68"/>Using VanillaJS</h1></div></div></div><p>Not having enough diversity in the ecosystem of frontend JavaScript rendering libraries isn't a problem. In fact, the problem for us is the exact opposite—there's too many libraries and frameworks<a id="id432" class="indexterm"/> to choose from. While some people in the JavaScript community view this disjointed plethora of choice as a problem, it doesn't have to be. It's better to have too many technologies to choose from than not enough.</p><p>In this section, we'll discuss using VanillaJS as our view technology—no libraries or frameworks. The idea isn't to completely avoid using frameworks, it's to keep our options open as the architecture of our application unfolds. Eventually, we might move our view components to use React, or perhaps there's some other new hotness we've been keeping our eye on.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec143"/>Keeping my options open</h2></div></div></div><p>At some point, we have to choose a technology to use with our view components. That depends on which stage<a id="id433" class="indexterm"/> of the project we're on. If it's early in the game and we've already decided on a view library, we could end up limiting ourselves to this technology for a long time. Given how fast JavaScript and it's surrounding ecosystem is moving, being stuck with any technology for a length of time usually isn't a good thing. We have to embrace the fact that change is constantly deprecating the thing that was once new hotness.</p><p>On the other hand, we don't want to wait too long to make a technology decision for our views, because the more things we build using plain JS, the more difficult it's going to be to migrate these views to a more opinionated approach. Where's the sweet-spot?</p><p>The best strategy is to avoid lock-in where possible. This involves keeping things loosely-coupled so that they're substitutable. Thankfully, Flux architectures make this easy because the responsibilities of the view layer are fairly limited. They need to listen to store change events and render the store state. Maybe we should try building two sets of view components. The first set uses a technology such as React, and the other uses something else, such as jQuery and Handlebars. This not only allows us to pick the view technology that works best for our product, but also lets us test our readiness to adopt new technologies, which we'll inevitably want to do.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec144"/>Moving to React</h2></div></div></div><p>As you saw in this chapter, we <a id="id434" class="indexterm"/>can use technologies like jQuery and Handlebars in the view components of our Flux architecture. What's more, they don't interfere with the unidirectional data-flow found in Flux architectures. That being said, React is probably the best suited view technology to use as part of a Flux architecture. From the perspective of unidirectional data-flow, React picks this up naturally. Even without Flux in place, stateless functional React components behave exactly how we would expect a view to behave in a Flux architecture. When new properties come in, new HTML is rendered.</p><p>In addition to React's natural tendency toward unidirectional data-flow, the idea of re-rendering large DOM structures feels less daunting. Thanks to the virtual DOM that React uses to patch the<a id="id435" class="indexterm"/> rendered output—instead of replacing the entire thing—we can efficiently pass store state to top-level views for re-rendering. React also handles other edge cases for us too, such as maintaining the focus of a form control during a re-render.</p><p>The real question is twofold: how inevitable is a move to React, and how salvageable is our existing code? Well, the first question is generally pretty easy to answer—there's a high probability that you're going to use React in your Flux architecture. It's simply a good fit for a Flux architecture. However, it's naive to assume that there are no negative tradeoffs, like higher memory consumption for example. So if we do decide to move to React after already having developed some view components, do we need to throw everything out? Unlikely. Views play a relatively small role in Flux architectures, as I've stressed throughout the book. So, if moving to React solves problems in your Flux view components, by all means do so—it's a good direction to move in. For now.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec145"/>New hotness</h2></div></div></div><p>A couple of years ago, React was brand new hotness. As with any new hotness, developers can and should approach the technology with some degree of skepticism. As it turned out, React was a good bet for many of it's early adopters. On the other hand, not all new and shiny technologies work out. This is how progress is made, and is why so much progress has been made<a id="id436" class="indexterm"/> in the JavaScript ecosystem. What's the point of this anecdote? There's always going to be new hotness that's superior to what you've already bet on. Be ready to adopt and re-adopt again.</p><p>For example, Google is currently<a id="id437" class="indexterm"/> implementing view technology called Incremental DOM (<a class="ulink" href="http://google.github.io/incremental-dom/">http://google.github.io/incremental-dom/</a>), which takes a different approach to rendering that uses a lot less memory. There's<a id="id438" class="indexterm"/> <code class="literal">Veu.js</code> (<a class="ulink" href="http://vuejs.org/">http://vuejs.org/</a>). There are endless other possibilities for the future. Just make sure that you are views can pivot and embrace the latest and greatest view technology—it'll be here soon.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec69"/>Summary</h1></div></div></div><p>The focus of this chapter was on the view components of our Flux architecture and how they're loosely-coupled to the point that we can substitute rendering technologies. We started with a discussion on React itself and what makes it a good fit for Flux architectures. Then, we switched gears and covered the potential downsides of using ReactJS.</p><p>We spent some time implementing views that leveraged both jQuery and Handlebars. These are two mature technologies that many developers are familiar with and serve as a good jumping off point for implementing a Flux architecture. However, there are strong motivations for anyone implementing Flux to look at React as the view technology of choice.</p><p>We wrapped the chapter up with a discussion on using VanillaJS to render our view components. There's no sense in rushing into using a particular technology until we understand the ramifications of that choice. There's always going to be newer and better view libraries, and Flux architectures make it easy to pivot and embrace new hotness.</p></div></body></html>