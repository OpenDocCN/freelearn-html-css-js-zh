<html><head></head><body>
		<div id="_idContainer033">
			<h1 id="_idParaDest-199" class="chapter-number"><a id="_idTextAnchor206"/>7</h1>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor207"/> Event-Driven Architecture</h1>
			<p>Events are one of the most powerful<a id="_idIndexMarker384"/> ways to use Node.js. Node.js was designed from the ground up to build event-driven modules. Many core libraries offer an events interface that can be used and extended easily. Also, Node.js provides a powerful events library that can be used to build <span class="No-Break">event-driven modules.</span></p>
			<p>In this chapter, we delve into events in Node.js. We will learn how to use events from the core libraries, from event listener registration to event emission, and handling multiple listeners for the <span class="No-Break">same event.</span></p>
			<p>We will build our first HTTP server using events, and we will discuss the organization of event listeners and <span class="No-Break">the cleanup.</span></p>
			<p>To sum up, here are the main topics that we will explore in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Introducing events</span></li>
				<li> Watching for <span class="No-Break">file changes</span></li>
				<li> The Node.js event <span class="No-Break">emitter library</span></li>
				<li>Your first <span class="No-Break">HTTP server</span></li>
				<li>Adding an event layer to <span class="No-Break">your modules</span></li>
			</ul>
			<p>By the end of this chapter, you will know how to use events and even how to include an event interface in <span class="No-Break">your modules.</span></p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor208"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a></p>
			<p>Check out the code in action video for this chapter <span class="No-Break">on </span><a href="https://youtu.be/opZER2MY1Yc"><span class="No-Break">https://youtu.be/opZER2MY1Yc</span></a><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners&#13;"/></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor209"/>Introducing events</h1>
			<p>In the real world, events<a id="_idIndexMarker385"/> are occurrences. For example, when you click a button, a click event is triggered. When you receive a message, a message received event is triggered. When you save a file, a file saved event is triggered. Events are present everywhere. In Node.js, events are also <span class="No-Break">present everywhere.</span></p>
			<p>So, when we talk about events in Node.js, we are talking about the same concept as in the real world. Events are occurrences, and we produce them or consume them. In some cases, one entity produces an event, and another entity consumes it. In other cases, the same entity produces and consumes the event. This can be very flexible; it is even possible that many entities consume the same event, or many entities produce the <span class="No-Break">same event.</span></p>
			<p>If you are familiar with the frontend world, you may have implemented handlers when a button is clicked, something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
document.getElementById('my-button').addEventListener('click', () =&gt; {
    console.log('Button clicked');
});</pre>			<p>In this case, the <strong class="source-inline">addEventListener</strong> method receives two arguments, the event name and the callback function. The callback function will be called when the event is triggered. In this case, the event name is <strong class="source-inline">click</strong>, but you can subscribe to many other events, such as <strong class="source-inline">mouseover</strong>, <strong class="source-inline">mouseout</strong>, <strong class="source-inline">keydown</strong>, <strong class="source-inline">keyup</strong>, <strong class="source-inline">change</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">submit</strong></span><span class="No-Break">.</span></p>
			<p>If you have worked with other programming languages, you may have heard about the Observer, Publish/Subscribe, and mediator patterns. In this chapter, we will explore how to use the Node.js events library to build event-driven modules and explore how the core libraries are using <span class="No-Break">this architecture.</span></p>
			<p>One of the best ways to get familiar with events is by using the Node.js core API to handle files. We can subscribe to events and react when a file is modified. So, in the next section, we will explore this topic <span class="No-Break">in detail.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor210"/>Watching for file changes</h1>
			<p>As we are already familiar<a id="_idIndexMarker386"/> with the Node.js filesystem library, let’s build a simple script that watches for file changes. We will use the <strong class="source-inline">fs.watch</strong> method to watch for file changes. This method receives two arguments, the path to the file to watch and a callback function that will be called when the file changes. The callback function receives two arguments, the event type and the filename. The event type can be <strong class="source-inline">rename</strong> or <strong class="source-inline">change</strong>. The <strong class="source-inline">rename</strong> event is triggered when the file is renamed or deleted. The change event is triggered when the file <span class="No-Break">is modified.</span></p>
			<p>Now, we will create a simple program to detect <span class="No-Break">file changes:</span></p>
			<ol>
				<li>Let’s create a file called <strong class="source-inline">watch.mjs</strong> and add the <span class="No-Break">following code:</span><pre class="source-code">
import { watch } from 'node:fs';
console.log('Watching for file changes...');
watch('./watch.txt', (eventType, filename) =&gt; {
    console.log('-----------------------------');
    console.log(`Event type is: ${eventType}`);
    if (filename) {
        console.log(`Filename provided: ${filename}`);
    }
});</pre></li>				<li>Create a file called <strong class="source-inline">watch.txt</strong> and run the script with the <span class="No-Break">following command:</span><pre class="source-code">
<strong class="bold">node watch.js</strong></pre></li>				<li>Open the watch.txt file, add some text, and save the changes. You will see that the script prints the <span class="No-Break">following output:</span><pre class="source-code">
<strong class="bold">Watching for file changes...</strong>
<strong class="bold">-----------------------------</strong>
<strong class="bold">Event type is: change</strong>
<strong class="bold">Filename provided: watch.txt</strong></pre></li>			</ol>
			<p>As you can see, the <strong class="source-inline">change</strong> event is triggered, and the filename is provided. Now, rename the file and save the changes. You will see that the script prints the <span class="No-Break">following output:</span></p>
			<pre class="console">
-----------------------------
Event type is: rename
Filename provided: watch2.txt</pre>			<p>In the next section, we will learn<a id="_idIndexMarker387"/> how we can implement custom events inside of our application and how we can emit and <span class="No-Break">consume them.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor211"/>The Node.js event emitter library</h1>
			<p>Now that we know how to watch<a id="_idIndexMarker388"/> for file changes, let’s explore the Node.js events library. This library provides an <strong class="source-inline">EventEmitter</strong> class that can be used to build simple interface to register and unregister event listeners and <span class="No-Break">emit events.</span></p>
			<p>Let’s create a file called <strong class="source-inline">event-emitter.mjs</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { EventEmitter } from 'node:events';
const emitter = new EventEmitter();
emitter.on('message', (message) =&gt; {
    console.log(`Message received: ${message}`);
});
emitter.emit('message', 'Hello world!');</pre>			<p>In this example, we created an instance of the <strong class="source-inline">EventEmitter</strong> class and registered an event listener for the <strong class="source-inline">message</strong> event. Then, we emit the <strong class="source-inline">message</strong> event with the message <strong class="source-inline">Hello world!</strong>. If you run the script, you will see that the message is printed in <span class="No-Break">the console.</span></p>
			<p>You can also register multiple<a id="_idIndexMarker389"/> event listeners and emitters for the same event; this is a common practice when you want to modularize code and/or you want from the same event to trigger multiple actions. Let’s say that you receive an incoming request, and you want to store a copy of that message and also notify that to the final user; by using events, you can handle both actions in parallel. Let’s modify the previous example by adding the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
setInterval(() =&gt; {
    emitter.emit('message', `Interval (${Date.now()})`);
}, 1000);
emitter.on('message', (message) =&gt; {
    console.log(`Additional listener received: ${message}`);
});
emitter.once('message', (message) =&gt; {
    console.log(`Once listener received: ${message}`);
});
setTimeout(() =&gt; {
    emitter.emit('message', 'Timeout says hello!');
}, 2500);</pre>			<p>Let’s analyze the code. First, we use<a id="_idIndexMarker390"/> the <strong class="source-inline">setInterval</strong> method to emit the <strong class="source-inline">message</strong> event every second. Then, we register an additional event listener for the <strong class="source-inline">message</strong> event. This event listener will be called every time the <strong class="source-inline">message</strong> event is emitted. Then, we register an event listener using the <strong class="source-inline">once</strong> method. This event listener will be called only once, but if you want to keep listening for more than one message, you can use <strong class="source-inline">on </strong>– for example, when you listen for incoming request in an HTTP server application. Finally, we use the <strong class="source-inline">setTimeout</strong> method to emit the <strong class="source-inline">message</strong> event after 2.5 seconds. If you run the script, you will see that the following output <span class="No-Break">is printed:</span></p>
			<pre class="console">
Message received: Hello world!
Message received: Interval (1691771547260)
Additional listener received: Interval (1691771547260)
Once listener received: Interval (1691771547260)
Message received: Interval (1691771548258)
Additional listener received: Interval (1691771548258)
Message received: Timeout says hello!
Additional listener received: Timeout says hello!</pre>			<h2 id="_idParaDest-205"><a id="_idTextAnchor212"/>Preventing chaos by organizing the listeners</h2>
			<p>One important thing to note<a id="_idIndexMarker391"/> is that the event listeners<a id="_idIndexMarker392"/> are called synchronously. This means that the event listeners are called in the same order that they are registered. Also, remember that you can use more channels to communicate between processes. In our example, we used <strong class="source-inline">message</strong>, but you can use any name you want or have multiple channels to better <span class="No-Break">segment communication.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor213"/>Removing listeners when they are not needed</h2>
			<p>The <strong class="source-inline">EventEmitter</strong> class<a id="_idIndexMarker393"/> provides <strong class="source-inline">removeListener</strong> and <strong class="source-inline">off</strong> methods that can be used to remove an event listener, as well as a <strong class="source-inline">removeAllListeners</strong> method that can be used to remove all event listeners for a given event. You can find<a id="_idIndexMarker394"/> more information about it in the official <span class="No-Break">documentation: </span><a href="https://nodejs.org/docs/latest-v20.x/api/events.html"><span class="No-Break">https://nodejs.org/docs/latest-v20.x/api/events.html</span></a><span class="No-Break">.</span></p>
			<p>In the next section, we will create<a id="_idIndexMarker395"/> our first HTTP server with Node.js, which is one of the most commons ways to use events while doing web applications <span class="No-Break">in Node.js.</span></p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor214"/>Your first HTTP server</h1>
			<p>Now that we know<a id="_idIndexMarker396"/> how to use the <strong class="source-inline">EventEmitter</strong> class, let’s build a simple HTTP server. We will use the <strong class="source-inline">http</strong> core library to create the server and the <strong class="source-inline">EventEmitter</strong> class to handle the requests. In <a href="B21678_09.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, we will explore in more detail how to build HTTP servers and clients, but for now, let’s focus on building our first <span class="No-Break">HTTP server.</span></p>
			<p>Let’s create a file called <strong class="source-inline">server.mjs</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { createServer } from 'node:http';
const port = 3000;
const server = createServer();
server.on('request', (request, res) =&gt; {
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end('&lt;h1&gt;This is my first HTTP server in Node.js. Yay&lt;/h1&gt;!');
});
server.listen(port, () =&gt; {
  console.log(`Server running at http://localhost:${port}/`);
});</pre>			<p>In this example, we created an instance of the <strong class="source-inline">http.Server</strong> class and registered an event listener for the <strong class="source-inline">request</strong> event. This event listener will be called every time a request is received. Then, we use the <strong class="source-inline">writeHead</strong> method to set the status code and the content type of the response. Finally, we use the <strong class="source-inline">end</strong> method to send the response. If you run the script, you will see that the following output <span class="No-Break">is printed:</span></p>
			<pre class="source-code">
Server running at http://localhost:3000/</pre>			<p>And if you open the URL in any browser, you will see your first HTTP server <span class="No-Break">in action:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B21678_07_1.jpg" alt="Figure 7.1 – A screenshot from the application running"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A screenshot from the application running</p>
			<p>In the next section, we will learn<a id="_idIndexMarker397"/> how to encapsulate the events in our modules and a lot other components to emit and consume those events easily. This technique is quite popular and extendable to <span class="No-Break">many libraries.</span></p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor215"/>Adding an event layer to your modules</h1>
			<p>Now that we know how<a id="_idIndexMarker398"/> to use<a id="_idIndexMarker399"/> the <strong class="source-inline">EventEmitter</strong> class, let’s add an event layer to our modules. In this example, we will create a module that will be used to save files and emit an event every time a file change <span class="No-Break">is saved.</span></p>
			<p>Let’s create a file called <strong class="source-inline">utils.mjs</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { writeFile } from 'node:fs/promises';
import { EventEmitter } from 'node:events';
const emitter = new EventEmitter();
const on = emitter.on.bind(emitter);
const save = async (location, data) =&gt; {
  await writeFile(location, data);
  emitter.emit('file:saved', { location, data });
};
export { save, on };</pre>			<p>In this example, we created<a id="_idIndexMarker400"/> an instance of the <strong class="source-inline">EventEmitter</strong> class and exported<a id="_idIndexMarker401"/> the <strong class="source-inline">save</strong> function. This function will be used to save the file and emit the <strong class="source-inline">file:saved</strong> event. Then, we export the <strong class="source-inline">on</strong> method of the <strong class="source-inline">EventEmitter</strong> class. This method will be used to register event listeners for the <span class="No-Break"><strong class="source-inline">file:saved</strong></span><span class="No-Break"> event.</span></p>
			<p class="callout-heading">Important info</p>
			<p class="callout">In the example, we used <strong class="source-inline">bind</strong> to check that the <strong class="source-inline">this</strong> value is correct. You can find more information<a id="_idIndexMarker402"/> about it in the official documentation at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a>. The use of <strong class="source-inline">bind</strong> is quite advanced, so you can skip it <span class="No-Break">for now.</span></p>
			<p>Now, let’s create a file called <strong class="source-inline">index.mjs</strong> and add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
import { save, on } from './utils.mjs';
on('file:saved', ({ location, data }) =&gt; {
  console.log(`File saved at ${location}`);
});
console.log('Saving file...');
save('test.txt', 'Hello world!').catch('Error saving file');
console.log('The file is being saved but is not blocking the execution...');</pre>			<p>If you run the script, you will see that the following output <span class="No-Break">is printed:</span></p>
			<pre class="source-code">
Saving file...
The file is being saved but is not blocking the execution...
File saved at test.txt</pre>			<p>As you can see, the <strong class="source-inline">file:saved</strong> event is emitted after the <strong class="source-inline">save</strong> function is completed. This means that the <strong class="source-inline">save</strong> function does not block the execution of the script. In previous examples in the book, we used <strong class="source-inline">then</strong> to handle the result of a promise; in this case, we offered <a id="_idIndexMarker403"/>an alternative, using events<a id="_idIndexMarker404"/> that will allow you to decouple the logic of your application <span class="No-Break">more easily.</span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor216"/>Summary</h1>
			<p>In this chapter, we learned about how to use events in Node.js. We learned about the <strong class="source-inline">EventEmitter</strong> class and how to use it to emit and listen to events. We also learned how to use events to decouple the logic of <span class="No-Break">our applications.</span></p>
			<p>Additionally, we built a script to watch for changes in files in our system, and we also built our first HTTP server and learned how to handle requests <span class="No-Break">using events.</span></p>
			<p>Finally, we built a simple library that exports an event layer to decouple the logic of our applications. This will allow us to build more robust applications in <span class="No-Break">future chapters.</span></p>
			<p>In the next chapter, we will learn how to add tests to our applications. This will help us to build more robust applications, avoid bugs, and overall, consolidate our knowledge about Node.js while <span class="No-Break">learning it.</span></p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor217"/>Further reading</h1>
			<ul>
				<li><em class="italic">Refactoring Guru – the Mediator </em><span class="No-Break"><em class="italic">pattern</em></span><span class="No-Break">: </span><a href="https://refactoring.guru/design-patterns/mediator"><span class="No-Break">https://refactoring.guru/design-patterns/mediator</span></a><a href="https://refactoring.guru/design-patterns/mediator&#13;"/></li>
				<li><em class="italic">Refactoring Guru – the Observer </em><span class="No-Break"><em class="italic">pattern</em></span><span class="No-Break">: </span><a href="https://refactoring.guru/design-patterns/observer"><span class="No-Break">https://refactoring.guru/design-patterns/observer</span></a><a href="https://refactoring.guru/design-patterns/observer&#13;"/></li>
				<li><em class="italic">NodeConf Remote 2020 - Anna Henningsen - Node.js and the struggles of being an </em><span class="No-Break"><em class="italic">EventTarget</em></span><span class="No-Break">: </span><a href="https://www.youtube.com/watch?v=SOPC3aLoD4U"><span class="No-Break">https://www.youtube.com/watch?v=SOPC3aLoD4U</span></a><a href="https://www.youtube.com/watch?v=SOPC3aLoD4U&#13;"/></li>
				<li><em class="italic">The Node.js event </em><span class="No-Break"><em class="italic">emitter</em></span><span class="No-Break">: </span><a href="https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter"><span class="No-Break">https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter</span></a></li>
			</ul>
		</div>
	</body></html>