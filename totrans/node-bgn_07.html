<html><head></head><body>
		<div><h1 id="_idParaDest-199" class="chapter-number"><a id="_idTextAnchor206"/>7</h1>
			<h1 id="_idParaDest-200"><a id="_idTextAnchor207"/> Event-Driven Architecture</h1>
			<p>Events are one of the most powerful<a id="_idIndexMarker384"/> ways to use Node.js. Node.js was designed from the ground up to build event-driven modules. Many core libraries offer an events interface that can be used and extended easily. Also, Node.js provides a powerful events library that can be used to build event-driven modules.</p>
			<p>In this chapter, we delve into events in Node.js. We will learn how to use events from the core libraries, from event listener registration to event emission, and handling multiple listeners for the same event.</p>
			<p>We will build our first HTTP server using events, and we will discuss the organization of event listeners and the cleanup.</p>
			<p>To sum up, here are the main topics that we will explore in this chapter:</p>
			<ul>
				<li>Introducing events</li>
				<li> Watching for file changes</li>
				<li> The Node.js event emitter library</li>
				<li>Your first HTTP server</li>
				<li>Adding an event layer to your modules</li>
			</ul>
			<p>By the end of this chapter, you will know how to use events and even how to include an event interface in your modules.</p>
			<h1 id="_idParaDest-201"><a id="_idTextAnchor208"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a></p>
			<p>Check out the code in action video for this chapter on <a href="https://youtu.be/opZER2MY1Yc">https://youtu.be/opZER2MY1Yc</a><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners&#13;"/></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor209"/>Introducing events</h1>
			<p>In the real world, events<a id="_idIndexMarker385"/> are occurrences. For example, when you click a button, a click event is triggered. When you receive a message, a message received event is triggered. When you save a file, a file saved event is triggered. Events are present everywhere. In Node.js, events are also present everywhere.</p>
			<p>So, when we talk about events in Node.js, we are talking about the same concept as in the real world. Events are occurrences, and we produce them or consume them. In some cases, one entity produces an event, and another entity consumes it. In other cases, the same entity produces and consumes the event. This can be very flexible; it is even possible that many entities consume the same event, or many entities produce the same event.</p>
			<p>If you are familiar with the frontend world, you may have implemented handlers when a button is clicked, something like this:</p>
			<pre class="source-code">
document.getElementById('my-button').addEventListener('click', () =&gt; {
    console.log('Button clicked');
});</pre>			<p>In this case, the <code>addEventListener</code> method receives two arguments, the event name and the callback function. The callback function will be called when the event is triggered. In this case, the event name is <code>click</code>, but you can subscribe to many other events, such as <code>mouseover</code>, <code>mouseout</code>, <code>keydown</code>, <code>keyup</code>, <code>change</code>, and <code>submit</code>.</p>
			<p>If you have worked with other programming languages, you may have heard about the Observer, Publish/Subscribe, and mediator patterns. In this chapter, we will explore how to use the Node.js events library to build event-driven modules and explore how the core libraries are using this architecture.</p>
			<p>One of the best ways to get familiar with events is by using the Node.js core API to handle files. We can subscribe to events and react when a file is modified. So, in the next section, we will explore this topic in detail.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor210"/>Watching for file changes</h1>
			<p>As we are already familiar<a id="_idIndexMarker386"/> with the Node.js filesystem library, let’s build a simple script that watches for file changes. We will use the <code>fs.watch</code> method to watch for file changes. This method receives two arguments, the path to the file to watch and a callback function that will be called when the file changes. The callback function receives two arguments, the event type and the filename. The event type can be <code>rename</code> or <code>change</code>. The <code>rename</code> event is triggered when the file is renamed or deleted. The change event is triggered when the file is modified.</p>
			<p>Now, we will create a simple program to detect file changes:</p>
			<ol>
				<li>Let’s create a file called <code>watch.mjs</code> and add the following code:<pre class="source-code">
import { watch } from 'node:fs';
console.log('Watching for file changes...');
watch('./watch.txt', (eventType, filename) =&gt; {
    console.log('-----------------------------');
    console.log(`Event type is: ${eventType}`);
    if (filename) {
        console.log(`Filename provided: ${filename}`);
    }
});</pre></li>				<li>Create a file called <code>watch.txt</code> and run the script with the following command:<pre class="source-code">
<strong class="bold">node watch.js</strong></pre></li>				<li>Open the watch.txt file, add some text, and save the changes. You will see that the script prints the following output:<pre class="source-code">
<strong class="bold">Watching for file changes...</strong>
<strong class="bold">-----------------------------</strong>
<strong class="bold">Event type is: change</strong>
<strong class="bold">Filename provided: watch.txt</strong></pre></li>			</ol>
			<p>As you can see, the <code>change</code> event is triggered, and the filename is provided. Now, rename the file and save the changes. You will see that the script prints the following output:</p>
			<pre class="console">
-----------------------------
Event type is: rename
Filename provided: watch2.txt</pre>			<p>In the next section, we will learn<a id="_idIndexMarker387"/> how we can implement custom events inside of our application and how we can emit and consume them.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor211"/>The Node.js event emitter library</h1>
			<p>Now that we know how to watch<a id="_idIndexMarker388"/> for file changes, let’s explore the Node.js events library. This library provides an <code>EventEmitter</code> class that can be used to build simple interface to register and unregister event listeners and emit events.</p>
			<p>Let’s create a file called <code>event-emitter.mjs</code> and add the following code:</p>
			<pre class="source-code">
import { EventEmitter } from 'node:events';
const emitter = new EventEmitter();
emitter.on('message', (message) =&gt; {
    console.log(`Message received: ${message}`);
});
emitter.emit('message', 'Hello world!');</pre>			<p>In this example, we created an instance of the <code>EventEmitter</code> class and registered an event listener for the <code>message</code> event. Then, we emit the <code>message</code> event with the message <code>Hello world!</code>. If you run the script, you will see that the message is printed in the console.</p>
			<p>You can also register multiple<a id="_idIndexMarker389"/> event listeners and emitters for the same event; this is a common practice when you want to modularize code and/or you want from the same event to trigger multiple actions. Let’s say that you receive an incoming request, and you want to store a copy of that message and also notify that to the final user; by using events, you can handle both actions in parallel. Let’s modify the previous example by adding the following code:</p>
			<pre class="source-code">
setInterval(() =&gt; {
    emitter.emit('message', `Interval (${Date.now()})`);
}, 1000);
emitter.on('message', (message) =&gt; {
    console.log(`Additional listener received: ${message}`);
});
emitter.once('message', (message) =&gt; {
    console.log(`Once listener received: ${message}`);
});
setTimeout(() =&gt; {
    emitter.emit('message', 'Timeout says hello!');
}, 2500);</pre>			<p>Let’s analyze the code. First, we use<a id="_idIndexMarker390"/> the <code>setInterval</code> method to emit the <code>message</code> event every second. Then, we register an additional event listener for the <code>message</code> event. This event listener will be called every time the <code>message</code> event is emitted. Then, we register an event listener using the <code>once</code> method. This event listener will be called only once, but if you want to keep listening for more than one message, you can use <code>on </code>– for example, when you listen for incoming request in an HTTP server application. Finally, we use the <code>setTimeout</code> method to emit the <code>message</code> event after 2.5 seconds. If you run the script, you will see that the following output is printed:</p>
			<pre class="console">
Message received: Hello world!
Message received: Interval (1691771547260)
Additional listener received: Interval (1691771547260)
Once listener received: Interval (1691771547260)
Message received: Interval (1691771548258)
Additional listener received: Interval (1691771548258)
Message received: Timeout says hello!
Additional listener received: Timeout says hello!</pre>			<h2 id="_idParaDest-205"><a id="_idTextAnchor212"/>Preventing chaos by organizing the listeners</h2>
			<p>One important thing to note<a id="_idIndexMarker391"/> is that the event listeners<a id="_idIndexMarker392"/> are called synchronously. This means that the event listeners are called in the same order that they are registered. Also, remember that you can use more channels to communicate between processes. In our example, we used <code>message</code>, but you can use any name you want or have multiple channels to better segment communication.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor213"/>Removing listeners when they are not needed</h2>
			<p>The <code>EventEmitter</code> class<a id="_idIndexMarker393"/> provides <code>removeListener</code> and <code>off</code> methods that can be used to remove an event listener, as well as a <code>removeAllListeners</code> method that can be used to remove all event listeners for a given event. You can find<a id="_idIndexMarker394"/> more information about it in the official documentation: <a href="https://nodejs.org/docs/latest-v20.x/api/events.html">https://nodejs.org/docs/latest-v20.x/api/events.html</a>.</p>
			<p>In the next section, we will create<a id="_idIndexMarker395"/> our first HTTP server with Node.js, which is one of the most commons ways to use events while doing web applications in Node.js.</p>
			<h1 id="_idParaDest-207"><a id="_idTextAnchor214"/>Your first HTTP server</h1>
			<p>Now that we know<a id="_idIndexMarker396"/> how to use the <code>EventEmitter</code> class, let’s build a simple HTTP server. We will use the <code>http</code> core library to create the server and the <code>EventEmitter</code> class to handle the requests. In <a href="B21678_09.xhtml#_idTextAnchor244"><em class="italic">Chapter 9</em></a>, we will explore in more detail how to build HTTP servers and clients, but for now, let’s focus on building our first HTTP server.</p>
			<p>Let’s create a file called <code>server.mjs</code> and add the following code:</p>
			<pre class="source-code">
import { createServer } from 'node:http';
const port = 3000;
const server = createServer();
server.on('request', (request, res) =&gt; {
  res.writeHead(200, { 'Content-Type': 'text/html' });
  res.end('&lt;h1&gt;This is my first HTTP server in Node.js. Yay&lt;/h1&gt;!');
});
server.listen(port, () =&gt; {
  console.log(`Server running at http://localhost:${port}/`);
});</pre>			<p>In this example, we created an instance of the <code>http.Server</code> class and registered an event listener for the <code>request</code> event. This event listener will be called every time a request is received. Then, we use the <code>writeHead</code> method to set the status code and the content type of the response. Finally, we use the <code>end</code> method to send the response. If you run the script, you will see that the following output is printed:</p>
			<pre class="source-code">
Server running at http://localhost:3000/</pre>			<p>And if you open the URL in any browser, you will see your first HTTP server in action:</p>
			<div><div><img src="img/B21678_07_1.jpg" alt="Figure 7.1 – A screenshot from the application running"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – A screenshot from the application running</p>
			<p>In the next section, we will learn<a id="_idIndexMarker397"/> how to encapsulate the events in our modules and a lot other components to emit and consume those events easily. This technique is quite popular and extendable to many libraries.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor215"/>Adding an event layer to your modules</h1>
			<p>Now that we know how<a id="_idIndexMarker398"/> to use<a id="_idIndexMarker399"/> the <code>EventEmitter</code> class, let’s add an event layer to our modules. In this example, we will create a module that will be used to save files and emit an event every time a file change is saved.</p>
			<p>Let’s create a file called <code>utils.mjs</code> and add the following code:</p>
			<pre class="source-code">
import { writeFile } from 'node:fs/promises';
import { EventEmitter } from 'node:events';
const emitter = new EventEmitter();
const on = emitter.on.bind(emitter);
const save = async (location, data) =&gt; {
  await writeFile(location, data);
  emitter.emit('file:saved', { location, data });
};
export { save, on };</pre>			<p>In this example, we created<a id="_idIndexMarker400"/> an instance of the <code>EventEmitter</code> class and exported<a id="_idIndexMarker401"/> the <code>save</code> function. This function will be used to save the file and emit the <code>file:saved</code> event. Then, we export the <code>on</code> method of the <code>EventEmitter</code> class. This method will be used to register event listeners for the <code>file:saved</code> event.</p>
			<p class="callout-heading">Important info</p>
			<p class="callout">In the example, we used <code>bind</code> to check that the <code>this</code> value is correct. You can find more information<a id="_idIndexMarker402"/> about it in the official documentation at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind</a>. The use of <code>bind</code> is quite advanced, so you can skip it for now.</p>
			<p>Now, let’s create a file called <code>index.mjs</code> and add the following code:</p>
			<pre class="source-code">
import { save, on } from './utils.mjs';
on('file:saved', ({ location, data }) =&gt; {
  console.log(`File saved at ${location}`);
});
console.log('Saving file...');
save('test.txt', 'Hello world!').catch('Error saving file');
console.log('The file is being saved but is not blocking the execution...');</pre>			<p>If you run the script, you will see that the following output is printed:</p>
			<pre class="source-code">
Saving file...
The file is being saved but is not blocking the execution...
File saved at test.txt</pre>			<p>As you can see, the <code>file:saved</code> event is emitted after the <code>save</code> function is completed. This means that the <code>save</code> function does not block the execution of the script. In previous examples in the book, we used <code>then</code> to handle the result of a promise; in this case, we offered <a id="_idIndexMarker403"/>an alternative, using events<a id="_idIndexMarker404"/> that will allow you to decouple the logic of your application more easily.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor216"/>Summary</h1>
			<p>In this chapter, we learned about how to use events in Node.js. We learned about the <code>EventEmitter</code> class and how to use it to emit and listen to events. We also learned how to use events to decouple the logic of our applications.</p>
			<p>Additionally, we built a script to watch for changes in files in our system, and we also built our first HTTP server and learned how to handle requests using events.</p>
			<p>Finally, we built a simple library that exports an event layer to decouple the logic of our applications. This will allow us to build more robust applications in future chapters.</p>
			<p>In the next chapter, we will learn how to add tests to our applications. This will help us to build more robust applications, avoid bugs, and overall, consolidate our knowledge about Node.js while learning it.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor217"/>Further reading</h1>
			<ul>
				<li><em class="italic">Refactoring Guru – the Mediator </em><em class="italic">pattern</em>: <a href="https://refactoring.guru/design-patterns/mediator">https://refactoring.guru/design-patterns/mediator</a><a href="https://refactoring.guru/design-patterns/mediator&#13;"/></li>
				<li><em class="italic">Refactoring Guru – the Observer </em><em class="italic">pattern</em>: <a href="https://refactoring.guru/design-patterns/observer">https://refactoring.guru/design-patterns/observer</a><a href="https://refactoring.guru/design-patterns/observer&#13;"/></li>
				<li><em class="italic">NodeConf Remote 2020 - Anna Henningsen - Node.js and the struggles of being an </em><em class="italic">EventTarget</em>: <a href="https://www.youtube.com/watch?v=SOPC3aLoD4U">https://www.youtube.com/watch?v=SOPC3aLoD4U</a><a href="https://www.youtube.com/watch?v=SOPC3aLoD4U&#13;"/></li>
				<li><em class="italic">The Node.js event </em><em class="italic">emitter</em>: <a href="https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter">https://nodejs.org/en/learn/asynchronous-work/the-nodejs-event-emitter</a></li>
			</ul>
		</div>
	</body></html>