- en: Chapter 2. Building a Photo-sharing Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You''ve done a great job of understanding the most basic Backbone features.
    I think you''re ready to level up and build something a little bigger, a little
    tougher. So in this chapter, we''ll be building an Instagram clone of sorts; users
    will be able to create accounts, upload photos, follow other users, and comment
    on photos. We''ll use a lot of the features that we used in the last chapter,
    but we''ll also look at a bunch of new ones. We''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How user accounts affect a Backbone application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own model sync function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternate uses for models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uploading files via AJAX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating user accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to start with the application template that we created in the first
    part of the last chapter. So, in the code download that comes with this book,
    find the `template` folder and make a copy of it. You'll need to install the necessary
    Node.js packages, of course; so, run `npm install` in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between this application and the one we wrote in the last
    chapter is that this app has a much more significant server component; we want
    to be able to create user accounts and allow users to log in and log out. In fact,
    that''s where we have to start. There''s a really great Node.js package called
    Passport ([http://passportjs.org/](http://passportjs.org/)), which makes authentication
    easy. We''ll begin by installing the library, as well as the `bcrypt` package,
    which we''ll use to encrypt users'' passwords. Do this with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `--save` flag will add these packages to the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several dozen lines of setup for this, so we''re going to put them
    in their own file. In the project folder, create a `signin.js` file. The first
    step is to pull in the libraries that we need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A strategy, in the Passport terminology, is a method of authentication. We're
    authenticating locally, as opposed to using Twitter or Facebook. The `salt` variable
    will be used when we encrypt a user's password; it's a good practice in encryption
    to ensure our user's passwords are stored safely.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll create our `strategy` object, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'First things first: we''re assigning a property to an `exports` object. This
    is a Node.js module''s object that can be exported from this file. When we require
    this file from the `server.js` file, anything that is a property of the `exports`
    object will be a property of the object returned from our `require` call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, about the code here: this might look a little weird to you, but hang on.
    We can''t just create the `strategy` method, because we need to use the database
    inside the `strategy` object. So, instead, we create a function that will take
    the database and return a `strategy` object. The `strategy` object constructor
    takes a function that will do the authentication and that function takes three
    parameters: the username, the password, and a callback function, which we call
    `done`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the function, we search the database for a user with the username we
    received as a parameter. Inside the callback, we first check to see if the user
    exists; if not, we call the `done` method by passing three parameters. The first
    is any error that occurred: that can just be `null`, because there''s no error.
    Second is `false`; would be a user object, but we pass `false` because there isn''t
    one. The last parameter is a message that we could display to the user.'
  prefs: []
  type: TYPE_NORMAL
- en: However, if we do find a user, we'll need to match the password that we were
    given. When we begin creating users in the database, we'll use the `bcrypt` package
    to convert the plaintext password to a hash, so we don't store the plaintext version.
    Then, here, we can compare the results using the `bcrypt.compareSync` method;
    it takes the password we're comparing and the `user.passwordHash` property from
    the user object we got out of the database. Finally, if that comparison doesn't
    fail, we'll authenticate the user by sending the user object back in the `done`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a lot to start with, but it''s important to begin with the authentication.
    We''ll also need the `serialize` and `deserialize` methods; these will be used
    by the Passport''s session feature to keep the user object available over page
    refreshes. The methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `serialize` method will send only the user's ID; in the `deserialize` method,
    we pull the same trick that we did with the `strategy` object, because we need
    the database inside the `deserialize` function. We return the function, which
    takes the ID, and send the user object to the `done` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final piece for the module; when creating a user account, we''ll need to
    convert the plaintext password to the hashed version. To do this, we''ll use the
    `bcrypt.hashSync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our function will take a single parameter—the plaintext password—and will hash
    it. Don't forget to pass the `salt` object we created as the second parameter
    to the `hashSync` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''re ready to go to the `server.js` file and start things in there.
    We start by pulling in the Passport library and our `signin.js` file, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you're not familiar with requesting local Node.js modules, we can just pass
    a relative path to the `require` function, as you see here. We don't need to include
    the `.js` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to create the database instances that we''ll need for the application;
    we do that like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to set up the passport functions that we put in the `signin.js`
    file. Use this code to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We pass the function that creates our strategy to `passport.use`. Then, we set
    the `serialize` and `deserialize` functions. Notice that `strategy` and `deserialize`
    take the `users` database as arguments and return the correct function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to prepare the middleware for the application. In our previous
    application, we didn''t need much middleware, because we weren''t doing that much
    on the server. But this time, we have to manage users'' sessions. So here''s what
    we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'All the extra pieces of middleware—the ones that we didn''t use in the previous
    chapter—are here for managing the user session. Actually, most of Express''s middleware
    comes from the Connect library ([https://github.com/senchalabs/connect](https://github.com/senchalabs/connect));
    it might seem like we''re adding a lot of middleware pieces here, but the truth
    is that they''re broken into many small pieces, so you can choose exactly what
    you need. You can find out more about each individual piece on the Connect website
    ([http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)), but
    here are the pieces of middleware in this application that we haven''t used before:'
  prefs: []
  type: TYPE_NORMAL
- en: '`urlencoded`: This method parses `x-ww-form-urlencoded` request bodies, providing
    the parsed object as `req.body`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multipart`: This method parses multipart/form-data request bodies, providing
    the parsed object as `req.body` and `req.files`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cookieParser`: This method parses the cookie header and provides that data
    as `req.cookies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`session`: This method sets up the session store with the given options'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`passport.initialize`: This method sets up Passport'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`passport.session`: This method sets up persistent logins with Passport'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that these pieces are in place, we''re ready to start writing some routes.
    We''ll start with the routes that are specifically related to logging a user in
    and out. Here''s the route for logging in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one is simple; at the `/login` route, we''ll render the `login.ejs`
    template. More on the content of this file soon. However, you can probably guess
    that there''s going to be a form on that page. The users will put in their usernames
    and passwords; when they submit the form, the data will be posted back to this
    URL. So, we''ll need to accept POST requests on the same URL. So, here''s the
    `post` method version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll notice something different about this route; we''re not writing our
    own function. Instead, we''re calling the `passport.authenticate` function. As
    you saw earlier, we''re using a local strategy, so that''s the first parameter.
    After that, we have an object with two properties. It defines the routes to which
    the user will be redirected, depending on whether the user is authenticated or
    not. Obviously, if the user is successfully logged in, they will be sent to the
    root route; otherwise, they''ll be sent back to the login page. The `get` method
    is given in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This one''s simple too: to log out, we''ll just call the `logout` method that
    Passport adds to the request object, and then redirect to the root route again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take care of the `login.ejs` file now. This will have to go in the `view`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We have two forms here: one for logging in, and one for creating users. Really,
    they''re pretty much identical, but they''ll be posted to different routes. We''ve
    already written the route for the first one, but we don''t yet have a route for
    creating new users. So, guess what''s next?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this route's function, we start by creating the `userAttrs` object. We'll
    get the username and the password from the `req.body` object, making sure we use
    the `hashPassword` method to hash the password. We'll also include an empty array
    called `following`; we'll be storing the list of IDs of the users that they are
    following in this array.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll search our database to see if another user has that username. If
    not, we can insert the user attribute objects we just created. Once we've stored
    the user, we can set the session up by using the `req.login` method that Passport
    gives us. Once they're logged in, we can redirect them to the root route.
  prefs: []
  type: TYPE_NORMAL
- en: That pretty much completes our user accounts feature. I should point out that
    I've left out some bits that would be important in a production application; for
    example, there will be no helpful messages for the user if they mistype their
    usernames or passwords when logging in, or try to create a user account with a
    username that already exists. They'll just be directed back to the forms. Of course,
    this as well as other important account-related features could be implemented
    (such as, changing a password); but we want to get to the Backbone code. That's
    what you're here for, right?
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''ve seen, a user will be directed back to the root route once they are
    logged in. We actually don''t have the root route method yet, so let''s create
    it now, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's actually not just the root route; it will collect many routes. The first
    step is to check for the `req.user` object, to see if the user is logged in. Remember
    the `deserialize` method we wrote? Passport will be using that behind the scenes
    to make sure that this `req.user` object is exactly the record we have in our
    database. If that isn't set, we'll send the user to the `/login` route. Otherwise,
    things can continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right now, we''re keeping things very simple; we''re just rendering the `index.ejs`
    template. The only piece of data we''re sending into that is the user. We already
    know why we need to wrap it in `JSON.stringify`, but what''s the `safe` function?
    This is something we''re about to write: the idea here is that we don''t want
    to send the whole user record back to the browser; we want to remove some classified
    properties, such as `passwordHash`. Here is the `safe` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It's very basic; we have an array of property names we want to remove. We start
    by cloning the `user` parameter. Then, we loop over the `toHide` variable, and
    delete those properties on the clone. Finally, we return the safe `user` object.
  prefs: []
  type: TYPE_NORMAL
- en: Well, things are really coming together here on the server. We're finally ready
    to turn our attention to the client-side code. We'll start with the `index.ejs`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our application navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve already got a basic version of this from the template. However, we need
    to adjust the script tags at the bottom. After the tag for `backbone.js`, but
    before the tag for `app.js`, you''ll want to add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the `user` object that is the user that is currently logged in. We'll
    need to be able to work with some of its properties inside our application components,
    which is why we need to load it before the `app.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of the `app.js` file, that''s our next stop. This time, we''re going
    to begin with a router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This is very similar to the router from our previous application. Any options—such
    as DOM elements, models, or collections—that we'll want to use inside our application
    will be passed into the router constructor. As you can see, we're prepared for
    the `main` element (mother of all that's displayed to the user). We'll also create
    a `navView` property. You can probably guess that this will display some navigation;
    our app will have several important links, and we want to make it simple for our
    users to get around. We'll write this view next.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might wonder why we've made `USER` a global variable instead of a property
    of our router. After all, as we saw last time, those properties are data from
    the server that we need inside views here on the browser, right? There's really
    no reason you couldn't, but I prefer to do it this way because our application
    isn't really about manipulating user records. While we will have a `User` class,
    it will just be for convenience. User records are not created or modified on the
    client side.
  prefs: []
  type: TYPE_NORMAL
- en: In our `routes` object, we're setting up our index route. Right now, we will
    only be rendering the navigation in that `index` method, but it's a good start.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write the navigation view. It''s the simplest view we have in this application,
    which is created by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is pretty standard view code. Notice that we''re using the `USER`
    object as the data for this template. Here''s the template content, which goes
    in the `index.ejs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve got enough here to give this a try. In the `index.ejs` file, make sure
    we''re creating and starting the router by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Start up the server (`npm start`) and head to `http://localhost:3000`. You
    should see something like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our application navigation](img/6997OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go ahead and create a new user account by putting a username and password into
    the bottom form. When you click on the **Create** button, you''ll be sent to a
    screen like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating our application navigation](img/6997OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's great! Things are shaping up.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you work through building this application, you''re going to find something
    annoying; every time you make a change, `nodemon` will restart the server, and
    the session that keeps you logged in will disappear. You''ll have to log in again,
    every time. To get around this, I added the following code at the top of the `server.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, everywhere that you use `req.user`, use `requser` instead. It's easy to
    do a search and replace on this, and it will keep you logged in over server refreshes.
    I'll continue to use `req.user` in the code snippets ahead. However, this convenience
    hack isn't perfect. When we get to the feature of following other users, you'll
    have to remove this `requser` variable, or things won't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s tackle the file uploads next. This is a photo sharing website, so it''s
    one of the most important features. Let''s begin by creating a view for the upload
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We start with an `initialize` function that assigns a property called `photos`
    that we get from the `options` object. This `photos` object is actually a collection,
    so you might wonder why we're not calling it `collection` in the `options` object;
    as you know, Backbone would handle this assignment automatically for us. The reason
    we're not doing it that way is so that it's clear that this view isn't for displaying
    this collection; it needs the collection for another reason (namely, to add a
    `Photo` model instance). You can write this off as semantics, but I hope the break
    from a Backbone convention makes someone reading the code pause and look for a
    reason.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `template`, `events`, and `render` properties are self-explanatory. The
    template that we''re pulling in is very simple: a little form that takes a file
    and a caption. This is the code for the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When that button is pressed, the `uploadFile` method is called. In there, we''ll
    cancel the default behavior of submitting the form and use the data to create
    an instance of the Photo model (coming soon). The `caption` property is obvious,
    but the `file` property is a little trickier. We start by getting the file input
    element, and then get the first item in the array property called `files`. This
    is the data we need to upload the file via AJAX. Then, we save this object by
    passing it to the collection''s `create` method. You might be curious about the
    `{ wait: true }` part. Hold that thought for a minute, however. It will be explained
    soon; when it will make sense, I''ll explain it.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we'll clear the form, so they can upload another one if they want to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can actually get this working, there are a couple of other pieces
    to build. Most obviously, we need the Photo model and Photos collection. In the
    last application, our models were pretty simple, but this one is more complex;
    this is the model class''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As you know, the `urlRoot` object is the base of the route that this model will
    GET and POST to on the server, but the big story here is the `sync` method. Normally,
    all models and collections use the `Backbone.sync` method. This is the method
    that is called every time we're reading or writing one or more models to or from
    the server. We can overwrite this at the model level if we need to do something
    a bit differently, and that's exactly the case here. Backbone doesn't support
    AJAX file uploads out of the box, so we need to write a `sync` function to do
    that.
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick here is that we can''t just write a function that does file uploads
    for creating new photo records. This is because of the fact that this is the method
    that is used for reading, updating, and deleting this model''s instances. As you
    can see, the `sync` method takes three parameters: the first is the CRUD method
    that we''re about to perform (create, read, update, and delete), the second is
    the `model` instance, and the third is an `options` object.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we'll be using jQuery to do the AJAX call, we only need to set up an `options`
    object of our own. That's how we start. Of course, it will need a URL, so we call
    this model class's `url` method. We also need to define a `success` callback.
    It's important that this callback calls the `success` method of the `options`
    object; this method will handle some important behind-the-scenes stuff. These
    properties are important no matter what method we're calling.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a `switch` statement; this is for the properties that will differ,
    depending on the method. In the case that we have `create`, we want to set the
    type to `POST`. We set the `data` property to a new `FormData` instance; this
    is how we send the file data. All we do is append the `file` property that we
    put on the model; we can append the caption as well.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to set `processData` and `contentType` to `false`. This way, we
    can be sure the file data will get to the server in the way we expect, so we can
    save it to a file.
  prefs: []
  type: TYPE_NORMAL
- en: We're also setting a default case here, which sets the type to GET. We're not
    preparing this method for doing updates or deletes, because that's not part of
    the application we're building. If we ever needed these features, we'd have to
    expand this.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we just need to make the AJAX call by using `$.ajax` and passing it
    in our `options` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need a `Photos` collection. For now, we''ll keep it simple. We''ll
    create it by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sync` method allows us to send our images to the server, but we don''t
    have a route ready to handle the incoming data, so that''s our next priority:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you saw, we're posting to `/photos`. Since this function is going to store
    a photo that needs to be viewable from the browser, we need to put it in the `public`
    folder. Go ahead and make a folder inside `public` called `images`, which is where
    we'll put them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a few paths. First, there''s `oldPath`; that''s the path to where
    the file is temporarily stored at the time of the request. Then, there''s `publicPath`:
    this is the path that we''ll use in the browser to view the photo; it''s just
    `images` plus the name of the file. We''re going to give the image a unique name
    based on the user''s ID and the number of photos we have in the database. Thirdly,
    there''s `newPath`, which is where we''re going to store the image relative to
    the current location.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To work with files like this in Node.js, we need to use the filesystem module,
    so add the following line to the top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can use the `rename` method to move the file. If this goes well, and
    there's no error, we can store the record for this image in the `photos` database.
    Notice that instead of a `file` property, we're just storing the `path` property.
    Once we send this object back to the browser, it will replace the attributes that
    we had. Once we store the photo, we'll send it back to the browser as confirmation
    that the deed is done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, move back to the client code in the `app.js` file. We need a route from
    which to access the upload form. If you look back at our navigation view, you''ll
    see that the route we want to make is `/upload`. You can add the following line
    to the `routes` object in `AppRouter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s create the `upload` function by doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re actually doing a bit more than you bargained for here; there''s a second
    view that we''re rendering: a `PhotosView` instance. Before we get to that though,
    notice that we''re using a `userPhotos` property; we have to add that to the router.
    Add the following line in the `AppRouter` class''s `initialize` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives us access to whatever collection we pass to the router as `userPhotos`.
    Then, in the `index.ejs` file, where we instantiate the router this line will
    create that collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now we create the `PhotosView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `PhotosView` class. Notice that we set the `tagName` property to
    `ul`; then, inside the `render` function, we just loop over the collection and
    call the `addPhoto` function, which renders the template and puts the result in
    the list. This time, instead of using the `template` function for the whole view,
    we use it to render each model in the collection. Also, notice that in the `initialize`
    function that we''re listening for whenever new photos are added to the collection,
    we can add them to the list. Now''s the time to recall that `{ wait: true }` option
    that we added when we made the `create` call. When we tell Backbone to wait like
    this, it won''t trigger this `add` event on a model until we''ve heard back from
    the server. This is important in this case, because otherwise we won''t have the
    public path for our image. The last piece for this class is the template; of course,
    the following code goes in the `index.ejs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It should all be in place now! You can go to `http://localhost:3000/upload`,
    choose a file, type a caption, and click on the **Upload** button. The file will
    be uploaded, and you''ll see it appear beneath the form. Congrats! You''ve just
    uploaded your first photo. The following screenshot shows how the photo might
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Uploading photos](img/6997OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While building this application, I used photos from [http://unsplash.com](http://unsplash.com);
    a great source for free high-resolution photos.
  prefs: []
  type: TYPE_NORMAL
- en: Sending photos from the server to the client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we work on another specific page, we need a route from which to get
    photos from the server. These photos will need to go in a `Photos` collection,
    but if you think about it for a second, you''ll realize that there are several
    different sets of photos we might get. For example, we could get all the photos
    from one user, or all the photos from the users that the current user follows.
    So, hold your breath, here''s that route''s code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Yes, it''s a doozy. Let''s start with the route; instead of a string, we''re
    using a regular expression that matches the routes we want it to catch. This one
    catches pretty much anything that begins with `/photos`. We''re interested in
    the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/photos/11`: Photo with ID 11'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/photos/following`: Photos of all the users the logged-in user is following'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/photos/user/2`: Photos of users with ID 2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capture groups from the route are put into `req.params`, so `req.params[1]`
    is the second capture group. We're putting that into the `getting` variable, and
    then we have to inspect if further. Assuming it exists, we check first to see
    if it's a number (by parsing it and passing it through `isNaN`). If it is a number,
    which is the easiest case, we find the photo with that ID and send it back.
  prefs: []
  type: TYPE_NORMAL
- en: If it's not a number, we run the `getting` variable against another regular
    expression to see if it matches `user/ID`. If it does, we'll return all the photos
    with the matching `userId`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the `getting` variable is the string `following`, we're going to
    loop over the current user's `following` array and get the photos from each of
    those users, pushing their photos into the `allPhotos` array, which we'll then
    return.
  prefs: []
  type: TYPE_NORMAL
- en: At any point, if we run into a pattern we weren't expecting, we'll just return
    an empty JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: Creating profile pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have this route available, we can do a lot more. How about a profile
    page? If you look back at the navigation view again, you'll see that we created
    a **My Profile** link, which takes us to `/users/1` (or whatever your ID number
    is). Of course, this means that we can use it for more than just our own profile
    page. It will work for any user, if we make the code generic enough.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll need a way to get the user data from the server (remember, this
    could be a profile for someone other than the logged-in user). We''ll use a model
    for this by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The URL is different from what we would usually do, but it shows the flexibility
    of Backbone; we can make the URL look like a path to a JSON file. Of course, this
    wouldn''t be so great if we needed to post to this URL to save a user (especially
    because a model doesn''t usually have an ID until it has been saved). However,
    since I know we won''t need to do that, we can have fun with this one and do it
    that way. As you might imagine, the server-side code is pretty simple as you can
    see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we can get a user, let''s add the profile page route to the router
    by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add the following method to the router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, let''s do something that''s a little different. Here''s the scenario:
    if users are viewing their own page, there''s no reason to pull their user and
    photo data from the server again; we can use the data we already have in the browser.
    To see if a user is viewing their own profile, we compare the ID in the route
    (which we get as a parameter) to the ID on the `USER` object. If the user is viewing
    another user''s profile, we create a user model and photos collection with just
    enough data: a model only needs `id`, and a collection only needs `url`. Then,
    we can have them both fetch the rest of the needed data from the server. In both
    cases, the `fetch` method returns a jQuery deferred object. If you aren''t familiar
    with deferreds or promises in JavaScript, think of them as a way to wait for data
    to be ready; we call the deferred''s `then` method, passing it a function to call
    when the data is ready. We''ll use promises a lot more in a later chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait, can we just hand a URL to a collection object? Not usually. We need to
    add an `initialize` method to our `Photos` collection class, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Clever, eh? This way, we can use any URL we want. That's why we created the
    URL-flexible backend for this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, we then call our internal `render` method. There''s something
    to note about this function. Even though it''s inside out router method, it will
    still be run in the global namespace; this is why we create the `thiz` variable,
    for use inside the `render` function. Of course, in one case we call it procedurally
    and in another we call it as a callback, but the same thing will be done; we will
    render the `UserView` instance. Here''s the code for that class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Very simple; it''s just a username and a list of your photos. We can even reuse
    the `PhotoView` class that we made earlier to display individual photos. Notice
    our use of the `this.$` method; it allows us to search for elements and create
    a jQuery object for those elements, but it limits the search to elements inside
    this view instance''s `el` property. Finally, here''s the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try this out, you might notice a problem; when viewing the current user''s
    profile, there won''t be any photos. That''s because we''re using the `userPhotos`
    property from the router, which is just an empty collection. When we load the
    page, we should load the user''s photos data too. This isn''t hard to do. First,
    back in your `server.js` file, in the `/*` route function, swap out your `res.render`
    call for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `index.ejs` file, use your template delimiters to put that in
    its place, inside the router instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Now, you should see your own photos on your profile page, because we're loading
    photos from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the individual photo page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve used the `PhotoView` class twice now; it creates a link, as you might
    recall, to an individual page for each photo. Let''s create that page next. This
    time, we''ll start in the router. First, add this route to the `routes` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, here''s the `showPhoto` method is partners with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as we did with the `showUser` function, we get the photo data by creating
    a `Photo` instance with `id`, and then calling the `fetch` method. However, we''re
    also creating a `Comments` collection based on this photo. Then, we create a `PhotoPageView`
    instance, which has both a model (the photo) and a collection (the comments).
    Once we fetch the comments from the server, we render it. So here''s the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can probably tell, this isn''t all of it. In the `initialize` function,
    we''re setting an event to call the `showComment` method whenever a new comment
    is added to the collection. This is also the method we use inside the `render`
    method to show each of the already-existing comments. Then, we have an event:
    a button-click that triggers an `addComment` method. Before we get to these methods,
    you might want to see the button as well as the rest of the template; here''s
    the template''s code, which you should add to the `index.ejs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s add those methods now, shall we? We''ll tackle the longer one first.
    The following is the code for the `addComment` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This is pretty similar to the `addPhoto` method in our `AddPhotoView` class.
    We create an attributes object with the text from the textbox, the ID of the photo
    we're commenting on, and the username of the commenter. Then, we send them to
    the server through the collection's `create` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we do this, our `add` event will be triggered, and the `showComment` method
    will be called. Here''s that method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, the magic is elsewhere. You want to see the `CommentView` instance,
    which is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s so simple; even its template is simple. Its template''s code is given
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Throughout all this, we got so excited that we completely overlooked an important
    factor: we don''t have a `Comment` model or a `Comments` collection yet. Not to
    worry. We create these by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `Comments` collection''s `url` function. It takes the `url` of the
    photo instance that was assigned as a property and appends `/comments` to the
    end. So, in our `server.js` file, we need to create the GET and POST methods for
    this route, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The GET route will return all the photos with the `photoId` property matching
    the URL parameter. Here''s the POST route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This route will take the attributes, create an object out of them, store them
    in the `comments` database, and return the saved version as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s a wrap on the comments feature! You should be able to go to an individual
    photo page, type a comment in, click on the button, and see your comment appear
    below. Even better, the comment will still be there when you refresh the page.
    The following screenshot shows what it may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the individual photo page](img/6997OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Following users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This brings us to what is easily the most complicated feature of our application:
    following other users. We want users to be able to choose which users they want
    to follow, and have those users'' photos show up on the home page.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start with the `/users` route. Add the following line to the router''s
    `routes` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create the `showUsers` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We don't really have a `Users` collection class yet; that's next. However, you
    can see that we'll fetch all the users here, and then render a `UserListView`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Users` collection is very straightforward, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we''ll need to put the server-side bits in place, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can look at the `UserListView` instance. Actually, it''s another one
    of our wrapper views, only there to pull together a collection of individual model
    views, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code, the one we''re really interested in is the `UserListItemView`
    instance. This is probably the biggest view you''ll see today (or at least in
    this chapter). We''ll take it piece by piece, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: This is the start. As you can see from the events, we will have follow and unfollow
    buttons that will trigger respective methods. The `render` function starts by
    rendering the template, which we'll put inline, because it's small.
  prefs: []
  type: TYPE_NORMAL
- en: More interesting things happen after rendering. First, we check to see if the
    user we're creating a list item for is the currently logged-in user; if it is,
    we'll add the text `(me)` to the end of it. Otherwise, we'll call the `update`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` method is actually pretty basic. Its goal is to see if the current
    user is following the user that we''re making the list item for. If they''re already
    following that user, we''ll put in an **Unfollow** button; otherwise, we''ll use
    the **Follow** button. This method will also be called when one of these buttons
    is clicked on, so we''ll remove buttons when appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It's pretty simple, actually. If the view's user ID is in the current user's
    `following` array, we remove an **Unfollow** button and add a **Follow** button.
    Otherwise, we remove the **Follow** button and add an **Unfollow** button. At
    this point, we could load the `/users` page, and we'll have a list of users with
    follow buttons. However, clicking on them won't do anything. We need to write
    those `follow` and `unfollow` functions (in the `UserListItemView` class).
  prefs: []
  type: TYPE_NORMAL
- en: 'These two functions are almost identical, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, we create a new `Follow` model instance. When the goal is to
    save the `following` array, we set the `userId` property; when the goal is to
    delete the `following` array, we set the `id` property. In the case of the `follow`
    function, we save that model; on the server side, this will add the user to the
    `following` array of the current user. In the case of the `unfollow` function,
    we delete the model; on the server side, this will remove the user from the `following`
    array. Again, in both cases, the method that calls to the server will return a
    deferred object. We'll pass the `then` method, a function that will reset the
    `following` array on the `USER` object with the `following` array from the server.
    In both cases, we'll then call the `update` method to correct the buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to create the `Follow` model. Really, we don''t need to use
    a Backbone model here; we just need two AJAX requests. However, we can make hacky
    use of a model class to do all the hard work for us. The following is the code
    for the `Follow` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: That's really it. We can use this class in two ways. If we give a `Follow` instance
    a `userId` property, we can then call the `save` method to POST to `/follow`.
    Or, if we create a `Follow` instance with an `id` property, we can call the `destroy`
    method to send a DELETE request to `/follow/id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Things are a little more complicated on the server side. First, let''s take
    a look at the POST route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We begin by finding out whether the ID is in the user's `following` list. If
    it isn't, we'll push it into the array and update the user record in the database.
    Then, we'll send back the updated user record. Even if the user is already following
    the chosen user, we'll still send the user data back.
  prefs: []
  type: TYPE_NORMAL
- en: 'The DELETE route is similar to that POST route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: If the current user is following this user, we'll use the JavaScript `splice`
    method to remove the item from the array (this method mutates the array, so we
    don't reassign it to `req.user.following`). Then, we'll update user records in
    the database and send the updated user back as JSON (we're sending `users[0]`
    because the `update` function gives an array to the `callback` function, but in
    our case that array should have only one record).
  prefs: []
  type: TYPE_NORMAL
- en: Now that this is in place, our `/users` route will have working follow/unfollow
    buttons. We can follow a few other users.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a followed user's photos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What do we do with followed users? We want to show the photos from the followed
    users on the home page. First, in the `server.js` file, we need to be able to
    get all the photos from all the users the current user is following. We''re going
    to write a separate function for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Does it look familiar? It''s almost identical to some of the code we had in
    our photo-fetching route, you know, the one with the regular expression route.
    Since we''ve put this code in a function, you can replace the appropriate lines
    in that function, so they look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step on the server side is to send these following photos to the client,
    where we''ll display them on the home page. Let''s wrap our previous `res.render`
    call with the function we just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in the `index.ejs` file, we can add `followingPhotos` to our router options
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll have to use the property in our `AppRouter` class, so add the following
    line to the `initialize` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to use this in the router''s `index` method; the whole body
    of that method should now look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you go to the home page, you'll be able to see the photos of the users
    you are following! Excellent!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've covered a lot of ground in the chapter, so let's retrace our steps a bit
    before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most important things I want you to take away from this chapter
    is how data is sent from the server to the client. We''ve used two different methods
    here: first, we use a server-side template to put them into the HTML response
    and send them as part of that. Secondly, we use `fetch` commands from the client
    and create a completely separate HTTP request for that data. The advantage of
    the first method is that individual "chunks" of data don''t have their own HTTP
    headers; also, since they''re part of the initial request, the user will never
    wait for data while using the application. The advantage of the second method
    is that we never load more data than we need to from the server; when we need
    it, it''s easy to request it. This is especially important in an application like
    this one, where a single user could have hundreds of posted photos over time,
    and people are likely to follow a lot of users; you wouldn''t want to load all
    the data right from the start. We''ve mixed it up here so that you can get a feel
    of how both methods work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, you should note that this mixing-it-up actually causes us to load
    more data than necessary most of the time. This is because we''re loading the
    current user''s photos and the photos of the people they follow even when we aren''t
    using that data (for example, on the user''s list page). We''ve actually written
    all our Backbone code so that we could override the default anchor tag behavior
    and navigate our entire app with the router''s `navigate` method; no page refreshes
    would be necessary. That might be a good exercise: try implementing functionality
    that uses Backbone''s navigation instead of refreshing the page. If you get stuck,
    review the code from the last chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from data loading techniques, we saw that the Backbone model and collection
    classes are actually very flexible and can be used in "nontraditional" ways. I
    hope you're finding that when you take the magic out of Backbone, and understand
    exactly what it's doing, you can use it more efficiently. These ideas will be
    very useful when we build a live data dashboard in the next chapter.
  prefs: []
  type: TYPE_NORMAL
