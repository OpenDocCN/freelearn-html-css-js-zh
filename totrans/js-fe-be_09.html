<html><head></head><body>
		<div><h1 id="_idParaDest-124"><em class="italic"><a id="_idTextAnchor123"/>Chapter 6</em>: Creating and Using Node.js Modules</h1>
			<p>Modules are at the heart of Node.js. They correspond to JavaScript files and can be used in our applications. A program for the Node.js server will consist of a set of modules, that is, JavaScript files.</p>
			<p>There are three kinds of modules:</p>
			<ul>
				<li>Modules that we write ourselves for our applications.</li>
				<li>Modules internal to Node.js and usable directly.</li>
				<li>Modules that can be downloaded from the internet using a utility called <code>npm</code> (npm stands for Node.js package manager). This <code>npm</code> utility is installed with Node.js itself.</li>
			</ul>
			<p>In this chapter, we will learn how to create and use these different types of modules.</p>
			<p>Regardless of the type of modules used, the <code>require(moduleName)</code> instruction (see below) allows the module called <code>moduleName</code> to be included in the current file. The functionalities of the module will then be accessible.</p>
			<p>Here are the topics covered in this chapter:</p>
			<ul>
				<li>Using our own modules</li>
				<li>Using internal Node.js modules</li>
				<li>Using downloaded modules with npm</li>
			</ul>
			<p>Let’s first see how to create and use our own modules with Node.js.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip">https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip</a>.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Creating and using our own modules</h1>
			<p>In this example, we <a id="_idIndexMarker462"/>use two modules, each corresponding to a JavaScript file:</p>
			<ul>
				<li>The first module (here named <code>test.js</code>) will be the main file of our application, the one we execute using the <code>node test.js</code> command in a command window.</li>
				<li>The second module (here named <code>module1.js</code>) will be the one we want to use in our main <code>test.js</code> module. The <code>module1.js</code> module will then be enriched to show how its functionalities are accessible outside the module (and will therefore be used in the main <code>test.js</code> module).</li>
			</ul>
			<p>Let’s go ahead and create these two modules. </p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Creating a module</h2>
			<p>Here is the content of the two files, <code>module1.js</code> and <code>test.js</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">module1.js file</p>
			<pre class="source-code">console.log("module1.js is loaded");</pre>
			<p>The module currently<a id="_idIndexMarker463"/> has a simple <code>console.log()</code> statement. The module will then be enriched. The main module test.js is the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">test.js file</p>
			<pre class="source-code">var mod1 = require("./module1.js");  </pre>
			<pre class="source-code">// or require("./module1") without specifying the .js extension</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<p>Here, we use the <code>require(moduleName)</code>instruction, which allows us to load in memory the <code>moduleName</code> module. Any use of the functionalities of the <code>moduleName</code> module requires the <code>require(moduleName)</code>instruction beforehand.</p>
			<p>The <code>require(moduleName)</code> instruction returns a reference to the module loaded in memory. This reference is stored in a variable (here, <code>mod1</code>), which will then allow access to the functionalities described in the module (here, none for the moment).</p>
			<p>The <code>test.js</code> file is the main file that loads the other modules. It is therefore this <code>test.js</code> file that is executed using the <code>node test.js</code> instruction in a command window.</p>
			<div><div><img src="img/Figure_6.01_B17416.jpg" alt="Figure 6.1 – Using a module with require(module)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Using a module with require(module)</p>
			<p>We can see here that the execution of the main <code>test.js</code> module invokes the call of the <code>require("./module1.js")</code>instruction, which executes the content of the <code>module1.js </code>file, hence the display text specified in the <code>console.log()</code> statement in the <code>module1.js</code> module.</p>
			<p>After loading <code>module1.js</code>, the <code>mod1</code> variable is initialized and we will be able to access functionalities that the <a id="_idIndexMarker464"/>module exports later on.</p>
			<p>Before adding functionalities to the <code>module1.js</code> module, let’s see how to manage the location of modules using the <code>node_modules</code> directory. The <code>node_modules</code> directory is used by Node.js to locate modules for which it does not have a path. Using this directory simplifies the writing of module names when loading them into memory with the <code>require(moduleName)</code> instruction.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Using the node_modules directory</h2>
			<p>Note that the previous <code>require(moduleName)</code> statement requires indicating the access path to the <a id="_idIndexMarker465"/>module, for example, <code>"./"</code> to indicate the current directory.</p>
			<p>However, if the module is in the <code>node_modules</code> directory, it is not necessary to indicate the path because we are sure that the module is inside the <code>node_modules</code> directory (and moreover, it should <em class="italic">not</em> be specified). The <code>node_modules</code> directory can be in the main application directory (called the <em class="italic">local</em> <code>node_modules</code> directory) or in a dedicated directory<a id="_idIndexMarker466"/> created by Node.js (called the <em class="italic">global</em> <code>node_modules</code> directory: in this case, it is automatically created during the installation of Node.js).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If the module is not found in the <code>node_modules</code> directory (local or global) and if the access path to the module is not indicated, an error occurs when loading the module with the <code>require(moduleName)</code> instruction.</p>
			<p>Now, we will create a <code>node_modules</code> directory in the current directory where the main file, <code>test.js</code>, is located. Let’s transfer the <code>module1.js</code> file to this directory and use the <code>require("module1.js")</code> statement without specifying the path to the module. You can also write <code>require("module1")</code> without indicating the extension of the JavaScript file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Include module1 located in node_modules directory (test.js file)</p>
			<pre class="source-code">var mod1 = require("module1.js");  // or require("module1")</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<p>The <code>module1.js</code> file must be in the locally created <code>node_modules</code> directory, while the <code>test.js</code> file remains in the current directory, as described here:</p>
			<p><code>root/</code></p>
			<p><code>|— node_modules/</code></p>
			<p><code>│       |— module1.js</code></p>
			<p><code>|— test.js</code></p>
			<div><div><img src="img/Figure_6.02_B17416.jpg" alt="Figure 6.2 – The module is loaded from the node_modules directory&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – The module is loaded from the node_modules directory</p>
			<p>We can see that the module is indeed found by Node.js, because Node.js looks for it in the <code>node_modules</code> directory, which was created in the current directory.</p>
			<p>Now let’s see how to allow a <a id="_idIndexMarker467"/>module’s files to be grouped in a directory, using the <code>package.json</code> file associated with the module.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>Using the package.json file</h2>
			<p>The <code>node_modules</code> directory (whether located in the application directory or the Node.js installation directory) can <a id="_idIndexMarker468"/>contain a lot of files and sometimes a module can consist of many files and directories. It would be easier to associate a module with a directory in the <code>node_modules</code> directory.</p>
			<p>Let’s create the <code>module1</code> directory inside the <code>node_modules</code> directory. The <code>module1</code> directory contains the <code>module1.js</code> file but may also contain other files and directories related to this module.</p>
			<p>The file system is displayed here:</p>
			<p><code>root/</code></p>
			<p><code>|— node_modules/</code></p>
			<p><code>|       |— module1/</code></p>
			<p><code>│              |— module1.js</code></p>
			<p><code>|— test.js</code></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>moduleName</code> indicated in the <code>require(moduleName)</code> statement represents, in this case, the name of the <em class="italic">directory</em> that contains the module files.</p>
			<p>But as it is necessary to know which file of the directory we must use first when loading the module (as there can be many files in this directory), we indicate this correspondence in the <code>package.json</code> file in the <code>"main"</code> key.</p>
			<p>The <code>package.json</code> file is a text file in JSON format, located in the directory of each Node.js module.</p>
			<p>Now, we will <a id="_idIndexMarker469"/>create the <code>package.json</code> file in the <code>module1</code> module directory and indicate in this file the <code>"main"</code> key with the value <code>"module1.js"</code>.</p>
			<p>The file system is as follows:</p>
			<p><code>root/</code></p>
			<p><code>|— node_modules/</code></p>
			<p><code>|       |— module1/</code></p>
			<p><code>│              |— module1.js</code></p>
			<p><code>│              |— package.json</code></p>
			<p><code>|— test.js</code></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json file in the node_modules/module1 directory (package.json file)</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "main" : "module1.js"</pre>
			<pre class="source-code">}</pre>
			<p>We indicate in the <code>"main"</code> key that we must load the <code>module1.js</code> file during the <code>require("module1")</code> instruction:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Including module1 located in node_modules/module1 directory (test.js file)</p>
			<pre class="source-code"><strong class="bold">var mod1 = require("module1"); </strong>//"module1" is the directory name</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Please note that the module name in the <code>require("module1")</code> statement in this case is the name of the directory that contains the module in the <code>node_modules</code> directory. So, we cannot write the instruction here in the form <code>require("module1.js")</code>, which would cause an error.</p>
			<p>We now visualize the<a id="_idIndexMarker470"/> execution of the <code>test.js</code> file:</p>
			<div><div><img src="img/Figure_6.02_B17416.jpg" alt="Figure 6.3 – Module loaded with the package.json file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Module loaded with the package.json file</p>
			<p>The <code>"main"</code> key in the <code>package.json</code> file is optional if the main module file is named <code>index.js</code>. In all other cases, the <code>"main"</code> key must be indicated in <code>package.json</code>.</p>
			<p>We know how to run a module, but for now, the module contains a simple <code>console.log()</code> statement. Let’s see how to add features to the module and then use them.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Adding functionalities to the module</h2>
			<p>The newly <a id="_idIndexMarker471"/>created <code>module1.js</code> module is accessible but does not currently offer any functionality. Let’s see how to add some.</p>
			<h3>Exporting multiple functions in the module</h3>
			<p>For example, let’s create<a id="_idIndexMarker472"/> the function <code>add(a, b)</code>, which returns the sum of <code>a</code> and <code>b</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">add(a, b) function defined in module1.js (module1.js file)</p>
			<pre class="source-code">console.log("module1 is loaded");</pre>
			<pre class="source-code">function add(a, b) {</pre>
			<pre class="source-code">  return a+b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">module.exports = { </strong></pre>
			<pre class="source-code"><strong class="bold">  add : add     // make the add() function accessible </strong></pre>
			<pre class="source-code"><strong class="bold">                // outside the module</strong></pre>
			<pre class="source-code"><strong class="bold">}; </strong></pre>
			<p>To export a function outside of a module (and make it accessible to users of the module), you can just embed it in the <code>module.exports</code> object defined by Node.js in each module. Each key defined in the <code>module.exports</code> object will be a function accessible outside the module.</p>
			<p>We can thus define several functions<a id="_idIndexMarker473"/> in the module that will be accessible thanks to the <code>module.exports</code> object.</p>
			<p>The usage of the <code>add(a, b)</code> function in the <code>test.js</code> file is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using add() function in test.js file (test.js file)</p>
			<pre class="source-code">var mod1 = require("module1");</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<pre class="source-code"><strong class="bold">var total = mod1.add(2, 3);</strong>      // call of the add() function </pre>
			<pre class="source-code">                                 // defined in module1</pre>
			<pre class="source-code">console.log("mod1.add(2, 3) = ", total);  // displays 5</pre>
			<p>The following display is obtained:</p>
			<div><div><img src="img/Figure_6.04_B17416.jpg" alt="Figure 6.4 – The add() function added to the module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The add() function added to the module</p>
			<p>Let’s add a second function in the <a id="_idIndexMarker474"/>module. For example, the function <code>mult(a, b)</code>, which returns <code>a*b</code>.</p>
			<p>If we add the <code>mult(a, b)</code> function in the module, it is written as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Adding the mult(a, b) function to the module (module1.js file)</p>
			<pre class="source-code">console.log("module1 is loaded");</pre>
			<pre class="source-code">function add(a, b) {</pre>
			<pre class="source-code">  return a+b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">function mult(a, b) {</strong></pre>
			<pre class="source-code"><strong class="bold">  return a*b;</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code"><strong class="bold">module.exports = {</strong></pre>
			<pre class="source-code"><strong class="bold">  add : add,</strong></pre>
			<pre class="source-code"><strong class="bold">  mult : mult</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<p>Now, we will use the two functions <code>add()</code> and <code>mult()</code> in the <code>test.js</code> file. This verifies that a <a id="_idIndexMarker475"/>module can provide several functionalities to other modules that use it:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the module’s add() and mult() functions (test.js file)</p>
			<pre class="source-code">var mod1 = require("module1");</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<pre class="source-code">var total = mod1.add(2, 3);</pre>
			<pre class="source-code">console.log("mod1.add(2, 3) = ", total);      // 2 + 3 = 5</pre>
			<pre class="source-code">var total = mod1.mult(2, 3);</pre>
			<pre class="source-code">console.log("mod1.mult(2, 3) = ", total);     // 2 * 3 = 6</pre>
			<p>The following display is obtained:</p>
			<div><div><img src="img/Figure_6.05_B17416.jpg" alt="Figure 6.5 – Using the two functions of the module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Using the two functions of the module</p>
			<p>Now let’s see how to improve the module concept by using a so-called main function in the module.</p>
			<h3>Allowing a function to be the main function of the module</h3>
			<p>Often, the module wishes to make a function its main function (the other functions defined in the module are secondary functions). This allows access to this main function in a simplified form.</p>
			<p>Suppose (as before) that <code>module1</code> makes available the <code>add(a, b)</code>function and the <code>mult(a, b)</code>function. We want the <code>add()</code> function to be the main function of the module, which means that we can use it outside the module as <code>mod1(2, 3)</code> instead of <code>mod1.add(2, 3)</code>. The <code>mult(a, b)</code> function will remain accessible in the form <code>mod1.mult(2, 3)</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that only one function can be defined as the main function in a module.</p>
			<p>In this case, just specify it in the <code>module.exports</code> object like so:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Making the add() function accessible as a main module function (module1.js file)</p>
			<pre class="source-code">console.log("module1 is loaded");</pre>
			<pre class="source-code">function add(a, b) {</pre>
			<pre class="source-code">  return a+b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">function mult(a, b) {</pre>
			<pre class="source-code">  return a*b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">// first define the main function</strong></pre>
			<pre class="source-code"><strong class="bold">module.exports = add;  // the add() function defined outside </strong></pre>
			<pre class="source-code"><strong class="bold">                       // the module, is made main</strong></pre>
			<pre class="source-code"><strong class="bold">// then define the secondary functions</strong></pre>
			<pre class="source-code"><strong class="bold">module.exports.mult = mult;   // and the mult() function </strong></pre>
			<pre class="source-code"><strong class="bold">                              // becomes usable as well</strong></pre>
			<p class="callout-heading">Note</p>
			<p class="callout">It is important to assign the values in this order in the <code>module.exports</code> object (define the main function first, then the secondary functions). If you make the assignment in the other direction (<code>module.exports.mult</code> first, then <code>module.exports</code>), the assignment of <code>module.exports</code> last will erase the value already positioned in <code>module.exports.mult</code>.</p>
			<p>Also, we can no longer assign <code>module.exports</code> as an object, because that would remove the previously<a id="_idIndexMarker476"/> assigned value if we wrote <code>module.exports = { mult : mult }</code>.</p>
			<p>We now use the module as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the module1.js module that has a main function (test.js file)</p>
			<pre class="source-code">var mod1 = require("module1");</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<pre class="source-code"><strong class="bold">var total = mod1(2, 3);</strong>          // instead of mod1.add(2, 3)</pre>
			<pre class="source-code">console.log("mod1(2, 3) = ", total);</pre>
			<pre class="source-code"><strong class="bold">var total = mod1.mult(2, 3);</strong></pre>
			<pre class="source-code">console.log("mod1.mult(2, 3) = ", total);</pre>
			<p>The following display is obtained:</p>
			<div><div><img src="img/Figure_6.06_B17416.jpg" alt="Figure 6.6 – Using the module with the main function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Using the module with the main function</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Notice that instead of using the <code>mod1</code> variable as an object, we now use it as a function. In the call to <code>mod1(a, b)</code> causes the addition of a and b, so it is preferable that the variable be named <code>"add"</code> rather than <code>"mod1"</code> in the instruction <code>require(moduleName)</code>.</p>
			<p>We saw how to create and <a id="_idIndexMarker477"/>use our own module. Now let’s take a look at how to use internal Node.js modules.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Using internal Node.js modules</h1>
			<p>Node.js already has internal modules. They <a id="_idIndexMarker478"/>can also be used with the <code>require(moduleName)</code> instruction seen previously.</p>
			<p>Let’s look at an example of an internal module. There is, for example, the <code>"fs"</code> module in the Node.js system. The name <code>"fs"</code> is short for file system. This module allows you to interact with the internal file system of Node.js.</p>
			<p>Now, we will use the <code>"fs"</code> module to read the contents of a file.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Reading the contents of a file</h2>
			<p>Let’s use the <code>"fs"</code> module to read the<a id="_idIndexMarker479"/> file named <code>file1.txt</code> located in the current directory (where the <code>test.js</code> file is located). Here<a id="_idIndexMarker480"/> are the contents of this file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">file1.txt file (in the directory where test.js is located)</p>
			<pre class="source-code">This is the content</pre>
			<pre class="source-code">of the file file1.txt</pre>
			<pre class="source-code">located in</pre>
			<pre class="source-code">the current directory.</pre>
			<p>The program that uses the <code>"fs"</code> module and displays the contents of the file is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Reading and displaying the contents of the file (test.js file)</p>
			<pre class="source-code"><strong class="bold">var fs = require("fs");</strong></pre>
			<pre class="source-code"><strong class="bold">var data = fs.readFileSync("file1.txt");</strong></pre>
			<pre class="source-code">console.log("File content:");</pre>
			<pre class="source-code">console.log(data);</pre>
			<p>We use the <code>readFileSync()</code> method defined in the <code>"fs"</code> module. It returns the contents of the file in the corresponding variable, which is then displayed.</p>
			<div><div><img src="img/Figure_6.07_B17416.jpg" alt="Figure 6.7 – Displaying file contents using the &quot;fs&quot; module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Displaying file contents using the “fs” module</p>
			<p>The contents of the<a id="_idIndexMarker481"/> file are displayed but as hexadecimal characters. Next, let’s display the contents of the file <a id="_idIndexMarker482"/>as strings.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Displaying file contents as strings</h2>
			<p>The contents of the file are <a id="_idIndexMarker483"/>displayed in the form of a buffer of bytes (see <em class="italic">Figure 6.7</em>). Node.js makes it easy to manipulate byte<a id="_idIndexMarker484"/> streams. It is also possible to view the contents of the file directly as strings by specifying the <code>{encoding: "utf-8"}</code> option in the second parameter (<code>options</code>) of the <code>readFileSync(name, options)</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying file contents as strings (test.js file)</p>
			<pre class="source-code">var fs = require("fs");</pre>
			<pre class="source-code">var data = <strong class="bold">fs.readFileSync("file1.txt", { encoding : "utf-8" });</strong></pre>
			<pre class="source-code">console.log("File content:");</pre>
			<pre class="source-code">console.log(data);</pre>
			<p>The result is now displayed as strings (see the following figure):</p>
			<div><div><img src="img/Figure_6.08_B17416.jpg" alt="Figure 6.8 – Displaying file contents as strings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Displaying file contents as strings</p>
			<p>The contents of the file are displayed. However, the program waits for the contents of the file to be retrieved in order to display<a id="_idIndexMarker485"/> them. By using the <code>readFile()</code> method instead of the <code>readFileSync()</code> method, it is <a id="_idIndexMarker486"/>possible to not block the program while waiting for the file.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Using non-blocking file reading</h2>
			<p>If you observe the previous <code>readFileSync()</code> method, you will see that the contents of the file are <a id="_idIndexMarker487"/>rendered in return for the method call. This means that the Node.js program is blocked while the file is being read (even if only <a id="_idIndexMarker488"/>for a few milliseconds). Within our small program, this is not noticeable, but in a case where the reading of the file is carried out by thousands of simultaneous users (for example, on a server), this will slow down access to the server.</p>
			<p>For this, Node.js has provided, for all blocking features such as this one, a non-blocking version of the method. Rather than returning the return result of the method (as before), we use a callback function indicated as a parameter of the method. In the case of reading the file, we will therefore use the <code>readFile(name, options, callback)</code> method, also defined in the <code>"fs"</code> module. The result of reading the file will be passed as a parameter in the callback function.</p>
			<p>Let’s use the non-blocking form of reading the file, using the <code>readFile()</code> method instead of the <code>readFileSync()</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using readFile() method to read the file (test.js file)</p>
			<pre class="source-code">var fs = require("fs");</pre>
			<pre class="source-code">console.log("File content:");</pre>
			<pre class="source-code"><strong class="bold">fs.readFile("file1.txt", { encoding : "utf-8" }, function(error, data) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log(data);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code">console.log("The readFile() method was called");</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The callback function uses the <code>error</code> and <code>data</code> parameters (in that order), which respectively correspond to a possible error message (<code>null</code> if none), and to the contents of the file if the latter has been read. The <code>options</code> parameter indicated as the second parameter of <code>readFile()</code> is similar to that of the <code>readFileSync(name, options)</code> method.</p>
			<p>The result is <a id="_idIndexMarker489"/>displayed here:</p>
			<div><div><img src="img/Figure_6.09_B17416.jpg" alt="Figure 6.9 – Displaying file contents using the non-blocking readFile() method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Displaying file contents using the non-blocking readFile() method</p>
			<p>We can check in the <a id="_idIndexMarker490"/>result displayed above that the <code>readFile()</code> method is really non-blocking. Indeed, the text indicated following the call to the <code>readFile()</code> method is displayed in the console even though the file has not yet been read and displayed, which would have been impossible using the blocking method <code>readFileSync()</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We can therefore see that the use of modules internal to Node.js is done very simply by using the <code>require(moduleName)</code> instruction, and then by calling methods on the object returned by this instruction.</p>
			<p>We have seen how to create and use your own modules, and how to use internal Node.js modules.</p>
			<p>Now let’s see how to use <a id="_idIndexMarker491"/>modules available on the internet using the <code>npm</code> command.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/>Using downloaded modules with npm</h1>
			<p>In addition to the modules internal to <a id="_idIndexMarker492"/>Node.js, it is possible to import modules from the internet using the <code>npm</code> utility provided with Node.js.</p>
			<p>For this, the <code>npm</code> command is<a id="_idIndexMarker493"/> used (in a command interpreter) by indicating arguments that allow you to perform the corresponding actions on the imported modules.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Using the npm command</h2>
			<p>Here are some common <a id="_idIndexMarker494"/>uses of the <code>npm</code> command:</p>
			<ul>
				<li><code>npm install moduleName</code>: Installs the indicated module in the <em class="italic">local</em> <code>node_modules</code> directory. The module will only be accessible for the current application and not for other applications (unless it is installed again).</li>
				<li><code>npm install moduleName -g</code>: Installs the specified module in the <em class="italic">global</em> <code>node_modules</code> directory. The <code>-g</code> option allows you to indicate that this module can be accessed by other applications because it is installed in the <code>node_modules</code> directory of Node.js (globally).</li>
				<li><code>npm link moduleName</code>: It is possible that a module installed globally (with the <code>-g</code> option) is inaccessible (you get a module loading error during the <code>require(moduleName)</code> statement). In this case, it is necessary to run the <code>npm link moduleName</code> command.</li>
				<li><code>npm ll</code>: Lists modules already present in the <em class="italic">local</em> <code>node_modules</code> directory.</li>
				<li><code>npm ll -g</code>: Lists modules already present in the <em class="italic">global</em> <code>node_modules</code> directory.</li>
				<li><code>npm start</code>: Starts the Node.js application according to the command indicated in the <code>"scripts"</code> key, then the <code>"start"</code> key of the <code>package.json</code> file. For example, if you specify <code>"scripts": { "start": "node test.js" }</code> in the <code>package.json</code> file, you can type <code>npm start</code> instead of <code>node test.js</code> to run the <code>test.js</code> file. It is common to use <code>npm start</code> to start a Node.js <a id="_idIndexMarker495"/>application. This will be used to start an application<a id="_idIndexMarker496"/> under <code>uninstall</code> instead of <code>install</code>.</p></li>
			</ul>
			<p>As an example, let’s create the following <code>package.json</code> file in the directory of the <code>test.js</code> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json file (in the same directory as test.js)</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "scripts" : {</pre>
			<pre class="source-code">    "start" : "node test.js"</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Then use the <code>npm start</code> command to start the program:</p>
			<div><div><img src="img/Figure_6.10_B17416.jpg" alt="Figure 6.10 – Starting the Node.js application with npm start&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Starting the Node.js application with npm start</p>
			<p>We can see that the <code>npm start</code> command thus makes it possible to execute the <code>test.js</code> program. The <code>npm start</code> command is often used to start a Node.js program, thanks to the mechanism explained above.</p>
			<p>Now let’s see how to use <a id="_idIndexMarker497"/>modules written by other developers by downloading them using <code>npm</code>.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Using a downloaded module with npm</h2>
			<p>Let’s look at an <a id="_idIndexMarker498"/>example of using <code>npm</code>. Here, we <a id="_idIndexMarker499"/>will use <code>npm</code> to install the module named <code>colors</code>. It allows you to display colored text in the console.</p>
			<h3>Installing the colors module in the node_modules local directory</h3>
			<p>We use the <a id="_idIndexMarker500"/>command <code>npm install colors</code>. The<a id="_idIndexMarker501"/> result of the installation of the <code>"colors"</code> module is displayed in the following figure.</p>
			<div><div><img src="img/Figure_6.11_B17416.jpg" alt="Figure 6.11 – Installing the colors module with npm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – Installing the colors module with npm</p>
			<p>Once the <a id="_idIndexMarker502"/>module has been installed by <code>npm</code>, you can see that the <code>colors</code> directory of the module has<a id="_idIndexMarker503"/> inserted itself into the <code>node_modules</code> local directory of the application.</p>
			<h3>Using the features of the colors module</h3>
			<p>One of the ways to have an <a id="_idIndexMarker504"/>overview of the functionalities offered by a module is to display the content of the object returned by the <code>require(moduleName)</code> instruction:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying contents of colors object returned by require(“colors”) (test.js file)</p>
			<pre class="source-code">var colors = require("colors");</pre>
			<pre class="source-code">console.log("colors = ", colors);</pre>
			<div><div><img src="img/Figure_6.12_B17416.jpg" alt="Figure 6.12 – Displaying contents of the colors module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – Displaying contents of the colors module</p>
			<p>For example, let’s use the <a id="_idIndexMarker505"/>last method listed in the module, namely the <code>random()</code> method. It allows you to transform a character string into a string with random colors for each character:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the random() method of the colors module (test.js file)</p>
			<pre class="source-code">var colors = require("colors");</pre>
			<pre class="source-code">console.log(colors.random("First text in random colors"));</pre>
			<pre class="source-code">console.log(colors.random("Second text in random colors"));</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The <code>random()</code> method is used by prefixing its name with the name of the variable returned by <code>require("colors")</code>, that is, with the name of the module.</p>
			<p>The display of the following figure is obtained, in which each character displayed is a random color:</p>
			<div><div><img src="img/Figure_6.13_B17416.jpg" alt="Figure 6.13 – Using the colors module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – Using the colors module</p>
			<p>We have seen here<a id="_idIndexMarker506"/> the three types of modules used with Node.js:</p>
			<ul>
				<li>Modules written by ourselves, for our own needs</li>
				<li>Existing internal modules in Node.js, such as the <code>fs</code> module allowing access to the internal file system of Node.js</li>
				<li>Modules downloadable using the <code>npm</code> command, such as the colors module used above</li>
			</ul>
			<p>All that remains is to use these different types of modules in our programs. We will discuss that later on. </p>
			<p>This brings us to the end of the chapter. </p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Summary</h1>
			<p>We have seen in this chapter how to create and use modules with Node.js, which are the essential components of programs created with Node.js.</p>
			<p>Whether the module is created by us, is an internal Node.js module, or is a module downloaded with <code>npm</code>, its use is the same in all cases. We use the <code>require(moduleName)</code> instruction and with the value returned in a variable, we access the functionality of the module.</p>
			<p>Next, we are going to study the Express module, which is one of the main modules used with Node.js, allowing us to easily structure our applications according to the rules of the MVC model, currently widely used.</p>
		</div>
	</body></html>