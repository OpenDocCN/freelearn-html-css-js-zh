<html><head></head><body>
		<div id="_idContainer131">
			<h1 id="_idParaDest-124"><em class="italic"><a id="_idTextAnchor123"/>Chapter 6</em>: Creating and Using Node.js Modules</h1>
			<p>Modules are at the heart of Node.js. They correspond to JavaScript files and can be used in our applications. A program for the Node.js server will consist of a set of modules, that is, JavaScript files.</p>
			<p>There are three kinds of modules:</p>
			<ul>
				<li>Modules that we write ourselves for our applications.</li>
				<li>Modules internal to Node.js and usable directly.</li>
				<li>Modules that can be downloaded from the internet using a utility called <strong class="source-inline">npm</strong> (npm stands for Node.js package manager). This <strong class="source-inline">npm</strong> utility is installed with Node.js itself.</li>
			</ul>
			<p>In this chapter, we will learn how to create and use these different types of modules.</p>
			<p>Regardless of the type of modules used, the <strong class="source-inline">require(moduleName)</strong> instruction (see below) allows the module called <strong class="source-inline">moduleName</strong> to be included in the current file. The functionalities of the module will then be accessible.</p>
			<p>Here are the topics covered in this chapter:</p>
			<ul>
				<li>Using our own modules</li>
				<li>Using internal Node.js modules</li>
				<li>Using downloaded modules with npm</li>
			</ul>
			<p>Let’s first see how to create and use our own modules with Node.js.</p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor124"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub at: <a href="https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip">https://github.com/PacktPublishing/JavaScript-from-Frontend-to-Backend/blob/main/Chapter%206.zip</a>.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor125"/>Creating and using our own modules</h1>
			<p>In this example, we <a id="_idIndexMarker462"/>use two modules, each corresponding to a JavaScript file:</p>
			<ul>
				<li>The first module (here named <strong class="source-inline">test.js</strong>) will be the main file of our application, the one we execute using the <strong class="source-inline">node test.js</strong> command in a command window.</li>
				<li>The second module (here named <strong class="source-inline">module1.js</strong>) will be the one we want to use in our main <strong class="source-inline">test.js</strong> module. The <strong class="source-inline">module1.js</strong> module will then be enriched to show how its functionalities are accessible outside the module (and will therefore be used in the main <strong class="source-inline">test.js</strong> module).</li>
			</ul>
			<p>Let’s go ahead and create these two modules. </p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor126"/>Creating a module</h2>
			<p>Here is the content of the two files, <strong class="source-inline">module1.js</strong> and <strong class="source-inline">test.js</strong>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">module1.js file</p>
			<pre class="source-code">console.log("module1.js is loaded");</pre>
			<p>The module currently<a id="_idIndexMarker463"/> has a simple <strong class="source-inline">console.log()</strong> statement. The module will then be enriched. The main module test.js is the following:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">test.js file</p>
			<pre class="source-code">var mod1 = require("./module1.js");  </pre>
			<pre class="source-code">// or require("./module1") without specifying the .js extension</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<p>Here, we use the <strong class="source-inline">require(moduleName)</strong>instruction, which allows us to load in memory the <strong class="source-inline">moduleName</strong> module. Any use of the functionalities of the <strong class="source-inline">moduleName</strong> module requires the <strong class="source-inline">require(moduleName)</strong>instruction beforehand.</p>
			<p>The <strong class="source-inline">require(moduleName)</strong> instruction returns a reference to the module loaded in memory. This reference is stored in a variable (here, <strong class="source-inline">mod1</strong>), which will then allow access to the functionalities described in the module (here, none for the moment).</p>
			<p>The <strong class="source-inline">test.js</strong> file is the main file that loads the other modules. It is therefore this <strong class="source-inline">test.js</strong> file that is executed using the <strong class="source-inline">node test.js</strong> instruction in a command window.</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Figure_6.01_B17416.jpg" alt="Figure 6.1 – Using a module with require(module)&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – Using a module with require(module)</p>
			<p>We can see here that the execution of the main <strong class="source-inline">test.js</strong> module invokes the call of the <strong class="source-inline">require("./module1.js")</strong>instruction, which executes the content of the <strong class="source-inline">module1.js </strong>file, hence the display text specified in the <strong class="source-inline">console.log()</strong> statement in the <strong class="source-inline">module1.js</strong> module.</p>
			<p>After loading <strong class="source-inline">module1.js</strong>, the <strong class="source-inline">mod1</strong> variable is initialized and we will be able to access functionalities that the <a id="_idIndexMarker464"/>module exports later on.</p>
			<p>Before adding functionalities to the <strong class="source-inline">module1.js</strong> module, let’s see how to manage the location of modules using the <strong class="source-inline">node_modules</strong> directory. The <strong class="source-inline">node_modules</strong> directory is used by Node.js to locate modules for which it does not have a path. Using this directory simplifies the writing of module names when loading them into memory with the <strong class="source-inline">require(moduleName)</strong> instruction.</p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor127"/>Using the node_modules directory</h2>
			<p>Note that the previous <strong class="source-inline">require(moduleName)</strong> statement requires indicating the access path to the <a id="_idIndexMarker465"/>module, for example, <strong class="source-inline">"./"</strong> to indicate the current directory.</p>
			<p>However, if the module is in the <strong class="source-inline">node_modules</strong> directory, it is not necessary to indicate the path because we are sure that the module is inside the <strong class="source-inline">node_modules</strong> directory (and moreover, it should <em class="italic">not</em> be specified). The <strong class="source-inline">node_modules</strong> directory can be in the main application directory (called the <em class="italic">local</em> <strong class="source-inline">node_modules</strong> directory) or in a dedicated directory<a id="_idIndexMarker466"/> created by Node.js (called the <em class="italic">global</em> <strong class="source-inline">node_modules</strong> directory: in this case, it is automatically created during the installation of Node.js).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If the module is not found in the <strong class="source-inline">node_modules</strong> directory (local or global) and if the access path to the module is not indicated, an error occurs when loading the module with the <strong class="source-inline">require(moduleName)</strong> instruction.</p>
			<p>Now, we will create a <strong class="source-inline">node_modules</strong> directory in the current directory where the main file, <strong class="source-inline">test.js</strong>, is located. Let’s transfer the <strong class="source-inline">module1.js</strong> file to this directory and use the <strong class="source-inline">require("module1.js")</strong> statement without specifying the path to the module. You can also write <strong class="source-inline">require("module1")</strong> without indicating the extension of the JavaScript file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Include module1 located in node_modules directory (test.js file)</p>
			<pre class="source-code">var mod1 = require("module1.js");  // or require("module1")</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<p>The <strong class="source-inline">module1.js</strong> file must be in the locally created <strong class="source-inline">node_modules</strong> directory, while the <strong class="source-inline">test.js</strong> file remains in the current directory, as described here:</p>
			<p><strong class="source-inline">root/</strong></p>
			<p><strong class="source-inline">|— node_modules/</strong></p>
			<p><strong class="source-inline">│       |— module1.js</strong></p>
			<p><strong class="source-inline">|— test.js</strong></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/Figure_6.02_B17416.jpg" alt="Figure 6.2 – The module is loaded from the node_modules directory&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – The module is loaded from the node_modules directory</p>
			<p>We can see that the module is indeed found by Node.js, because Node.js looks for it in the <strong class="source-inline">node_modules</strong> directory, which was created in the current directory.</p>
			<p>Now let’s see how to allow a <a id="_idIndexMarker467"/>module’s files to be grouped in a directory, using the <strong class="source-inline">package.json</strong> file associated with the module.</p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor128"/>Using the package.json file</h2>
			<p>The <strong class="source-inline">node_modules</strong> directory (whether located in the application directory or the Node.js installation directory) can <a id="_idIndexMarker468"/>contain a lot of files and sometimes a module can consist of many files and directories. It would be easier to associate a module with a directory in the <strong class="source-inline">node_modules</strong> directory.</p>
			<p>Let’s create the <strong class="source-inline">module1</strong> directory inside the <strong class="source-inline">node_modules</strong> directory. The <strong class="source-inline">module1</strong> directory contains the <strong class="source-inline">module1.js</strong> file but may also contain other files and directories related to this module.</p>
			<p>The file system is displayed here:</p>
			<p><strong class="source-inline">root/</strong></p>
			<p><strong class="source-inline">|— node_modules/</strong></p>
			<p><strong class="source-inline">|       |— module1/</strong></p>
			<p><strong class="source-inline">│              |— module1.js</strong></p>
			<p><strong class="source-inline">|— test.js</strong></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">moduleName</strong> indicated in the <strong class="source-inline">require(moduleName)</strong> statement represents, in this case, the name of the <em class="italic">directory</em> that contains the module files.</p>
			<p>But as it is necessary to know which file of the directory we must use first when loading the module (as there can be many files in this directory), we indicate this correspondence in the <strong class="source-inline">package.json</strong> file in the <strong class="source-inline">"main"</strong> key.</p>
			<p>The <strong class="source-inline">package.json</strong> file is a text file in JSON format, located in the directory of each Node.js module.</p>
			<p>Now, we will <a id="_idIndexMarker469"/>create the <strong class="source-inline">package.json</strong> file in the <strong class="source-inline">module1</strong> module directory and indicate in this file the <strong class="source-inline">"main"</strong> key with the value <strong class="source-inline">"module1.js"</strong>.</p>
			<p>The file system is as follows:</p>
			<p><strong class="source-inline">root/</strong></p>
			<p><strong class="source-inline">|— node_modules/</strong></p>
			<p><strong class="source-inline">|       |— module1/</strong></p>
			<p><strong class="source-inline">│              |— module1.js</strong></p>
			<p><strong class="source-inline">│              |— package.json</strong></p>
			<p><strong class="source-inline">|— test.js</strong></p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json file in the node_modules/module1 directory (package.json file)</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "main" : "module1.js"</pre>
			<pre class="source-code">}</pre>
			<p>We indicate in the <strong class="source-inline">"main"</strong> key that we must load the <strong class="source-inline">module1.js</strong> file during the <strong class="source-inline">require("module1")</strong> instruction:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Including module1 located in node_modules/module1 directory (test.js file)</p>
			<pre class="source-code"><strong class="bold">var mod1 = require("module1"); </strong>//"module1" is the directory name</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Please note that the module name in the <strong class="source-inline">require("module1")</strong> statement in this case is the name of the directory that contains the module in the <strong class="source-inline">node_modules</strong> directory. So, we cannot write the instruction here in the form <strong class="source-inline">require("module1.js")</strong>, which would cause an error.</p>
			<p>We now visualize the<a id="_idIndexMarker470"/> execution of the <strong class="source-inline">test.js</strong> file:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/Figure_6.02_B17416.jpg" alt="Figure 6.3 – Module loaded with the package.json file&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Module loaded with the package.json file</p>
			<p>The <strong class="source-inline">"main"</strong> key in the <strong class="source-inline">package.json</strong> file is optional if the main module file is named <strong class="source-inline">index.js</strong>. In all other cases, the <strong class="source-inline">"main"</strong> key must be indicated in <strong class="source-inline">package.json</strong>.</p>
			<p>We know how to run a module, but for now, the module contains a simple <strong class="source-inline">console.log()</strong> statement. Let’s see how to add features to the module and then use them.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor129"/>Adding functionalities to the module</h2>
			<p>The newly <a id="_idIndexMarker471"/>created <strong class="source-inline">module1.js</strong> module is accessible but does not currently offer any functionality. Let’s see how to add some.</p>
			<h3>Exporting multiple functions in the module</h3>
			<p>For example, let’s create<a id="_idIndexMarker472"/> the function <strong class="source-inline">add(a, b)</strong>, which returns the sum of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">add(a, b) function defined in module1.js (module1.js file)</p>
			<pre class="source-code">console.log("module1 is loaded");</pre>
			<pre class="source-code">function add(a, b) {</pre>
			<pre class="source-code">  return a+b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">module.exports = { </strong></pre>
			<pre class="source-code"><strong class="bold">  add : add     // make the add() function accessible </strong></pre>
			<pre class="source-code"><strong class="bold">                // outside the module</strong></pre>
			<pre class="source-code"><strong class="bold">}; </strong></pre>
			<p>To export a function outside of a module (and make it accessible to users of the module), you can just embed it in the <strong class="source-inline">module.exports</strong> object defined by Node.js in each module. Each key defined in the <strong class="source-inline">module.exports</strong> object will be a function accessible outside the module.</p>
			<p>We can thus define several functions<a id="_idIndexMarker473"/> in the module that will be accessible thanks to the <strong class="source-inline">module.exports</strong> object.</p>
			<p>The usage of the <strong class="source-inline">add(a, b)</strong> function in the <strong class="source-inline">test.js</strong> file is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using add() function in test.js file (test.js file)</p>
			<pre class="source-code">var mod1 = require("module1");</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<pre class="source-code"><strong class="bold">var total = mod1.add(2, 3);</strong>      // call of the add() function </pre>
			<pre class="source-code">                                 // defined in module1</pre>
			<pre class="source-code">console.log("mod1.add(2, 3) = ", total);  // displays 5</pre>
			<p>The following display is obtained:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/Figure_6.04_B17416.jpg" alt="Figure 6.4 – The add() function added to the module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – The add() function added to the module</p>
			<p>Let’s add a second function in the <a id="_idIndexMarker474"/>module. For example, the function <strong class="source-inline">mult(a, b)</strong>, which returns <strong class="source-inline">a*b</strong>.</p>
			<p>If we add the <strong class="source-inline">mult(a, b)</strong> function in the module, it is written as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Adding the mult(a, b) function to the module (module1.js file)</p>
			<pre class="source-code">console.log("module1 is loaded");</pre>
			<pre class="source-code">function add(a, b) {</pre>
			<pre class="source-code">  return a+b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">function mult(a, b) {</strong></pre>
			<pre class="source-code"><strong class="bold">  return a*b;</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<pre class="source-code"><strong class="bold">module.exports = {</strong></pre>
			<pre class="source-code"><strong class="bold">  add : add,</strong></pre>
			<pre class="source-code"><strong class="bold">  mult : mult</strong></pre>
			<pre class="source-code"><strong class="bold">}</strong></pre>
			<p>Now, we will use the two functions <strong class="source-inline">add()</strong> and <strong class="source-inline">mult()</strong> in the <strong class="source-inline">test.js</strong> file. This verifies that a <a id="_idIndexMarker475"/>module can provide several functionalities to other modules that use it:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the module’s add() and mult() functions (test.js file)</p>
			<pre class="source-code">var mod1 = require("module1");</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<pre class="source-code">var total = mod1.add(2, 3);</pre>
			<pre class="source-code">console.log("mod1.add(2, 3) = ", total);      // 2 + 3 = 5</pre>
			<pre class="source-code">var total = mod1.mult(2, 3);</pre>
			<pre class="source-code">console.log("mod1.mult(2, 3) = ", total);     // 2 * 3 = 6</pre>
			<p>The following display is obtained:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/Figure_6.05_B17416.jpg" alt="Figure 6.5 – Using the two functions of the module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.5 – Using the two functions of the module</p>
			<p>Now let’s see how to improve the module concept by using a so-called main function in the module.</p>
			<h3>Allowing a function to be the main function of the module</h3>
			<p>Often, the module wishes to make a function its main function (the other functions defined in the module are secondary functions). This allows access to this main function in a simplified form.</p>
			<p>Suppose (as before) that <strong class="source-inline">module1</strong> makes available the <strong class="source-inline">add(a, b)</strong>function and the <strong class="source-inline">mult(a, b)</strong>function. We want the <strong class="source-inline">add()</strong> function to be the main function of the module, which means that we can use it outside the module as <strong class="source-inline">mod1(2, 3)</strong> instead of <strong class="source-inline">mod1.add(2, 3)</strong>. The <strong class="source-inline">mult(a, b)</strong> function will remain accessible in the form <strong class="source-inline">mod1.mult(2, 3)</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that only one function can be defined as the main function in a module.</p>
			<p>In this case, just specify it in the <strong class="source-inline">module.exports</strong> object like so:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Making the add() function accessible as a main module function (module1.js file)</p>
			<pre class="source-code">console.log("module1 is loaded");</pre>
			<pre class="source-code">function add(a, b) {</pre>
			<pre class="source-code">  return a+b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">function mult(a, b) {</pre>
			<pre class="source-code">  return a*b;</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"><strong class="bold">// first define the main function</strong></pre>
			<pre class="source-code"><strong class="bold">module.exports = add;  // the add() function defined outside </strong></pre>
			<pre class="source-code"><strong class="bold">                       // the module, is made main</strong></pre>
			<pre class="source-code"><strong class="bold">// then define the secondary functions</strong></pre>
			<pre class="source-code"><strong class="bold">module.exports.mult = mult;   // and the mult() function </strong></pre>
			<pre class="source-code"><strong class="bold">                              // becomes usable as well</strong></pre>
			<p class="callout-heading">Note</p>
			<p class="callout">It is important to assign the values in this order in the <strong class="source-inline">module.exports</strong> object (define the main function first, then the secondary functions). If you make the assignment in the other direction (<strong class="source-inline">module.exports.mult</strong> first, then <strong class="source-inline">module.exports</strong>), the assignment of <strong class="source-inline">module.exports</strong> last will erase the value already positioned in <strong class="source-inline">module.exports.mult</strong>.</p>
			<p>Also, we can no longer assign <strong class="source-inline">module.exports</strong> as an object, because that would remove the previously<a id="_idIndexMarker476"/> assigned value if we wrote <strong class="source-inline">module.exports = { mult : mult }</strong>.</p>
			<p>We now use the module as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the module1.js module that has a main function (test.js file)</p>
			<pre class="source-code">var mod1 = require("module1");</pre>
			<pre class="source-code">console.log("mod1 =", mod1);</pre>
			<pre class="source-code"><strong class="bold">var total = mod1(2, 3);</strong>          // instead of mod1.add(2, 3)</pre>
			<pre class="source-code">console.log("mod1(2, 3) = ", total);</pre>
			<pre class="source-code"><strong class="bold">var total = mod1.mult(2, 3);</strong></pre>
			<pre class="source-code">console.log("mod1.mult(2, 3) = ", total);</pre>
			<p>The following display is obtained:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_6.06_B17416.jpg" alt="Figure 6.6 – Using the module with the main function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.6 – Using the module with the main function</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Notice that instead of using the <strong class="source-inline">mod1</strong> variable as an object, we now use it as a function. In the call to <strong class="source-inline">mod1(a, b)</strong> causes the addition of a and b, so it is preferable that the variable be named <strong class="source-inline">"add"</strong> rather than <strong class="source-inline">"mod1"</strong> in the instruction <strong class="source-inline">require(moduleName)</strong>.</p>
			<p>We saw how to create and <a id="_idIndexMarker477"/>use our own module. Now let’s take a look at how to use internal Node.js modules.</p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor130"/>Using internal Node.js modules</h1>
			<p>Node.js already has internal modules. They <a id="_idIndexMarker478"/>can also be used with the <strong class="source-inline">require(moduleName)</strong> instruction seen previously.</p>
			<p>Let’s look at an example of an internal module. There is, for example, the <strong class="source-inline">"fs"</strong> module in the Node.js system. The name <strong class="source-inline">"fs"</strong> is short for file system. This module allows you to interact with the internal file system of Node.js.</p>
			<p>Now, we will use the <strong class="source-inline">"fs"</strong> module to read the contents of a file.</p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor131"/>Reading the contents of a file</h2>
			<p>Let’s use the <strong class="source-inline">"fs"</strong> module to read the<a id="_idIndexMarker479"/> file named <strong class="source-inline">file1.txt</strong> located in the current directory (where the <strong class="source-inline">test.js</strong> file is located). Here<a id="_idIndexMarker480"/> are the contents of this file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">file1.txt file (in the directory where test.js is located)</p>
			<pre class="source-code">This is the content</pre>
			<pre class="source-code">of the file file1.txt</pre>
			<pre class="source-code">located in</pre>
			<pre class="source-code">the current directory.</pre>
			<p>The program that uses the <strong class="source-inline">"fs"</strong> module and displays the contents of the file is as follows:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Reading and displaying the contents of the file (test.js file)</p>
			<pre class="source-code"><strong class="bold">var fs = require("fs");</strong></pre>
			<pre class="source-code"><strong class="bold">var data = fs.readFileSync("file1.txt");</strong></pre>
			<pre class="source-code">console.log("File content:");</pre>
			<pre class="source-code">console.log(data);</pre>
			<p>We use the <strong class="source-inline">readFileSync()</strong> method defined in the <strong class="source-inline">"fs"</strong> module. It returns the contents of the file in the corresponding variable, which is then displayed.</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_6.07_B17416.jpg" alt="Figure 6.7 – Displaying file contents using the &quot;fs&quot; module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.7 – Displaying file contents using the “fs” module</p>
			<p>The contents of the<a id="_idIndexMarker481"/> file are displayed but as hexadecimal characters. Next, let’s display the contents of the file <a id="_idIndexMarker482"/>as strings.</p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor132"/>Displaying file contents as strings</h2>
			<p>The contents of the file are <a id="_idIndexMarker483"/>displayed in the form of a buffer of bytes (see <em class="italic">Figure 6.7</em>). Node.js makes it easy to manipulate byte<a id="_idIndexMarker484"/> streams. It is also possible to view the contents of the file directly as strings by specifying the <strong class="source-inline">{encoding: "utf-8"}</strong> option in the second parameter (<strong class="source-inline">options</strong>) of the <strong class="source-inline">readFileSync(name, options)</strong> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying file contents as strings (test.js file)</p>
			<pre class="source-code">var fs = require("fs");</pre>
			<pre class="source-code">var data = <strong class="bold">fs.readFileSync("file1.txt", { encoding : "utf-8" });</strong></pre>
			<pre class="source-code">console.log("File content:");</pre>
			<pre class="source-code">console.log(data);</pre>
			<p>The result is now displayed as strings (see the following figure):</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_6.08_B17416.jpg" alt="Figure 6.8 – Displaying file contents as strings&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.8 – Displaying file contents as strings</p>
			<p>The contents of the file are displayed. However, the program waits for the contents of the file to be retrieved in order to display<a id="_idIndexMarker485"/> them. By using the <strong class="source-inline">readFile()</strong> method instead of the <strong class="source-inline">readFileSync()</strong> method, it is <a id="_idIndexMarker486"/>possible to not block the program while waiting for the file.</p>
			<h2 id="_idParaDest-134"><a id="_idTextAnchor133"/>Using non-blocking file reading</h2>
			<p>If you observe the previous <strong class="source-inline">readFileSync()</strong> method, you will see that the contents of the file are <a id="_idIndexMarker487"/>rendered in return for the method call. This means that the Node.js program is blocked while the file is being read (even if only <a id="_idIndexMarker488"/>for a few milliseconds). Within our small program, this is not noticeable, but in a case where the reading of the file is carried out by thousands of simultaneous users (for example, on a server), this will slow down access to the server.</p>
			<p>For this, Node.js has provided, for all blocking features such as this one, a non-blocking version of the method. Rather than returning the return result of the method (as before), we use a callback function indicated as a parameter of the method. In the case of reading the file, we will therefore use the <strong class="source-inline">readFile(name, options, callback)</strong> method, also defined in the <strong class="source-inline">"fs"</strong> module. The result of reading the file will be passed as a parameter in the callback function.</p>
			<p>Let’s use the non-blocking form of reading the file, using the <strong class="source-inline">readFile()</strong> method instead of the <strong class="source-inline">readFileSync()</strong> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using readFile() method to read the file (test.js file)</p>
			<pre class="source-code">var fs = require("fs");</pre>
			<pre class="source-code">console.log("File content:");</pre>
			<pre class="source-code"><strong class="bold">fs.readFile("file1.txt", { encoding : "utf-8" }, function(error, data) {</strong></pre>
			<pre class="source-code"><strong class="bold">  console.log(data);</strong></pre>
			<pre class="source-code"><strong class="bold">});</strong></pre>
			<pre class="source-code">console.log("The readFile() method was called");</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The callback function uses the <strong class="source-inline">error</strong> and <strong class="source-inline">data</strong> parameters (in that order), which respectively correspond to a possible error message (<strong class="source-inline">null</strong> if none), and to the contents of the file if the latter has been read. The <strong class="source-inline">options</strong> parameter indicated as the second parameter of <strong class="source-inline">readFile()</strong> is similar to that of the <strong class="source-inline">readFileSync(name, options)</strong> method.</p>
			<p>The result is <a id="_idIndexMarker489"/>displayed here:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/Figure_6.09_B17416.jpg" alt="Figure 6.9 – Displaying file contents using the non-blocking readFile() method&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.9 – Displaying file contents using the non-blocking readFile() method</p>
			<p>We can check in the <a id="_idIndexMarker490"/>result displayed above that the <strong class="source-inline">readFile()</strong> method is really non-blocking. Indeed, the text indicated following the call to the <strong class="source-inline">readFile()</strong> method is displayed in the console even though the file has not yet been read and displayed, which would have been impossible using the blocking method <strong class="source-inline">readFileSync()</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We can therefore see that the use of modules internal to Node.js is done very simply by using the <strong class="source-inline">require(moduleName)</strong> instruction, and then by calling methods on the object returned by this instruction.</p>
			<p>We have seen how to create and use your own modules, and how to use internal Node.js modules.</p>
			<p>Now let’s see how to use <a id="_idIndexMarker491"/>modules available on the internet using the <strong class="source-inline">npm</strong> command.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor134"/>Using downloaded modules with npm</h1>
			<p>In addition to the modules internal to <a id="_idIndexMarker492"/>Node.js, it is possible to import modules from the internet using the <strong class="source-inline">npm</strong> utility provided with Node.js.</p>
			<p>For this, the <strong class="source-inline">npm</strong> command is<a id="_idIndexMarker493"/> used (in a command interpreter) by indicating arguments that allow you to perform the corresponding actions on the imported modules.</p>
			<h2 id="_idParaDest-136"><a id="_idTextAnchor135"/>Using the npm command</h2>
			<p>Here are some common <a id="_idIndexMarker494"/>uses of the <strong class="source-inline">npm</strong> command:</p>
			<ul>
				<li><strong class="source-inline">npm install moduleName</strong>: Installs the indicated module in the <em class="italic">local</em> <strong class="source-inline">node_modules</strong> directory. The module will only be accessible for the current application and not for other applications (unless it is installed again).</li>
				<li><strong class="source-inline">npm install moduleName -g</strong>: Installs the specified module in the <em class="italic">global</em> <strong class="source-inline">node_modules</strong> directory. The <strong class="source-inline">-g</strong> option allows you to indicate that this module can be accessed by other applications because it is installed in the <strong class="source-inline">node_modules</strong> directory of Node.js (globally).</li>
				<li><strong class="source-inline">npm link moduleName</strong>: It is possible that a module installed globally (with the <strong class="source-inline">-g</strong> option) is inaccessible (you get a module loading error during the <strong class="source-inline">require(moduleName)</strong> statement). In this case, it is necessary to run the <strong class="source-inline">npm link moduleName</strong> command.</li>
				<li><strong class="source-inline">npm ll</strong>: Lists modules already present in the <em class="italic">local</em> <strong class="source-inline">node_modules</strong> directory.</li>
				<li><strong class="source-inline">npm ll -g</strong>: Lists modules already present in the <em class="italic">global</em> <strong class="source-inline">node_modules</strong> directory.</li>
				<li><strong class="source-inline">npm start</strong>: Starts the Node.js application according to the command indicated in the <strong class="source-inline">"scripts"</strong> key, then the <strong class="source-inline">"start"</strong> key of the <strong class="source-inline">package.json</strong> file. For example, if you specify <strong class="source-inline">"scripts": { "start": "node test.js" }</strong> in the <strong class="source-inline">package.json</strong> file, you can type <strong class="source-inline">npm start</strong> instead of <strong class="source-inline">node test.js</strong> to run the <strong class="source-inline">test.js</strong> file. It is common to use <strong class="source-inline">npm start</strong> to start a Node.js <a id="_idIndexMarker495"/>application. This will be used to start an application<a id="_idIndexMarker496"/> under <strong class="bold">Express</strong> (see the next chapter).<p class="callout-heading">Note</p><p class="callout">If you want to remove an npm-installed module, use the same commands as before, specifying <strong class="source-inline">uninstall</strong> instead of <strong class="source-inline">install</strong>.</p></li>
			</ul>
			<p>As an example, let’s create the following <strong class="source-inline">package.json</strong> file in the directory of the <strong class="source-inline">test.js</strong> file:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json file (in the same directory as test.js)</p>
			<pre class="source-code">{</pre>
			<pre class="source-code">  "scripts" : {</pre>
			<pre class="source-code">    "start" : "node test.js"</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Then use the <strong class="source-inline">npm start</strong> command to start the program:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/Figure_6.10_B17416.jpg" alt="Figure 6.10 – Starting the Node.js application with npm start&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.10 – Starting the Node.js application with npm start</p>
			<p>We can see that the <strong class="source-inline">npm start</strong> command thus makes it possible to execute the <strong class="source-inline">test.js</strong> program. The <strong class="source-inline">npm start</strong> command is often used to start a Node.js program, thanks to the mechanism explained above.</p>
			<p>Now let’s see how to use <a id="_idIndexMarker497"/>modules written by other developers by downloading them using <strong class="source-inline">npm</strong>.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor136"/>Using a downloaded module with npm</h2>
			<p>Let’s look at an <a id="_idIndexMarker498"/>example of using <strong class="source-inline">npm</strong>. Here, we <a id="_idIndexMarker499"/>will use <strong class="source-inline">npm</strong> to install the module named <strong class="source-inline">colors</strong>. It allows you to display colored text in the console.</p>
			<h3>Installing the colors module in the node_modules local directory</h3>
			<p>We use the <a id="_idIndexMarker500"/>command <strong class="source-inline">npm install colors</strong>. The<a id="_idIndexMarker501"/> result of the installation of the <strong class="source-inline">"colors"</strong> module is displayed in the following figure.</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/Figure_6.11_B17416.jpg" alt="Figure 6.11 – Installing the colors module with npm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.11 – Installing the colors module with npm</p>
			<p>Once the <a id="_idIndexMarker502"/>module has been installed by <strong class="source-inline">npm</strong>, you can see that the <strong class="source-inline">colors</strong> directory of the module has<a id="_idIndexMarker503"/> inserted itself into the <strong class="source-inline">node_modules</strong> local directory of the application.</p>
			<h3>Using the features of the colors module</h3>
			<p>One of the ways to have an <a id="_idIndexMarker504"/>overview of the functionalities offered by a module is to display the content of the object returned by the <strong class="source-inline">require(moduleName)</strong> instruction:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Displaying contents of colors object returned by require(“colors”) (test.js file)</p>
			<pre class="source-code">var colors = require("colors");</pre>
			<pre class="source-code">console.log("colors = ", colors);</pre>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/Figure_6.12_B17416.jpg" alt="Figure 6.12 – Displaying contents of the colors module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.12 – Displaying contents of the colors module</p>
			<p>For example, let’s use the <a id="_idIndexMarker505"/>last method listed in the module, namely the <strong class="source-inline">random()</strong> method. It allows you to transform a character string into a string with random colors for each character:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Using the random() method of the colors module (test.js file)</p>
			<pre class="source-code">var colors = require("colors");</pre>
			<pre class="source-code">console.log(colors.random("First text in random colors"));</pre>
			<pre class="source-code">console.log(colors.random("Second text in random colors"));</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">random()</strong> method is used by prefixing its name with the name of the variable returned by <strong class="source-inline">require("colors")</strong>, that is, with the name of the module.</p>
			<p>The display of the following figure is obtained, in which each character displayed is a random color:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/Figure_6.13_B17416.jpg" alt="Figure 6.13 – Using the colors module&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.13 – Using the colors module</p>
			<p>We have seen here<a id="_idIndexMarker506"/> the three types of modules used with Node.js:</p>
			<ul>
				<li>Modules written by ourselves, for our own needs</li>
				<li>Existing internal modules in Node.js, such as the <strong class="source-inline">fs</strong> module allowing access to the internal file system of Node.js</li>
				<li>Modules downloadable using the <strong class="source-inline">npm</strong> command, such as the colors module used above</li>
			</ul>
			<p>All that remains is to use these different types of modules in our programs. We will discuss that later on. </p>
			<p>This brings us to the end of the chapter. </p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Summary</h1>
			<p>We have seen in this chapter how to create and use modules with Node.js, which are the essential components of programs created with Node.js.</p>
			<p>Whether the module is created by us, is an internal Node.js module, or is a module downloaded with <strong class="source-inline">npm</strong>, its use is the same in all cases. We use the <strong class="source-inline">require(moduleName)</strong> instruction and with the value returned in a variable, we access the functionality of the module.</p>
			<p>Next, we are going to study the Express module, which is one of the main modules used with Node.js, allowing us to easily structure our applications according to the rules of the MVC model, currently widely used.</p>
		</div>
	</body></html>