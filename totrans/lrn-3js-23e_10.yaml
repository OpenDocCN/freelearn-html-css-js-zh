- en: Chapter 10. Loading and Working with Textures
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。加载和使用纹理
- en: 'In [Chapter 4](ch04.html "Chapter 4. Working with Three.js Materials"), *Working
    with Three.js Materials*, we introduced you to the various materials that are
    available in Three.js. In that chapter, however, we didn''t talk about applying
    textures to meshes. In this chapter, we''ll look at that subject. More specifically,
    in this chapter, we''ll discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](ch04.html "第4章。使用Three.js材质")中，*使用Three.js材质*，我们向您介绍了Three.js中可用的各种材质。然而，在第4章中，我们没有讨论将纹理应用于网格。在本章中，我们将探讨这个主题。更具体地说，在本章中，我们将讨论以下主题：
- en: Loading textures in Three.js and applying them to a mesh
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Three.js中加载纹理并将其应用于网格
- en: Using bump and normal maps to apply depth and detail to a mesh
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用凹凸图和法线图将深度和细节应用于网格
- en: Creating fake shadows using a light map
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光照图创建假阴影
- en: Adding detailed reflection to a material using an environment map
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境图向材质添加详细反射
- en: Using a specular map to set the *shininess* of specific parts of a mesh
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高光图设置网格特定部分的光泽度
- en: Fine-tuning and customizing the UV mapping of a mesh
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微调和自定义网格的UV贴图
- en: Using the HTML5 canvas and video element as input for a texture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTML5画布和视频元素作为纹理的输入
- en: Let's start with the most basic example, where we show you how to load and apply
    a texture.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本示例开始，向您展示如何加载并应用纹理。
- en: Using textures in materials
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在材质中使用纹理
- en: There are different ways textures are used in Three.js. You can use them to
    define the colors of the mesh, but you can also use them to define shininess,
    bumps, and reflections. The first example we look at, though, is the most basic
    approach, where we use a texture to define the colors of the individual pixels
    of a mesh.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中有不同的纹理使用方式。您可以使用它们来定义网格的颜色，但您也可以使用它们来定义光泽度、凹凸和反射。然而，我们首先查看的示例是最基本的方法，其中我们使用纹理来定义网格单个像素的颜色。
- en: Loading a texture and applying it to a mesh
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载纹理并将其应用于网格
- en: The most basic usage of a texture is when it's set as a map on a material. When
    you use this material to create a mesh, the mesh will be colored based on the
    supplied texture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的最基本用法是将其设置为材质上的映射。当您使用此材质创建网格时，网格将根据提供的纹理进行着色。
- en: 'Loading a texture and using it on a mesh can be done in the following manner:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 加载纹理并在网格上使用的方法如下：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this code sample, we use the `THREE.ImageUtils.loadTexture` function to
    load an image file from a specific location. You can use PNG, GIF, or JPEG images
    as input for a texture. Note that loading textures is done asynchronously. In
    our scenario, this isn''t an issue as we have a `render` loop where we render
    the scene around 60 times per second. If you want to wait until a texture is loaded,
    you could use the following approach:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码示例中，我们使用`THREE.ImageUtils.loadTexture`函数从特定位置加载图像文件。您可以使用PNG、GIF或JPEG图像作为纹理的输入。请注意，加载纹理是异步进行的。在我们的场景中，这不是问题，因为我们有一个每秒渲染场景约60次的`render`循环。如果您想等待纹理加载完成，可以使用以下方法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this example, we supply a callback function to `loadTexture`. This callback
    is called when the texture is loaded. In our examples, we don't use the callback
    and rely on the `render` loop to eventually show the texture when it's loaded.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们向`loadTexture`提供了一个回调函数。当纹理加载时，会调用此回调函数。在我们的示例中，我们不使用回调，而是依赖于`render`循环在纹理加载后最终显示纹理。
- en: 'You can use pretty much any image you''d like as a texture. The best results,
    however, are when you use a square texture whose dimensions are a power of 2\.
    So dimensions such as 256 x 256, 512 x 512, 1024 x 1024, and so on work the best.
    The following image is an example of a square texture:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎可以使用任何图像作为纹理。然而，最佳结果是在使用边长为2的幂的方形纹理时获得。因此，如256 x 256、512 x 512、1024 x 1024等尺寸效果最佳。以下图像是一个方形纹理的示例：
- en: '![Loading a texture and applying it to a mesh](img/2215OS_10_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![加载纹理并将其应用于网格](img/2215OS_10_01.jpg)'
- en: 'Since the pixels of a texture (also called **texels**) usually don''t map one-to-one
    on the pixels of the face, the texture needs to be magnified or minified. For
    this purpose, WebGL and Three.js offer a couple of different options. You can
    specify how the texture is magnified by setting the `magFilter` property and how
    it is minified with the `minFilter` property. These properties can be set to the
    following two basic values:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纹理的像素（也称为**纹理像素**）通常不会一对一地映射到面的像素上，因此需要放大或缩小纹理。为此目的，WebGL和Three.js提供了一些不同的选项。你可以通过设置`magFilter`属性来指定纹理的放大方式，以及通过设置`minFilter`属性来指定缩小方式。这些属性可以设置为以下两个基本值：
- en: '| Name | Description |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.NearestFilter` | This filter uses the color of the nearest texel that
    it can find. When used for magnification, this will result in blockiness, and
    when used for minification, the result will lose much detail. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.NearestFilter` | 此过滤器使用它能够找到的最近的纹理像素的颜色。当用于放大时，这将导致块状效果，当用于缩小，结果将丢失很多细节。|'
- en: '| `THREE.LinearFilter` | This filter is more advanced and uses the color value
    of the four neighboring texels to determine the correct color. You''ll still lose
    much detail in minification, but the magnification will be much smoother and less
    blocky. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LinearFilter` | 此过滤器更高级，使用四个相邻的纹理像素的颜色值来确定正确的颜色。在缩小操作中，你仍然会丢失很多细节，但放大将会更加平滑且不那么块状。|'
- en: 'Besides these basic values, we can also use a mipmap. A **mipmap** is a set
    of texture images, each half the size of the previous one. These are created when
    you load the texture and allow much smoother filtering. So, when you''ve got a
    square texture (as a power of 2), you can use a couple of additional approaches
    for better filtering. The properties can be set using the following values:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些基本值之外，我们还可以使用米普图。**米普图**是一组纹理图像，每个图像的大小是前一个图像的一半。这些图像在加载纹理时创建，允许进行更平滑的过滤。因此，当你有一个平方纹理（作为2的幂）时，你可以使用一些额外的策略来获得更好的过滤效果。可以使用以下值设置属性：
- en: '| Name | Description |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.NearestMipMapNearestFilter` | This property selects the mipmap that
    best maps the required resolution and applies the nearest filter principle that
    we discussed in the previous table. Magnification is still blocky, but minification
    looks much better. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.NearestMipMapNearestFilter` | 此属性选择最佳的米普图以映射所需的分辨率，并应用我们在前表中讨论的最近邻过滤原则。放大仍然会有块状效果，但缩小看起来要好得多。|'
- en: '| `THREE.NearestMipMapLinearFilter` | This property selects not just a single
    mipmap but the two nearest mipmap levels. On both these levels, a nearest filter
    is applied to get two intermediate results. These two results are passed through
    a linear filter to get the final result. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.NearestMipMapLinearFilter` | 此属性选择不仅仅是单个米普图，而是两个最近的米普图级别。在这两个级别上，都应用最近邻过滤器以获得两个中间结果。这两个结果通过线性过滤器传递以获得最终结果。|'
- en: '| `THREE.LinearMipMapNearestFilter` | This property selects the mipmap that
    best maps the required resolution and applies the linear filter principle we discussed
    in the previous table. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LinearMipMapNearestFilter` | 此属性选择最佳的米普图以映射所需的分辨率，并应用我们在前表中讨论的线性过滤原则。|'
- en: '| `THREE.LinearMipMapLinearFilter` | This property selects not a single mipmap
    but the two nearest mipmap levels. On both these levels, a linear filter is applied
    to get two intermediate results. These two results are passed through a linear
    filter to get the final result. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `THREE.LinearMipMapLinearFilter` | 此属性选择不仅仅是单个米普图，而是两个最近的米普图级别。在这两个级别上，都应用线性过滤器以获得两个中间结果。这两个结果通过线性过滤器传递以获得最终结果。|'
- en: 'If you don''t specify the `magFilter` and `minFilter` properties explicitly,
    Three.js uses `THREE.LinearFilter` as the default for the `magFilter` property
    and `THREE.LinearMipMapLinearFilter` as the default for the `minFilter` property.
    In our examples, we''ll just use these default properties. An example for the
    basic texture can be found in `01-basic-texture.html`. The following screenshot
    shows this example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有明确指定`magFilter`和`minFilter`属性，Three.js将使用`THREE.LinearFilter`作为`magFilter`属性的默认值，并将`THREE.LinearMipMapLinearFilter`作为`minFilter`属性的默认值。在我们的示例中，我们将只使用这些默认属性。基本纹理的示例可以在`01-basic-texture.html`中找到。以下截图显示了此示例：
- en: '![Loading a texture and applying it to a mesh](img/2215OS_10_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![加载纹理并将其应用于网格](img/2215OS_10_02.jpg)'
- en: 'In this example, we load a couple of textures (using the code you saw earlier)
    and apply them to various shapes. In this example, you can see that the textures
    nicely wrap around the shapes. When you create geometries in Three.js, it makes
    sure that any texture that is used is applied correctly. This is done by something
    called **UV mapping** (more on this later in this chapter). With UV mapping, we
    tell the renderer which part of a texture should be applied to a specific face.
    The easiest example for this is the cube. The UV mapping for one of the faces
    looks like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们加载了一些纹理（使用你之前看到的代码）并将它们应用到各种形状上。在这个例子中，你可以看到纹理很好地包裹在形状周围。当你使用Three.js创建几何体时，它会确保使用的任何纹理都得到正确应用。这是通过一种称为**UV贴图**（本章后面会详细介绍）的方法实现的。通过UV贴图，我们告诉渲染器纹理的哪一部分应该应用到特定的面上。这个例子中最简单的是立方体。其中一个面的UV贴图看起来像这样：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means that we use the complete texture (UV values range from 0 to 1) for
    this face.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们使用整个纹理（UV值从0到1）来应用这个面。
- en: 'Besides the standard image formats we can load with `THREE.ImageUtils.loadTexture`,
    Three.js also provides a couple of custom loaders you can use to load textures
    provided in different formats. The following table shows the additional loaders
    you can use:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们可以使用`THREE.ImageUtils.loadTexture`加载的标准图像格式外，Three.js还提供了一些自定义加载器，你可以使用这些加载器来加载不同格式的纹理。以下表格显示了你可以使用的附加加载器：
- en: '| Name | Description |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `THREE.DDSLoader` | With this loader, you can load textures that are provided
    in the DirectDraw Surface format. This format is a proprietary Microsoft format
    to store compressed textures. Using this loader is very easy. First, include the
    `DDSLoader.js` file in your HTML page and then use the following to use a texture:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '| `THREE.DDSLoader` | 使用这个加载器，你可以加载以DirectDraw Surface格式提供的纹理。这种格式是微软专有的格式，用于存储压缩纹理。使用这个加载器非常简单。首先，在HTML页面中包含`DDSLoader.js`文件，然后使用以下代码来使用纹理：'
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can see an example of this loader in the sources for this chapter in `01-basic-texture-dds.html`.
    Internally, this loader uses `THREE.CompressedTextureLoader`. |
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章源代码中的`01-basic-texture-dds.html`找到一个此加载器的示例。内部，这个加载器使用了`THREE.CompressedTextureLoader`。|
- en: '| `THREE.PVRLoader` | Power VR is another proprietary file format to store
    compressed textures. Three.js supports the Power VR 3.0 file format and can use
    textures provided in this format. To use this loader, include the `PVRLoader.js`
    file in your HTML page and then use the following to use a texture:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '| `THREE.PVRLoader` | Power VR是另一种专有文件格式，用于存储压缩纹理。Three.js支持Power VR 3.0文件格式，并可以使用这种格式提供的纹理。要使用此加载器，请在HTML页面中包含`PVRLoader.js`文件，然后使用以下代码来使用纹理：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see an example of this loader in the sources for this chapter: `01-basic-texture-pvr.html`.
    Note that not all WebGL implementations support textures in this format. So when
    you use this and don''t see a texture, check the console for errors. Internally,
    this loader also uses `THREE.CompressedTextureLoader`. |'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章源代码中找到一个此加载器的示例：`01-basic-texture-pvr.html`。请注意，并非所有WebGL实现都支持这种格式的纹理。所以当你使用它而没有看到纹理时，请检查控制台是否有错误。内部，这个加载器也使用了`THREE.CompressedTextureLoader`。|
- en: '| `THREE.TGALoader` | Targa is a raster graphics file format that is still
    used by a large number of 3D software programs. With the `THREE.TGALoader` object,
    you can use textures provided in this format with your 3D models. To use these
    image files, you first have to include the `TGALoader.js` file in your HTML, and
    then you can use the following to load a TGA texture:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '| `THREE.TGALoader` | Targa是一种仍然被大量3D软件程序使用的位图图形文件格式。使用`THREE.TGALoader`对象，你可以使用这种格式提供的纹理与你的3D模型一起使用。要使用这些图像文件，你首先需要在HTML中包含`TGALoader.js`文件，然后你可以使用以下代码来加载TGA纹理：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: An example of this loader is provided in the sources of this chapter. You can
    view this example by opening `01-basic-texture-tga.html` in your browser. |
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本章源代码中提供了一个此加载器的示例。你可以在浏览器中打开`01-basic-texture-tga.html`来查看此示例。|
- en: In these examples, we've used textures to define the color of the pixels of
    our mesh. We can also use textures for other purposes. The following two examples
    are used to define how shading is applied to a material. You use this to create
    bumps and wrinkles on the surface of a mesh.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们使用了纹理来定义网格像素的颜色。我们也可以使用纹理来达到其他目的。以下两个示例用于定义如何将着色应用到材质上。你可以使用这个来在网格表面创建凹凸和皱纹。
- en: Using a bump map to create wrinkles
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用凹凸贴图创建皱纹
- en: 'A **bump map** is used to add more depth to a material. You can see this in
    action by opening up the `02-bump-map.html` example. Refer to the following screenshot
    to see the example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**凹凸贴图**用于为材质添加更多深度。您可以通过打开`02-bump-map.html`示例来查看其效果。参考以下截图以查看示例：'
- en: '![Using a bump map to create wrinkles](img/2215OS_10_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![使用凹凸贴图创建皱纹](img/2215OS_10_03.jpg)'
- en: 'In this example, you can see that the left-hand side wall looks much more detailed
    and seems to have much more depth when you compare it with the wall on the right-hand
    side. This is done by setting an additional texture, a so-called bump map, on
    the material:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以看到，与右侧的墙面相比，左侧的墙面看起来更加详细，似乎具有更多的深度。这是通过在材质上设置一个额外的纹理，即所谓的凹凸贴图来实现的：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see in this code that besides setting the `map` property, we also set
    the `bumpMap` property to a texture. Additionally, with the `bumpScale` property,
    we can set the height (or depth if set to a negative value) of the bumps. The
    textures used in this example are shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，除了设置`map`属性外，我们还设置了`bumpMap`属性为一个纹理。此外，通过`bumpScale`属性，我们可以设置凹凸的高度（或设置为负值时的深度）。此示例中使用的纹理如下所示：
- en: '![Using a bump map to create wrinkles](img/2215OS_10_04.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![使用凹凸贴图创建皱纹](img/2215OS_10_04.jpg)'
- en: The bump map is a grayscale image, but you can also use a color image. The intensity
    of the pixel defines the height of the bump. A bump map only contains the relative
    height of a pixel. It doesn't say anything about the direction of the slope. So
    the level of detail and perception of depth that you can reach with a bump map
    is limited. For more details, you can use a normal map.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 凹凸贴图是灰度图像，但您也可以使用彩色图像。像素的强度定义了凹凸的高度。凹凸贴图只包含像素的相对高度。它不涉及斜坡的方向。因此，您可以通过凹凸贴图达到的细节水平和深度感知是有限的。对于更多细节，您可以使用法线贴图。
- en: Achieving more detailed bumps and wrinkles with a normal map
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用法线贴图实现更详细的凹凸和皱纹
- en: 'In a normal map, the height (displacement) is not stored, but the direction
    of the normal for each picture is stored. Without going into too much detail,
    with normal maps, you can create very detailed-looking models that still only
    use a small number of vertices and faces. For instance, have a look at the `03-normal-map.html`
    example. The following screenshot depicts this example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在法线贴图中，不存储高度（位移），但存储每个图片的法线方向。不深入细节，使用法线贴图，您可以创建看起来非常详细的模型，同时仍然只使用少量顶点和面。例如，查看`03-normal-map.html`示例。以下截图描述了此示例：
- en: '![Achieving more detailed bumps and wrinkles with a normal map](img/2215OS_10_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用法线贴图实现更详细的凹凸和皱纹](img/2215OS_10_05.jpg)'
- en: 'In this screenshot, you can see a very detailed plastered cube to the left.
    The light source moves around the cubes, and you can see that the texture responds
    naturally to the light source. This provides a very realistic-looking model and
    only requires a very simple model and a couple of textures. The following code
    fragment shows how to use a normal map in Three.js:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此截图中，您可以看到左侧一个非常详细的抹灰立方体。光源在立方体周围移动，您可以看到纹理自然地响应光源。这提供了一个非常逼真的模型，并且只需要一个非常简单的模型和一些纹理。以下代码片段显示了如何在Three.js中使用法线贴图：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same approach is used here as was done for the bump map. This time, though,
    we set the `normalMap` property to the normal texture. We can also define how
    pronounced the bumps look by setting the `normalScale` property `mat.normalScale.set(1,1)`.
    With these two properties, you can scale along the *x* and *y* axes. The best
    approach, though, is to keep these values the same for the best effect. Note that
    once again, when these values are below zero, the heights inverse. The following
    screenshot shows both the texture (on the left-hand side) and the normal map (on
    the right-hand side):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的方法与凹凸贴图相同。不过，这次我们将`normalMap`属性设置为法线纹理。我们还可以通过设置`normalScale`属性`mat.normalScale.set(1,1)`来定义凹凸的明显程度。使用这两个属性，您可以在*x*和*y*轴上缩放。然而，最好的方法是将这些值保持相同以获得最佳效果。请注意，一旦这些值低于零，高度将反转。以下截图显示了纹理（左侧）和法线贴图（右侧）：
- en: '![Achieving more detailed bumps and wrinkles with a normal map](img/2215OS_10_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![使用法线贴图实现更详细的凹凸和皱纹](img/2215OS_10_06.jpg)'
- en: The problem with normal maps, however, is that they aren't very easy to create.
    You need to use specialized tools, such as Blender or Photoshop. They can use
    high-resolution renderings or textures as input and create normal maps from them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正常贴图的问题在于它们并不容易创建。你需要使用专门的工具，如Blender或Photoshop。它们可以使用高分辨率的渲染或纹理作为输入，并从中创建正常贴图。
- en: Three.js also provides a way to do this during runtime. The `THREE.ImageUtils`
    object has a function called `getNormalMap`, which takes a JavaScript/DOM `Image`
    as input and converts it into a normal map.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js还提供了一种在运行时执行此操作的方法。`THREE.ImageUtils`对象有一个名为`getNormalMap`的函数，它接受一个JavaScript/DOM
    `Image`作为输入，并将其转换为正常贴图。
- en: Creating fake shadows using a light map
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用光照贴图创建假阴影
- en: 'In the previous examples, we used specific maps to create real-looking shadows
    that react to the lighting in the room. There is an alternative option to create
    fake shadows. In this section, we''ll use a light map. A **light map** is a pre-rendered
    shadow (also called a prebaked shadow) that you can use to create the illusion
    of a real shadow. The following screenshot, from the `04-light-map.html` example,
    shows how this looks:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了特定的地图来创建看起来真实的阴影，这些阴影会根据房间内的光照做出反应。有一种替代方案可以创建假阴影。在本节中，我们将使用光照贴图。**光照贴图**是一个预先渲染的阴影（也称为预烘焙阴影），你可以用它来创建真实阴影的错觉。以下截图，来自`04-light-map.html`示例，展示了它的样子：
- en: '![Creating fake shadows using a light map](img/2215OS_10_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用光照贴图创建假阴影](img/2215OS_10_07.jpg)'
- en: 'If you look at the previous example, it shows a couple of very nice shadows,
    which seem to be cast by the two cubes. These shadows, however, are based on a
    light map texture that looks like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看前面的例子，它展示了几个非常漂亮的阴影，看起来像是两个立方体投射出来的。然而，这些阴影是基于以下类似的光照贴图纹理：
- en: '![Creating fake shadows using a light map](img/2215OS_10_08.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用光照贴图创建假阴影](img/2215OS_10_08.jpg)'
- en: 'As you can see, the shadows, as specified in the light map, are also shown
    as the shadows on the ground plane, creating the illusion of real shadows. You
    can use this technique to create high-resolution shadows, without incurring a
    heavy rendering penalty. This, of course, only works for static scenes. Using
    a light map is pretty much the same as using other textures with a couple of small
    differences. This is how we go about using a light map:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，光照贴图中指定的阴影也显示在地面平面上，从而营造出真实阴影的错觉。你可以使用这种技术来创建高分辨率的阴影，而不会产生沉重的渲染惩罚。当然，这仅适用于静态场景。使用光照贴图几乎与使用其他纹理一样，只是有几个小的不同。这是我们使用光照贴图的方法：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To apply a light map, we just need to set the `lightMap` property of the material
    to the light map we just showed. There is, however, an additional step required
    to get the light map to show up. We need to explicitly define the UV mapping (what
    part of the texture is shown on a face) for the light map. This needs to be done
    so that you can apply and map the light map independently of the other textures.
    In our example, we just use the basic UV mapping, automatically created by Three.js
    when we created the ground plane. More information and a background of why an
    explicit UV mapping is required can be found at [http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op](http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用光照贴图，我们只需将材质的`lightMap`属性设置为刚才展示的光照贴图。然而，为了使光照贴图显示出来，还需要进行一个额外的步骤。我们需要明确定义光照贴图的UV贴图（纹理的哪一部分显示在表面上）。这样做是为了可以独立于其他纹理应用和映射光照贴图。在我们的例子中，我们只是使用了Three.js在创建地面平面时自动创建的基本UV贴图。更多信息和为什么需要显式UV贴图的背景信息可以在[http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op](http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op)找到。
- en: When the shadow map is positioned correctly, we need to place the cubes in the
    correct location so that it looks as though the shadows are being cast by them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当阴影贴图放置正确时，我们需要将立方体放置在正确的位置，这样看起来就像阴影是由它们投射出来的。
- en: Three.js provides another texture that you can use to fake advanced 3D effects.
    In the next section, we'll look at using environment maps for fake reflections.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js还提供了另一种纹理，你可以用它来模拟高级3D效果。在下一节中，我们将探讨使用环境贴图来创建假反射。
- en: Creating fake reflections using an environment map
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用环境贴图创建假反射
- en: 'Calculating environment reflections is very CPU-intensive and usually requires
    a ray tracer approach. If you want to use reflections in Three.js, you can still
    do that, but you''ll have to fake it. You can do this by creating a texture of
    the environment the object is in and apply this to the specific object. First,
    we''ll show you the result we''re aiming for (see `05-env-map-static.html`, which
    is also shown in the following screenshot):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 计算环境反射非常占用CPU资源，通常需要使用光线追踪方法。如果你想在Three.js中使用反射，你仍然可以这样做，但你必须伪造它。你可以通过创建对象所在环境的纹理并将其应用到特定对象上来实现这一点。首先，我们将向您展示我们想要达到的结果（请参阅`05-env-map-static.html`，它也在下面的屏幕截图中显示）：
- en: '![Creating fake reflections using an environment map](img/2215OS_10_09.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![使用环境贴图创建假反射](img/2215OS_10_09.jpg)'
- en: 'In this screenshot, you can see the sphere and cube reflect the environment.
    If you move your mouse around, you can also see that the reflection corresponds
    with the camera angle in relation to the city environment you see. To create this
    example, we perform the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，你可以看到球体和立方体反射了环境。如果你移动鼠标，你还可以看到反射与你在城市环境中看到的相机角度相对应。为了创建这个示例，我们执行以下步骤：
- en: '**Create a CubeMap object**: The first thing we need to do is create a `CubeMap`
    object. `CubeMap` is a set of six textures that can be applied to each side of
    a cube.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**创建一个CubeMap对象**：我们需要做的第一件事是创建一个`CubeMap`对象。`CubeMap`是一组可以应用到立方体每个面的六个纹理。'
- en: '**Create a box with this CubeMap object**: The box with `CubeMap` is the environment
    you see when you move the camera around. It gives the illusion that you''re standing
    in an environment where you can look around. In reality, you''re inside a cube
    with textures rendered on the inside to give an illusion of space.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使用这个CubeMap对象创建一个盒子**：带有`CubeMap`的盒子是你移动相机时看到的环境。它给人一种你站在一个可以四处张望的环境中的错觉。实际上，你在一个立方体内部，立方体的内部渲染了纹理，以产生空间的错觉。'
- en: '**Apply the CubeMap object as a texture**: The same `CubeMap` object we used
    to simulate the environment can be used as a texture on the meshes. Three.js will
    make sure it looks like a reflection of the environment.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将CubeMap对象作为纹理应用**：我们用来模拟环境的同一个`CubeMap`对象也可以用作网格的纹理。Three.js会确保它看起来像是环境的反射。'
- en: 'Creating `CubeMap` is pretty easy once you''ve got the source material. What
    you need are six images that together make up a complete environment. So you need
    the following pictures: looking forward (`posz`), looking backward (`negz`), looking
    up (`posy`), looking down (`negy`), looking right (`posx`), and looking left (`negx`).
    Three.js will patch these together to create a seamless environment map. There
    are a couple of sites where you can download these pictures. The ones used in
    this example are from [http://www.humus.name/index.php?page=Textures](http://www.humus.name/index.php?page=Textures).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`CubeMap`一旦你有了源材料就相当简单。你需要的是六张图片，这些图片组合起来可以构成一个完整的环境。因此，你需要以下这些图片：向前看（`posz`）、向后看（`negz`）、向上看（`posy`）、向下看（`negy`）、向右看（`posx`）和向左看（`negx`）。Three.js会将这些图片拼接起来，创建一个无缝的环境贴图。有几个网站可以下载这些图片。本例中使用的图片来自[http://www.humus.name/index.php?page=Textures](http://www.humus.name/index.php?page=Textures)。
- en: 'Once you''ve got the six separate pictures, you can load them as shown in the
    following code fragment:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了六张单独的图片，你可以按照以下代码片段加载它们：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We again use the `THREE.ImageUtils` JavaScript object, but this time, we pass
    in an array of textures and create the `CubeMap` object using the `loadTextureCube`
    function. If you''ve already got a 360-degree panoramic image, you can also convert
    that into a set of images you can use to create `CubeMap`. Just go to [http://gonchar.me/panorama/](http://gonchar.me/panorama/)
    to convert an image, and you end up with six images with names like `right.png`,
    `left.png`, `top.png`, `bottom.png`, `front.png`, and `back.png`. You can use
    these by creating the `urls` variable like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用`THREE.ImageUtils` JavaScript对象，但这次我们传递一个纹理数组，并使用`loadTextureCube`函数创建`CubeMap`对象。如果你已经有一个360度的全景图像，你也可以将其转换为可以用来创建`CubeMap`的一组图片。只需访问[http://gonchar.me/panorama/](http://gonchar.me/panorama/)将图像转换为，你最终会得到六个名为`right.png`、`left.png`、`top.png`、`bottom.png`、`front.png`和`back.png`的图片。你可以通过创建`urls`变量来使用这些图片，如下所示：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Alternatively, you can also let Three.js handle the conversion when you load
    the scene by creating `textureCube` like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你还可以在加载场景时让Three.js处理转换，通过创建`textureCube`如下所示：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With `CubeMap`, we first create a box, which can be created like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`CubeMap`，我们首先创建一个盒子，可以创建如下：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Three.js provides a specific shader that we can use with `THREE.ShaderMaterial`
    to create an environment based on `CubeMap` (`var shader = THREE.ShaderLib[ "cube"
    ];`). We configure this shader with `CubeMap`, create a mesh, and add it to the
    scene. This mesh, if seen from the inside, represents the fake environment we're
    standing in.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一个特定的着色器，我们可以使用`THREE.ShaderMaterial`与之结合来创建基于`CubeMap`的环境（`var shader
    = THREE.ShaderLib[ "cube" ];`）。我们使用`CubeMap`配置这个着色器，创建一个网格，并将其添加到场景中。从内部看，这个网格代表了我们站立的假环境。
- en: 'This same `CubeMap` object should be applied to the meshes we want to render
    to create the fake reflection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的`CubeMap`对象应该应用于我们想要渲染的网格以创建假反射：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we set the `envMap` property of the material to the `cubeMap`
    object we created. The result is a scene where it looks like we're standing in
    a wide, outdoors environment, where the meshes reflect this environment. If you
    use the sliders, you can set the `reflectivity` property of the material, and,
    as the name implies, this determines how much of the environment is reflected
    by the material.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将材质的`envMap`属性设置为之前创建的`cubeMap`对象。结果是，场景看起来就像我们站在一个宽敞的户外环境中，网格反射了这一环境。如果你使用滑块，你可以设置材质的`reflectivity`属性，正如其名，这决定了材质反射环境程度的大小。
- en: 'Besides reflection, Three.js also allows you to use a `CubeMap` object for
    refraction (glass-like objects). The following screenshot shows this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了反射之外，Three.js还允许你使用`CubeMap`对象来实现折射（类似玻璃的物体）。以下截图展示了这一点：
- en: '![Creating fake reflections using an environment map](img/2215OS_10_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![使用环境贴图创建假反射](img/2215OS_10_10.jpg)'
- en: 'To get this effect, we just need to change the loading of the textures to this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种效果，我们只需要更改纹理的加载方式为以下内容：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can control the `refraction` ratio with the `refraction` property on the
    material, just as with the `reflection` property. In this example, we''ve used
    a static environment map for the meshes. In other words, we only saw the environment
    reflection and not the other meshes in this environment. In the following screenshot
    (which you can see in action by opening `05-env-map-dynamic.html` in your browser),
    we''ll show you how you can create a reflection that also shows the other objects
    in the scene:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过材质上的`refraction`属性来控制折射率，就像使用`reflection`属性一样。在这个例子中，我们为网格使用了静态的环境贴图。换句话说，我们只看到了这个环境中的环境反射，而没有看到其他网格。在以下截图（你可以在浏览器中打开`05-env-map-dynamic.html`来查看其效果）中，我们将向你展示如何创建一个同时显示场景中其他物体的反射：
- en: '![Creating fake reflections using an environment map](img/2215OS_10_22.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![使用环境贴图创建假反射](img/2215OS_10_22.jpg)'
- en: 'To also show reflections from the other objects in the scene, we need to use
    some other Three.js components. The first thing we need is an additional camera
    called `THREE.CubeCamera`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示场景中其他物体的反射，我们需要使用一些其他的Three.js组件。我们首先需要的是一个额外的相机，称为`THREE.CubeCamera`：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We will use `THREE.CubeCamera` to take a snapshot of the scene with all the
    objects rendered, and use that to set up `CubeMap`. You need to make sure you
    position this camera at the exact location of `THREE.Mesh` on which you want to
    show the dynamic reflections. For this example, we'll only show reflections on
    the center sphere (as you can see in the previous screenshot). This sphere is
    located at the position 0, 0, 0, so for this example, we don't need to explicitly
    position `THREE.CubeCamera`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`THREE.CubeCamera`来捕捉渲染了所有物体的场景快照，并使用它来设置`CubeMap`。你需要确保将这个相机放置在你想要显示动态反射的`THREE.Mesh`的确切位置。对于这个例子，我们只会在中心球体上显示反射（如前一个截图所示）。这个球体位于位置0,
    0, 0，因此在这个例子中，我们不需要显式地定位`THREE.CubeCamera`。
- en: 'We only apply the dynamic reflections to the sphere, so we''re going to need
    two different materials:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只将动态反射应用于球体，因此我们需要两种不同的材质：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The main difference with our previous example is that for the dynamic reflections,
    we set the `envMap` property to `cubeCamera.renderTarget` instead of to `textureCube`,
    which we created earlier. For this example, we use `dynamicEnvMaterial` on the
    central sphere and `envMaterial` for the other two objects:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的例子相比，主要区别在于，对于动态反射，我们将`envMap`属性设置为`cubeCamera.renderTarget`而不是我们之前创建的`textureCube`。对于这个例子，我们在中心球体上使用`dynamicEnvMaterial`，在其他两个物体上使用`envMaterial`：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'All that is left to do is make sure `cubeCamera` renders the scene, so we can
    use that output as input for the center sphere. To do this, we update the `render`
    loop like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作就是确保`cubeCamera`渲染场景，这样我们就可以将其输出作为中心球体的输入。为此，我们像这样更新`render`循环：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, we first disable the visibility of `sphere`. We do this because
    we only want to see reflections from the other two objects. Next, we render the
    scene using `cubeCamera` by calling the `updateCubeMap` function. After that,
    we make `sphere` visible again and render the scene as normal. The result is that
    in the reflection of the sphere, you can see the reflections of the cube and the
    cylinder.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先禁用了`sphere`的可见性。我们这样做是因为我们只想看到其他两个对象的反射。接下来，我们通过调用`updateCubeMap`函数使用`cubeCamera`渲染场景。然后，我们再次使`sphere`可见，并正常渲染场景。结果是，在球体的反射中，你可以看到立方体和圆柱体的反射。
- en: The last of the basic materials we'll look at is the specular map.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的最后一种基本材质是反射图。
- en: Specular map
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射图
- en: 'With a **specular map**, you can specify a map that defines the shininess and
    the highlight color of a material. For instance, in the following screenshot,
    we''ve used a specular map together with a normal map to render a globe. You can
    see this example if you open `06-specular-map.html` in your browser. The result
    of this is also shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**反射图**，你可以指定一个定义材料光泽度和高光颜色的图。例如，在下面的屏幕截图中，我们使用了一个反射图和一个法线图来渲染一个地球仪。如果你在浏览器中打开`06-specular-map.html`，你可以看到这个例子。其结果也在下面的屏幕截图中显示：
- en: '![Specular map](img/2215OS_10_11.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![反射图](img/2215OS_10_11.jpg)'
- en: 'In this screenshot, you can see that the oceans are highlighted and reflect
    light. The continents, on the other hand, are very dark and don''t reflect (much)
    light. For this effect, we didn''t use any specific normal textures, but only
    a normal map to show heights and the following specular map to highlight the oceans:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，你可以看到海洋被突出显示并反射光线。另一方面，大陆非常暗，不反射（很多）光线。为了实现这种效果，我们没有使用任何特定的法线纹理，而只使用了一个法线图来显示高度，以及以下反射图来突出海洋：
- en: '![Specular map](img/2215OS_10_12.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![反射图](img/2215OS_10_12.jpg)'
- en: 'Basically, what happens is that the higher the value of the pixel (from black
    to white), the shinier the surface will appear. A specular map is usually used
    together with the `specular` property that you can use to determine the color
    of the reflection. In this case, it is set to red:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，发生的情况是像素值（从黑色到白色）越高，表面看起来越亮。通常，反射图会与`specular`属性一起使用，你可以使用它来确定反射的颜色。在这种情况下，它被设置为红色：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Also note that the best effects are usually realized with low shininess, but
    depending on the lighting and the specular map you use, you might need to experiment
    to get the desired effect.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，最佳效果通常是在低光泽度下实现的，但根据你所使用的照明和反射图，你可能需要实验以获得期望的效果。
- en: Advanced usage of textures
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纹理的高级用法
- en: In the previous section, we saw some basic texture usages. Three.js also provides
    options for more advanced texture usage. In this section, we'll look at a couple
    of options that Three.js provides.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了一些基本的纹理用法。Three.js还提供了更高级纹理用法的选项。在本节中，我们将探讨Three.js提供的一些选项。
- en: Custom UV mapping
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义UV贴图
- en: 'We''ll start off with a deeper look at UV mappings. We explained earlier that
    with UV mapping, you can specify what part of a texture is shown on a specific
    face. When you create a geometry in Three.js, these mappings will also be automatically
    created based on the type of geometry you created. In most cases, you don''t really
    need to change this default UV mapping. A good way to understand how UV mapping
    works is to look at an example from Blender, which is shown in the following screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先深入探讨UV贴图。我们之前解释过，使用UV贴图，你可以指定纹理的哪个部分显示在特定的面上。当你使用Three.js创建几何体时，这些映射也将根据你创建的几何体类型自动创建。在大多数情况下，你实际上并不需要更改这个默认的UV贴图。了解UV贴图工作原理的一个好方法是查看Blender中的示例，如下面的屏幕截图所示：
- en: '![Custom UV mapping](img/2215OS_10_13.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV贴图](img/2215OS_10_13.jpg)'
- en: 'In this example, you see two windows. The window on the left-hand side contains
    a cube geometry. The window on the right-hand side is the UV mapping, where we''ve
    loaded an example texture to show how the mapping is. In this example, we''ve
    selected a single face for the window on the left-hand side and the window on
    the right-hand side shows the UV mapping for this face. As you can see, each vertex
    of the face is positioned in one of the corners of the UV mapping on the right
    (the small circles). This means that the complete texture will be used for that
    face. All the other faces of this cube are mapped in the same manner, so the result
    will show a cube where each face shows the complete texture; see `07-uv-mapping.html`,
    which is also shown in the following screenshot:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以看到两个窗口。左侧的窗口包含一个立方体几何体。右侧的窗口是UV映射，我们已加载一个示例纹理来展示映射方式。在这个例子中，我们为左侧的窗口选择了一个面，右侧窗口显示了该面的UV映射。正如你所见，该面的每个顶点都位于右侧UV映射的一个角落（小圆圈）。这意味着将使用完整的纹理来覆盖该面。这个立方体的其他面也以相同的方式映射，因此结果将显示一个每个面都显示完整纹理的立方体；请参阅`07-uv-mapping.html`，它也在以下截图中显示：
- en: '![Custom UV mapping](img/2215OS_10_14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](img/2215OS_10_14.jpg)'
- en: 'This is the default for a cube in Blender (also in Three.js). Let''s change
    the UV by selecting only two-thirds of the texture (see the selected area in the
    following screenshot):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Blender（同样在Three.js中）中立方体的默认设置。让我们通过只选择纹理的三分之二来更改UV（参见以下截图中的选中区域）：
- en: '![Custom UV mapping](img/2215OS_10_15.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](img/2215OS_10_15.jpg)'
- en: 'If we now show this in Three.js, you can see that the texture is applied differently,
    as shown in the following screenshot:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在在Three.js中显示，你可以看到纹理的应用方式不同，如下面的截图所示：
- en: '![Custom UV mapping](img/2215OS_10_16.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](img/2215OS_10_16.jpg)'
- en: 'Customizing UV mappings is normally done from programs such as Blender, especially
    when the models become more complex. The most important part to remember here
    is that UV mappings run in two dimensions, `u` and `v`, from 0 to 1\. To customize
    the UV mapping, you need to define, for each face, what part of the texture should
    be shown. You do this by defining the `u` and `v` coordinates for each of the
    vertices that make up the face. You can use the following code to set the `u`
    and `v` values:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，从Blender等程序中自定义UV映射，特别是当模型变得更加复杂时。这里需要记住的最重要部分是UV映射在两个维度`u`和`v`上运行，范围从0到1。要自定义UV映射，你需要为每个面定义纹理的哪一部分应该显示。这是通过为构成面的每个顶点定义`u`和`v`坐标来实现的。你可以使用以下代码来设置`u`和`v`值：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code snippet will set the `uv` properties of the first face to the specified
    value. Remember that each face is defined by three vertices, so to set all the
    `uv` values for a face, we need to set six properties. If you open the `07-uv-mapping-manual.html,`
    example you can see what happens when you change the `uv` mappings manually. The
    following screenshot shows the example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将设置第一个面的`uv`属性为指定的值。请记住，每个面由三个顶点定义，因此要设置一个面的所有`uv`值，我们需要设置六个属性。如果你打开`07-uv-mapping-manual.html`示例，你可以看到手动更改`uv`映射时会发生什么。以下截图显示了此示例：
- en: '![Custom UV mapping](img/2215OS_10_23.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![自定义UV映射](img/2215OS_10_23.jpg)'
- en: Next, we'll look at how textures can be repeated, which is done by some internal
    UV mapping tricks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何重复纹理，这是通过一些内部UV映射技巧实现的。
- en: Repeat wrapping
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复包裹
- en: 'When you apply a texture to a geometry created by Three.js, Three.js will try
    to apply the texture as optimally as possible. For instance, for cubes, this means
    each side will show the complete texture, and for spheres, the complete texture
    is wrapped around the sphere. There are, however, situations where you don''t
    want the texture to spread around a complete face or the complete geometry, but
    have the texture repeat itself. Three.js provides detailed functionality that
    allows you to control this. An example where you can play around with the repeat
    properties is provided in the `08-repeat-wrapping.html` example. The following
    screenshot shows this example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将纹理应用到由Three.js创建的几何体上时，Three.js会尽可能优化地应用纹理。例如，对于立方体，这意味着每个面都会显示完整的纹理，而对于球体，完整的纹理会被包裹在球体上。然而，有些情况下，你可能不希望纹理在完整面上或完整几何体上扩散，而是希望纹理重复。Three.js提供了详细的功能，允许你控制这一点。一个可以让你玩转重复属性的例子在`08-repeat-wrapping.html`示例中提供。以下截图显示了此示例：
- en: '![Repeat wrapping](img/2215OS_10_17.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![重复包裹](img/2215OS_10_17.jpg)'
- en: In this example, you can set the property that controls how a texture repeats
    itself.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你可以设置控制纹理如何重复自身的属性。
- en: 'Before this property has the desired effect, you need to make sure you set
    the wrapping of the texture to `THREE.RepeatWrapping`, as shown in the following
    code snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在此属性产生预期效果之前，你需要确保将纹理的包装设置为 `THREE.RepeatWrapping`，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `wrapS` property defines how you want the texture to behave along its *x*
    axis and the `wrapT` property defines how the texture should behave along its
    *y* axis. Three.js provides two options for this, which are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapS` 属性定义了纹理在其 *x* 轴上的行为方式，而 `wrapT` 属性定义了纹理在其 *y* 轴上的行为方式。Three.js 为此提供了两个选项，如下所示：'
- en: '`THREE.RepeatWrapping` allows the texture to repeat itself.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.RepeatWrapping` 允许纹理重复自身。'
- en: '`THREE.ClampToEdgeWrapping` is a default setting. With `THREE.ClampToEdgeWrapping,`
    the texture doesn''t repeat as a whole, but only the pixels at the edge are repeated.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.ClampToEdgeWrapping` 是默认设置。使用 `THREE.ClampToEdgeWrapping` 时，纹理不会整体重复，只有边缘的像素会被重复。'
- en: 'If you disable the **repeatWrapping** menu option, the `THREE.ClampToEdgeWrapping`
    option is used, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你禁用了 **repeatWrapping** 菜单选项，将使用 `THREE.ClampToEdgeWrapping` 选项，如下所示：
- en: '![Repeat wrapping](img/2215OS_10_18.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![重复包装](img/2215OS_10_18.jpg)'
- en: 'If we use `THREE.RepeatWrapping`, we can set the `repeat` property as shown
    in the following code fragment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `THREE.RepeatWrapping`，我们可以设置 `repeat` 属性，如下面的代码片段所示：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `repeatX` variable defines how often the texture is repeated along its *x*
    axis and the `repeatY` variable defines the same for the *y* axis. If these values
    are set to `1`, the texture won't repeat itself; if they are set to a higher value,
    you'll see that the texture will start repeating. You can also use values less
    than 1\. In that case, you can see that you'll zoom in on the texture. If you
    set the repeat value to a negative value, the texture will be mirrored.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeatX` 变量定义了纹理在其 *x* 轴上重复的频率，而 `repeatY` 变量定义了其在 *y* 轴上的相同频率。如果这些值设置为 `1`，纹理将不会重复；如果它们设置为更高的值，你会看到纹理开始重复。你也可以使用小于
    1 的值。在这种情况下，你可以看到你会放大纹理。如果你将重复值设置为负值，纹理将被镜像。'
- en: 'When you change the `repeat` property, Three.js will automatically update the
    textures and render with this new setting. If you change from `THREE.RepeatWrapping`
    to `THREE.ClampToEdgeWrapping`, you need to explicitly update the texture:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改 `repeat` 属性时，Three.js 会自动更新纹理并使用这个新设置进行渲染。如果你从 `THREE.RepeatWrapping` 更改为
    `THREE.ClampToEdgeWrapping`，你需要显式地更新纹理：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Until now, we've only used static images for our textures. Three.js, however,
    also has the option to use the HTML5 canvas as a texture.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只为纹理使用了静态图像。然而，Three.js 也提供了使用 HTML5 画布作为纹理的选项。
- en: Rendering to canvas and using it as a texture
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将渲染到画布上并用作纹理
- en: In this section, we're going to look at two different examples. First, we're
    going to look at how you can use the canvas to create a simple texture and apply
    it to a mesh, and after that, we'll go one step further and create a canvas that
    can be used as a bump map using a randomly generated pattern.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨两个不同的例子。首先，我们将看看如何使用画布创建一个简单的纹理并将其应用到网格上，然后，我们将更进一步，创建一个可以使用随机生成的图案作为凹凸图的画布。
- en: Using the canvas as a texture
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用画布作为纹理
- en: 'In the first example, we will use the **Literally** library (from [http://literallycanvas.com/](http://literallycanvas.com/))
    to create an interactive canvas that you can draw on; see the bottom-left corner
    in the following screenshot. You can view this example at `09-canvas-texture`.
    The ensuing screenshot shows this example:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们将使用 **Literally** 库（来自 [http://literallycanvas.com/](http://literallycanvas.com/)）创建一个可以绘制的交互式画布；请参见以下截图的左下角。你可以在
    `09-canvas-texture` 处查看此示例。接下来的截图显示了此示例：
- en: '![Using the canvas as a texture](img/2215OS_10_19.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![使用画布作为纹理](img/2215OS_10_19.jpg)'
- en: 'Anything you draw on this canvas is directly rendered on the cube as a texture.
    Accomplishing this in Three.js is really simple and only takes a couple of steps.
    The first thing we need to do is create a canvas element and, for this specific
    example, configure it to be used with the `Literally` library, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这张画布上绘制的任何内容都会直接作为纹理渲染到立方体上。在 Three.js 中实现这一点非常简单，只需几个步骤。首先，我们需要创建一个画布元素，并且在这个特定例子中，将其配置为与
    `Literally` 库一起使用，如下所示：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We just create a `canvas` element from JavaScript and add it to a specific
    `div` element. With the `literallycanvas` call, we can create the drawing tools
    that you can use to directly draw on the canvas. Next, we need to create a texture
    that uses the canvas drawing as its input:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需使用 JavaScript 创建一个 `canvas` 元素并将其添加到特定的 `div` 元素中。通过 `literallycanvas` 调用，我们可以创建可以直接在画布上使用的绘图工具。接下来，我们需要创建一个使用画布绘制作为其输入的纹理：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As the code shows, the only thing you need to do to is pass in the reference
    to the canvas element when you create a new texture, `new THREE.Texture(canvas)`.
    This will create a texture that uses the canvas element as its material. All that
    is left is to update the material whenever we render so that the latest version
    of the canvas drawing is shown on the cube, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码所示，您需要做的只是在新创建纹理时传入画布元素的引用，`new THREE.Texture(canvas)`。这将创建一个使用画布元素作为其材质的纹理。剩下的事情就是在渲染时更新材质，以便在立方体上显示最新的画布绘制版本，如下所示：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To inform Three.js that we want to update the texture, we just set the `needsUpdate`
    property of the texture to `true`. In this example, we've used the canvas element
    as input for the most simple of textures. We can, of course, use this same idea
    for all the different types of maps we've seen so far. In the next example, we'll
    use it as a bump map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通知 Three.js 我们想要更新纹理，我们只需将纹理的 `needsUpdate` 属性设置为 `true`。在这个例子中，我们使用了画布元素作为最简单纹理的输入。当然，我们可以使用这个相同的概念来处理我们迄今为止看到的所有不同类型的贴图。在下一个示例中，我们将将其用作凹凸贴图。
- en: Using the canvas as a bump map
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用画布作为凹凸贴图
- en: As we've seen earlier in this chapter, we can create a simple wrinkled texture
    with a bump map. The higher the intensity of a pixel in this map, the higher the
    wrinkling. Since a bump map is just a simple black-and-white image, nothing keeps
    us from creating this on a canvas and using that canvas as an input for the bump
    map.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在本章前面所见，我们可以使用凹凸贴图创建一个简单的皱纹纹理。在这个地图中像素的强度越高，皱纹就越深。由于凹凸贴图只是一个简单的黑白图像，没有什么阻止我们在画布上创建这样的图像，并将其用作凹凸贴图的输入。
- en: 'In the following example, we use a canvas to generate a random grayscale image,
    and we use that image as an input for the bump map we apply to the cube. See the
    `09-canvas-texture-bumpmap.html` example. The following screenshot shows this
    example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用画布生成一个随机灰度图像，并将该图像作为我们应用于立方体的凹凸贴图的输入。请参阅 `09-canvas-texture-bumpmap.html`
    示例。以下截图显示了此示例：
- en: '![Using the canvas as a bump map](img/2215OS_10_20.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![使用画布作为凹凸贴图](img/2215OS_10_20.jpg)'
- en: 'The JavaScript code required for this is not that different from the previous
    example we explained. We need to create a canvas element and fill this canvas
    with some random noise. For the noise, we use **Perlin noise**. Perlin noise ([http://en.wikipedia.org/wiki/Perlin_noise](http://en.wikipedia.org/wiki/Perlin_noise))
    generates a very natural-looking random texture as you can see in the preceding
    screenshot. We use the Perlin noise function from [https://github.com/wwwtyro/perlin.js](https://github.com/wwwtyro/perlin.js)
    for this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的的 JavaScript 代码与我们之前解释的示例没有太大区别。我们需要创建一个画布元素并将一些随机噪声填充到这个画布中。对于噪声，我们使用
    **Perlin 噪声**。Perlin 噪声（[http://en.wikipedia.org/wiki/Perlin_noise](http://en.wikipedia.org/wiki/Perlin_noise)）生成了一种非常自然的外观随机纹理，正如您在前面的截图中所看到的。我们使用来自
    [https://github.com/wwwtyro/perlin.js](https://github.com/wwwtyro/perlin.js) 的
    Perlin 噪声函数：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We use the `perlin.noise` function to create a value from 0 to 1 based on the
    *x* and *y* coordinates of the canvas element. This value is used to draw a single
    pixel on the canvas element. Doing this for all the pixels creates the random
    map you can also see in the bottom-left corner of the previous screenshot. This
    map can then be easily used as a bump map. Here''s how the random map can be created:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `perlin.noise` 函数根据画布元素的 *x* 和 *y* 坐标创建一个从 0 到 1 的值。这个值用于在画布元素上绘制单个像素。对所有像素执行此操作将创建一个随机地图，您也可以在上一张截图的左下角看到。这个地图可以很容易地用作凹凸贴图。以下是创建随机地图的方法：
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In this example, we've rendered Perlin noise using an HTML canvas element. Three.js
    also provides an alternative way to dynamically create a texture. The `THREE.ImageUtils`
    object has a `generateDataTexture` function, which you can use to create a `THREE.DataTexture`
    texture of a specific size. This texture contains `Uint8Array` in the `image.data`
    property, which you can use to directly set the RGB values of this texture.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用HTML画布元素渲染了Perlin噪声。Three.js还提供了一个动态创建纹理的替代方法。`THREE.ImageUtils`对象有一个`generateDataTexture`函数，你可以使用它来创建一个特定大小的`THREE.DataTexture`纹理。这个纹理在`image.data`属性中包含`Uint8Array`，你可以使用它来直接设置这个纹理的RGB值。
- en: 'The final input we use for the texture is another HTML element: the HTML5 video
    element.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于纹理的最终输入是另一个HTML元素：HTML5视频元素。
- en: Using the output from a video as a texture
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视频输出作为纹理
- en: 'If you''ve read the previous paragraph on rendering to canvas, you might have
    thought about rendering video to canvas and using that as input for a texture.
    That is an option, but Three.js (through WebGL) already has direct support to
    use the HTML5 video element. Check out `11-video-texture.html`. Refer to the following
    screenshot for a still image of this example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读了关于渲染到画布的上一段内容，你可能已经考虑过将视频渲染到画布上，并使用它作为纹理的输入。这是一个选项，但Three.js（通过WebGL）已经直接支持使用HTML5视频元素。查看`11-video-texture.html`。参考以下截图以获取此示例的静态图像：
- en: '![Using the output from a video as a texture](img/2215OS_10_21.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![使用视频输出作为纹理](img/2215OS_10_21.jpg)'
- en: 'Using video as input for a texture is, just like using the canvas element,
    very easy. First off, we need to have a video element to play the video:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用视频作为纹理的输入，就像使用画布元素一样，非常简单。首先，我们需要一个视频元素来播放视频：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This was just a basic HTML5 video element that we set to automatically play.
    Next, we can configure Three.js to use this video as an input for a texture, as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个基本的HTML5视频元素，我们将其设置为自动播放。接下来，我们可以配置Three.js使用这个视频作为纹理的输入，如下所示：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since our video isn''t square, we need to make sure we disable the mipmap generation
    on the material. We also set some simple high-performance filters as the material
    changes very often. All that is left to do now is create a mesh and set the texture.
    In this example, we''ve used `MeshFaceMaterial` together with `MeshBasicMaterial`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的视频不是正方形，我们需要确保在材质上禁用mipmap生成。我们还设置了一些简单的、高性能的过滤器，因为材质经常改变。现在我们只剩下创建网格并设置纹理了。在这个例子中，我们使用了`MeshFaceMaterial`与`MeshBasicMaterial`：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'All that is left to do is make sure that in our `render` loop, we update the
    texture, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下要做的就是确保在我们的`render`循环中更新纹理，如下所示：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we just rendered the video to one side of the cube, but since
    this is a normal texture, we could do anything we want with it. We could, for
    instance, divide it along the sides of a cube using custom UV mapping, or we could
    even use video input as input for a bump map or a normal map.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是将视频渲染到立方体的一个侧面，但由于这是一个普通纹理，我们可以用它做任何事情。例如，我们可以使用自定义UV映射沿着立方体的侧面分割它，或者甚至可以使用视频输入作为凹凸贴图或法线贴图的输入。
- en: 'In Three.js version r69, a texture specifically for dealing with videos was
    introduced. This texture (`THREE.VideoTexture`) wraps the code you''ve seen in
    this section, and you can use the `THREE.VideoTexture` approach as an alternative.
    The following code fragment shows how to use `THREE.VideoTexture` to create a
    texture (you can see this in action by looking at the `11-video-texture.html`
    example):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js版本r69中，引入了一种专门用于处理视频的纹理。这个纹理（`THREE.VideoTexture`）封装了你在本节中看到的代码，你可以使用`THREE.VideoTexture`方法作为替代。以下代码片段显示了如何使用`THREE.VideoTexture`创建纹理（你可以在`11-video-texture.html`示例中看到这个动作）：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: And so we end this chapter on textures. As you've seen, there are lots of different
    kinds of textures available in Three.js, each with their different uses. You can
    use any image in the PNG, JPG, GIF, TGA, DDS, or PVR format as a texture. Loading
    these images is done asynchronously, so remember to either use a rendering loop
    or add a callback when you load the texture. With textures, you can create great-looking
    objects from low-poly models and even add fake detailed depth using bump maps
    and normal maps. With Three.js, it is also easy to create dynamic textures using
    either the HTML5 canvas element or the video element. Just define a texture with
    these elements as the input and set the `needsUpdate` property to `true` whenever
    you want the texture to be updated.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们以纹理这一章节结束。正如你所见，Three.js中提供了许多不同种类的纹理，每种纹理都有其不同的用途。你可以使用PNG、JPG、GIF、TGA、DDS或PVR格式的任何图像作为纹理。加载这些图像是异步进行的，所以记得在加载纹理时使用渲染循环或添加回调。使用纹理，你可以从低多边形模型创建外观出色的对象，甚至可以使用凹凸贴图和法线贴图添加虚假的深度细节。在Three.js中，使用HTML5画布元素或视频元素创建动态纹理也非常简单。只需定义一个以这些元素作为输入的纹理，并在需要更新纹理时将`needsUpdate`属性设置为`true`。
- en: With this chapter out of the way, we've pretty much covered all the important
    concepts of Three.js. We haven't, however, looked at an interesting feature Three.js
    offers—**postprocessing**. With postprocessing, you can add effects to your scene
    after it is rendered. You could, for instance, blur or colorize your scene or
    add a TV-like effect using scan lines. In the next chapter, we'll look at postprocessing
    and how you can apply it to your scene.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容已经完成，我们基本上涵盖了Three.js的所有重要概念。然而，我们还没有探讨Three.js提供的一个有趣特性——**后期处理**。通过后期处理，你可以在场景渲染后添加效果。例如，你可以模糊或着色你的场景，或者使用扫描线添加类似电视的效果。在下一章中，我们将探讨后期处理以及如何将其应用于你的场景。
