- en: Chapter 10. Loading and Working with Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Working with Three.js Materials"), *Working
    with Three.js Materials*, we introduced you to the various materials that are
    available in Three.js. In that chapter, however, we didn''t talk about applying
    textures to meshes. In this chapter, we''ll look at that subject. More specifically,
    in this chapter, we''ll discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Loading textures in Three.js and applying them to a mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using bump and normal maps to apply depth and detail to a mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating fake shadows using a light map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding detailed reflection to a material using an environment map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a specular map to set the *shininess* of specific parts of a mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fine-tuning and customizing the UV mapping of a mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the HTML5 canvas and video element as input for a texture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the most basic example, where we show you how to load and apply
    a texture.
  prefs: []
  type: TYPE_NORMAL
- en: Using textures in materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different ways textures are used in Three.js. You can use them to
    define the colors of the mesh, but you can also use them to define shininess,
    bumps, and reflections. The first example we look at, though, is the most basic
    approach, where we use a texture to define the colors of the individual pixels
    of a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a texture and applying it to a mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most basic usage of a texture is when it's set as a map on a material. When
    you use this material to create a mesh, the mesh will be colored based on the
    supplied texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading a texture and using it on a mesh can be done in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code sample, we use the `THREE.ImageUtils.loadTexture` function to
    load an image file from a specific location. You can use PNG, GIF, or JPEG images
    as input for a texture. Note that loading textures is done asynchronously. In
    our scenario, this isn''t an issue as we have a `render` loop where we render
    the scene around 60 times per second. If you want to wait until a texture is loaded,
    you could use the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we supply a callback function to `loadTexture`. This callback
    is called when the texture is loaded. In our examples, we don't use the callback
    and rely on the `render` loop to eventually show the texture when it's loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use pretty much any image you''d like as a texture. The best results,
    however, are when you use a square texture whose dimensions are a power of 2\.
    So dimensions such as 256 x 256, 512 x 512, 1024 x 1024, and so on work the best.
    The following image is an example of a square texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading a texture and applying it to a mesh](img/2215OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since the pixels of a texture (also called **texels**) usually don''t map one-to-one
    on the pixels of the face, the texture needs to be magnified or minified. For
    this purpose, WebGL and Three.js offer a couple of different options. You can
    specify how the texture is magnified by setting the `magFilter` property and how
    it is minified with the `minFilter` property. These properties can be set to the
    following two basic values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.NearestFilter` | This filter uses the color of the nearest texel that
    it can find. When used for magnification, this will result in blockiness, and
    when used for minification, the result will lose much detail. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.LinearFilter` | This filter is more advanced and uses the color value
    of the four neighboring texels to determine the correct color. You''ll still lose
    much detail in minification, but the magnification will be much smoother and less
    blocky. |'
  prefs: []
  type: TYPE_TB
- en: 'Besides these basic values, we can also use a mipmap. A **mipmap** is a set
    of texture images, each half the size of the previous one. These are created when
    you load the texture and allow much smoother filtering. So, when you''ve got a
    square texture (as a power of 2), you can use a couple of additional approaches
    for better filtering. The properties can be set using the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.NearestMipMapNearestFilter` | This property selects the mipmap that
    best maps the required resolution and applies the nearest filter principle that
    we discussed in the previous table. Magnification is still blocky, but minification
    looks much better. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.NearestMipMapLinearFilter` | This property selects not just a single
    mipmap but the two nearest mipmap levels. On both these levels, a nearest filter
    is applied to get two intermediate results. These two results are passed through
    a linear filter to get the final result. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.LinearMipMapNearestFilter` | This property selects the mipmap that
    best maps the required resolution and applies the linear filter principle we discussed
    in the previous table. |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.LinearMipMapLinearFilter` | This property selects not a single mipmap
    but the two nearest mipmap levels. On both these levels, a linear filter is applied
    to get two intermediate results. These two results are passed through a linear
    filter to get the final result. |'
  prefs: []
  type: TYPE_TB
- en: 'If you don''t specify the `magFilter` and `minFilter` properties explicitly,
    Three.js uses `THREE.LinearFilter` as the default for the `magFilter` property
    and `THREE.LinearMipMapLinearFilter` as the default for the `minFilter` property.
    In our examples, we''ll just use these default properties. An example for the
    basic texture can be found in `01-basic-texture.html`. The following screenshot
    shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading a texture and applying it to a mesh](img/2215OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, we load a couple of textures (using the code you saw earlier)
    and apply them to various shapes. In this example, you can see that the textures
    nicely wrap around the shapes. When you create geometries in Three.js, it makes
    sure that any texture that is used is applied correctly. This is done by something
    called **UV mapping** (more on this later in this chapter). With UV mapping, we
    tell the renderer which part of a texture should be applied to a specific face.
    The easiest example for this is the cube. The UV mapping for one of the faces
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This means that we use the complete texture (UV values range from 0 to 1) for
    this face.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the standard image formats we can load with `THREE.ImageUtils.loadTexture`,
    Three.js also provides a couple of custom loaders you can use to load textures
    provided in different formats. The following table shows the additional loaders
    you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `THREE.DDSLoader` | With this loader, you can load textures that are provided
    in the DirectDraw Surface format. This format is a proprietary Microsoft format
    to store compressed textures. Using this loader is very easy. First, include the
    `DDSLoader.js` file in your HTML page and then use the following to use a texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You can see an example of this loader in the sources for this chapter in `01-basic-texture-dds.html`.
    Internally, this loader uses `THREE.CompressedTextureLoader`. |
  prefs: []
  type: TYPE_NORMAL
- en: '| `THREE.PVRLoader` | Power VR is another proprietary file format to store
    compressed textures. Three.js supports the Power VR 3.0 file format and can use
    textures provided in this format. To use this loader, include the `PVRLoader.js`
    file in your HTML page and then use the following to use a texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see an example of this loader in the sources for this chapter: `01-basic-texture-pvr.html`.
    Note that not all WebGL implementations support textures in this format. So when
    you use this and don''t see a texture, check the console for errors. Internally,
    this loader also uses `THREE.CompressedTextureLoader`. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `THREE.TGALoader` | Targa is a raster graphics file format that is still
    used by a large number of 3D software programs. With the `THREE.TGALoader` object,
    you can use textures provided in this format with your 3D models. To use these
    image files, you first have to include the `TGALoader.js` file in your HTML, and
    then you can use the following to load a TGA texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: An example of this loader is provided in the sources of this chapter. You can
    view this example by opening `01-basic-texture-tga.html` in your browser. |
  prefs: []
  type: TYPE_NORMAL
- en: In these examples, we've used textures to define the color of the pixels of
    our mesh. We can also use textures for other purposes. The following two examples
    are used to define how shading is applied to a material. You use this to create
    bumps and wrinkles on the surface of a mesh.
  prefs: []
  type: TYPE_NORMAL
- en: Using a bump map to create wrinkles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **bump map** is used to add more depth to a material. You can see this in
    action by opening up the `02-bump-map.html` example. Refer to the following screenshot
    to see the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a bump map to create wrinkles](img/2215OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you can see that the left-hand side wall looks much more detailed
    and seems to have much more depth when you compare it with the wall on the right-hand
    side. This is done by setting an additional texture, a so-called bump map, on
    the material:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see in this code that besides setting the `map` property, we also set
    the `bumpMap` property to a texture. Additionally, with the `bumpScale` property,
    we can set the height (or depth if set to a negative value) of the bumps. The
    textures used in this example are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a bump map to create wrinkles](img/2215OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The bump map is a grayscale image, but you can also use a color image. The intensity
    of the pixel defines the height of the bump. A bump map only contains the relative
    height of a pixel. It doesn't say anything about the direction of the slope. So
    the level of detail and perception of depth that you can reach with a bump map
    is limited. For more details, you can use a normal map.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving more detailed bumps and wrinkles with a normal map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a normal map, the height (displacement) is not stored, but the direction
    of the normal for each picture is stored. Without going into too much detail,
    with normal maps, you can create very detailed-looking models that still only
    use a small number of vertices and faces. For instance, have a look at the `03-normal-map.html`
    example. The following screenshot depicts this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Achieving more detailed bumps and wrinkles with a normal map](img/2215OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot, you can see a very detailed plastered cube to the left.
    The light source moves around the cubes, and you can see that the texture responds
    naturally to the light source. This provides a very realistic-looking model and
    only requires a very simple model and a couple of textures. The following code
    fragment shows how to use a normal map in Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The same approach is used here as was done for the bump map. This time, though,
    we set the `normalMap` property to the normal texture. We can also define how
    pronounced the bumps look by setting the `normalScale` property `mat.normalScale.set(1,1)`.
    With these two properties, you can scale along the *x* and *y* axes. The best
    approach, though, is to keep these values the same for the best effect. Note that
    once again, when these values are below zero, the heights inverse. The following
    screenshot shows both the texture (on the left-hand side) and the normal map (on
    the right-hand side):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Achieving more detailed bumps and wrinkles with a normal map](img/2215OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The problem with normal maps, however, is that they aren't very easy to create.
    You need to use specialized tools, such as Blender or Photoshop. They can use
    high-resolution renderings or textures as input and create normal maps from them.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js also provides a way to do this during runtime. The `THREE.ImageUtils`
    object has a function called `getNormalMap`, which takes a JavaScript/DOM `Image`
    as input and converts it into a normal map.
  prefs: []
  type: TYPE_NORMAL
- en: Creating fake shadows using a light map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous examples, we used specific maps to create real-looking shadows
    that react to the lighting in the room. There is an alternative option to create
    fake shadows. In this section, we''ll use a light map. A **light map** is a pre-rendered
    shadow (also called a prebaked shadow) that you can use to create the illusion
    of a real shadow. The following screenshot, from the `04-light-map.html` example,
    shows how this looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fake shadows using a light map](img/2215OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look at the previous example, it shows a couple of very nice shadows,
    which seem to be cast by the two cubes. These shadows, however, are based on a
    light map texture that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fake shadows using a light map](img/2215OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, the shadows, as specified in the light map, are also shown
    as the shadows on the ground plane, creating the illusion of real shadows. You
    can use this technique to create high-resolution shadows, without incurring a
    heavy rendering penalty. This, of course, only works for static scenes. Using
    a light map is pretty much the same as using other textures with a couple of small
    differences. This is how we go about using a light map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To apply a light map, we just need to set the `lightMap` property of the material
    to the light map we just showed. There is, however, an additional step required
    to get the light map to show up. We need to explicitly define the UV mapping (what
    part of the texture is shown on a face) for the light map. This needs to be done
    so that you can apply and map the light map independently of the other textures.
    In our example, we just use the basic UV mapping, automatically created by Three.js
    when we created the ground plane. More information and a background of why an
    explicit UV mapping is required can be found at [http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op](http://stackoverflow.com/questions/15137695/three-js-lightmap-causes-an-error-webglrenderingcontext-gl-error-gl-invalid-op).
  prefs: []
  type: TYPE_NORMAL
- en: When the shadow map is positioned correctly, we need to place the cubes in the
    correct location so that it looks as though the shadows are being cast by them.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js provides another texture that you can use to fake advanced 3D effects.
    In the next section, we'll look at using environment maps for fake reflections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating fake reflections using an environment map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Calculating environment reflections is very CPU-intensive and usually requires
    a ray tracer approach. If you want to use reflections in Three.js, you can still
    do that, but you''ll have to fake it. You can do this by creating a texture of
    the environment the object is in and apply this to the specific object. First,
    we''ll show you the result we''re aiming for (see `05-env-map-static.html`, which
    is also shown in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fake reflections using an environment map](img/2215OS_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot, you can see the sphere and cube reflect the environment.
    If you move your mouse around, you can also see that the reflection corresponds
    with the camera angle in relation to the city environment you see. To create this
    example, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create a CubeMap object**: The first thing we need to do is create a `CubeMap`
    object. `CubeMap` is a set of six textures that can be applied to each side of
    a cube.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Create a box with this CubeMap object**: The box with `CubeMap` is the environment
    you see when you move the camera around. It gives the illusion that you''re standing
    in an environment where you can look around. In reality, you''re inside a cube
    with textures rendered on the inside to give an illusion of space.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Apply the CubeMap object as a texture**: The same `CubeMap` object we used
    to simulate the environment can be used as a texture on the meshes. Three.js will
    make sure it looks like a reflection of the environment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creating `CubeMap` is pretty easy once you''ve got the source material. What
    you need are six images that together make up a complete environment. So you need
    the following pictures: looking forward (`posz`), looking backward (`negz`), looking
    up (`posy`), looking down (`negy`), looking right (`posx`), and looking left (`negx`).
    Three.js will patch these together to create a seamless environment map. There
    are a couple of sites where you can download these pictures. The ones used in
    this example are from [http://www.humus.name/index.php?page=Textures](http://www.humus.name/index.php?page=Textures).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve got the six separate pictures, you can load them as shown in the
    following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We again use the `THREE.ImageUtils` JavaScript object, but this time, we pass
    in an array of textures and create the `CubeMap` object using the `loadTextureCube`
    function. If you''ve already got a 360-degree panoramic image, you can also convert
    that into a set of images you can use to create `CubeMap`. Just go to [http://gonchar.me/panorama/](http://gonchar.me/panorama/)
    to convert an image, and you end up with six images with names like `right.png`,
    `left.png`, `top.png`, `bottom.png`, `front.png`, and `back.png`. You can use
    these by creating the `urls` variable like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also let Three.js handle the conversion when you load
    the scene by creating `textureCube` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With `CubeMap`, we first create a box, which can be created like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Three.js provides a specific shader that we can use with `THREE.ShaderMaterial`
    to create an environment based on `CubeMap` (`var shader = THREE.ShaderLib[ "cube"
    ];`). We configure this shader with `CubeMap`, create a mesh, and add it to the
    scene. This mesh, if seen from the inside, represents the fake environment we're
    standing in.
  prefs: []
  type: TYPE_NORMAL
- en: 'This same `CubeMap` object should be applied to the meshes we want to render
    to create the fake reflection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we set the `envMap` property of the material to the `cubeMap`
    object we created. The result is a scene where it looks like we're standing in
    a wide, outdoors environment, where the meshes reflect this environment. If you
    use the sliders, you can set the `reflectivity` property of the material, and,
    as the name implies, this determines how much of the environment is reflected
    by the material.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides reflection, Three.js also allows you to use a `CubeMap` object for
    refraction (glass-like objects). The following screenshot shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fake reflections using an environment map](img/2215OS_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get this effect, we just need to change the loading of the textures to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can control the `refraction` ratio with the `refraction` property on the
    material, just as with the `reflection` property. In this example, we''ve used
    a static environment map for the meshes. In other words, we only saw the environment
    reflection and not the other meshes in this environment. In the following screenshot
    (which you can see in action by opening `05-env-map-dynamic.html` in your browser),
    we''ll show you how you can create a reflection that also shows the other objects
    in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating fake reflections using an environment map](img/2215OS_10_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To also show reflections from the other objects in the scene, we need to use
    some other Three.js components. The first thing we need is an additional camera
    called `THREE.CubeCamera`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We will use `THREE.CubeCamera` to take a snapshot of the scene with all the
    objects rendered, and use that to set up `CubeMap`. You need to make sure you
    position this camera at the exact location of `THREE.Mesh` on which you want to
    show the dynamic reflections. For this example, we'll only show reflections on
    the center sphere (as you can see in the previous screenshot). This sphere is
    located at the position 0, 0, 0, so for this example, we don't need to explicitly
    position `THREE.CubeCamera`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only apply the dynamic reflections to the sphere, so we''re going to need
    two different materials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference with our previous example is that for the dynamic reflections,
    we set the `envMap` property to `cubeCamera.renderTarget` instead of to `textureCube`,
    which we created earlier. For this example, we use `dynamicEnvMaterial` on the
    central sphere and `envMaterial` for the other two objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do is make sure `cubeCamera` renders the scene, so we can
    use that output as input for the center sphere. To do this, we update the `render`
    loop like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we first disable the visibility of `sphere`. We do this because
    we only want to see reflections from the other two objects. Next, we render the
    scene using `cubeCamera` by calling the `updateCubeMap` function. After that,
    we make `sphere` visible again and render the scene as normal. The result is that
    in the reflection of the sphere, you can see the reflections of the cube and the
    cylinder.
  prefs: []
  type: TYPE_NORMAL
- en: The last of the basic materials we'll look at is the specular map.
  prefs: []
  type: TYPE_NORMAL
- en: Specular map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With a **specular map**, you can specify a map that defines the shininess and
    the highlight color of a material. For instance, in the following screenshot,
    we''ve used a specular map together with a normal map to render a globe. You can
    see this example if you open `06-specular-map.html` in your browser. The result
    of this is also shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specular map](img/2215OS_10_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this screenshot, you can see that the oceans are highlighted and reflect
    light. The continents, on the other hand, are very dark and don''t reflect (much)
    light. For this effect, we didn''t use any specific normal textures, but only
    a normal map to show heights and the following specular map to highlight the oceans:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specular map](img/2215OS_10_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Basically, what happens is that the higher the value of the pixel (from black
    to white), the shinier the surface will appear. A specular map is usually used
    together with the `specular` property that you can use to determine the color
    of the reflection. In this case, it is set to red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Also note that the best effects are usually realized with low shininess, but
    depending on the lighting and the specular map you use, you might need to experiment
    to get the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced usage of textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw some basic texture usages. Three.js also provides
    options for more advanced texture usage. In this section, we'll look at a couple
    of options that Three.js provides.
  prefs: []
  type: TYPE_NORMAL
- en: Custom UV mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll start off with a deeper look at UV mappings. We explained earlier that
    with UV mapping, you can specify what part of a texture is shown on a specific
    face. When you create a geometry in Three.js, these mappings will also be automatically
    created based on the type of geometry you created. In most cases, you don''t really
    need to change this default UV mapping. A good way to understand how UV mapping
    works is to look at an example from Blender, which is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UV mapping](img/2215OS_10_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you see two windows. The window on the left-hand side contains
    a cube geometry. The window on the right-hand side is the UV mapping, where we''ve
    loaded an example texture to show how the mapping is. In this example, we''ve
    selected a single face for the window on the left-hand side and the window on
    the right-hand side shows the UV mapping for this face. As you can see, each vertex
    of the face is positioned in one of the corners of the UV mapping on the right
    (the small circles). This means that the complete texture will be used for that
    face. All the other faces of this cube are mapped in the same manner, so the result
    will show a cube where each face shows the complete texture; see `07-uv-mapping.html`,
    which is also shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UV mapping](img/2215OS_10_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the default for a cube in Blender (also in Three.js). Let''s change
    the UV by selecting only two-thirds of the texture (see the selected area in the
    following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UV mapping](img/2215OS_10_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we now show this in Three.js, you can see that the texture is applied differently,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UV mapping](img/2215OS_10_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Customizing UV mappings is normally done from programs such as Blender, especially
    when the models become more complex. The most important part to remember here
    is that UV mappings run in two dimensions, `u` and `v`, from 0 to 1\. To customize
    the UV mapping, you need to define, for each face, what part of the texture should
    be shown. You do this by defining the `u` and `v` coordinates for each of the
    vertices that make up the face. You can use the following code to set the `u`
    and `v` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This code snippet will set the `uv` properties of the first face to the specified
    value. Remember that each face is defined by three vertices, so to set all the
    `uv` values for a face, we need to set six properties. If you open the `07-uv-mapping-manual.html,`
    example you can see what happens when you change the `uv` mappings manually. The
    following screenshot shows the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom UV mapping](img/2215OS_10_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we'll look at how textures can be repeated, which is done by some internal
    UV mapping tricks.
  prefs: []
  type: TYPE_NORMAL
- en: Repeat wrapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you apply a texture to a geometry created by Three.js, Three.js will try
    to apply the texture as optimally as possible. For instance, for cubes, this means
    each side will show the complete texture, and for spheres, the complete texture
    is wrapped around the sphere. There are, however, situations where you don''t
    want the texture to spread around a complete face or the complete geometry, but
    have the texture repeat itself. Three.js provides detailed functionality that
    allows you to control this. An example where you can play around with the repeat
    properties is provided in the `08-repeat-wrapping.html` example. The following
    screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Repeat wrapping](img/2215OS_10_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, you can set the property that controls how a texture repeats
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before this property has the desired effect, you need to make sure you set
    the wrapping of the texture to `THREE.RepeatWrapping`, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wrapS` property defines how you want the texture to behave along its *x*
    axis and the `wrapT` property defines how the texture should behave along its
    *y* axis. Three.js provides two options for this, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`THREE.RepeatWrapping` allows the texture to repeat itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`THREE.ClampToEdgeWrapping` is a default setting. With `THREE.ClampToEdgeWrapping,`
    the texture doesn''t repeat as a whole, but only the pixels at the edge are repeated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you disable the **repeatWrapping** menu option, the `THREE.ClampToEdgeWrapping`
    option is used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Repeat wrapping](img/2215OS_10_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we use `THREE.RepeatWrapping`, we can set the `repeat` property as shown
    in the following code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `repeatX` variable defines how often the texture is repeated along its *x*
    axis and the `repeatY` variable defines the same for the *y* axis. If these values
    are set to `1`, the texture won't repeat itself; if they are set to a higher value,
    you'll see that the texture will start repeating. You can also use values less
    than 1\. In that case, you can see that you'll zoom in on the texture. If you
    set the repeat value to a negative value, the texture will be mirrored.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you change the `repeat` property, Three.js will automatically update the
    textures and render with this new setting. If you change from `THREE.RepeatWrapping`
    to `THREE.ClampToEdgeWrapping`, you need to explicitly update the texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Until now, we've only used static images for our textures. Three.js, however,
    also has the option to use the HTML5 canvas as a texture.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering to canvas and using it as a texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we're going to look at two different examples. First, we're
    going to look at how you can use the canvas to create a simple texture and apply
    it to a mesh, and after that, we'll go one step further and create a canvas that
    can be used as a bump map using a randomly generated pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Using the canvas as a texture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the first example, we will use the **Literally** library (from [http://literallycanvas.com/](http://literallycanvas.com/))
    to create an interactive canvas that you can draw on; see the bottom-left corner
    in the following screenshot. You can view this example at `09-canvas-texture`.
    The ensuing screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the canvas as a texture](img/2215OS_10_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Anything you draw on this canvas is directly rendered on the cube as a texture.
    Accomplishing this in Three.js is really simple and only takes a couple of steps.
    The first thing we need to do is create a canvas element and, for this specific
    example, configure it to be used with the `Literally` library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We just create a `canvas` element from JavaScript and add it to a specific
    `div` element. With the `literallycanvas` call, we can create the drawing tools
    that you can use to directly draw on the canvas. Next, we need to create a texture
    that uses the canvas drawing as its input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As the code shows, the only thing you need to do to is pass in the reference
    to the canvas element when you create a new texture, `new THREE.Texture(canvas)`.
    This will create a texture that uses the canvas element as its material. All that
    is left is to update the material whenever we render so that the latest version
    of the canvas drawing is shown on the cube, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: To inform Three.js that we want to update the texture, we just set the `needsUpdate`
    property of the texture to `true`. In this example, we've used the canvas element
    as input for the most simple of textures. We can, of course, use this same idea
    for all the different types of maps we've seen so far. In the next example, we'll
    use it as a bump map.
  prefs: []
  type: TYPE_NORMAL
- en: Using the canvas as a bump map
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we've seen earlier in this chapter, we can create a simple wrinkled texture
    with a bump map. The higher the intensity of a pixel in this map, the higher the
    wrinkling. Since a bump map is just a simple black-and-white image, nothing keeps
    us from creating this on a canvas and using that canvas as an input for the bump
    map.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we use a canvas to generate a random grayscale image,
    and we use that image as an input for the bump map we apply to the cube. See the
    `09-canvas-texture-bumpmap.html` example. The following screenshot shows this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the canvas as a bump map](img/2215OS_10_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The JavaScript code required for this is not that different from the previous
    example we explained. We need to create a canvas element and fill this canvas
    with some random noise. For the noise, we use **Perlin noise**. Perlin noise ([http://en.wikipedia.org/wiki/Perlin_noise](http://en.wikipedia.org/wiki/Perlin_noise))
    generates a very natural-looking random texture as you can see in the preceding
    screenshot. We use the Perlin noise function from [https://github.com/wwwtyro/perlin.js](https://github.com/wwwtyro/perlin.js)
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `perlin.noise` function to create a value from 0 to 1 based on the
    *x* and *y* coordinates of the canvas element. This value is used to draw a single
    pixel on the canvas element. Doing this for all the pixels creates the random
    map you can also see in the bottom-left corner of the previous screenshot. This
    map can then be easily used as a bump map. Here''s how the random map can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we've rendered Perlin noise using an HTML canvas element. Three.js
    also provides an alternative way to dynamically create a texture. The `THREE.ImageUtils`
    object has a `generateDataTexture` function, which you can use to create a `THREE.DataTexture`
    texture of a specific size. This texture contains `Uint8Array` in the `image.data`
    property, which you can use to directly set the RGB values of this texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final input we use for the texture is another HTML element: the HTML5 video
    element.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the output from a video as a texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve read the previous paragraph on rendering to canvas, you might have
    thought about rendering video to canvas and using that as input for a texture.
    That is an option, but Three.js (through WebGL) already has direct support to
    use the HTML5 video element. Check out `11-video-texture.html`. Refer to the following
    screenshot for a still image of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the output from a video as a texture](img/2215OS_10_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Using video as input for a texture is, just like using the canvas element,
    very easy. First off, we need to have a video element to play the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This was just a basic HTML5 video element that we set to automatically play.
    Next, we can configure Three.js to use this video as an input for a texture, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Since our video isn''t square, we need to make sure we disable the mipmap generation
    on the material. We also set some simple high-performance filters as the material
    changes very often. All that is left to do now is create a mesh and set the texture.
    In this example, we''ve used `MeshFaceMaterial` together with `MeshBasicMaterial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do is make sure that in our `render` loop, we update the
    texture, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we just rendered the video to one side of the cube, but since
    this is a normal texture, we could do anything we want with it. We could, for
    instance, divide it along the sides of a cube using custom UV mapping, or we could
    even use video input as input for a bump map or a normal map.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Three.js version r69, a texture specifically for dealing with videos was
    introduced. This texture (`THREE.VideoTexture`) wraps the code you''ve seen in
    this section, and you can use the `THREE.VideoTexture` approach as an alternative.
    The following code fragment shows how to use `THREE.VideoTexture` to create a
    texture (you can see this in action by looking at the `11-video-texture.html`
    example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: And so we end this chapter on textures. As you've seen, there are lots of different
    kinds of textures available in Three.js, each with their different uses. You can
    use any image in the PNG, JPG, GIF, TGA, DDS, or PVR format as a texture. Loading
    these images is done asynchronously, so remember to either use a rendering loop
    or add a callback when you load the texture. With textures, you can create great-looking
    objects from low-poly models and even add fake detailed depth using bump maps
    and normal maps. With Three.js, it is also easy to create dynamic textures using
    either the HTML5 canvas element or the video element. Just define a texture with
    these elements as the input and set the `needsUpdate` property to `true` whenever
    you want the texture to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: With this chapter out of the way, we've pretty much covered all the important
    concepts of Three.js. We haven't, however, looked at an interesting feature Three.js
    offers—**postprocessing**. With postprocessing, you can add effects to your scene
    after it is rendered. You could, for instance, blur or colorize your scene or
    add a TV-like effect using scan lines. In the next chapter, we'll look at postprocessing
    and how you can apply it to your scene.
  prefs: []
  type: TYPE_NORMAL
