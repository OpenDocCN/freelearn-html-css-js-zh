- en: Chapter 4. Working with Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：处理集合
- en: The purpose of the Backbone collection is pretty straightforward. As an ordered
    set of models, a collection provides a number of useful methods to play around
    with, including a set of Underscore.js utility methods. A collection includes
    functionality to add, remove, sort, and filter models, and save to or fetch data
    from the server. A collection listens to the events fired on its models–if an
    event is fired on a model of a collection, it will also be fired on the collection
    itself. This facility is quite significant when you want to listen to an attribute-change
    event of the model. We will look into it using some examples in the *Basic usage
    of collections* section of this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Backbone 集合的目的非常直接。作为一个有序的模型集合，集合提供了一系列有用的方法来操作，包括一组 Underscore.js 工具方法。集合包括添加、删除、排序和过滤模型的功能，以及保存到或从服务器获取数据。集合监听其模型上触发的事件——如果集合的模型上触发了一个事件，它也会在集合本身上触发。当你想监听模型的属性更改事件时，这个功能相当重要。我们将通过本章的
    *集合的基本用法* 部分中的示例来探讨它。
- en: 'In the previous chapters, we saw a number of implementations of a simple collection
    to display multiple items in a list view. However, there can be cases where you
    want to sort the list with a number of criteria or you want to filter the list
    items to show only a particular type. In such cases, you have to either alter
    the collection to restructure the model positions or get the data that matches
    the filter condition. Let us look into what we will learn in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了许多简单集合的实现，用于在列表视图中显示多个项目。然而，可能存在你想要根据多个标准对列表进行排序或你想要过滤列表项以仅显示特定类型的情况。在这种情况下，你必须修改集合以重新结构化模型位置或获取符合过滤条件的数据。让我们看看在本章中我们将学习什么：
- en: '**Basic usage of collections**: Understanding the basic use of the Backbone
    collection and data operations with collections'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合的基本用法**：理解 Backbone 集合的基本用法以及与集合的数据操作'
- en: '**Sorting collection**: Basic and multiple sorting of a collection'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**排序集合**：集合的基本和多重排序'
- en: '**Filtering collection**: Performing basic filtering, avoiding re-filtering
    a filtered collection with duplicate collection, and filtering with full data
    pointers'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤集合**：执行基本过滤，避免使用重复的集合重新过滤，以及使用完整数据指针进行过滤'
- en: '**Collection with multiple model types**: Managing a collection when a mixed
    set of data is passed from the server and each type belongs to separate models'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含多种模型类型的集合**：当从服务器传递混合数据集且每种类型属于不同的模型时管理集合'
- en: Basic usage of collections
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合的基本用法
- en: We will start looking into different features of the `Backbone` collection with
    a simple example. Let's assume we have a `User` model and a `Users` collection.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个简单的示例开始研究 `Backbone` 集合的不同特性。假设我们有一个 `User` 模型和 `Users` 集合。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, simple model and collection definitions have been described.
    Here, we tried to demonstrate, as we mentioned in the introduction of this chapter,
    that any event fired on a model will get fired on the collection too. When you
    run this code, the model-change handler is run first, then followed by the collection
    change-event handler.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，已经描述了简单的模型和集合定义。在这里，我们试图证明，正如我们在本章引言中提到的，任何在模型上触发的事件也会在集合上触发。当你运行此代码时，模型更改处理程序首先运行，然后是集合更改事件处理程序。
- en: The `Backbone` collection provides a huge set of methods along with a number
    of `Underscore` utility methods to work on it. Because a collection deals with
    multiple data, you will find the `Underscore` utility methods are very useful
    to operate on it. Discussing all these methods and their functionality is beyond
    the scope of this book, but we are going to see how to use the `fetch()` and `save()`
    methods to retrieve data from and save data to the server using an AJAX request
    in the next section.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`Backbone` 集合提供了一组丰富的方法，以及一系列 `Underscore` 工具方法来操作它。由于集合处理多个数据，你会发现 `Underscore`
    工具方法在操作它时非常有用。讨论所有这些方法和它们的函数性超出了本书的范围，但我们将看到如何使用 `fetch()` 和 `save()` 方法通过 AJAX
    请求从服务器检索数据并将数据保存到服务器，在下一节中。'
- en: Performing data operations with collections
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用集合执行数据操作
- en: You can use AJAX requests to save and fetch data to and from the server. The
    result then needs to be applied on the collection. However, Backbone simplifies
    the complete process by providing a few methods such as `fetch()` and `save()`
    to directly interact with the server. We will use the same collection that we
    used in the previous section to demonstrate how we can perform all data operations
    with collections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用AJAX请求将数据保存到服务器并从服务器获取数据。然后需要将结果应用到集合上。然而，Backbone通过提供一些方法，如`fetch()`和`save()`，简化了与服务器直接交互的整个过程。我们将使用之前章节中使用的相同集合来演示如何使用集合执行所有数据操作。
- en: Fetching data from the server
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从服务器获取数据
- en: Fetching data from the server is quite easy. You just call the `fetch()` method
    on the collection as shown in the following code line, and a `GET` request is
    sent to the URL that we added in the collection's configuration. It receives a
    `JSON` array with objects that get added to the collection as models.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器获取数据相当简单。您只需在集合上调用`fetch()`方法，如下面的代码行所示，然后向我们在集合配置中添加的URL发送一个`GET`请求。它接收一个包含对象的`JSON`数组，这些对象被添加到集合中作为模型。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: On receiving the data, the `set()` method of the collection is automatically
    called to update the collection. If a model doesn't exist, it gets added; if the
    model exists already, the latest data gets merged with it; and if the collection
    has a model that is not there in the new data, it gets removed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到数据后，集合的`set()`方法会自动被调用以更新集合。如果不存在模型，则将其添加；如果模型已存在，则最新数据与它合并；如果集合中有一个模型在新数据中不存在，则将其移除。
- en: Saving data to the server
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据保存到服务器
- en: 'Unlike fetching data from the server, collections do not have a method to store
    data as a whole to the server. Instead, the `save()` method of each individual
    model needs to be called as shown in the following code snippet:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与从服务器获取数据不同，集合没有将数据作为一个整体存储到服务器的方法。相反，需要调用每个单独模型的`save()`方法，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `save()` method appends the model's ID to the server's URL (`/users/1`)
    and sends a `PUT` request to that URL. So, to save the complete collection to
    the server, you need to iterate through the collection and call the `save()` method
    on each model individually.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`方法将模型的ID附加到服务器的URL（`/users/1`）并向该URL发送一个`PUT`请求。因此，要将整个集合保存到服务器，你需要遍历集合并对每个模型单独调用`save()`方法。'
- en: Sorting a collection
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对集合进行排序
- en: 'Sorting a collection is fairly easy with Backbone as built-in methods are already
    available for this purpose. To sort a collection, add a `comparator` to the collection,
    which in general, is a function that can take a single model or two consecutive
    models for comparison, or it can be a string that points to an attribute of its
    model. Whenever a model is added to the collection, the comparator sorts the collection
    accordingly. Changing an attribute of a model later doesn''t initiate the sort
    functionality automatically and you need to call the `sort()` method on the collection
    again to re-sort it. Let''s look into a simple example of sorting a collection:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Backbone按多个属性对集合进行排序相当简单，因为已经内置了用于此目的的方法。要对集合进行排序，向集合中添加一个`comparator`，它通常是一个可以接受单个模型或两个连续模型进行比较的函数，或者它可以是指向其模型属性的字符串。每当模型被添加到集合中时，比较器就会相应地排序集合。稍后更改模型的属性不会自动启动排序功能，您需要再次在集合上调用`sort()`方法以重新排序。让我们看看排序集合的一个简单示例：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, the output is a collection sorted by age. Similarly, we can
    implement the alphabetical order with `name` as the comparator. The preceding
    functionality can also be replicated by the following two options:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输出是一个按年龄排序的集合。同样，我们可以通过将`name`作为比较器来实现字母顺序。前述功能也可以通过以下两种选项来复制：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first case is simple; it provides a string attribute to the comparator.
    The second case provides a comparison between two models (`model1` and `model2`).
    If the `age` attribute of `model1` is greater than that of `model2`, `model1`
    and `model2` will interchange their positions to be in ascending order.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况很简单；它向比较器提供了一个字符串属性。第二种情况提供了两个模型（`model1`和`model2`）之间的比较。如果`model1`的`age`属性大于`model2`的`age`属性，则`model1`和`model2`将互换位置以保持升序。
- en: Sorting a collection with multiple attributes
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按多个属性对集合进行排序
- en: 'Note that there are three 29-years-old values in the example mentioned in the
    preceding section. What if we want to sort these models according to the `name`
    attribute too? The string comparison can also be done the same way as we did for
    numbers; the functionality will be simple (see the following example):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前一节提到的示例中，有三个29岁的值。如果我们想根据`name`属性对这些模型进行排序怎么办？字符串比较也可以像我们为数字做的那样进行；功能将是简单的（见以下示例）：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code only sorts the collection by the `name` attribute. If two
    models have the same age values, the result will look like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码仅按`name`属性对集合进行排序。如果有两个模型的年龄值相同，结果将如下所示：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A `sort` event is always fired when there is a comparator present in the collection
    and you add some data to it. It also gets fired when you specifically call the
    `sort()` method on the collection.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当集合中存在比较器并且向其中添加数据时，总会触发一个`sort`事件。当你专门在集合上调用`sort()`方法时，它也会被触发。
- en: Filtering a collection
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤集合
- en: Filtering a collection is a fairly simple concept; here we want to get a part
    of the data based on a certain criteria. For example, if you have a list of items
    and you want to filter the list to only show a subset of all the items, you filter
    the attached collection. By default, Backbone provides some built-in functions
    that take care of basic filtering. The two methods `where()` and `findWhere()`
    produce similar functionality, though `findWhere()` only returns the first model
    that matches the condition.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤集合是一个相当简单的概念；在这里，我们希望根据某些标准获取数据的一部分。例如，如果你有一个项目列表，并且你只想显示所有项目的一个子集，你可以过滤附加的集合。默认情况下，Backbone提供了一些内置函数来处理基本过滤。`where()`和`findWhere()`方法产生类似的功能，尽管`findWhere()`只返回第一个符合条件的数据模型。
- en: Performing basic filtering
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行基本过滤
- en: The `where()` method accepts a set of model attributes and returns an array
    of the matched models.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`where()`方法接受一组模型属性并返回匹配的模型数组。'
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result will be an array of two models that have `A` as their company. However,
    note that filtering the collection does not change the original collection data
    at all; instead, it just returns an array with the results. If there is a Backbone
    view that is displaying the collection data as a list, filtering the collection
    will not have any effect on the list.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个包含两个模型的数组，它们的公司是`A`。然而，请注意，过滤集合并不会改变原始集合数据；相反，它只是返回一个包含结果的数组。如果有一个Backbone视图正在将集合数据作为列表显示，过滤集合对列表没有任何影响。
- en: 'So, how are we going to resolve this? One simple task can be done—let''s reset
    the collection with the filtered data and re-render the list. The following code
    will work fine and the collection will only have the filtered data with it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何解决这个问题呢？一个简单的任务可以是——让我们用过滤后的数据重置集合并重新渲染列表。以下代码将正常工作，并且集合将只包含过滤后的数据：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if you re-render the list, it will only show the filtered data. This looks
    fine; however, if you want to re-filter the collection, it will not be applied
    on the complete collection of data but on the previously filtered data. This is
    wrong; it is advisable to avoid such patterns that may lead to severe problems
    in a later stage. When you filter a collection only once, there should not be
    any problem, but multiple filtering of the collection will surely cause problems
    if the same collection is used elsewhere too. The following code, for example,
    will return zero results for the same reason:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你重新渲染列表，它将只显示过滤后的数据。这看起来不错；然而，如果你想要重新过滤集合，它将不会应用于完整的数据集合，而是应用于之前过滤的数据。这是错误的；建议避免可能导致后期严重问题的模式。当你只过滤一次集合时，不应该有任何问题，但如果相同的集合在其他地方也被使用，多次过滤集合肯定会引起问题。例如，以下代码将因为相同的原因返回零结果：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let's attempt a few options to find a solution to this problem. We will first
    try this using a duplicate collection.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一些选项来找到这个问题的解决方案。我们首先尝试使用重复集合。
- en: Filtering a collection with a duplicate collection
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用重复集合过滤集合
- en: There are multiple solutions to the problem we found in the preceding section.
    For example, we can create another collection instance whenever a collection is
    filtered and we always reset this second collection with the filtered data. That
    way, the main collection will not be altered and passing the second collection
    to the view instance will produce the desired result.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上一节中我们发现的问题，存在多种解决方案。例如，每当集合被过滤时，我们可以创建另一个集合实例，并且始终用过滤后的数据重置这个第二个集合。这样，主集合就不会被改变，将第二个集合传递给视图实例将产生期望的结果。
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This time, the original collection holds its state and the new filtered collection
    provides the necessary functionality. This process can become quite beneficial
    for displaying a filtered set of data. The main disadvantage of this process is
    that you need to create another new instance of the collection in order to filter
    it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，原始集合保持其状态，而新的过滤集合提供了必要的功能。这个过程对于显示过滤后的数据集可以非常有益。这个过程的主要缺点是，你需要创建集合的另一个新实例来过滤它。
- en: Self-filtering with full data pointers
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用完整数据指针的自过滤
- en: 'The disadvantage of multiple filtering can also be eliminated by keeping a
    reference to the complete dataset before applying filters. If we can save the
    initial data in a property inside the collection itself and then apply a filter
    on it, the collection data gets changed but the raw data is still available. Therefore,
    if we need to re-apply another filter on the collection, we can first reset it
    with the total data and then apply the new filter. To understand the concept with
    an example, we will define a custom `FilterCollection` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用过滤器之前保留完整数据集的引用也可以消除多次过滤的缺点。如果我们能在集合本身的一个属性中保存初始数据，然后对其应用过滤器，集合数据会发生变化，但原始数据仍然可用。因此，如果我们需要重新在集合上应用另一个过滤器，我们可以首先使用全部数据重置它，然后应用新的过滤器。为了通过示例理解这个概念，我们将定义一个自定义的`FilterCollection`类：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We create a custom `Collection` class that has a `_totalData` property, which
    is supposed to hold the complete data of that collection. In the `initialize`
    method, we check whether any data has been passed to the collection; if it has
    been passed, we save that data in this variable. We also include an `add` event
    listener so that the newly added data gets reflected.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个自定义的`Collection`类，它有一个`_totalData`属性，这个属性应该包含该集合的全部数据。在`initialize`方法中，我们检查是否已向集合传递了任何数据；如果有，我们将该数据保存到这个变量中。我们还包括一个`add`事件监听器，以便新添加的数据能够得到反映。
- en: 'Now, once you call the `applyFilter()` method on the collection, it first resets
    the collection with full data and then applies the filter on this collection.
    That way, each time you filter the collection with this method, you do not need
    to worry about whether it is being applied to the previously filtered collection
    or not. Let''s analyze the functionality with a test case:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦你在集合上调用`applyFilter()`方法，它首先使用全部数据重置集合，然后在这个集合上应用过滤器。这样，每次你使用这个方法过滤集合时，你都不必担心它是否被应用到之前过滤过的集合上。让我们通过一个测试用例来分析这个功能：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Earlier, after second-time filtering, you received only one set of data because
    the collection had been filtered twice and the returned model had the name `John`
    and the company `A`. But now, because the collection is refreshed before every
    filtering, you will get a proper result.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，在第二次过滤后，你只收到一组数据，因为集合已被过滤两次，返回的模型名称为`John`和公司`A`。但现在，因为每次过滤之前集合都会被刷新，所以你会得到正确的结果。
- en: The preceding code is not ready for production, and you need to make it more
    sophisticated so that `_totalData` should always have the latest data. Anyhow,
    the pattern comes useful in certain cases, and keeping a filterable collection
    extension or a `Filterable` mixin ready can get you an immediate solution.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码尚未准备好投入生产，你需要使其更加复杂，以便`_totalData`始终包含最新的数据。无论如何，这种模式在某些情况下很有用，保持一个可过滤的集合扩展或`Filterable`混入可以立即解决问题。
- en: Understanding the collection of multiple model types
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多模型类型集合
- en: 'There are cases when we have a mixed set of data coming from the server and
    we need to put the complete data in a single collection. For example, assume that
    the server is sending the complete employee details of a company. Now, there are
    different types of employees—developers, managers, designers, and so on, and you
    want to have different model types for each of these. How is the collection supposed
    to hold all types of models together? Here is an example with which you can get
    the desired functionality:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们从服务器接收到的数据是混合的，我们需要将完整的数据放入单个集合中。例如，假设服务器正在发送一家公司的完整员工详细信息。现在，有不同类型的员工——开发者、经理、设计师等等，你希望为这些中的每一个都有不同的模型类型。集合应该如何将所有类型的模型放在一起？以下是一个可以让你获得所需功能的例子：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The model that a collection asks for is either the model itself, an instance
    of it that is created every time data is added to the collection, or can hold
    a function to which data attributes are passed to and you can check for the related
    model according to the data and pass an instance of it. Here, in the preceding
    example, we did the same thing and returned separate models depending on the type
    of data attribute.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 集合请求的模型要么是模型本身，要么是每次向集合添加数据时创建的该模型的实例，或者可以包含一个函数，数据属性会被传递给它，你可以根据数据检查相关模型并传递其一个实例。在这里，在前面的例子中，我们做了同样的事情，根据数据属性的类型返回了不同的模型。
- en: Summary
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Working with collections is a basic requirement of Backbone, and the questions
    associated with a collection are related to the models too. For example, the most
    common issue that almost every developer faces is nested collections, and the
    solution to the problem is related to how the data is parsed inside the model
    itself. We discussed the relational data plugin in [Chapter 3](ch03.html "Chapter 3. Working
    with Models"), *Working with Models*, that wonderfully solves the problem with
    nested models and collections. It is highly recommended to use this plugin for
    any such data relationships.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与集合一起工作是 Backbone 的基本要求，与集合相关的问题也与模型相关。例如，几乎每个开发者都会遇到的最常见问题是嵌套集合，而解决这个问题与模型内部数据解析的方式有关。我们在[第
    3 章](ch03.html "第 3 章。与模型一起工作")*与模型一起工作*中讨论了关系数据插件，它巧妙地解决了嵌套模型和集合的问题。强烈建议在处理任何此类数据关系时使用此插件。
- en: This chapter discussed how we can sort and filter collections. Simple sorting
    and multiple sorting processes were described with examples. We also saw a number
    of methods for filtering a collection, which can be useful in different situations.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了如何对集合进行排序和过滤。通过示例描述了简单的排序和多个排序过程。我们还看到了一些过滤集合的方法，这些方法在不同情况下可能很有用。
- en: A collection can hold different types of model data inside—the solution to which
    was described with an example. In general, any dataset needs a handful of utility
    methods to work with. A large set of Underscore.js utility methods made it much
    easier for us to work with Backbone collections.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以在内部持有不同类型的模型数据——这个解决方案通过一个例子进行了描述。一般来说，任何数据集都需要一些实用方法来处理。大量 Underscore.js
    实用方法使得我们处理 Backbone 集合变得更加容易。
- en: In the next chapter, we are going to discuss the necessities of Backbone routers
    and why the use of multiple subrouters is beneficial for uncomplex applications.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 Backbone 路由器的必要性以及为什么在简单应用中使用多个子路由器是有益的。
