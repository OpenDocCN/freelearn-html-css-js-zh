- en: Chapter 4. Working with Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of the Backbone collection is pretty straightforward. As an ordered
    set of models, a collection provides a number of useful methods to play around
    with, including a set of Underscore.js utility methods. A collection includes
    functionality to add, remove, sort, and filter models, and save to or fetch data
    from the server. A collection listens to the events fired on its models–if an
    event is fired on a model of a collection, it will also be fired on the collection
    itself. This facility is quite significant when you want to listen to an attribute-change
    event of the model. We will look into it using some examples in the *Basic usage
    of collections* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapters, we saw a number of implementations of a simple collection
    to display multiple items in a list view. However, there can be cases where you
    want to sort the list with a number of criteria or you want to filter the list
    items to show only a particular type. In such cases, you have to either alter
    the collection to restructure the model positions or get the data that matches
    the filter condition. Let us look into what we will learn in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basic usage of collections**: Understanding the basic use of the Backbone
    collection and data operations with collections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting collection**: Basic and multiple sorting of a collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering collection**: Performing basic filtering, avoiding re-filtering
    a filtered collection with duplicate collection, and filtering with full data
    pointers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collection with multiple model types**: Managing a collection when a mixed
    set of data is passed from the server and each type belongs to separate models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic usage of collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start looking into different features of the `Backbone` collection with
    a simple example. Let's assume we have a `User` model and a `Users` collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, simple model and collection definitions have been described.
    Here, we tried to demonstrate, as we mentioned in the introduction of this chapter,
    that any event fired on a model will get fired on the collection too. When you
    run this code, the model-change handler is run first, then followed by the collection
    change-event handler.
  prefs: []
  type: TYPE_NORMAL
- en: The `Backbone` collection provides a huge set of methods along with a number
    of `Underscore` utility methods to work on it. Because a collection deals with
    multiple data, you will find the `Underscore` utility methods are very useful
    to operate on it. Discussing all these methods and their functionality is beyond
    the scope of this book, but we are going to see how to use the `fetch()` and `save()`
    methods to retrieve data from and save data to the server using an AJAX request
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Performing data operations with collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use AJAX requests to save and fetch data to and from the server. The
    result then needs to be applied on the collection. However, Backbone simplifies
    the complete process by providing a few methods such as `fetch()` and `save()`
    to directly interact with the server. We will use the same collection that we
    used in the previous section to demonstrate how we can perform all data operations
    with collections.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching data from the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fetching data from the server is quite easy. You just call the `fetch()` method
    on the collection as shown in the following code line, and a `GET` request is
    sent to the URL that we added in the collection's configuration. It receives a
    `JSON` array with objects that get added to the collection as models.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: On receiving the data, the `set()` method of the collection is automatically
    called to update the collection. If a model doesn't exist, it gets added; if the
    model exists already, the latest data gets merged with it; and if the collection
    has a model that is not there in the new data, it gets removed.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data to the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike fetching data from the server, collections do not have a method to store
    data as a whole to the server. Instead, the `save()` method of each individual
    model needs to be called as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `save()` method appends the model's ID to the server's URL (`/users/1`)
    and sends a `PUT` request to that URL. So, to save the complete collection to
    the server, you need to iterate through the collection and call the `save()` method
    on each model individually.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sorting a collection is fairly easy with Backbone as built-in methods are already
    available for this purpose. To sort a collection, add a `comparator` to the collection,
    which in general, is a function that can take a single model or two consecutive
    models for comparison, or it can be a string that points to an attribute of its
    model. Whenever a model is added to the collection, the comparator sorts the collection
    accordingly. Changing an attribute of a model later doesn''t initiate the sort
    functionality automatically and you need to call the `sort()` method on the collection
    again to re-sort it. Let''s look into a simple example of sorting a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the output is a collection sorted by age. Similarly, we can
    implement the alphabetical order with `name` as the comparator. The preceding
    functionality can also be replicated by the following two options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first case is simple; it provides a string attribute to the comparator.
    The second case provides a comparison between two models (`model1` and `model2`).
    If the `age` attribute of `model1` is greater than that of `model2`, `model1`
    and `model2` will interchange their positions to be in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting a collection with multiple attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note that there are three 29-years-old values in the example mentioned in the
    preceding section. What if we want to sort these models according to the `name`
    attribute too? The string comparison can also be done the same way as we did for
    numbers; the functionality will be simple (see the following example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code only sorts the collection by the `name` attribute. If two
    models have the same age values, the result will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A `sort` event is always fired when there is a comparator present in the collection
    and you add some data to it. It also gets fired when you specifically call the
    `sort()` method on the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Filtering a collection is a fairly simple concept; here we want to get a part
    of the data based on a certain criteria. For example, if you have a list of items
    and you want to filter the list to only show a subset of all the items, you filter
    the attached collection. By default, Backbone provides some built-in functions
    that take care of basic filtering. The two methods `where()` and `findWhere()`
    produce similar functionality, though `findWhere()` only returns the first model
    that matches the condition.
  prefs: []
  type: TYPE_NORMAL
- en: Performing basic filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `where()` method accepts a set of model attributes and returns an array
    of the matched models.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The result will be an array of two models that have `A` as their company. However,
    note that filtering the collection does not change the original collection data
    at all; instead, it just returns an array with the results. If there is a Backbone
    view that is displaying the collection data as a list, filtering the collection
    will not have any effect on the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how are we going to resolve this? One simple task can be done—let''s reset
    the collection with the filtered data and re-render the list. The following code
    will work fine and the collection will only have the filtered data with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you re-render the list, it will only show the filtered data. This looks
    fine; however, if you want to re-filter the collection, it will not be applied
    on the complete collection of data but on the previously filtered data. This is
    wrong; it is advisable to avoid such patterns that may lead to severe problems
    in a later stage. When you filter a collection only once, there should not be
    any problem, but multiple filtering of the collection will surely cause problems
    if the same collection is used elsewhere too. The following code, for example,
    will return zero results for the same reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's attempt a few options to find a solution to this problem. We will first
    try this using a duplicate collection.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering a collection with a duplicate collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple solutions to the problem we found in the preceding section.
    For example, we can create another collection instance whenever a collection is
    filtered and we always reset this second collection with the filtered data. That
    way, the main collection will not be altered and passing the second collection
    to the view instance will produce the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This time, the original collection holds its state and the new filtered collection
    provides the necessary functionality. This process can become quite beneficial
    for displaying a filtered set of data. The main disadvantage of this process is
    that you need to create another new instance of the collection in order to filter
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Self-filtering with full data pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The disadvantage of multiple filtering can also be eliminated by keeping a
    reference to the complete dataset before applying filters. If we can save the
    initial data in a property inside the collection itself and then apply a filter
    on it, the collection data gets changed but the raw data is still available. Therefore,
    if we need to re-apply another filter on the collection, we can first reset it
    with the total data and then apply the new filter. To understand the concept with
    an example, we will define a custom `FilterCollection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We create a custom `Collection` class that has a `_totalData` property, which
    is supposed to hold the complete data of that collection. In the `initialize`
    method, we check whether any data has been passed to the collection; if it has
    been passed, we save that data in this variable. We also include an `add` event
    listener so that the newly added data gets reflected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once you call the `applyFilter()` method on the collection, it first resets
    the collection with full data and then applies the filter on this collection.
    That way, each time you filter the collection with this method, you do not need
    to worry about whether it is being applied to the previously filtered collection
    or not. Let''s analyze the functionality with a test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Earlier, after second-time filtering, you received only one set of data because
    the collection had been filtered twice and the returned model had the name `John`
    and the company `A`. But now, because the collection is refreshed before every
    filtering, you will get a proper result.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code is not ready for production, and you need to make it more
    sophisticated so that `_totalData` should always have the latest data. Anyhow,
    the pattern comes useful in certain cases, and keeping a filterable collection
    extension or a `Filterable` mixin ready can get you an immediate solution.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the collection of multiple model types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are cases when we have a mixed set of data coming from the server and
    we need to put the complete data in a single collection. For example, assume that
    the server is sending the complete employee details of a company. Now, there are
    different types of employees—developers, managers, designers, and so on, and you
    want to have different model types for each of these. How is the collection supposed
    to hold all types of models together? Here is an example with which you can get
    the desired functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The model that a collection asks for is either the model itself, an instance
    of it that is created every time data is added to the collection, or can hold
    a function to which data attributes are passed to and you can check for the related
    model according to the data and pass an instance of it. Here, in the preceding
    example, we did the same thing and returned separate models depending on the type
    of data attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with collections is a basic requirement of Backbone, and the questions
    associated with a collection are related to the models too. For example, the most
    common issue that almost every developer faces is nested collections, and the
    solution to the problem is related to how the data is parsed inside the model
    itself. We discussed the relational data plugin in [Chapter 3](ch03.html "Chapter 3. Working
    with Models"), *Working with Models*, that wonderfully solves the problem with
    nested models and collections. It is highly recommended to use this plugin for
    any such data relationships.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discussed how we can sort and filter collections. Simple sorting
    and multiple sorting processes were described with examples. We also saw a number
    of methods for filtering a collection, which can be useful in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: A collection can hold different types of model data inside—the solution to which
    was described with an example. In general, any dataset needs a handful of utility
    methods to work with. A large set of Underscore.js utility methods made it much
    easier for us to work with Backbone collections.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss the necessities of Backbone routers
    and why the use of multiple subrouters is beneficial for uncomplex applications.
  prefs: []
  type: TYPE_NORMAL
