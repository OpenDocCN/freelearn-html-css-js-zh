<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Create Collisions on Objects</h1></div></div></div><p>The previous chapters introduced the 3D programming basics and Babylon.js. You can easily create and customize your scenes using the materials and meshes provided by your designer as you now understand the complete workflow.</p><p>In this chapter, let's play with the gameplay itself and create interactions with objects in the scene by creating collisions and physics simulations. Collisions are important to add realism to your scenes if you want to walk without crossing the walls. Moreover, to make the scenes more alive, let's introduce the physics simulation with Babylon.js and finally, see how easy it is to integrate these two notions in your scenes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Checking collisions in a scene</li><li class="listitem" style="list-style-type: disc">Simulatating physics</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec22"/>Checking collisions in a scene</h1></div></div></div><p>Starting from the concept, configuring and checking collisions in a scene can be done without mathematical notations. We all have the notion of gravity and ellipsoid, even if the <em>ellipsoid</em> word is not necessarily familiar.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec37"/>How collisions work in Babylon.js?</h2></div></div></div><p>Let's start with the following scene (a camera, light, plane, and box):</p><p>
</p><div><img src="img/image_05_001-1024x496.png" alt="How collisions work in Babylon.js?"/></div><p>
</p><p>The goal is to prevent the currently active camera of the scene from crossing the objects in the scene. In other words, we want the camera to stay above the plane and stop moving forward if it collides with the box.</p><p>To perform these actions, the collisions system provided by Babylon.js uses a <strong>collider</strong>. A collider can be represented by the <code class="literal">bounding box</code> of a simple object and it looks similar to the following image:</p><p>
</p><div><img src="img/image_05_002-1024x492.png" alt="How collisions work in Babylon.js?"/></div><p>
</p><p>For information, a bounding box simply represents the minimum and maximum positions of a mesh's vertices and it is computed automatically by Babylon.js.</p><p>As explained in <a class="link" href="ch03.html" title="Chapter 3. Create, Load, and Draw 3D Objects on the Screen">Chapter 3</a>, <em>Create, Load, and Draw 3D Objects on the Screen</em>, the meshes are composed of vertices that are linked together using the index buffer to finally build triangles; to be precise, the collisions are based on these triangles and are automatically managed/computed by Babylon.js. This means that you have to do nothing that is particularly tricky to configure collisions with objects.</p><p>To resume, all the collisions are based on the triangles of each mesh in order to determine whether the camera should be blocked or not.</p><div><div><h3 class="title"><a id="note6"/>Note</h3><p>You'll also see that the physics engines use the same kind of collider to simulate physics for simple meshes (bounding boxes).</p></div></div><p>In this case, the complicated part is for the designer. They must optimize all their meshes to work well with the collisions. This means that they must split the big meshes into multiple or submeshes thanks to their 3D modeler.</p><p>In fact, when rendering the scene, the collision system of Babylon.js will test whether the collisions should be tested for each mesh in the scene according to the global position of the camera. This is how 3D engines tend to optimize collisions as the main problem is that the collisions are computed in the CPU side.</p><p>For example, some 3D engines offer a way to configure collisions on meshes by giving a particular type of collision; even if the mesh is complex, you can choose whether you want to use a bounding box as collider (to save the CPU performances) or directly use the triangles of the mesh (realistic collisions).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Configuring collisions in a scene</h2></div></div></div><p>Let's practice with the Babylon.js collisions engine itself. You'll see that the engine is particularly well-hidden as you only have to enable checks on the scene and objects.</p><p>Firstly, configure the scene in order to enable the collisions and then wake the engine up. If the following property is <code class="literal">false</code>, all the next properties will be ignored by Babylon.js and the collisions engine will be in the <em>stand by</em> mode. Then, it's easy to enable or disable the collisions in a scene without modifying more properties, as follows:</p><pre class="programlisting">scene.collisionsEnabled = true; // Enable collisions in scene</pre><p>Next, configure the camera to check the collisions. The collisions engine will check collisions for all the rendered cameras that have collisions enabled. Here, we have only one camera to configure:</p><pre class="programlisting">camera.checkCollisions = true; // Check collisions for THIS camera</pre><p>To finish, set the <code class="literal">.checkCollisions </code>property of each mesh to <code class="literal">true</code> to activate collisions (here, the plane and box), as shown in the following:</p><pre class="programlisting">plane.checkCollisions = true;&#13;
box.checkCollisions = true;</pre><p>Now, the collisions engine will check the collisions in the scene for the camera on both plane and box meshes.</p><p>You guessed right , if you want to enable collisions only on the plane and want the camera to move across the box, you'll have to set the <code class="literal">.checkCollisions</code> property of the box to <code class="literal">false</code>, as follows:</p><pre class="programlisting">plane.checkCollisions = true;&#13;
box.checkCollisions = false;</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec39"/>Configure gravity and ellipsoid</h2></div></div></div><p>
<strong>Gravity</strong>
</p><p>In the previous section, the camera checks the collision on the plane and the box; however, this is not submitted to a famous force named <strong>the gravity</strong>. To enrich the collisions in your scene, you can apply the gravity force, for example, to go down from the stairs.</p><p>First, enable the gravity on the camera by setting the <code class="literal">.applyGravity</code> property to <code class="literal">true</code>, as shown in the following:</p><pre class="programlisting">camera.applyGravity = true; // Enable gravity on the camera</pre><p>Finally, customize the gravity direction by setting <code class="literal">BABYLON.Vector3</code> to the <code class="literal">.gravity</code> property of your scene, as follows:</p><pre class="programlisting">scene.gravity = new BABYLON.Vector3(0.0, -9.81, 0.0); // To stay on earth</pre><p>Of course, the gravity in space should be as shown in the following:</p><pre class="programlisting">scene.gravity = BABYLON.Vector3.Zero(); // No gravity in space</pre><p>Don't hesitate to play with the values in order to adjust the gravity to your scene referential.</p><p>
<strong>Ellipsoid</strong>
</p><p>The last parameter to enrich the collisions in your scene is the camera's ellipsoid. The ellipsoid represents the camera's dimensions in the scene. In other words, it adjusts the collisions according to the x, y, and z axes of the ellipsoid (an ellipsoid is represented by <code class="literal">BABYLON.Vector3</code>).</p><p>For example, the camera must measure 1.8 m (y axis) and the minimum distance to collide with the x (sides) and z (forward) axes must be 1 m. Then, the ellipsoid must be (<code class="literal">x = 1</code>, <code class="literal">y = 1.8</code>, and <code class="literal">z = 1</code>). Simply, set the  <code class="literal">.ellipsoid</code> property of the camera, as follows:</p><pre class="programlisting">camera.ellipsoid = new BABYLON.Vector3(1, 1.8, 1);</pre><div><div><h3 class="title"><a id="note7"/>Note</h3><p>The default value of the camera's ellipsoids is (<code class="literal">x = 0.5</code>, <code class="literal">y = 1.0</code>, and <code class="literal">z = 0.5</code>)</p></div></div><p>As for the gravity, don't hesitate to adjust the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> according to your scene scale.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec23"/>Simulate physics</h1></div></div></div><p>Physics simulation is pretty different from the collisions system since it does not occur on the cameras but on the objects of the scene itself. In other words, if physics is enabled (and configured) on a box, the box will interact with other meshes in the scene and try to represent the real physical movements.</p><p>For example, let's take a sphere in the air. If you apply physics to the sphere, the sphere will fall until it collides with another mesh and according to the given parameters, it will bounce and roll in the scene.</p><div><div><h3 class="title"><a id="note8"/>Note</h3><p>The example files reproduce the behavior of a sphere that falls on the box in the middle of the scene.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec40"/>Enable physics in Babylon.js</h2></div></div></div><p>In Babylon.js, physics simulations can be only done using plugins. Two plugins are available for use: the Cannon.js framework and the Oimo.js framework. These two frameworks are included in the Babylon.js GitHub repository in the <code class="literal">dist</code> folder.</p><p>Each scene has its own physics simulations system and can be enabled by the following lines:</p><pre class="programlisting">var gravity = new BABYLON.Vector3(0, -9.81, 0);&#13;
scene.enablePhysics(gravity, new BABYLON.OimoJSPlugin());&#13;
// or&#13;
scene.enablePhysics(gravity, new BABYLON.CannonJSPlugin());</pre><p>The  <code class="literal">.enablePhysics(gravity, plugin)</code> function takes the following two arguments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The gravity force of the scene to apply on objects</li><li class="listitem" style="list-style-type: disc">The plugin to use:
<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Oimo.js: <code class="literal">new BABYLON.OimoJSPlugin()</code></li><li class="listitem" style="list-style-type: disc">Cannon.js: <code class="literal">new BABYLON.CannonJSPlugin()</code></li></ul></div></li></ul></div><p>To disable physics in a scene, simply call the <code class="literal">.disablePhysicsEngine()</code> function, as follows: </p><pre class="programlisting">scene.disablePhysicsEngine();</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec41"/>Impostors</h2></div></div></div><p>Once the physics simulations are enabled in a scene, you can configure the physics properties (or physics states) of the scene meshes. To configure the physics properties of a mesh, the <code class="literal">BABYLON.Mesh</code> class provides a <code class="literal">setPhysicsState(impostor, options)</code> function.</p><p>The parameters are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">impostor</code>: Each kind of mesh has its own impostor according to its form. For example, a box will tend to slip while a sphere will roll. There are several types of impostors.</li><li class="listitem" style="list-style-type: disc"><code class="literal">options</code>: These options define the values used in physics equations. It counts the mass, friction, and restitution.</li></ul></div><p>Let's consider a box named <code class="literal">box</code> with a mass of <code class="literal">1</code> and set its physics properties, as shown in the following snippet:</p><pre class="programlisting">box.setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 1 });</pre><p>That's all, the box is now configured to interact with other configured meshes by following the physics equations. Let's imagine that the box is in the air and will fall until it collides with another configured mesh.</p><p>Now, let's take a sphere named <code class="literal">sphere</code> with a mass of <code class="literal">2</code> and set its physics properties, as shown in the following snippet:</p><pre class="programlisting">sphere.setPhysicsState(BABYLON.PhysicsEngine.SphereImpostor, { mass: 2 });</pre><p>You'll notice that the sphere, which is a particular kind of mesh, has its own impostor (<code class="literal">SphereImpostor</code>). In contrast to the box, the physics equations of the plugin will make the sphere roll, while the box will slip on other meshes.</p><p>According to their masses, if the box and sphere collide, then the sphere will tend to push the box harder .</p><p>The following impostors are available in Babylon.js:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The box impostor: <code class="literal">BABYLON.PhysicsEngine.BoxImpostor</code></li><li class="listitem" style="list-style-type: disc">The sphere impostor: <code class="literal">BABYLON.PhysicsEngine.SphereImpostor</code></li><li class="listitem" style="list-style-type: disc">The plane impostor: <code class="literal">BABYLON.PhysicsEngine.PlaneImpostor</code></li><li class="listitem" style="list-style-type: disc">The cylinder impostor: <code class="literal">BABYLON.PhysicsEngine.CylinderImpostor</code></li></ul></div><div><div><h3 class="title"><a id="note9"/>Note</h3><p>In fact, in Babylon.js, the box, plane, and cylinder impostors are the same according to the Cannon.js and Oimo.js plugins. It exists other kinds of physics bodies that are not yet supported (but maybe soon) in the physics engine of Babylon.js; for example, the soft bodies (such as a flag which is deformed due to the wind) and the liquid bodies (simulating the behavior of an object on a water surface according to its mass and the water's properties, such as clear or watery). Only rigid bodies are supported here at the moment.</p></div></div><p>Regardless of the <code class="literal">impostor</code> parameter, the <code class="literal">options</code> parameter is the same. You can customize the physics state of a mesh by providing the following parameters:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>The mass</strong>: This is the mass of the mesh in the world. The heavier the mesh is, the harder it is to stop its movement.</li><li class="listitem" style="list-style-type: disc"><strong>The friction</strong>: This represents the force opposed to the meshes in contact. In other words, this represents how the mesh is slippery. To give you an order, The value of the friction for the ice is equal to <code class="literal">1.0</code>. We can determine that the friction is in the  <code class="literal">[0, 1]</code> range.</li><li class="listitem" style="list-style-type: disc"><strong>The restitution</strong>: This represents how the mesh will bounce on others. Consider a ping-pong ball and its table; if the table's material is a carpet, the restitution will be small. However, if the table's material is a glass, the restitution will be maximum. A real interval for the restitution is in <code class="literal">[0, 1]</code>.</li></ul></div><p>In the example files, these parameters are set and if you play with them, you'll see that these three parameters are linked together in the physics equations.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec42"/>Applying a force to a mesh</h2></div></div></div><p>At any moment, you can apply a new force or impulse to a configured mesh. Let's take an explosion for example, a box is located at the (<code class="literal">x = 0</code>, <code class="literal">y = 0</code>, and <code class="literal">z = 0</code>) coordinates and an explosion takes place above the box at the  (<code class="literal">x = 0</code>, <code class="literal">y = -5</code>, and <code class="literal">z = 0</code>) coordinates. In real life, the box would be pushed up; this action is possible by calling a <code class="literal">applyImpulse(force, contactPoint)</code> function provided by the <code class="literal">BABYLON.Mesh</code> class.</p><p>Once the mesh is configured with its options and impostor, you can call this function at any moment to apply a force to the object. The parameters for this are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">force</code>: This represents the force in the x, y, and z axes</li><li class="listitem" style="list-style-type: disc"><code class="literal">contact point</code>: This represents the origin of the force located in the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> axes.</li></ul></div><p>For example, the explosion generates a force only on <code class="literal">y</code> (why not?), which is equal to <code class="literal">10</code> (<code class="literal">10</code> is an arbitrary value) and has its origin at the  (<code class="literal">x = 0</code>, <code class="literal">y = -5</code>, and <code class="literal">z = 0</code>) coordinates, as follows:</p><pre class="programlisting">mesh.applyImpulse(new BABYLON.Vector3(0, 10, 0), new BABYLON.Vector3(0, -5, 0));</pre><p>Once the impulse is applied to the mesh (only once), the box is pushed up and it will fall according to its physics parameters (mass, friction, and restitution).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Configuring in Blender and 3ds Max</h1></div></div></div><p>Going back to the 3D software such as Blender and 3ds Max that are used by the artists, it's also possible to configure collisions and physics simulations.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec43"/>Collisions in Blender</h2></div></div></div><p>Starting from this scene, the collisions are easy to configure, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_05_003.png" alt="Collisions in Blender"/></div><p>
</p><p>For <a class="link" href="ch03.html" title="Chapter 3. Create, Load, and Draw 3D Objects on the Screen">Chapter 3</a>, <em>Create, Load, and Draw 3D Objects on the Screen</em>, let's zoom on the Babylon.js properties, as shown in the following image:</p><p>
</p><div><img src="img/image_05_004.png" alt="Collisions in Blender"/></div><p>
</p><p>First, click on the options button (at the top) and for the selected object, which is the cube here, enable the collisions by checking the <strong>Check Collisions</strong> check box. For every mesh, check the checkbox to enable the collisions.</p><p>Now, let's configure the camera in Blender. Select the camera in the scene, click on the camera's options (at the top), and check the <strong>Enable Collisions</strong> and <strong>Apply Gravity</strong> check boxes if you want to apply gravity on your camera, as shown in the following image:</p><p>
</p><div><img src="img/image_05_005.png" alt="Collisions in Blender"/></div><p>
</p><p>To configure the camera's ellipsoid, a <code class="literal">BABYLON.Vector3</code> dialog is available under the two check boxes. You can configure the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> values of the camera's ellipsoid in the same order.</p><p>Finally, if you want to apply gravity to your camera, the last parameter to configure is the scene's gravity. First, click on the scene menu (at the top) and modify the gravity values. In Blender, the <code class="literal">y</code> and <code class="literal">z</code> axes are switched, therefore, the <code class="literal">z</code>-axis of the gravity in Blender corresponds to the <code class="literal">y</code>-axis in Babylon.js, as shown in the following image:</p><p>
</p><div><img src="img/image_05_006.png" alt="Collisions in Blender"/></div><p>
</p><p>You can now export the Blender project and test it; the gravity will be applied and the camera will check the collisions on the cube and plane.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec44"/>Configuring physics simulations in Blender</h2></div></div></div><p>As for the collisions system, you can configure the meshes in Blender in order to simulate physics. You'll find the notions of impostor, mass, friction, and restitution, and all these parameters can be configured in Blender. Once you select a mesh, click on the physics options (at the top) and click on the <strong>Rigid Body</strong> button (only rigid bodies are supported), as shown in the following image:</p><p>
</p><div><img src="img/image_05_007.png" alt="Configuring physics simulations in Blender"/></div><p>
</p><p>Once you click on the button, more options will appear. Some of these options are relative to Blender; however, only some of them will interest us, as shown in the following:</p><p>
</p><div><img src="img/image_05_008.png" alt="Configuring physics simulations in Blender"/></div><p>
</p><p>You'll find the three parameters (options): the mass, friction, and bounciness (bounciness represents the restitution). In Blender, the impostor is called shape and you'll find the same impostors: Box and Sphere.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec45"/>Configuring collisions in 3ds Max</h2></div></div></div><p>As for Blender, you can configure collisions in 3ds Max. To enable collisions on an object, simply open the Babylon properties of the mesh, as shown in the following image:</p><p>
</p><div><img src="img/image_05_009.png" alt="Configuring collisions in 3ds Max"/></div><p>
</p><p>To enable collisions on the mesh, simply check the <strong>Check collisions</strong> check box, as shown in the following image:</p><p>
</p><div><img src="img/image_05_010.png" alt="Configuring collisions in 3ds Max"/></div><p>
</p><p>As for Blender, you have to also configure the camera to check the collisions and apply gravity (or not). As for the mesh, open the Babylon properties of the camera and check the <strong>Check collisions</strong> and <strong>Apply gravity</strong> check boxes. You can also configure the camera's ellipsoid on the <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code> axes in the same order, as shown in the following image:</p><p>
</p><div><img src="img/image_05_011.png" alt="Configuring collisions in 3ds Max"/></div><p>
</p><p>Finally, open the Babylon properties of the 3ds Max scene to configure the gravity if you want to apply gravity to the camera, as follows:</p><p>
</p><div><img src="img/image_05_012.png" alt="Configuring collisions in 3ds Max"/></div><p>
</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec46"/>Configuring physics simulations in 3ds Max</h2></div></div></div><p>In 3ds Max, the physics properties are located in the Babylon mesh properties in contrast to Blender. Simply select a mesh and open the Babylon properties. You'll find the same notions of impostor, mass, friction, and restitution, as shown in the following screenshot:</p><p>
</p><div><img src="img/image_05_013.png" alt="Configuring physics simulations in 3ds Max"/></div><p>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Summary</h1></div></div></div><p>You are now ready to configure the collisions for your scene and simulate physics. Whether by code or by artists, you can understand the pipeline in order to make your scenes more alive. Don't hesitate to manipulate the example files. There are three important functions, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">createScene()</code>: This creates the meshes and materials</li><li class="listitem" style="list-style-type: disc"><code class="literal">createCollisions()</code>: This configures the collisions on scene, camera, and meshes</li><li class="listitem" style="list-style-type: disc"><code class="literal">createPhysics()</code>: This configures the physics properties of meshes and applies impulses</li></ul></div><p>In the next chapter, it's time to make your scenes more alive by adding audio tracks to it. You'll be able to add sounds, spatialized or not, to your scenes whether by code or by artists with the help of the sound support in 3ds Max and Blender.</p></div></body></html>