- en: Chapter 8. Content Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we developed the static data module that consisted
    of emulating the edition of a table from a database. Basically, it was a **Create,
    Read, Update, Delete** (**CRUD**) of a single table with some extra capabilities.
    In this chapter, we are going further in the complexity of managing information
    from a table. Usually, in real-world applications, the tables, the information
    of which we want to manage have relationships with other tables, and we have to
    manage the relationships as well. And this is what this chapter is all about.
    How can we build screens and manage complex information in Ext JS?
  prefs: []
  type: TYPE_NORMAL
- en: 'So in this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing complex information with Ext JS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to handle many-to-many associations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forms with associations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reusing components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing information – films
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Sakila database has four major modules within it: **Inventory**, which
    consists of the films'' information, along with the inventory information (how
    many movies we have in each store available for rental); customer data, which
    consists of customer information; business, which consists of the stores, staff
    and also rental and payment information (this depends on inventory and customer
    data to feed some information); and views, which consists of data we can use for
    reports and charts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, we are only interested in **Inventory**, customer data, and business,
    which contains the core business information of the application. Let''s take a
    look at **Inventory**, which has more tables than the other two:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing information – films](img/0457OT_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'According to the Sakila documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `film` table is a list of all films potentially in stock in the stores.
    The actual in-stock copies of each film are represented in the `inventory` table.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `film` table refers to the `language` table and is referred to by the
    `film_category`, `film_actor`, and `inventory` tables.*'
  prefs: []
  type: TYPE_NORMAL
- en: The `film` table has a many-to-many relationship with the `category` and `actor`
    tables. It has two many-to-one relationships with the `language` table. In the
    last chapter, we have already developed code to manage the `category`, `actor`,
    and `language` tables. Now, we need to manage the relationships between the `film`
    table and these other tables.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS 5 has really nice capabilities to manage associated entities similar
    to the `film` table. We will dive into them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: So let's take a brief look at the screens that we are going to develop in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a screen to list the films we have, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing information – films](img/0457OT_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This screen displays three data grids. The first one is the `film` table, which
    is going to display the list of all **Films**. The second one is the **Film Categories**,
    which represents the many-to-many relationship between the `film` and `category`
    tables. And the third one is the **Film Actors**, which represents the many-to-many
    relationship between the `film` and `actor` tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, if we want to create or edit a film, we will create a FormPanel within
    a window so that we can edit its information, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing information – films](img/0457OT_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the `film` table has a many-to-many association with the `categories` table,
    we also need to handle it within the FormPanel using a different tab. If we want
    to add more categories associated with the film, we can **Search** and add, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing information – films](img/0457OT_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Likewise, the `film` table has also a many-to-many association with the `actor`
    table, so we also need to handle it within the FormPanel. The following screenshot
    exemplifies this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing information – films](img/0457OT_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we want to add more actors associated to the film, we can use **Search and
    Add Actor**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing information – films](img/0457OT_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that we are taking a different approach for each screen. This way we
    can learn more ways of handling these scenarios in Ext JS. By the end of this
    chapter, we will learn to create this complex form and save associated data as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: So now that we have an idea of what we will implement throughout this chapter,
    let's have some fun and get our hands dirty!
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the Film data grid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, let's start with the basics. Whenever we need to implement a complex
    screen, we need to start with the simplest component we can develop. When this
    component is working, we can start incrementing it and add more complex capabilities.
    So first, we need to create a Model to represent the `film` table. In this chapter,
    we are going to use the MVVM approach, so we can dive into capabilities we have
    not covered in previous chapters. Once we have this part of the code working,
    we can work with the relationships between the `category`, `language`, and `actor`
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: The Film Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we are going to create the Model to represent the `film` table. Let's
    not worry about the relationships this table has for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new class named `Packt.view.film.FilmsGrid`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As all Sakila tables have the `last_update` column, we will extend `Packt.model.staticData.Base`
    to avoid declaring this field in every single Model we create that represents
    a Sakila table. The `staticData.Base` class also extends `Packt.model.Base`, which
    contains the `schema` and `proxy` details for our models.
  prefs: []
  type: TYPE_NORMAL
- en: For the fields, we will have the same ones we have in the `film` table.
  prefs: []
  type: TYPE_NORMAL
- en: Films ModelView
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our next step is to create a ModelView that will contain a Store that will
    load the collection of films. Let''s create a Store named `films` (remember that
    the Store name is always the plural of the name of the Model—if you want to follow
    the Sencha naming convention) inside the ViewModel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We need to create a file named `FilmsModel.js` inside the `app/view/film` folder
    and put the preceding code inside the file.
  prefs: []
  type: TYPE_NORMAL
- en: In the `films` Store, we are declaring the `model` as usual (`#1`), and we are
    also declaring `pageSize` as `15` (`#2`), meaning we will use the PagingToolbar
    in the Films data grid, and we will retrieve sets of 15 films per unit time to
    display in the GridPanel.
  prefs: []
  type: TYPE_NORMAL
- en: The `autoLoad` configuration is also set to `true` (`#3`). As the ViewModel
    is created once the View is instantiated, the Store will be loaded once the View
    is created as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'At last, we have a `session` configuration (`#4`). We have not worked with
    sessions so far in this book. When we worked with CRUD in the preceding chapter,
    we used the Store to save the data. In this chapter, we are going to work with
    associated data, and a session can be really helpful when we need to save data
    from different models. The session will be created in the View. Having `session:
    true` declared inside a Store inside the ViewModel links the Store with the session
    of the View. We will discuss how this works later on in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Film data grid (with paging)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the Model and the ViewModel with the Store, we need to create
    `FilmsGrid`, which we can do as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As our application starts to grow, we notice that we use some of the configurations
    in different components. For example, for most of the GridPanels, we use a toolbar
    with the **Add**, **Edit** and **Delete** buttons, or we can use a toolbar with
    the **Add** button and have the **Edit** and **Delete** buttons inside the grid
    as Widget Columns (or Action Columns). As all tables from the Sakila database
    have the `Last Update` column, this column is also common to all the GridPanels
    we use to list information from Sakila tables. For this reason, we can create
    a super GridPanel (as we did specifically for the static data module). So, for
    the Films GridPanel, we will extend from `base.Grid` (`#1`) that we will create
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Having declared the ViewModel already, we can `bind` the `films` Store in this
    grid as well (`#2`). To make our job easier later, we will also declare `reference`
    for this grid (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have the columns mapping `dataIndex` with the field of the Film Model.
    When we want to manipulate the information that is going to be displayed in the
    grid, we can use the `renderer` function. For the length column, we want to display
    the length and `'min'` because the length of a film is based in minutes. So, we
    can return the value itself (length) concatenated to the string we want (`#6`).
  prefs: []
  type: TYPE_NORMAL
- en: Inside the renderer function, we can also use other fields to manipulate the
    information by retrieving the desired field from `record`. For example, inside
    the `renderer` function (`#4`) of the title column, we want to display a tooltip
    with the film's `description` (`#5`) when the user does a mouse over on the title
    column. But we are not changing the value that is going to be displayed, which
    is `title` (`value` parameter of the `renderer` function) itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Base Grid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the base `Grid` class, we are going to create a new base folder named
    `base` inside `app/view` so that we can place all our `base` classes. Then we
    are going to create a new file named `Grid.js` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have created a similar class to this one in [Chapter 7](ch07.html "Chapter 7. Static
    Data Management"), *Static Data Management*. However, this class has something
    different. In lines `#1` and `#2` we are declaring a `handler` that is going to
    be handled in the ViewController. Working with MVVM and Widget Columns is much
    simpler than working using the MVC approach because we do not need to fire a custom
    event; we can simply declare the `onEdit` and `onDelete` methods inside the ViewController.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the RowExpander plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's go back to the `FilmsGrid` class and add the `RowExpander` plugin. The
    `film` table has more columns than the ones we are displaying inside the `FilmsGrid`
    class. We can use the `RowExpander` plugin to display other information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add the following code inside the `FilmsGrid` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We need to configure a template to display the extra information we want. In
    this case, we are displaying the `description` of the film and some other information
    that could not fit on the columns, such as the `rental` information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the template, you can visit [http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.Template](http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.Template)
    and [http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.XTemplate](http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.XTemplate).
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is not possible to use the `RowExpander` plugin with the associated
    models. If we want to display associated data, we can use the `SubTable` plugin.
    It is also not possible to use the `RowExpander` and `SubTable` plugins at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding code, a new column will be added in the Grid so that we
    can see this extra information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the RowExpander plugin](img/0457OT_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Actor-Language – handling a hasOne association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. User Management"), *User Management*, we
    handled the relationship between the `User` and `Group` models using a `hasOne`
    association by adding a new field in the `User` Model (creating a `User` Model
    section). We will learn a different way to display a `hasOne` association in the
    grid in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'A film has a `hasOne` association with language (language has a `hasMany` association
    with film). We will display the language `name` instead of `language_id` using
    a `renderer` function as demonstrated in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We will take advantage of the fact that the `Languages` Store was created within
    the global scope of the application (which we created in [Chapter 7](ch07.html
    "Chapter 7. Static Data Management"), *Static Data Management*) and use this.
    This way, we do not need to load the language `name` from the server again. So,
    we are going to retrieve the Store (`#1`) using the store manager and search for
    the `Language` Model that has `language_id`, which we are looking for (`#2`).
    If the value exists, then we display it; otherwise, we display the `language_id`
    parameter anyway (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: Even though Ext JS has the capability to load the information from the server
    and parse using the association capability, is it worth using it in this scenario
    since we already have a Store with the values we need loaded? If we do use association,
    it means that more data will be loaded from the server, and some of them can be
    duplicated for a different Model (in this case, all films have `language_id` as
    `1`, which is English). So the same language Model would be loaded several times,
    and the JSON we would load from the server would be larger.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the PagingToolbar
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we are going to declare a PagingToolbar. Inside the `FilmsGrid` class,
    we are going to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The PagingToolbar is a special toolbar that is bound to a Store. For this reason,
    we need to specify the Store (`#1`). In this case, it will be the same Store we
    declared in `FilmsGrid`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling paging on the server side
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since we are using the PagingToolbar, it is important to remember a few things.
    Ext JS provides tools to help us to page the content, but let's emphasize the
    word "provide". Ext JS will not do the paging for us if we retrieve all the records
    from the database at once.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to page data that is already loaded, we can use `PagingMemoryProxy`
    (`Ext.ux.data.PagingMemoryProxy`) provided within the Ext JS SDK.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the request Ext JS sends to the server, we will find that
    it sends three extra parameters when we use the PagingToolbar. These parameters
    are **start**, **limit**, and **page**. For example, as we can see, when we load
    the GridPanel information for the first time, **start** is **0**, **limit** is
    the `pageSize` configuration we set on the Store (in this case, **15**), and **page**
    is **1**. The following figure exemplifies this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling paging on the server side](img/0457OT_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click on the next page of the GridPanel, **start** will be **15** (0
    + **limit** (15) = 15), **limit** will have the value **15** (this value does
    not change unless we change `pageSize` dynamically), and **page** will be **2**.
    This is demonstrated by the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling paging on the server side](img/0457OT_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a third-party plugin that can change `pageSize` dynamically according
    to the user's selection at [https://github.com/loiane/extjs4-ux-paging-toolbar-resizer](https://github.com/loiane/extjs4-ux-paging-toolbar-resizer).
  prefs: []
  type: TYPE_NORMAL
- en: 'These parameters help us to page the information on the database as well. For
    example, for MySQL, we only need `start` and `limit`, so we need to get them from
    the request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when we execute the `SELECT` query, we need to add `LIMIT $start, $limit`
    at the end (after the `WHERE`, `ORDER BY`, `GROUP BY` clauses, if any):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will bring the information we need from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another very important detail is that the PagingToolbar displays the total
    number of records we have on the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we also need to return a `total` property on the JSON with the count of
    the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Then Ext JS will receive all the information required to make the paging work
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Paging queries on MySQL, Oracle, and Microsoft SQL Server
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: We need to be careful because if we use a different database, the query to page
    the information directly from the database is different.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were using the Oracle database, the `SELECT` query with paging would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be much more complicated than MySQL. Now let''s see Microsoft SQL
    Server (SQL Server 2012):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In SQL Server 2012**,** it is simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In Firebird**,** it is also simpler than MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So be careful with the SQL syntax if you are using a different database than
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the films container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is creating the **Films** screen that we presented at the beginning
    of this chapter. It consists of a toolbar with a button (**Add**), the Films grid,
    and two associated grids (Categories and Actors). We are going to create this
    View in the `Films.js` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we declared a ViewController (`#1`) and also the ViewModel (`#2`).
    The ViewModel was already created, so we need to create the ViewController.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have `session` (`#3`). If provided, this creates a new session instance
    for this component. As this class is a container for other classes, the session
    will then be inherited by all child components. We will dive into the session
    when we work in the ViewController.
  prefs: []
  type: TYPE_NORMAL
- en: In line `#4`, we have the `FilmsGrid` class we created. And in lines `#5` and
    `#6` ,we have the `categories` and `actors` grid that we will use to display the
    many-to-many association.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have `TopToolBar` declared in line `#7`. This toolbar was created separately,
    so we can reuse it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We cannot forget to update the `menu` table to reflect the films `xtype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We will be adding more buttons to this toolbar in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Handling many-to-many associations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `film` and `category` tables are associated by a many-to-many relationship.
    When this happens, a matrix table is created with two columns to hold the IDs
    of a pair of related entities. There is a matrix table representing the many-to-many
    relationship between the `film` and `category` tables, called `film_category`
    and a table called `film_actor` representing the many-to-many relationship between
    `film` and `actor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To represent a many-to-many relationship in Ext JS, we will add the following
    code to the `Film` Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For each many-to-many relationship, we need to define a `name` (`#1`). The name
    must be unique within the schema. We also need to define a `type` (`#2`). The
    `type` is the name of the `model` of the association—we can use `entityName` to
    define the associated Model. We can also define `role` (`#3`), which will be the
    name of the method generated to retrieve the associated data. We also need to
    specify the foreign key (`#4`) used to identify the association. As the many-to-many
    relationship is created between two tables, we can also specify the information
    that links this Model to the matrix table, which is the `field` (foreign key—`#5`)
    and also the `role` of the association in the `Category` and `Actor` models (`#6`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `Category` Model, we will also declare the many-to-many association:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'And we will do this inside the `Actor` Model as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Loading nested JSON from the server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the server-side code, we need to retrieve the film information and its categories
    and actors as well. The JSON that the server will return to Ext JS will have the
    following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The server-side code is included within the source code of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we inspect a `Film` Model instance of the `films` Store, we will see that
    a function/method is created for each of the associations, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading nested JSON from the server](img/0457OT_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When accessing `model.actors()` or `model.categories()`, the methods will return
    a Store for each association and not an array of the `Actor` or `Category` Model.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the ViewModel – chained stores
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ext JS will understand the association and will be able to create the methods
    and associated stores, but we need to add the stores to the session as well by
    adding the `actors` and `categories` Store in the same ViewModel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note the highlighted code. The stores we are creating use existing stores (which
    we created in the preceding chapter, and which are available in the global scope
    of the application through their `storeId`) through a `source` configuration.
    This capability was also introduced in Ext JS 5, and it is called a chained store
    (`Ext.data.ChainedStore`). A chained store is a store that is a view of an existing
    store. The data comes from the `source`; however, this view of the store can be
    sorted and filtered independently without having any impact on the source store.
    This is very useful when we want to have two different stores with synchronized
    data, but independent instances.
  prefs: []
  type: TYPE_NORMAL
- en: Film-Actor – handling many-to-many associations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have the many-to-many association in place, we can create the `FilmActorsGrid`
    class. This class will have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This grid contains a column we have not used so far, which is the Template Column.
    When using this column, you can create a template to display more than one field
    (`#2`) instead of using a `renderer` function to do so.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code presents how to display associated data in a detail grid.
    When we select a film from the `FilmsGrid`, the Actors grid will automatically
    display the associated data by binding the `actors` (role of the association)
    with the Actors grid (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: Film-Category – handling many-to-many associations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will use the same approach used for the Film-Actor many-to-many associations
    for the Film-Category many-to-many associations. We will create a class named
    `FilmCategoriesGrid`. This class will have the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We will also `bind` the Store of this grid to the data loaded from the association
    (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ViewController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The missing piece now is the ViewController, which will handle all the handlers
    and listeners declared in our code. We will split the code into two classes: the
    `base.ViewController` that contains generic code and can be reused, and the `film.FilmsController`
    that contains the code to handle specific details of the `Films` View.'
  prefs: []
  type: TYPE_NORMAL
- en: The base ViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inside this class, we will put all the generic code that can be reused by other
    views that have the same behavior as the `Films` View. For example, editing or
    deleting a record by clicking on a button of a Widget Column opens the pop-up
    window. If the user clicks on the **Add** button, then close the pop-up window
    that is used to create or edit information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this class is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding chapter, you learned that it is possible to create a generic
    Controller in MVC to handle events from multiple screens. It was implemented using
    a generic selector from the components we created. In MVVM, it is also possible
    to create a generic ViewController, but not using a generic selector (because
    we do not work with selectors in MVVM). This is possible if we set a pattern of
    listeners (the components will have the same `handler` name), and declare a generic
    ViewController. However, we also need to specify a specific ViewController for
    the View, and this ViewContoller is going to extend our base ViewController. Generic
    code in ViewController is handled by inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `FilmsGrid`, class we have two handlers: one for the **Edit** Widget
    Button and one for the **Delete** Widget Button.'
  prefs: []
  type: TYPE_NORMAL
- en: For the **Delete** button (`#4`), all we have to do is ask whether the user
    is certain that they want to delete the `record`, and then if we receive a positive
    response, we use the `record.drop()` method to do it. The `drop` method marks
    the record as dropped and waiting to be deleted on the server. When a record is
    dropped, it is automatically removed from all association stores, and any child
    record associated with this record is also dropped (a cascade delete) depending
    on the cascade parameter. As the View and the Store are associated with a session,
    when we call the method `drop`, the session records that this record and its associated
    data need to be deleted, and the Store is also notified. We could also use the
    remove method from the Store; it would have the same output.
  prefs: []
  type: TYPE_NORMAL
- en: For the **Add** (`#1`) and **Edit** (`#2`) handlers, we want to open the **Edit**
    window so that we can modify or create a new film. We are going to use the same
    approach we used in [Chapter 6](ch06.html "Chapter 6. User Management"), *User
    Management*, when we handled `Users` and `Groups`. The `createDialog` method will
    be created in the specific ViewController, which is the `FilmsController` class
    we will create next. This way we can have a generic code, but the details will
    be implemented in the specific ViewController.
  prefs: []
  type: TYPE_NORMAL
- en: A detail for the `edit` and `delete` handlers is that we can easily use the
    method `getWidgetRecord` from the button (Widget Column) to retrieve the `record`
    from the grid. This approach is very different from the approach we used in the
    preceding chapter (where we created a custom event to be handled in the MVC Controller).
  prefs: []
  type: TYPE_NORMAL
- en: Just as we did in [Chapter 6](ch06.html "Chapter 6. User Management"), *User
    Management*, we will create the **Edit** window, and it will have a **Cancel**
    button. When the user clicks on this button, we will destroy the window (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can go back to [Chapter 6](ch06.html "Chapter 6. User Management"), *User
    Management*, and modify the code to use this ViewController as well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the FilmsController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we are going to implement the ViewController for the `Films` View. Its
    initial code is presented here; in the subsequent topics, we will add more code
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Adding or editing a film
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that `FilmsGrid` is already being rendered and loaded and the `add` and
    `edit` handlers are in place in the ViewController, we need to create the `createDialog`
    method. But first, we need to create the `Edit` window class.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we could see in the screenshots at the beginning of this chapter, the **Edit**
    window has three tabs: one for editing the film details, another one to edit the
    categories related to the film, and the third one to edit the actors related to
    the film. For now, we are going to deal with the film details only.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, inside `app/view/film`, we are going to create a new view named `Packt.view.film.FilmWindow`.
    This class will be a window that has a form with a TabPanel as an `item`. Inside
    each of the tabs, we will place the film''s details, the categories, and the actors,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This window extends from a custom class (`#1`) that we are going to create.
    As for the creation and editing of grid rows, we always use a window, so we can
    create a super window class with the common configuration and use it throughout
    our application. We will create this new class in a minute; let's finish overviewing
    this class first. We cannot forget to declare an `xtype` configuration (`#2`);
    we will use this `xtype` configuration in the ViewController later.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this window, we have a form (`#3`), to which we need to declare a reference
    to easily retrieve in the ViewController. Inside the form we have a TabPanel (`#4`),
    which contains a tab with the film information (`#5`)—we are going to create a
    separate class for it, and the categories (`#6`), for which we are also going
    to create a separate class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of this class is the actors details that are presented in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: For the actors details, we are going to reuse the `Actors` grid (`#7`) displayed
    in the `Films` View. We are going to add a reference as well (`#8`), because it
    is going to be useful when we work on the **Search and Add** screen to handle
    the `onAddActor` (`#9`) listener. And at last, we also need a listener for the
    delete button (`#10`).
  prefs: []
  type: TYPE_NORMAL
- en: The **Add** and **Delete** actor buttons are going to add and delete entries
    of the `film_actor` table.
  prefs: []
  type: TYPE_NORMAL
- en: Packt.view.base.WindowForm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the **Edit** windows we have already implemented are a window with Fit
    layout and usually have a FormPanel inside it. The window also has a **Cancel**
    and a **Save** button. As all these configurations are default for our components,
    we can create a super window for them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are not declaring a configuration inside the `initConfig` method
    (which is not present in this class). This means this class is a base, and anything
    can be overridden in a child class.
  prefs: []
  type: TYPE_NORMAL
- en: An important detail here is that the `title` (`#1`) and the `glyph` (`#2`) configurations
    used in this window can be bound to the information from the ViewModel. We will
    handle these details in the `createDialog` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This window class uses `CancelSaveToolbar`. The code for this toolbar is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Inside the preceding class there are `listeners` for the **Save** button (`#3`),
    which we are going to handle inside the `FilmsController` class and for the **Cancel**
    button (`#4`), which is handled by the base ViewController class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can go back to the code we implemented in [Chapter 6](ch06.html "Chapter 6. User
    Management"), *User Management*, and [Chapter 7](ch07.html "Chapter 7. Static
    Data Management"), *Static Data Management*, and refactor to use the base classes
    and toolbar classes. This is what is nice about Ext JS and its object-oriented
    approach: it allows you to reuse code, and you can refactor it as you can do in
    any other object-oriented language, and there are no headaches involved.'
  prefs: []
  type: TYPE_NORMAL
- en: The films form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first item of the TabPanel (`#3`) is the `film-form-container`. Inside this
    class, we are going to declare all the fields that represent the columns of the
    `film` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to the Sakila documentation and take a look at the fields of
    the `film` table ([http://dev.mysql.com/doc/sakila/en/sakila-structure-tables-film.html](http://dev.mysql.com/doc/sakila/en/sakila-structure-tables-film.html)).
    You can also refer to the first image of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`film_id`: This is the primary key of the table and has a unique value. So,
    for this field, we can use a hidden field to control this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This is the title of the film. So, we can use a text field for it.
    The maximum length on the database is 255, so we also need to add validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`description`: This is a short description or plot summary of the film. As
    the description can be 5,000 characters in length, we can use a text area to represent
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`release_year`: This is the year in which the movie was released. This can
    be a numeric field, with a minimum value of 1950 until the current year + 1 (let''s
    say we want to add a film that is going to be released next year).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`language_id`: This is a foreign key pointing at the language table. It identifies
    the language of the film. This can be a combobox with the language Store (already
    populated when we load the application).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`original_language_id`: This is a foreign key pointing at the language table
    that identifies the original language of the film. This is used when a film has
    been dubbed in a new language. Also, this can be a combobox with the language
    Store (already populated when we load the application).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rental_duration`: This is the length of the rental period in days. This can
    be a number field, with a minimum value of `1` and maximum value of `10` (let''s
    give a limit to the maximum value).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rental_rate`: This is the cost to rent the film for the period specified in
    the `rental_duration` column. This can also be a number field. The minimum value
    is `0` and the maximum value is `5`, and we need to allow decimal values as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`: This is the duration of the film in minutes. The `length` column
    can also be a number field between 1 and 999.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`replacement_cost`: This is the amount charged to the customer if the film
    is not returned or is returned in a damaged state. This is also a numeric field.
    Let''s give a minimum value of `0` and maximum value of `100`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rating`: This is the rating assigned to the film. It can be one of `G`, `PG`,
    `PG-13`, `R`, or `NC-17`. As these have fixed values, we can represent them on
    a radio button group or a Combobox. We are going to use a Combobox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`special_features`: This lists which common special features are included on
    the DVD. It can be zero or more of trailers, commentaries, deleted scenes, and
    behind the scenes. As this can be one or more, we can use the TagField introduced
    in Ext JS 5\. We can also use checkboxes or a combobox allowing multiple selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s declare the class structure first, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The fields will be inside a panel (which will become a tab) that uses the Anchor
    layout, and each field will occupy all available horizontal space (`anchor: 100%`).
    The labels are `105` pixels wide, and any error messages will be displayed on
    the `side` of the field. There has been no news for us so far.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s declare the first two fields—`title` and `release_year`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Both values are bound (`#1` and `#3`) to the fields of a record called `currentFilm`
    (that we will create in `FilmsController` later). `Release Year` is a numeric
    field, and as we want the value to be an integer, we will not allow the user to
    enter decimal numbers (`#2`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about forms and field validation, please refer to [http://docs.sencha.com/extjs/5.0/components/forms.html](http://docs.sencha.com/extjs/5.0/components/forms.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the language fields, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As both comboboxes represent language, their configuration is going to be exactly
    the same except for `fieldLabel` and `bind` (`#5` and `#6`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that we are using the same Store for both fields (`#4`) and we want them
    to have the same values, which means that if the user goes to the language GridPanel
    on static data and add or change a language, we want these changes to be applied
    to these stores at the same time, and that is why we are using the same Store
    as used by static data module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have four numeric fields: `rental_duration`, `rental_rate`, `length`,
    and `replacement_cost`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing is very important: whenever we have numeric fields and we want to
    load them from a Model, we need the field from the Model to be numeric as well
    (`int` or `float`); otherwise, the form will not load the values properly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the rating combobox with its `store`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We have the combobox `value` (`#6`) and a `store` (`#7`) bound to this `combobox`.
    We are going to create this Store in `FilmsModel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'And at last, we have `tagfield` and `textareafield`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Tag field was introduced in Ext JS 5, and its behavior is very similar to that
    of a combobox that allows you to select multiple values. To set the selected values,
    we need to pass an array (`#8`). In the `Film` Model, `special_features` is a
    string. For this reason, we will handle these values in the ViewModel as well
    using a formula. We are also going to create a `store` configuration (`#9`) in
    the ViewModel to represent this static Store.
  prefs: []
  type: TYPE_NORMAL
- en: Film categories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have the film details part covered, we can handle the most complex
    part, which is the association with the `category` and `actor` tables. The `category`
    and `actor` tables have a many-to-many association with the `film` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'As declared inside the films form, we are going to declare a new class to represent
    this tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This class contains a `multiselector`, which is a new component introduced in
    Ext JS 5\. It created a grid to render the selected values, and it is also going
    to display a red cross sign to remove unwanted values. We can set any selected
    values in its Store (`#1`). This component also allows you to add values using
    the plus sign that is configured by the `search` configuration. We also need to
    set a `store` (`#2`) to feed the options the user can select.
  prefs: []
  type: TYPE_NORMAL
- en: Film Actors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The actor relationship with the film is very similar to the relationship between
    `category` and `film` tables, meaning it is also a many-to-many relationship.
    We will handle the `actor` tables' many-to-many relationship in a way that is
    different from how we handled `film_categories`. As the available options for
    categories are limited, we could use a `multiselector` component to represent
    it. We do not know how many actors we can have in our database, so it is a little
    bit more complicated. The approach we are going to use here is to display a grid
    to render the selected actors and have an **Add** button so that the user can
    search for and add desired values.
  prefs: []
  type: TYPE_NORMAL
- en: We have declared the grid inside the `FilmWindow` class already. What is pending
    is the class that will display a pop up so that we can search for available Actors.
  prefs: []
  type: TYPE_NORMAL
- en: Search Actors – Live Search combobox
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The idea of the Live Search combobox is to display the **Search** screen for
    the user and a combobox field, where the user can enter a few characters and then
    the system will do a live search, displaying the actors that match the search
    made by the user. All the actors that match the search will be displayed as items
    of the combobox, and the combobox will also have paging. When the user selects
    the actor, we will display its `last_name` and `first_name`. Along with the actor
    name, we will also display a list of films this actor has acted in.
  prefs: []
  type: TYPE_NORMAL
- en: Model
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'First, we need a Model to represent the information we want to retrieve from
    the server. We will retrieve the actors information plus the film the actor already
    made. So, we can create a Model extending from the `Actor` Model, and in the `SearchActor`
    Model, we only need to declare the missing field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Store
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Next, we need a Store to load the `SearchActor` Model collection, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'On the server, we will use the `actor_info` view to retrieve the information.
    However, the combobox also passes three extra parameters: `start` and `limit`
    for the paging and a parameter named `query` with the text the user entered to
    do the live search.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `SELECT` query will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And as we are working with paging, we cannot forget to `COUNT` how many records
    we have that match the search and return the result inside the `total` attribute
    of the JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And now, we are able to retrieve the information according to the search text
    entered by the user.
  prefs: []
  type: TYPE_NORMAL
- en: Live Search combobox
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Our next step now is to implement the view that is going to provide the tools
    for searching. So, we are going to create a class that extends from `Ext.window.Window`,
    and inside this class, we will have a combobox that will provide all the features
    to do the Live Search. The code is presented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom, there''s only a comment for the user to know that they are required
    to enter at least two characters so that the Live Search can work, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Live Search combobox](img/0457OT_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s see the code for the combobox that goes where `#1` is in the previous
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: To get started, we are going to declare `reference` so that we can easily retrieve
    this component in the ViewController later (`#2`). As always, we need a `store`
    declaration (`#8`) to populate the combobox. In this example, we are instantiating
    the Store by its type. For this reason, we need to declare the full name of the
    Store in the `requires` of this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we need `displayField` (`#3`). The `displayField` will only show the `first_name`
    of the actor when an actor is selected from the Live Search. However, we want
    to display `last_name` and `first_name`. So to be able to do it, we need to overwrite
    the `displayTpl` template (`#9`). This is the result we will get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Live Search combobox](img/0457OT_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Next, we have `valueField` (`#4`), which is the ID of the selected actor; we
    are going to hide the down arrow (called `trigger`—`#5`) to make the Live Search
    work. The user needs to enter at least two characters (`#6`), and the combobox
    will display only two actors per page (`#7`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have `listConfig` (`#10`), where we can configure the loading text
    and the empty text, and also the template to display the actor's information.
    Basically, we are displaying `last_name`, `first_name` at the top and in bold,
    and on the next line, we are displaying all the films already made by this actor.
  prefs: []
  type: TYPE_NORMAL
- en: Complementing the ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two pending things we need to do in the ViewModel: add the `ratings`
    and `special_features` stores and also implement the `specialFeatures` formula
    that we used to `bind` in the film details form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s begin declaring the stores to our ViewModel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Both stores have predefined `data`, meaning they are an instance of the ArrayStore.
    This kind of Store is very useful in situations like this. The Model both stores
    are using is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The Model is very simple, with a single field. We can reuse this Model for any
    Store we create to be used in comboboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with formulas and two-way data binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We created a tag field to declare the special features of a film. This field
    requires an array of values to be set and also an array of values to be returned
    as field values. The out field `special_features` in the Model is a string, which
    clearly is not an array! Until Ext JS 4, we had to encode and decode the values
    manually in a Controller (or somewhere else in the code, but preferably in a Controller).
    With Ext JS 5 and the introduction of the ViewModel we can use a capability called
    formulas.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to create simple formulas similar to the extra `fields` we can
    declare in a Model (we declare `groupName` in the `User` Model), and it is also
    possible to declare more complex `formulas`. In the Ext JS examples, we can find
    some examples of how to use simple `formulas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the formula named `specialFeatures` that we bound to
    `tagfield` in the `FilmFormContainer` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we need to do is give a name to our `formulas` declaration (`#1`).
    We can `bind` our formula to an existing value (such as selection). In our case,
    we are binding to the `special_features` attribute of `currentFilm` ((`#2`)—which
    we will pass to the **Edit** window later in the ViewController). We are also
    specifying that this is a `deep` data binding (`#3`), which means any change that
    happens in `currentFilm.special_features` will update the formula, or any update
    that happens in the formula through its methods will update `currentFilm.special_features`
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: We can also define a getter and a setter method to a formula. First, we are
    defining a `get` method (`#4`). This method receives the `value` from `currentFilm.special_features`,
    splits the string, and transforms it into an array, and will be used by the tag
    field. Likewise, we have a `set` method (`#5`), which will receive the `value`
    set in the tag field, transform it into a string, and update `currentFilm.special_features`.
    Just keep in mind that `currentFilm` is an instance of the `Film` Model.
  prefs: []
  type: TYPE_NORMAL
- en: The Films ViewController
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In past chapters, we have already covered some examples of how to save data.
    We used the form `submit`, an Ajax `request`, and also the writing resource from
    the Store. In this chapter, let's focus on functionalities we have not implemented
    yet. Do not worry. The complete implementation is available within the source
    code distributed with this book.
  prefs: []
  type: TYPE_NORMAL
- en: The createDialog method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created all the views for our application. In the base **ViewController**,
    we created the handlers for the Add and Edit buttons, and both call the `createDialog`
    method, which we are going to develop now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is to display a blank **Edit** window in case the user clicks on the
    **Add** button, and to display the selected film in case the user clicks on the
    **Edit** button. The source code for this method is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we are going to do is get the reference of the View, which is
    the `Films` class (`#1`). Next, we are also going to create an `isEdit` flag (`#2`)
    and assign it to the ViewController so that we can access other methods later
    (such as the `save` method).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we are going to instantiate the **Edit** window, adding it to the View
    (`#3`). When we add a child to the main View, it inherits the ViewModel and the
    ViewController as well. However, in this case, we are setting specific configurations
    to the **Edit** window ViewModel as well (`#4`), meaning it will have access to
    whatever configuration is already there plus the ones we are setting, such as
    `title` and `glyph`, which is predefined `data` (`#5`) to this ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will create a link (`#6`) to a record called `currentFilm` ((`#7`),
    which we used in the bind configurations in the **Edit** window). If it is an
    `edit`, it will link to the selected row in the grid; otherwise, we create a new
    `Film` Model instance.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to create a child `session` (`#8`) for this View. We are going
    to discuss `session` when we discuss the `save` method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we display the **Edit** window pop up (`#9`).
  prefs: []
  type: TYPE_NORMAL
- en: Getting the selected actor from Live Search
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a user searches for an actor and clicks on `Add Selected`, we will have
    to handle the event in the ViewController in the `onSaveActors` methods. The logic
    for this method is that we need to get the actor ID selected in the combobox and
    search for its value in the `actors` Store. Once we have the `Actor` Model instance,
    we can add it to the `actorsGrid` store. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: First, we get the reference of the combobox (`#1`) and get its `value`, which
    will return the ID of the selected actor. Next, we will get the reference of the
    `actors` Store declared in the `FilmsModel` (`#2`). We will search for the actor
    selected in the Store (`#3`); it will return the `Actor` Model reference or null
    if the actor does not exist. Then we get the `actorsGrid` reference ((`#4`)—the
    one inside the films form), and we also get its Store (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: If an actor is found, we add to the `actorsGrid` Store (`#6`). This grid is
    bound to the selected film actors association, so if an actor is added or deleted
    from the grid Store, it is also added or deleted from the association. This is
    another example of two-way data binding in Ext JS 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'And at last, we close the Live Search pop up (`#7`) with the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Saving the form and working with sessions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now it is time to save any data updated, deleted, or created. Any changes we
    make in the form will be saved to the session (`Ext.data.Session`). Sessions were
    introduced in Ext JS 5 and are great for when we are working with associations.
    We added a session to our films View by adding the configuration `session: true`
    in it. Then, all the stores from the ViewModel are also bound to the session,
    meaning any change made in the stores or in the session will be synchronized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `onSave` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: We are going to get the pending information to be saved from the session and
    save it in the server. First, we need to get the `session` (`#1`). Then, we are
    going to get the film's `id` if it is a new film ((`#2`)—a random temporary ID
    is created for every Model in Ext JS, usually with the name of the entity and
    a sequential number). This `id` will be overwritten after we save it in the database
    and use the database table sequential ID.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that when we created the dialog, we assigned a child session to the
    **Edit** window? This allows us to work with the data without committing to it,
    meaning we can roll back the changes easily by destroying the **Edit** window.
    When we want to save the data from the child session into the `Films` session
    officially, we can call the `getSession` method from the **Edit** window and save
    it (`#3`). This will save the child session data in the `Film` session.
  prefs: []
  type: TYPE_NORMAL
- en: Next, if it is a new film, we also want to add the record to the `films` Store
    (so it can be displayed in the `FilmsGrid` as well—(`#4`)).
  prefs: []
  type: TYPE_NORMAL
- en: There are two different ways to save information from a session. The first way
    is using `batch` (`Ext.data.Batch`) that can be retrieved from the session (`#5`),
    and the second way is executing its method `start` (`#6`). This will trigger the
    CRUD operations and will use the `proxy` details to connect to the server of the
    pending models of the session to be saved.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Writer – saving associated data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, the session does not save associated data. If we create a Film, Category,
    and Actor, the create operation from each respective Model will be triggered,
    but the data to be saved in the many-to-many matrix tables will not be sent to
    the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a custom `writer` class that will send any associated data to
    the server as well in a single batch. Then, we need to handle the proper CRUD
    operations of the associated data on the server as well. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to go back to the `Packt.model.Base` class, add this `writer`
    class to the `requires` declaration, and change the writer type as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: All associated data will be sent to the server; in the same way, we are receiving
    a nested JSON from the server when we read information from it.
  prefs: []
  type: TYPE_NORMAL
- en: Saving session data manually
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A second option to save the session data to the server is doing it manually.
    If we use the `getChanges` method of the session, it will return an object with
    all the pending information to be saved in the server, including associated data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we try to edit a Film, add some Actor information and Category
    information, and call `JSON.stringify(session. getChanges(), null, 4)`, we will
    have an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This means we are updating (`U`) some fields of the Film with ID of `1`, deleting
    (`D`) the category with ID of `6` from the Film `1` and adding (`C`) the categories
    `7`, `8`, and `9` to the Film `1` as well. We are also deleting (`D`) the Actor
    `1` from Film `1` and adding (`C`) the Actor `71` to the Film `1` as well. Note
    that the `categories` and `actors` are the names of the many-to-many associations
    we created for `Film` Model.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use this object to save the data manually in the server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to implement a more complex screen to manage
    the inventory information from the database. You learned to handle a many-to-many
    association as well. You learned how to use some different form fields and how
    to do a Live Search. You also learned how to save data from a session.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to add some extra capabilities that are
    not native to the Ext JS API to the screens we have already developed so far,
    such as print, export to Excel, and export to PDF, the contents of a GridPanel.
    Also, we will learn how to implement charts and export them to images and PDFs.
  prefs: []
  type: TYPE_NORMAL
