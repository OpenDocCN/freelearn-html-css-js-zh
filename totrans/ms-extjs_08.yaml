- en: Chapter 8. Content Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 内容管理
- en: In the preceding chapter, we developed the static data module that consisted
    of emulating the edition of a table from a database. Basically, it was a **Create,
    Read, Update, Delete** (**CRUD**) of a single table with some extra capabilities.
    In this chapter, we are going further in the complexity of managing information
    from a table. Usually, in real-world applications, the tables, the information
    of which we want to manage have relationships with other tables, and we have to
    manage the relationships as well. And this is what this chapter is all about.
    How can we build screens and manage complex information in Ext JS?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开发了静态数据模块，该模块模拟了从数据库中编辑表格的过程。基本上，它是一个带有一些额外功能的单个表的**创建、读取、更新、删除**（**CRUD**）操作。在本章中，我们将进一步探讨从表中管理信息的复杂性。通常，在现实世界的应用程序中，我们想要管理的表与其他表有关联，我们必须管理这些关联。这正是本章的主题。我们如何在
    Ext JS 中构建屏幕并管理复杂信息？
- en: 'So in this chapter, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将涵盖：
- en: Managing complex information with Ext JS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ext JS 管理复杂信息
- en: How to handle many-to-many associations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理多对多关联
- en: Forms with associations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带关联的表单
- en: Reusing components
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件重用
- en: Managing information – films
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理信息 – 电影
- en: 'The Sakila database has four major modules within it: **Inventory**, which
    consists of the films'' information, along with the inventory information (how
    many movies we have in each store available for rental); customer data, which
    consists of customer information; business, which consists of the stores, staff
    and also rental and payment information (this depends on inventory and customer
    data to feed some information); and views, which consists of data we can use for
    reports and charts.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Sakila 数据库内部有四个主要模块：**库存**，它包含了电影信息以及库存信息（每个店面有多少部电影可供出租）；客户数据，它包含了客户信息；业务，它包含了店面、员工以及租赁和支付信息（这取决于库存和客户数据以提供一些信息）；以及视图，它包含了我们可以用于报告和图表的数据。
- en: 'For now, we are only interested in **Inventory**, customer data, and business,
    which contains the core business information of the application. Let''s take a
    look at **Inventory**, which has more tables than the other two:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只对**库存**、客户数据和业务感兴趣，这些包含了应用程序的核心业务信息。让我们来看看**库存**，它比其他两个表有更多的表：
- en: '![Managing information – films](img/0457OT_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![管理信息 – 电影](img/0457OT_08_01.jpg)'
- en: 'According to the Sakila documentation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Sakila 文档：
- en: '*The `film` table is a list of all films potentially in stock in the stores.
    The actual in-stock copies of each film are represented in the `inventory` table.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*`电影`表是所有可能存放在店面中的电影的列表。每种电影的实际库存副本在`库存`表中表示。*'
- en: '*The `film` table refers to the `language` table and is referred to by the
    `film_category`, `film_actor`, and `inventory` tables.*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*`电影`表引用了`语言`表，并被`电影类别`、`电影演员`和`库存`表引用。*'
- en: The `film` table has a many-to-many relationship with the `category` and `actor`
    tables. It has two many-to-one relationships with the `language` table. In the
    last chapter, we have already developed code to manage the `category`, `actor`,
    and `language` tables. Now, we need to manage the relationships between the `film`
    table and these other tables.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`电影`表与`类别`和`演员`表之间存在多对多关系。它与`语言`表有两个多对一关系。在上一章中，我们已经开发了管理`类别`、`演员`和`语言`表的代码。现在，我们需要管理`电影`表与其他表之间的关系。'
- en: Ext JS 5 has really nice capabilities to manage associated entities similar
    to the `film` table. We will dive into them in this chapter.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 5 确实具有管理类似于`电影`表的关联实体的出色功能。我们将在本章深入探讨这些功能。
- en: So let's take a brief look at the screens that we are going to develop in this
    chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们简要地看看本章将要开发的屏幕。
- en: 'First, we need a screen to list the films we have, which is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个屏幕来列出我们拥有的电影，如下所示：
- en: '![Managing information – films](img/0457OT_08_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![管理信息 – 电影](img/0457OT_08_02.jpg)'
- en: This screen displays three data grids. The first one is the `film` table, which
    is going to display the list of all **Films**. The second one is the **Film Categories**,
    which represents the many-to-many relationship between the `film` and `category`
    tables. And the third one is the **Film Actors**, which represents the many-to-many
    relationship between the `film` and `actor` tables.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个屏幕显示了三个数据网格。第一个是`film`表，它将显示所有**电影**的列表。第二个是**电影类别**，它表示`film`和`category`表之间的多对多关系。第三个是**电影演员**，它表示`film`和`actor`表之间的多对多关系。
- en: 'Then, if we want to create or edit a film, we will create a FormPanel within
    a window so that we can edit its information, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们想创建或编辑一个电影，我们将在窗口内创建一个表单面板，以便我们可以编辑其信息，如下所示：
- en: '![Managing information – films](img/0457OT_08_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![管理信息 – 电影](img/0457OT_08_03.jpg)'
- en: 'As the `film` table has a many-to-many association with the `categories` table,
    we also need to handle it within the FormPanel using a different tab. If we want
    to add more categories associated with the film, we can **Search** and add, as
    follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`film`表与`categories`表有一个多对多关联，我们还需要在表单面板中使用不同的标签页来处理它。如果我们想添加更多与电影相关的类别，我们可以**搜索**并添加，如下所示：
- en: '![Managing information – films](img/0457OT_08_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![管理信息 – 电影](img/0457OT_08_04.jpg)'
- en: 'Likewise, the `film` table has also a many-to-many association with the `actor`
    table, so we also need to handle it within the FormPanel. The following screenshot
    exemplifies this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`film`表也与`actor`表有一个多对多关联，因此我们还需要在表单面板中处理它。以下截图展示了这一点：
- en: '![Managing information – films](img/0457OT_08_05.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![管理信息 – 电影](img/0457OT_08_05.jpg)'
- en: 'If we want to add more actors associated to the film, we can use **Search and
    Add Actor**, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想添加更多与电影相关的演员，我们可以使用**搜索并添加演员**，如下所示：
- en: '![Managing information – films](img/0457OT_08_06.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![管理信息 – 电影](img/0457OT_08_06.jpg)'
- en: Notice that we are taking a different approach for each screen. This way we
    can learn more ways of handling these scenarios in Ext JS. By the end of this
    chapter, we will learn to create this complex form and save associated data as
    well.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们对每个屏幕采取了不同的方法。这样我们可以学习更多在Ext JS中处理这些场景的方法。到本章结束时，我们将学会创建这个复杂的表单并保存相关数据。
- en: So now that we have an idea of what we will implement throughout this chapter,
    let's have some fun and get our hands dirty!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们已经对在本章中将要实现的内容有了概念，让我们享受乐趣并动手实践吧！
- en: Displaying the Film data grid
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示电影数据网格
- en: First, let's start with the basics. Whenever we need to implement a complex
    screen, we need to start with the simplest component we can develop. When this
    component is working, we can start incrementing it and add more complex capabilities.
    So first, we need to create a Model to represent the `film` table. In this chapter,
    we are going to use the MVVM approach, so we can dive into capabilities we have
    not covered in previous chapters. Once we have this part of the code working,
    we can work with the relationships between the `category`, `language`, and `actor`
    tables.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从基础知识开始。每次我们需要实现一个复杂的屏幕时，我们都需要从我们可以开发的 simplest component 开始。当这个组件工作后，我们可以开始逐步增加它并添加更复杂的功能。所以首先，我们需要创建一个模型来表示`film`表。在本章中，我们将使用MVVM方法，这样我们可以深入了解之前章节中没有涉及到的功能。一旦这部分代码工作正常，我们就可以处理`category`、`language`和`actor`表之间的关系。
- en: The Film Model
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电影模型
- en: First, we are going to create the Model to represent the `film` table. Let's
    not worry about the relationships this table has for now.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个模型来表示`film`表。现在我们先不考虑这个表之间的关系。
- en: 'We need to create a new class named `Packt.view.film.FilmsGrid`, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个名为`Packt.view.film.FilmsGrid`的新类，如下所示：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As all Sakila tables have the `last_update` column, we will extend `Packt.model.staticData.Base`
    to avoid declaring this field in every single Model we create that represents
    a Sakila table. The `staticData.Base` class also extends `Packt.model.Base`, which
    contains the `schema` and `proxy` details for our models.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有Sakila表都有`last_update`列，我们将扩展`Packt.model.staticData.Base`以避免在创建代表Sakila表的每个模型时声明此字段。`staticData.Base`类也扩展了`Packt.model.Base`，它包含我们模型的`schema`和`proxy`细节。
- en: For the fields, we will have the same ones we have in the `film` table.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字段，我们将与`film`表中的字段相同。
- en: Films ModelView
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电影模型视图
- en: 'Our next step is to create a ModelView that will contain a Store that will
    load the collection of films. Let''s create a Store named `films` (remember that
    the Store name is always the plural of the name of the Model—if you want to follow
    the Sencha naming convention) inside the ViewModel, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是创建一个 ModelView，它将包含一个 Store，该 Store 将加载影片集合。让我们在 ViewModel 中创建一个名为 `films`
    的 Store（记住，Store 的名称总是 Model 名称的复数形式——如果你想要遵循 Sencha 命名约定），如下所示：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We need to create a file named `FilmsModel.js` inside the `app/view/film` folder
    and put the preceding code inside the file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `app/view/film` 文件夹内创建一个名为 `FilmsModel.js` 的文件，并将前面的代码放入该文件中。
- en: In the `films` Store, we are declaring the `model` as usual (`#1`), and we are
    also declaring `pageSize` as `15` (`#2`), meaning we will use the PagingToolbar
    in the Films data grid, and we will retrieve sets of 15 films per unit time to
    display in the GridPanel.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `films` Store 中，我们像往常一样声明 `model` (`#1`)，并且我们还声明 `pageSize` 为 `15` (`#2`)，这意味着我们将使用
    Films 数据网格中的分页工具栏，并且我们将每单位时间检索 15 部影片的集合来显示在 GridPanel 中。
- en: The `autoLoad` configuration is also set to `true` (`#3`). As the ViewModel
    is created once the View is instantiated, the Store will be loaded once the View
    is created as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`autoLoad` 配置也被设置为 `true` (`#3`)。由于 ViewModel 在 View 实例化后创建，因此 Store 也会在 View
    创建时加载。'
- en: 'At last, we have a `session` configuration (`#4`). We have not worked with
    sessions so far in this book. When we worked with CRUD in the preceding chapter,
    we used the Store to save the data. In this chapter, we are going to work with
    associated data, and a session can be really helpful when we need to save data
    from different models. The session will be created in the View. Having `session:
    true` declared inside a Store inside the ViewModel links the Store with the session
    of the View. We will discuss how this works later on in this chapter.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，我们有一个 `session` 配置 (`#4`)。到目前为止，我们在这本书中还没有使用会话。当我们上一章中处理 CRUD 时，我们使用了 Store
    来保存数据。在这一章中，我们将处理关联数据，并且当我们需要从不同的模型中保存数据时，会话可以非常有帮助。会话将在 View 中创建。在 ViewModel
    中的 Store 内声明 `session: true` 将 Store 与 View 的会话链接起来。我们将在本章的后面讨论它是如何工作的。'
- en: Film data grid (with paging)
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影片数据网格（带分页）
- en: 'Now that we have the Model and the ViewModel with the Store, we need to create
    `FilmsGrid`, which we can do as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了 Model 和带有 Store 的 ViewModel，我们需要创建 `FilmsGrid`，我们可以按照以下方式操作：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As our application starts to grow, we notice that we use some of the configurations
    in different components. For example, for most of the GridPanels, we use a toolbar
    with the **Add**, **Edit** and **Delete** buttons, or we can use a toolbar with
    the **Add** button and have the **Edit** and **Delete** buttons inside the grid
    as Widget Columns (or Action Columns). As all tables from the Sakila database
    have the `Last Update` column, this column is also common to all the GridPanels
    we use to list information from Sakila tables. For this reason, we can create
    a super GridPanel (as we did specifically for the static data module). So, for
    the Films GridPanel, we will extend from `base.Grid` (`#1`) that we will create
    next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序开始增长，我们注意到我们在不同的组件中使用了某些配置。例如，对于大多数的 GridPanels，我们使用带有**添加**、**编辑**和**删除**按钮的工具栏，或者我们可以使用带有**添加**按钮的工具栏，并将**编辑**和**删除**按钮放在网格内的
    Widget Columns（或 Action Columns）中。由于 Sakila 数据库中的所有表都有**最后更新**列，因此这个列也是我们用于列出
    Sakila 表信息的所有 GridPanels 的共同点。因此，我们可以创建一个超级 GridPanel（就像我们为静态数据模块专门创建的那样）。所以，对于影片
    GridPanel，我们将从我们将要创建的 `base.Grid` (`#1`) 扩展。
- en: Having declared the ViewModel already, we can `bind` the `films` Store in this
    grid as well (`#2`). To make our job easier later, we will also declare `reference`
    for this grid (`#3`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 已经声明了 ViewModel 后，我们也可以在这个网格中将 `films` Store 进行绑定 (`#2`)。为了使我们的工作更简单，我们还将声明这个网格的
    `reference` (`#3`)。
- en: Then, we have the columns mapping `dataIndex` with the field of the Film Model.
    When we want to manipulate the information that is going to be displayed in the
    grid, we can use the `renderer` function. For the length column, we want to display
    the length and `'min'` because the length of a film is based in minutes. So, we
    can return the value itself (length) concatenated to the string we want (`#6`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有列映射 `dataIndex` 与 Film 模型的字段。当我们想要操作将在网格中显示的信息时，我们可以使用 `renderer` 函数。对于长度列，我们想要显示长度和
    `'min'`，因为影片的长度是以分钟为单位的。因此，我们可以返回值本身（长度）与我们要连接的字符串（`#6`）。
- en: Inside the renderer function, we can also use other fields to manipulate the
    information by retrieving the desired field from `record`. For example, inside
    the `renderer` function (`#4`) of the title column, we want to display a tooltip
    with the film's `description` (`#5`) when the user does a mouse over on the title
    column. But we are not changing the value that is going to be displayed, which
    is `title` (`value` parameter of the `renderer` function) itself.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Base Grid
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To create the base `Grid` class, we are going to create a new base folder named
    `base` inside `app/view` so that we can place all our `base` classes. Then we
    are going to create a new file named `Grid.js` with the following content:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have created a similar class to this one in [Chapter 7](ch07.html "Chapter 7. Static
    Data Management"), *Static Data Management*. However, this class has something
    different. In lines `#1` and `#2` we are declaring a `handler` that is going to
    be handled in the ViewController. Working with MVVM and Widget Columns is much
    simpler than working using the MVC approach because we do not need to fire a custom
    event; we can simply declare the `onEdit` and `onDelete` methods inside the ViewController.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Adding the RowExpander plugin
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's go back to the `FilmsGrid` class and add the `RowExpander` plugin. The
    `film` table has more columns than the ones we are displaying inside the `FilmsGrid`
    class. We can use the `RowExpander` plugin to display other information.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add the following code inside the `FilmsGrid` class, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need to configure a template to display the extra information we want. In
    this case, we are displaying the `description` of the film and some other information
    that could not fit on the columns, such as the `rental` information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the template, you can visit [http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.Template](http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.Template)
    and [http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.XTemplate](http://docs.sencha.com/extjs/5.0/5.0.0-apidocs/#!/api/Ext.XTemplate).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, it is not possible to use the `RowExpander` plugin with the associated
    models. If we want to display associated data, we can use the `SubTable` plugin.
    It is also not possible to use the `RowExpander` and `SubTable` plugins at the
    same time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding code, a new column will be added in the Grid so that we
    can see this extra information:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the RowExpander plugin](img/0457OT_08_07.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Actor-Language – handling a hasOne association
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. User Management"), *User Management*, we
    handled the relationship between the `User` and `Group` models using a `hasOne`
    association by adding a new field in the `User` Model (creating a `User` Model
    section). We will learn a different way to display a `hasOne` association in the
    grid in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'A film has a `hasOne` association with language (language has a `hasMany` association
    with film). We will display the language `name` instead of `language_id` using
    a `renderer` function as demonstrated in the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一部电影与语言有一个 `hasOne` 关联（语言与电影有一个 `hasMany` 关联）。我们将使用以下代码中的 `renderer` 函数显示语言
    `name` 而不是 `language_id`：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We will take advantage of the fact that the `Languages` Store was created within
    the global scope of the application (which we created in [Chapter 7](ch07.html
    "Chapter 7. Static Data Management"), *Static Data Management*) and use this.
    This way, we do not need to load the language `name` from the server again. So,
    we are going to retrieve the Store (`#1`) using the store manager and search for
    the `Language` Model that has `language_id`, which we are looking for (`#2`).
    If the value exists, then we display it; otherwise, we display the `language_id`
    parameter anyway (`#3`).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 `Languages` Store 是在应用程序的全局范围内创建的事实（我们在 [第 7 章](ch07.html "第 7 章。静态数据管理")，*静态数据管理*
    中创建的）并使用它。这样，我们就不需要再次从服务器加载语言 `name`。因此，我们将使用存储管理器检索 Store (`#1`) 并搜索具有 `language_id`
    的 `Language` 模型，这是我们正在寻找的 (`#2`)。如果存在该值，则显示它；否则，无论如何都显示 `language_id` 参数 (`#3`)。
- en: Even though Ext JS has the capability to load the information from the server
    and parse using the association capability, is it worth using it in this scenario
    since we already have a Store with the values we need loaded? If we do use association,
    it means that more data will be loaded from the server, and some of them can be
    duplicated for a different Model (in this case, all films have `language_id` as
    `1`, which is English). So the same language Model would be loaded several times,
    and the JSON we would load from the server would be larger.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Ext JS 有从服务器加载信息并使用关联功能解析的能力，但在这种情况下使用它是否值得，因为我们已经有一个包含我们需要的值的 Store 加载了？如果我们使用关联，这意味着将从服务器加载更多数据，其中一些数据对于不同的模型（在这种情况下，所有电影都有
    `language_id` 为 `1`，即英语）可能是重复的。因此，相同的语言模型将被加载多次，我们从服务器加载的 JSON 也会更大。
- en: Adding the PagingToolbar
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加分页工具栏
- en: 'Next, we are going to declare a PagingToolbar. Inside the `FilmsGrid` class,
    we are going to add the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明一个分页工具栏。在 `FilmsGrid` 类内部，我们将添加以下代码：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The PagingToolbar is a special toolbar that is bound to a Store. For this reason,
    we need to specify the Store (`#1`). In this case, it will be the same Store we
    declared in `FilmsGrid`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 分页工具栏是一个特殊的工具栏，它与 Store 相绑定。因此，我们需要指定 Store (`#1`)。在这种情况下，它将是我们在 `FilmsGrid`
    中声明的同一个 Store。
- en: Handling paging on the server side
  id: totrans-76
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理服务器端分页
- en: Since we are using the PagingToolbar, it is important to remember a few things.
    Ext JS provides tools to help us to page the content, but let's emphasize the
    word "provide". Ext JS will not do the paging for us if we retrieve all the records
    from the database at once.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用分页工具栏，因此记住以下几点很重要。Ext JS 提供了帮助我们分页内容的工具，但让我们强调一下“提供”这个词。如果一次从数据库中检索所有记录，Ext
    JS 不会为我们进行分页。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we want to page data that is already loaded, we can use `PagingMemoryProxy`
    (`Ext.ux.data.PagingMemoryProxy`) provided within the Ext JS SDK.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要分页已加载的数据，我们可以使用 Ext JS SDK 内提供的 `PagingMemoryProxy` (`Ext.ux.data.PagingMemoryProxy`)。
- en: 'If we take a look at the request Ext JS sends to the server, we will find that
    it sends three extra parameters when we use the PagingToolbar. These parameters
    are **start**, **limit**, and **page**. For example, as we can see, when we load
    the GridPanel information for the first time, **start** is **0**, **limit** is
    the `pageSize` configuration we set on the Store (in this case, **15**), and **page**
    is **1**. The following figure exemplifies this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 Ext JS 发送到服务器的请求，我们会发现当我们使用分页工具栏时，它会发送三个额外的参数。这些参数是 **start**、**limit**
    和 **page**。例如，正如我们所看到的，当我们第一次加载 GridPanel 信息时，**start** 是 **0**，**limit** 是我们在
    Store 上设置的 `pageSize` 配置（在这种情况下，**15**），而 **page** 是 **1**。以下图示了这一点：
- en: '![Handling paging on the server side](img/0457OT_08_08.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![处理服务器端分页](img/0457OT_08_08.jpg)'
- en: 'When we click on the next page of the GridPanel, **start** will be **15** (0
    + **limit** (15) = 15), **limit** will have the value **15** (this value does
    not change unless we change `pageSize` dynamically), and **page** will be **2**.
    This is demonstrated by the following figure:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击 GridPanel 的下一页时，**start** 将会是 **15**（0 + **limit**（15）= 15），**limit**
    将保持 **15**（除非我们动态更改 `pageSize`，否则此值不会改变），而 **page** 将是 **2**。这可以通过以下图示来演示：
- en: '![Handling paging on the server side](img/0457OT_08_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![处理服务器端分页](img/0457OT_08_09.jpg)'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a third-party plugin that can change `pageSize` dynamically according
    to the user's selection at [https://github.com/loiane/extjs4-ux-paging-toolbar-resizer](https://github.com/loiane/extjs4-ux-paging-toolbar-resizer).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个第三方插件可以根据用户的选项动态更改 `pageSize`，请参阅 [https://github.com/loiane/extjs4-ux-paging-toolbar-resizer](https://github.com/loiane/extjs4-ux-paging-toolbar-resizer)。
- en: 'These parameters help us to page the information on the database as well. For
    example, for MySQL, we only need `start` and `limit`, so we need to get them from
    the request, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数帮助我们分页数据库上的信息。例如，对于 MySQL，我们只需要 `start` 和 `limit`，因此我们需要从请求中获取它们，如下所示：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, when we execute the `SELECT` query, we need to add `LIMIT $start, $limit`
    at the end (after the `WHERE`, `ORDER BY`, `GROUP BY` clauses, if any):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们执行 `SELECT` 查询时，我们需要在末尾添加 `LIMIT $start, $limit`（在 `WHERE`、`ORDER BY`、`GROUP
    BY` 子句之后，如果有这些子句）：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will bring the information we need from the database.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从数据库中获取我们所需的信息。
- en: 'Another very important detail is that the PagingToolbar displays the total
    number of records we have on the database:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常重要的细节是，分页工具栏显示了我们在数据库上拥有的总记录数：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, we also need to return a `total` property on the JSON with the count of
    the table:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还需要在 JSON 中返回一个 `total` 属性，包含表的计数：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then Ext JS will receive all the information required to make the paging work
    as expected.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 Ext JS 将接收到所有必需的信息，以便按预期工作分页。
- en: Paging queries on MySQL, Oracle, and Microsoft SQL Server
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: MySQL、Oracle 和 Microsoft SQL Server 的分页查询
- en: We need to be careful because if we use a different database, the query to page
    the information directly from the database is different.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心，因为如果我们使用不同的数据库，直接从数据库分页查询信息的方式就不同。
- en: 'If we were using the Oracle database, the `SELECT` query with paging would
    be as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是 Oracle 数据库，带有分页的 `SELECT` 查询如下所示：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This would be much more complicated than MySQL. Now let''s see Microsoft SQL
    Server (SQL Server 2012):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将比 MySQL 复杂得多。现在让我们看看 Microsoft SQL Server（SQL Server 2012）：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In SQL Server 2012**,** it is simpler:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 2012**中**，这要简单得多：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Firebird**,** it is also simpler than MySQL:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Firebird**中**，这比 MySQL 简单：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So be careful with the SQL syntax if you are using a different database than
    MySQL.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你使用的是不同于 MySQL 的数据库，请小心 SQL 语法。
- en: Creating the films container
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建电影容器
- en: 'The next step is creating the **Films** screen that we presented at the beginning
    of this chapter. It consists of a toolbar with a button (**Add**), the Films grid,
    and two associated grids (Categories and Actors). We are going to create this
    View in the `Films.js` file, as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建我们在本章开头提到的 **Films** 屏幕。它由一个带有按钮（**添加**）的工具栏、电影网格和两个相关网格（类别和演员）组成。我们将在这个
    `Films.js` 文件中创建这个视图，如下所示：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this class, we declared a ViewController (`#1`) and also the ViewModel (`#2`).
    The ViewModel was already created, so we need to create the ViewController.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们声明了一个 ViewController (`#1`) 和 ViewModel (`#2`)。ViewModel 已经创建，因此我们需要创建
    ViewController。
- en: Next, we have `session` (`#3`). If provided, this creates a new session instance
    for this component. As this class is a container for other classes, the session
    will then be inherited by all child components. We will dive into the session
    when we work in the ViewController.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有 `session` (`#3`)。如果提供，将为该组件创建一个新的会话实例。由于这个类是其他类的容器，因此会话将被所有子组件继承。当我们工作在
    ViewController 时，我们将深入研究会话。
- en: In line `#4`, we have the `FilmsGrid` class we created. And in lines `#5` and
    `#6` ,we have the `categories` and `actors` grid that we will use to display the
    many-to-many association.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `#4` 行，我们有我们创建的 `FilmsGrid` 类。在第 `#5` 和 `#6` 行，我们有 `categories` 和 `actors`
    网格，我们将使用它们来显示多对多关联。
- en: 'We also have `TopToolBar` declared in line `#7`. This toolbar was created separately,
    so we can reuse it, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在第 `#7` 行声明了 `TopToolBar`。这个工具栏是单独创建的，因此我们可以重用它，如下所示：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We cannot forget to update the `menu` table to reflect the films `xtype`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忘记更新 `menu` 表以反映电影的 `xtype`：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will be adding more buttons to this toolbar in the next chapter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中向这个工具栏添加更多按钮。
- en: Handling many-to-many associations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理多对多关联
- en: The `film` and `category` tables are associated by a many-to-many relationship.
    When this happens, a matrix table is created with two columns to hold the IDs
    of a pair of related entities. There is a matrix table representing the many-to-many
    relationship between the `film` and `category` tables, called `film_category`
    and a table called `film_actor` representing the many-to-many relationship between
    `film` and `actor`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`film`和`category`表通过多对多关系相关联。当这种情况发生时，会创建一个矩阵表，包含两列以存储相关实体的ID对。有一个矩阵表代表`film`和`category`表之间的多对多关系，称为`film_category`，还有一个称为`film_actor`的表代表`film`和`actor`之间的多对多关系。'
- en: 'To represent a many-to-many relationship in Ext JS, we will add the following
    code to the `Film` Model:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Ext JS中表示多对多关系，我们需要将以下代码添加到`Film`模型中：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For each many-to-many relationship, we need to define a `name` (`#1`). The name
    must be unique within the schema. We also need to define a `type` (`#2`). The
    `type` is the name of the `model` of the association—we can use `entityName` to
    define the associated Model. We can also define `role` (`#3`), which will be the
    name of the method generated to retrieve the associated data. We also need to
    specify the foreign key (`#4`) used to identify the association. As the many-to-many
    relationship is created between two tables, we can also specify the information
    that links this Model to the matrix table, which is the `field` (foreign key—`#5`)
    and also the `role` of the association in the `Category` and `Actor` models (`#6`).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个多对多关系，我们需要定义一个`名称`（`#1`）。该名称必须在模式内是唯一的。我们还需要定义一个`类型`（`#2`）。`类型`是关联`模型`的名称——我们可以使用`entityName`来定义关联的模型。我们还可以定义`角色`（`#3`），这将作为生成以检索关联数据的方法的名称。我们还需要指定用于标识关联的外键（`#4`）。由于多对多关系是在两个表之间创建的，我们还可以指定将此模型链接到矩阵表的信息，即`字段`（外键——`#5`）以及`关联`在`Category`和`Actor`模型中的`角色`（`#6`）。
- en: 'In the `Category` Model, we will also declare the many-to-many association:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Category`模型中，我们还将声明多对多关联：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And we will do this inside the `Actor` Model as well:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样在`Actor`模型内部执行此操作：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Loading nested JSON from the server
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从服务器加载嵌套JSON
- en: 'In the server-side code, we need to retrieve the film information and its categories
    and actors as well. The JSON that the server will return to Ext JS will have the
    following format:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端代码中，我们需要检索电影信息及其类别和演员。服务器将返回给Ext JS的JSON将具有以下格式：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The server-side code is included within the source code of this book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端代码包含在此书的源代码中。
- en: 'If we inspect a `Film` Model instance of the `films` Store, we will see that
    a function/method is created for each of the associations, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查`films` Store的`Film`模型实例，我们会看到为每个关联创建了一个函数/方法，如下所示：
- en: '![Loading nested JSON from the server](img/0457OT_08_10.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![从服务器加载嵌套JSON](img/0457OT_08_10.jpg)'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When accessing `model.actors()` or `model.categories()`, the methods will return
    a Store for each association and not an array of the `Actor` or `Category` Model.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问`model.actors()`或`model.categories()`时，方法将返回每个关联的Store，而不是`Actor`或`Category`模型的数组。
- en: Changing the ViewModel – chained stores
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改ViewModel – 连锁store
- en: 'Ext JS will understand the association and will be able to create the methods
    and associated stores, but we need to add the stores to the session as well by
    adding the `actors` and `categories` Store in the same ViewModel, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS将理解这种关联，并能够创建方法和关联的store，但我们需要通过在相同的ViewModel中添加`actors`和`categories`
    Store来将store添加到会话中，如下所示：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note the highlighted code. The stores we are creating use existing stores (which
    we created in the preceding chapter, and which are available in the global scope
    of the application through their `storeId`) through a `source` configuration.
    This capability was also introduced in Ext JS 5, and it is called a chained store
    (`Ext.data.ChainedStore`). A chained store is a store that is a view of an existing
    store. The data comes from the `source`; however, this view of the store can be
    sorted and filtered independently without having any impact on the source store.
    This is very useful when we want to have two different stores with synchronized
    data, but independent instances.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意高亮的代码。我们正在创建的stores使用现有的stores（我们在上一章中创建的，并且可以通过它们的`storeId`在应用程序的全局范围内访问）通过`source`配置。这种能力也在Ext
    JS 5中引入，被称为链式store（`Ext.data.ChainedStore`）。链式store是一个现有store的视图。数据来自`source`；然而，这个store的视图可以独立地进行排序和过滤，而不会对源store产生影响。当我们想要有两个不同但数据同步的独立实例时，这非常有用。
- en: Film-Actor – handling many-to-many associations
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Film-Actor – 处理多对多关联
- en: 'Now that we have the many-to-many association in place, we can create the `FilmActorsGrid`
    class. This class will have the following content:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了多对多关联，我们可以创建`FilmActorsGrid`类。这个类将包含以下内容：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This grid contains a column we have not used so far, which is the Template Column.
    When using this column, you can create a template to display more than one field
    (`#2`) instead of using a `renderer` function to do so.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网格包含一个我们迄今为止尚未使用的列，即模板列。当使用这个列时，你可以创建一个模板来显示多个字段（`#2`），而不是使用`renderer`函数来做到这一点。
- en: The preceding code presents how to display associated data in a detail grid.
    When we select a film from the `FilmsGrid`, the Actors grid will automatically
    display the associated data by binding the `actors` (role of the association)
    with the Actors grid (`#1`).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码展示了如何在详细网格中显示关联数据。当我们从`FilmsGrid`中选择一部电影时，Actors网格将自动通过将`actors`（关联的角色）与Actors网格绑定（`#1`）来显示关联数据。
- en: Film-Category – handling many-to-many associations
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Film-Category – 处理多对多关联
- en: 'We will use the same approach used for the Film-Actor many-to-many associations
    for the Film-Category many-to-many associations. We will create a class named
    `FilmCategoriesGrid`. This class will have the following content:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与Film-Actor多对多关联相同的处理方法来处理Film-Category多对多关联。我们将创建一个名为`FilmCategoriesGrid`的类。这个类将包含以下内容：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We will also `bind` the Store of this grid to the data loaded from the association
    (`#1`).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`绑定`这个网格的Store到从关联（`#1`）加载的数据。
- en: Creating the ViewController
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ViewController
- en: 'The missing piece now is the ViewController, which will handle all the handlers
    and listeners declared in our code. We will split the code into two classes: the
    `base.ViewController` that contains generic code and can be reused, and the `film.FilmsController`
    that contains the code to handle specific details of the `Films` View.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在缺少的部分是ViewController，它将处理我们在代码中声明的所有处理程序和监听器。我们将代码分成两个类：包含通用代码并可重用的`base.ViewController`，以及包含处理`Films`视图特定细节的代码的`film.FilmsController`。
- en: The base ViewController
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础ViewController
- en: Inside this class, we will put all the generic code that can be reused by other
    views that have the same behavior as the `Films` View. For example, editing or
    deleting a record by clicking on a button of a Widget Column opens the pop-up
    window. If the user clicks on the **Add** button, then close the pop-up window
    that is used to create or edit information.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将放置所有可以被具有与`Films`视图相同行为的其他视图重用的通用代码。例如，通过点击Widget列的按钮来编辑或删除记录会打开弹出窗口。如果用户点击**添加**按钮，然后关闭用于创建或编辑信息的弹出窗口。
- en: 'The code for this class is presented as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的代码如下所示：
- en: '[PRE25]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding chapter, you learned that it is possible to create a generic
    Controller in MVC to handle events from multiple screens. It was implemented using
    a generic selector from the components we created. In MVVM, it is also possible
    to create a generic ViewController, but not using a generic selector (because
    we do not work with selectors in MVVM). This is possible if we set a pattern of
    listeners (the components will have the same `handler` name), and declare a generic
    ViewController. However, we also need to specify a specific ViewController for
    the View, and this ViewContoller is going to extend our base ViewController. Generic
    code in ViewController is handled by inheritance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你了解到在MVC中创建一个通用的控制器来处理来自多个屏幕的事件是可能的。它是通过使用我们创建的组件的通用选择器来实现的。在MVVM中，也可以创建一个通用的`ViewController`，但不是使用通用选择器（因为我们不与选择器一起工作）。这是可能的，如果我们设置一个监听器模式（组件将具有相同的`handler`名称），并声明一个通用的`ViewController`。然而，我们还需要为视图指定一个特定的`ViewController`，这个`ViewController`将扩展我们的基本`ViewController`。`ViewController`中的通用代码通过继承来处理。
- en: 'In the `FilmsGrid`, class we have two handlers: one for the **Edit** Widget
    Button and one for the **Delete** Widget Button.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FilmsGrid`类中，我们有两个处理程序：一个用于**编辑**Widget按钮和一个用于**删除**Widget按钮。
- en: For the **Delete** button (`#4`), all we have to do is ask whether the user
    is certain that they want to delete the `record`, and then if we receive a positive
    response, we use the `record.drop()` method to do it. The `drop` method marks
    the record as dropped and waiting to be deleted on the server. When a record is
    dropped, it is automatically removed from all association stores, and any child
    record associated with this record is also dropped (a cascade delete) depending
    on the cascade parameter. As the View and the Store are associated with a session,
    when we call the method `drop`, the session records that this record and its associated
    data need to be deleted, and the Store is also notified. We could also use the
    remove method from the Store; it would have the same output.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**删除**按钮（`#4`），我们只需要询问用户是否确定要删除`记录`，然后如果我们收到积极的回应，我们使用`record.drop()`方法来执行删除。`drop`方法将记录标记为已删除并等待在服务器上删除。当记录被删除时，它将自动从所有关联存储中移除，并且与该记录关联的任何子记录也将被删除（级联删除），具体取决于级联参数。由于视图和存储与会话相关联，当我们调用`drop`方法时，会话记录将此记录及其关联数据需要被删除，并且存储也会被通知。我们也可以使用存储的`remove`方法；它会产生相同的结果。
- en: For the **Add** (`#1`) and **Edit** (`#2`) handlers, we want to open the **Edit**
    window so that we can modify or create a new film. We are going to use the same
    approach we used in [Chapter 6](ch06.html "Chapter 6. User Management"), *User
    Management*, when we handled `Users` and `Groups`. The `createDialog` method will
    be created in the specific ViewController, which is the `FilmsController` class
    we will create next. This way we can have a generic code, but the details will
    be implemented in the specific ViewController.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 对于**添加**（`#1`）和**编辑**（`#2`）处理程序，我们希望打开**编辑**窗口，以便我们可以修改或创建一个新的电影。我们将使用我们在[第6章](ch06.html
    "第6章。用户管理")中处理`Users`和`Groups`时使用的方法。`createDialog`方法将在特定的`ViewController`中创建，即我们将创建的`FilmsController`类。这样我们就可以有通用代码，但细节将在特定的`ViewController`中实现。
- en: A detail for the `edit` and `delete` handlers is that we can easily use the
    method `getWidgetRecord` from the button (Widget Column) to retrieve the `record`
    from the grid. This approach is very different from the approach we used in the
    preceding chapter (where we created a custom event to be handled in the MVC Controller).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`edit`和`delete`处理程序的一个细节是，我们可以轻松地使用按钮（Widget列）中的`getWidgetRecord`方法从网格中检索`record`。这种方法与我们前一章中使用的方法非常不同（在那里我们在MVC控制器中创建了一个自定义事件来处理）。
- en: Just as we did in [Chapter 6](ch06.html "Chapter 6. User Management"), *User
    Management*, we will create the **Edit** window, and it will have a **Cancel**
    button. When the user clicks on this button, we will destroy the window (`#3`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在[第6章](ch06.html "第6章。用户管理")中做的那样，*用户管理*，我们将创建**编辑**窗口，并且它将包含一个**取消**按钮。当用户点击此按钮时，我们将销毁该窗口（`#3`）。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can go back to [Chapter 6](ch06.html "Chapter 6. User Management"), *User
    Management*, and modify the code to use this ViewController as well.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回到[第6章](ch06.html "第6章。用户管理")，并修改代码以使用这个`ViewController`。
- en: Creating the FilmsController
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建`FilmsController`
- en: 'Now we are going to implement the ViewController for the `Films` View. Its
    initial code is presented here; in the subsequent topics, we will add more code
    to it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将实现`Films`视图的`ViewController`。它的初始代码如下；在随后的主题中，我们将向其中添加更多代码：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding or editing a film
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加或编辑电影
- en: Now that `FilmsGrid` is already being rendered and loaded and the `add` and
    `edit` handlers are in place in the ViewController, we need to create the `createDialog`
    method. But first, we need to create the `Edit` window class.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`FilmsGrid`已经被渲染和加载，并且`add`和`edit`处理程序已经在`ViewController`中就位，我们需要创建`createDialog`方法。但首先，我们需要创建`Edit`窗口类。
- en: 'As we could see in the screenshots at the beginning of this chapter, the **Edit**
    window has three tabs: one for editing the film details, another one to edit the
    categories related to the film, and the third one to edit the actors related to
    the film. For now, we are going to deal with the film details only.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章开头的屏幕截图中所见，**编辑**窗口有三个标签：一个用于编辑电影详情，另一个用于编辑与电影相关的类别，第三个用于编辑与电影相关的演员。目前，我们将只处理电影详情。
- en: 'So, inside `app/view/film`, we are going to create a new view named `Packt.view.film.FilmWindow`.
    This class will be a window that has a form with a TabPanel as an `item`. Inside
    each of the tabs, we will place the film''s details, the categories, and the actors,
    as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`app/view/film`中，我们将创建一个新的视图名为`Packt.view.film.FilmWindow`。这个类将是一个包含具有标签面板作为`item`的表单的窗口。在每个标签中，我们将放置电影的详情、类别和演员，如下所示：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This window extends from a custom class (`#1`) that we are going to create.
    As for the creation and editing of grid rows, we always use a window, so we can
    create a super window class with the common configuration and use it throughout
    our application. We will create this new class in a minute; let's finish overviewing
    this class first. We cannot forget to declare an `xtype` configuration (`#2`);
    we will use this `xtype` configuration in the ViewController later.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口扩展自我们将要创建的自定义类（`#1`）。至于网格行的创建和编辑，我们总是使用窗口，因此我们可以创建一个具有通用配置的超级窗口类，并在我们的应用程序中使用它。我们将在一分钟内创建这个新类；让我们首先完成对这个类的概述。我们不能忘记声明一个`xtype`配置（`#2`）；我们将在`ViewController`中稍后使用这个`xtype`配置。
- en: Inside this window, we have a form (`#3`), to which we need to declare a reference
    to easily retrieve in the ViewController. Inside the form we have a TabPanel (`#4`),
    which contains a tab with the film information (`#5`)—we are going to create a
    separate class for it, and the categories (`#6`), for which we are also going
    to create a separate class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个窗口内部，我们有一个表单（`#3`），我们需要声明一个引用以便在`ViewController`中轻松检索。在表单内部，我们有一个标签面板（`#4`），其中包含一个包含电影信息的标签（`#5`）——我们将为它创建一个单独的类，以及类别（`#6`），我们也将为它创建一个单独的类。
- en: 'The last piece of this class is the actors details that are presented in the
    following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的最后一部分是以下代码中展示的演员详情：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For the actors details, we are going to reuse the `Actors` grid (`#7`) displayed
    in the `Films` View. We are going to add a reference as well (`#8`), because it
    is going to be useful when we work on the **Search and Add** screen to handle
    the `onAddActor` (`#9`) listener. And at last, we also need a listener for the
    delete button (`#10`).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于演员详情，我们将重用`Films`视图中显示的`Actors`网格（`#7`）。我们还将添加一个引用（`#8`），因为它在我们处理**搜索和添加**屏幕上的`onAddActor`（`#9`）监听器时将非常有用。最后，我们还需要一个用于删除按钮的监听器（`#10`）。
- en: The **Add** and **Delete** actor buttons are going to add and delete entries
    of the `film_actor` table.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**添加**和**删除**演员按钮将向`film_actor`表中添加和删除条目。'
- en: Packt.view.base.WindowForm
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Packt.view.base.WindowForm
- en: 'All the **Edit** windows we have already implemented are a window with Fit
    layout and usually have a FormPanel inside it. The window also has a **Cancel**
    and a **Save** button. As all these configurations are default for our components,
    we can create a super window for them:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现的所有**编辑**窗口都是一个具有适应布局的窗口，通常在其中包含一个表单面板。该窗口还包含一个**取消**和一个**保存**按钮。由于所有这些配置都是我们组件的默认配置，我们可以为它们创建一个超级窗口：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that we are not declaring a configuration inside the `initConfig` method
    (which is not present in this class). This means this class is a base, and anything
    can be overridden in a child class.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`initConfig`方法中没有声明配置（这个方法在这个类中不存在）。这意味着这个类是一个基础类，任何东西都可以在子类中被覆盖。
- en: An important detail here is that the `title` (`#1`) and the `glyph` (`#2`) configurations
    used in this window can be bound to the information from the ViewModel. We will
    handle these details in the `createDialog` method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个重要的细节是，在这个窗口中使用的`标题`（`#1`）和`图标`（`#2`）配置可以绑定到ViewModel的信息。我们将在`createDialog`方法中处理这些细节。
- en: 'This window class uses `CancelSaveToolbar`. The code for this toolbar is as
    follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口类使用`CancelSaveToolbar`。这个工具栏的代码如下：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Inside the preceding class there are `listeners` for the **Save** button (`#3`),
    which we are going to handle inside the `FilmsController` class and for the **Cancel**
    button (`#4`), which is handled by the base ViewController class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的类中，有对**保存**按钮（`#3`）的`监听器`，我们将在`FilmsController`类中处理它，以及对于**取消**按钮（`#4`），它由基础`ViewController`类处理。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'We can go back to the code we implemented in [Chapter 6](ch06.html "Chapter 6. User
    Management"), *User Management*, and [Chapter 7](ch07.html "Chapter 7. Static
    Data Management"), *Static Data Management*, and refactor to use the base classes
    and toolbar classes. This is what is nice about Ext JS and its object-oriented
    approach: it allows you to reuse code, and you can refactor it as you can do in
    any other object-oriented language, and there are no headaches involved.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以回到我们在[第6章](ch06.html "第6章。用户管理")中实现的代码，*用户管理*和[第7章](ch07.html "第7章。静态数据管理")，*静态数据管理*，并进行重构以使用基础类和工具栏类。这就是Ext
    JS及其面向对象方法的好处：它允许你重用代码，并且你可以像在其他面向对象语言中一样重构它，而且没有头痛的问题。
- en: The films form
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电影表单
- en: The first item of the TabPanel (`#3`) is the `film-form-container`. Inside this
    class, we are going to declare all the fields that represent the columns of the
    `film` table.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: TabPanel的第一个项目是`film-form-container`。在这个类中，我们将声明所有代表`film`表列的字段。
- en: 'Let''s go back to the Sakila documentation and take a look at the fields of
    the `film` table ([http://dev.mysql.com/doc/sakila/en/sakila-structure-tables-film.html](http://dev.mysql.com/doc/sakila/en/sakila-structure-tables-film.html)).
    You can also refer to the first image of this chapter:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到Sakila文档，看看`film`表的字段（[http://dev.mysql.com/doc/sakila/en/sakila-structure-tables-film.html](http://dev.mysql.com/doc/sakila/en/sakila-structure-tables-film.html)）。您也可以参考本章的第一张图片：
- en: '`film_id`: This is the primary key of the table and has a unique value. So,
    for this field, we can use a hidden field to control this.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`film_id`: 这是表的主键，具有唯一值。因此，对于这个字段，我们可以使用隐藏字段来控制它。'
- en: '`title`: This is the title of the film. So, we can use a text field for it.
    The maximum length on the database is 255, so we also need to add validation.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标题`: 这是电影的标题。因此，我们可以为它使用一个文本字段。数据库中的最大长度为255，因此我们还需要添加验证。'
- en: '`description`: This is a short description or plot summary of the film. As
    the description can be 5,000 characters in length, we can use a text area to represent
    it.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`: 这是电影的简短描述或剧情摘要。由于描述长度可达5,000个字符，我们可以使用文本区域来表示它。'
- en: '`release_year`: This is the year in which the movie was released. This can
    be a numeric field, with a minimum value of 1950 until the current year + 1 (let''s
    say we want to add a film that is going to be released next year).'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`release_year`: 这是电影发布的年份。这可以是一个数值字段，最小值为1950年，直到当前年份加1（比如说我们想要添加一部明年将要上映的电影）。'
- en: '`language_id`: This is a foreign key pointing at the language table. It identifies
    the language of the film. This can be a combobox with the language Store (already
    populated when we load the application).'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language_id`: 这是一个指向语言表的键。它标识电影的语种。这可以是一个带有语言存储的组合框（当加载应用程序时已经填充）。'
- en: '`original_language_id`: This is a foreign key pointing at the language table
    that identifies the original language of the film. This is used when a film has
    been dubbed in a new language. Also, this can be a combobox with the language
    Store (already populated when we load the application).'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`original_language_id`: 这是一个指向语言表的键，用于标识电影的原始语言。当电影被翻译成新语言时使用。此外，这可以是一个带有语言存储的组合框（当加载应用程序时已经填充）。'
- en: '`rental_duration`: This is the length of the rental period in days. This can
    be a number field, with a minimum value of `1` and maximum value of `10` (let''s
    give a limit to the maximum value).'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rental_duration`: 这是租赁期限的天数。这可以是一个数字字段，最小值为`1`，最大值为`10`（让我们给最大值设置一个限制）。'
- en: '`rental_rate`: This is the cost to rent the film for the period specified in
    the `rental_duration` column. This can also be a number field. The minimum value
    is `0` and the maximum value is `5`, and we need to allow decimal values as well.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rental_rate`：这是在`rental_duration`列指定的期间租用电影的费用。这也可以是一个数字字段。最小值是`0`，最大值是`5`，并且我们需要允许小数值。'
- en: '`length`: This is the duration of the film in minutes. The `length` column
    can also be a number field between 1 and 999.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`length`：这是电影以分钟为单位的时间长度。`length`列也可以是一个介于1到999之间的数值字段。'
- en: '`replacement_cost`: This is the amount charged to the customer if the film
    is not returned or is returned in a damaged state. This is also a numeric field.
    Let''s give a minimum value of `0` and maximum value of `100`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replacement_cost`：这是如果电影未归还或损坏归还时向客户收取的金额。这也是一个数值字段。让我们设置最小值为`0`，最大值为`100`。'
- en: '`rating`: This is the rating assigned to the film. It can be one of `G`, `PG`,
    `PG-13`, `R`, or `NC-17`. As these have fixed values, we can represent them on
    a radio button group or a Combobox. We are going to use a Combobox.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rating`：这是分配给电影的评级。它可以是一组`G`、`PG`、`PG-13`、`R`或`NC-17`中的任何一个。由于这些有固定值，我们可以在单选按钮组或组合框中代表它们。我们将使用组合框。'
- en: '`special_features`: This lists which common special features are included on
    the DVD. It can be zero or more of trailers, commentaries, deleted scenes, and
    behind the scenes. As this can be one or more, we can use the TagField introduced
    in Ext JS 5\. We can also use checkboxes or a combobox allowing multiple selection.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`special_features`：这列出了DVD上包含哪些常见的特殊功能。它可以包括零个或多个预告片、评论、删减场景和幕后花絮。由于这可以是一个或多个，我们可以使用Ext
    JS 5中引入的TagField。我们还可以使用复选框或允许多选的组合框。'
- en: 'Let''s declare the class structure first, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们声明类结构，如下所示：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The fields will be inside a panel (which will become a tab) that uses the Anchor
    layout, and each field will occupy all available horizontal space (`anchor: 100%`).
    The labels are `105` pixels wide, and any error messages will be displayed on
    the `side` of the field. There has been no news for us so far.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '字段将位于一个使用锚布局的面板（它将成为一个标签页）内，每个字段将占用所有可用的水平空间（`anchor: 100%`）。标签宽度为`105`像素，任何错误信息都将显示在字段的`side`上。到目前为止，我们还没有收到任何消息。'
- en: 'Let''s declare the first two fields—`title` and `release_year`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明前两个字段——`title`和`release_year`：
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Both values are bound (`#1` and `#3`) to the fields of a record called `currentFilm`
    (that we will create in `FilmsController` later). `Release Year` is a numeric
    field, and as we want the value to be an integer, we will not allow the user to
    enter decimal numbers (`#2`).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个值都绑定到名为`currentFilm`的记录的字段上（我们将在`FilmsController`中稍后创建）。`Release Year`是一个数值字段，由于我们希望值是整数，因此不允许用户输入小数（`#2`）。
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: For more information about forms and field validation, please refer to [http://docs.sencha.com/extjs/5.0/components/forms.html](http://docs.sencha.com/extjs/5.0/components/forms.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 关于表单和字段验证的更多信息，请参阅[http://docs.sencha.com/extjs/5.0/components/forms.html](http://docs.sencha.com/extjs/5.0/components/forms.html)。
- en: 'Next, we have the language fields, which are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有语言字段，如下所示：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As both comboboxes represent language, their configuration is going to be exactly
    the same except for `fieldLabel` and `bind` (`#5` and `#6`).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个组合框都代表语言，它们的配置将完全相同，除了`fieldLabel`和`bind`（`#5`和`#6`）。
- en: Note that we are using the same Store for both fields (`#4`) and we want them
    to have the same values, which means that if the user goes to the language GridPanel
    on static data and add or change a language, we want these changes to be applied
    to these stores at the same time, and that is why we are using the same Store
    as used by static data module.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用相同的存储器（`#4`）来处理这两个字段，并且我们希望它们具有相同的值，这意味着如果用户在静态数据的语言GridPanel中添加或更改语言，我们希望这些更改同时应用于这些存储器，这就是为什么我们使用与静态数据模块相同的存储器。
- en: 'Then we have four numeric fields: `rental_duration`, `rental_rate`, `length`,
    and `replacement_cost`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有四个数值字段：`rental_duration`、`rental_rate`、`length`和`replacement_cost`：
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One thing is very important: whenever we have numeric fields and we want to
    load them from a Model, we need the field from the Model to be numeric as well
    (`int` or `float`); otherwise, the form will not load the values properly.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事非常重要：无论何时我们都有数值字段并且想要从模型中加载它们，我们需要模型中的字段也是数值的（`int`或`float`）；否则，表单将无法正确加载值。
- en: 'Then we have the rating combobox with its `store`, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有带有其`store`的评级组合框，如下所示：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have the combobox `value` (`#6`) and a `store` (`#7`) bound to this `combobox`.
    We are going to create this Store in `FilmsModel`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个与这个组合框绑定的`value`（`#6`）和一个`store`（`#7`）。我们将在`FilmsModel`中创建这个Store。
- en: 'And at last, we have `tagfield` and `textareafield`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`tagfield`和`textareafield`：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Tag field was introduced in Ext JS 5, and its behavior is very similar to that
    of a combobox that allows you to select multiple values. To set the selected values,
    we need to pass an array (`#8`). In the `Film` Model, `special_features` is a
    string. For this reason, we will handle these values in the ViewModel as well
    using a formula. We are also going to create a `store` configuration (`#9`) in
    the ViewModel to represent this static Store.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Tag field是在Ext JS 5中引入的，其行为与允许您选择多个值的组合框非常相似。为了设置选定的值，我们需要传递一个数组（`#8`）。在`Film`模型中，`special_features`是一个字符串。因此，我们将在ViewModel中也使用公式来处理这些值。我们还将创建一个`store`配置（`#9`）在ViewModel中来表示这个静态Store。
- en: Film categories
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电影分类
- en: Now that we have the film details part covered, we can handle the most complex
    part, which is the association with the `category` and `actor` tables. The `category`
    and `actor` tables have a many-to-many association with the `film` table.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了电影详情部分，我们可以处理最复杂的部分，即与`分类`和`演员`表的关联。`分类`和`演员`表与`电影`表有多个对多个的关联。
- en: 'As declared inside the films form, we are going to declare a new class to represent
    this tab:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如在电影表单中声明的那样，我们将声明一个新的类来表示这个标签页：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This class contains a `multiselector`, which is a new component introduced in
    Ext JS 5\. It created a grid to render the selected values, and it is also going
    to display a red cross sign to remove unwanted values. We can set any selected
    values in its Store (`#1`). This component also allows you to add values using
    the plus sign that is configured by the `search` configuration. We also need to
    set a `store` (`#2`) to feed the options the user can select.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包含一个`多选器`，这是Ext JS 5中引入的新组件。它创建了一个网格来渲染选定的值，并且它还将显示一个红色交叉符号来移除不需要的值。我们可以在其Store（`#1`）中设置任何选定的值。此组件还允许您使用由`search`配置设置的加号添加值。我们还需要设置一个`store`（`#2`）来提供用户可以选择的选项。
- en: Film Actors
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电影演员
- en: The actor relationship with the film is very similar to the relationship between
    `category` and `film` tables, meaning it is also a many-to-many relationship.
    We will handle the `actor` tables' many-to-many relationship in a way that is
    different from how we handled `film_categories`. As the available options for
    categories are limited, we could use a `multiselector` component to represent
    it. We do not know how many actors we can have in our database, so it is a little
    bit more complicated. The approach we are going to use here is to display a grid
    to render the selected actors and have an **Add** button so that the user can
    search for and add desired values.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 与电影的关系，演员与电影的关系非常类似于`分类`和`电影`表之间的关系，意味着它也是一个多对多关系。我们将以与处理`电影分类`不同的方式来处理`演员`表的多对多关系。由于可用的分类选项有限，我们可以使用`多选器`组件来表示它。我们不知道我们数据库中可以有多少演员，所以这要复杂一些。我们将采用的方法是显示一个网格来渲染选定的演员，并有一个**添加**按钮，以便用户可以搜索并添加所需值。
- en: We have declared the grid inside the `FilmWindow` class already. What is pending
    is the class that will display a pop up so that we can search for available Actors.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`FilmWindow`类内部声明了网格。待定的是将显示弹出窗口以搜索可用演员的类。
- en: Search Actors – Live Search combobox
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索演员 – 实时搜索组合框
- en: The idea of the Live Search combobox is to display the **Search** screen for
    the user and a combobox field, where the user can enter a few characters and then
    the system will do a live search, displaying the actors that match the search
    made by the user. All the actors that match the search will be displayed as items
    of the combobox, and the combobox will also have paging. When the user selects
    the actor, we will display its `last_name` and `first_name`. Along with the actor
    name, we will also display a list of films this actor has acted in.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Live Search组合框的想法是为用户显示**搜索**屏幕和一个组合框字段，用户可以在其中输入几个字符，然后系统将进行实时搜索，显示与用户搜索匹配的演员。所有与搜索匹配的演员都将显示为组合框的项目，组合框还将具有分页功能。当用户选择演员时，我们将显示其`last_name`和`first_name`。除了演员姓名外，我们还将显示该演员出演的电影列表。
- en: Model
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 模型
- en: 'First, we need a Model to represent the information we want to retrieve from
    the server. We will retrieve the actors information plus the film the actor already
    made. So, we can create a Model extending from the `Actor` Model, and in the `SearchActor`
    Model, we only need to declare the missing field:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个模型来表示从服务器检索的信息。我们将检索演员信息以及该演员已经制作的电影。因此，我们可以创建一个从`Actor`模型扩展的模型，在`SearchActor`模型中，我们只需要声明缺失的字段：
- en: '[PRE38]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Store
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 存储
- en: 'Next, we need a Store to load the `SearchActor` Model collection, as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个存储库来加载`SearchActor`模型集合，如下所示：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the server, we will use the `actor_info` view to retrieve the information.
    However, the combobox also passes three extra parameters: `start` and `limit`
    for the paging and a parameter named `query` with the text the user entered to
    do the live search.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，我们将使用`actor_info`视图来检索信息。然而，组合框还传递了三个额外的参数：用于分页的`start`和`limit`，以及一个名为`query`的参数，包含用户输入的用于实时搜索的文本。
- en: 'Our `SELECT` query will be something like the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SELECT`查询将类似于以下内容：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And as we are working with paging, we cannot forget to `COUNT` how many records
    we have that match the search and return the result inside the `total` attribute
    of the JSON:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理分页，我们不能忘记计算与搜索匹配的记录数，并将结果返回到JSON的`total`属性中：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: And now, we are able to retrieve the information according to the search text
    entered by the user.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够根据用户输入的搜索文本检索信息。
- en: Live Search combobox
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实时搜索组合框
- en: 'Our next step now is to implement the view that is going to provide the tools
    for searching. So, we are going to create a class that extends from `Ext.window.Window`,
    and inside this class, we will have a combobox that will provide all the features
    to do the Live Search. The code is presented as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的步骤是实现将要提供搜索工具的视图。因此，我们将创建一个从`Ext.window.Window`扩展的类，在这个类中，我们将有一个组合框，它将提供所有进行实时搜索的功能。代码如下所示：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'At the bottom, there''s only a comment for the user to know that they are required
    to enter at least two characters so that the Live Search can work, as shown in
    the following screenshot:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在底部，只有一个注释，提示用户至少输入两个字符，以便实时搜索可以工作，如下面的截图所示：
- en: '![Live Search combobox](img/0457OT_08_11.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![实时搜索组合框](img/0457OT_08_11.jpg)'
- en: 'Now, let''s see the code for the combobox that goes where `#1` is in the previous
    code:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看之前代码中`#1`位置所对应的组合框的代码：
- en: '[PRE43]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To get started, we are going to declare `reference` so that we can easily retrieve
    this component in the ViewController later (`#2`). As always, we need a `store`
    declaration (`#8`) to populate the combobox. In this example, we are instantiating
    the Store by its type. For this reason, we need to declare the full name of the
    Store in the `requires` of this class.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将声明`reference`，这样我们可以在ViewController中轻松检索此组件（`#2`）。像往常一样，我们需要一个`store`声明（`#8`）来填充组合框。在这个例子中，我们通过其类型实例化存储库。因此，我们需要在这个类的`requires`中声明存储库的完整名称。
- en: 'Then we need `displayField` (`#3`). The `displayField` will only show the `first_name`
    of the actor when an actor is selected from the Live Search. However, we want
    to display `last_name` and `first_name`. So to be able to do it, we need to overwrite
    the `displayTpl` template (`#9`). This is the result we will get:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要`displayField`（`#3`）。`displayField`将只显示当从实时搜索中选择演员时的演员的`first_name`。然而，我们希望显示`last_name`和`first_name`。因此，为了能够做到这一点，我们需要重写`displayTpl`模板（`#9`）。这将是我们得到的结果：
- en: '![Live Search combobox](img/0457OT_08_12.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![实时搜索组合框](img/0457OT_08_12.jpg)'
- en: Next, we have `valueField` (`#4`), which is the ID of the selected actor; we
    are going to hide the down arrow (called `trigger`—`#5`) to make the Live Search
    work. The user needs to enter at least two characters (`#6`), and the combobox
    will display only two actors per page (`#7`).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`valueField`（`#4`），它是所选演员的ID；我们将隐藏下拉箭头（称为`trigger`—`#5`），以便实时搜索可以工作。用户需要至少输入两个字符（`#6`），组合框将每页显示两个演员（`#7`）。
- en: Then, we have `listConfig` (`#10`), where we can configure the loading text
    and the empty text, and also the template to display the actor's information.
    Basically, we are displaying `last_name`, `first_name` at the top and in bold,
    and on the next line, we are displaying all the films already made by this actor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有`listConfig`（`#10`），在这里我们可以配置加载文本和空文本，以及显示演员信息的模板。基本上，我们在顶部显示`last_name`和`first_name`并加粗，在下一行显示该演员已经制作的所有电影。
- en: Complementing the ViewModel
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补充ViewModel
- en: 'There are two pending things we need to do in the ViewModel: add the `ratings`
    and `special_features` stores and also implement the `specialFeatures` formula
    that we used to `bind` in the film details form.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ViewModel 中，我们需要完成两个待办事项：添加 `ratings` 和 `special_features` 存储，并实现我们在电影详情表单中使用的
    `specialFeatures` 公式。
- en: 'So let''s begin declaring the stores to our ViewModel, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始声明我们的 ViewModel 中的存储，如下所示：
- en: '[PRE44]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Both stores have predefined `data`, meaning they are an instance of the ArrayStore.
    This kind of Store is very useful in situations like this. The Model both stores
    are using is listed as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个存储都有预定义的 `data`，这意味着它们是 ArrayStore 的实例。这种类型的 Store 在这种情况下非常有用。这两个存储使用的模型如下所示：
- en: '[PRE45]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The Model is very simple, with a single field. We can reuse this Model for any
    Store we create to be used in comboboxes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 模型非常简单，只有一个字段。我们可以为任何创建用于组合框的 Store 重复使用这个模型。
- en: Working with formulas and two-way data binding
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与公式和双向数据绑定一起工作
- en: We created a tag field to declare the special features of a film. This field
    requires an array of values to be set and also an array of values to be returned
    as field values. The out field `special_features` in the Model is a string, which
    clearly is not an array! Until Ext JS 4, we had to encode and decode the values
    manually in a Controller (or somewhere else in the code, but preferably in a Controller).
    With Ext JS 5 and the introduction of the ViewModel we can use a capability called
    formulas.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个标签字段来声明电影的特殊功能。这个字段需要设置一个值数组，并且还需要返回一个值数组作为字段值。模型中的输出字段 `special_features`
    是一个字符串，显然这不是一个数组！直到 Ext JS 4，我们不得不在控制器（或者在代码的其他地方，但最好是控制器）中手动编码和解码值。随着 Ext JS
    5 的推出以及 ViewModel 的引入，我们可以使用一个名为公式的功能。
- en: It is possible to create simple formulas similar to the extra `fields` we can
    declare in a Model (we declare `groupName` in the `User` Model), and it is also
    possible to declare more complex `formulas`. In the Ext JS examples, we can find
    some examples of how to use simple `formulas`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可以创建类似于我们可以在模型中声明的额外 `fields` 的简单公式（我们在 `User` 模型中声明 `groupName`），也可以声明更复杂的
    `formulas`。在 Ext JS 示例中，我们可以找到一些如何使用简单 `formulas` 的示例。
- en: 'Let''s take a look at the formula named `specialFeatures` that we bound to
    `tagfield` in the `FilmFormContainer` class:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看绑定到 `FilmFormContainer` 类中的 `tagfield` 的名为 `specialFeatures` 的公式：
- en: '[PRE46]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The first thing we need to do is give a name to our `formulas` declaration (`#1`).
    We can `bind` our formula to an existing value (such as selection). In our case,
    we are binding to the `special_features` attribute of `currentFilm` ((`#2`)—which
    we will pass to the **Edit** window later in the ViewController). We are also
    specifying that this is a `deep` data binding (`#3`), which means any change that
    happens in `currentFilm.special_features` will update the formula, or any update
    that happens in the formula through its methods will update `currentFilm.special_features`
    as well.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是为我们的 `formulas` 声明命名（`#1`）。我们可以将我们的公式绑定到现有的值（例如选择）。在我们的例子中，我们绑定到
    `currentFilm.special_features` 的 `special_features` 属性（`#2`）——我们将在 ViewController
    中的稍后时间传递给 **编辑** 窗口）。我们还指定这是一个 `deep` 数据绑定（`#3`），这意味着 `currentFilm.special_features`
    中发生的任何更改都将更新公式，或者通过其方法发生的任何更新也将更新 `currentFilm.special_features`。
- en: We can also define a getter and a setter method to a formula. First, we are
    defining a `get` method (`#4`). This method receives the `value` from `currentFilm.special_features`,
    splits the string, and transforms it into an array, and will be used by the tag
    field. Likewise, we have a `set` method (`#5`), which will receive the `value`
    set in the tag field, transform it into a string, and update `currentFilm.special_features`.
    Just keep in mind that `currentFilm` is an instance of the `Film` Model.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为公式定义一个获取器和设置器方法。首先，我们定义一个 `get` 方法（`#4`）。这个方法接收来自 `currentFilm.special_features`
    的 `value`，分割字符串，并将其转换为数组，将被标签字段使用。同样，我们有一个 `set` 方法（`#5`），它将接收在标签字段中设置的 `value`，将其转换为字符串，并更新
    `currentFilm.special_features`。只需记住 `currentFilm` 是 `Film` 模型的实例。
- en: The Films ViewController
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电影 ViewController
- en: In past chapters, we have already covered some examples of how to save data.
    We used the form `submit`, an Ajax `request`, and also the writing resource from
    the Store. In this chapter, let's focus on functionalities we have not implemented
    yet. Do not worry. The complete implementation is available within the source
    code distributed with this book.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经介绍了一些如何保存数据的示例。我们使用了 `submit` 表单、Ajax `request` 以及 Store 中的写入资源。在本章中，让我们关注我们尚未实现的功能。不要担心，完整的实现可以在本书附带源代码中找到。
- en: The createDialog method
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`createDialog` 方法'
- en: We created all the views for our application. In the base **ViewController**,
    we created the handlers for the Add and Edit buttons, and both call the `createDialog`
    method, which we are going to develop now.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的应用程序创建了所有视图。在基础 `ViewController` 中，我们创建了添加和编辑按钮的处理程序，并且两者都调用 `createDialog`
    方法，这是我们接下来要开发的。
- en: 'The idea is to display a blank **Edit** window in case the user clicks on the
    **Add** button, and to display the selected film in case the user clicks on the
    **Edit** button. The source code for this method is as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是，当用户点击 `Add` 按钮时显示一个空的 `Edit` 窗口，而当用户点击 `Edit` 按钮时显示选定的电影。此方法的源代码如下：
- en: '[PRE47]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The first thing we are going to do is get the reference of the View, which is
    the `Films` class (`#1`). Next, we are also going to create an `isEdit` flag (`#2`)
    and assign it to the ViewController so that we can access other methods later
    (such as the `save` method).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是获取视图的引用，即 `Films` 类 (`#1`)。接下来，我们还将创建一个 `isEdit` 标志 (`#2`) 并将其分配给 ViewController，这样我们就可以稍后访问其他方法（如
    `save` 方法）。
- en: Then, we are going to instantiate the **Edit** window, adding it to the View
    (`#3`). When we add a child to the main View, it inherits the ViewModel and the
    ViewController as well. However, in this case, we are setting specific configurations
    to the **Edit** window ViewModel as well (`#4`), meaning it will have access to
    whatever configuration is already there plus the ones we are setting, such as
    `title` and `glyph`, which is predefined `data` (`#5`) to this ViewModel.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将实例化 `Edit` 窗口，将其添加到视图 (`#3`)。当我们向主视图添加子视图时，它将继承 ViewModel 和 ViewController。然而，在这种情况下，我们正在为
    `Edit` 窗口的 ViewModel 设置特定的配置 (`#4`)，这意味着它将能够访问已经存在的配置以及我们设置的配置，例如 `title` 和 `glyph`，这是预定义的数据
    (`#5`)。
- en: Next, we will create a link (`#6`) to a record called `currentFilm` ((`#7`),
    which we used in the bind configurations in the **Edit** window). If it is an
    `edit`, it will link to the selected row in the grid; otherwise, we create a new
    `Film` Model instance.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个链接 (`#6`) 到一个名为 `currentFilm` 的记录（`(#7)`），我们在 `Edit` 窗口的绑定配置中使用过。如果是编辑，它将链接到网格中的选定行；否则，我们创建一个新的
    `Film` 模型实例。
- en: We are also going to create a child `session` (`#8`) for this View. We are going
    to discuss `session` when we discuss the `save` method.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将为这个视图创建一个子 `session` (`#8`)。当我们讨论 `save` 方法时，我们将讨论 `session`。
- en: Finally, we display the **Edit** window pop up (`#9`).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们显示 `Edit` 窗口弹出 (`#9`)。
- en: Getting the selected actor from Live Search
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Live Search 获取选定的演员
- en: 'When a user searches for an actor and clicks on `Add Selected`, we will have
    to handle the event in the ViewController in the `onSaveActors` methods. The logic
    for this method is that we need to get the actor ID selected in the combobox and
    search for its value in the `actors` Store. Once we have the `Actor` Model instance,
    we can add it to the `actorsGrid` store. The code is as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户搜索演员并点击 `Add Selected` 时，我们将在 `ViewController` 的 `onSaveActors` 方法中处理该事件。此方法的逻辑是，我们需要获取
    combobox 中选定的演员 ID 并在 `actors` Store 中搜索其值。一旦我们有了 `Actor` 模型实例，我们就可以将其添加到 `actorsGrid`
    Store 中。代码如下：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, we get the reference of the combobox (`#1`) and get its `value`, which
    will return the ID of the selected actor. Next, we will get the reference of the
    `actors` Store declared in the `FilmsModel` (`#2`). We will search for the actor
    selected in the Store (`#3`); it will return the `Actor` Model reference or null
    if the actor does not exist. Then we get the `actorsGrid` reference ((`#4`)—the
    one inside the films form), and we also get its Store (`#5`).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取 combobox 的引用 (`#1`) 并获取其 `value`，这将返回选定演员的 ID。接下来，我们将获取在 `FilmsModel`
    中声明的 `actors` Store 的引用 (`#2`)。我们将在 Store 中搜索选定的演员 (`#3`)；它将返回 `Actor` 模型引用或 null（如果演员不存在）。然后我们获取
    `actorsGrid` 的引用（`(#4)`——在 films 表单内部），我们还获取其 Store (`#5`)。
- en: If an actor is found, we add to the `actorsGrid` Store (`#6`). This grid is
    bound to the selected film actors association, so if an actor is added or deleted
    from the grid Store, it is also added or deleted from the association. This is
    another example of two-way data binding in Ext JS 5.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到一个演员，我们将将其添加到`actorsGrid`存储库中（`#6`）。这个网格绑定到所选电影演员的关联，因此如果从网格存储中添加或删除演员，它也将从关联中添加或删除。这是Ext
    JS 5中双向数据绑定的另一个例子。
- en: 'And at last, we close the Live Search pop up (`#7`) with the following method:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下方法关闭Live Search弹出窗口（`#7`）：
- en: '[PRE49]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Saving the form and working with sessions
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存表单和会话操作
- en: 'Now it is time to save any data updated, deleted, or created. Any changes we
    make in the form will be saved to the session (`Ext.data.Session`). Sessions were
    introduced in Ext JS 5 and are great for when we are working with associations.
    We added a session to our films View by adding the configuration `session: true`
    in it. Then, all the stores from the ViewModel are also bound to the session,
    meaning any change made in the stores or in the session will be synchronized.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '现在是保存任何更新、删除或创建的数据的时候了。我们在表单中进行的任何更改都将保存到会话中（`Ext.data.Session`）。会话是在Ext JS
    5中引入的，当我们在处理关联时非常有用。我们通过在它中添加配置`session: true`将一个会话添加到我们的电影视图中。然后，ViewModel中的所有存储都将绑定到会话，这意味着在存储或会话中进行的任何更改都将同步。'
- en: 'Let''s take a look at the `onSave` method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`onSave`方法：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We are going to get the pending information to be saved from the session and
    save it in the server. First, we need to get the `session` (`#1`). Then, we are
    going to get the film's `id` if it is a new film ((`#2`)—a random temporary ID
    is created for every Model in Ext JS, usually with the name of the entity and
    a sequential number). This `id` will be overwritten after we save it in the database
    and use the database table sequential ID.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从会话中获取待保存的信息并将其保存在服务器上。首先，我们需要获取`session`（`#1`）。然后，如果是一部新电影，我们将获取电影的`id`（`(#2)`——Ext
    JS为每个模型创建一个随机临时ID，通常以实体名称和顺序号命名）。这个`id`在我们将其保存到数据库并使用数据库表顺序ID后将被覆盖。
- en: Remember that when we created the dialog, we assigned a child session to the
    **Edit** window? This allows us to work with the data without committing to it,
    meaning we can roll back the changes easily by destroying the **Edit** window.
    When we want to save the data from the child session into the `Films` session
    officially, we can call the `getSession` method from the **Edit** window and save
    it (`#3`). This will save the child session data in the `Film` session.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们创建对话框时，我们分配了一个子会话给**编辑**窗口？这允许我们在不提交数据的情况下工作，这意味着我们可以通过销毁**编辑**窗口轻松地回滚更改。当我们想将子会话中的数据正式保存到`Films`会话中时，我们可以从**编辑**窗口调用`getSession`方法并保存它（`#3`）。这将保存子会话数据到`Film`会话。
- en: Next, if it is a new film, we also want to add the record to the `films` Store
    (so it can be displayed in the `FilmsGrid` as well—(`#4`)).
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果是一部新电影，我们还想将记录添加到`films`存储库中（这样它也可以在`FilmsGrid`中显示——(`#4`)）。
- en: There are two different ways to save information from a session. The first way
    is using `batch` (`Ext.data.Batch`) that can be retrieved from the session (`#5`),
    and the second way is executing its method `start` (`#6`). This will trigger the
    CRUD operations and will use the `proxy` details to connect to the server of the
    pending models of the session to be saved.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 从会话中保存信息有两种不同的方式。第一种方式是使用`batch`（`Ext.data.Batch`），可以从会话中检索（`#5`），第二种方式是执行其`start`（`#6`）方法。这将触发CRUD操作，并使用`proxy`详细信息连接到会话中待保存模型的服务器。
- en: Custom Writer – saving associated data
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义Writer – 保存相关数据
- en: However, the session does not save associated data. If we create a Film, Category,
    and Actor, the create operation from each respective Model will be triggered,
    but the data to be saved in the many-to-many matrix tables will not be sent to
    the server.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，会话不会保存相关数据。如果我们创建一个电影、类别和演员，每个相应模型将触发创建操作，但不会将要在多对多矩阵表中保存的数据发送到服务器。
- en: 'We can create a custom `writer` class that will send any associated data to
    the server as well in a single batch. Then, we need to handle the proper CRUD
    operations of the associated data on the server as well. The code is as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个自定义的`writer`类，将任何相关数据作为一个批次发送到服务器。然后，我们需要在服务器上处理相关数据的适当CRUD操作。代码如下：
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we need to go back to the `Packt.model.Base` class, add this `writer`
    class to the `requires` declaration, and change the writer type as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要回到`Packt.model.Base`类，将此`writer`类添加到`requires`声明中，并按以下方式更改写入器类型：
- en: '[PRE52]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: All associated data will be sent to the server; in the same way, we are receiving
    a nested JSON from the server when we read information from it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 所有相关数据都将发送到服务器；同样地，当我们从服务器读取信息时，我们也会接收到嵌套的JSON。
- en: Saving session data manually
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动保存会话数据
- en: A second option to save the session data to the server is doing it manually.
    If we use the `getChanges` method of the session, it will return an object with
    all the pending information to be saved in the server, including associated data.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 将会话数据保存到服务器的第二种方法是手动操作。如果我们使用会话的`getChanges`方法，它将返回一个对象，其中包含所有待保存到服务器上的信息，包括关联数据。
- en: 'For example, if we try to edit a Film, add some Actor information and Category
    information, and call `JSON.stringify(session. getChanges(), null, 4)`, we will
    have an output similar to the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们尝试编辑一个影片，添加一些演员信息和分类信息，并调用`JSON.stringify(session.getChanges(), null,
    4)`，我们将得到以下类似的输出：
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This means we are updating (`U`) some fields of the Film with ID of `1`, deleting
    (`D`) the category with ID of `6` from the Film `1` and adding (`C`) the categories
    `7`, `8`, and `9` to the Film `1` as well. We are also deleting (`D`) the Actor
    `1` from Film `1` and adding (`C`) the Actor `71` to the Film `1` as well. Note
    that the `categories` and `actors` are the names of the many-to-many associations
    we created for `Film` Model.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们正在更新（`U`）ID为`1`的影片的一些字段，从影片`1`中删除（`D`）ID为`6`的分类，并将分类`7`、`8`和`9`添加（`C`）到影片`1`中。我们还在影片`1`中删除（`D`）演员`1`并添加（`C`）演员`71`。请注意，`categories`和`actors`是我们为`Film`模型创建的多对多关联的名称。
- en: We can also use this object to save the data manually in the server.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用此对象手动在服务器上保存数据。
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to implement a more complex screen to manage
    the inventory information from the database. You learned to handle a many-to-many
    association as well. You learned how to use some different form fields and how
    to do a Live Search. You also learned how to save data from a session.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何实现一个更复杂的屏幕来管理从数据库中获取的库存信息。你还学会了如何处理多对多关联。你学习了如何使用不同的表单字段以及如何进行实时搜索。此外，你还学习了如何从会话中保存数据。
- en: In the next chapter, we will learn how to add some extra capabilities that are
    not native to the Ext JS API to the screens we have already developed so far,
    such as print, export to Excel, and export to PDF, the contents of a GridPanel.
    Also, we will learn how to implement charts and export them to images and PDFs.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何将一些不属于Ext JS API原生功能的额外功能添加到我们迄今为止已经开发的屏幕中，例如打印、导出到Excel和导出到PDF，以及GridPanel的内容。我们还将学习如何实现图表并将它们导出为图像和PDF。
