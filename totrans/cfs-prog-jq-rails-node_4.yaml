- en: Chapter 4. CoffeeScript and Rails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ruby on Rails is a web framework that came around in 2004\. It was written by
    David Heinemeier Hansson and was extracted as a framework from **Basecamp** ,
    a project management web application he had written in Ruby for his company **37signals**.
  prefs: []
  type: TYPE_NORMAL
- en: Rails immediately impressed a lot of people by how effortlessly and quickly
    one could go about writing web applications and soon became quite popular.
  prefs: []
  type: TYPE_NORMAL
- en: At the time it was developed, Ruby was an obscure scripting language from Japan
    that no one had really heard of. Ruby was really at the heart of why Rails was
    so successful. It has proved to be a powerful and succinct programming language,
    and many programmers have stated that it makes programming fun again.
  prefs: []
  type: TYPE_NORMAL
- en: What makes Rails special?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rails has pushed the envelope on how web developers approach writing applications.
    Its core philosophy consists of the following two important principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Convention over configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don't repeat yourself, or DRY
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convention over configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rails is designed to assume that the programmer will follow certain known conventions,
    which if used, provide great benefit and much less need to configure the framework.
    It's often called an opinionated framework. That means that the framework makes
    assumptions on how a typical application should be built and structured and it
    doesn't try to be overly flexible and configurable. This helps you spend less
    time on mundane tasks like configuring and wiring up an application architecture
    and more time on actually building your app.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, Rails will model tables in your database with objects corresponding
    to their names, so a record in the `Transactions` database will automatically
    map to a `Transactions` class instance, as will a record in the `people` database
    table automatically map to a `Person` class instance.
  prefs: []
  type: TYPE_NORMAL
- en: Rails will generally use conventions to do smart things for you. Let's say our
    `people` table also has a `datetime` field called `created_at` and `updated_at`.
    Rails will be smart enough to now automatically update the timestamps on these
    two fields when a record gets created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing about Rails' conventions is that you should know about
    them and not fight the framework, or try to diverge too much from the Rails way,
    without good reason. Often, this can cancel out any of the benefits you get from
    these conventions, or even make it harder on yourself to try and find workarounds.
  prefs: []
  type: TYPE_NORMAL
- en: Don't repeat yourself (DRY)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This software engineering principle can also be stated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Every piece of knowledge must have a single, unambiguous, and authoritative
    representation within a system.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means that Rails strives to remove duplication and boilerplate wherever
    it can.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, a `Person` class that models records in the `people` table will
    not need to define its fields, since they are already defined as columns in your
    database table. Here, Rails can use the powerful metaprogramming capabilities
    of Ruby to magically add attributes to the `Person` class that correspond to columns
    in your database.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Metaprogramming** is the concept of writing code that acts on other code
    as data structures. In other words, metaprogramming is writing code that writes
    code. It is used heavily in the Ruby community and the Rails source code in particular.'
  prefs: []
  type: TYPE_NORMAL
- en: The Ruby language has very powerful metaprogramming abilities that are tied
    to the concept of open classes and objects, meaning that you can easily "open
    up" an existing class definition and redefine and add members to it.
  prefs: []
  type: TYPE_NORMAL
- en: Rails and JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a long time, Rails was shipped with the `Prototype.js` and `Script.aculo.us`
    JavaScript libraries for AJAX, page animation, and effects.
  prefs: []
  type: TYPE_NORMAL
- en: Rails has the concept of view helpers—these are Ruby methods that can be used
    in views to abstract away common HTML constructs. Many of the view helpers that
    deal with client-side code and AJAX were built on top of these two frameworks,
    and thus they were completely baked in the framework without an easy way of using
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: '`Prototype.js` shares many of the same ideas and goals as jQuery, but over
    time, jQuery has grown to be perceived as a more elegant and powerful library
    by many programmers.'
  prefs: []
  type: TYPE_NORMAL
- en: As jQuery became more popular, many developers in the Rails community started
    experimenting by using jQuery with Rails instead of the default JavaScript libraries.
    A standard set of libraries or **gems** emerged for replacing the built-in Prototype
    library with jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: In Rails Version 3.1, it was announced that jQuery will be the default JavaScript
    library. Because jQuery already had most of the animation and page effect features
    of `Script.aculo.us`, this library was also not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: This move seemed to have been a long time coming and generally had the blessings
    of most of the Rails community.
  prefs: []
  type: TYPE_NORMAL
- en: Rails and CoffeeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another big addition to Rails 3.1 was the asset pipeline. Its main goal is to
    make it easy to treat assets such as JavaScript and CSS as first-class citizens
    in your Rails app. Prior to this, JavaScript and CSS were just served as static
    content. It also provides an organizational skeleton that helps you to organize
    your JavaScript and CSS and provides a DSL for accessing them.
  prefs: []
  type: TYPE_NORMAL
- en: With the asset pipeline, you can organize and manage dependencies between assets
    using manifest files. Rails will also use the pipeline to minify and concatenate
    JavaScript as well as apply fingerprints for cache busting.
  prefs: []
  type: TYPE_NORMAL
- en: The asset pipeline also has a pre-processor chain that will allow you to run
    files through a series of input-output processors before they are served. It knows
    which pre-processors to run using file extension names.
  prefs: []
  type: TYPE_NORMAL
- en: Before Rails 3.1 was released, it was announced that the CoffeeScript compiler
    would be supported out of the box using the asset pipeline. This was a huge announcement
    since CoffeeScript is still quite a young language and it stoked quite some controversy
    within the Rails community, with some lamenting the fact that they didn't want
    to learn or use this new language.
  prefs: []
  type: TYPE_NORMAL
- en: The Rails maintainers have stuck to their guns though, and at present it couldn't
    be easier to use CoffeeScript in Rails. The fact that CoffeeScript is the default
    for writing client-side JavaScript code has been a huge boost for CoffeeScript,
    and a lot of Rails developers have since gotten to know and embraced the language.
  prefs: []
  type: TYPE_NORMAL
- en: We've been going on about how wonderful Rails is and how well it works with
    CoffeeScript, so let's get Rails installed so that you can see for yourself what
    all the fuss is about.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many different ways of installing Ruby and Rails on your development
    machine depending on your operating system, which version of Ruby you would like
    to use, if you're using version managers, building from source, and dozens of
    other options. In this book, we will only briefly cover the most common ways of
    installing it on Windows, Mac, and Linux. Please note that in this book we'll
    be using a Rails version of at least 3.2 and higher and Ruby 1.9.2 and higher.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rails using RailsInstaller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On Windows, or optionally on a Mac, I would recommend **RailsInstaller** ([http://railsinstaller.org/](http://railsinstaller.org/)).
    It contains everything you need to start with Rails, including the latest version
    of Ruby itself. After downloading the setup program, installation couldn't be
    much easier; just run it and step through the wizard. After the installation,
    you should be presented with an open console command prompt. Try entering `rails
    -v`. If you see a version number, you should be good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Rails using RVM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing Ruby and Rails on a Mac and Linux can be really easy using **RVM**,
    or the **Ruby Version Manager**, from [https://rvm.io/](https://rvm.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ruby language has grown to be very popular over the past few years, and
    this has resulted in multiple implementations of the language being written, which
    can run on difference platforms. **Matz''s Ruby Interpreter** (**MRI**), the standard
    implementation of Ruby, has also gone through several versions. RVM is great for
    managing and installing different versions of Ruby. It comes with a one-stop installer
    bash script that will install both the latest Ruby and Rails. Just run the following
    command from the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This might take quite a while to finish. Once it's done, you should try entering
    `rails -v` in the terminal. If you see a version number of at least 3.2, you should
    be good to go.
  prefs: []
  type: TYPE_NORMAL
- en: Got Rails installed?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have Rails installed, let's go ahead and build an application using
    CoffeeScript.
  prefs: []
  type: TYPE_NORMAL
- en: If you ran into any problem or want more information on installing Rails, the
    best place to start would be on the **Download** section of the Ruby on Rails
    site ([http://rubyonrails.org/download](http://rubyonrails.org/download)).
  prefs: []
  type: TYPE_NORMAL
- en: Developing our Rails application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll take parts of our existing to-do list application and extend it with a
    server-side backend using Rails. If you weren't following along in the previous
    chapter, then you should be able to just copy the code for that chapter as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter isn't meant to be a complete introduction to all of Ruby on Rails
    or Ruby, the language. Here, we would like to focus on building a simple Rails
    app within the context of how you would go about using Rails with CoffeeScript.
  prefs: []
  type: TYPE_NORMAL
- en: We will not go into everything in too much detail, and we'll trust in the fact
    that Ruby is quite a simple and readable language and that Rails code is simple
    to understand. Even if you aren't familiar with the language and the framework,
    it should not be too hard to follow along.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll start out by creating an empty base Rails application using the
    `rails` command. Navigate to a folder where you would like to create your app
    and then run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will create a `todo` folder with a whole bunch of files and folders for
    your web application. In Rails' spirit of following conventions, your web application
    will be organized in a certain manner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `rails` command is used for many things besides generating a new application
    and serves as your entry point into many of the common day-to-day Rails tasks.
    We'll be covering a few of them in this book and if you want to see the full list
    of what it can do, you can run `rails -h`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly talk about how Rails organizes our application. Most of your
    application code will probably live in the top-level `app` folder. This folder
    contains the following four important subfolders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assets:` This is the folder from which the asset pipeline operates. This is
    where all your CoffeeScript (or JavaScript) and CSS source code, as well as images
    used by our web app, will be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`controllers`: This is where your controllers live. These are responsible for
    handling routed requests for the application and they talk to your views and models.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`models`: This is where you''ll find the domain models. Models represent domain
    objects in a system and correspond to database tables using the `ActiveRecord`
    base class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views`: This folder contains view templates that are used to render your application''s
    HTML. By default, Rails uses ERB templates, which allow us to include snippets
    of Ruby code within an HTML template that will be evaluated to generate the final
    output HTML.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MVC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MVC**, or **Model-View-Controller**, is a widely used application architecture
    pattern that aims to simplify code and reduce coupling by splitting application
    concerns into three domain object types.'
  prefs: []
  type: TYPE_NORMAL
- en: Rails follows the MVC pattern very closely, and most Rails applications will
    be structured very heavily in terms of models, controllers, and views.
  prefs: []
  type: TYPE_NORMAL
- en: Another pattern on top of MVC that has been espoused by many Rails programmers
    over the last few years is fat models, skinny controllers. This concept encourages
    the practice of placing most of your domain logic within models, and that controllers
    should only be concerned about routing and interaction between models and views.
  prefs: []
  type: TYPE_NORMAL
- en: Running our application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this stage we can already run our Rails application to see if it all worked.
    From the terminal, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Rails will now start hosting a local web server for our application on port
    **3000**. You can test it by browsing to `http://localhost:3000/`. If all went
    well, then you should see the following friendly welcome message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our application](img/9588_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to keep this server running in a separate console window as we test
    our application. You can also check the output of this process for any errors
    that might occur while it's running.
  prefs: []
  type: TYPE_NORMAL
- en: Our todo_items resource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, we now have a running application, but it doesn't do much except show us
    a welcome page.
  prefs: []
  type: TYPE_NORMAL
- en: To get to our goal of being able to track to-do tasks, we'll generate a resource
    for our to-do items. In Rails parlance, a resource consists of a model, a controller
    with some actions, as well as views for those actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the terminal, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What did this do? This is an example of Rails' generator syntax, which can be
    used to generate boilerplate code. Here, we tell it to create a "resourceful"
    controller named `TodoItemsController` and a model, `TodoItem`, which has a `string`
    field for its title and a `boolean` flag to mark it as completed.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the command output, it has generated a bunch of files as
    well as modified an existing one, in `config/routes.rb`. Let's start by opening
    this file.
  prefs: []
  type: TYPE_NORMAL
- en: routes.rb
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is what you should see at the top of the `routes.rb` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In Rails, `routes.rb` defines how HTTP calls to URLs map to controller actions
    that can handle them.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the generator added a line for us, which uses the `resources` method.
    This method creates the routes for the most common actions of a "resourceful"
    controller. This means it exposes a single domain resource in your application
    using the HTTP verbs, GET, POST, PUT, and DELETE.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, this will create routes for seven different controller actions, `index`,
    `show`, `new`, `create`, `edit`, `update`, and `destroy`. As you will see later
    on, we won''t need to create all these actions for our controller, so we''ll tell
    the `resources` method to filter out only the ones we want. Modify the file to
    look like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the call to `resources`, Rails uses the `:todo_items` symbol to conventionally
    map the `resources` method to `TodoItemsController`, which was also generated
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `app/controllers/todo_items_controller.rb` file; here is what you''ll
    see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there isn't a whole lot in here. A class named `TodoItemController`
    is declared, and it derives from the `ApplicationController` class. The `ApplicationController`
    class was also generated for us when we created the app, and it derives from `ActionController::Base`,
    which gives it a whole lot of functionality and lets it behave like a Rails controller.
  prefs: []
  type: TYPE_NORMAL
- en: We should now be able to test out our controller by navigating to the `http://localhost:3000/todo_items`
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: What do you see? You should get the **Unknown action** error page stating that
    the `index` action could not be found for `TodoItemsController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because the controller doesn''t yet have an `index` action defined,
    as specified in our `routes.rb` file. Let''s go ahead and add a method to our
    `TodoItemsController` class to handle that action; this is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the page, we get a different error message: **Template is missing**.
    This happens because we don''t have a template for the `index` action. By default,
    Rails will always try to return a rendered template that corresponds to the `index`
    action name. Let''s go ahead and add one now.'
  prefs: []
  type: TYPE_NORMAL
- en: The view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rails views are saved in the `app/views` folder. Each controller will have a
    subfolder here containing its views. We already have an `index.html` file from
    the previous chapter, which we'll re-use here. To do this, we'll need to copy
    everything that is inside the `body` tag, excluding the last two `script` tags
    from the old `index.html` file, into a file called `app/views/todo_items/index.html.erb`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should end up with the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Looking at this, you might be wondering where the rest of the HTML such as the
    enclosing `html`, `head`, and `body` tags have gone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, Rails has the concept of a layout file, which acts as a wrapper for all
    the other views. This way you can have a consistent skeleton for your site that
    you don''t need to create for each view. Our view will be embedded inside the
    default layout file: `app/views/layouts/application.html.erb`. Let''s have a look
    at that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `stylesheet_link_tag` and `javascript_include_tag` methods will make sure
    that all the files specified in the `assets` folder are included in the HTML.
    The `<%= yield %>` line is where the current view will be rendered, which is `index.html.erb`
    in our case.
  prefs: []
  type: TYPE_NORMAL
- en: When we refresh the page now, we'll see the `index` page. Have a look at the
    source code to get an idea of how the final HTML is output.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our page is still unstyled and looks quite dull. Let's see if
    we can make it look pretty again.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, the asset pipeline will look for CSS files in the `app/assets/stylesheets`
    folder. When we browse to this folder, we'll see a file named `todo_items.css.scss`,
    which was generated for us when we created the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the contents of the previous chapter's `styles.css` file into this file.
    Our `index` page should now look decent again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This file with the strange `.css.scss` extension is a Saas file ([http://sass-lang.com/](http://sass-lang.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Like CoffeeScript, Sass is an extended version of the normal CSS language, with
    a lot of nice features that make writing CSS easier and less repetitive.
  prefs: []
  type: TYPE_NORMAL
- en: As with CoffeeScript, it is the default CSS compiler in the Rails asset pipeline.
    The flavor of Sass that we're using is a superset of CSS, which means we can use
    normal CSS in this file without using any of the Sass features and it will work
    fine.
  prefs: []
  type: TYPE_NORMAL
- en: Our model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So now we can see our to-do list, but we don''t have any items showing up.
    This time, instead of storing them locally, we''ll store them in the database.
    Luckily for us, we already have a database model that was generated for us when
    we created the resource and the `TodoItem` model, which is defined in `app/models/todo_item.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, like with controllers, you can see that Rails models get most of their
    functionality by deriving from `ActiveRecord::Base`. The `attr_accessible` line
    tells `ActiveRecord` which fields on this model can be assigned to and from user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we use the model? Add the following highlighted code in `todo_items_controller.rb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This line uses an `all` class method on the `TodoItem` class, which is also
    provided by `ActiveRecord`. This will return a new instance of the `TodoItem`
    class for each record in the database, which we can assign to an instance variable
    called `@todo_items` (in Ruby all instance variables start with an `@` symbol).
  prefs: []
  type: TYPE_NORMAL
- en: When Rails executes a controller action, it will automatically make any of the
    controller instance variables available to the view being rendered, which is why
    we're assigning it here. We'll get to use it in our view soon.
  prefs: []
  type: TYPE_NORMAL
- en: Let's refresh the page again to see if this worked. Yet again, we get a **Could
    not find table 'todo_items'** error.
  prefs: []
  type: TYPE_NORMAL
- en: You've probably guessed that we're supposed to create a table called `todo_items`
    in a database somewhere. Luckily, Rails has already taken care of the hard work,
    using something called migration.
  prefs: []
  type: TYPE_NORMAL
- en: Migrations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we generated our resource, Rails not only created a model for us, but
    also a database script written in Ruby, or **migration** . We should be able to
    open it in the `db/migrations` folder. The actual file will be prefixed with a
    timestamp and will end with `_create_todo_items.rb`. It should look similar to
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This script will create a table named `todo_items` with the fields that we had
    specified when we generated the `todo_item` resource. It also creates two timestamp
    fields named `created_at` and `updated_at` using the `t.timestamps` method. Rails
    will make sure that fields with those names get updated with the appropriate timestamp
    when a record gets created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Migration scripts are a wonderful way of automating database changes, even
    allowing you to roll back a previous change. You don''t have to rely on migrations
    created by resource or model generators either. Custom migrations can be generated
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: After generating your custom migration, you can just implement the `up` and
    `down` methods, which will be called when your migration gets executed or rolled
    back.
  prefs: []
  type: TYPE_NORMAL
- en: 'Migrations are executed with the `rake` command. `rake` is a task-management
    tool that allows you to write tasks as Ruby scripts, which are then run using
    the `rake` command-line utility. Rails comes with a whole lot of built-in `rake`
    tasks, and you can see the full list of them by using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The task that we''re interested in the moment is called `db:migrate` , let''s
    run it and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '**== CreateTodoItems: migrating ================================================**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-- create_table(:todo_items)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**-> 0.0011s**'
  prefs: []
  type: TYPE_NORMAL
- en: '**== CreateTodoItems: migrated (0.0013s) =======================================**'
  prefs: []
  type: TYPE_NORMAL
- en: This means Rails has successfully created a `todo_items` table for us in the
    database. When we refresh the application page, we should see that the error is
    gone and we're seeing our blank to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where is the database?**'
  prefs: []
  type: TYPE_NORMAL
- en: You might have wondered where our actual database lives at the moment. Rails
    defaults to using an embedded SQLite database. SQLite ([http://www.sqlite.org](http://www.sqlite.org))
    is a self-contained, file-based database that doesn't need a server to be configured
    for it to run. This makes it really nice and easy to get up and running quickly
    when developing an application.
  prefs: []
  type: TYPE_NORMAL
- en: Once you actually deploy your web app, you would probably want to go with a
    more traditional database server, such as MySQL or PostgreSQL. You can easily
    change your database connection settings in the `config/database.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: We still haven't hooked up our view to actually show the list of to-do items.
    Before we do that, let's manually create a couple of to-do items in the database.
  prefs: []
  type: TYPE_NORMAL
- en: The Rails console
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rails has a nifty way of interactively playing with your code by using the
    Rails console. This is an interactive Ruby interpreter, or **irb**, session with
    all the Rails project code loaded. Let''s fire it up by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''re in the console you can enter any valid Ruby code. You can also
    access all the models in your Rails app. Let''s try it with the `TodoItem.all`
    method that we used earlier; this is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Rails consoleRails consoleabout](img/9588_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the moment it returns an empty array, since our table is still empty. Notice
    that Rails also outputted the SQL query that it has generated to get all the records.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here we can also create a new to-do item using our model. The following
    code will do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we should have a single to-do item in our table. You can verify this by
    using `TodoItem.first`, which will return the first item in our table.
  prefs: []
  type: TYPE_NORMAL
- en: 'I want to make sure that our model always has a title. `ActiveRecord` has very
    powerful validation features that are built-in, which allows for specifying constraints
    on model attributes in a very declarative manner. Let''s make sure that our model
    always checks for the presence of a title before saving; to do this, add the following
    highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and create a couple of other to-do items. Once you have done this,
    try running `TodoItem.all` again. This time it returns an array of `TodoItem`
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To exit the rails console, just enter `exit`.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the items in our view using ERB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To display our to-do items in our view, we''ll use the `@todo_items` instance
    variable that we created in our controller action. Let''s modify the `app/views/todo_items.html.erb`
    file and mix in some Ruby using ERB; add the code that is highlighted in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'ERB templates are quite simple to understand. The basic idea is that you write
    your HTML as normal and mix in Ruby using ERB tags. The following three tags are
    important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In our `index` ERB template, we use Ruby's `each` iterator to loop through all
    the elements in the `@todo_items` array instance variable; `each` takes a Ruby
    block as an argument. A block is a piece of code that can be passed to a method
    as data, similar to how functions can be passed as arguments in CoffeeScript.
  prefs: []
  type: TYPE_NORMAL
- en: This block will be executed for each item in the array, passing it in as the
    item variable. For each item, we create its markup, using the item's `title` and
    `completed` attributes inside of our ERB tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we refresh the page, we should now finally see our list of to-do items!
    If you are curious, have a look at the HTML source of the document and compare
    it to the ERB template, this should give you a good idea of how it was generated.
    The output page is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Displaying the items in our view using ERB](img/9588_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a partial
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the moment, our view code is starting to get a bit messy, especially the
    to-do items list. We can clean it up a bit by using a **view partial** , which
    allows us to pull out snippets of our view into a separate file. This can then
    be rendered where we need it in the main view. Add the line of code highlighted
    in the following code snippet to your file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll move the to-do item markup to its own partial file. By convention, partial
    filenames start with an underscore, and when rendering a partial, Rails will look
    for a file with the same name as the specified partial, with a leading underscore.
    Go ahead and create a file: `app/views/todo_items/_todo_item.html.erb` with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If all went well, our view should still work as before, and we have cleaned
    up the main view code nicely. Simplifying views with partials are also great for
    reusability, which we'll see later on.
  prefs: []
  type: TYPE_NORMAL
- en: Our to-do list app still needs some work. At the moment, we can't add new tasks
    and the completed task and delete actions don't work either. This calls for some
    client-side code, which means we can finally start using some CoffeeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Adding new items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add new items to our to-do list, we''ll use some of Rails'' native AJAX
    capabilities. The following code snippet is a modified version of the `todo` input
    on our `index` view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So what has changed here? First, you'll notice that we have included the `form_for`
    method, with another call to `text_field` inside of its block. These are Rails'
    view helpers, which are Ruby methods available inside of views, that provide ways
    of building the HTML output.
  prefs: []
  type: TYPE_NORMAL
- en: The `form_for` method will output an HTML `form` tag, and the `text_field` method
    will generate an `input` tag inside the form, which will be of type `text`.
  prefs: []
  type: TYPE_NORMAL
- en: We pass a new instance of `TodoItem` as a parameter to the `form_for` method.
    Rails is smart enough to know from the `TodoItem` instance that the form's URL
    should point to `TodoItemController`, and will use attributes of the `TodoItem`
    model as names of inputs inside the form.
  prefs: []
  type: TYPE_NORMAL
- en: The real magic comes in with the `:remote => true` parameter sent to the `form_for`
    method. This tells Rails that you want this form to be submitted using AJAX. Rails
    will take care of all of this in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'So which controller action will my form be submitted to? Since we specified
    its action as `post`, it will map to a `create` action in `TodoItemController`.
    We don''t have one yet, so let''s go and write it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create `TodoItem` using the `:todo_item` key in `params`—`params`,
    which is a Ruby hash that Rails created. It contains a value with the key, `:todo_items`,
    which is a hash containing all the parameter values that were submitted from the
    form. When we pass this hash to the `TodoItem.create` method, Rails will know
    how to map them to attributes on our new model and save it to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try and add a to-do item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Type a title in our input box for a new to-do item and hit *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it seems like nothing happened. We can head over to the output of
    our running Rails server session to see if we can spot any errors. If you scroll
    around a bit, you should see an error similar to the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ActionView::MissingTemplate (Missing template todo_items/create, application/create
    with {:locale=>[:en], :formats=>[:js, "application/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**ecmascript", "application/x-ecmascript", :html, :text, :js, :css, :ics, :csv,
    :png, :jpeg, :gif, :bmp, :tiff, :mpeg, :xml, :rss, :atom,**'
  prefs: []
  type: TYPE_NORMAL
- en: '**:yaml, :multipart_form, :url_encoded_form, :json, :pdf, :zip], :handlers=>[:erb,
    :builder, :coffee]}. Searched in:**'
  prefs: []
  type: TYPE_NORMAL
- en: '*** "/home/michael/dev/todo/app/views"**'
  prefs: []
  type: TYPE_NORMAL
- en: '**)**'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a CoffeeScript view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, it seems we still need to do one more thing. All controller actions will
    try and render a view by default. When we try adding a to-do item now, we would
    get the same **Template is missing** error as earlier. It might not be clear what
    should happen, since the form was posted using AJAX. Should we still render a
    view? And how would it look?
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the error message a bit more closely might give us a clue. Since
    our action was invoked using AJAX, Rails will, by default, look for a CoffeeScript
    view to render as JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The generated JavaScript will serve as the response to the AJAX call and will
    be executed on completion. This also seems like the perfect place to update our
    to-do items list, after creating it on the server.
  prefs: []
  type: TYPE_NORMAL
- en: We'll create a CoffeeScript view template for our `create` action in `app/views/todo_items/create.js.coffee`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the previous code snippet, we grab the `#new-todo` input and clear
    its value. We then render the same `todo_item` partial that we used before, passing
    in the `@todo_item` instance variable that we created in our controller action.
  prefs: []
  type: TYPE_NORMAL
- en: We wrap the render call in an `escape_javascript` helper method, which will
    ensure that any special JavaScript character will be escaped in our string. We
    then append the newly rendered partial to our `#todo-list` element.
  prefs: []
  type: TYPE_NORMAL
- en: Try it out. We can now finally create to-do list items!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Where did jQuery come from?**'
  prefs: []
  type: TYPE_NORMAL
- en: Rails already included jQuery for us. The Rails asset pipeline uses a manifest
    file, `app/assets/javascript/application.js` to include required dependencies,
    for instance jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: CoffeeScript in the asset pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Notice how seamless this all was? Rails treats CoffeeScript as a first-class
    citizen in its stack, and will make sure that the `.coffee` files get compiled
    into JavaScript before they are used. The fact that you can also pre-process your
    CoffeeScript using ERB templates on the server makes this even more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the to-do items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's hook up this functionality. This time, we will do things a bit differently
    to show you a different style of writing CoffeeScript in Rails. We'll follow the
    more traditional approach of handling the AJAX call ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Rails has already created a file where we can put our client-side code, back
    when we created the controller. Each controller will get its own CoffeeScript
    file, which will be included in the page automatically for any action on that
    controller.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also an `application.js.coffee` file, where global client-side code
    can be added.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file that we''re interested in will be `app/assets/views/javascripts/todo_items.js.coffee`.
    We can replace the contents of it with the following code, which will handle the
    AJAX call when completing a task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we define a function called `toggleItem`, which we set up to be called
    when a checkbox value changes. In this function we toggle the parent `li` element's
    `completed` class and get the ID of the to-do item using its `data` attribute.
    We then make an AJAX call to `TodoItemController` to update the item with the
    current checked value of the checkbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can run this code, we''ll need to add an `update` action to our controller,
    which is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`params[:id]` will be the value of the ID in the URL. We use this to find the
    to-do item and then call the `update_attributes` method, which do just that, update
    our model and save it to the database. Note that we explicitly tell Rails not
    to render a view here by calling `render nothing: true`.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting tasks to completed should now work. Notice that when you refresh the
    page, tasks stay completed, since they were saved to the database.
  prefs: []
  type: TYPE_NORMAL
- en: Removing tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For removing tasks, we'll follow a very similar pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `todo_items.js.coffee`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In our controller, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That should be all we need to remove list items. Notice that here we only remove
    the element once the AJAX call was successful, by handling the `success` callback.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's your turn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a final exercise to you, I will ask you to make the **Clear completed** button
    work. As a hint, you should be able to use the existing `destroyItem` method functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter started with a whirlwind tour of Ruby on Rails. You have hopefully
    grown to appreciate some of the magic that Rails offers web developers and how
    much fun it can be developing a Rails app. We have also spent some time discovering
    how easy it is to use CoffeeScript in a Rails app, and the different approaches
    and techniques you would typically use to write client-side code.
  prefs: []
  type: TYPE_NORMAL
- en: If you haven't done so already, I encourage you to spend some more time learning
    Rails as well as Ruby, and immersing yourself in the wonderful communities they
    support.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll explore yet another new exciting server framework
    that was built using JavaScript, and how CoffeeScript relates to it.
  prefs: []
  type: TYPE_NORMAL
