- en: Chapter 4. CoffeeScript and Rails
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：CoffeeScript和Rails
- en: Ruby on Rails is a web framework that came around in 2004\. It was written by
    David Heinemeier Hansson and was extracted as a framework from **Basecamp** ,
    a project management web application he had written in Ruby for his company **37signals**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby on Rails是一个在2004年出现的网络框架。它是由David Heinemeier Hansson编写的，并从他为他的公司**37signals**编写的Ruby项目管理网络应用**Basecamp**中提取出来的框架。它是一个诺贝尔物理奖获得者**理查德·费曼**。
- en: Rails immediately impressed a lot of people by how effortlessly and quickly
    one could go about writing web applications and soon became quite popular.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Rails通过如何轻松快速地编写网络应用程序给很多人留下了深刻印象，很快变得非常受欢迎。
- en: At the time it was developed, Ruby was an obscure scripting language from Japan
    that no one had really heard of. Ruby was really at the heart of why Rails was
    so successful. It has proved to be a powerful and succinct programming language,
    and many programmers have stated that it makes programming fun again.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发的时候，Ruby是一种来自日本的神秘脚本语言，没有人真正听说过。Ruby实际上是Rails之所以成功的关键。它已经证明是一种强大而简洁的编程语言，许多程序员都表示它让编程变得有趣起来。
- en: What makes Rails special?
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rails有什么特别之处？
- en: 'Rails has pushed the envelope on how web developers approach writing applications.
    Its core philosophy consists of the following two important principles:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Rails推动了网络开发者编写应用程序的方法。其核心哲学包括以下两个重要原则：
- en: Convention over configuration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 约定优于配置
- en: Don't repeat yourself, or DRY
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复自己，或者DRY
- en: Convention over configuration
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约定优于配置
- en: Rails is designed to assume that the programmer will follow certain known conventions,
    which if used, provide great benefit and much less need to configure the framework.
    It's often called an opinionated framework. That means that the framework makes
    assumptions on how a typical application should be built and structured and it
    doesn't try to be overly flexible and configurable. This helps you spend less
    time on mundane tasks like configuring and wiring up an application architecture
    and more time on actually building your app.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Rails被设计成假设程序员会遵循某些已知约定，如果使用这些约定，将提供巨大的好处，并减少对框架配置的需求。它通常被称为有偏见的框架。这意味着框架对典型应用程序应该如何构建和结构做出了假设，并且它不会试图过于灵活和可配置。这有助于你花更少的时间在配置和连接应用程序架构等日常任务上，更多的时间用于实际构建你的应用程序。
- en: For instance, Rails will model tables in your database with objects corresponding
    to their names, so a record in the `Transactions` database will automatically
    map to a `Transactions` class instance, as will a record in the `people` database
    table automatically map to a `Person` class instance.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Rails会使用对象来模拟你的数据库中的表，这些对象对应于它们的名称，因此`Transactions`数据库中的记录将自动映射到`Transactions`类实例，同样，`people`数据库表中的记录也会自动映射到`Person`类实例。
- en: Rails will generally use conventions to do smart things for you. Let's say our
    `people` table also has a `datetime` field called `created_at` and `updated_at`.
    Rails will be smart enough to now automatically update the timestamps on these
    two fields when a record gets created or updated.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Rails通常会使用约定为你做智能的事情。比如说，我们的`people`表也有一个名为`created_at`和`updated_at`的`datetime`字段。Rails足够智能，现在可以自动更新这两个字段在记录创建或更新时的时间戳。
- en: The most important thing about Rails' conventions is that you should know about
    them and not fight the framework, or try to diverge too much from the Rails way,
    without good reason. Often, this can cancel out any of the benefits you get from
    these conventions, or even make it harder on yourself to try and find workarounds.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Rails约定最重要的地方在于你应该了解它们，而不是与框架对抗，或者没有充分的理由试图过多地偏离Rails的方式。通常，这可能会抵消你从这些约定中获得的所有好处，甚至可能使你更难找到解决方案。
- en: Don't repeat yourself (DRY)
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复自己（DRY）
- en: 'This software engineering principle can also be stated as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个软件工程原则也可以表述如下：
- en: Every piece of knowledge must have a single, unambiguous, and authoritative
    representation within a system.
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 每项知识必须在系统中有一个单一、明确和权威的表示。
- en: This means that Rails strives to remove duplication and boilerplate wherever
    it can.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着Rails力求在可能的情况下消除重复和样板代码。
- en: For instance, a `Person` class that models records in the `people` table will
    not need to define its fields, since they are already defined as columns in your
    database table. Here, Rails can use the powerful metaprogramming capabilities
    of Ruby to magically add attributes to the `Person` class that correspond to columns
    in your database.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个`Person`类，它模拟`people`表中的记录，不需要定义其字段，因为它们已经在你的数据库表中定义为列。在这里，Rails可以使用Ruby强大的元编程能力，神奇地给`Person`类添加与数据库列相对应的属性。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Metaprogramming** is the concept of writing code that acts on other code
    as data structures. In other words, metaprogramming is writing code that writes
    code. It is used heavily in the Ruby community and the Rails source code in particular.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**元编程**是编写作用于其他代码作为数据结构的代码的概念。换句话说，元编程就是编写编写代码的代码。它在Ruby社区，尤其是Rails源代码中得到了广泛的应用。'
- en: The Ruby language has very powerful metaprogramming abilities that are tied
    to the concept of open classes and objects, meaning that you can easily "open
    up" an existing class definition and redefine and add members to it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby语言具有非常强大的元编程能力，这与开放类和对象的概念紧密相关，这意味着你可以轻松地“打开”现有的类定义，并对其进行重新定义和添加成员。
- en: Rails and JavaScript
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rails和JavaScript
- en: For a long time, Rails was shipped with the `Prototype.js` and `Script.aculo.us`
    JavaScript libraries for AJAX, page animation, and effects.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间里，Rails都附带`Prototype.js`和`Script.aculo.us` JavaScript库，用于AJAX、页面动画和效果。
- en: Rails has the concept of view helpers—these are Ruby methods that can be used
    in views to abstract away common HTML constructs. Many of the view helpers that
    deal with client-side code and AJAX were built on top of these two frameworks,
    and thus they were completely baked in the framework without an easy way of using
    alternatives.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Rails有视图辅助器的概念——这些是在视图中使用的Ruby方法，可以用来抽象常见的HTML结构。许多处理客户端代码和AJAX的视图辅助器都是建立在这些两个框架之上的，因此它们完全内置于框架中，没有使用替代方案的方法。
- en: '`Prototype.js` shares many of the same ideas and goals as jQuery, but over
    time, jQuery has grown to be perceived as a more elegant and powerful library
    by many programmers.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Prototype.js`与jQuery共享许多相同的思想和目标，但随着时间的推移，jQuery被许多程序员视为一个更优雅、更强大的库。'
- en: As jQuery became more popular, many developers in the Rails community started
    experimenting by using jQuery with Rails instead of the default JavaScript libraries.
    A standard set of libraries or **gems** emerged for replacing the built-in Prototype
    library with jQuery.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随着jQuery变得越来越流行，Rails社区中的许多开发者开始尝试使用jQuery与Rails一起使用，而不是默认的JavaScript库。一套标准的库或**gem**出现了，用于用jQuery替换内置的Prototype库。
- en: In Rails Version 3.1, it was announced that jQuery will be the default JavaScript
    library. Because jQuery already had most of the animation and page effect features
    of `Script.aculo.us`, this library was also not needed anymore.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rails 3.1版本中，宣布jQuery将成为默认的JavaScript库。因为jQuery已经包含了`Script.aculo.us`的大部分动画和页面效果功能，所以这个库也不再需要了。
- en: This move seemed to have been a long time coming and generally had the blessings
    of most of the Rails community.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这项举措似乎已经酝酿良久，并且普遍得到了Rails社区大多数人的祝福。
- en: Rails and CoffeeScript
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Rails和CoffeeScript
- en: Another big addition to Rails 3.1 was the asset pipeline. Its main goal is to
    make it easy to treat assets such as JavaScript and CSS as first-class citizens
    in your Rails app. Prior to this, JavaScript and CSS were just served as static
    content. It also provides an organizational skeleton that helps you to organize
    your JavaScript and CSS and provides a DSL for accessing them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 3.1的另一个重大新增功能是资产管道。其主要目标是使JavaScript和CSS等资产在Rails应用程序中成为一等公民变得容易。在此之前，JavaScript和CSS只是作为静态内容被服务。它还提供了一个组织结构，帮助你组织JavaScript和CSS，并提供了一个用于访问它们的领域特定语言（DSL）。
- en: With the asset pipeline, you can organize and manage dependencies between assets
    using manifest files. Rails will also use the pipeline to minify and concatenate
    JavaScript as well as apply fingerprints for cache busting.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用资产管道，你可以通过清单文件来组织和管理工作之间的依赖关系。Rails还会使用管道来压缩和连接JavaScript，以及应用指纹以实现缓存破坏。
- en: The asset pipeline also has a pre-processor chain that will allow you to run
    files through a series of input-output processors before they are served. It knows
    which pre-processors to run using file extension names.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 资产管道还包含一个预处理链，允许你在文件被服务之前，通过一系列的输入-输出处理器来运行这些文件。它通过文件扩展名来识别应该运行哪些预处理程序。
- en: Before Rails 3.1 was released, it was announced that the CoffeeScript compiler
    would be supported out of the box using the asset pipeline. This was a huge announcement
    since CoffeeScript is still quite a young language and it stoked quite some controversy
    within the Rails community, with some lamenting the fact that they didn't want
    to learn or use this new language.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Rails 3.1 发布之前，宣布了将支持 CoffeeScript 编译器，通过资产管道直接使用。这是一个重大的宣布，因为 CoffeeScript
    仍然是一个非常年轻的语言，它在 Rails 社区中引起了很多争议，有些人哀叹他们不想学习或使用这种新语言。
- en: The Rails maintainers have stuck to their guns though, and at present it couldn't
    be easier to use CoffeeScript in Rails. The fact that CoffeeScript is the default
    for writing client-side JavaScript code has been a huge boost for CoffeeScript,
    and a lot of Rails developers have since gotten to know and embraced the language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，Rails 维护者坚持了自己的立场，目前使用 CoffeeScript 在 Rails 中使用非常简单。CoffeeScript 作为编写客户端
    JavaScript 代码的默认语言，对 CoffeeScript 来说是一个巨大的推动，许多 Rails 开发者因此开始了解并接受这种语言。
- en: We've been going on about how wonderful Rails is and how well it works with
    CoffeeScript, so let's get Rails installed so that you can see for yourself what
    all the fuss is about.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论 Rails 的美妙之处以及它与 CoffeeScript 的良好配合，所以让我们安装 Rails，这样你就可以亲自看看所有这些喧嚣的原因。
- en: Installing Rails
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Rails
- en: There are many different ways of installing Ruby and Rails on your development
    machine depending on your operating system, which version of Ruby you would like
    to use, if you're using version managers, building from source, and dozens of
    other options. In this book, we will only briefly cover the most common ways of
    installing it on Windows, Mac, and Linux. Please note that in this book we'll
    be using a Rails version of at least 3.2 and higher and Ruby 1.9.2 and higher.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的操作系统、你想要使用的 Ruby 版本、你是否使用版本管理器、从源代码构建以及许多其他选项，有无数种方式可以在你的开发机器上安装 Ruby 和
    Rails。在这本书中，我们将简要介绍在 Windows、Mac 和 Linux 上安装它的最常见方法。请注意，在这本书中，我们将使用至少 3.2 版本的
    Rails 和 1.9.2 版本的 Ruby 或更高版本。
- en: Installing Rails using RailsInstaller
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RailsInstaller 安装 Rails
- en: On Windows, or optionally on a Mac, I would recommend **RailsInstaller** ([http://railsinstaller.org/](http://railsinstaller.org/)).
    It contains everything you need to start with Rails, including the latest version
    of Ruby itself. After downloading the setup program, installation couldn't be
    much easier; just run it and step through the wizard. After the installation,
    you should be presented with an open console command prompt. Try entering `rails
    -v`. If you see a version number, you should be good to go.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，或者可选地在 Mac 上，我推荐使用 **RailsInstaller** ([http://railsinstaller.org/](http://railsinstaller.org/))。它包含了开始使用
    Rails 所需的一切，包括 Ruby 的最新版本。下载设置程序后，安装过程非常简单；只需运行它并按照向导操作。安装完成后，你应该会看到一个打开的控制台命令提示符。尝试输入
    `rails -v`。如果你看到一个版本号，你应该可以开始了。
- en: Installing Rails using RVM
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 RVM 安装 Rails
- en: Installing Ruby and Rails on a Mac and Linux can be really easy using **RVM**,
    or the **Ruby Version Manager**, from [https://rvm.io/](https://rvm.io/).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac 和 Linux 上使用 **RVM**（Ruby 版本管理器），从 [https://rvm.io/](https://rvm.io/)，可以非常容易地安装
    Ruby 和 Rails。
- en: 'The Ruby language has grown to be very popular over the past few years, and
    this has resulted in multiple implementations of the language being written, which
    can run on difference platforms. **Matz''s Ruby Interpreter** (**MRI**), the standard
    implementation of Ruby, has also gone through several versions. RVM is great for
    managing and installing different versions of Ruby. It comes with a one-stop installer
    bash script that will install both the latest Ruby and Rails. Just run the following
    command from the terminal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，Ruby 语言变得越来越受欢迎，这导致了多种语言实现被编写出来，可以在不同的平台上运行。**Matz 的 Ruby 解释器**（**MRI**），Ruby
    的标准实现，也已经经过了几个版本。RVM 对于管理和安装不同版本的 Ruby 来说非常出色。它包含一个一站式安装器 bash 脚本，可以安装最新的 Ruby
    和 Rails。只需从终端运行以下命令：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This might take quite a while to finish. Once it's done, you should try entering
    `rails -v` in the terminal. If you see a version number of at least 3.2, you should
    be good to go.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要相当长的时间才能完成。一旦完成，你应该尝试在终端中输入 `rails -v`。如果你看到一个至少为 3.2 的版本号，你应该可以开始了。
- en: Got Rails installed?
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rails 已经安装好了吗？
- en: Now that we have Rails installed, let's go ahead and build an application using
    CoffeeScript.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了 Rails，让我们继续使用 CoffeeScript 来构建一个应用程序。
- en: If you ran into any problem or want more information on installing Rails, the
    best place to start would be on the **Download** section of the Ruby on Rails
    site ([http://rubyonrails.org/download](http://rubyonrails.org/download)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到了任何问题或需要有关安装Rails的更多信息，最好的起点是Ruby on Rails网站的**下载**部分（[http://rubyonrails.org/download](http://rubyonrails.org/download))。
- en: Developing our Rails application
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发我们的Rails应用程序
- en: We'll take parts of our existing to-do list application and extend it with a
    server-side backend using Rails. If you weren't following along in the previous
    chapter, then you should be able to just copy the code for that chapter as needed.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Rails在服务器端后端扩展我们现有的待办事项列表应用程序。如果您没有在前一章中跟随，那么您应该能够根据需要复制该章节的代码。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter isn't meant to be a complete introduction to all of Ruby on Rails
    or Ruby, the language. Here, we would like to focus on building a simple Rails
    app within the context of how you would go about using Rails with CoffeeScript.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的不是全面介绍Ruby on Rails或Ruby语言，而是希望专注于在如何使用Rails与CoffeeScript结合的背景下构建一个简单的Rails应用程序。
- en: We will not go into everything in too much detail, and we'll trust in the fact
    that Ruby is quite a simple and readable language and that Rails code is simple
    to understand. Even if you aren't familiar with the language and the framework,
    it should not be too hard to follow along.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过于详细地介绍所有内容，并且我们将相信Ruby是一种相当简单且易于阅读的语言，Rails代码也易于理解。即使您不熟悉这种语言和框架，也应该不会太难跟随。
- en: 'First, we''ll start out by creating an empty base Rails application using the
    `rails` command. Navigate to a folder where you would like to create your app
    and then run this command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用`rails`命令创建一个空的Rails基础应用程序。导航到您想要创建应用程序的文件夹，然后运行此命令：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will create a `todo` folder with a whole bunch of files and folders for
    your web application. In Rails' spirit of following conventions, your web application
    will be organized in a certain manner.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个包含大量文件和文件夹的`todo`文件夹，用于您的Web应用程序。遵循Rails的约定精神，您的Web应用程序将以某种方式组织。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `rails` command is used for many things besides generating a new application
    and serves as your entry point into many of the common day-to-day Rails tasks.
    We'll be covering a few of them in this book and if you want to see the full list
    of what it can do, you can run `rails -h`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`rails`命令除了用于生成新应用程序之外，还用于许多其他事情，并且是您进入许多常见日常Rails任务的入口点。本书将介绍其中的一些，如果您想查看它可以做什么的完整列表，可以运行`rails
    -h`。'
- en: 'Let''s briefly talk about how Rails organizes our application. Most of your
    application code will probably live in the top-level `app` folder. This folder
    contains the following four important subfolders:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地谈谈Rails如何组织我们的应用程序。您的大部分应用程序代码可能都位于顶级`app`文件夹中。这个文件夹包含以下四个重要的子文件夹：
- en: '`assets:` This is the folder from which the asset pipeline operates. This is
    where all your CoffeeScript (or JavaScript) and CSS source code, as well as images
    used by our web app, will be.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`assets:` 这是资产管道操作的文件夹。这是所有CoffeeScript（或JavaScript）和CSS源代码以及我们的Web应用程序使用的图像所在的地方。'
- en: '`controllers`: This is where your controllers live. These are responsible for
    handling routed requests for the application and they talk to your views and models.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`controllers`: 这是您的控制器所在的位置。这些负责处理应用程序的路由请求，并与您的视图和模型进行交互。'
- en: '`models`: This is where you''ll find the domain models. Models represent domain
    objects in a system and correspond to database tables using the `ActiveRecord`
    base class.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models`: 这是您将找到领域模型的地方。模型代表系统中的领域对象，并使用`ActiveRecord`基类对应于数据库表。'
- en: '`views`: This folder contains view templates that are used to render your application''s
    HTML. By default, Rails uses ERB templates, which allow us to include snippets
    of Ruby code within an HTML template that will be evaluated to generate the final
    output HTML.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`: 这个文件夹包含用于渲染应用程序HTML的视图模板。默认情况下，Rails使用ERB模板，这允许我们在HTML模板中包含Ruby代码片段，这些代码片段将被评估以生成最终的输出HTML。'
- en: MVC
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC
- en: '**MVC**, or **Model-View-Controller**, is a widely used application architecture
    pattern that aims to simplify code and reduce coupling by splitting application
    concerns into three domain object types.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**MVC**，或**模型-视图-控制器**，是一种广泛使用的应用程序架构模式，旨在通过将应用程序关注点拆分为三个领域对象类型来简化代码并减少耦合。'
- en: Rails follows the MVC pattern very closely, and most Rails applications will
    be structured very heavily in terms of models, controllers, and views.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Rails非常遵循MVC模式，大多数Rails应用程序在模型、控制器和视图方面都会结构得非常严格。
- en: Another pattern on top of MVC that has been espoused by many Rails programmers
    over the last few years is fat models, skinny controllers. This concept encourages
    the practice of placing most of your domain logic within models, and that controllers
    should only be concerned about routing and interaction between models and views.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 过去几年中，许多Rails程序员提倡的一种MVC之上的模式是“胖模型，瘦控制器”。这个概念鼓励将大部分领域逻辑放在模型中，而控制器只应关注路由以及模型和视图之间的交互。
- en: Running our application
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: 'At this stage we can already run our Rails application to see if it all worked.
    From the terminal, enter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们 already 可以运行我们的Rails应用程序来查看是否一切正常。从终端输入：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Rails will now start hosting a local web server for our application on port
    **3000**. You can test it by browsing to `http://localhost:3000/`. If all went
    well, then you should see the following friendly welcome message:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Rails现在将在端口**3000**上为我们应用程序启动一个本地Web服务器。您可以通过浏览到`http://localhost:3000/`来测试它。如果一切顺利，那么您应该看到以下友好的欢迎信息：
- en: '![Running our application](img/9588_04_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的应用程序](img/9588_04_01.jpg)'
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Remember to keep this server running in a separate console window as we test
    our application. You can also check the output of this process for any errors
    that might occur while it's running.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在另一个控制台窗口中保持这个服务器运行，因为我们测试我们的应用程序。您还可以检查这个过程的输出，以查找可能发生的任何错误。
- en: Our todo_items resource
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的待办事项资源
- en: So, we now have a running application, but it doesn't do much except show us
    a welcome page.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个正在运行的应用程序，但它除了显示欢迎页面之外并没有做什么。
- en: To get to our goal of being able to track to-do tasks, we'll generate a resource
    for our to-do items. In Rails parlance, a resource consists of a model, a controller
    with some actions, as well as views for those actions.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到跟踪待办任务的最终目标，我们将为我们的待办事项生成一个资源。在Rails术语中，资源由一个模型、具有一些操作的控制器以及这些操作的视图组成。
- en: 'At the terminal, run the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端，运行以下命令：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What did this do? This is an example of Rails' generator syntax, which can be
    used to generate boilerplate code. Here, we tell it to create a "resourceful"
    controller named `TodoItemsController` and a model, `TodoItem`, which has a `string`
    field for its title and a `boolean` flag to mark it as completed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这是什么操作？这是一个Rails生成器语法的示例，它可以用来生成样板代码。在这里，我们告诉它创建一个名为`TodoItemsController`的“资源型”控制器和一个模型`TodoItem`，该模型有一个用于标题的`string`字段和一个标记为完成的`boolean`标志。
- en: As you can see from the command output, it has generated a bunch of files as
    well as modified an existing one, in `config/routes.rb`. Let's start by opening
    this file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从命令输出中看到的，它还生成了一些文件，并在`config/routes.rb`中修改了一个现有的文件。让我们首先打开这个文件。
- en: routes.rb
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: routes.rb
- en: 'Here is what you should see at the top of the `routes.rb` file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`routes.rb`文件的顶部，您应该看到以下内容：
- en: '[PRE4]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In Rails, `routes.rb` defines how HTTP calls to URLs map to controller actions
    that can handle them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Rails中，`routes.rb`定义了HTTP调用如何映射到可以处理它们的控制器操作。
- en: Here, the generator added a line for us, which uses the `resources` method.
    This method creates the routes for the most common actions of a "resourceful"
    controller. This means it exposes a single domain resource in your application
    using the HTTP verbs, GET, POST, PUT, and DELETE.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，生成器为我们添加了一行，使用了`resources`方法。这个方法为“资源型”控制器的最常见操作创建路由。这意味着它使用HTTP动词GET、POST、PUT和DELETE在您的应用程序中公开单个领域资源。
- en: 'Usually, this will create routes for seven different controller actions, `index`,
    `show`, `new`, `create`, `edit`, `update`, and `destroy`. As you will see later
    on, we won''t need to create all these actions for our controller, so we''ll tell
    the `resources` method to filter out only the ones we want. Modify the file to
    look like the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这将创建七个不同的控制器操作的路由，即`index`、`show`、`new`、`create`、`edit`、`update`和`destroy`。您稍后将会看到，我们不需要为我们的控制器创建所有这些操作，因此我们将告诉`resources`方法只过滤出我们想要的。将文件修改如下代码片段：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The controller
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: In the call to `resources`, Rails uses the `:todo_items` symbol to conventionally
    map the `resources` method to `TodoItemsController`, which was also generated
    for us.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在`resources`的调用中，Rails使用`:todo_items`符号将`resources`方法传统地映射到为我们生成的`TodoItemsController`。
- en: 'Open the `app/controllers/todo_items_controller.rb` file; here is what you''ll
    see:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `app/controllers/todo_items_controller.rb` 文件；这里是你将看到的内容：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, there isn't a whole lot in here. A class named `TodoItemController`
    is declared, and it derives from the `ApplicationController` class. The `ApplicationController`
    class was also generated for us when we created the app, and it derives from `ActionController::Base`,
    which gives it a whole lot of functionality and lets it behave like a Rails controller.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这里并没有太多内容。一个名为 `TodoItemController` 的类被声明，并且它继承自 `ApplicationController`
    类。`ApplicationController` 类也是在创建应用时为我们生成的，并且它继承自 `ActionController::Base`，这给了它很多功能，并让它表现得像
    Rails 控制器。
- en: We should now be able to test out our controller by navigating to the `http://localhost:3000/todo_items`
    URL.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够通过导航到 `http://localhost:3000/todo_items` URL 来测试我们的控制器。
- en: What do you see? You should get the **Unknown action** error page stating that
    the `index` action could not be found for `TodoItemsController`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了什么？你应该会得到一个 **未知动作** 错误页面，指出 `TodoItemsController` 中找不到 `index` 动作。
- en: 'This is because the controller doesn''t yet have an `index` action defined,
    as specified in our `routes.rb` file. Let''s go ahead and add a method to our
    `TodoItemsController` class to handle that action; this is shown in the following
    code snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为控制器还没有定义 `index` 动作，正如我们在 `routes.rb` 文件中所指定的。让我们继续在我们的 `TodoItemsController`
    类中添加一个方法来处理这个动作；这将在下面的代码片段中显示：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we refresh the page, we get a different error message: **Template is missing**.
    This happens because we don''t have a template for the `index` action. By default,
    Rails will always try to return a rendered template that corresponds to the `index`
    action name. Let''s go ahead and add one now.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新页面，我们会得到一个不同的错误消息：**模板缺失**。这是因为我们没有为 `index` 动作提供模板。默认情况下，Rails 总是会尝试返回与
    `index` 动作名称相对应的已渲染模板。让我们现在就添加一个。
- en: The view
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: Rails views are saved in the `app/views` folder. Each controller will have a
    subfolder here containing its views. We already have an `index.html` file from
    the previous chapter, which we'll re-use here. To do this, we'll need to copy
    everything that is inside the `body` tag, excluding the last two `script` tags
    from the old `index.html` file, into a file called `app/views/todo_items/index.html.erb`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 视图保存在 `app/views` 文件夹中。每个控制器都会在这里有一个子文件夹，包含其视图。我们已经在上一章中有一个 `index.html`
    文件，我们将在这里重新使用它。为此，我们需要将 `body` 标签内的一切内容复制到名为 `app/views/todo_items/index.html.erb`
    的文件中，除了旧 `index.html` 文件中的最后两个 `script` 标签。
- en: 'You should end up with the following markup:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该得到以下标记：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Looking at this, you might be wondering where the rest of the HTML such as the
    enclosing `html`, `head`, and `body` tags have gone.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 看到这里，你可能想知道其余的 HTML，如包围的 `html`、`head` 和 `body` 标签去哪里了。
- en: 'Well, Rails has the concept of a layout file, which acts as a wrapper for all
    the other views. This way you can have a consistent skeleton for your site that
    you don''t need to create for each view. Our view will be embedded inside the
    default layout file: `app/views/layouts/application.html.erb`. Let''s have a look
    at that file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Rails 有一个布局文件的概念，它充当所有其他视图的包装器。这样，你可以有一个一致的网站骨架，你不需要为每个视图创建它。我们的视图将被嵌入到默认布局文件中：`app/views/layouts/application.html.erb`。让我们看看这个文件：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `stylesheet_link_tag` and `javascript_include_tag` methods will make sure
    that all the files specified in the `assets` folder are included in the HTML.
    The `<%= yield %>` line is where the current view will be rendered, which is `index.html.erb`
    in our case.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`stylesheet_link_tag` 和 `javascript_include_tag` 方法将确保所有在 `assets` 文件夹中指定的文件都包含在
    HTML 中。`<%= yield %>` 行是当前视图将被渲染的地方，在我们的例子中是 `index.html.erb`。'
- en: When we refresh the page now, we'll see the `index` page. Have a look at the
    source code to get an idea of how the final HTML is output.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新页面后，我们会看到 `index` 页面。查看源代码以了解最终的 HTML 是如何输出的。
- en: As you can see, our page is still unstyled and looks quite dull. Let's see if
    we can make it look pretty again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的页面仍然没有样式，看起来相当单调。让我们看看我们能否让它再次看起来很漂亮。
- en: The CSS
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS
- en: By default, the asset pipeline will look for CSS files in the `app/assets/stylesheets`
    folder. When we browse to this folder, we'll see a file named `todo_items.css.scss`,
    which was generated for us when we created the controller.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，资产管道会在 `app/assets/stylesheets` 文件夹中查找 CSS 文件。当我们浏览到这个文件夹时，我们会看到一个名为 `todo_items.css.scss`
    的文件，这是在我们创建控制器时为我们生成的。
- en: Copy the contents of the previous chapter's `styles.css` file into this file.
    Our `index` page should now look decent again.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一章的 `styles.css` 文件内容复制到这个文件中。现在我们的 `index` 页面应该看起来又体面了。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This file with the strange `.css.scss` extension is a Saas file ([http://sass-lang.com/](http://sass-lang.com/)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个具有奇怪 `.css.scss` 扩展名的文件是一个 Sass 文件 ([http://sass-lang.com/](http://sass-lang.com/))。
- en: Like CoffeeScript, Sass is an extended version of the normal CSS language, with
    a lot of nice features that make writing CSS easier and less repetitive.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CoffeeScript 一样，Sass 是正常 CSS 语言的扩展版本，具有许多使编写 CSS 更容易、更简洁的出色功能。
- en: As with CoffeeScript, it is the default CSS compiler in the Rails asset pipeline.
    The flavor of Sass that we're using is a superset of CSS, which means we can use
    normal CSS in this file without using any of the Sass features and it will work
    fine.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CoffeeScript 一样，它是 Rails 资产管道中的默认 CSS 编译器。我们使用的 Sass 版本是 CSS 的超集，这意味着我们可以在该文件中使用正常的
    CSS 而不需要使用 Sass 的任何功能，并且它将正常工作。
- en: Our model
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的模型
- en: 'So now we can see our to-do list, but we don''t have any items showing up.
    This time, instead of storing them locally, we''ll store them in the database.
    Luckily for us, we already have a database model that was generated for us when
    we created the resource and the `TodoItem` model, which is defined in `app/models/todo_item.rb`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们可以看到我们的待办事项列表，但没有任何条目显示出来。这次，我们不会将它们存储在本地，而是将它们存储在数据库中。幸运的是，我们已经有了一个数据库模型，它是我们在创建资源时自动生成的，即
    `TodoItem` 模型，该模型定义在 `app/models/todo_item.rb` 中：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, like with controllers, you can see that Rails models get most of their
    functionality by deriving from `ActiveRecord::Base`. The `attr_accessible` line
    tells `ActiveRecord` which fields on this model can be assigned to and from user
    input.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，就像控制器一样，你可以看到 Rails 模型通过从 `ActiveRecord::Base` 继承而获得大部分功能。`attr_accessible`
    行告诉 `ActiveRecord` 哪些字段可以从用户输入中分配和赋值。
- en: 'How do we use the model? Add the following highlighted code in `todo_items_controller.rb`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用模型？在 `todo_items_controller.rb` 中添加以下高亮代码：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line uses an `all` class method on the `TodoItem` class, which is also
    provided by `ActiveRecord`. This will return a new instance of the `TodoItem`
    class for each record in the database, which we can assign to an instance variable
    called `@todo_items` (in Ruby all instance variables start with an `@` symbol).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用了 `TodoItem` 类的 `all` 类方法，这也是由 `ActiveRecord` 提供的。这将返回数据库中每个记录的新 `TodoItem`
    类实例，我们可以将其分配给名为 `@todo_items` 的实例变量（在 Ruby 中，所有实例变量都以 `@` 符号开头）。
- en: When Rails executes a controller action, it will automatically make any of the
    controller instance variables available to the view being rendered, which is why
    we're assigning it here. We'll get to use it in our view soon.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Rails 执行控制器动作时，它会自动将任何控制器实例变量提供给正在渲染的视图，这就是为什么我们在这里将其赋值。我们很快就会在视图中使用它。
- en: Let's refresh the page again to see if this worked. Yet again, we get a **Could
    not find table 'todo_items'** error.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次刷新页面以查看是否成功。然而，我们再次遇到了 **找不到表 'todo_items'** 的错误。
- en: You've probably guessed that we're supposed to create a table called `todo_items`
    in a database somewhere. Luckily, Rails has already taken care of the hard work,
    using something called migration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经猜到，我们应该在某个数据库中创建一个名为 `todo_items` 的表。幸运的是，Rails 已经为我们处理了这项艰巨的工作，使用了一种称为迁移的方法。
- en: Migrations
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移
- en: 'When we generated our resource, Rails not only created a model for us, but
    also a database script written in Ruby, or **migration** . We should be able to
    open it in the `db/migrations` folder. The actual file will be prefixed with a
    timestamp and will end with `_create_todo_items.rb`. It should look similar to
    the following code snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们生成资源时，Rails 不仅为我们创建了一个模型，还创建了一个用 Ruby 编写的数据库脚本，或称为 **迁移**。我们应该能够在 `db/migrations`
    文件夹中打开它。实际的文件将以时间戳开头，并以 `_create_todo_items.rb` 结尾。它应该类似于以下代码片段：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This script will create a table named `todo_items` with the fields that we had
    specified when we generated the `todo_item` resource. It also creates two timestamp
    fields named `created_at` and `updated_at` using the `t.timestamps` method. Rails
    will make sure that fields with those names get updated with the appropriate timestamp
    when a record gets created or updated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将创建一个名为 `todo_items` 的表，其中包含我们在生成 `todo_item` 资源时指定的字段。它还使用 `t.timestamps`
    方法创建了两个时间戳字段，名为 `created_at` 和 `updated_at`。Rails 将确保在创建或更新记录时，具有这些名称的字段会更新为适当的时间戳。
- en: 'Migration scripts are a wonderful way of automating database changes, even
    allowing you to roll back a previous change. You don''t have to rely on migrations
    created by resource or model generators either. Custom migrations can be generated
    by running the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移脚本是一种自动化数据库更改的绝佳方式，甚至允许你回滚之前的更改。你也不必依赖于由资源或模型生成器创建的迁移。可以通过运行以下命令来生成自定义迁移：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After generating your custom migration, you can just implement the `up` and
    `down` methods, which will be called when your migration gets executed or rolled
    back.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成你的自定义迁移之后，你只需实现 `up` 和 `down` 方法，这些方法将在你的迁移执行或回滚时被调用。
- en: 'Migrations are executed with the `rake` command. `rake` is a task-management
    tool that allows you to write tasks as Ruby scripts, which are then run using
    the `rake` command-line utility. Rails comes with a whole lot of built-in `rake`
    tasks, and you can see the full list of them by using:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是通过 `rake` 命令执行的。`rake` 是一个任务管理工具，它允许你将任务编写为 Ruby 脚本，然后通过 `rake` 命令行工具运行。Rails
    随带了许多内置的 `rake` 任务，你可以通过以下方式查看它们的完整列表：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The task that we''re interested in the moment is called `db:migrate` , let''s
    run it and see what happens:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们感兴趣的任务是名为 `db:migrate` 的任务，让我们运行它看看会发生什么：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should see the following output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '**== CreateTodoItems: migrating ================================================**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**== CreateTodoItems: 迁移中 ==================================================**'
- en: '**-- create_table(:todo_items)**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**-- create_table(:todo_items)**'
- en: '**-> 0.0011s**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**-> 0.0011s**'
- en: '**== CreateTodoItems: migrated (0.0013s) =======================================**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**== CreateTodoItems: 迁移完成 (0.0013s) =====================================**'
- en: This means Rails has successfully created a `todo_items` table for us in the
    database. When we refresh the application page, we should see that the error is
    gone and we're seeing our blank to-do list.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Rails 已经成功地在数据库中为我们创建了一个 `todo_items` 表。当我们刷新应用程序页面时，我们应该看到错误已经消失，我们看到了我们的空白待办事项列表。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Where is the database?**'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库在哪里？**'
- en: You might have wondered where our actual database lives at the moment. Rails
    defaults to using an embedded SQLite database. SQLite ([http://www.sqlite.org](http://www.sqlite.org))
    is a self-contained, file-based database that doesn't need a server to be configured
    for it to run. This makes it really nice and easy to get up and running quickly
    when developing an application.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们的实际数据库目前在哪里。Rails 默认使用嵌入式的 SQLite 数据库。SQLite ([http://www.sqlite.org](http://www.sqlite.org))
    是一个自包含的、基于文件的数据库，不需要配置服务器即可运行。这使得在开发应用程序时快速启动和运行变得非常方便。
- en: Once you actually deploy your web app, you would probably want to go with a
    more traditional database server, such as MySQL or PostgreSQL. You can easily
    change your database connection settings in the `config/database.yml` file.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你实际部署你的网络应用程序，你可能希望使用更传统的数据库服务器，例如 MySQL 或 PostgreSQL。你可以在 `config/database.yml`
    文件中轻松更改你的数据库连接设置。
- en: We still haven't hooked up our view to actually show the list of to-do items.
    Before we do that, let's manually create a couple of to-do items in the database.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有将我们的视图与显示待办事项列表的实际功能连接起来。在我们这样做之前，让我们在数据库中手动创建几个待办事项。
- en: The Rails console
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rails 控制台
- en: 'Rails has a nifty way of interactively playing with your code by using the
    Rails console. This is an interactive Ruby interpreter, or **irb**, session with
    all the Rails project code loaded. Let''s fire it up by using the following command:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 通过使用 Rails 控制台以交互方式与你的代码进行玩耍，这是一种加载了所有 Rails 项目代码的交互式 Ruby 解释器，或称为 **irb**
    会话。让我们通过以下命令启动它：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once you''re in the console you can enter any valid Ruby code. You can also
    access all the models in your Rails app. Let''s try it with the `TodoItem.all`
    method that we used earlier; this is shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进入控制台，你可以输入任何有效的 Ruby 代码。你还可以访问你 Rails 应用程序中的所有模型。让我们用之前用过的 `TodoItem.all`
    方法来试一试；这将在以下屏幕截图中展示：
- en: '![The Rails consoleRails consoleabout](img/9588_04_02.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Rails 控制台Rails 控制台关于](img/9588_04_02.jpg)'
- en: At the moment it returns an empty array, since our table is still empty. Notice
    that Rails also outputted the SQL query that it has generated to get all the records.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 目前它返回一个空数组，因为我们的表仍然是空的。注意，Rails 还输出了它为获取所有记录生成的 SQL 查询。
- en: 'From here we can also create a new to-do item using our model. The following
    code will do that:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们也可以使用我们的模型创建一个新的待办事项。以下代码将完成这个任务：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we should have a single to-do item in our table. You can verify this by
    using `TodoItem.first`, which will return the first item in our table.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该在我们的表格中只有一个待办事项。你可以通过使用 `TodoItem.first` 来验证这一点，它将返回我们表格中的第一个项目。
- en: 'I want to make sure that our model always has a title. `ActiveRecord` has very
    powerful validation features that are built-in, which allows for specifying constraints
    on model attributes in a very declarative manner. Let''s make sure that our model
    always checks for the presence of a title before saving; to do this, add the following
    highlighted code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我想要确保我们的模型始终有一个标题。`ActiveRecord` 有非常强大的内置验证功能，允许以非常声明性的方式指定模型属性的约束。让我们确保我们的模型在保存之前始终检查标题的存在；为此，添加以下突出显示的代码：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Go ahead and create a couple of other to-do items. Once you have done this,
    try running `TodoItem.all` again. This time it returns an array of `TodoItem`
    instances.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 继续创建一些其他的待办事项。一旦完成，再次尝试运行 `TodoItem.all`。这次它返回一个 `TodoItem` 实例的数组。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To exit the rails console, just enter `exit`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出 Rails 控制台，只需输入 `exit`。
- en: Displaying the items in our view using ERB
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ERB 在我们的视图中显示项目
- en: 'To display our to-do items in our view, we''ll use the `@todo_items` instance
    variable that we created in our controller action. Let''s modify the `app/views/todo_items.html.erb`
    file and mix in some Ruby using ERB; add the code that is highlighted in the following
    code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的视图中显示待办事项，我们将使用我们在控制器操作中创建的 `@todo_items` 实例变量。让我们修改 `app/views/todo_items.html.erb`
    文件，并使用 ERB 混合一些 Ruby；在以下代码片段中添加突出显示的代码：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'ERB templates are quite simple to understand. The basic idea is that you write
    your HTML as normal and mix in Ruby using ERB tags. The following three tags are
    important:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ERB 模板很容易理解。基本思想是，你像平常一样编写你的 HTML，然后使用 ERB 标签混合 Ruby。以下三个标签很重要：
- en: '[PRE20]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In our `index` ERB template, we use Ruby's `each` iterator to loop through all
    the elements in the `@todo_items` array instance variable; `each` takes a Ruby
    block as an argument. A block is a piece of code that can be passed to a method
    as data, similar to how functions can be passed as arguments in CoffeeScript.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `index` ERB 模板中，我们使用 Ruby 的 `each` 迭代器遍历 `@todo_items` 数组实例变量中的所有元素；`each`
    接收一个 Ruby 块作为参数。块是一段可以被传递给方法作为数据的代码，类似于在 CoffeeScript 中函数可以作为参数传递的方式。
- en: This block will be executed for each item in the array, passing it in as the
    item variable. For each item, we create its markup, using the item's `title` and
    `completed` attributes inside of our ERB tags.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块将为数组中的每个项目执行，将其作为项目变量传递。对于每个项目，我们创建其标记，在 ERB 标签中使用项目的 `title` 和 `completed`
    属性。
- en: 'When we refresh the page, we should now finally see our list of to-do items!
    If you are curious, have a look at the HTML source of the document and compare
    it to the ERB template, this should give you a good idea of how it was generated.
    The output page is shown in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们刷新页面时，我们现在最终应该看到我们的待办事项列表！如果你好奇，查看文档的 HTML 源代码，并将其与 ERB 模板进行比较，这应该能给你一个很好的想法它是如何生成的。输出页面在以下屏幕截图中显示：
- en: '![Displaying the items in our view using ERB](img/9588_04_03.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ERB 在我们的视图中显示项目](img/9588_04_03.jpg)'
- en: Creating a partial
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建部分
- en: 'At the moment, our view code is starting to get a bit messy, especially the
    to-do items list. We can clean it up a bit by using a **view partial** , which
    allows us to pull out snippets of our view into a separate file. This can then
    be rendered where we need it in the main view. Add the line of code highlighted
    in the following code snippet to your file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的视图代码开始变得有些杂乱，特别是待办事项列表。我们可以通过使用 **视图部分** 来清理它，这允许我们将视图的片段拉到一个单独的文件中。然后，我们可以在主视图中需要的地方渲染它。在你的文件中添加以下代码片段中突出显示的行：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We''ll move the to-do item markup to its own partial file. By convention, partial
    filenames start with an underscore, and when rendering a partial, Rails will look
    for a file with the same name as the specified partial, with a leading underscore.
    Go ahead and create a file: `app/views/todo_items/_todo_item.html.erb` with the
    following content:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把待办事项标记移动到它自己的部分文件中。按照惯例，部分文件名以下划线开头，当渲染部分时，Rails 会寻找与指定的部分具有相同名称的文件，且文件名以一个下划线开头。继续创建一个文件：`app/views/todo_items/_todo_item.html.erb`，内容如下：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If all went well, our view should still work as before, and we have cleaned
    up the main view code nicely. Simplifying views with partials are also great for
    reusability, which we'll see later on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们的视图应该仍然像以前一样工作，我们已经很好地清理了主要的视图代码。使用部分来简化视图也是为了提高可重用性，我们稍后会看到这一点。
- en: Our to-do list app still needs some work. At the moment, we can't add new tasks
    and the completed task and delete actions don't work either. This calls for some
    client-side code, which means we can finally start using some CoffeeScript.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的待办事项应用还需要做一些工作。目前，我们无法添加新任务，完成的任务和删除操作也不起作用。这需要一些客户端代码，这意味着我们终于可以开始使用一些 CoffeeScript
    了。
- en: Adding new items
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新项目
- en: 'To add new items to our to-do list, we''ll use some of Rails'' native AJAX
    capabilities. The following code snippet is a modified version of the `todo` input
    on our `index` view:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新项目添加到我们的待办事项列表中，我们将使用一些 Rails 的原生 AJAX 功能。以下代码片段是我们在 `index` 视图上修改后的 `todo`
    输入：
- en: '[PRE23]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So what has changed here? First, you'll notice that we have included the `form_for`
    method, with another call to `text_field` inside of its block. These are Rails'
    view helpers, which are Ruby methods available inside of views, that provide ways
    of building the HTML output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里有什么变化？首先，你会注意到我们包含了 `form_for` 方法，并在其块内调用另一个 `text_field`。这些都是 Rails 的视图辅助方法，它们是
    Ruby 方法，可以在视图中使用，提供构建 HTML 输出的方式。
- en: The `form_for` method will output an HTML `form` tag, and the `text_field` method
    will generate an `input` tag inside the form, which will be of type `text`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`form_for` 方法将输出一个 HTML `form` 标签，而 `text_field` 方法将在表单内生成一个 `input` 标签，其类型为
    `text`。'
- en: We pass a new instance of `TodoItem` as a parameter to the `form_for` method.
    Rails is smart enough to know from the `TodoItem` instance that the form's URL
    should point to `TodoItemController`, and will use attributes of the `TodoItem`
    model as names of inputs inside the form.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `TodoItem` 的新实例作为参数传递给 `form_for` 方法。Rails 足够聪明，可以从 `TodoItem` 实例中知道表单的
    URL 应该指向 `TodoItemController`，并且将使用 `TodoItem` 模型的属性作为表单内输入的名称。
- en: The real magic comes in with the `:remote => true` parameter sent to the `form_for`
    method. This tells Rails that you want this form to be submitted using AJAX. Rails
    will take care of all of this in the background.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的魔法来自于发送给 `form_for` 方法的 `:remote => true` 参数。这告诉 Rails 你希望使用 AJAX 提交这个表单。Rails
    将在后台处理所有这些。
- en: 'So which controller action will my form be submitted to? Since we specified
    its action as `post`, it will map to a `create` action in `TodoItemController`.
    We don''t have one yet, so let''s go and write it:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我的表单将提交到哪个控制器动作？由于我们指定了它的动作为 `post`，它将映射到 `TodoItemController` 中的 `create`
    动作。我们还没有一个，所以让我们去写一个：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we create `TodoItem` using the `:todo_item` key in `params`—`params`,
    which is a Ruby hash that Rails created. It contains a value with the key, `:todo_items`,
    which is a hash containing all the parameter values that were submitted from the
    form. When we pass this hash to the `TodoItem.create` method, Rails will know
    how to map them to attributes on our new model and save it to the database.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `params` 中的 `:todo_item` 键创建 `TodoItem`——`params` 是 Rails 创建的 Ruby
    哈希。它包含一个具有 `:todo_items` 键的值，这是一个包含从表单提交的所有参数值的哈希。当我们把这个哈希传递给 `TodoItem.create`
    方法时，Rails 将知道如何将它们映射到我们新模型上的属性并将它们保存到数据库中。
- en: Let's try and add a to-do item
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们尝试添加一个待办事项
- en: Type a title in our input box for a new to-do item and hit *Enter*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的输入框中输入一个新待办事项的标题并按 *Enter*。
- en: 'However, it seems like nothing happened. We can head over to the output of
    our running Rails server session to see if we can spot any errors. If you scroll
    around a bit, you should see an error similar to the following error message:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，看起来什么都没发生。我们可以查看正在运行的 Rails 服务器会话的输出，看看是否能找到任何错误。如果你稍微滚动一下，你应该会看到一个类似于以下错误消息的错误：
- en: '**ActionView::MissingTemplate (Missing template todo_items/create, application/create
    with {:locale=>[:en], :formats=>[:js, "application/**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**ActionView::MissingTemplate (Missing template todo_items/create, application/create
    with {:locale=>[:en], :formats=>[:js, "application/**'
- en: '**ecmascript", "application/x-ecmascript", :html, :text, :js, :css, :ics, :csv,
    :png, :jpeg, :gif, :bmp, :tiff, :mpeg, :xml, :rss, :atom,**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**ecmascript", "application/x-ecmascript", :html, :text, :js, :css, :ics, :csv,
    :png, :jpeg, :gif, :bmp, :tiff, :mpeg, :xml, :rss, :atom,**'
- en: '**:yaml, :multipart_form, :url_encoded_form, :json, :pdf, :zip], :handlers=>[:erb,
    :builder, :coffee]}. Searched in:**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**:yaml, :multipart_form, :url_encoded_form, :json, :pdf, :zip], :handlers=>[:erb,
    :builder, :coffee]}. Searched in:**'
- en: '*** "/home/michael/dev/todo/app/views"**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*** "/home/michael/dev/todo/app/views"**'
- en: '**)**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**)**'
- en: Adding a CoffeeScript view
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 CoffeeScript 视图
- en: So, it seems we still need to do one more thing. All controller actions will
    try and render a view by default. When we try adding a to-do item now, we would
    get the same **Template is missing** error as earlier. It might not be clear what
    should happen, since the form was posted using AJAX. Should we still render a
    view? And how would it look?
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，似乎我们还需要做一件事。所有控制器动作都会默认尝试渲染一个视图。当我们现在尝试添加待办事项时，我们会得到与之前相同的 **模板缺失** 错误。由于表单是使用
    AJAX 提交的，所以可能不清楚应该发生什么。我们是否仍然需要渲染一个视图？它会是什么样子？ '
- en: Looking at the error message a bit more closely might give us a clue. Since
    our action was invoked using AJAX, Rails will, by default, look for a CoffeeScript
    view to render as JavaScript.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看错误信息可能会给我们一些线索。由于我们的动作是通过 AJAX 调用的，Rails 默认会寻找一个 CoffeeScript 视图来渲染成 JavaScript。
- en: The generated JavaScript will serve as the response to the AJAX call and will
    be executed on completion. This also seems like the perfect place to update our
    to-do items list, after creating it on the server.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 JavaScript 将作为 AJAX 调用的响应，并在完成后执行。这似乎也是更新我们在服务器上创建的待办事项列表的完美位置。
- en: We'll create a CoffeeScript view template for our `create` action in `app/views/todo_items/create.js.coffee`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `app/views/todo_items/create.js.coffee` 中为我们的 `create` 动作创建一个 CoffeeScript
    视图模板。
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, in the previous code snippet, we grab the `#new-todo` input and clear
    its value. We then render the same `todo_item` partial that we used before, passing
    in the `@todo_item` instance variable that we created in our controller action.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们获取了 `#new-todo` 输入并清除了其值。然后我们渲染了之前使用的相同的 `todo_item` 部分视图，传递了在控制器动作中创建的
    `@todo_item` 实例变量。
- en: We wrap the render call in an `escape_javascript` helper method, which will
    ensure that any special JavaScript character will be escaped in our string. We
    then append the newly rendered partial to our `#todo-list` element.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将渲染调用包裹在 `escape_javascript` 辅助方法中，这将确保我们的字符串中的任何特殊 JavaScript 字符都会被转义。然后我们将新渲染的部分追加到我们的
    `#todo-list` 元素中。
- en: Try it out. We can now finally create to-do list items!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。我们现在终于可以创建待办事项列表项了！
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Where did jQuery come from?**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**jQuery 从何而来？**'
- en: Rails already included jQuery for us. The Rails asset pipeline uses a manifest
    file, `app/assets/javascript/application.js` to include required dependencies,
    for instance jQuery.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Rails 已经为我们包含了 jQuery。Rails 资产管道使用一个清单文件，`app/assets/javascript/application.js`，来包含所需的依赖项，例如
    jQuery。
- en: CoffeeScript in the asset pipeline
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产管道中的 CoffeeScript
- en: Notice how seamless this all was? Rails treats CoffeeScript as a first-class
    citizen in its stack, and will make sure that the `.coffee` files get compiled
    into JavaScript before they are used. The fact that you can also pre-process your
    CoffeeScript using ERB templates on the server makes this even more powerful.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这一切是多么的流畅？Rails 将 CoffeeScript 视为其堆栈中的第一公民，并确保在它们被使用之前，`.coffee` 文件被编译成 JavaScript。你还可以在服务器上使用
    ERB 模板预先处理 CoffeeScript，这使得它更加强大。
- en: Completing the to-do items
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成待办事项
- en: Let's hook up this functionality. This time, we will do things a bit differently
    to show you a different style of writing CoffeeScript in Rails. We'll follow the
    more traditional approach of handling the AJAX call ourselves.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接这个功能。这次，我们将采取不同的方式来展示在 Rails 中编写 CoffeeScript 的不同风格。我们将遵循处理 AJAX 调用的更传统方法。
- en: Rails has already created a file where we can put our client-side code, back
    when we created the controller. Each controller will get its own CoffeeScript
    file, which will be included in the page automatically for any action on that
    controller.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建控制器时，Rails 已经创建了一个文件，我们可以将其用于客户端代码。每个控制器都会得到自己的 CoffeeScript 文件，该文件将在页面上自动包含任何对该控制器动作的操作。
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: There is also an `application.js.coffee` file, where global client-side code
    can be added.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 `application.js.coffee` 文件，可以在其中添加全局客户端代码。
- en: 'The file that we''re interested in will be `app/assets/views/javascripts/todo_items.js.coffee`.
    We can replace the contents of it with the following code, which will handle the
    AJAX call when completing a task:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的文件将是 `app/assets/views/javascripts/todo_items.js.coffee`。我们可以用以下代码替换其内容，该代码将处理完成任务时的
    AJAX 调用：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we define a function called `toggleItem`, which we set up to be called
    when a checkbox value changes. In this function we toggle the parent `li` element's
    `completed` class and get the ID of the to-do item using its `data` attribute.
    We then make an AJAX call to `TodoItemController` to update the item with the
    current checked value of the checkbox.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为 `toggleItem` 的函数，该函数在复选框值改变时被调用。在这个函数中，我们切换父 `li` 元素的 `completed`
    类，并使用其 `data` 属性获取待办事项的 ID。然后，我们向 `TodoItemController` 发起一个 AJAX 调用，以更新复选框的当前选中值。
- en: 'Before we can run this code, we''ll need to add an `update` action to our controller,
    which is shown in the following code snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够运行此代码之前，我们需要在我们的控制器中添加一个 `update` 动作，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`params[:id]` will be the value of the ID in the URL. We use this to find the
    to-do item and then call the `update_attributes` method, which do just that, update
    our model and save it to the database. Note that we explicitly tell Rails not
    to render a view here by calling `render nothing: true`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`params[:id]` 将是 URL 中 ID 的值。我们使用这个值来查找待办事项，然后调用 `update_attributes` 方法，它正是这样做的，更新我们的模型并将其保存到数据库中。注意，我们明确告诉
    Rails 不要渲染视图，通过调用 `render nothing: true`。'
- en: Setting tasks to completed should now work. Notice that when you refresh the
    page, tasks stay completed, since they were saved to the database.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 将任务设置为已完成现在应该可以工作。注意，当你刷新页面时，任务保持已完成状态，因为它们已经被保存到数据库中。
- en: Removing tasks
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除任务
- en: For removing tasks, we'll follow a very similar pattern.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于移除任务，我们将遵循一个非常相似的模式。
- en: 'In `todo_items.js.coffee`, add the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `todo_items.js.coffee` 文件中，添加以下代码：
- en: '[PRE28]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In our controller, add the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的控制器中，添加以下代码：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That should be all we need to remove list items. Notice that here we only remove
    the element once the AJAX call was successful, by handling the `success` callback.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 那应该就是我们需要移除列表项的所有内容。注意，在这里我们只在 AJAX 调用成功后移除元素，通过处理 `success` 回调。
- en: Now, it's your turn
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在，轮到你了
- en: As a final exercise to you, I will ask you to make the **Clear completed** button
    work. As a hint, you should be able to use the existing `destroyItem` method functionality.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的练习，我会要求你使 **清除已完成** 按钮工作。作为一个提示，你应该能够使用现有的 `destroyItem` 方法功能。
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter started with a whirlwind tour of Ruby on Rails. You have hopefully
    grown to appreciate some of the magic that Rails offers web developers and how
    much fun it can be developing a Rails app. We have also spent some time discovering
    how easy it is to use CoffeeScript in a Rails app, and the different approaches
    and techniques you would typically use to write client-side code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以对 Ruby on Rails 的快速浏览开始。你可能会逐渐欣赏 Rails 为网络开发者提供的魔法，以及开发 Rails 应用程序有多么有趣。我们还花了一些时间发现使用
    CoffeeScript 在 Rails 应用程序中是多么容易，以及你通常会用到的不同方法和技巧来编写客户端代码。
- en: If you haven't done so already, I encourage you to spend some more time learning
    Rails as well as Ruby, and immersing yourself in the wonderful communities they
    support.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有这样做，我鼓励你花更多的时间学习 Rails 以及 Ruby，并沉浸在他们支持的精彩社区中。
- en: In the next chapter, we'll explore yet another new exciting server framework
    that was built using JavaScript, and how CoffeeScript relates to it.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索另一个使用 JavaScript 构建的新兴服务器框架，以及 CoffeeScript 与其的关系。
