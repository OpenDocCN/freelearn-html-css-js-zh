<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-74"><a id="_idTextAnchor073"/>5</h1>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Framework Considerations</h1>
<p>In the previous chapters, we primarily focused on learning from other framework projects to prepare for building our full stack JavaScript framework, which will include the ability to create backend infrastructure and frontend interfaces and will have capabilities to test both sides of these features. Even though our goal is a full stack framework for application development, you will be able to use what you learned from this experience and apply it to similar JavaScript projects. Existing projects’ architectural patterns and design decisions will help us orient our project and set it up for success. In this chapter, we will study three factors to consider when we plan out our framework that are useful for aspiring software architects and those considering being the responsible individuals behind larger technical project decisions.</p>
<p>Items to cover for the purposes of our framework considerations are set out here:</p>
<ul>
<li><strong class="bold">Determining project goals</strong>: Focusing on what you are building and who will be the main consumer and patron of the framework’s APIs</li>
<li><strong class="bold">Identifying framework problem spaces</strong>: Aligning with the problem space of the new framework you are developing</li>
<li><strong class="bold">Technical design decisions</strong>: Factors such as the technological stack, architecture, and development approach that shape your framework’s uniqueness from other projects</li>
</ul>
<p>In this chapter and generally in this book, we are considering an educational approach to framework building, which means that future chapters will cover the development of specific kinds of JavaScript frameworks, focusing on web application systems. However, you can utilize the gathered knowledge to build a framework that satisfies your particular needs.</p>
<p>The following image will help us focus on the consideration categories and highlights particular subsections that are useful to know as part of the planning and development cycles:</p>
<div><div><img alt="Figure 5.1: Framework development pillars" src="img/Figure_5.1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1: Framework development pillars</p>
<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>Technical requirements</h1>
<p>The technical requirements are similar to the preceeding chapters. Use the <code>chapter5</code> directory from the book's repository to run <code>npm install</code> and then <code>npm start</code> to quickly get started with the code and samples that are mentioned in this chapter.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Determining project goals</h1>
<p>While contemplating <a id="_idIndexMarker393"/>building a new framework, you must identify your project’s objectives and stakeholders. These two factors are the main drivers behind your time and investment into building something new. Embarking on a new framework project requires understanding potential motivators and a clear insight into the goals, emphasizing the developer you support and their needs. These reasons can range from internal work use cases to open source hobby projects. Your scenario may very well differ but based on <em class="italic">Figure 5</em><em class="italic">.1</em>, we can explore the first pillar—<em class="italic">project goals</em>—as part of this section.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Context</h2>
<p>Comprehending the context<a id="_idIndexMarker394"/> of a project is fundamental to guiding its development and ensuring it meets the needs of its intended users. The context involves assessing factors such as the project’s purpose, target audience, and the environments in which it will be used. Two contexts for framework projects are along the following themes:</p>
<ul>
<li>Work-related company-backed initiatives</li>
<li>Public open source projects, often with an educational or hobby nature</li>
</ul>
<p>Each of these scenarios comes with its distinctive set of necessities and considerations.</p>
<p>Frameworks developed for particular business needs could have business objectives ranging from small start-up environments to large enterprises. Professional use cases, contextualized in building a framework for business needs, can drastically vary. For instance, similar to the initial development of the React library, a project can support a single platform such as Facebook. However, business needs can also include developing a framework for repeating use cases, such as deploying multiple services with the same core architecture.</p>
<p>Hobby/open source projects can grow from <strong class="bold">proofs of concept</strong> (<strong class="bold">PoCs</strong>) or learning materials to widely used tools across the software industry. These are usually not monetarily impactful, but they can serve as a growth tool for your career and practical knowledge. Focus on expanding your skill set in particular software development and JavaScript knowledge areas.</p>
<p>It is a good idea to determine and align the project’s goals for your new framework before writing any code. If your project focuses on internal company use cases, such as supporting internal company products, then the goals are more tailored toward enhancing efficiency, improving collaboration, and streamlining the development process. Ultimately, all the planning and building support the main core goal—enabling the organization to ship higher-quality and more reliable projects faster.</p>
<p>Once your framework progresses, the context can potentially alter into something new. For example, if the framework was initially started as an internal project, further down the road, you could open source it and leverage the input from other developers who are not directly associated with it. It can also work the other way—a framework started as a hobby project could be picked up for internal professional use with new investment supported by commercial clients. Both of these scenarios are quite common in the software<a id="_idIndexMarker395"/> development industry.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Stakeholders</h2>
<p>The target audience<a id="_idIndexMarker396"/> and stakeholders of your project are your framework’s customers. They are the ones that expect an easy-to-use system with adequate programming interfaces. Catering to their needs and expectations is vital for the success of your framework. These users are looking for a system that is easy to use and provides efficient programming interfaces, allowing them to develop applications and services with ease and agility.</p>
<p>To create a framework that appeals to your target audience, your investment into stakeholder support is essential to ensure that the developer experience is intuitive and user-friendly. Stakeholder support involves designing clear, well-organized resources and providing example code and use cases that solve everyday problems. Often, you will need to offer support to your stakeholders directly or through other means. You will encourage adaptation by making it easier for developers to understand and navigate your framework.</p>
<p>The robust programming interfaces that cater to the diverse needs of your audience also play an important role. By offering practical, adaptable, and efficient tools, you will empower your users to tackle their projects confidently and foster a sense of trust and loyalty toward your framework.</p>
<p>As a framework developer, remember that your audience’s needs and expectations should be at the forefront of your design process, so your aim should be to deliver a user-centric experience that stands out in the competitive landscape and becomes an invaluable asset to developers and stakeholders.</p>
<p>In the context of this book, the framework has the reader as the stakeholder, focusing on educational materials. If you are following along and creating your own framework, consider yourself the stakeholder. This makes things much easier; you have the freedom to alter and change the pathway of your framework.</p>
<p>In the next section, we look at several other considerations that could be beneficial to reflect upon before you start coding.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Other considerations</h2>
<p>Additional project <a id="_idIndexMarker397"/>considerations in framework development are very similar to those of a small or large team developing software projects. Helpful questions to consider as part of determining if your project needs to exist and should be built are along the following themes:</p>
<ul>
<li><strong class="bold">The general purpose of the framework</strong>: This is derived from the core objectives; you should have a clear understanding of the primary reasons to deliver your project, identifying specific software-related problems and aiming to solve them.</li>
<li><strong class="bold">Survey of existing tools</strong>: Before building something new from scratch, evaluating projects already in the ecosystem is a good idea. This consideration will help you make a decision to internally use some of the tools or extend them to fit your needs.</li>
<li><strong class="bold">Maintenance costs</strong>: Depending on the size of resources to address your framework’s problem space, you need to understand time and money investments into the project. Projecting this will help you allocate resources appropriately and ensure the project’s long-term sustainability.</li>
<li><strong class="bold">Innovative and distinctive features</strong>: Identify unique selling points and advantages that your framework will offer compared to existing solutions in the ecosystem. This could include advanced functionality, enhanced performance, or unexplored approaches to solving typical problems.</li>
<li><strong class="bold">Resourcing</strong>: Assess your development team’s skills, expertise, and availability, and identify any gaps that may need to be addressed. This could involve hiring new team members or seeking external support to ensure the successful development of the framework. In some cases, you could be the only resource powering the development of this project. This comes with the advantages of efficient design making but puts you in the driving seat for the whole project.</li>
<li><strong class="bold">Roadmap</strong>: Develop a comprehensive roadmap outlining project milestones and feature support. By spending time on this, you can provide a clear vision for the development process and help keep the project on track while communicating the framework’s direction to its stakeholders.</li>
<li><strong class="bold">Timeline</strong>: Determine how much time you invest in the framework. This involves setting realistic deadlines for each project stage and considering potential risks and obstacles that may impact the timeline. By establishing a well-defined timeline, you can ensure that the project progresses efficiently and focuses on delivering value to its intended audience.</li>
</ul>
<p>All the considerations mentioned in this section can contribute to your development process. Spending a little time figuring out the answer to all these considerations could greatly benefit your<a id="_idIndexMarker398"/> project. A lot of these considerations will depend on the problem space of your framework. To help handle this, we will cover potential problem spaces in the next section.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Identifying framework problem spaces</h1>
<p>Frameworks are <a id="_idIndexMarker399"/>designed to support the development of one or many projects, focusing on solving a particular problem space. We define a problem space as a set of challenges or a range of problems that the framework is prepared to address; this is the second pillar from <em class="italic">Figure 5</em><em class="italic">.1</em>. A problem space can be a specific software application area in which the framework is intended to be used.</p>
<p>As we saw from examples of frameworks in previous chapters of this book, JavaScript has a broad reach in client and server environments. It enables us to build frameworks to fit our needs and technological requirements. For your brand new project, you could potentially be tackling a particular framework category. By focusing on the technical aspects of a unique project, combined with innovative features, you can make your project different from what is already available out there in the wild.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Popular problem spaces</h2>
<p>Here are some <a id="_idIndexMarker400"/>potential development paths you could take in the JavaScript framework problem space:</p>
<ul>
<li><strong class="bold">Frontend frameworks</strong>: Focused on building frontend applications’ frameworks, you can find ways to utilize the latest browser technologies to develop unique rendering techniques and improve on state management. Given that this is a popular category of frameworks with many existing solutions, a more straightforward approach is to write your own abstractions on top of these existing solutions—for example, internally using a project such as Vue.js while developing your own self-developed framework interfaces. This way, you can approach your problem space, focusing on its challenges and solving them instead of reinventing the basics.</li>
<li><strong class="bold">Browser-focused solutions</strong>: Similar to the previous point, you could take the approach of building browser-focused solutions, different from frameworks focused on web application development, and concentrate on utilizing new technologies available to web browsers. For instance, you could leverage WebAssembly (<a href="https://webassembly.org">webassembly.org</a>) or WebGPU (<a href="https://w3.org/TR/webgpu">w3.org/TR/webgpu</a>) to develop unique frameworks in the client-side environment.</li>
<li><strong class="bold">Backend applications</strong>: If you are building a new JavaScript framework for backend <a id="_idIndexMarker401"/>development, it is important to focus on reliability, scalability, and security features. You could start by looking over the examples from this book or elsewhere on the internet, then build a framework that addresses common backend challenges, such as working with certain types of databases, enabling different types of authentication, and rapid API development techniques.</li>
<li><strong class="bold">Testing</strong>: If you are building a new testing framework for JavaScript applications, you could focus on providing a simple and intuitive interface for writing and running tests. You could also enable built-in support for popular testing frameworks and libraries and integrations with continuous integration tools. You could also provide advanced testing features such as visual regression testing, unique parallelization and grouping techniques, and pattern-matching-powered test automation. In <a href="B19014_06.xhtml#_idTextAnchor089"><em class="italic">Chapter 6</em></a> of this book, we will start developing a simple testing framework, while focusing on the learning process; it is a good contender for a simpler type of framework.</li>
<li><strong class="bold">Native applications</strong>: By building a new framework for native applications, you could focus on providing components and APIs that make creating responsive and high-performance applications easy. Often, these systems offer built-in support for mobile and desktop features, such as camera access, push notifications, and integration with native operating system features. This type of framework is challenging to develop due to the number of environments you have to support. Though, as we have seen examples in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> and <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, with React Native and Electron, these kinds of projects are not impossible.</li>
<li><strong class="bold">Embedded solutions</strong>: This type of framework would focus on providing a simple and easy-to-use interface for programming and interacting with hardware devices. To create one of these, you must develop APIs for standard sensors and devices. These include working with external chipsets, motors, GPS, and Bluetooth accessories. The main focus behind this framework would be to create a unique approach to reduce memory and processor usage, as you are targeting embedded instruments. This is a more complex challenge with JavaScript, even though there have been many projects in the past that allowed the runtime to interact with embedded devices.</li>
</ul>
<p>We explored several examples of more popular JavaScript frameworks in the previous chapters. However, JavaScript’s versatility extends beyond those we’ve already discussed. The<a id="_idIndexMarker402"/> language can enable you to build new framework projects that cater to other niches. JavaScript has become ubiquitous in modern web development, allowing developers to build robust and feature-rich applications.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor082"/>Other framework pathways</h2>
<p>There are many other<a id="_idIndexMarker403"/> types of projects that JavaScript allows us to build; they all have their own considerations. In no particular order, let’s take a look at more framework development pathways:</p>
<ul>
<li><strong class="bold">Game development</strong>: As JavaScript is the only target runtime available to the web browser, it ends up being the only solution for building games. Your JavaScript game development framework can provide tools and utilities that make it easy to build 2D or 3D games for web and mobile platforms. These utilities could include built-in support for physics engines, animation, and audio. In such a scenario, the framework could concentrate on providing advanced features, such as multiplayer support or virtual reality integration, as those features become more popular. Some popular JavaScript game development frameworks include Phaser, Pixi.js, PlayCanvas, and Babylon.js. Even though game development frameworks have specific requirements related to rendering and performance, you can still use knowledge from this book to structure this type of framework.</li>
<li><strong class="bold">Computation</strong>: A new framework for computation and data science could potentially perform scientific computing and data analysis tasks. You could focus on providing a set of APIs for performing mathematical operations and working with data. This framework could have built-in support for popular data visualization libraries and statistical analysis tools. The potential for JavaScript computation frameworks is in the frontend presentation and backend computation layers. A single framework can combine both of those possibilities.</li>
<li><strong class="bold">Visualization</strong>: Similar <a id="_idIndexMarker404"/>to the computation theme, there is room for better JavaScript data visualization frameworks. In visualization projects, you could focus on providing a set of tools and components for creating interactive and dynamic visualizations. You could also integrate with visualization libraries such as D3.js and explore advanced features such as real-time data streaming. As this niche is developing, you can find new ways to render and interact with information from many data sources.</li>
<li><strong class="bold">Artificial intelligence</strong>: If you decide to develop a JavaScript framework for AI and <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>), you<a id="_idIndexMarker405"/> should prioritize providing a comprehensive set of APIs for building and training neural networks. Consider basing your framework on widely used ML APIs and libraries, such as <a id="_idIndexMarker406"/>TensorFlow.js (<a href="https://tensorflow.org/js">tensorflow.org/js</a>). The features of such a framework could include interoperability with various types of ML formats and configurations.</li>
<li><strong class="bold">User interface (UI)</strong>: A framework built around constructing UIs could be helpful for a different feature set from regular frontend applications. It could include capabilities for customizable components and responsive UIs. Innovative features could consist of styling and theming components utilizing modern CSS features. The framework could integrate with external libraries such as Tailwind CSS, Material UI, Bootstrap, and so on. Building a UI framework can be advantageous if you work in marketing or design-related environments.</li>
</ul>
<p>Depending on your framework goal, these are some potential framework pathways. In previous chapters of the book, we have covered the ins and outs of some classes of these frameworks in detail. This is not an exhaustive list of possible solutions within a JavaScript environment, but<a id="_idIndexMarker407"/> it showcases the many possibilities. The most popular and competitive category of frameworks is related to building frontend applications.</p>
<p>Now that we have a clearer vision of the problem space, in the next section, we can proceed to considerations with regard to the technical architectures of framework projects.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Technical architecture</h1>
<p>In the previous sections <a id="_idIndexMarker408"/>of this chapter, we identified our stakeholders—those who will directly benefit from our framework project. We also identified potential problem spaces. Those two factors give us a solid idea of what we want to build. In this section, we explore the third pillar from <em class="italic">Figure 5</em><em class="italic">.1</em>—<em class="italic">technical architecture</em>—to give us a focused look at the technical specificities of our planned project.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Abstraction levels and flexibility</h2>
<p>The importance of <a id="_idIndexMarker409"/>practical abstraction levels and allowing flexibility in code APIs of a JavaScript framework is an important design decision. As you develop your frameworks, these two principles are necessary to ensure the framework’s usability, maintainability, and adaptability.</p>
<p>As explored in <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, sensible abstraction levels are essential for providing developers with clean, easy-to-understand interfaces. The encapsulated complexities of the underlying implementation improve productivity and minimize the risk of errors as developers work with a higher-level, more intuitive API that shields them from unnecessary complexity.</p>
<p>The sensible abstraction levels promote modularity and reusability of code, as the framework’s features can be more easily connected and adapted to varying circumstances. Providing a level of modularity enables developers to build upon existing modules, fostering a developer-driven ecosystem of extensions that further enhance the framework’s capabilities. By striking the right balance between abstraction and flexibility, a JavaScript framework can cater to various projects, from small-scale to complex applications.</p>
<p>Allowing flexibility in code APIs is another critical aspect of a successful JavaScript framework. A flexible API accommodates different coding styles, paradigms, and use cases, enabling developers to tailor their approach to suit their unique requirements. This adaptability is essential in the fast-paced world of web development, where new tools, libraries, and patterns are constantly emerging. By offering a versatile API, a JavaScript framework can remain relevant and valuable in the face of these evolving trends.</p>
<p>One potential pitfall of abstraction is the creation of highly opinionated abstractions that impose strict constraints on how developers can use the framework. While abstractions can streamline specific use cases, they may hinder the framework’s overall flexibility and limit its applicability to a broader range of projects. If you would like to build a less opinionated framework, consider providing your stakeholders with expandable options, such as using different templating engines or various ways of managing state within built applications.</p>
<p>Striking the right <a id="_idIndexMarker410"/>balance between abstraction and flexibility, and avoiding overly opinionated abstractions, will help you craft a versatile and enduring JavaScript framework.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Environment compatibility</h2>
<p>JavaScript runs in<a id="_idIndexMarker411"/> diverse environments, including browsers, servers, mobile devices, and other unique hardware, each with unique characteristics, making compatibility a pressing factor in any framework’s success. Determining the runtime environment compatibility of your framework is about figuring out which runtimes to support and maintain. Generally, in JavaScript frameworks, it is about the time and technological investment choice of frontend and backend features. This includes browser-specific APIs and compatibility with different backend systems. Besides frontend and backend systems, JavaScript is supported in many other environments.</p>
<p>Framework developers face a significant challenge in ensuring compatibility with multiple JavaScript environments and the specific quirks of those environments. At a high level, this includes different types of browser engines and compatibility with different module systems. This task requires careful consideration and design decisions to ensure the framework works seamlessly across all targeted runtimes.</p>
<p>The first design decision is about configuring compatibility for the appropriate JavaScript environment. Developers must consider the target environment for the framework and ensure that it is compatible with the chosen setting. For instance, if the framework is designed for web applications, the developers must ensure it works seamlessly across multiple browser versions and APIs. Incompatibilities may arise due to variations in browser capabilities, leading to problems such as inconsistent rendering or unresponsive applications.</p>
<p>Another significant <a id="_idIndexMarker412"/>consideration when developing a new JavaScript framework is handling environment differences. Writing extra code-compatibility layers is valuable for minor and significant runtime differences. Handling runtime differences includes investing time in backward compatibility for both older browsers and older versions of server-side runtimes. In general, supporting multiple frontend JavaScript environments takes different versions of the same browser environment. For example, many browsers, such as Firefox, have various versions, and each version may have unique capabilities or features. Developers must ensure the framework is designed to handle these variations and provides optimal performance and functionality regardless of the browser version.</p>
<p>For instance, you must handle cross-runtime compatibility to enable server-side rendering or Node.js testing of frontend components. JavaScript server environments may require specific deliberations when building frameworks. They may have different APIs than browsers, and some features, such as the DOM, may not be available. Thus, developers must ensure that the framework is designed to handle such variations and provides optimal performance in server environments. Framework developers include JavaScript polyfills and similar code snippets, providing a fallback mechanism for new and missing features in other environments. These are essential when building a new framework that should work across multiple domains.</p>
<p>Ensuring compatibility with multiple JavaScript environments requires additional thorough testing during framework development and maintenance. Testing is essential in identifying and resolving compatibility issues early in the development cycle. For instance, we can use the automated testing tooling we saw in the previous chapter to test the framework on various browser versions and mobile devices to identify compatibility issues. Including these tests helps to ensure that the framework delivers optimal performance and functionality across all targeted environments. However, testing through all possible runtime use cases and quirks can be challenging, and running a test on all configurations your framework will be used in is impossible. Fortunately, compatibility issues significantly reduced as JavaScript runtimes matured. If you are developing a framework outside the browser, something similar to Electron or React Native, you have further challenges. You must ensure the framework is compatible with the multiple operating systems that you are designing your project for. For example, the operating system runtimes may have different capabilities, affecting the framework’s feature set.</p>
<p>Overall, you are able to define the supported JavaScript environments and take control of the types of runtimes you support in your framework, knowing that compatibility with multiple JavaScript <a id="_idIndexMarker413"/>environments requires continuous maintenance and updates to your project. This maintenance includes compatibility with new browser versions or server environments that tweak their capabilities or add new features.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Utilizing libraries</h2>
<p>It makes sense to<a id="_idIndexMarker414"/> commit to specific JavaScript libraries before developing a new framework. The use of existing JavaScript libraries will save you time—time you can use to focus on the framework’s features and technical architecture. It is a common pattern for frameworks to rely on libraries to build out the internals. These libraries often indirectly enable the framework feature set behind the scenes, including features such as data management, routing, interacting with the DOM, and abstracting away JavaScript runtime complexity. As the framework covers a more extensive feature set and shapes the development experience, the internal libraries focus on delivering a precise solution to a particular problem.</p>
<p>Choosing the right set of libraries can significantly impact the development process and the shape of your framework. The libraries you utilize in your framework will likely make you an expert user of them. However, balancing the benefits of using libraries with potential downsides, such as compatibility problems, API restrictions, and ongoing maintenance, is necessary.</p>
<p>As we explore other JavaScript frameworks, we can identify libraries they rely on for specific functionality. Depending on the architecture, your framework can build the library right into the framework or use it to extend aspects of your framework. If we look at Angular, we will find that it<a id="_idIndexMarker415"/> utilizes <code>BookService</code> service:</p>
<pre class="source-code">
import { HttpClient } from '@angular/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { map, retry } from 'rxjs/operators';
@Injectable()
export class BookService {
  private baseUrl = '...';
  constructor(private http: HttpClient) {}
  getWeather(latitude: number, longitude: number):
    Observable&lt;any&gt; {
    const url = `${this.baseUrl}?latitude=${latitude}
      &amp;longitude=${longitude}&amp;current_weather=true`;
    return this.httpClient.get(url).pipe(retry(3));
  }}</pre>
<p>The preceding code uses the <code>Observable</code> class to return the <code>getWeather</code> function first. From within your Angular classes, you can rely upon RxJS to provide many data-operating operators. In addition, the RxJS library provides error-handling operators, as seen in the <code>retry</code> call in the preceding code. A detailed explanation of the library’s operators can be found at <a href="https://rxjs.dev/guide/operators">rxjs.dev/guide/operators</a>.</p>
<p class="callout-heading">Exploring the RxJS example</p>
<p class="callout">The <code>chapter5</code> directory in <a id="_idIndexMarker417"/>the book repository includes an example of using Angular with the RxJS library. You can try this out on your own computer by running the interactive script from the chapter directory or executing <code>npm install</code>, and then <code>npm run dev</code> from the <code>angular-rxjs</code> directory.</p>
<p class="callout">The example application will utilize the <code>BookService</code> service presented previously to fetch data. The API data comes with additional properties that you can use to extend the existing application. Refer to the <code>README.md</code> files for additional information.</p>
<p>In another example of library usage, Vue.js initially <a id="_idIndexMarker418"/>used <strong class="bold">Vuex</strong> as a library for centralized state management. However, as the framework developed, the approach to managing the state changed. Vue has switched over to recommending and utilizing <strong class="bold">Pinia</strong> (<a href="https://pinia.vuejs.org">pinia.vuejs.org</a>) for<a id="_idIndexMarker419"/> state management. With an intuitive approach based on the Flux architecture, the library closely related to Vue, it allows developers to use multiple stores to manage states, enables extensibility, and is much more closely aligned with the framework’s <a id="_idIndexMarker420"/>features. Another example that we have seen in <a href="B19014_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a> is Next.js, which uses the React library for rendering and other features. Next.js focuses on using primitives provided by React to abstract away complexities when using the library directly.</p>
<p>As you introduce libraries into your framework, be smart about choosing them. Often, it is more effortless to abstract away direct access to the libraries for the users of your framework. Otherwise, you must support particular library APIs in your framework, locking you into a specific coding pattern. Historically, Ember.js had to spin up an effort to decouple the framework from its usage of the jQuery library. This type of migration meant providing an update path for projects trying to keep up with the latest versions of the framework.</p>
<p>As your framework develops, you will find great benefits in the ecosystem of JavaScript libraries. The <a id="_idIndexMarker421"/>challenge will be keeping up with the developing nature of these projects as the target runtime evolves.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Compiler tooling</h2>
<p>In <em class="italic">Chapters 3</em> and <em class="italic">4</em>, we<a id="_idIndexMarker422"/> examined instances of framework development patterns. These patterns included the use of compilers and other build tools for the purposes of framework development and structure. There’s no question that the tools utilized in these patterns make the development, refactoring, and maintenance workflow much more manageable. Therefore, unless there is a specific reason for your framework to avoid the benefits of these tools, it is firmly advisable to lean into the ecosystem.</p>
<h3>Build tooling and compilers</h3>
<p>While writing the code<a id="_idIndexMarker423"/> of your framework project, you want to have a good feedback loop from the code changes you make. This feedback loop can come from running the project’s tests or having a sample application that utilizes your framework as you work on new features or bug fixes. This kind of iteration workflow can be configured with built-in JavaScript behaviors, or you could rely on a number of existing build tools and compilers. For the development process, the choice of compiler tooling can significantly impact and affect the efficiency of the development of your framework. Looking back at framework showcases, we have seen examples of using tools such as Rollup.js, <code>webpack</code>, and <code>esbuild</code> for web framework development and packaging.</p>
<p>The choice of these tools will depend on the precise requirements of your framework. While meticulously choosing to use these tools, you need to make sure to evaluate their benefits and drawbacks. In addition, the tools you choose should be suitable for both the development workflow and a good framework publishing workflow. You could decide to separate those two workflows, but then you could end up with too many tools that you need to maintain. For example, we can take some of these tools and consider the following factors:</p>
<ul>
<li>The overall JavaScript runtime and feature support, such as features that include extensive JavaScript module format support and advanced features such as tree-shaking and intelligent code bundling</li>
<li>For frontend systems, evaluate browser and web API support</li>
<li>The complexity and flexibility of configuration when targeting different workflows and environments, potentially choosing zero-configuration tools versus comprehensive configuration</li>
<li>Build-time speed for both development and production builds of the framework</li>
<li>Maturity of the tool compared to other similar solutions</li>
<li>Developer feature <a id="_idIndexMarker424"/>set, such as <strong class="bold">Hot Module Replacement </strong>(<strong class="bold">HMR</strong>), development server, and instant live reload</li>
<li>Integration with external tools, such as test frameworks</li>
</ul>
<p>Some of these factors <a id="_idIndexMarker425"/>can differ depending on your framework’s problem space—for example, frontend versus backend domains.</p>
<p class="callout-heading">Trying out esbuild</p>
<p class="callout">The <code>chapter5/esbuild</code> directory in the book's repository includes a sample project that uses <code>esbuild</code> to bundle frontend files. You can refer to the <code>build.js</code> file for the <code>esbuild</code> compiler configuration. When you run this project locally on your machine, the tool will take the assets from the <code>src</code> directory and output the resulting files into the <code>dist</code> directory; these are later loaded into the <code>index.html</code> file in the root of the project. The build steps are executed using the <code>npm run dev</code> command from the project directory.</p>
<p>With enough time investment, you can develop your own compiler or bundler. We have seen prior examples of custom framework compiler development with projects such as Svelte. Creating your own tooling is a larger undertaking, but this is something that could set your framework apart and has immense potential.</p>
<h3>JavaScript extensions</h3>
<p>TypeScript and<a id="_idIndexMarker426"/> similar tools that <a id="_idIndexMarker427"/>extend the JavaScript functionality get a special mention in the design decision section. These JavaScript language extensions have been at the core of framework development in recent years. Even if the popularity of using TypeScript in the framework development workflow might decrease over time, it will likely be replaced by other similar tooling that encompasses benefits not available directly with JavaScript. With TypeScript in particular, framework developers get a productivity boost from extra features such as static typing, interfaces, decorators, namespaces, and much more. All these are highly beneficial for framework development.</p>
<p>Suppose you are unsure about introducing an additional TypeScript workflow into your framework or have a specific JavaScript environment that conflicts with TypeScript’s tooling. In that case, you could consider a design decision to opt in for the JSDoc annotation version of TypeScript types. A range of supported types for JavaScript files with TypeScript annotations can be found at <a href="https://typescriptlang.org/docs/handbook/jsdoc-supported-types.html">typescriptlang.org/docs/handbook/jsdoc-supported-types.html</a>. If you don’t mind the additional transpiling step and entirely opt into TypeScript’s ecosystem, then it can help you with many development hurdles, such as the following:</p>
<ul>
<li>Reducing the number of code issues identified at runtime</li>
<li><strong class="bold">Enabling faster refactoring of your code</strong>: The ability to do this is much more critical in frameworks, as frameworks have much more dynamic code bases than routine web application projects</li>
<li><strong class="bold">Improved class-based programming concepts</strong>: You can use additional building blocks such as interfaces, inheritance features, and more to have a well-designed code base</li>
<li><strong class="bold">Having a much more descriptive and documented code base</strong>: This proactively benefits you and other teammates working on the project with you</li>
<li><strong class="bold">It allows you to utilize new syntax features faster</strong>: TypeScript constantly adds new valuable features and is not bound by slow browser adoption of new syntax features</li>
</ul>
<p>All these benefits are highly useful, and ultimately it is a good design decision to use TypeScript or <a id="_idIndexMarker428"/>TypeScript-like<a id="_idIndexMarker429"/> solutions to enhance the quality of your coding experience.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Summary</h1>
<p>This chapter’s core ideas looked at several critical factors and considerations that we need to research and keep in mind as we start our new project. First is identifying the framework’s stakeholders and goals, these being the objectives and the audience that will benefit from having these objectives fulfilled. Then, we examined potential problem spaces, focusing on understanding the project types we can consider. Finally, we explored examples of specific JavaScript architectural design decisions that could shape our project.</p>
<p>Considering all this information will help you create a better framework project. Meanwhile, we will also use these framework considerations together throughout this book. We will start applying all these considerations in the next chapter, as we start building a new framework from scratch.</p>
</div>
</body></html>