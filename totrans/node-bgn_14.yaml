- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Error Handling in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js applications require solid and consistent control over errors. Most
    applications are built using many dependencies or heavily rely on asynchronous
    operations (network, disk, and so on), which makes error management more complex.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the different types of errors that we can
    encounter in a Node.js application and how to handle them properly. We will also
    learn how to throw custom errors and how to capture and resume the application
    from any kind of error, including the ones that occur in Express applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will also learn how to manage a graceful shutdown when the service crashes,
    how to use exit codes according to the situation, and how to prevent zombie processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum up, here are the main topics that we will explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to throw custom errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to capture and recover from any kind of error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage application and user errors in Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to manage a graceful shutdown when the service crashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to prevent zombie processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use exit codes to indicate the reason why the application was shut down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code in action video for this chapter on [https://youtu.be/VPXV1L1epIk](https://youtu.be/VPXV1L1epIk)
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the types of errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we learned in the first chapter, Node.js is a single-threaded application.
    This means that if an error occurs and we don’t properly handle it, the application
    will crash. This is why it is important to handle errors properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main types of errors in Node.js: **syntax** errors and **runtime**
    errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Syntax errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Syntax errors are thrown when the code is parsed and it is not valid. These
    errors are thrown by the JavaScript engine, and they are usually easy to fix.
    Many IDEs and code editors can detect these errors and highlight them in the code
    editor, so you can fix them before running the application. In our case, we have
    been using StandardJS as a linter (which is a tool that helps us detect syntax
    errors and enforce a consistent code style) in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a syntax error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code will throw a `ReferenceError` error because the `executeThisFunction`
    function is not defined. This error can be easily fixed by defining the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Runtime errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Runtime errors are also known as **operational** errors. These errors are thrown
    when the application is running and are not related to the syntax of the code.
    These errors can be thrown by the application itself or by the dependencies that
    the application is using.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to generate runtime errors, such as by accessing a property
    of an undefined object, calling a function that does not exist, trying to read
    a file that does not exist, trying to connect to a database that is not available,
    and trying to access a network resource that is not available.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many ways to generate runtime errors. This is why
    it is important to handle them properly. If we don’t handle them, the application
    will crash and it will stop working. So, while coding the application, it is very
    important to keep in mind the possible runtime errors that can be thrown and how
    to handle them.
  prefs: []
  type: TYPE_NORMAL
- en: Some errors can be recovered and others not, depending on the type of error.
    For example, if we have a REST API application and the database is not available,
    we could recover from this error by returning a `503` HTTP status code and a message
    to the client. You will be always in charge of deciding whether the error can
    be recovered or not and how to handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the types of errors that can be thrown in Node.js applications,
    let’s see how to throw meaningful errors in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing meaningful errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When an error occurs, it is important that it is meaningful. This means that
    the error should contain enough information to understand what happened and, potentially,
    how to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: The error object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The error object is an instance of the `Error` class. This class has a constructor
    that accepts a message as a parameter. This message will be used to describe the
    error. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the error message is displayed in the output. This is the message
    that we passed to the constructor of the `Error` class. If you compare it with
    `ReferenceError: executeThisFunction is not defined`, we can see that the error
    message is not very descriptive and that we are using a generic error class.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create your own custom errors by extending the `Error` class. This
    is useful when you want to create your own `Error` classes and add more information
    to the error object. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run the previous code, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the error message `Looks like you need more sleep` is displayed
    in the output, as well as the class name, `NotEnoughSleep`. Additionally, we have
    added two properties to the error object: `requireSleep` and `isRecoverable`.
    These properties are created by us, and we can create as many as we need and be
    as specific as we want. These properties can be used to add more information to
    the error object, so we can handle the error properly using these properties in
    a `try`/`catch` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have used the `isRecoverable` and `requireSleep` properties
    to handle the error. This is a very simple example, but you can add more properties
    to the error object to handle the error properly.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to capture and recover from any
    kind of error while using Express.
  prefs: []
  type: TYPE_NORMAL
- en: Managing errors in Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to create a REST API application using
    Express and we saw how to handle errors in Express applications, but in this section,
    we are going to refresh the concepts and extend them.
  prefs: []
  type: TYPE_NORMAL
- en: Error-handling middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Express has a built-in error-handling middleware that can be used to handle
    errors in a centralized way. This middleware is executed when an error occurs
    in the application. This middleware is executed after all the other middleware
    and routes have been executed. It is executed only when an error occurs, so it
    is important to add it at the end of the middleware chain, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Custom errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are building a REST API application, you could add a property to the
    error object to indicate the HTTP status code that should be returned to the client.
    This way, you can handle the error properly in the error-handling middleware and
    return the proper HTTP status code to the client. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can use the `statusCode` property to return the proper HTTP
    status code to the client. This is a very simple example but you can add more
    properties to the error object to handle the error properly.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to handle errors, it is time to learn how to gracefully
    shut down the application when the application cannot recover from an error.
  prefs: []
  type: TYPE_NORMAL
- en: Gracefully shutting down the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout the book, we have learned how to handle errors using `try`/`catch`
    blocks, error-first callbacks, `catch` for promises, and also events to handle
    errors but, sometimes, we need to handle errors globally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js provides a way to handle errors globally and gracefully shut down the
    application when an error occurs: using `process.on()`. You can also use `process.exit()`
    to exit the application with a specific exit code. This is useful in CI/CD pipelines,
    to indicate whether or not the application was shut down because of an error,
    and also in productive environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many events that can be used to handle errors globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uncaughtException`: This event is emitted when an uncaught exception occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unhandledRejection`: This event is emitted when an unhandled rejection occurs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exit`: This event is emitted when the Node.js process is about to exit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT` and `SIGTERM`: These events are emitted when the Node.js process receives
    these signals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many other events can be used to handle errors globally but these are the most
    common ones. In the following example, we combine some scenarios to handle errors
    globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you run the previous code, you will see that the application will be shut
    down after 20 seconds because of the unhandled rejection, but the uncaught exception
    was eventually caught and the process continues running. Also, if you press *Ctrl*
    + *C* at any time, the application will be shut down because of the `SIGINT` signal.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we can see that the `exit` event is always triggered
    when we are closing the Node.js application. So, it is quite common to use this
    event to perform some actions before the application is shut down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Take into account that the `exit` event is not only triggered when an error
    occurs but also when the application is closed gracefully and does not support
    asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to use exit codes to indicate the reason
    why the application was shut down. This is very useful in CI/CD pipelines to indicate
    whether the application was shut down because of an error or not.
  prefs: []
  type: TYPE_NORMAL
- en: Exit codes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Exit codes are used to indicate the reason that the application was shut down,
    as well as whether or not the application was shut down because of an error and
    whether the application was shut down gracefully or not.
  prefs: []
  type: TYPE_NORMAL
- en: If the exit code is `0`, it means that the application was shut down gracefully.
    If the exit code is different from `0`, it means that the application was shut
    down because of an error. By default, when there is nothing to do in the application,
    Node.js will exit with the exit code of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: By using `process.exit()`, we can indicate the exit code that we want to use.
    For example, if we want to indicate that the application was shut down because
    of an error, we can use `process.exit(1)`. If we want to indicate that the application
    was shut down gracefully, we can use `process.exit(0)`.
  prefs: []
  type: TYPE_NORMAL
- en: Some processes might finish correctly in terms of execution but use an error
    code. For example, when we run and complete application tests, if any test fails,
    the exit code will be different from `0`. That way, the execution output will
    be an error that can prevent CI from continuing to execute the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to prevent zombie processes while using
    the process library to handle errors globally.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding zombie processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I love zombie movies but I don’t like zombie processes. A zombie process is
    a process that is running in the background and is not doing anything. These kinds
    of processes eat resources from the host machine, and they can be a huge problem
    in certain scenarios such as low-capability devices.
  prefs: []
  type: TYPE_NORMAL
- en: Using `process.on()` can be dangerous because it can prevent the Node.js process
    from exiting. This is why it is important to use `process.exit()` to exit the
    application with a specific exit code when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. If we don’t use `process.exit()`, the application will
    not exit and it will be running forever, even if an error occurs while executing
    a function that is not defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This is shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can prevent that by adding `process.exit()` to exit the application with
    a specific exit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the application was shut down because we used `process.exit()`
    to exit the application with a specific exit code. If we don’t use `process.exit()`,
    the application will be running forever, making it a zombie process.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the types of errors that can be thrown in
    Node.js applications. We saw how to throw custom errors and how to capture and
    recover from any kind of error.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we reviewed how to manage application and user errors in Express.
    We also learned how to manage a graceful shutdown when the service crashed.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to prevent zombie processes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn more about security, including how
    to protect our application by applying the best practices available and how to
    evaluate CVEs and security vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Express* | *Health Checks and Graceful* *Shutdown*: [https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html](https://expressjs.com/en/advanced/healthcheck-graceful-shutdown.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Express* | *Error* *Handling*: [https://expressjs.com/en/guide/error-handling.html](https://expressjs.com/en/guide/error-handling.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node.js docs | *Error* *API*: [https://nodejs.org/dist/latest-v20.x/docs/api/errors.html](https://nodejs.org/dist/latest-v20.x/docs/api/errors.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Bash command line exit codes* *demystified*: [https://www.redhat.com/sysadmin/exit-codes-demystified](https://www.redhat.com/sysadmin/exit-codes-demystified)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
