<html><head></head><body>
  <div><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Layouts – d3's Black Magic</h1></div></div></div><p>Most of us look at the Internet for inspiration and code samples. You find something that looks great, look at the code, and your eyes glaze over. It doesn't make any sense.</p><p>The usual culprit is d3's reliance on layouts for anything remotely complicated. The black magic of taking some data, calling a function, and voilà—visualization! This elegance makes layouts look deceptively difficult, but they make things a lot easier when you get a hang of them.</p><p>In this chapter, we'll go in, guns blazing, with everything we've learned so far to create 11 visualizations of the same dataset.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>What are layouts and why should you care</h1></div></div></div><p>d3 layouts<a id="id287" class="indexterm"/> are modules that transform data into drawing rules. The simplest layout might only transform an array of objects into coordinates, like a scale.</p><p>But we usually use layouts for more complex visualizations—drawing a force-directed graph or a tree, for instance. In these cases, layouts help us to separate calculating coordinates from putting pixels on a page. This not only makes our code cleaner, but it also lets us reuse the same layouts for vastly different visualizations.</p><p>Theory is boring, let's dig in.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Built-in layouts</h2></div></div></div><p>By default, d3 <a id="id288" class="indexterm"/>comes with 12 built-in layouts that cover most common visualizations. They can be split roughly into normal and hierarchical layouts. The normal layouts are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">histogram</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">pie</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">stack</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">chord</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">force</code></li></ul></div><p>The hierarchical layouts<a id="id289" class="indexterm"/> are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">partition</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">tree</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">cluster</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">pack</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">treemap</code></li></ul></div><p>To see how they behave, we're going to make an example for each type. We'll start with the humble pie chart and histogram, then progress to force-directed graphs and fancy trees. We're using the same dataset for all examples, so that we can get a feel of how different presentations affect the perception of data.</p><p>These are the last examples in this book, so we're going to make them particularly magnificent. That's going to create a lot of code, so every time we come up with something reusable, we'll put it in a<a id="id290" class="indexterm"/> <code class="literal">helpers.js</code> file as a function.</p><p>Let's create an empty <code class="literal">helper.js</code> file:</p><div><pre class="programlisting">window.helpers = {
};</pre></div><p>We're going to add functions as members of this global object. Add the following line to the HTML right before including the normal code.</p><div><pre class="programlisting">&lt;script src="img/helpers.js"&gt;&lt;/script&gt;</pre></div><p>Let's also agree that all examples start with a drawing area and fetching the data.</p><div><pre class="programlisting">var width = 1024,
    height = 1024,
    svg = d3.select('#graph')
        .append('svg')
        .attr({width: width,
               height: height});

d3.json('data/karma_matrix.json', function (data) {
});</pre></div><p>Example code will go in the<code class="literal"> d3.json</code> load listener.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec14"/>The dataset</h3></div></div></div><p>The <a id="id291" class="indexterm"/>dataset we'll be playing with has been scraped from my favorite IRC channel's log going back to late 2011. The channel's special feature is the karma bot.</p><p>When someone does something we like, we give them karma with <code class="literal">nick++</code> and the bot counts it as a vote for that person. Just like on Reddit, karma is supposed to measure how much the community likes someone, but it's really just about who is most active.</p><p>The karma is what we're interested in.</p><p>You can get the dataset at <a class="ulink" href="https://raw.github.com/Swizec/d3.js-book-examples/master/ch5/data/karma_matrix.json">https://raw.github.com/Swizec/d3.js-book-examples/master/ch5/data/karma_matrix.json</a>. The dataset consists of objects representing instances of giving karma. Each looks like the following code:</p><div><pre class="programlisting">{"to": "smotko",
 "from": "Swizec",
 "time": "2012-02-28 23:44:40"}</pre></div><p>Every object tells <a id="id292" class="indexterm"/>us at what time (<code class="literal">time</code>) somebody (<code class="literal">from</code>) gave karma to (<code class="literal">to</code>) somebody else. To deal with the cruft often tacked onto nicknames—for instance, <code class="literal">smotko</code> is <code class="literal">smotko-nexus</code> from his phone—only the first four letters of the nickname were considered when scraping the dataset.</p><p>This creates a clean dataset for us to work with. You can think of it as a list of edges in a graph, where users are nodes and <code class="literal">to</code> and <code class="literal">from</code> create a directed edge.</p><p>Time to draw!</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec15"/>Using the histogram layout</h3></div></div></div><p>We are going to use<a id="id293" class="indexterm"/> the <code class="literal">histogram</code> layout to create a bar chart of the karma people have received. The layout itself will handle everything from collecting values into bins, to calculating heights, widths, and the positions of the bars.</p><p>Histograms usually represent a probability distribution over a continuous numerical domain, but nicknames are ordinal. To bend the <code class="literal">histogram</code> layout to our will, we have to turn nicknames into numbers—we'll use a scale.</p><p>Since it feels like this could be useful in other examples, we'll put the code in <code class="literal">helpers.js</code>:</p><div><pre class="programlisting">uniques: function (data, nick) {
        var uniques = [];
        
        data.forEach(function (d) {
            if (uniques.indexOf(nick(d)) &lt; 0) {
                uniques.push(nick(d));
            }
        });

        return uniques;
    },

    nick_id: function (data, nick) {
        var uniques = helpers.uniques(data, nick);

        return d3.scale.ordinal()
            .domain(uniques)
            .range(d3.range(uniques.length));
    },</pre></div><p>These are<a id="id294" class="indexterm"/> two simple functions. <code class="literal">uniques</code> goes through the data and returns a list of unique nicknames. We help it with the <code class="literal">nick</code> accessor. <code class="literal">nick_id</code> creates an ordinal scale we'll be using to convert nicknames into numbers.</p><p>Now we can tell the histogram how to handle our data with <code class="literal">nick_id</code>.</p><div><pre class="programlisting">var nick_id = helpers.nick_id(data, function (d) { return d.to; });

var histogram = d3.layout.histogram()
            .bins(nick_id.range())
            .value(function (d) { return nick_id(d.to); })(data);</pre></div><p>Using <code class="literal">d3.layout.histogram()</code> we create a new histogram and use <code class="literal">.bins()</code> to define the upper threshold for each bin. Given <code class="literal">[1,2,3]</code>, values under <code class="literal">1</code> go in the first bin, values between <code class="literal">1</code> and <code class="literal">2</code> in the second, and so on.</p><p>The <code class="literal">.value()</code> accessor tells the histogram how to find values in our dataset.</p><p>Another way to specify bins is by specifying the number of bins you want and letting the histogram uniformly divide a continuous numerical input domain into bins. For such domains, you can even make probability histograms by setting <code class="literal">.frequency()</code> to <code class="literal">false</code>. You can limit the range of considered bins with <code class="literal">.range()</code>.</p><p>Finally, we used the layout as a function on our data to get an array of objects like this:</p><div><pre class="programlisting">{0: {from: "HairyFotr",
         time: "2011-10-11 18:38:17",
         to: "notepad"},
     1: {from: "HairyFotr",
        time: "2012-01-09 10:41:53",
        to: "notepad"},
     dx: 1,
     x: 0,
     y: 2}</pre></div><p>Bin width is in the <code class="literal">dx</code> property, <code class="literal">x</code> is the horizontal position and <code class="literal">y</code> is the height. We access elements in bins with normal array functions.</p><p>Using this data to draw a bar chart should be easy by now. We'll define a scale for each dimension, label both axes, and place some rectangles for bars.</p><p>To make things easier, we begin with some margins. Remember, all this code goes in the data load listener we defined earlier:</p><div><pre class="programlisting">var margins = {top: 10,
               right: 40,
               bottom: 100,
               left: 50};</pre></div><p>And two scales.</p><div><pre class="programlisting">var x = d3.scale.linear()
            .domain([0, d3.max(histogram, function (d) { return d.x; })])
            .range([margins.left, width-margins.right]),
        y = d3.scale.log()
            .domain([1, d3.max(histogram, function (d) { return d.y; })])
            .range([height-margins.bottom, margins.top]);</pre></div><p>Using a log <a id="id295" class="indexterm"/>scale for the vertical axis will make the graph easier to read despite the huge karma variations.</p><p>Next, put a vertical axis on the left:</p><div><pre class="programlisting">var yAxis = d3.svg.axis()
            .scale(y)
            .tickFormat(d3.format('f'))
            .orient('left');

    svg.append('g')
        .classed('axis', true)
        .attr('transform', 'translate(50, 0)')
        .call(yAxis);</pre></div><p>We create a grouping element for every bar and its label:</p><div><pre class="programlisting">var bar = svg.selectAll('.bar')
            .data(histogram)
            .enter()
            .append('g')
            .classed('bar', true)
            .attr('transform',
                  function (d) { return 'translate('+x(d.x)+', '+y(d.y)+')'; });</pre></div><p>Moving the group into position, as shown in the following code, means less work when positioning the bar and its label:</p><div><pre class="programlisting">bar.append('rect')
        .attr({x: 1,
               width: x(histogram[0].dx)-margins.left-1,
               height: function (d) { return height-margins.bottom-y(d.y); }
              });</pre></div><p>Because the group is in place, we can put the bar a pixel from the group's edge. All bars will be <code class="literal">histogram[0].dx</code> wide and we'll calculate heights using the <code class="literal">y</code> position of each datum and the total graph height. Lastly, we create the labels:</p><div><pre class="programlisting">bar.append('text')
        .text(function (d) { return d[0].to; })
        .attr({transform: function (d) {
                   var bar_height = height-margins.bottom-y(d.y);

                   return 'translate(0, '+(bar_height+7)+') rotate(60)'; }
        });</pre></div><p>We move <a id="id296" class="indexterm"/>labels to the bottom of the graph, rotate them by 60 degrees to avoid overlap, and set their text to the <code class="literal">.to</code> property of the datum.</p><p>Add some CSS styling to the HTML:</p><div><pre class="programlisting">&lt;style&gt;
.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.axis text {
  font-size: 0.75em;
}

rect {
  fill: steelblue;
  shape-rendering: crispEdges;
}
&lt;/style&gt;</pre></div><p>Our bar chart looks like this:</p><div><img src="img/0007_05_01.jpg" alt="Using the histogram layout"/></div><p>Well, the whole graph wouldn't fit in the book. Run the example.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec16"/>Delicious pie</h3></div></div></div><p>The previous bar chart reveals that <strong>HairyFotr</strong> has the most karma by far. Let's find out who's making him so popular.</p><p>We are going to use the<a id="id297" class="indexterm"/> pie chart layout to cut the karma of <strong>HairyFotr</strong> into slices, showing how much karma he gets from the others. After filtering the dataset for karma going to <strong>HairyFotr</strong>, we have to categorize entries by givers, and finally feed them into the pie chart layout to generate a pie chart.</p><p>We can use the <code class="literal">histogram</code> layout to put data into bins depending on the <code class="literal">.from</code> property. Let's add a function to <code class="literal">helpers.js</code>:</p><div><pre class="programlisting">    bin_per_nick: function (data, nick) {
        var nick_id = helpers.nick_id(data, nick);
        
        var histogram = d3.layout.histogram()
                .bins(nick_id.range())
                .value(function (d) { return nick_id(nick(d)); });

        histogram(data);
        
        return histogram;
    },</pre></div><p>Similar to the <code class="literal">uniques</code> and <code class="literal">nick_id</code> functions, <code class="literal">bin_per_nick</code> takes the data and a <code class="literal">nick</code> accessor, and returns histogram data.</p><p>We can now do this in pie chart's data listener:</p><div><pre class="programlisting">    filtered = data.filter(
                function (d) { return d.to == 'HairyFotr'; });

    var per_nick = helpers.bin_per_nick(filtered,
                              function (d) { return d.from; });</pre></div><p>Entries in the <code class="literal">per_nick</code> variable will tell us exactly how much karma <strong>HairyFotr</strong> got from someone.</p><p>To bake a pie, we call the <code class="literal">pie</code> layout and give it a value accessor:</p><div><pre class="programlisting">var pie = d3.layout.pie()
            .value(function (d) { return d.length; })(per_nick);</pre></div><p>The <code class="literal">pie</code> layout is now full of slice objects, each holding the <code class="literal">startAngle</code> and <code class="literal">endAngle</code> values and the original value.</p><p>Entries look like this:</p><div><pre class="programlisting">    {data: Array[135],
    endAngle: 2.718685950221936,
    startAngle: 0,
    value: 135}</pre></div><p>We could have<a id="id298" class="indexterm"/> specified a <code class="literal">.sort()</code> function to change how slices are organized and a <code class="literal">.startAngle()</code> or <code class="literal">.endAngle()</code> function to limit the pie's size.</p><p>All that's left to do now is drawing a pie chart. We'll need an <code class="literal">arc</code> generator, just as the ones in <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>, <em>A Primer on DOM, SVG</em>, and CSS and some color to tell slices apart.</p><p>Finding 24 distinct colors that look great together is hard; lucky for us, <code class="literal">@ponywithhiccups</code> jumped to the challenge and made the pick. Thank you!</p><p>Let's add these colors to <code class="literal">helpers.js</code>:</p><div><pre class="programlisting">color:  d3.scale.ordinal()
        .range(['#EF3B39', '#FFCD05', '#69C9CA', '#666699', '#CC3366', '#0099CC',
                '#CCCB31', '#009966', '#C1272D', '#F79420', '#445CA9', '#999999',
                '#402312', '#272361', '#A67C52', '#016735', '#F1AAAF', '#FBF5A2',
                '#A0E6DA', '#C9A8E2', '#F190AC', '#7BD2EA', '#DBD6B6', '#6FE4D0']),</pre></div><p>The<code class="literal"> color</code> scale is an ordinal scale without a domain. To make sure nicknames always get the same color, a function in <code class="literal">helpers.js</code> will help us fixate the domain, as shown in the following code:</p><div><pre class="programlisting">fixate_colors: function (data) {
        helpers.color.domain(helpers.uniques(data,
                                function (d) { return d.from; }));
    }</pre></div><p>Now, we can <a id="id299" class="indexterm"/>define the <code class="literal">arc</code> generator and fixate the colors:</p><div><pre class="programlisting">var arc = d3.svg.arc()
            .outerRadius(150)
            .startAngle(function (d) { return d.startAngle; })
            .endAngle(function (d) { return d.endAngle; });

helpers.fixate_colors(data);</pre></div><p>A group element will hold each arc and its label as shown in the following code:</p><div><pre class="programlisting">var slice = svg.selectAll('.slice')
            .data(pie)
            .enter()
            .append('g')
            .attr('transform', 'translate(300, 300)');</pre></div><p>To make positioning simpler, we move every group to the center of the pie chart. Creating slices works the same as in <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>, <em>A Primer on DOM, SVG, and CSS</em>:</p><div><pre class="programlisting">slice.append('path')
        .attr({d: arc,
                  fill: function (d) { return colors(d.data[0].from); }
              });</pre></div><p>We get the color for a slice with <code class="literal">d.data[0].from</code>—the original dataset is in <code class="literal">.data</code> and all the <code class="literal">.from</code> properties in it are the same. That's what we grouped by.</p><p>Labels take a bit more work. They need to be rotated into place and sometimes flipped so that they don't appear upside-down.</p><p>Labeling an arc will be handy later as well, so let's make a general function in <code class="literal">helpers.js</code>:</p><div><pre class="programlisting">arc_labels: function (text, radius) {
        return function (selection) {
            selection.append('text')
                .text(text)
                .attr('text-anchor', function (d) {
                    return helpers.tickAngle(d) &gt; 100 ? 'end' : 'start';
                })
                .attr('transform', function (d) {
                    var degrees = helpers.tickAngle(d);
                    
                    var turn = 'rotate('+degrees+') translate('+(radius(d)+10)+', 0)';
                    
                    if (degrees &gt; 100) {
                        turn += 'rotate(180)';
                    }
                    
                    return turn;
                });
        }
    },</pre></div><p>We're using <a id="id300" class="indexterm"/>partial application to generate a function operating on a d3 selection. This means we can use it with <code class="literal">.call()</code>, while still defining our own parameters.</p><p>We'll give <code class="literal">arc_labels</code> a <code class="literal">text</code> accessor and a <code class="literal">radius</code> accessor, and it will return a function we can use with <code class="literal">.call()</code> on a selection to make labels appear in just the right places. The meaty part appends a text element, tweaks its <code class="literal">text-anchor</code> element, depending on whether we're going to flip it, and rotates the element into a particular position with the help of a <code class="literal">tickAngle</code> function.</p><p>Let's add the contents of the <code class="literal">tickAngle</code> function:</p><div><pre class="programlisting">tickAngle: function (d) {
        var midAngle = (d.endAngle-d.startAngle)/2,
            degrees = (midAngle+d.startAngle)/Math.PI*180-90;

        return degrees;
    }</pre></div><p>
<code class="literal">helpers.tickAngle</code> calculates the middle angle between <code class="literal">d.startAngle</code> and <code class="literal">d.endAngle</code> and transforms the result from radians to degrees so that SVG can understand it.</p><p>This is basic trigonometry, so I won't go into details, but your favorite high schooler should be able to explain the math.</p><p>We use <code class="literal">arc_labels</code> back in the load listener:</p><div><pre class="programlisting">slice.call(helpers.arc_labels(
                  function (d) { return d.data[0].from; },
                  arc.outerRadius()));</pre></div><p>And our delicious pie is done as shown in the following screenshot:</p><div><img src="img/0007_05_02.jpg" alt="Delicious pie"/></div><p>Clearly, the smallest values could do with some grouping under other, but you can play around with <a id="id301" class="indexterm"/>that on your own.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec17"/>Showing popularity through time with stack</h3></div></div></div><p>D3's official <a id="id302" class="indexterm"/>docs say:</p><div><blockquote class="blockquote"><p>"The stack layout takes a two-dimensional array of data and computes a baseline; the baseline is then propagated to the above layers, so as to produce a stacked graph."</p></blockquote></div><p>Not clear at all, <a id="id303" class="indexterm"/>but I am hard pressed to come up with better. The <code class="literal">stack</code> layout calculates where one layer ends and another begins. An example should help.</p><div><img src="img/0007_05_14.jpg" alt="Showing popularity through time with stack"/></div><p>We're going to make a layered timeline of karma, stretching as far back as 2011, with the width of each layer telling us how much karma went to a user at a certain time. This timeline is called a<a id="id304" class="indexterm"/> <strong>streamgraph</strong>.</p><p>To label layers, we're going to create a <code class="literal">mouseover</code> behavior that highlights a layer and shows a tooltip with the user's nickname. By fiddling until the graph looked pretty, I discovered that we should bin data into 12-day slots.</p><p>Let's begin the binning:</p><div><pre class="programlisting">var time = d3.time.format('%Y-%m-%d %H:%M:%S'),
        extent = d3.extent(data.map(function (d) { return time.parse(d.time); })),
        time_bins = d3.time.days(extent[0], extent[1], 12);</pre></div><p>To parse<a id="id305" class="indexterm"/> timestamps into date objects, we specified a format for strings like <code class="literal">2012-01-25 15:32:15</code>. Then, we used this format to find the earliest and latest time with <code class="literal">d3.extent</code>. Telling <code class="literal">d3.time.days()</code> to go from start to finish with a step of 12 days creates a list of bins.</p><p>We use the <code class="literal">histogram</code> layout to munge our dataset into a more useful form:</p><div><pre class="programlisting">var per_nick = helpers.bin_per_nick(data, function (d) { return d.to; });

    var time_binned  = per_nick.map(function (nick_layer) {
        return {to: nick_layer[0].to,
                     values: d3.layout.histogram()
                                 .bins(time_bins)
                                 .value(function (d) {
                                            return time.parse(d.time); })(nick_layer)};
    });</pre></div><p>You already know what <code class="literal">helpers.bin_per_nick</code> does.</p><p>To bin data into time slots, we mapped through each layer of the <code class="literal">nick</code> accessors and turned it into a two-property object. The <code class="literal">.to</code> property tells us whom the layer represents, and <code class="literal">.values</code> is a histogram of time slots where entries tell us how much karma the user got in a certain 12-day period.</p><p>Time for a <code class="literal">stack</code> layout:</p><div><pre class="programlisting">    var layers = d3.layout.stack()
            .order('inside-out')
            .offset('wiggle')
            .values(function (d) { return d.values; })(time_binned);</pre></div><p>
<code class="literal">d3.layout.stack()</code> creates a new <code class="literal">stack</code> layout. We told it how to order layers with <code class="literal">.order('inside-out')</code> (you should also try <code class="literal">default</code> and <code class="literal">reverse</code>) and decided how the final graph looks with <code class="literal">.offset('wiggle')</code>.<code class="literal"> wiggle</code> minimizes change in slope. Other options include <code class="literal">silhouette</code>, <code class="literal">zero</code>, and <code class="literal">expand</code>. Try them.</p><p>Once again, we told the layout how to find values with the <code class="literal">.values()</code> accessor.</p><p>Our <code class="literal">layers</code> array is now filled with objects like this:</p><div><pre class="programlisting">{to: "notepad",
   values: Array[50]}</pre></div><p>
<code class="literal">values</code> is an array of arrays. Entries in the outer array are time bins that look like this:</p><div><pre class="programlisting">{dx: 1036800000,
   length: 1,
   x: Object(Thu Oct 13 2011 00:00:00 GMT+0200 (CEST)),
   y: 1,
   y0: 140.16810522517937}</pre></div><p>The important parts of this array are as follows:</p><p>
<code class="literal">x</code> is the horizontal position, <code class="literal">y</code> is the thickness, and <code class="literal">y0</code> is the baseline. <code class="literal">d3.layout.stack</code> will always return these.</p><p>To start drawing, we need some margins and two scales:</p><div><pre class="programlisting">var margins = {
        top: 220,
        right: 50,
        bottom: 0,
        left: 50
    };

    var x = d3.time.scale()
            .domain(extent)
            .range([margins.left, width-margins.right]),
        y = d3.scale.linear()
            .domain([0, d3.max(layers, function (layer) {
                return d3.max(layer.values, function (d) {
                    return d.y0+d.y;
                });
            })])
            .range([height-margins.top, 0]);</pre></div><p>The tricky thing <a id="id306" class="indexterm"/>was finding the vertical scale's domain. We found it by going through each value of every layer, looking for the maximum <code class="literal">d.y0+d.y</code> value—baseline plus thickness.</p><p>We'll use an <code class="literal">area</code> path generator for the layers;</p><div><pre class="programlisting">    var offset = 100,
        area = d3.svg.area()
            .x(function(d) { return x(d.x); })
            .y0(function(d) { return y(d.y0)+offset; })
            .y1(function(d) { return y(d.y0 + d.y)+offset; });</pre></div><p>Nothing too fancy, the baselines define bottom edges and adding the thickness gives the top edge. Fiddling determined that both should be pushed down by 100 pixels.</p><p>Let's draw an axis first:</p><div><pre class="programlisting">    var xAxis = d3.svg.axis()
            .scale(x)
            .tickFormat(d3.time.format('%b %Y'))
            .ticks(d3.time.months, 2)
            .orient('bottom');

    svg.append('g')
        .attr('transform', 'translate(0, '+(height-100)+')')
        .classed('axis', true)
        .call(xAxis);</pre></div><p>Same as usual—we defined an axis, called it on a selection, and let d3 do its thing. We only made it prettier with a custom <code class="literal">.tickFormat()</code> function and used <code class="literal">.ticks()</code> to say we want a new tick every two months.</p><p>Ok, now for the <a id="id307" class="indexterm"/>streamgraph, add the following code:</p><div><pre class="programlisting">svg.selectAll('path')
        .data(layers)
        .enter()
        .append('path')
        .attr('d', function (d) { return area(d.values); })
        .style('fill', function (d, i) { return helpers.color(i); })
        .call(helpers.tooltip(function (d) { return d.nick; });</pre></div><p>Not much is going on. We used the <code class="literal">area</code> generator to draw each layer, defined colors with <code class="literal">helpers.color</code>, and called a <code class="literal">tooltip</code> function, which we'll define in <code class="literal">helpers.js</code> later.</p><p>The graph looks like this:</p><div><img src="img/0007_05_03.jpg" alt="Showing popularity through time with stack"/></div><p>It looks pretty, but it is useless. Let's add that <code class="literal">tooltip</code> function to <code class="literal">helpers.js</code>:</p><div><pre class="programlisting">tooltip: function (text) {
        return function (selection) {
            selection.on('mouseover.tooltip', mouseover)
                .on('mousemove.tooltip', mousemove)
                .on('mouseout.tooltip', mouseout);
         }
}</pre></div><p>We defined <a id="id308" class="indexterm"/>event listeners with a <code class="literal">.tooltip</code> namespace so that we can define multiple listeners on the same events.</p><p>The <code class="literal">mouseover</code> function will highlight streams and create tooltips, <code class="literal">mousemove</code> will move tooltips, and <code class="literal">mouseout</code> will put everything back to normal.</p><p>Let's put the three listeners inside the inner function:</p><div><pre class="programlisting">function mouseover(d) {
    var path = d3.select(this);
     path.classed('highlighted', true);
}</pre></div><p>That's the simple part of <code class="literal">mouseover</code>. It selects the current area and changes its class to <code class="literal">highlighted</code>. That will make it lighter and add a red outline.</p><p>In the same function, add the meaty part:</p><div><pre class="programlisting">var mouse = d3.mouse(svg.node());
    var tool = svg.append('g')
            .attr({'id': "nicktool",
                   transform: 'translate('+(mouse[0]+5)+', '+(mouse[1]+10)+')'});
    
    var textNode = tool.append('text')
                       .text(text(d)).node();
               
    tool.append('rect')
        .attr({height: textNode.getBBox().height,
               width: textNode.getBBox().width,
               transform: 'translate(0, -16)'});
                
    tool.select('text')
        .remove();

    tool.append('text')
        .text(d.nick);</pre></div><p>It is longer and with a dash of magic, but not scary at all!</p><p>First we find the mouse's position, then create a group element, and position it down and to the right of the mouse. We add a text element to the group and call SVG's <code class="literal">getBBox()</code> function on its node. This gives us the text element's bounding box and helps us size the background rectangle.</p><p>Finally, we remove <a id="id309" class="indexterm"/>the text because it's covered by the background and add it again. We might be able to avoid all this trouble by using divs, but I wanted to show you pure SVG tooltips. Hence, consider the following code:</p><div><pre class="programlisting">function mousemove () {
    var mouse = d3.mouse(svg.node());
    d3.select('#nicktool')
        .attr('transform', 'translate('+(mouse[0]+15)+', '+(mouse[1]+20)+')');
}</pre></div><p>The <code class="literal">mousemove</code> listener in the following code is much simpler. It just finds the <code class="literal">#nicktool</code> element and moves it to follow the cursor.</p><div><pre class="programlisting">function mouseout () {
    var path = d3.select(this);
    path.classed('highlighted', false);
    
    d3.select('#nicktool').remove();
}</pre></div><p>The <code class="literal">mouseout</code> function selects the current path, removes its <code class="literal">highlighted</code> styling, and removes the tooltip.</p><p>Voila! Tooltips</p><p>Very rudimentary—they don't understand edges and they won't break any hearts with their looks, but they get the job done. Let's add some CSS to the HTML:</p><div><pre class="programlisting">&lt;style&gt;
.axis path, .axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

path.highlighted {
  fill-opacity: 0.5;
  stroke: red;
  stroke-width: 1.5;
}
#nicktool {
  font-size: 1.3em;
}

#nicktool rect {
  fill: white;
}
&lt;/style&gt;</pre></div><p>And now we have a <a id="id310" class="indexterm"/>potentially useful streamgraph on our hands.</p><div><img src="img/0007_05_04.jpg" alt="Showing popularity through time with stack"/></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec18"/>Highlighting friends with chord</h3></div></div></div><p>We've seen how much karma people have and when they got it, but there's another gem hiding in the data—connections. We <a id="id311" class="indexterm"/>can visualize who is a friend of whom using the <code class="literal">chord</code> layout.</p><p>We're going to draw a chord diagram—a circular diagram of connections between users. Chord diagrams are often used in genetics and have even appeared on covers of magazines (<a class="ulink" href="http://circos.ca/intro/published_images/">http://circos.ca/intro/published_images/</a>).</p><p>Ours is going to have an outer ring showing how much karma users give out and chords showing where that karma is going.</p><p>First, we need a matrix of connections for the chord diagram, and then we'll go the familiar route of path generators and adding elements. The matrix code will be useful later, so let's put it in <code class="literal">helpers.js</code>:</p><div><pre class="programlisting">connection_matrix: function (data) {
        var nick_id = helpers.nick_id(data, function (d) { return d.from; }),
            uniques = nick_id.domain();
        
        var matrix = d3.range(uniques.length).map(function () {
            return d3.range(uniques.length).map(function () { return 0; });
        });
        
        data.forEach(function (d) {
            matrix[nick_id(d.from)][nick_id(d.to)] += 1;
        });

        return matrix;
    }</pre></div><p>We begin with the <a id="id312" class="indexterm"/>familiar <code class="literal">uniques</code> list and the <code class="literal">nick_id</code> scale, then create a zero matrix, and loop through the data to increase connection counts in cells. Rows are <em>from whom</em>, columns are <em>to whom</em>—if the fifth cell in the first row holds <code class="literal">10</code>, the first user has given ten karma to the fifth user. This is called an <a id="id313" class="indexterm"/>
<strong>adjacency matrix</strong>.</p><p>Back in the load listener, we can do this:</p><div><pre class="programlisting">    var uniques = helpers.uniques(data, function (d) { return d.from; }),
        matrix = helpers.connection_matrix(data);</pre></div><p>We're going to need <code class="literal">uniques</code> for labels and it would be nice to have the <code class="literal">innerRadius</code> and <code class="literal">outerRadius</code> variables handy:</p><div><pre class="programlisting">var innerRadius = Math.min(width, height)*0.3,
        outerRadius = innerRadius*1.1;</pre></div><p>Time to make the <code class="literal">chord</code> layout do our bidding:</p><div><pre class="programlisting">var chord = d3.layout.chord()
            .padding(.05)
            .sortGroups(d3.descending)
            .sortSubgroups(d3.descending)
            .sortChords(d3.descending)
            .matrix(matrix);</pre></div><p>It is a little different from others. The <code class="literal">chord</code> layout takes data via the <code class="literal">.matrix()</code> method and can't be called as a function.</p><p>We started with <code class="literal">d3.layout.chord()</code> and put some <code class="literal">.padding()</code> method between groups which improves readability. To improve readability further, everything is sorted. <code class="literal">.sortGroups</code> sorts groups on the edge, <code class="literal">.sortSubgroups</code> sorts chord attachments in groups, and <code class="literal">.sortChords</code> sorts chord drawing order so that smaller chords overlap bigger ones.</p><p>In the end, we feed data into the layout with <code class="literal">.matrix()</code>:</p><div><pre class="programlisting">var diagram = svg.append('g')
            .attr('transform', 'translate('+width/2+','+height/2+')');</pre></div><p>We add a centered group element so that all our coordinates are relative to the center from now on.</p><p>Drawing the<a id="id314" class="indexterm"/> diagram happens in three steps—arcs, labels, and chords, as shown in the following code:</p><div><pre class="programlisting">var group = diagram.selectAll('.group')
            .data(chord.groups)
            .enter()
            .append('g'),
    arc = d3.svg.arc()
                     .innerRadius(innerRadius)
                     .outerRadius(outerRadius);

    group.append('path')
        .attr('d', arc)R
        .attr('fill', function (d) {
               return helpers.color(d.index); });</pre></div><p>This creates the outer ring. We used <code class="literal">chord.groups</code> to get group data from the layout, created a new grouping element for every chord group, and then added an arc. We use <code class="literal">arc_labels</code> from the pie example to add the labels:</p><div><pre class="programlisting">group.call(helpers.arc_labels(
              function (d) { return uniques[d.index]; },
              function () { return outerRadius+10; }));</pre></div><p>Even though the radius is constant, we have to define it as a function using the following code because we didn't make <code class="literal">arc_labels</code> flexible enough for constants. Shame on us!</p><div><pre class="programlisting">diagram.append('g')
        .classed('chord', true)
        .selectAll('path')
        .data(chord.chords)
        .enter()
        .append('path')
        .attr('d', d3.svg.chord().radius(innerRadius))
        .attr('fill', function (d, i) { return helpers.color(d.target.index); });</pre></div><p>We got chord data from <code class="literal">chord.chords</code> and used a <code class="literal">chord path</code> generator to draw the chords. We pick colors with <code class="literal">d.target.index</code> because the graph looks better, but chord colors are <em>not</em> informative.</p><p>We add some <a id="id315" class="indexterm"/>CSS to make chords easier to follow:</p><div><pre class="programlisting">&lt;style&gt;
.chord path {
   stroke: black;
   stroke-width: 0.2;
   opacity: 0.6;
}
&lt;/style&gt;</pre></div><p>And our diagram looks perfect:</p><div><img src="img/0007_05_05.jpg" alt="Highlighting friends with chord"/></div><p>It looks pretty but unintuitive. We spent hours bickering on IRC before we figured it out.</p><p>First of all, chord colors don't mean anything! They just make it easier to distinguish chords. Furthermore, this graph shows how much karma everyone is <em>giving</em>.</p><p>From my arc's size you can see I've given about 30 percent of the karma ever given on this channel. I might be too generous.</p><p>The width of chords touching my arc tells you how much of that karma is going to whom.</p><p>At the other end of each chord, it's exactly the same. Chord width tells you how much karma that user has given me. Chords are bidirectional connections between users.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec19"/>Drawing with force</h3></div></div></div><p>The <code class="literal">force</code> layout <a id="id316" class="indexterm"/>is the most complicated of the non-hierarchical layouts. It lets you draw complex graphs using physical simulations—force-directed graphs if you will. Everything you draw will have built-in animation.</p><p>We're going to draw a graph of connections between users. Every user will be a node, the size of which will correspond to the user's karma. Links between nodes will tell us who is giving karma to whom.</p><p>To make things clearer, we're going to add tooltips and make sure mousing over a node highlights the connected nodes.</p><p>Let's begin.</p><p>As in the chord example, <a id="id317" class="indexterm"/>we begin with a matrix of connections. We aren't going to feed this directly to the <code class="literal">force</code> layout, but we will use it to create the kind of data it enjoys:</p><div><pre class="programlisting">var nick_id = helpers.nick_id(data, function (d) { return d.from; }),
        uniques = nick_id.domain(),
        matrix = helpers.connection_matrix(data);</pre></div><p>The <code class="literal">force</code> layout expects an array of nodes and links. Let's make them:</p><div><pre class="programlisting">    var nodes = uniques.map(function (nick) {
        return {nick: nick};
    });
    var links = data.map(function (d) {
        return {source: nick_id(d.from),
                     target: nick_id(d.to),
                     count: matrix[nick_id(d.from)][nick_id(d.to)]};
    });</pre></div><p>We're defining the bare minimum of what we need, and the layout will calculate all the hard stuff.</p><p>
<code class="literal">nodes</code> tell us who they represent and <code class="literal">links</code> connect a <code class="literal">source</code> object to a <code class="literal">target</code> object with an index into the <code class="literal">nodes</code> array—the layout will turn them into proper references as shown in the following code. Every link also contains a <code class="literal">count</code> object that we'll use to define its strength.</p><div><pre class="programlisting">var force = d3.layout.force()
            .nodes(nodes)
            .links(links)
            .gravity(0.5)
            .size([width, height]);

    force.start();</pre></div><p>We create a new <code class="literal">force</code> layout with <code class="literal">d3.layout.force()</code>; just like the <code class="literal">chord</code> layout, it isn't a function either. We feed in the data with <code class="literal">.nodes()</code> and <code class="literal">.links()</code>.</p><p>Gravity pulls the graph towards the center of the image; we defined its strength with <code class="literal">.gravity()</code>. We tell the <code class="literal">force</code> layout the size of our picture with <code class="literal">.size()</code>.</p><p>No calculation happens until <code class="literal">force.start()</code> is called, but we need the results to define a few scales for later.</p><p>There are a few <a id="id318" class="indexterm"/>more parameters to play with: overall <code class="literal">.friction()</code> (the smallest <code class="literal">.linkDistance()</code> value the nodes stabilize to), <code class="literal">.linkStrength()</code> for link stretchiness, and <code class="literal">.charge()</code> for attraction between nodes. Play with them.</p><p>
<code class="literal">nodes</code> members look like this now:</p><div><pre class="programlisting">{index: 0,
  nick: "HairyFotr",
  px: 497.0100389553633,
  py: 633.2734045531992,
  weight: 458,
  x: 499.5873097327753,
  y: 633.395804766377}</pre></div><p>
<code class="literal">weight</code> tells us how many links connect with this node, <code class="literal">px</code> and <code class="literal">py</code> are its previous positions, and <code class="literal">x</code> and <code class="literal">y</code> are the current position.</p><p>
<code class="literal">links</code> members are a lot simpler:</p><div><pre class="programlisting">{count: 2
  source: Object
  target: Object}</pre></div><p>Both <code class="literal">source</code> and <code class="literal">target</code> objects are a direct reference to the correct node.</p><p>Now that the layout made its first calculation step, we have the data to define some scales;</p><div><pre class="programlisting">    var weight = d3.scale.linear()
            .domain(d3.extent(nodes.map(function (d) { return d.weight; })))
            .range([5, 30]),
        distance = d3.scale.linear()
            .domain(d3.extent(d3.merge(matrix)))
            .range([300, 100]),
        given = d3.scale.linear()
            .range([2, 35]);</pre></div><p>We're going to use the <code class="literal">weight</code> scale for node sizes, <code class="literal">distance</code> for link lengths, and <code class="literal">given</code> to scale nodes for the highlighting effect:</p><div><pre class="programlisting">    force.linkDistance(function (d) {
            return distance(d.count);
        });

    force.start();</pre></div><p>We use <code class="literal">.linkDistance()</code> to dynamically define link lengths according to the <code class="literal">.count</code> property. To put the change in effect, we restart the layout with <code class="literal">force.start()</code>.</p><p>Finally! Time to put some ink on paper—well, pixels on screen:</p><div><pre class="programlisting">var link = svg.selectAll("line")
            .data(links)
            .enter()
            .append("line")
            .classed('link', true);</pre></div><p>Links are simple—go through the list of links and draw a <code class="literal">line</code>.</p><p>Draw a circle for <a id="id319" class="indexterm"/>every node and give it the right size and color. The strange <code class="literal">nick_</code> class will help us with the highlighting we're doing in the two mouse event listeners:</p><div><pre class="programlisting">var node = svg.selectAll("circle")
            .data(nodes)
            .enter()
            .append("circle")
            .classed('node', true)
            .attr({r: function (d) { return weight(d.weight); },
                   fill: function (d) { return helpers.color(d.index); },
                   class: function (d) { return 'nick_'+nick_id(d.nick); }})
            .on('mouseover', function (d) {
                highlight(d, uniques, given, matrix, nick_id);
            })
            .on('mouseout', function (d) {
                dehighlight(d, weight);
            });</pre></div><p>We add tooltips with the familiar <code class="literal">helpers.tooltip</code> function and <code class="literal">force.drag</code> will automatically make the nodes draggable:</p><div><pre class="programlisting">node.call(helpers.tooltip(function (d) { return d.nick; }));
node.call(force.drag);</pre></div><p>After all that work, <a id="id320" class="indexterm"/>we still have to do the updating on every tick of the <code class="literal">force</code> layout animation:</p><div><pre class="programlisting">force.on("tick", function() {
        link.attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });
        
        node.attr("cx", function(d) { return d.x; })
            .attr("cy", function(d) { return d.y; });
    });</pre></div><p>On a <code class="literal">tick</code> event, we move every <code class="literal">link</code> endpoint and <code class="literal">node</code> to its new position. Simple.</p><p>Time to define the two highlighting functions we mentioned earlier:</p><div><pre class="programlisting">function highlight (d, uniques, given, matrix, nick_id) {
    given.domain(d3.extent(matrix[nick_id(d.nick)]));

    uniques.map(function (nick) {
        var count = matrix[nick_id(d.nick)][nick_id(nick)];

        if (nick != d.nick) {
            d3.selectAll('circle.nick_'+nick_id(nick))
                .classed('unconnected', true)
                .transition()
                .attr('r', given(count));
        }
    });
}</pre></div><p>The <code class="literal">highlight</code> function will grow all connected nodes according to how much karma they've gotten from the node we're touching with the mouse. It starts by setting the <code class="literal">given</code> object's domain, then goes through the <code class="literal">uniques</code> list, resizes corresponding nodes using the <code class="literal">given</code> scale for size, and uses <code class="literal">nick_id</code> to find the nodes.</p><p>The current node is left alone.</p><p>
<code class="literal">dehighlight</code> will remove all the shenanigans we caused:</p><div><pre class="programlisting">function mouseout (d, weight) {
    d3.selectAll('.node')
        .transition()
        .attr('r', function (d) { return weight(d.weight); });
}</pre></div><p>Add some styling to the HTML:</p><div><pre class="programlisting">&lt;style&gt;
line {
  stroke: lightgrey;
  stroke-width: 0.3;
}

#nicktool {
  font-size: 1.3em;
}
&lt;/style&gt;</pre></div><p>And voilà! We get <a id="id321" class="indexterm"/>a force-directed graph of user connections.</p><p>Running this example looks silly because it spins around a lot before settling down. But once it stabilizes, the graph looks something like this:</p><div><img src="img/0007_05_06.jpg" alt="Drawing with force"/></div><p>The graph would be more interesting if all nodes were not connected, but hovering one of the smaller nodes will reveal interesting connections.</p><p>We should have added some code to print names next to the highlighted nodes, but the example was long enough. Let's say that's left as an exercise for the reader.</p><p>We will now move towards hierarchical layouts!</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec20"/>Hierarchical layouts</h3></div></div></div><p>All <a id="id322" class="indexterm"/>hierarchical layouts are based on an abstract hierarchy layout designed for representing hierarchical data—data within data within data within data within.... You get the idea.</p><p>All the common code for the <code class="literal">partition</code>, <code class="literal">tree</code>, <code class="literal">cluster</code>, <code class="literal">pack</code>, and <code class="literal">treemap</code> layouts is defined in <code class="literal">d3.layout.hierarchy()</code> and they all follow similar design patterns. The layouts are so similar that the official documentation very obviously copy-pastes most of its explanations. Let's avoid that by looking at the common stuff first, and then we will focus on the differences.</p><p>First of all, we need some hierarchical data. I spent an afternoon trying to make our karma dataset hierarchical. The result was a scheme that works well with three of the layouts and looks contrived for the other two. Sorry about that.</p><p>It's simple really, we kill the Batman.</p><p>We'll have a root node called <code class="literal">karma</code>, which will contain the 24 users who have ever given karma. For the <code class="literal">tree</code> and <code class="literal">cluster</code> layouts, each of those will contain nodes for everyone they have given karma to. For the <code class="literal">partition</code>, <code class="literal">pack</code>, and <code class="literal">treemap</code> layouts, children nodes will tell us who contributed to the parent's karma.</p><p>The final data structure will look like this:</p><div><pre class="programlisting">{
    "nick": "karma",
    "children": [
        {
            "nick": "HairyFotr",
            "count": 312,
            "children": [
                {
                    "nick": "notepad",
                    "count": 2,
                    "children": []
                },
                {
                    "nick": "LorD_DDooM",
                    "count": 6,
                    "children": []
                },</pre></div><p>While it could potentially go on forever, that wouldn't make sense in our case.</p><p>The default accessor expects a <code class="literal">.children</code> property, but we could easily have done something crazy like dynamically generating a fractal structure in a custom accessor.</p><p>As usual, there's a <code class="literal">.value()</code> accessor that helps layouts to find data in a node. We'll use it for the <code class="literal">.count</code> property—to check how much karma a user's got.</p><p>To run a hierarchical layout, we call <code class="literal">.nodes()</code> with our dataset. This immediately returns a list of nodes that you can't get to later. For a list of connections, we call <code class="literal">.links()</code> with a list of our nodes. Nodes in the returned list will have some extra properties calculated by the layout. Most layouts tell us where to put something with <code class="literal">.x</code> and <code class="literal">.y</code>, then use <code class="literal">.dx</code> and <code class="literal">.dy</code> to tell us how big the layout should be.</p><p>All hierarchical layouts also support sorting with <code class="literal">.sort()</code>, which takes a sorting function such as <code class="literal">d3.ascending</code> or <code class="literal">d3.descending</code>.</p><p>Enough theory, let's<a id="id323" class="indexterm"/> add a data munging function to <code class="literal">helpers.js</code>:</p><div><pre class="programlisting">make_tree: function (data, filter1, filter2, nick1, nick2) {
        var tree = {nick: 'karma',
                    children: []};
        var uniques = helpers.uniques(data, function (d) { return d.from; });

        tree.children = uniques.map(
            function (nick) {
                var my_karma = data.filter(function (d) { return filter1(d, nick); }).length,
                    given_to = helpers.bin_per_nick(
                        data.filter(function (d) { return filter2(d, nick); }),
                        nick1
                    );

                return {nick: nick,
                        count: my_karma,
                        children: given_to.map(function (d) {
                            return {nick: nick2(d),
                                    count: d.length,
                                    children: []};
                        })};
            });

        return tree;
    },</pre></div><p>Wow, there's a lot going on here. We avoided recursion because we know our data will never nest more than two levels deep.</p><p>
<code class="literal">tree</code> holds an empty root node at first. We use <code class="literal">helpers.uniques</code> to get a list of nicknames, then map through the array and define the children of the root node by counting everyone's karma and using <code class="literal">helpers.bin_per_nick</code> to get an array of children.</p><p>The code is <a id="id324" class="indexterm"/>wibbly-wobbly because we use <code class="literal">filter1</code>, <code class="literal">filter2</code>, <code class="literal">nick1</code>, and <code class="literal">nick2</code> for data accessors, but making this function flexible makes it useful in all hierarchical examples.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec21"/>Drawing a tree</h3></div></div></div><p>The <code class="literal">tree</code> layout <a id="id325" class="indexterm"/>displays data in a tree using the tidy <a id="id326" class="indexterm"/>
<strong>Reingold-Tilford</strong> tidy algorithm. We'll use it to display our dataset in a large circular tree with every node <a id="id327" class="indexterm"/>connected to its parent by a curvy line.</p><p>We begin the load listener by fixating colors, turning data into a tree, and defining a way to draw curvy lines:</p><div><pre class="programlisting">helpers.fixate_colors(data);

var tree = helpers.make_tree(data,
                   function (d, nick) { return d.to == nick; },
                   function (d, nick) { return d.from == nick; },
                   function (d) { return d.to; },
                   function (d) { return d[0].to; });

var diagonal = d3.svg.diagonal.radial()
     .projection(function(d) { return [d.y, d.x / 180 * Math.PI]; });</pre></div><p>You know <code class="literal">fixate_colors</code> from before, we defined <code class="literal">make_tree</code> not a page ago, and we've talked about the <code class="literal">diagonal</code> generator in <a class="link" href="ch02.html" title="Chapter 2. A Primer on DOM, SVG, and CSS">Chapter 2</a>,  <em>A Primer on DOM, SVG, and CSS</em>.</p><div><pre class="programlisting">var layout = d3.layout.tree()
            .size([360, width/2 - 120]);

    var nodes = layout.nodes(tree),
        links = layout.links(nodes);</pre></div><p>We create a new tree layout by calling <code class="literal">d3.layout.tree()</code>. Defining its size with <code class="literal">.size()</code> and executing it with <code class="literal">.nodes()</code>. <code class="literal">size()</code> tells the layout how much room it's got—in this case, we're using <code class="literal">x</code> as an angle (<code class="literal">360</code> degrees) and <code class="literal">y</code> as a radius. Though the layout itself doesn't really care about that.</p><p>To avoid worrying about centering later on, we put a grouping element center stage:</p><div><pre class="programlisting">var chart = svg.append('g')
            .attr('transform', 'translate('+width/2+','+height/2+')');</pre></div><p>First we are going to draw the links, then the nodes and their labels:</p><div><pre class="programlisting">    var link = chart.selectAll(".link")
            .data(links)
            .enter()
            .append("path")
            .attr("class", "link")
            .attr("d", diagonal);</pre></div><p>You should be familiar with this by now; go through the data and append new paths shaped with the <code class="literal">diagonal</code> generator:</p><div><pre class="programlisting">var node = chart.selectAll(".node")
            .data(nodes)
            .enter().append("g")
            .attr("class", "node")
            .attr("transform", function(d) { return "rotate(" + (d.x - 90) + ")translate(" + d.y + ")"; });</pre></div><p>For every node in the data, we create a new grouping element and move it into place using <code class="literal">rotate</code> for angles and <code class="literal">translate</code> for radius positions.</p><p>Now it's just a <a id="id328" class="indexterm"/>matter of <a id="id329" class="indexterm"/>adding a circle and a label:</p><div><pre class="programlisting">     node.append("circle")
        .attr("r", 4.5)
        .attr('fill', function (d) { return helpers.color(d.nick); });
    
    node.append("text")
        .attr("dy", ".31em")
        .attr("text-anchor", function(d) { return d.x &lt; 180 ? "start" : "end"; })
        .attr("transform", function(d) { return d.x &lt; 180 ? "translate(8)" : "rotate(180)translate(-8)"; })
        .text(function(d) { return d.nick; })
        .style('font-size', function (d) { return d.depth &gt; 1 ? '0.8em' : '1.1em'; });</pre></div><p>Every node is colored with the user's native color and the text is transformed similarly to the earlier pie and chord examples. Finally, we made leaf nodes' text smaller to avoid overlap.</p><p>After this, we will add some styling:</p><div><pre class="programlisting">&lt;style&gt;
.link {
  fill: none;
  stroke: lightgrey;
}
&lt;/style&gt;</pre></div><p>Our tree looks like this:</p><div><img src="img/0007_05_08.jpg" alt="Drawing a tree"/></div><p>It's rather big, so <a id="id330" class="indexterm"/>you should <a id="id331" class="indexterm"/>try it out in the browser. Just remember, the inner ring is users giving karma to the outer ring.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec22"/>Showing clusters</h3></div></div></div><p>The <code class="literal">cluster</code> layout is the same as the <code class="literal">tree</code> layout, except that leaf nodes line up.</p><p>Do you see that the <strong>hoi</strong> user is<a id="id332" class="indexterm"/> hanging out in the inner ring of the tree example? With <a id="id333" class="indexterm"/>the cluster layout they end up on the outside with the other leaf nodes.</p><p>Codewise this example is the same as the last, so we won't go through it again. Really, the only difference is that we don't have to flip labels at certain angles. You can look at the code on the GitHub examples repository <a class="ulink" href="https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/cluster.js">https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/cluster.js</a>.</p><p>We end up with a very tall graph that looks something like this:</p><div><img src="img/0007_05_09.jpg" alt="Showing clusters"/></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec23"/>Partitioning a pie</h3></div></div></div><p>Now we're getting<a id="id334" class="indexterm"/> somewhere! The next three layouts fit our data perfectly—we're taking three looks at how our core users' karma is structured.</p><p>The <code class="literal">partition</code> layout creates adjacency diagrams, where you don't draw nodes with links between them, but next to each other so that it looks like the children partition the parent.</p><p>We are going to draw a two-layer donut chart. Users will go on the first layer and the layer on top will show us where the karma is coming from.</p><p>We begin by munging the dataset and fixating colors:</p><div><pre class="programlisting">    var tree = helpers.make_tree(data,
                   function (d, nick) { return d.to == nick; },
                   function (d, nick) { return d.to == nick; },
                   function (d) { return d.from; },
                   function (d) { return d[0].from; });
    helpers.fixate_colors(data);</pre></div><p>Then use the <code class="literal">partition</code> layout:</p><div><pre class="programlisting">    var partition = d3.layout.partition()
            .value(function (d) { return d.count; })
            .sort(function (a, b) {
                return d3.descending(a.count, b.count);
            })
            .size([2*Math.PI, 300]);

    var nodes = partition.nodes(tree);</pre></div><p>We used <code class="literal">.value()</code> to tell the layout we care about the <code class="literal">.count</code> values, and we'll get a better picture if we <code class="literal">.sort()</code> the output. Similarly, to the <code class="literal">tree</code> layout, <code class="literal">x</code> will represent angles—this time in radians—and <code class="literal">y</code> will be radii.</p><p>We need an <code class="literal">arc</code> <a id="id335" class="indexterm"/>generator as well, as shown in the following code:</p><div><pre class="programlisting">    var arc = d3.svg.arc()
            .innerRadius(function (d) { return d.y; })
            .outerRadius(function (d) {
                                 return d.depth ? d.y+d.dy/d.depth : 0; });</pre></div><p>The generator will use each node's <code class="literal">.y</code> property for the inner radius and add <code class="literal">.dy</code> for the outer radius. Fiddling shows the outer layer should be thinner, hence we are dividing it by the tree depth.</p><p>Notice that there's no accessor for <code class="literal">.startAngle</code> and <code class="literal">.endAngle</code>, which are stored as <code class="literal">.x</code> and <code class="literal">.dx</code>. It's easier to just fix the data:</p><div><pre class="programlisting">    nodes = nodes.map(function (d) {
        d.startAngle = d.x;
        d.endAngle = d.x+d.dx;
        return d;
    });

    nodes = nodes.filter(function (d) { return d.depth; });</pre></div><p>It is as simple as mapping the data and defining angle properties, then filtering the data to make sure the root isn't drawn.</p><p>We use the familiar grouping trick to center our diagram.</p><div><pre class="programlisting">    var chart = svg.append('g')
            .attr('transform', 'translate('+width/2+','+height/2+')');</pre></div><p>Preparation work is done. It's drawing time:</p><div><pre class="programlisting">    var node = chart.selectAll('g')
            .data(nodes)
            .enter()
            .append('g');
    
    node.append('path')
        .attr({d: arc,
               fill: function (d) { return helpers.color(d.nick); }});</pre></div><p>An arc is drawn for every node, color is chosen as usual:</p><div><pre class="programlisting">    node.filter(function (d) { return d.depth &gt; 1 &amp;&amp; d.count &gt; 10; })
        .call(helpers.arc_labels(function (d) { return d.nick; },
                                 arc.outerRadius()));

    node.call(helpers.tooltip(function (d) { return d.nick; }));</pre></div><p>We add labels and <a id="id336" class="indexterm"/>tooltips with the functions prepared in earlier examples. We avoid adding labels for very thin slices so that they don't overlap and make a mess. Sprinkle some CSS:</p><div><pre class="programlisting">&lt;style&gt;
path {
  stroke: white;
  stroke-width: 2;
}

#nicktool {
  font-size: 1.3em;
}

#nicktool rect {
  fill: white;
}
&lt;/style&gt;</pre></div><p>The adjacency diagram looks like this:</p><div><img src="img/0007_05_10.jpg" alt="Partitioning a pie"/></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec24"/>Packing circles into circles</h3></div></div></div><p>The <code class="literal">pack</code> layout<a id="id337" class="indexterm"/> uses packing to visually represent hierarchies. It stuffs children nodes into their parents, trying to conserve space and sizing each node so that it's the cumulative size of its children.</p><p>Conceptually it's <a id="id338" class="indexterm"/>very similar to the <code class="literal">treemap</code> layout, so I'm going to skip all the code and just show you the picture. You can still see the code over at GitHub <a class="ulink" href="https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/pack.js">https://github.com/Swizec/d3.js-book-examples/blob/master/ch5/pack.js</a>.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>The code is rather familiar—generate a tree, fixate colors, create layout, tweak a few parameters, get computed nodes, draw nodes, and add tooltips. Simple.</p></div></div><div><img src="img/0007_05_11.jpg" alt="Packing circles into circles"/></div><p>It looks very pretty, but not too informative. Adding labels wouldn't help much because most nodes are too small.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec25"/>Subdividing with treemap</h3></div></div></div><p>The <code class="literal">treemap</code> layout<a id="id339" class="indexterm"/> subdivides nodes with horizontal and vertical slices, essentially packing children into their parents just like the <code class="literal">pack</code> layout, but using rectangles. As a result, node sizes on every level can be compared directly, making this one of the best layouts for analyzing cumulative effects of subdivisions.</p><p>We are going to have some <a id="id340" class="indexterm"/>fun with this example. Tooltips will name the parent—parents are almost completely obscured by the children—and mousing over a node will make unrelated nodes become lighter, making the graph less confusing (at least in theory).</p><p>It's also a cool effect and a great way to end this chapter on layouts.</p><p>We begin with the boring stuff; prepare data and fixate colors:</p><div><pre class="programlisting">    var tree = helpers.make_tree(data,
                       function (d, nick) { return d.to == nick; },
                       function (d, nick) { return d.to == nick; },
                       function (d) { return d.from; },
                       function (d) { return d[0].from; });
    helpers.fixate_colors(data);</pre></div><p>Creating the <code class="literal">treemap</code> layout follows familiar patterns:</p><div><pre class="programlisting">var treemap = d3.layout.treemap()
            .size([width, height])
            .padding(3)
            .value(function (d) { return d.count; })
            .sort(d3.ascending);

var nodes = treemap.nodes(tree)
            .filter(function (d) { return d.depth; });</pre></div><p>We added some padding with <code class="literal">.padding()</code> to give nodes room to breathe.</p><p>Every node will become a group element holding a rectangle. The leaves will also hold a label:</p><div><pre class="programlisting">var node = svg.selectAll('g')
            .data(nodes)
            .enter()
            .append('g')
            .classed('node', true)
            .attr('transform', function (d) { return 'translate(    node.a'+d.x+','+d.y+')'; });

ppend('rect')
        .attr({width: function (d) { return d.dx; },
               height: function (d) { return d.dy; },
               fill: function (d) { return helpers.color(d.nick); }});</pre></div><p>Now for the first fun bit. Let's <a id="id341" class="indexterm"/>fit labels into as many nodes as they can possibly go:</p><div><pre class="programlisting">var leaves = node.filter(function (d) { return d.depth &gt; 1; });

    leaves.append('text')
        .text(function (d) { return d.nick; })
        .attr('text-anchor', 'middle')
        .attr('transform', function (d) {
            var box = this.getBBox(),
                transform = 'translate('+(d.dx/2)+','+(d.dy/2+box.height/2)+')';

            if (d.dx &lt; box.width &amp;&amp; d.dx &gt; box.height &amp;&amp; d.dy &gt; box.width) {
                transform += 'rotate(-90)';
            }else if (d.dx &lt; box.width || d.dy &lt; box.height) {
                d3.select(this).remove();
            }

            return transform;
        });</pre></div><p>Finally! That was some interesting code!</p><p>We found all the leaves and started adding text. To fit labels into nodes, we get their size with <code class="literal">this.getBBox()</code>, then move them to the middle of the node, and check for fit.</p><p>If the label is too wide but fits vertically, we rotate it; otherwise, we remove the label after checking again that it doesn't fit. Making sure of the height is important because some nodes are very thin.</p><p>We add tooltips with <code class="literal">helpers.tooltip</code>:</p><div><pre class="programlisting">    leaves.call(helpers.tooltip(function (d) { return d.parent.nick; }));</pre></div><p>Another fun bit—partially <a id="id342" class="indexterm"/>hiding nodes from different parents:</p><div><pre class="programlisting">    leaves.on('mouseover', function (d) {
        var belongs_to = d.parent.nick;

        svg.selectAll('.node')
            .transition()
            .style('opacity', function (d) {
                if (d.depth &gt; 1 &amp;&amp; d.parent.nick != belongs_to) {
                    return 0.3;
                }
                if (d.depth == 1 &amp;&amp; d.nick != belongs_to) {
                    return 0.3;
                }
                return 1;
            });
    })
        .on('mouseout', function () {
            d3.selectAll('.node')
                .transition()
                .style('opacity', 1);
        });</pre></div><p>We used two mouse event listeners: one creates the effect, another removes it. The <code class="literal">mouseover</code> listener goes through all the nodes and lightens those with a different parent or that aren't the parent (<code class="literal">d.parent.nick</code> and <code class="literal">d.nick</code> are different). The <code class="literal">mouseout</code> listener removes all changes.</p><p>After this, add some CSS:</p><div><pre class="programlisting">&lt;style&gt;
#nicktool {
  font-size: 1.3em;
}

#nicktool rect {
  fill: white;
}

.node text {
  font-size: 0.9em;
}

.name text {
  font-size: 1.5em;
}

.name rect {
  fill: white;
}
&lt;/style&gt;</pre></div><p>The end result looks<a id="id343" class="indexterm"/> like an abstract painting:</p><div><img src="img/0007_05_12.jpg" alt="Subdividing with treemap"/></div><p>Touching an area with your mouse restores some sanity as shown in the following screenshot:</p><div><img src="img/0007_05_13.jpg" alt="Subdividing with treemap"/></div><a id="id344" class="indexterm"/><p>Although, not as much sanity as we hoped.</p></div></div></div></div></div>


  <div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Summary</h1></div></div></div><p>Despite the near mythical power of d3 layouts, they turn out to be nothing more than helpers that turn your data into a collection of coordinates.</p><p>After going full out with these examples, we used almost every trick we've learned so far. We even wrote so much code that we had to make a separate library! With a bit of generalization, some of those functions could be layouts of their own. There's a whole world of community-developed layouts for various types of charts. The d3-plugins repository on GitHub (<a class="ulink" href="https://github.com/d3/d3-plugins">https://github.com/d3/d3-plugins</a>) is a good way to start exploring.</p><p>You now understand what all the default layouts are up to, and I hope you're already thinking about using them for purposes beyond the original developers' wildest dreams.</p></div></div>
</body></html>