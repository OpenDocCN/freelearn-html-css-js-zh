<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Leveraging the MEAN Stack"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Leveraging the MEAN Stack</h1></div></div></div><p>The MEAN stack is an acronym for MongoDB, Express, AngularJS, and Node.js. It represents full stack development using practically nothing but JavaScript alone. Naturally, you will need some HTML and CSS to render things to the browser and make them look pretty.</p><p>MongoDB is a document-based NoSQL database that stores data in ways that can be treated like plain JavaScript objects. As the data and database methods are essentially JavaScript, MongoDB plays well with JavaScript-based applications.At this point, if you typed the code correctly, there will be no output in the console other than a new line. Open your favourite browser </p><p>Express is a web application framework, written in JavaScript that runs beautifully on Node.js. It's similar to other frameworks, such as Sinatra, but less obtrusive and opinionated. Express is essentially routing and middleware that handles web requests and responses.</p><p>AngularJS is a frontend JavaScript framework that is primarily used to build Single Page Web applications. It's a powerful and prescriptive framework curated by Google, which has become one of the more popular JavaScript MV* toolkits.</p><p>In this chapter, you'll explore each of the following components of the MEAN stack while starting to build the framework of your very own Single Page Application:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Running Node.js code from the command line using the REPL</li><li class="listitem" style="list-style-type: disc">Writing and running Node.js scripts</li><li class="listitem" style="list-style-type: disc">Installing MongoDB and basic CRUD operations from the Mongo shell</li><li class="listitem" style="list-style-type: disc">Installing Express via the standard method and the Express generator</li><li class="listitem" style="list-style-type: disc">Express routing, middleware, and view rendering</li><li class="listitem" style="list-style-type: disc">Building the basic components of a frontend application with Angular</li></ul></div><div class="section" title="The Node.js environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec44"/>The Node.js environment</h1></div></div></div><p>Node.js is a runtime environment built to execute JavaScript. With it, you can build powerful software, such as full-fledged backend web servers. In <span class="emphasis"><em>
<a class="link" href="ch01.html" title="Chapter 1. Getting Organized with NPM, Bower, and Grunt">Chapter 1</a>
</em></span>, <span class="emphasis"><em>Getting Organized with NPM, Bower, and Grunt</em></span>, you began to use some Node.js-based tools, such as Grunt, NPM, and the Node Package Manager.</p><p>Node.js is powerful, and extremely fast. It is based on the V8 JavaScript engine that's used in the Chrome browser and is tuned for speed. It uses a non-blocking I/O that allows it to handle many requests simultaneously.</p><p>This chapter assumes that you have already installed the Node runtime. If not, go to <a class="ulink" href="https://nodejs.org">https://nodejs.org</a>, and follow the installation instructions for your operating system Node version 4.3.2 has been used in this book.</p><div class="section" title="Running the REPL"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec83"/>Running the REPL</h2></div></div></div><p>Node.js provides a way to enter a run JavaScript code from the command line called the Read-Eval-Print Loop or REPL. You can start the REPL simply by typing <code class="literal">node</code> at the command line in a console. It's a great way to begin exploring some of the possibilities with Node.js, as shown in the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ node</strong></span>
<span class="strong"><strong>&gt; var sum = 1 + 2;</strong></span>
<span class="strong"><strong>undefined</strong></span>
<span class="strong"><strong>&gt; sum</strong></span>
<span class="strong"><strong>3</strong></span>
<span class="strong"><strong>console.log(sum);</strong></span>
<span class="strong"><strong>3</strong></span>
<span class="strong"><strong>undefined</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note7"/>Note</h3><p>The variable assignment in JavaScript returns undefined.</p></div></div><p>Here, it might appear that there are two return values, the first being <code class="literal">3</code> and the second being <code class="literal">undefined</code>. In this case, <code class="literal">console.log()</code> is a function that is used to write things out to the screen, but the function actually returns <code class="literal">undefined</code>. This will be useful in writing Node.js code where you want to log things to the screen, similar to print statements in other programming languages.</p><p>To quit out of the REPL, hit <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> twice.</p></div><div class="section" title="Writing a hello Node.js script"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec84"/>Writing a hello Node.js script</h2></div></div></div><p>Using the REPL on its own will not be incredibly useful. Node.js allows developers to create programs by writing them out and saving them as text files with a <code class="literal">.js</code> file extension.</p><p>One of the advantages of this is that you can use any text editor and practically any IDE to write Node.js programs.</p><p>To show you how powerful Node.js can be, let's start by building a simple web server. It will not do much, other than handling HTTP requests, but it's a great start.</p><p>Let's create a new file, call it <code class="literal">hello.js</code>, and open it in your favorite text editor or text-based IDE. Then, type the following lines of code:</p><pre class="programlisting">var http = require('http'); &#13;
var serverResponse = function(req, res){ &#13;
    res.end("Hello Node"); &#13;
} &#13;
 &#13;
var server = http.createServer(serverResponse); &#13;
server.listen(3000); &#13;
</pre><p>Save the file and navigate it to the directory where it is stored with a console program. Then, type the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ node hello</strong></span>
</pre><p>At this point, if you typed the code correctly, there will be no output in the console other than a new line. Open your favorite browser and type <code class="literal">localhost:3000</code> in your address bar.</p><p>You should see <span class="strong"><strong>Hello Node </strong></span>in your browser's main window. And just like that, you have written a web server.</p><p>You can stop the server by typing Ctrl + C in the console.</p><p>There's a lot going on in a small piece of code, so let's walk through what the program is doing:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">In the first line of the <code class="literal">varhttp=require('http');</code> code, similar to import statements in some programming languages, Node.js uses require to import code modules. Node.js ships with a number of built-in code modules. The HTTP module is a built-in module that provides, as you might assume, HTTP services. Built-in modules can be required using a string containing the name of the module. Generally, they will be used by assigning them to a variable. Non-built-in modules are required using a string containing the full path to the module.</li><li class="listitem" style="list-style-type: disc">In the next two lines, <code class="literal">var serverResponse = function(req, res)</code> and <code class="literal">res.end("Hello Node")</code>, the <code class="literal">serverResponse</code> function here is a callback function that we will pass to the web server we are creating. We will cover the request and response objects in more detail when we get into <code class="literal">Express.js</code>, but it's important to realize that we are setting up <code class="literal">req</code> to deal with the HTTP request object, and <code class="literal">res</code> to deal with the response. The end function on the response object sends whatever text is passed to it and tells the server that the response is done.</li><li class="listitem" style="list-style-type: disc">In the next code line, <code class="literal">varserver=http.createServer(serverResponse);</code>, we are actually creating a web server by invoking the <code class="literal">createServer</code> function on the HTTP object we required earlier. We pass the <code class="literal">serverResponse</code> function to the <code class="literal">createServer</code> function, which becomes a callback function for the server. We will store a reference to the server we just created in the variable called <span class="emphasis"><em>server</em></span>.</li><li class="listitem" style="list-style-type: disc">In the last line of the code, <code class="literal">server.listen(3000);</code>, we will invoke the <code class="literal">listen</code> function on the server object we just created. We will pass to it an integer representing the port number we want it to use to listen to requests. This bit of code actually starts up the server, and has it listen to requests on port <code class="literal">3000</code>.</li></ul></div></div><div class="section" title="Setting up a Node.js project with NPM"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec85"/>Setting up a Node.js project with NPM</h2></div></div></div><p>As Node.js projects become larger, having a tool to mange it properly is important. Concerns such as consistent dependency management, version management, and environment management are made easier using <span class="strong"><strong>Node Package Manager</strong></span> and the <code class="literal">package.json</code> file.</p><p>Fortunately, the smart people who created Node.js created a method of doing that using NPM. Running <code class="literal">npm init</code> from the command line will set up a Node.js project and build out a <code class="literal">package.json</code> file, which is used to manage your node projects. Let's try it with your <code class="literal">hello</code> Node project. Note that some of the prompts are optional and can be left blank, as shown in the following commands:</p><pre class="programlisting">
<span class="strong"><strong>$ npm init</strong></span>
<span class="strong"><strong>This utility will walk you through creating a package.json file.</strong></span>
<span class="strong"><strong>It only covers the most common items, and tries to guess sensible defaults.</strong></span>
<span class="strong"><strong>See `npm help json` for definitive documentation on these fields</strong></span>
<span class="strong"><strong>and exactly what they do.</strong></span>
<span class="strong"><strong>Use `npm install &lt;pkg&gt; --save` afterwards to install a package and</strong></span>
<span class="strong"><strong>save it as a dependency in the package.json file.</strong></span>
<span class="strong"><strong>Press ^C at any time to quit.</strong></span>
<span class="strong"><strong>name: (SPA-js) hello-node</strong></span>
<span class="strong"><strong>version: (1.0.0) </strong></span>
<span class="strong"><strong>description: my new program</strong></span>
<span class="strong"><strong>entry point: (hello.js) </strong></span>
<span class="strong"><strong>test command: </strong></span>
<span class="strong"><strong>git repository: </strong></span>
<span class="strong"><strong>keywords: </strong></span>
<span class="strong"><strong>author: Your Name</strong></span>
<span class="strong"><strong>license: (ISC) </strong></span>
<span class="strong"><strong>About to write to /Users/your-home/helloNode/package.json:</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>  "name": "hello-node",</strong></span>
<span class="strong"><strong>  "version": "1.0.0",</strong></span>
<span class="strong"><strong>  "description": "my new program",</strong></span>
<span class="strong"><strong>  "main": "hello.js",</strong></span>
<span class="strong"><strong>  "scripts": {</strong></span>
<span class="strong"><strong>    "test": "echo "Error: no test specified" &amp;&amp; exit 1"</strong></span>
<span class="strong"><strong>  },</strong></span>
<span class="strong"><strong>  "author": "John Moore",</strong></span>
<span class="strong"><strong>  "license": "ISC"</strong></span>
<span class="strong"><strong>}</strong></span>
<span class="strong"><strong>Is this ok? (yes) </strong></span>
</pre><p>Pressing Enter at this point will create the <code class="literal">package.json</code> file in the directory you're in. Open it in your IDE or text editor and take a look. While you're in there, let's make the following small change to the scripts section:</p><pre class="programlisting">"scripts": { &#13;
  "test": "echo "Error: no test specified" &amp;&amp; exit 1", &#13;
  "start": "node hello" &#13;
} &#13;
</pre><p>The scripts section of <code class="literal">package.json</code> allows you to run code using NPM. In this case, typing npm<code class="literal"> start</code> will run the <code class="literal">node hello</code> command and start your web server. It's not a super efficient shortcut at this point, but you can create efficient and useful aliases for lots of commands this way.</p><p>One of the very important things that NPM does is manage dependencies. In the next section, on Express, you'll see how to store references to NPM modules and their versions in the <code class="literal">package.json</code> file. This is important when working as part of a group or team. By taking a copy of a project's <code class="literal">package.json</code> file, a developer can recreate the environment for the project just by running NPM installation.</p></div></div></div>
<div class="section" title="Getting started with Express"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Getting started with Express</h1></div></div></div><p>Express describes itself as a fast, unopinionated, minimalist web framework for Node.js. Express is a very powerful and flexible framework that operates on top of Node.js, but still allows you access to all of the features of Node. At its core, Express operates as a set of routing and middleware functionality.</p><p>We'll get into routing and middleware in detail in later chapters. Basically, routing handles web requests. Middleware consists of functions that have access to the request and response objects and call the next piece of middleware in the stack.</p><p>If it's so easy to just throw up a web server using Node,js, why do we need something like Express?</p><p>The answer is, you don't. You could, all on your own, build a fully featured web application by just writing your own Node.js. Express has done a lot of the grunt work and heavy lifting for you. Because of the middleware that's easy to plus into Express, adding things such as security, authentication, and routing is fairly simple. And, who wants to build that stuff from scratch when you have an exciting new web application to build?</p><div class="section" title="Installing Express"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec86"/>Installing Express</h2></div></div></div><p>Of course, you will use NPM to install Express. There are two ways to do this.</p><p>The standard method is just to use NPM to pull the Express project down and add a reference to it in <code class="literal">package.json</code>. This is just adding the module into a Node.js project. You will build an application script, require it in Express, and utilize it in that WAR file.</p><p>The second method is to install the Express generator and use it to generate a starter web application. This method is simple to employ but it does structure your whole application, including folder structure, for you. Some people would prefer to do all of this on their own to get their setup precisely a certain way.</p><p>We will try both methods, and use the Express generator to build the framework for the Single Page Application that you will build throughout the rest of this book.</p><div class="section" title="Standard method"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec86"/>Standard method</h3></div></div></div><p>Again, the standard method will just be to pull the module down and add it to your project. In your console, in the directory with the <code class="literal">package.json</code> file we just created, type the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install express --save</strong></span>
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip8"/>Tip</h3><p>On a Mac, you may have to type <code class="literal">sudo</code> before <code class="literal">npm instal</code>l. If you're on a Mac, I would just go ahead and use <code class="literal">sudo</code> each type you are installing something with NPM.</p></div></div><p>The <code class="literal">-save</code> part tells npm to add Express as a dependency to your <code class="literal">package.json</code> file. Go ahead and open your <code class="literal">package.json</code> file and look at the dependencies section.</p><p>If you are using <code class="literal">git</code> or another source control system to share a code base with other developers, you, typically, will not store the dependencies in the remote repository. Instead, the <code class="literal">package.json</code> file will hold a reference to the required modules and their version.</p><p>Another developer can pull down your code, run <code class="literal">npm install</code>, and install all of the dependencies.</p><p>If you look in the folder where your <code class="literal">package.json</code> file resides, you will see a new folder called <code class="literal">node_modules</code>. This is where all of your dependencies installed with <code class="literal">npm</code> are stored. It's important not to move this or change it as the require function will look in here for modules. Typically, this folder will be added to a .<code class="literal">gitignore</code> file to ensure that its files aren't stored on a remote <code class="literal">git</code> repository.</p></div><div class="section" title="Express generator"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec87"/>Express generator</h3></div></div></div><p>There is another method of setting up an Express application. Express has created a generator that is a tool for rapidly setting up the framework for an Express application. It assumes some common conventions used in Express applications and configures things such as the main application, the <code class="literal">package,json</code>, and even the directory structure.</p><p>The generator is installed globally rather than in a specific project using the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ npm install express-generator -g</strong></span>
</pre><p>The <code class="literal">-g</code> tells NPM to install the module and its dependencies globally. They won't be installed in the <code class="literal">npm_modules</code> folder in your project, but in a global modules folder on your system.</p></div></div><div class="section" title="Setting up your Express application"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec87"/>Setting up your Express application</h2></div></div></div><p>Now that we have the express generator installed globally, let's use it to start building the application we'll be building out in the rest of the book. Pick a folder where you want this project to live. The Express generator will create a new folder inside this folder, so it's fine if it is a home or projects folder containing other things.</p><p>Navigate to this folder in your console using the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ express -e giftapp</strong></span>
<span class="strong"><strong>   create : giftapp</strong></span>
<span class="strong"><strong>   create : giftapp/package.json</strong></span>
<span class="strong"><strong>   create : giftapp/app.js</strong></span>
<span class="strong"><strong>   create : giftapp/public</strong></span>
<span class="strong"><strong>   create : giftapp/public/javascripts</strong></span>
<span class="strong"><strong>   create : giftapp/public/images</strong></span>
<span class="strong"><strong>   create : giftapp/routes</strong></span>
<span class="strong"><strong>   create : giftapp/routes/index.js</strong></span>
<span class="strong"><strong>   create : giftapp/routes/users.js</strong></span>
<span class="strong"><strong>   create : giftapp/public/stylesheets</strong></span>
<span class="strong"><strong>   create : giftapp/public/stylesheets/style.css</strong></span>
<span class="strong"><strong>   create : giftapp/views</strong></span>
<span class="strong"><strong>   create : giftapp/views/index.ejs</strong></span>
<span class="strong"><strong>   create : giftapp/views/error.ejs</strong></span>
<span class="strong"><strong>   create : giftapp/bin</strong></span>
<span class="strong"><strong>   create : giftapp/bin/www</strong></span>
<span class="strong"><strong>   install dependencies:</strong></span>
<span class="strong"><strong>     $ cd giftapp &amp;&amp; npm install</strong></span>
<span class="strong"><strong>   run the app:</strong></span>
<span class="strong"><strong>     $ DEBUG=giftapp:* npm start</strong></span>
</pre><p>As you can see, the express generator has created a number of files including <code class="literal">app,js</code>, your main app file.</p><p>The <code class="literal">-e</code> modifier we typed after the express command told the generator that we want to use <code class="literal">ejs</code> (embedded JavaScript) frontend templates. Express supports a number of templating languages, including Handlebars and Jade. If you add no modifier, the Express generator will assume you want to use Jade. For this project, we will use <code class="literal">ejs</code>, which is essentially real HTML with embedded JavaScript code.</p><p>The final output of the generator tells you the next steps you need to actually stand up your application. Navigate to your new <code class="literal">giftapp</code> directory and run <code class="literal">npm install</code> (remember <code class="literal">sudo</code> if you're on a Mac or Linux box). The <code class="literal">npm install</code> command at this point might take a few minutes as it's installing a number of dependencies.</p><p>The next command starts your new Express application in <code class="literal">DEBUG</code> mode—you will see all requests logged to the console. Navigating to <code class="literal">localhost:3000</code> in your browser will display a <span class="strong"><strong>Welcome to Express</strong></span> page.</p><p>Congratulations, this page is being served from your very own robust Express web application. It's not doing much yet, but a lot of pieces are already in place for you.</p></div><div class="section" title="Exploring the main script"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec88"/>Exploring the main script</h2></div></div></div><p>Open giftapp's new <code class="literal">package.json</code> file. Note the following scripts object:</p><pre class="programlisting">"scripts": { &#13;
  "start": "node ./bin/www" &#13;
} &#13;
</pre><p>This is saying that when the <code class="literal">npm</code> start is run, the script that's actually invoked is at <code class="literal">./bin/www</code>. So, let's open the <code class="literal">www</code> file in your bin directory and take a look.</p><p>You'll see that this file is requiring a number of things, including <code class="literal">app.js</code>; this is your main application file:</p><pre class="programlisting">var app = require('../app'); &#13;
</pre><p>The next bit of code set's the port number of the app. It looks to see if there's an environment variable set containing the desired port number. If not, it sets it to <code class="literal">3000</code>. When deploying an application to production, typically, you will use <code class="literal">port 80</code> for HTTP or <code class="literal">port 443</code> for HTTPS:</p><pre class="programlisting">var port = normalizePort(process.env.PORT || '3000'); &#13;
app.set('port', port); &#13;
</pre><p>The next bit creates the server and starts listening on the correct port:</p><pre class="programlisting">var server = http.createServer(app); &#13;
... &#13;
server.listen(port); &#13;
</pre><p>For now, we'll skip over the rest of this file and take a look at what's in the <code class="literal">app.js</code> file. Go ahead and open it up.</p></div><div class="section" title="Looking at the main application"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec89"/>Looking at the main application</h2></div></div></div><p>
<code class="literal">App.js</code> is the main application file that loads the routes and middleware and configures the application. There are a number of important sections of this file. In general, in Express applications, the order of loading and utilization, and the order middleware is invoked in this file, is important. Let's take a look.</p><div class="section" title="Loading dependencies"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec88"/>Loading dependencies</h3></div></div></div><p>When you open <code class="literal">app.js</code>, you will first encounter a number of calls to the require function, as follows:</p><pre class="programlisting">var express = require('express'); &#13;
var path = require('path'); &#13;
var favicon = require('serve-favicon'); &#13;
var logger = require('morgan'); &#13;
var cookieParser = require('cookie-parser'); &#13;
var bodyParser = require('body-parser'); &#13;
var routes = require('./routes/index'); &#13;
var users = require('./routes/users'); &#13;
</pre><p>This system is known as <code class="literal">CommonJS</code>. The first set of modules includes the dependencies, such as Express, and a parser for cookies. The routes and users modules were created by the Express generator for routing. The routes you create will be required in the main file as well.</p></div><div class="section" title="Configuring the application"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec89"/>Configuring the application</h3></div></div></div><p>Next, an <code class="literal">app </code>variable is declared by invoking the express function, and a couple of configuration variables are set, as follows:</p><pre class="programlisting">var app = express(); &#13;
... &#13;
app.set('views', path.join(__dirname, 'views')); &#13;
app.set('view engine', 'ejs'); &#13;
</pre><p>The first configuration, views, tells Express where to look for the view templates. These are the templates that are normally rendered into HTML as the result of requests to the web application.</p><p>The second configuration sets the view engine. As we discussed earlier, we will use <code class="literal">ejs</code> or embedded JavaScript templates.</p></div><div class="section" title="Application-level middleware"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec90"/>Application-level middleware</h3></div></div></div><p>The next thing we will see in this file is a bunch of calls to the app object's <code class="literal">use</code> function, which is as follows:</p><pre class="programlisting">app.use(logger('dev')); &#13;
app.use(bodyParser.json()); &#13;
app.use(bodyParser.urlencoded({ extended: false })); &#13;
app.use(cookieParser()); &#13;
app.use(express.static(path.join(__dirname, 'public'))); &#13;
app.use('/', routes); &#13;
app.use('/users', users); &#13;
// catch 404 and forward to error handler &#13;
app.use(function(req, res, next) { &#13;
  var err = new Error('Not Found'); &#13;
  err.status = 404; &#13;
  next(err); &#13;
}); &#13;
</pre><p>In Express, calls to the application object's use function are application-level middleware. Requests sent to the application will execute every function matching the path set in <code class="literal">app.use</code>. If no path is set, the middleware function defaults to the root path <code class="literal">/</code>and will be invoked for every request.</p><p>For example, <code class="literal">app.use(cookieParser());</code> means that the <code class="literal">cookieParser</code> function will be invoked for every request sent to the application because it defaults to the root path. However, <code class="literal">app.use('/users',users);</code> will only apply when the request begins with <code class="literal">/users</code>.</p><p>Middleware is invoked in the order it's declared. This will become very clear later, when we add authentication to our application, or want to handle <code class="literal">POST</code> data. If you don't parse cookies before you try to manage a request requiring authentication, it won't work.</p></div></div><div class="section" title="Our first Express route"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec90"/>Our first Express route</h2></div></div></div><p>Express uses a mechanism called routing, using its <code class="literal">Router</code> object, to handle HTTP requests, such as those from web browsers. In a later chapter, we will take a more in-depth look at Express routing. It bears examining the first route that the Express generator created for us. Open your <code class="literal">routes/index.js</code> file, as shown in the following code block:</p><pre class="programlisting">var express = require('express'); &#13;
var router = express.Router(); &#13;
 &#13;
/* GET home page. */ &#13;
router.get('/', function(req, res, next) { &#13;
  res.render('index', { title: 'Express' }); &#13;
}); &#13;
module.exports = router; &#13;
</pre><p>To create a new set of routes, we must create a new router object by invoking the <code class="literal">Expresses Router</code> function. You will see that we require Express first, then do exactly that.</p><p>The next expression is a call to the router object's get function. This, in Express, is router-level middleware. This function sets up middleware, in the form of the enclosed anonymous function, which responds to HTTP <code class="literal">GET</code> requests, such as typing a URL in a browser's address bar or clicking on a link.</p><p>The first argument to the function is a path to match. When the path matches, in this case the root path, the function is invoked. The anonymous function here receives the request object, the response object, and the next object.</p><p>The function invokes the response object's render function. This function looks in the views directory for a template called index and renders it, passing it the object in the second argument. The template has access to all the properties of that object, in this case, just the title, and can render them to in the response.</p><p>Finally, we will see the <code class="literal">module.exports=router;</code> expression. This allows the Node.js module system to load this code using the required function and assign the router object to a variable. Near the top of our <code class="literal">app.js</code> file, you'll see <code class="literal">varroutes=require('./routes/index');</code>.</p></div><div class="section" title="Rendering the first view"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec91"/>Rendering the first view</h2></div></div></div><p>When you started the Express server, navigated to <code class="literal">localhost:3000</code>, and saw the default Express page, what happened?</p><p>The request came into the web application and was routed to index based on the request type, <code class="literal">GET</code>, and the path, <code class="literal">/</code>. The middleware then called the response object's render function and told it to get the index template, passing it an object with a property called title.</p><p>Open your <code class="literal">views/ index.ejs</code> file to see the following template code:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
  &lt;head&gt; &#13;
    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
  &lt;/head&gt; &#13;
  &lt;body&gt; &#13;
    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &#13;
    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>If you've used other dynamic templating languages before, you probably already understand that this is normal HTML that contains some dynamic elements. Those dynamic elements that are contained by <code class="literal">&lt;%...%&gt;</code> are processed by the server. These <span class="emphasis"><em>tags</em></span> are not sent to the browser, just clean HTML.</p><p>In this case, the three tags are identical, all rendering the title property of the object passed in the call to the response object's render method. As a quick experiment, change the value of the title passed in.</p></div></div>
<div class="section" title="Exploring MongoDB"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Exploring MongoDB</h1></div></div></div><p>Remember that the <span class="emphasis"><em>M</em></span> in the MEAN stack, is an open source document-based database. It's considered a NoSQL database because it doesn't use SQL and is not relational. It integrates well with JavaScript-based tools because, instead of tables, it stores data in documents that can be treated by our Node.js application as JSON.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note9"/>Note</h3><p>Technically, MongoDB stores data in a format called BSON, short for Binary JSON.</p></div></div><div class="section" title="Setting up MongoDB"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Setting up MongoDB</h2></div></div></div><p>The first step in getting MongoDB running on your system is installation. Head over to <a class="ulink" href="https://www.mongodb.org/downloads#production">https://www.mongodb.org/downloads#production</a>, and you will find the most updated installation download for Windows, Mac, Linux, or Solaris. There are also links to instructions there to install MongoDB with tools such as Homebrew for Mac and yum for Linux.</p><p>Up-to-date installation instructions for each operating system can be found at <a class="ulink" href="https://docs.mongodb.org/manual/">https://docs.mongodb.org/manual/</a>. There are differences between the operating systems, and installation instructions may change with newer versions. I suggest following the official installation instructions.</p><p>Once installed, you can start the MongoDB service by typing <code class="literal">mongod</code> in a console.</p><p>You will not be able to type any other commands in that console while the MongoDB daemon is running. By default, this process will run on <code class="literal">port 27017</code> and bind to the IP address, <code class="literal">127.0.0.1</code>. Both of these can be changed with command flags at start up, or with a <code class="literal">.conf</code> file. For our purposes, the defaults will do.</p></div><div class="section" title="Working with the MongoDB shell"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Working with the MongoDB shell</h2></div></div></div><p>We'll begin to work with MongoDB with the command-line shell included with the Mongo installation. As you must have the MongoDB daemon running to work with the database, you'll need to open a new console.</p><p>In the application we are building, we will rely on Node.js plugins to handle our database operations. It is beneficial, however, to gain an understanding of how MongoDB works and how it differs from SQL databases.</p><p>The best way to do that is to get our hands dirty and run some basic operations from the command line of MongoDB's shell.</p><div class="section" title="Selecting a database"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec91"/>Selecting a database</h3></div></div></div><p>Let's select the database that we want to work with. Open your command line and enter the following command:</p><pre class="programlisting">
<span class="strong"><strong>$mongo</strong></span>
<span class="strong"><strong>&gt; use test</strong></span>
<span class="strong"><strong>switched to db test</strong></span>
<span class="strong"><strong>&gt;</strong></span>
</pre><p>Running <code class="literal">mongo</code>, as opposed to <code class="literal">mongod</code>, from the command line starts the MongoDB shell, which allows typing commands directly to the running MongoDB daemon.</p><p>The <code class="literal">use</code> command selects which database we are currently using. But, wait a minute; we never created a test database. That's correct, and we still haven't. We can use the <code class="literal">showdbs</code> command to list all of the databases on our computer that MongoDB knows about:</p><pre class="programlisting">
<span class="strong"><strong>&gt; show dbs</strong></span>
<span class="strong"><strong>local  0.078GB</strong></span>
</pre><p>If you've done all the previous examples, you would already have created a local database name <code class="literal">test</code>. Local stores a <code class="literal">startup</code> log and replica information in replicated environments. We can use local and add our own data to it, but that's not really a great idea. Let's create a database of our own.</p></div><div class="section" title="Inserting documents"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec92"/>Inserting documents</h3></div></div></div><p>Remember that records in MongoDB are referred to as documents. They loosely relate to rows in a traditional relation database but are much more flexible.</p><p>If we insert a document now, the new database will be created use the following commands:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.cat.insert({name:"Tom",color:"grey"})</strong></span>
<span class="strong"><strong>WriteResult({ "nInserted" : 1 })</strong></span>
<span class="strong"><strong>&gt; show dbs</strong></span>
<span class="strong"><strong>local  0.078GB</strong></span>
<span class="strong"><strong>test   0.078GB</strong></span>
</pre><p>The <code class="literal">db.cat.insert()</code>command adds the document in the argument to insert to a collection called cat.</p><p>In MongoDB, a collection is a set of documents. This is similar to a table in a relational database, which is a set of records. Unlike relational databases, the documents in a collection do not have to all be the same type or have the same set of data.</p><p>You may get notices that the document we inserted looks like a plain old JavaScript object. Essentially, it is. This is one of the nice things about working with MongoDB as part of the MEAN stack—it's JavaScript from the frontend all the way to the database.</p><p>When we type <code class="literal">showdbs</code>, we will see that the test database is now created. We also created a cat collection in the test database by inserting a document into it. This is something to be cautious of when working with the shell. It's easy to accidentally create unwanted databases and collections with a typo.</p></div><div class="section" title="Finding documents"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec93"/>Finding documents</h3></div></div></div><p>Now that we have a database, a collection in that database, and have inserted a document into that collection, we need to be able to retrieve the document. The most basic way to do that is using the find method of MongoDB.</p><p>Let's take a look at our document:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.cat.find()</strong></span>
<span class="strong"><strong>{ "_id" : ObjectId("565c010dd9d61e2dc614181f"), "name" : "Tom", "color" : "grey" }</strong></span>
</pre><p>The <code class="literal">db.collection.find()</code> method is MongoDB's basic method to read data. It is the <span class="emphasis"><em>R</em></span> in MongoDB's CRUD—Create, Read, Update, Delete—operations.</p><p>As you can see, MongoDB has added an <code class="literal">_id</code> field to our object, which is as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.cat.insert({name:"Bob",color:"orange"})</strong></span>
<span class="strong"><strong>WriteResult({ "nInserted" : 1 })</strong></span>
<span class="strong"><strong>&gt; db.cat.find({},{_id:0,name:1})</strong></span>
<span class="strong"><strong>{ "name" : "Tom" }</strong></span>
<span class="strong"><strong>{ "name" : "Bob" }</strong></span>
</pre><p>We've inserted a new orange cat named <code class="literal">Bob</code> here and, this time, the find method we're using is a little different. It's taking two arguments.</p><p>The first argument is the query criteria. This tells MongoDB which documents to select. In this case, we've used an empty object so all documents are selected.</p><p>The second argument is a projection that limits the amount of data MongoDB returns. We told MongoDB that we want the name field, but to suppress the <code class="literal">_id</code> field, which will be returned by default.</p><p>In a later chapter, we will explore how to limit the number of documents returned and sort them.</p><p>Take a look at following command:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.cat.find({color:"orange"},{_id:0,name:1})</strong></span>
<span class="strong"><strong>{ "name" : "Bob" }</strong></span>
</pre><p>We've adjusted our query to contain query criteria that selects only cats that have a color of orange. <code class="literal">Bob</code> is the only orange cat, so this is the only document returned. Again, we will suppress <code class="literal">_id</code> and tell MongoDB that we only want to see the name field.</p></div><div class="section" title="Updating documents"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec94"/>Updating documents</h3></div></div></div><p>What if we want to change a record in our database? There are several methods to do this, but we'll start with the simplest one. MongoDB provides the appropriately named update method to modify documents in a database, as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.cat.update({name:"Bob"},{$set:{color:"purple"}})</strong></span>
<span class="strong"><strong>WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })</strong></span>
<span class="strong"><strong>&gt; db.cat.find({color:"orange"},{_id:0,name:1})</strong></span>
<span class="strong"><strong>&gt; db.cat.find({color:"purple"},{_id:0,name:1})</strong></span>
<span class="strong"><strong>{ "name" : "Bob" }</strong></span>
</pre><p>Similar to the find method, the first argument to the update method tells MongoDB which documents to select. By default, however, MongoDB will only update one document at a time. To update multiple documents, we will add a third argument, a modifier object, <code class="literal">{multi:true}</code>.</p><p>We have selected documents where the name field equals <code class="literal">Bob</code> (there is only one). Then, we will use the <code class="literal">$set</code> operator to change color of <code class="literal">Bob</code> to purple.</p><p>We can verify that this has worked by querying for <code class="literal">orange</code> cats using the following command:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.cat.find({color:"orange"},{_id:0,name:1})</strong></span>
<span class="strong"><strong>&gt; db.cat.find({color:"purple"},{_id:0,name:1})</strong></span>
<span class="strong"><strong>{ "name" : "Bob" }</strong></span>
</pre><p>No documents are returned. A query for purple <code class="literal">cat</code> now returns our document for a <code class="literal">cat</code> named <code class="literal">Bob</code>.</p></div><div class="section" title="Removing documents"><div class="titlepage"><div><div><h3 class="title"><a id="ch07lvl3sec95"/>Removing documents</h3></div></div></div><p>No set of CRUD operations is complete without the <span class="emphasis"><em>D</em></span> or Delete operation. MongoDB provides the remove method for this, which is as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.cat.remove({color:"purple"})</strong></span>
<span class="strong"><strong>WriteResult({ "nRemoved" : 1 })</strong></span>
<span class="strong"><strong>&gt; db.cat.find({},{_id:0,name:1})</strong></span>
<span class="strong"><strong>{ "name" : "Tom" }</strong></span>
</pre><p>The remove method has a fairly similar signature to the other MongoDB CRUD methods. The first argument, as you may have surmised, is a selector to choose which documents MongoDB should be removed.</p><p>In the preceding example, we removed all documents containing the <code class="literal">purple</code> value for the color property. There was only one, so goodbye poor <code class="literal">Bob</code>. We verified with our call to the find method which now only returns <code class="literal">Tom</code>.</p><p>The default for the remove method is to delete all found documents, so use caution. Passing an empty selector will delete all documents in a collection, as follows:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.cat.remove({})</strong></span>
<span class="strong"><strong>WriteResult({ "nRemoved" : 1 })</strong></span>
<span class="strong"><strong>&gt; db.cat.find()</strong></span>
<span class="strong"><strong>&gt;</strong></span>
</pre><p>And with that, we have no cats.</p><p>MongoDB has no built-in rollback functionality, so there's no real way to undo such a deletion. In production, this is one reason why replication and regular database backups are important.</p></div></div><div class="section" title="Create your SPA database"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Create your SPA database</h2></div></div></div><p>So, now that we have mucked about with MongoDB a little bit, let's create the development database we will use for the SPA we are building.</p><p>In a later chapter, we will use a Node.js plugin called <span class="emphasis"><em>mongoose to model</em></span> to validate, query, and manipulate our data.</p><p>For now, let's just get the database set up. In your mongo shell, type the following command:</p><pre class="programlisting">
<span class="strong"><strong>&gt; use giftapp</strong></span>
<span class="strong"><strong>switched to db giftapp</strong></span>
</pre><p>Remember, we haven't actually created the database yet. For that, we will need to stick a document into a collection. As we'll let Mongoose do all of the heavy lifting for us later, we'll just put something in a test collection to get started. Let's consider the following code as an example:</p><pre class="programlisting">
<span class="strong"><strong>&gt; db.test.insert({test:"here is the first document in the new database"})</strong></span>
<span class="strong"><strong>WriteResult({ "nInserted" : 1 })</strong></span>
<span class="strong"><strong>&gt; db.test.find()</strong></span>
<span class="strong"><strong>{ "_id" : ObjectId("565ce0a2d9d61e2dc6141821"), "test" : "here is the first document in the new database" }</strong></span>
<span class="strong"><strong>&gt; show dbs</strong></span>
<span class="strong"><strong>giftapp  0.078GB</strong></span>
<span class="strong"><strong>local    0.078GB</strong></span>
<span class="strong"><strong>test     0.078GB</strong></span>
</pre><p>Here, we will insert a document into the test collection. We can verify it's there with a call to the find method. Finally, we will run <code class="literal">showdbs</code> and see that our <code class="literal">giftapp</code> database is successfully created.</p></div></div>
<div class="section" title="Starting with AngularJS"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec47"/>Starting with AngularJS</h1></div></div></div><p>We've got most of the pieces of our application stack in place now. We have a runtime environment, Node.js. We've installed and set up a web application framework, Express. We just set up our database, MongoDB.</p><p>The one piece that's missing is pretty crucial in any SPA—no matter what the backend stack looks like, there's a frontend framework to make the SPA magic happen.</p><p>There are numerous frontend libraries and frameworks used for SPAs, but one of the most popular, and the <span class="emphasis"><em>A</em></span> in MEAN, is AngularJS, otherwise known as Angular.</p><p>Angular is an open source frontend framework, particularly well-suited to building SPA. It's extremely popular and currently maintained by Google.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>In this book, we will use AngularJS version 1.4.8, which was released in November, 2015. AngularJS 2.0 was announced in 2014 and is, at the time of publication, just made available in a production version. The 2.0 version introduced breaking non-backward-compatible changes. Most development today is done using some version on the 1.x branch, and the plan is to continue support for the foreseeable future.</p></div></div><div class="section" title="Installing AngularJS into the application"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Installing AngularJS into the application</h2></div></div></div><p>Ultimately, Angular is a single JavaScript file with some optional plugin files. There are a few ways to add Angular to your frontend application. You can download the package you're interested in or load it with a tool such as <code class="literal">Bower</code>.</p><p>The simplest way for us to get started is to simply point to the Angular file on a publicly available CDN. We can include Angular 1.4.8 from <a class="ulink" href="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js">https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js</a>.</p><p>Let's open our <code class="literal">index.ejs</code> file and include a script tag linking to the following file:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
  &lt;head&gt; &#13;
    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
  &lt;/head&gt; &#13;
  &lt;body&gt; &#13;
    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &#13;
    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &#13;
<span class="strong"><strong>    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js"&gt;&lt;/script&gt;</strong></span> &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>It's good practice, when possible, to include script tags linking to external JavaScript files right before the closing body tag in HTML. This is done for performance reasons. You can find out more and see some examples showcasing the reasoning for this at <a class="ulink" href="http://stevesouders.com/hpws/rule-js-bottom.php">http://stevesouders.com/hpws/rule-js-bottom.php</a>.</p></div></div><p>If you restart the server and load the default page at <code class="literal">localhost:3000</code>, you won't see very much. You are loading AngularJS, but there's no visible effect yet. We will build up some example frontend code in layers.</p><p>The first thing we want to do after adding the AngularJS script is to change the <code class="literal">html</code> tag to read as shown in the following code:</p><pre class="programlisting">&lt;html ng-app&gt; &#13;
</pre><p>The <code class="literal">ng-app</code> attribute on the head element is what is called an Angular directive. When Angular loads in a page, it goes through a bootstrapping phase looking for directives such as <code class="literal">ng-app</code>. This directive tells Angular where the root element of the application is.</p><p>You can think of this attribute as a way of marking out an area of interest that Angular will manage. In our case, we'd like to use Angular components on the whole page, so we'll declare the HTML element as the root element.</p><p>In the next section, we will build a module that will become our root application.</p></div><div class="section" title="Building the first AngularJS module"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Building the first AngularJS module</h2></div></div></div><p>AngularJS was designed to be modular and includes a function to register modules. Modules act as containers for other objects, such as Angular services, directives, and controllers.</p><p>Angular modules are also injectable. This means that modules can be injected into and consumed by other modules. Angular has a unique dependency injection system, which we will see shortly and use a lot.</p><p>Create a new JavaScript file in the <code class="literal">public/javavscripts</code> directory of <code class="literal">giftapp</code> called <code class="literal">app.js</code> and type the following code into it:</p><pre class="programlisting">var giftAppModule = angular.module('giftAppModule', []); &#13;
 &#13;
giftAppModule.value('appName', 'GiftApp'); &#13;
</pre><p>The first line creates and registers an Angular module using the <code class="literal">angular.module()</code> function. The first argument to this function is a string that Angular will use as the name of the module, <code class="literal">giftAppModule</code>. The second argument is an array of dependencies we wish to inject into this module. For now, we don't have any, so the array is empty.</p><p>We then assign the module to the <code class="literal">giftAppModule</code> variable. This variable name, even though it happens to be identical to the module name, is unrelated; we could have called it anything else. You don't have to assign a module to a variable name, but it's useful as it allows us to more cleanly add assets to the module.</p><p>The next line, <code class="literal">giftAppModule.value('appName','GiftApp');</code>, creates a new service on the module by calling the <code class="literal">value</code> function. A service in Angular is a singleton, which is injectable. Angular includes a number of types of services. A value service is the simplest type and creates a name value pair that can be injected and used. We will use this in our controller.</p><p>Finally, we want to load our new module and <code class="literal">Bootstrap</code> it as the root Angular application in our <code class="literal">index.ejs</code> template.</p><p>Take a look at the following code:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html ng-app="giftAppModule"&gt; &#13;
  &lt;head&gt; &#13;
    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
  &lt;/head&gt; &#13;
  &lt;body&gt; &#13;
    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &#13;
    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &#13;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="/javascripts/app.js"&gt;&lt;/script&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>There are two important changes to note here. First, in the HTML element we added a reference to the <code class="literal">giftAppModule</code> we just created by setting it as the value of the <code class="literal">ng-app</code> directive. The next change is that we've added a new <code class="literal">script</code> tag before the closing body tag that loads the <code class="literal">app.js</code> file that we just created.</p><p>Load order is important here, and Angular must be loaded before <code class="literal">app.js</code> or it will fail. Note the path that we're using to load <code class="literal">app.js</code>: <code class="literal">/javascripts/app.js</code>. This works because of piece of code in the Express <code class="literal">app.js</code> that points requests for static files at the public directory, <code class="literal">app.use(express.static(path.join(__dirname,'public')));</code>.</p><p>Starting the server up, if it's stopped, and reloading the page does nothing visible at this point. To start making changes to the page, we need to add a controller and an Angular expression.</p></div><div class="section" title="Adding a controller"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec97"/>Adding a controller</h2></div></div></div><p>In Angular, a controller is a JavaScript object that exposes data and functionality to the view. It does this through Angular's <code class="literal">$scope</code> object.</p><p>Open your <code class="literal">app.js</code> file and add the following code:</p><pre class="programlisting">var giftAppModule = angular.module('giftAppModule', []); &#13;
 &#13;
giftAppModule.value('appName', 'GiftApp'); &#13;
 &#13;
<span class="strong"><strong>giftAppModule.controller("GreetingController", ['$scope','appName', function($scope)&#13;
{&#13;
</strong></span>
<span class="strong"><strong>        $scope.name = appName;&#13;
</strong></span>
<span class="strong"><strong>        $scope.greeting = "Hello Angular"&#13;
</strong></span>
<span class="strong"><strong>    }&#13;
]&#13;
</strong></span>
<span class="strong"><strong>);</strong></span>
</pre><p>The additional code has created a controller constructor on <code class="literal">giftAppModule</code> called <code class="literal">GreetingController</code>. This isn't an actual controller until it is invoked in the page using the <code class="literal">ng-controller</code> directive.</p><p>The first argument to the function is the name of the controller. The second argument is an array consisting of the dependencies we wish to inject. The final item in the array is the function itself. Angular documentation refers to this as array annotation and it is the preferred method of creating constructors.</p><p>The module name strings of the first part of the array map to the arguments of the function. The order of each must be the same.</p><p>Next, we will need to add the controller to our <code class="literal">index.ejs html</code>, as follows:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html ng-app="giftAppModule"&gt; &#13;
  &lt;head&gt; &#13;
    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
  &lt;/head&gt; &#13;
  &lt;body&gt; &#13;
    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &#13;
    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &#13;
    &lt;div ng-controller="GreetingController"&gt; &#13;
 &#13;
    &lt;/div&gt; &#13;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="/javascripts/app.js"&gt;&lt;/script&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>Here, we will add a <code class="literal">div</code> tag and give it an <code class="literal">ng-controller</code> attribute with a value of <code class="literal">GreetingController</code>. When we load this page, Angular will create a new <code class="literal">GreetingController</code> object and attach a child scope to this part of the page.</p><p>Again, if you hit reload on your browser, you will not see anything different. Generally, to display data to the user, you will use Angular expressions.</p></div><div class="section" title="Displaying data with Angular expressions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Displaying data with Angular expressions</h2></div></div></div><p>Angular expressions are code snippets that are placed between double curly braces (<code class="literal">{{}}</code>). Angular evaluates these (the JavaScript <code class="literal">eval()</code> function is not used as it's not a safe mechanism).</p><p>The Angular documentation refers to expressions as JavaScript as there are some pretty major differences. For example, Angular expressions don't have <code class="literal">control loops</code>.</p><p>Angular expressions are evaluated within the context of the current scope.</p><p>Let's make the following changes to <code class="literal">index.ejs</code>:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html ng-app="giftAppModule"&gt; &#13;
  &lt;head&gt; &#13;
    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
  &lt;/head&gt; &#13;
  &lt;body&gt; &#13;
    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &#13;
    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &#13;
    &lt;div ng-controller="GreetingController"&gt; &#13;
       {{ greeting }} from {{ name }} {{ 2+3 }} &#13;
    &lt;/div&gt; &#13;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="/javascripts/app.js"&gt;&lt;/script&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>We've added some Angular expressions inside <code class="literal">div</code>, where we invoked <code class="literal">GreetingController</code>. Angular makes the <code class="literal">GreetingController</code> scope object available inside this <code class="literal">div</code>.</p><p>Now, if you reload this page, under <span class="strong"><strong>Welcome to Express</strong></span>, you should see the following line of code:</p><pre class="programlisting">Hello Angular from GiftApp 5 &#13;
</pre><p>Angular has evaluated the expressions and displayed them as strings. The expressions containing greeting and name are pulling those values from the scope. The final expression is just doing a little bit of arithmetic.</p></div><div class="section" title="Two-way data binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Two-way data binding</h2></div></div></div><p>One of the main features that Angular provides is called two-way data binding. This means that changing data in the view updates the data on the model. Likewise, data changed in the model is reflected in the view.</p><p>Open <code class="literal">app.js</code> and add the following property to the scope:</p><pre class="programlisting">var giftAppModule = angular.module('giftAppModule', []); &#13;
 &#13;
giftAppModule.value('appName', 'GiftApp'); &#13;
 &#13;
giftAppModule.controller("GreetingController", ['$scope','appName', function($scope, appName){ &#13;
        $scope.name = appName; &#13;
        $scope.greeting = "Hello Angular"; &#13;
        $scope.newName = "Bob"; &#13;
    }] &#13;
); &#13;
</pre><p>We've added a <code class="literal">newName</code> property and assigned to it the string, <code class="literal">Bob</code>.</p><p>Now, we will need to make the following changes to <code class="literal">index.ejs</code>:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html ng-app="giftAppModule"&gt; &#13;
  &lt;head&gt; &#13;
    &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
  &lt;/head&gt; &#13;
  &lt;body&gt; &#13;
    &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &#13;
    &lt;p&gt;Welcome to &lt;%= title %&gt;&lt;/p&gt; &#13;
    &lt;div ng-controller="GreetingController"&gt; &#13;
       {{ greeting }} from {{ name }} {{ 2+3 }} {{ newName }} &#13;
        &lt;p&gt;&lt;input type=""text" ng-model="newName"&gt;&lt;/p&gt; &#13;
    &lt;/div&gt; &#13;
    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/angular.js/1.4.8/angular.js"&gt;&lt;/script&gt; &#13;
    &lt;script src="/javascripts/app.js"&gt;&lt;/script&gt; &#13;
  &lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>We've made two changes to this file. The first is that we've added the <code class="literal">{{newName}}</code> expression after the arithmetic expression. This renders the <code class="literal">Bob</code> string to the screen. The second change is that we've added a text input control and added the <code class="literal">ng-model="newName"</code> directive. This directive binds the value in the text box to the <code class="literal">newName</code> property on the scope.</p><p>When the page loads, the value in the text box is <code class="literal">Bob</code>. But what happens if we type something besides <code class="literal">Bob</code> in the text box? The value rendered by the expression changes nearly instantly.</p><p>This is a clear example of what is meant by two-way data binding. Changes to the data in the view affect the model seamlessly.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, you learned how to build a full stack application from database to frontend using nothing but JavaScript-based tools. In the previous chapters we looked at the MEAN stack components. Now we've started to put them together.</p><p>You started by looking at Node.js, our JavaScript-based runtime environment. You used the Node.js REPL to execute JavaScript code on the command line. You then wrote a script, a small web server, which could be run by Node.js</p><p>You learned the two methods to set up an Express application. Additionally, you also used the express generator to build out a functioning framework to build an application. You learned about routing and middleware—the two key components of Express.</p><p>MongoDB is a NoSQL database that stores data as flexible documents in collections as opposed to the records/table model of relational databases. You ran each of the basic CRUD (Create, Read, Update, Delete) methods in Mongo with insert, find, update, and remove.</p><p>In the next chapter, we will dive deeply into MongoDB, gaining experience with the command-line interface.</p></div></body></html>