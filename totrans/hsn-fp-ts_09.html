<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Functional-Reactive Programming</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapters, we learned about the functional programming paradigm. We explored the main functional programming concepts, techniques, and patterns. In this chapter, we are going to learn about the functional-reactive programming paradigm, including the following topics:</p>
<ul>
<li>Reactive programming</li>
<li>Functional-reactive programming</li>
<li>Streams</li>
<li>Observables</li>
<li>The observer pattern</li>
<li>The iterator pattern</li>
<li>Operators</li>
</ul>
<p>We are going to learn what functional-reactive programming is and how it can help us to develop applications that are easier to extend and maintain.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reactive programming</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to learn what the main differences are between functional programming and reactive programming as well as what principal benefits of reactive programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional programming versus functional-reactive programming</h1>
                </header>
            
            <article>
                
<p>Functional programming and reactive programming should be considered as two different paradigms. Functional programming focuses on the interpretation of functions as mathematical functions—stateless and without side effects. On the other hand, reactive programming focuses on the propagation of changes as streams of events. The term <em>functional-reactive programming</em> is used to refer to a superset of reactive programming. Functional-reactive programming tries to take advantage of both the functional and reactive programming paradigms. For example, in functional-reactive programming, the event streams can be composed, we are encouraged to avoid external state mutations, and many of the functional programming principles are still relevant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The benefits of functional-reactive programming</h1>
                </header>
            
            <article>
                
<p>Functional-reactive programming is highly influenced by the functional programming principles and, as a result, many of the benefits of functional programming are also shared by functional-reactive programming. Functional-reactive applications are easier to reason about because they tend to avoid state mutations and side effects and promote a declarative style. They are particularly well suited for event-based architectures and concurrent systems. Functional-reactive programming is also considered by many developers a programming style that tends to be scalable because it follows the principle of composability.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with observables</h1>
                </header>
            
            <article>
                
<p>Reactive programming requires us to cha<span>n</span>ge the way that we think about events in an application. Reactive programming requires us to think about events as a stream of values. For example, a mouse click event can be represented as a stream of data. Every click event generates a new value in the data stream. In reactive programming, we can use the stream of data to query and manipulate the values in the stream.</p>
<p>We are going to use the <strong>Reactive Extensions Library for JavaScript</strong> (<strong>RxJS</strong>). RxJS provides us with an implementation of the observable pattern, as well as many operators and utilities that allow us to manipulate the observables. RxJS also includes helpers that allow us to create observables given different data types.</p>
<p>We can install RxJS using <kbd>npm</kbd>:</p>
<pre class="mce-root"><strong>npm install rxjs</strong></pre>
<p>The observable pattern is also known as the <strong>observable sequence pattern</strong>, which is the result of putting two other popular patterns together: the observer and the iterator patterns. In this section, we are going to learn more about these patterns so that we can have a better understanding of what observables are and how they work internally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The observer pattern</h1>
                </header>
            
            <article>
                
<p>In an implementation of the observer pattern, we can have many known listener entities that subscribe to messages. The following code snippet contains a very basic implementation of a listener in the observer pattern:</p>
<pre>class Listener&lt;T&gt; {<br/><br/>    public update: (message: T) =&gt; void;<br/><br/>    public constructor(fn: (message: T) =&gt; void) {<br/>        this.update = fn;<br/>    }<br/><br/>}</pre>
<p><span>A <kbd>Listener</kbd> has a method named <kbd>update</kbd>, which is invoked </span>when<span> a second entity </span>known as the <kbd>Producer</kbd> generates a new message. A <kbd>Producer</kbd> instance manages a number of <kbd>Listener</kbd> instances. A <kbd>message</kbd> can be generated with the <kbd>notify</kbd> method. The <kbd>message</kbd> is then passed to all the subscribed listeners. The following code snippet contains a very basic implementation of a producer in the observer pattern:</p>
<pre>class Producer&lt;T&gt; {<br/><br/>    private _listeners: Listener&lt;T&gt;[] = [];<br/><br/>    public add(listener: Listener&lt;T&gt;) {<br/>        this._listeners.push(listener);<br/>    }<br/><br/>    public remove(listener: Listener&lt;T&gt;) {<br/>        this._listeners = this._listeners.filter(<br/>            l =&gt; l !== listener<br/>        );<br/>    }<br/><br/>    public notify(message: T) {<br/>        this._listeners.forEach(<br/>            l =&gt; l.update(message)<br/>        );<br/>    }<br/><br/>}</pre>
<p>The following code snippet declares a couple of <kbd>Listener</kbd> instances and a <kbd>Producer</kbd> instance. It then subscribes both listeners to the <kbd><span>Producer</span></kbd> <span>messages </span>using the <kbd>add</kbd> method. Later, we use the <kbd>notify</kbd> method in <kbd>Producer</kbd> to send a message. The message will be received by all the subscribed listeners. In this case, both listeners will receive the message:</p>
<pre>const listerner1 = new Listener(<br/>    (msg: string) =&gt; console.log(`Listener 1: ${msg}`)<br/>);<br/><br/>const listerner2 = new Listener(<br/>    (msg: string) =&gt; console.log(`Listener 2: ${msg}`)<br/>);<br/><br/>const notify = new Producer&lt;string&gt;();<br/>notify.add(listerner1);<br/>notify.add(listerner2);<br/>notify.notify("Hello World!");</pre>
<p>Now that we have learned how to implement the observer pattern, we are going to focus on the second pattern used by the observable sequence pattern—the iterator pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The iterator pattern</h1>
                </header>
            
            <article>
                
<p>To understand how the observable sequence pattern works, w<span>e also need to understand the iterator pattern. The following code snippet uses a generator to create an iterator that iterates the multiples of a given number in an array. Only the elements in the array that are multiples of a given number are iterated:</span></p>
<pre>function* iterateOnMultiples(arr: number[], divisor: number) {<br/>    for (let item of arr) {<br/>        if (item % divisor === 0) {<br/>            yield item;<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">To get an instance of the iterator, we only need to invoke the function and pass an array and a number as its arguments. The function returns an iterator that will return the numbers in the array that are multiples of the given number: <kbd>3</kbd>. We can invoke the iterator's <kbd>next</kbd> method to get the next element. Each element has a property named <kbd>done</kbd> and a property named <kbd>value</kbd>. The <kbd>done</kbd> property can be used to check whether there are more items to be iterated. The <kbd>value</kbd> property can be used to access the value of the current item:</p>
<pre>const iterator1 = iterateOnMultiples([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3);<br/><br/>const iteratorResult1 = iterator1.next();<br/>console.log(iteratorResult1.value);<br/><br/>if (iteratorResult1.done === false) {<br/><br/>    const iteratorResult2 = iterator1.next();<br/>    console.log(iteratorResult2.value);<br/><br/>}</pre>
<p>We can also iterate all the items in an iterator using a <kbd>for...of</kbd> statement, as opposed to accessing the <kbd>done</kbd> property by hand:</p>
<pre>const iterator2 = iterateOnMultiples([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3);<br/><br/>for (let value of iterator2) {<br/>    console.log(value);<br/>}</pre>
<p>The observer and the iterator pattern can be very useful in many different scenarios. We can combine these two patterns in a pattern known as the <strong>observable sequence</strong>, or simply <strong>observable</strong>. An observable allows us to iterate and be notified about changes in a sequence. Now that we understand what is an observable is, we are going to learn how we can create instances of observables with RxJS.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating observables</h1>
                </header>
            
            <article>
                
<p><strong>Observables</strong> are streams of data, and this explains why it is easy to imagine that we can represent an event such as an <kbd>onClick</kbd> event using an observable. However, the use cases for observables are much more diverse than that. In this section, we are going to explore how to create an observable given different types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating observables from a value</h1>
                </header>
            
            <article>
                
<p>We can create an observable given a value using the <kbd>of</kbd> function. In the old versions of RxJS, the function <kbd>of</kbd> was a static method of the <kbd>Observable</kbd> class, which was available as <kbd>Observable.of</kbd>. This should remind us to use the <kbd>of</kbd> method of the <kbd>Applicative</kbd> type in category theory because <span>observables take some inspiration from category theory. However, in RxJS 6.0, the <kbd>of</kbd> method is available as a standalone factory function:</span></p>
<pre>import { of } from "rxjs";<br/><br/>const observable = of(1);<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value),<br/>    (error: any) =&gt; console.log(error),<br/>    () =&gt; console.log("Done!")<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p class="mce-root">The preceding code snippet declares an observable with one unique value using the <kbd>of</kbd> function. The code snippet also showcases how we can subscribe to an observable using the <kbd>subscribe</kbd> method. The <kbd>subscribe</kbd> method takes three function arguments:</p>
<ul>
<li><strong>Item handler</strong>: Invoked once for each item in the sequence.</li>
<li><strong>Error handler</strong>: Invoked if there is an error in the sequence. This argument is optional.</li>
<li><strong>Done handler</strong>: Invoked when there are no more items in the sequence. <span>This argument is optional.</span></li>
</ul>
<p class="mce-root">The following diagram is known as a <strong>marble diagram</strong>, and is used to represent observables in a visual manner. The arrow represents the time and the circles are values. In this case, we have only one value:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b39af7a3-e60b-4e05-a161-ca543aa8ffed.png" style="width:30.17em;height:3.08em;"/></p>
<p><span>As we can see, the circle also has a small vertical line in the middle. This line is used to represent the last element in an observable. In this case, the item handler in the subscription will only be invoked once.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating observables from arrays</h1>
                </header>
            
            <article>
                
<p>We can create an observable given an existing array using the <kbd>from</kbd> function:</p>
<pre>import { from } from "rxjs";<br/><br/>const observable = from([10, 20, 30]);<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value),<br/>    (error: any) =&gt; console.log(error),<br/>    () =&gt; console.log("Done!")<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet declares an observable with three values using the </span><kbd>from</kbd><span> function. The code snippet also showcases how we can subscribe once more.</span></p>
<p>The following marble diagram represents the preceding example in a visual manner. The generated observable has three values (<strong>10</strong>, <strong>20,</strong> and <strong>30</strong>) and <strong>30</strong> is the last element in the observable:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/2781af68-d51b-4689-997f-fe7f43b76e9a.png" style="width:36.00em;height:3.58em;"/></p>
<p class="mce-root">We can alternatively use the <kbd>interval</kbd> function to generate an array with a given number of elements:</p>
<pre>import { interval } from "rxjs";<br/><br/>const observable = interval(10);<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value),<br/>    (error: any) =&gt; console.log(error),<br/>    () =&gt; console.log("Done!")<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet declares an observable with ten values using the </span><kbd>interval</kbd><span> function. The code snippet also showcases how we can subscribe once more. In this case, the item handler in the subscription will be invoked ten times.</span></p>
<p>The following marble diagram represents the preceding example in a visual manner. The generating observable has ten values, and <kbd>9</kbd> is the last item contained by it:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/ff64f459-4563-45d0-977f-4d2d154e9e1e.png" style="width:34.42em;height:3.67em;"/></p>
<p><span> In this case, the item handler in the subscription will be invoked ten times.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating observables from events</h1>
                </header>
            
            <article>
                
<p>It is also possible to create an observable using an event as the source of the items in the stream. We can do this using the <kbd>fromEvent</kbd> function:</p>
<pre>import { fromEvent } from "rxjs";<br/><br/>const observable = fromEvent(document, "click");<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>In this case, the item handler in the subscription will be invoked as many times as the click event <kbd>takes</kbd> place.</span></p>
<div class="packt_infobox">Please note that the preceding example can only be executed in a web browser. To execute the preceding code in a web browser, you will need to use a module bundler, such as Webpack. We will not cover this topic, since it is beyond the scope of this book.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating observables from callbacks</h1>
                </header>
            
            <article>
                
<p>It is also possible to create an observable that will iterate the arguments of a callback using the <kbd>bindCallback</kbd> function:</p>
<pre>import { bindCallback } from "rxjs";<br/>import fetch from "node-fetch";<br/><br/>function getJSON(url: string, cb: (response: unknown|null) =&gt; void) {<br/>    fetch(url)<br/>        .then(response =&gt; response.json())<br/>        .then(json =&gt; cb(json))<br/>        .catch(_ =&gt; cb(null));<br/>}<br/><br/>const uri = "https://jsonplaceholder.typicode.com/todos/1";<br/>const observableFactory = bindCallback(getJSON);<br/>const observable = observableFactory(uri);<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p>The preceding example uses the <kbd>node-fetch</kbd> module because the fetch function is not available in Node.js. You can install the <kbd>node-fetch</kbd> module using the following <kbd>npm</kbd> command:</p>
<pre><strong>npm install node-fetch @types/node-fetch</strong></pre>
<p>The <kbd>getJSON</kbd> <span>function </span>takes a URL and a callback as its arguments. When we pass it to the <kbd>bindCallback</kbd> function, a new function is returned. The new function takes a URL as its only argument and returns an observable instead of taking a callback.</p>
<p>In Node.js, callbacks follow a well-defined pattern. The Node.js callbacks take two arguments, <kbd>error</kbd> and <kbd>result</kbd>, and don't throw exceptions. We must use the <kbd>error</kbd> argument to check whether something went wrong instead of a <kbd>try</kbd>/<kbd>catch</kbd> statement. RxJS also defines a function named <kbd>bindNodeCallback</kbd> that allows us to work with the callbacks:</p>
<pre>import { bindNodeCallback } from "rxjs";<br/>import * as fs from "fs";<br/><br/>const observableFactory = bindNodeCallback(fs.readFile);<br/>const observable = observableFactory("./roadNames.txt");<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value.toString())<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p>The helpers, <kbd>bindCallback</kbd> and <kbd>bindNodeCallback</kbd>, have very similar behavior, but the second has been specially designed to work with Node.js callbacks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating observables from promises</h1>
                </header>
            
            <article>
                
<p>Another potential source of items for an observable sequence is a <kbd>Promise</kbd>. RxJS also allows us to handle this use case with the <kbd>from</kbd> function. We must pass a <kbd>Promise</kbd> instance to the <kbd>from</kbd> function. In the following example, we use the <kbd>fetch</kbd> function to send an HTTP request. The <kbd>fetch</kbd> function returns a promise that is passed to the <kbd>from</kbd> function:</p>
<pre>import { bindCallback } from "rxjs";<br/>import fetch from "node-fetch";<br/><br/>const uri = "https://jsonplaceholder.typicode.com/todos/1";<br/>const observable = from(fetch(uri)).pipe(map(x =&gt; x.json()));<br/><br/>const subscription = observable.subscribe(<br/> (value) =&gt; console.log(value.toString())<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p>The generated observable will contain the result of the promise as its only item.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cold and hot observables</h1>
                </header>
            
            <article>
                
<p>The official RxJS documentation explores the differences between cold and hot observables as follows:</p>
<div class="packt_quote"><span>"Cold observables start running upon subscription, that is, the observable sequence only starts pushing values to the observers when Subscribe is called. Values are also not shared among subscribers. This is different from hot observables, such as mouse move events or stock tickers, which are already producing values even before a subscription is active. When an observer subscribes to a hot observable sequence, it will get all values in the stream that are emitted after it subscribes. The hot observable sequence is shared among all subscribers, and each subscriber is pushed the next value in the sequence."</span></div>
<p>It is important to understand these differences if we want to have control over the execution flow of our components. The key point to remember is that cold observables are lazily evaluated.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with operators</h1>
                </header>
            
            <article>
                
<p>In this section, we are going to learn how to use some functions known as operators, which allow us to manipulate observables in many different ways.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pipe</h1>
                </header>
            
            <article>
                
<p>In RxJS, observables have a method named <kbd>pipe</kbd>, which is very similar to the pipe operator in functional programming. When we pipe two functions, we generate a new function that <span>passes the return of the </span>first<span> function as arguments to the second function in the pipe.</span></p>
<p>The idea is very similar in reactive programming. When we pipe an observable through an operator, we generate a new observable. The new observable passes each of the items in the original observable to an operator that transforms them into the items in the new sequence.</p>
<p>We are not going to include a code example here, because we are going to use the pipe method multiple times during the remaining part of this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Max</h1>
                </header>
            
            <article>
                
<p>The <kbd>max</kbd> operator function can be used to find the biggest value in an observable. We must apply the <kbd>max</kbd> operator using the <kbd>pipe</kbd> method:</p>
<pre>import { from } from "rxjs";<br/>import { max } from "rxjs/operators";<br/><br/>const observable = from&lt;number&gt;([2, 30, 22, 5, 60, 1]);<br/><br/>observable.pipe(max());<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p>The following marble diagram showcases the initial sequence and the result sequence after applying the <kbd>max</kbd> operator:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b447b334-12c9-495b-abe7-c9a06397777d.png" style="width:25.50em;height:6.25em;"/></p>
<p>The result sequence contains only one value (the biggest value in the original sequence).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Every</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>every</kbd><span> operator function can be used to test whether all the values in an observable adhere to a given requirement:</span></p>
<pre>import { from } from "rxjs";<br/>import { every } from "rxjs/operators";<br/><br/>const observable = from&lt;number&gt;([1,2, 3, 4, 5]);<br/><br/>observable.pipe(every(x =&gt; x &lt; 10));<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p>The preceding code snippet uses the <kbd>every</kbd> operator to test that all the values in an observable are lower than ten. The following marble diagram showcases the initial sequence and the result sequence after applying the <kbd>every</kbd> operator:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/51541bb3-4fc4-4492-932c-7315ad70c4cc.png" style="width:33.17em;height:6.42em;"/></p>
<p><span>The result sequence contains only one value (true or false).</span></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Find</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>find</kbd><span> operator function can be used to find the first value in an observable that adheres to a given constraint:</span></p>
<pre>import { from } from "rxjs";<br/>import { find } from "rxjs/operators";<br/><br/>const observable = from&lt;number&gt;([2, 30, 22, 5, 60, 1]);<br/><br/>observable.pipe(find(x =&gt; x &gt; 10));<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet uses the </span><kbd>find</kbd><span> operator to find the first value in an observable greater than ten. The following marble diagram showcases the initial sequence and the result sequence after applying the </span><kbd>find</kbd><span> operator:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a60c397d-6adc-49f7-967d-28774443498a.png" style="width:29.42em;height:6.25em;"/></p>
<p><span>The result sequence contains only one value (the first value in the stream that matches the given constraint).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Filter</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>filter</kbd><span> operator function can be used to find the values in an observable that adhere to a given constraint:</span></p>
<pre>import { from } from "rxjs";<br/>import { filter } from "rxjs/operators";<br/><br/>const observable = from&lt;number&gt;([2, 30, 22, 5, 60, 1]);<br/><br/>observable.pipe(filter(x =&gt; x &gt; 10));<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet uses the </span><kbd>filter</kbd><span> operator to find the values in an observable greater than ten. The following marble diagram showcases the initial sequence and the result sequence after applying the </span><kbd>filter</kbd><span> operator:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/13821276-63f2-45b5-b68f-0699900f5a68.png" style="width:33.92em;height:6.83em;"/></p>
<p><span>The result sequence contains only some values (the values in the stream that match the given constraint).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Map</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>map</kbd><span> operator function can be used to transform the values in an observable into derived values:</span></p>
<pre>import { from } from "rxjs";<br/>import { map } from "rxjs/operators";<br/><br/>const observable = from&lt;number&gt;([1, 2, 3]);<br/><br/>observable.pipe(map(x =&gt; 10 * x));<br/><br/>const subscription = observable.subscribe(<br/> (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet uses the </span><kbd>map</kbd><span> operator to transform the values in an observable into new values (the original value multiplied by ten). The following marble diagram showcases the initial sequence and the result sequence after applying the </span><kbd>map</kbd><span> operator:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/e05cb0a1-68f9-40fb-a0d6-1f66366e5f33.png" style="width:32.00em;height:7.42em;"/></p>
<p><span>The result sequence contains a new mapped value for each value in the original sequence.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reduce</h1>
                </header>
            
            <article>
                
<p>The <kbd>reduce</kbd> operator function can be used to transform all the values in an observable into one single value:</p>
<pre>import { from } from "rxjs";<br/>import { reduce } from "rxjs/operators";<br/><br/>const observable = from&lt;number&gt;([1, 2, 3, 3, 4, 5]);<br/><br/>observable.pipe(reduce((x, y) =&gt; x + y));<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet uses the </span><kbd>reduce</kbd><span> operator to transform the values in an observable into a new single value (the total of all the values). The function that transforms multiple values into one single value is known as an accumulator. The following marble diagram showcases the initial sequence and the result sequence after applying the </span><kbd>reduce</kbd><span> operator:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a26f8f43-33ec-4f9b-9abd-5c554fe06553.png" style="width:35.42em;height:7.42em;"/></p>
<p><span>The result sequence contains only one value (the result of the accumulator).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Throttle</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>throttle</kbd><span> operator function can be used to reduce the number of values that are added to an observable:</span></p>
<pre>import { fromEvent, interval } from "rxjs";<br/>import { throttle, mapTo, scan } from "rxjs/operators";<br/><br/>const observable = fromEvent(document, "click")<br/>                    .pipe(mapTo(1))<br/>                    .pipe(throttle(x =&gt; interval(100)))<br/>                    .pipe(scan((acc, one) =&gt; acc + one, 0));<br/><br/>const subscription = observable.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet creates an observable for <kbd>click</kbd> events. Every click will add an item to the sequence. The example also uses the <kbd>pipe</kbd> method and the <kbd>mapTo</kbd> function to map all the click events to the numeric value <kbd>1</kbd>. It is then when we use</span> <span>the </span><kbd>throttle</kbd><span> operator to reduce the number of values that are added to the sequence. If two or more click events take place within a time interval lower than the one declared by the interval, only the first value will be added to the sequence.</span></p>
<div class="packt_infobox">Please note that the preceding example can only be executed in a web browser. To execute the preceding code in a web browser, you will need to use a module bundler such as Webpack. We will not cover this topic because it is beyond the scope of this book.</div>
<p><span>The following marble diagram showcases the initial sequence and the result sequence after applying the </span><kbd>reduce</kbd><span> operator:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/f5607f7c-ffa3-48c2-b189-534720121053.png" style="width:32.83em;height:6.92em;"/></p>
<p><span>The result sequence only contains some values because the values that take place too close in time are ignored.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Merge</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>merge</kbd><span> operator function can be used to merge the values of two observables into value pairs:</span></p>
<pre>import { from } from "rxjs";<br/>import { merge } from "rxjs/operators";<br/><br/>const observableA = from&lt;number&gt;([20, 40, 60, 80, 100]);<br/>const observableB = from&lt;number&gt;([1, 1]);<br/><br/>const observableC = observableA.pipe(merge&lt;number, number&gt;(observableB));<br/><br/>const subscription = observableC.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet uses the </span><kbd>merge</kbd><span> operator to combine the values of two observables into a new observable. The values are ordered chronologically. The following marble diagram showcases the initial sequences and the result sequence after applying the </span><kbd>merge</kbd><span> operator:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b02ed865-4487-49a5-bc24-3690f618cdc6.png" style="width:41.00em;height:8.08em;"/></p>
<p><span>The result sequence contains the values of both observables ordered in the same sequence as they took place in time.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Zip</h1>
                </header>
            
            <article>
                
<p><span>The </span><kbd>zip</kbd><span> operator function can be used to merge the values of two observables into value pairs:</span></p>
<pre>import { from } from "rxjs";<br/>import { zip } from "rxjs/operators";<br/><br/>const observableA = from&lt;number&gt;([1, 2, 3, 3, 4, 5]);<br/>const observableB = from&lt;string&gt;(["A", "B", "C", "D"]);<br/><br/>const observableC = observableA.pipe(zip&lt;number, string&gt;(observableB));<br/><br/>const subscription = observableC.subscribe(<br/>    (value) =&gt; console.log(value)<br/>);<br/><br/>subscription.unsubscribe();</pre>
<p><span>The preceding code snippet uses the </span><kbd>zip</kbd><span> operator to combine the values of two observables into a new observable. The values in the new observable are value pairs that contain a value from the first observable and a value from the second observable and are grouped by their index in the sequence. The following marble diagram showcases the initial sequences and the result sequence after applying the </span><kbd>zip</kbd><span> operator:</span></p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/a7e246ce-1a59-46d5-9e6e-d0eb1f2a58a4.png" style="width:43.50em;height:9.33em;"/></p>
<p><span>The result sequence contains the values of both observables merged into single value pairs.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we have learned about the functional-reactive programming paradigm. We have learned that many of the functional programming ideas, such as pure functions and function composition, can be applied to reactive programming. We also learned what observables are and how we can create them and work with them.</p>
<p class="mce-root">In the next chapter, we are going to learn about some production-ready functional programming libraries, such as Ramda and Immutable.js.</p>


            </article>

            
        </section>
    </body></html>