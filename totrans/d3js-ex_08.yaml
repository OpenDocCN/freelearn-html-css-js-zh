- en: Chapter 8. Adding User Interactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Great visualizations provide more than a pretty picture and animations; they
    allow the user to interact with the data, giving them the ability to play with
    the data to discover the meaning in the data that may not be obvious through a
    given static presentation.
  prefs: []
  type: TYPE_NORMAL
- en: Exceptional interactions allow the users to steer their way through large amounts
    of information. It allows them to pan through data too large for a single display,
    to dive into summary information, and also zoom out to get a higher level view—in
    essence, it allows users to see the forest from the trees.
  prefs: []
  type: TYPE_NORMAL
- en: Also of great value is the capability to allow the user to easily select, reorder,
    and reposition visual elements. Through these actions, the user is able to see
    details of a datum simply by mouseover or touch, to rearrange items for exposing
    other insights, and to also see how data moves around when reordered. This provides
    the user a sense of constancy and shows how the data changes when asked to reshuffle
    on demand.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will examine a number of techniques for adding interactivity
    to your D3.js visualizations. We will examine concepts involved in using the mouse
    to highlight information and provide contextual information, to pan and zoom your
    visualizations, and to use brushing to select and zoom the view of information
    in and out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooking into mouse events on D3.js visuals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking and responding to mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building several models of visual animation to provide feedback on interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling mouse hovers to provide detailed information on specific visuals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating fluid animations that respond to mouse events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brushing and its use in selecting data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a context-focus pattern of interaction for viewing stock data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling mouse events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mouse is the most common device available to users for interacting with
    D3.js visualizations. Touch is commonly used in case of tablets, and in many cases,
    touch events can be mapped to mouse events. In this chapter, we will focus exclusively
    on the mouse. But most of everything we cover also applies to touch. Touch concepts
    such as pinching can also be easily supported on touch devices with D3.js.
  prefs: []
  type: TYPE_NORMAL
- en: To work with mouse events in D3.js, we attach event listeners to the SVG elements
    for which we desire to handle the events. The handlers are added using the `.on()`
    function, which takes as parameters the name of the event and a function to call
    when the mouse event happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will examine the handling of four mouse events: `mousemove`, `mouseenter`,
    `mouseout`, and `click`.'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the mouse position using mousemove
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The movement of the mouse on an SVG visual is reported to your code by listening
    for the `mousemove` event. This following example demonstrates tracking and reporting
    the mouse position:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (8.1): [http://goo.gl/VK67C4](http://goo.gl/VK67C4)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We listen to `mousemove` events using `.on()`, passing it when the event fires,
    and the example updates the content of the text in the SVG text element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracking the mouse position using mousemove](img/B04230_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The position of the mouse is not passed to the function as parameters. To get
    the actual mouse position, we need to call the `d3.mouse()` function, passing
    it to the return value of `svg.node()`. This function then calculates the *X*
    and *Y* mouse position relative to the SVG element for which the mouse is moving
    over.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing the mouse entering and exiting an SVG element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mouse entering and exiting a particular SVG element is captured using the
    respective `mouseenter` and `mouseout` events. The following example shows this
    by creating several circles and then changing their color while the mouse is within
    the area of the circle (also known as **hovering**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (8.2): [http://goo.gl/4cfrdq](http://goo.gl/4cfrdq)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code creates three circles of varying size (`30`, `20`, and `40` pixel
    radius):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Tracking the enter and exit of the mouse is performed by hooking into those
    two events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this example, you will be presented by three `steelblue` circles
    of slightly varying size, and when you hover the mouse over any of them you will
    see it change to `red`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Capturing the mouse entering and exiting an SVG element](img/B04230_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the SVG element which the mouse is currently entering or exiting is
    not passed to the functions, so we need to retrieve them using `d3.select(this)`.
  prefs: []
  type: TYPE_NORMAL
- en: Letting the user know they have clicked the mouse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the user clicks a button on the mouse, the mouse can track the mouse being
    clicked by using the `mouseclick` event. The code at the following link demonstrates
    handling the click event handler:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (8.3): [http://goo.gl/91rt4S](http://goo.gl/91rt4S)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This code adds an event handler to the code in example *8.2* to capture the
    click event and pop up an alert box that shows the value of the datum and its
    position in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Letting the user know they have clicked the mouse](img/B04230_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is pretty neat as you are given the data underlying the visual that you
    clicked. There is no need to retain a map of the visuals to the data to just look
    this up.
  prefs: []
  type: TYPE_NORMAL
- en: Using behaviors to drag, pan, and zoom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mouse events often need to be combined to create more complex interactions such
    as drag, pan, and zoom. Normally, this requires a good quantity of code to track
    sequences of the `mouseenter`, `mousemove`, and `mouseexit` events.
  prefs: []
  type: TYPE_NORMAL
- en: D3.js provides us with a better way of implementing these interactions through
    the use of **behaviors**. These behaviors are a complex set of DOM/SVG interactions
    through D3.js itself handling the mouse events. In a sense, behaviors function
    similarly to gesture recognizers on mobile platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'D3.js currently provides two built-in behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Drag**: This tracks mouse or multi-touch movements relative to an origin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zoom**: This emits zoom and pan events in response to dragging or pinching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's examine an example of implementing drag and another that also adds pan
    and zoom capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Drag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Drag is a common behavior in interactive visualization that allows the movement
    of visual elements by the user via the mouse or touch. The following example demonstrates
    using the drag behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (8.4): [http://goo.gl/wxn6iN](http://goo.gl/wxn6iN)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example renders four circles and lets you move them around the
    SVG area using the mouse, but also constrains the movement so that the circles
    remain completely within the SVG element''s visual area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Drag](img/B04230_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code begins by calculating the positions for the circles and rendering
    them using a selection. The drag behavior is then implemented with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The behavior is created using `d3.behavior.drag()`. This object then requires
    us to tell it that we are interested in listening to `drag` events. You can also
    specify handlers for `dragstart` and `dragged` events to identify the start and
    completion of a drag behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to inform D3.js to hook up the behavior to SVG elements. This
    is done by using the `.call()` function on the selection. As we saw when rendering
    axes, the function we specified will be called by D3.js during the rendering of
    each selected item. In this case, this will be our drag behavior, and hence, the
    implementation of this function can perform all the event processing needed for
    dragging an SVG element on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Our event handler for the drag behavior is then called whenever the user drags
    an associated SVG element. This function first retrieves the new `x` and `y` position
    for the item being dragged from the `d3.event` object. These values are computed
    and set by D3.js prior to this function being called.
  prefs: []
  type: TYPE_NORMAL
- en: All that is required at this point is to set a new transform for the respective
    SVG element to move it into the new position. This example also checks that the
    circle is still completely within the SVG element and only sets the new position
    if that is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Pan and zoom
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Panning and zooming are two common techniques in data visualization. Panning
    allows the user to drag the entire visual around the screen. This exposes visuals
    that would otherwise be rendered outside of the bounds of the visual area. A common
    scenario for panning is to move a map around to expose areas previously out of
    view.
  prefs: []
  type: TYPE_NORMAL
- en: Zooming allows you to scale up or down the perceived distance of the user from
    the visual. This can be used to make small items bigger or to zoom out to see
    items that were too big or out of the extent of the visual display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both panning and zooming are implemented by the same D3.js behavior, `d3.behavior.zoom()`.
    The following example demonstrates its use:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (8.5): [http://goo.gl/tEY0hm](http://goo.gl/tEY0hm)'
  prefs: []
  type: TYPE_NORMAL
- en: 'When running this example, you can not only drag the circles, but you can drag
    the background to move all the circles at once (the pan) and use your mouse wheel
    to zoom in and out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Pan and zoom](img/B04230_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are a few small changes to the previous example for adding these additional
    features. These start with the declaration of the zoom behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The initial zoom level is `1.0`. The call `to .scaleExtent()` informs the behavior
    that it should zoom down to `0.1`, one-tenth of the original size, and up to `10`,
    or 10x of the original. Moreover, the behavior should call the `onZoom()` function
    when zoom events occur .
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we create the main SVG element and attach the zoom behavior to it using
    `.call()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code also appends a group element to the SVG element and the `svg` variable
    then refers to this group. The pan and zoom events are routed by the top level
    SVG element to our handler, which then sets the translate and scale factor on
    this group, therefore creating the effects on the circles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we just need to implement the `zoomIt` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Just before the behavior calls this function, it sets the `d3.event.translate`
    variable to represent the extent of translation that should occur on the entire
    visual.
  prefs: []
  type: TYPE_NORMAL
- en: The `d3.event.scale` variable is also set by D3.js to represent the appropriate
    level of zoom. In this example, this ranges from 0.1 to 10.
  prefs: []
  type: TYPE_NORMAL
- en: Another small change is in the way the drag behavior is declared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is done because there will be an issue with the example if this is not
    modified in the preceding manner. If left as-is, the pan and zoom behavior and
    the drag behavior will conflict with each other. When dragging a circle, the `svg`
    element will also pan when it should stay in place.
  prefs: []
  type: TYPE_NORMAL
- en: By handling the `dragstart` event and calling `d3.event.sourceEvent.stopPropagation()`,
    we prevent this mouse event on a circle from **bubbling up** to the `svg` element
    and starting a pan. Problem solved!
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing a bar graph with interactivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's apply what we have learned about mouse event handling to create an
    interactive bar graph. Mouse events on a bar chart can provide useful contextual
    information to the person interacting with the graph.
  prefs: []
  type: TYPE_NORMAL
- en: The data for the examples will use a stripped-down version of the life expectancy
    vs fertility dataset that was used in earlier chapters. This dataset will use
    the data for the Latin American and Caribbean economic regions only, which contain
    roughly 35 countries, for the year 2013.
  prefs: []
  type: TYPE_NORMAL
- en: The bars in the examples will represent the longevity, will be annotated at
    the top with the country code, and have vertically oriented text representing
    the actual longevity value and the full country name. The examples will omit axes
    and margins to keep things simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code and live example for this example is available at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (8.6): [http://goo.gl/8jb9Rn](http://goo.gl/8jb9Rn)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This interaction pattern can be used to visually accentuate a particular bar
    in a bar chart when the mouse is moved over it. We have seen this when using `mouseenter`
    and `mouseout` events earlier as applied to circles. Here, we will use it to highlight
    the bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Enhancing a bar graph with interactivity](img/B04230_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The rectangles representing the bars are created with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'After the creation of the bars, the code hooks up the `mouseover` and `mouseout`
    events. The `mouseover` event makes the vertical text completely opaque and sets
    the bar color to orange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mouseout` event animates and sets the text opacity back to the original
    value and starts an animation to set the color back to its original shade. This
    animation gives the appearance of mouse trails when moving across the bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The last portion of the selection creating the bars performs an animation to
    make the bars grow and transition from black to their eventual colors which the
    graph loads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To also enhance the presentation of the underlying information, we will place
    two pieces of data on each bar: the country code as horizontal text at the top
    and a piece of vertical text which shows the actual value of the datum and the
    full name of the country. The following code creates the horizontal text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The vertical text is created by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Highlighting selected items using brushes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **brush** in D3.js provides the ability for the user to interact with your
    visualization by allowing the selection of one or more visual elements (and the
    underlying data items) using the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: This is a very important concept in exploratory data analysis and visualization,
    as it allows users to easily drill in and out of data or select specific data
    items for further analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Brushing in D3.js is very flexible, and how you implement it depends upon the
    type of visualization you are presenting to the user. We will look at several
    examples or brushes and then implement a real example that lets us use a brush
    to examine stock data.
  prefs: []
  type: TYPE_NORMAL
- en: Online examples of brushes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand brushes, let's first take a look at several brush examples on
    the Internet. These are all examples available on the web that you can go and
    play with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following brush shows the use of rectangular selection for selecting data
    that is within the brush ([http://bl.ocks.org/mbostock/4343214](http://bl.ocks.org/mbostock/4343214)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Online examples of brushes](img/B04230_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Another example of this brushing is the scatterplot matrix brush at [http://bl.ocks.org/mbostock/4063663](http://bl.ocks.org/mbostock/4063663).
    This example is notable for the way in which you can select points on any one
    of the scatter plots. The app then selects the points on all the other plots so
    that the data is highlighted on those too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Online examples of brushes](img/B04230_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following example demonstrates using a brush to select a point within a
    force-directed network visualization ([http://bl.ocks.org/mbostock/4565798](http://bl.ocks.org/mbostock/4565798)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Online examples of brushes](img/B04230_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will learn about force-directed network visualizations in greater detail
    in [Chapter 11](ch11.html "Chapter 11. Visualizing Information Networks"), *Visualizing
    Information Networks*.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of custom brush handles is a common scenario you will see when
    using brushes. Handles provide you a means of providing a custom rendering of
    the edges of the brush to provide a visual cue to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of a custom brush, the following creates semicircles as the handles:
    [http://bl.ocks.org/mbostock/4349545](http://bl.ocks.org/mbostock/4349545).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can resize the brush by dragging either handle and reposition it by dragging
    the area between the handles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Online examples of brushes](img/B04230_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The last example of a brush (before we create our own) is the following, which
    demonstrates a concept referred to as `focus + context`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Online examples of brushes](img/B04230_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the brush is drawn atop the smaller graph (the context). The
    context graph is static in nature, showing a summary of the entire range of data.
    As the brush is changed upon the context, the larger graph (the focus) animates
    in real-time while the brush is changed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will examine creating a similar version of this graph
    which utilizes financial data, a common domain for this type of interactive visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing focus + context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s examine how to implement **focus + context**. The following example
    that we will use will apply this concept to a series of stock data:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (8.7): [http://goo.gl/Niyc56](http://goo.gl/Niyc56)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting graph will look like the following graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing focus + context](img/B04230_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The top graph is the focus of the chart and represents the detail of the stock
    data that we are examining. The bottom graph is the context and is always a plot
    of the full series of data. In this example, we focus on data from just before
    the start of 2010 until just after the start of 2012.
  prefs: []
  type: TYPE_NORMAL
- en: The context area supports brushing. You can create a new brush by clicking on
    the context graph and dragging the mouse to select the extents of the brush. The
    brush can then be slid back and forth by dragging it, and it can be resized on
    the left and right by dragging either boundary. The focus area will always display
    the details of the area selected by the context.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this visualization, we will be drawing two different graphs, and
    hence, we need to layout the vertical areas for each and create the main SVG element
    with a size enough to hold both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This example will also require the creation of a clipping area. As the line
    drawn in the focus area scales, it may be drawn overlapping on the left with the
    *y* axis. The clipping area prevents the line from flowing off to the left over
    the axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This clipping rectangle is referred to in the styling for the lines. When the
    lines are drawn, they will be clipped to this boundary. We will see how this is
    specified when examining the function to style the lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we add two groups that will hold the renderings for both the focus and
    context graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This visual requires one *y* axis, two *x* axes, and the appropriate scales
    for each. These are created with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be drawing two lines, so we create the two line generators, one for
    each of the lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing we need to do before loading the data and actually rendering
    it is to create our brush using `d3.svg.brush()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This preceding snippet informs the brush that we want to brush along the `x`
    values using the scale defined in `xScaleBottom`. Brushes are event-driven and
    will handle the `brush` event, which is raised every time the brush is moved or
    resized.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, the last major thing the code does is load the data and establish
    the initial visuals. You''ve seen this code before, so we won''t explain it step
    by step. In short, it consists of loading the data, setting the domains on the
    scales, and adding and drawing the axes and lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations! You have stepped through creating a fairly complicated interactive
    display of stock data. But the beauty is that through the underlying capabilities
    of D3.js, it was comprised of a relatively small set of simple steps that result
    in **Beautiful Data**.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to use mouse events provided by D3.js to create
    interactive visualization. We started by explaining how to hook up mouse events
    and respond to them, changing the visualization as the events occurred. Then we
    examined behaviors and how we can use them to implement drag, pan, and zoom, which
    allow the user to move around data, take a closer look, as well as zoom in and
    out. Finally, we covered brushing and how it can be used to select multiple visuals/data
    items, ending with a slick example of applying **focus + context** to visualize
    financial data.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter on layouts, we will move a little higher up the visual stack
    of D3.js to examine layouts, which are essentially generators for complex data
    visualizations.
  prefs: []
  type: TYPE_NORMAL
