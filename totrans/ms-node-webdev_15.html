<html><head></head><body>
<div><h1 class="chapternumber">14</h1>
<h1 class="chaptertitle" id="_idParaDest-240">Creating RESTful Web Services</h1>
<p class="normal1">This chapter explains how Node.js can be used to create web services that provide access to data over HTTP requests, which is<a id="_idIndexMarker667" class="calibre3"/> a key enabler for <strong class="screentext">single-page applications</strong> (<strong class="screentext">SPAs</strong>). The chapter begins with a basic web service and then incorporates more complex features, such as partial updates and data validation. <em class="italic">Table 14.1</em> puts this chapter in context.</p>
<p class="packt_figref">Table 14.1: Putting RESTful web services in context</p>
<table class="table-container" id="table001-11">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Question</p>
</td>
<td class="table-cell">
<p class="normal">Answer</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">What are they?</p>
</td>
<td class="table-cell">
<p class="normal">RESTful web services<a id="_idIndexMarker668" class="calibre3"/> provide access to data over HTTP requests. Instead of sending data embedded in HTML content, the server responds with “raw” data, usually in JSON format.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Why are they useful?</p>
</td>
<td class="table-cell">
<p class="normal">Web services allow clients to perform data operations, such as querying or updating data, using HTTP requests. This is most often used by JavaScript code executing in the browser, although any type of client can consume a web service.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">How are they used?</p>
</td>
<td class="table-cell">
<p class="normal">The HTTP request method/verb is used to denote an operation and the request URL identifies the data on which the operations should be performed.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any pitfalls or limitations?</p>
</td>
<td class="table-cell">
<p class="normal">There is no standard way to create a web service, which leads to significant variations in how they are designed. </p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Are there any alternatives?</p>
</td>
<td class="table-cell">
<p class="normal">Most modern web applications require some form of web service to deliver data to client-side JavaScript applications. That said, web services are not required for applications that are purely round-trip and that do not need to support clients.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal"><em class="italic">Table 14.2</em> summarizes the chapter.</p>
<p class="packt_figref">Table 14.2: Chapter summary</p>
<table class="table-container" id="table002-11">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Problem</p>
</td>
<td class="table-cell">
<p class="normal">Solution</p>
</td>
<td class="table-cell">
<p class="normal">Listing</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Define a web service</p>
</td>
<td class="table-cell">
<p class="normal">Use the <a id="_idIndexMarker669" class="calibre3"/>standard request handlers and return JSON data instead of HTML.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">9-15</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Consolidate the code required to create a web service</p>
</td>
<td class="table-cell">
<p class="normal">Separate the code that handles HTTP requests so that the data-handling code can be isolated.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">16-18, 43-45</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Update data with a web service</p>
</td>
<td class="table-cell">
<p class="normal">Handle <code class="inlinecode">PUT</code> and <code class="inlinecode">PATCH</code> requests.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">19-26</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Describe complex data changes</p>
</td>
<td class="table-cell">
<p class="normal">Use the JSON Patch specification.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">27-30</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Validate the data values received by the web service</p>
</td>
<td class="table-cell">
<p class="normal">Perform validation before passing the data to the code that processes data.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">31-37</em></p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Validate the combinations of data received by the web service</p>
</td>
<td class="table-cell">
<p class="normal">Perform model validation.</p>
</td>
<td class="table-cell">
<p class="normal"><em class="italic1">38-41</em></p>
</td>
</tr>
</tbody>
</table>
<h1 class="heading" id="_idParaDest-241">Preparing for this chapter</h1>
<p class="normal1">This chapter uses the <code class="inlinecode">part2app</code> project from <em class="italic">Chapter 13</em>. The examples in this chapter are easier to understand with a simple command-line client application that sends HTTP requests and displays the responses that are received. To prepare, run the commands shown in <em class="italic">Listing 14.1</em> in the <code class="inlinecode">part2app</code> folder to install the <code class="inlinecode">Inquirer</code> package (<a href="https://github.com/SBoudrias/Inquirer.js" class="calibre3">https://github.com/SBoudrias/Inquirer.js</a>), which provides features for prompting the user.</p>
<div><p class="normal"><strong class="screentext">Tip</strong> </p>
<p class="normal">You can download the example project for this chapter – and for all other chapters in this book – from <a href="https://github.com/PacktPublishing/Mastering-Node.js-Web-Development" class="calibre3">https://github.com/PacktPublishing/Mastering-Node.js-Web-Development</a>. See <em class="italic">Chapter 1</em> for how to get help if you have problems running the examples.</p>
</div>
<p class="packt_figref">Listing 14.1: Installing a package</p>
<pre class="programlisting1"><code class="hljs-con">npm install @inquirer/prompts@3.3.0
</code></pre>
<p class="normal">Create the <code class="inlinecode">src/cmdline</code> folder and add to it a file named <code class="inlinecode">main.mjs</code>, with the contents shown in <em class="italic">Listing 14.2</em>. The .<code class="inlinecode">mjs</code> file extension tells Node.js to treat this file as a JavaScript module and allow the use of the <code class="inlinecode">import</code> statement.</p>
<p class="packt_figref">Listing 14.2: The contents of the main.mjs file in the src/cmdline folder</p>
<pre class="programlisting"><code class="hljs-code">import { select } from "@inquirer/prompts";
import { ops } from "./operations.mjs";
(async function run() {
    let loop = true;
    while (loop) {
        const selection = await select({
            message: "Select an operation",
            choices: [...Object.keys(ops).map(k =&gt; {return { value: k }})]
        });
        await ops[selection]();
    }
})();
</code></pre>
<p class="normal">This code uses the <code class="inlinecode">Inquirer</code> package to prompt the user to choose an operation to perform. The choices presented to the user are obtained from the properties of an object, and making a choice executes the function assigned to that property. Add a file named <code class="inlinecode">operations.mjs</code> to the <code class="inlinecode">src/cmdline</code> folder with the contents shown in <em class="italic">Listing 14.3</em>.</p>
<p class="packt_figref">Listing 14.3: The contents of the operations.mjs file in the src/cmdline folder</p>
<pre class="programlisting"><code class="hljs-code">export const ops = {
    "Test": () =&gt; {
        console.log("Test operation selected");
    },
    "Exit": () =&gt; process.exit()
}
</code></pre>
<p class="normal">This file provides the operations that the user can select, with a <code class="inlinecode">Test</code> operation to get started and make sure everything works as it should, and an <code class="inlinecode">Exit</code> option that uses the Node.js <code class="inlinecode">process.exit</code> method to terminate the process. <em class="italic">Listing 14.4</em> adds an entry to the scripts section of the <code class="inlinecode">package.json</code> file to run the command-line client.</p>
<p class="packt_figref">Listing 14.4: Adding a script in the package.json file in the part2app folder</p>
<pre class="programlisting"><code class="hljs-code">...
"scripts": {
    "server": "tsc-watch --noClear --onsuccess \"node dist/server/server.js\"",
    "client": "webpack serve",
    "start": "npm-run-all --parallel server client",
    <strong class="screentext">"cmdline": "node --watch ./src/cmdline/main.mjs"</strong>
},
...
</code></pre>
<p class="normal">The new entry will execute the <code class="inlinecode">main.mjs</code> file using Node.js. The <code class="inlinecode">--watch</code> argument puts Node.js into watch mode, where it will restart if changes are detected.</p>
<h2 class="heading1" id="_idParaDest-242">Preparing for a web service</h2>
<p class="normal1">To prepare for the<a id="_idIndexMarker670" class="calibre3"/> introduction of a web service, create the <code class="inlinecode">src/server/api</code> folder and add to it a file named <code class="inlinecode">index.ts</code> with the content shown in <em class="italic">Listing 14.5</em>.</p>
<p class="packt_figref">Listing 14.5: The contents of the index.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
export const createApi = (app: Express) =&gt; {
    // TODO - implement API
}
</code></pre>
<p class="normal">This file is just a placeholder for now but will be used to configure Express to handle HTTP API requests. The final change is to call the function defined in <em class="italic">Listing 14.5</em> to set up the web service, as shown in <em class="italic">Listing 14.6</em>.</p>
<p class="packt_figref">Listing 14.6: Configuring Express in the server.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">import { createServer } from "http";
import express, {Express } from "express";
import httpProxy from "http-proxy";
import helmet from "helmet";
import { engine } from "express-handlebars";
import { registerFormMiddleware, registerFormRoutes } from "./forms";
<strong class="screentext">import { createApi } from "./api"</strong><strong class="screentext">;</strong>
const port = 5000;
const expressApp: Express = express();
const proxy = httpProxy.createProxyServer({
    target: "http://localhost:5100", ws: true
});
expressApp.set("views", "templates/server");
expressApp.engine("handlebars", engine());
expressApp.set("view engine", "handlebars");
expressApp.use(helmet());
expressApp.use(express.json());
registerFormMiddleware(expressApp);
registerFormRoutes(expressApp);
<strong class="screentext">createApi(expressApp);</strong>
expressApp.use("^/$", (req, resp) =&gt; resp.redirect("/form"));
expressApp.use(express.static("static"));
expressApp.use(express.static("node_modules/bootstrap/dist"));
expressApp.use((req, resp) =&gt; proxy.web(req, resp));
const server = createServer(expressApp);
server.on('upgrade', (req, socket, head) =&gt; proxy.ws(req, socket, head));
server.listen(port,
    () =&gt; console.log(`HTTP Server listening on port ${port}`));
</code></pre>
<p class="normal">Run the<a id="_idIndexMarker671" class="calibre3"/> command shown in <em class="italic">Listing 14.7</em> in the <code class="inlinecode">part2app</code> folder to start the development tools.</p>
<p class="packt_figref">Listing 14.7: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm start
</code></pre>
<p class="normal">Open a second command prompt, navigate to the <code class="inlinecode">part2app</code> folder, and run the command shown in <em class="italic">Listing 14.8</em> to start the command-line client.</p>
<p class="packt_figref">Listing 14.8: Starting the command-line client</p>
<pre class="programlisting1"><code class="hljs-con">npm run cmdline
</code></pre>
<p class="normal">The features provided by the <code class="inlinecode">Inquirer</code> package present a single choice, like this:</p>
<pre class="programlisting1"><code class="hljs-con">? Select an operation (Use arrow keys)
&gt; Test
Exit
</code></pre>
<p class="normal">Use the arrow keys to move up and down the list of choices. Selecting the <code class="inlinecode">Test</code> operation displays a test message, and selecting <code class="inlinecode">Exit</code> terminates the process. Node.js is running in watch mode, which means that it will start the command-line <a id="_idIndexMarker672" class="calibre3"/>client again if a change is detected. Press <em class="italic">Ctrl + C</em> if you want to stop the client entirely.</p>
<h1 class="heading" id="_idParaDest-243">Understanding web services</h1>
<p class="normal1">There is no definitive <a id="_idIndexMarker673" class="calibre3"/>agreement about what a web service is, no single standard to follow, and no set of widely adopted patterns. The opposite is true: there is an endless multitude of opinions, countless patterns, and an endless internet shouting match over the “correct” way to deliver data to clients. </p>
<p class="normal">The chaos and noise surrounding web services can be overwhelming, and it can be difficult to know where to start. However, the lack of standardization can be liberating because it means that a project can focus on delivering just the functionality that clients require, without any of the boilerplate or overheads that standardization can sometimes bring. </p>
<p class="normal">Web services are just data access APIs that are accessed over HTTP. A RESTful web service is just a web service that uses aspects of the HTTP requests to determine which parts of the API a client wants to use. The term <em class="italic">RESTful</em> comes from <a id="_idIndexMarker674" class="calibre3"/>the<strong class="screentext"> representational state transfer</strong> (<strong class="screentext">REST</strong>) pattern, but there has been so much variation and adaptation in web services that only the core premise of REST is widely used, which is that an API is defined using a combination of HTTP methods and URLs. The HTTP method, such as GET or POST, defines the type of operation that will be<a id="_idIndexMarker675" class="calibre3"/> performed, while the URL specifies the data object or objects to which the operation will be applied.</p>
<p class="normal">Projects are free to create <a id="_idIndexMarker676" class="calibre3"/>web service APIs in any way, but the best web services are the ones that are simple and easy to use. As an example, here is a URL that might identify data managed by the application:</p>
<pre class="programlisting1"><code class="hljs-con">/api/results/1
</code></pre>
<p class="normal">There are no restrictions on how the URL is used to identify data, as long as the client and the server both understand the URL format so that data can be unambiguously identified. If an application stores data in a database, then a URL typically identifies a specific value using a primary key, but that is just a common convention and not a requirement.</p>
<p class="normal">The URL identifies the data, but it is the HTTP request method that specifies what should be done with that data. <em class="italic">Table 14.3</em> describes the HTTP methods that are commonly used in web services and the operations they conventionally<a id="_idIndexMarker677" class="calibre3"/> represent. </p>
<p class="packt_figref">Table 14.3: Commonly used HTTP methods </p>
<table class="table-container" id="table003-11">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Method</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">GET</code></p>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker678" class="calibre3"/>method is used to retrieve one or more data values</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">POST</code></p>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker679" class="calibre3"/>method is used to store a new data value</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">PUT</code></p>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker680" class="calibre3"/>method is used to replace an existing data value</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">PATCH</code></p>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker681" class="calibre3"/>method is used to update part of an existing data value</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<p class="normal"><code class="inlinecode3">DELETE</code></p>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker682" class="calibre3"/>method is used to delete a data value</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">A<a id="_idIndexMarker683" class="calibre3"/> web service presents an API by combining URLs and methods and will typically return JSON data. For operations that don’t query for data, an indication of the outcome is returned and that can also be JSON data. A basic web service might provide the combinations described in <em class="italic">Table 14.4</em>, which also describes the results the web service will produce.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Early web services used XML rather than JSON. JSON became the de facto standard because it is simple and easily parsed by JavaScript clients, but you will still see the occasional reference to XML, such as the <code class="inlinecode">XMLHttpRequest</code> objects, that browsers provide for sending HTTP requests (although these have been superseded by the more modern Fetch API). </p>
</div>
<p class="packt_figref">Table 14.4: A typical web service</p>
<table class="table-container" id="table004-7">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Method</p>
</td>
<td class="table-cell">
<p class="normal">URL</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">GET</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">/api/results/1</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This combination gets the single value with ID <code class="inlinecode">1</code>, expressed as a JSON representation of a <code class="inlinecode">Result</code> object. If there is no such ID, a 404 response will be returned.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">GET</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">/api/results</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This combination gets all available data values, expressed as a JSON representation of an array of <code class="inlinecode">Result</code> objects. If there is no data, an empty array will be returned.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">GET</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">/api/results?name=Alice</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This combination finds all values with a <code class="inlinecode">name</code> value of <code class="inlinecode">Alice</code> and returns a JSON representation of an array of <code class="inlinecode">Result</code> objects. An empty array will be returned if there is no matching data.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">POST</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">/api/results</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This combination stores a value and returns a JSON representation of the stored data.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">DELETE</code>
</code></pre>
</td>
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">/api/results/1</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This combination deletes the single value with ID <code class="inlinecode">1</code> and returns a JSON object with a <code class="inlinecode">success</code> property with a <code class="inlinecode">boolean</code> value that indicates the outcome.</p>
</td>
</tr>
</tbody>
</table>
<div><p class="normal"><strong class="screentext">Understanding microservice</strong>s</p>
<p class="normal">Any research on web services will quickly take you into the world of microservices, which is why I suggested it as a search term in the previous section. Microservices are a way to design applications around business capabilities and that often involves web services. A good overview of microservices can be found at <a href="https://microservices.io" class="calibre3">https://microservices.io</a>, along with details design patterns. </p>
<p class="normal">My view of microservices is that they are interesting but should be avoided for most projects. The core problem that microservices address is a dysfunctional development organization that cannot be managed to provide coordinated software releases. This is a problem that many projects face, given that any group of three or more developers immediately splits into factions that compete for resources, argue over design issues, and blame each other for delays.</p>
</div>
<div><p class="normal">Microservices attempt to resolve these problems by having development teams work largely in isolation and agreeing only on how different parts of the project will be integrated. There are some excellent tools designed to support microservices, the most well-known one being Kubernetes, but the tools are incredibly complex, and adopting microservices feels like giving up on the complexities of staff management to focus on the complexities of software management. In my experience, few HR issues have been resolved by increasing the complexity of development tools, so I am skeptical that microservices are a practical way to solve complex organizational problems. You should form your own view, but my advice is to think carefully before adopting microservices and ask yourself whether your colleagues will behave any better in a federated development model than they do today.</p>
</div>
<h1 class="heading" id="_idParaDest-244">Creating a basic RESTful web service</h1>
<p class="normal1">As a<a id="_idIndexMarker684" class="calibre3"/> first step, <em class="italic">Listing 14.9</em> creates a web service that implements some of the combinations of URL and HTTP methods described in <em class="italic">Table 14.4</em>. </p>
<p class="packt_figref">Listing 14.9: Creating a basic web service in the index.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
<strong class="screentext">import repository from "../data"</strong><strong class="screentext">;</strong>
export const createApi = (app: Express) =&gt; {
   <strong class="screentext"> app.get("/api/results", async (req, resp) =&gt; {</strong>
<strong class="screentext">        if (req.query</strong><strong class="screentext">.name) {</strong>
<strong class="screentext">            const data = await repository.getResultsByName(</strong>
<strong class="screentext">                req.query.name.toString(), 10);</strong>
<strong class="screentext">            if (data.length</strong><strong class="screentext"> &gt; 0) {</strong>
<strong class="screentext">                resp.json(data);</strong>
<strong class="screentext">            } else {</strong>
<strong class="screentext">                resp.writeHead(404);</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">        }   else {</strong>
<strong class="screentext">                resp.json(await repository.getAllResults(10</strong><strong class="screentext">));</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        resp.end();</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">The listing<a id="_idIndexMarker685" class="calibre3"/> shows how easy it is to create an API for clients by repurposing the parts of the application created for round-trip requests. This is how most web services start, but there are some problems and improvements that can be made, as later sections explain. But, to complete the initial process, <em class="italic">Listing 14.10</em> adds operations to the client to consume the API.</p>
<p class="packt_figref">Listing 14.10: Adding operations in the operations.mjs file in the src/cmdline folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { input } from "@inquirer/prompts";</strong>
<strong class="screentext">const baseUrl = "http://localhost:5000";</strong>
export const ops = {
    <strong class="screentext">"Get All": () =&gt; sendRequest("GET", "/api/results"),</strong>
<strong class="screentext">    "Get Name": async () =&gt; {</strong>
<strong class="screentext">        </strong><strong class="screentext">const name = await input({ message: "Name?"});</strong>
<strong class="screentext">        await sendRequest("GET", `/api/results?name=${name}`);</strong>
<strong class="screentext">    },</strong>
    "Exit": () =&gt; process.exit()
}
<strong class="screentext">const sendRequest = async (method, url, body, contentType) =&gt; {</strong>
<strong class="screentext">    const response = await fetch</strong><strong class="screentext">(baseUrl + url, {</strong>
<strong class="screentext">        method, headers: { "Content-Type": contentType ?? "application/json"},</strong>
<strong class="screentext">        body: JSON.stringify(body)</strong>
<strong class="screentext">    });</strong>
<strong class="screentext">    if (response.status == 200) {</strong>
<strong class="screentext">        const</strong><strong class="screentext"> data = await response.json();</strong>
<strong class="screentext">        (Array.isArray(data) ? data : [data])</strong>
<strong class="screentext">            .forEach(elem =&gt; console.log(JSON.</strong><strong class="screentext">stringify(elem)));</strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        console.log(response.status + " " + response.statusText);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">Node.js <a id="_idIndexMarker686" class="calibre3"/>supports the Fetch API, which is commonly used by browser-based JavaScript code to make HTTP requests. The changes in <em class="italic">Listing 14.10</em> add a <code class="inlinecode">sendRequest</code> function that sends HTTP requests and displays their results and adds <code class="inlinecode">Get All</code> and <code class="inlinecode">Get Name</code> operations. The <code class="inlinecode">Get Name</code> operation uses <code class="inlinecode">Inquirer</code> to prompt for a name, which is then added to the HTTP request query string.</p>
<p class="normal">The command-line client will restart when the changes in <em class="italic">Listing 14.10</em> are detected. Selecting the <strong class="screentext">Get All</strong> option and pressing <em class="italic">Return</em> will display all of the available data, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
{"id":3,"name":"Alice","age":35,"years":10,"nextage":45}
{"id":2,"name":"Bob","age":35,"years":10,"nextage":45}
{"id":1,"name":"Alice","age":35,"years":5,"nextage":40}
...
</code></pre>
<p class="normal">Select the <code class="inlinecode">Get Name</code> operation and press the <em class="italic">Return</em> key, and you will be prompted for a name. Enter <code class="inlinecode">Alice</code> and press <em class="italic">Return</em>, and you will see the matching results:</p>
<pre class="programlisting1"><code class="hljs-con">...
{"id":3,"name":"Alice","age":35,"years":10,"nextage":45}
{"id":1,"name":"Alice","age":35,"years":5,"nextage":40}
...
</code></pre>
<p class="normal">If you <a id="_idIndexMarker687" class="calibre3"/>enter a name that doesn’t exist, the web service will respond with a 404 Not Found response.</p>
<h2 class="heading1" id="_idParaDest-245">Getting data for the web service</h2>
<p class="normal1">The reason<a id="_idIndexMarker688" class="calibre3"/> that the web service only supports two of the<a id="_idIndexMarker689" class="calibre3"/> combinations from <em class="italic">Table 14.4</em> is that those are the only operations that can be performed using the repository, which was created for the needs of the round-trip application.</p>
<p class="normal">There is no single best way to address this issue, and compromises are required. Some projects have web service and round-trip requirements that are similar enough to share a repository, but these are rare, and trying to force consistency between the two can end up compromising one or both parts of the application.</p>
<div><p class="normal"><strong class="screentext">Understanding GraphQL</strong></p>
<p class="normal">GraphQL (<a href="https://graphql.org" class="calibre3">https://graphql.org</a>) is a different approach to providing clients with data. A <a id="_idIndexMarker690" class="calibre3"/>regular RESTful web service provides a specific set of <a id="_idIndexMarker691" class="calibre3"/>operations that produce the same results for all clients. If a client needs additional data in responses, for example, then a developer must modify the web service, and then all clients will receive that new data. </p>
<p class="normal">GraphQL still uses HTTP requests, and the data is still expressed as JSON, but clients can execute custom queries, which include selecting the data values that will be included and filtering data in different ways. This means that clients can receive just the data they require, and different clients can receive different data.</p>
<p class="normal">GraphQL is great, but it is more complex than a regular RESTful web service, both in terms of the server-side development and performing client queries, and most projects are better suited to conventional RESTful web services, which present a fixed set of operations and results to all clients. GraphQL shines in projects that have large amounts of data and clients that are going to use that data in widely different ways, which the server-side developers cannot anticipate. But, for most other projects, GraphQL is <a id="_idIndexMarker692" class="calibre3"/>too complex, and a conventional web service is simpler to create and consume.</p>
</div>
<p class="normal">One alternative <a id="_idIndexMarker693" class="calibre3"/>is to create separate repositories for each <a id="_idIndexMarker694" class="calibre3"/>part of the application, which allows each to evolve independently, but inevitably leads to some degree of code duplication since some operations are likely to be needed by both round-trip and web service clients.</p>
<p class="normal">Another alternative – and the one used in this chapter – is to create a subclass of the original repository and add the missing features. This works when the features required by one part of the application are a subset of those required elsewhere, which is the case with the example application. <em class="italic">Listing 14.11</em> defines a new interface that describes additional features required for the web service. Further methods will be required later, but this is enough for the moment.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">If you are unsure where to start, then start by creating a subclass. If you find that you need to replace most of the features inherited from the base class, then you should split the code into two separate repositories.</p>
</div>
<p class="packt_figref">Listing 14.11: Defining a new interface in the repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">export interface Result {
    id: number,
    name: string,
    age: number,
    years: number,
    nextage: number
}
export interface Repository {
    saveResult(r: Result):  Promise&lt;number&gt;;
    getAllResults(limit: number) : Promise&lt;Result[]&gt;;
    getResultsByName(name: string, limit: number): Promise&lt;Result[]&gt;;
}
<strong class="screentext">export interface ApiRepository extends </strong><strong class="screentext">Repository {</strong>
<strong class="screentext">    getResultById(id: number): Promise&lt;Result | undefined&gt;;</strong>
<strong class="screentext">    delete(id: number) : </strong><strong class="screentext">Promise&lt;boolean&gt;;</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The new methods allow an individual <code class="inlinecode">Result</code> object to be requested by its ID, and for<a id="_idIndexMarker695" class="calibre3"/> data to be deleted by specifying<a id="_idIndexMarker696" class="calibre3"/> an ID. <em class="italic">Listing 14.12</em> updates the <code class="inlinecode">OrmRepository</code> class to implement the new interface.</p>
<p class="packt_figref">Listing 14.12: Implementing the interface in the orm_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { Sequelize } from "sequelize";
<strong class="screentext">import { ApiRepository, Result } from "./repository";</strong>
import { addSeedData, defineRelationships,
    fromOrmModel, initializeModels } from "./orm_helpers";
import { Calculation, Person, ResultModel } from "./orm_models";
<strong class="screentext">export class OrmRepository implements ApiRepository {</strong>
    sequelize: Sequelize;
    // ...constructor and methods omitted for brevity...
    <strong class="screentext">async getResultById(id: number): Promise&lt;Result | undefined&gt; {</strong>
<strong class="screentext">        const model = </strong><strong class="screentext">await ResultModel.findByPk(id, {</strong>
<strong class="screentext">            include: [Person, Calculation ]</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">        return model ? fromOrmModel(model): undefined;</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    </strong><strong class="screentext">async delete(id: number): Promise&lt;boolean&gt; {</strong>
<strong class="screentext">        const count = await ResultModel.destroy({ where: { id }});</strong>
<strong class="screentext">        return count == </strong><strong class="screentext">1;</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal"><em class="italic">Listing 14.13</em> updates the exports from the <code class="inlinecode">data</code> module to add the API-specific repository.</p>
<p class="packt_figref">Listing 14.13: Updating exports in the index.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { ApiRepository } from "./repository";</strong>
import { OrmRepository } from "./orm_repository";
<strong class="screentext">const repository: ApiRepository = new OrmRepository();</strong>
export default repository;
</code></pre>
<p class="normal"><em class="italic">Listing 14.14</em> uses<a id="_idIndexMarker697" class="calibre3"/> the new repository interface to add <a id="_idIndexMarker698" class="calibre3"/>features to the web service. This code is difficult to read, but this will be addressed in the next section.</p>
<p class="packt_figref">Listing 14.14: Adding features in the index.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import repository from "../data";
export const createApi = (app: Express) =&gt; {
    app.get("/api/results", async (req, resp) =&gt; {
        if (req.query.name) {
            const data = await repository.getResultsByName(
                req.query.name.toString(), 10);
            if (data.length &gt; 0) {
                resp.json(data);
            } else {
                resp.writeHead(404);
            }
        }   else {
                resp.json(await repository.getAllResults(10));
        }
        resp.end();
    });
   <strong class="screentext"> app.all("/api/results/:id", </strong><strong class="screentext">async (req, resp) =&gt; {</strong>
<strong class="screentext">        const id = Number.parseInt(req.params.id);</strong>
<strong class="screentext">        if (req.method == "GET") {</strong>
<strong class="screentext">            const result = </strong><strong class="screentext">await repository.getResultById(id);</strong>
<strong class="screentext">            if (result == undefined) {</strong>
<strong class="screentext">                resp.writeHead(404);</strong>
<strong class="screentext">            } else {</strong>
<strong class="screentext">                resp.json(result);</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">        } else if (req.</strong><strong class="screentext">method == "DELETE") {</strong>
<strong class="screentext">            let deleted = await repository.delete(id);</strong>
<strong class="screentext">            resp.json({ deleted });</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        resp.end();</strong>
<strong class="screentext">    })</strong>
<strong class="screentext">    app.post("/api/results", async (req, resp) =&gt; {</strong>
<strong class="screentext">        </strong><strong class="screentext">const { name, age, years} = req.body;</strong>
<strong class="screentext">        const nextage = Number.parseInt(age) + Number.parseInt(years);</strong>
<strong class="screentext">        const id = await repository.saveResult({ </strong><strong class="screentext">id: 0, name, age,</strong>
<strong class="screentext">            years, nextage});</strong>
<strong class="screentext">        resp.json(await repository.getResultById(id));</strong>
<strong class="screentext">        resp.end();</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">The new <a id="_idIndexMarker699" class="calibre3"/>routes add support for querying by ID, storing new results, and deleting existing results. The ability to store new<a id="_idIndexMarker700" class="calibre3"/> results depends on the ability to query by ID because there is a mismatch between the result returned by the <code class="inlinecode">Repository.saveResult</code> method, and the result required by the web service for POST requests. The <code class="inlinecode">saveResult</code> method returns the <code class="inlinecode">Id</code> of the newly stored object, and so an additional query is required to get the <code class="inlinecode">Result</code> object that has been stored so that it can be sent back to the client. <em class="italic">Listing 14.15</em> adds new operations to the command-line client that rely on the new web service features.</p>
<p class="packt_figref">Listing 14.15: Adding features in the operations.mjs file in the src/cmdline folder</p>
<pre class="programlisting"><code class="hljs-code">...
export const ops = {
    "Get All": () =&gt; sendRequest("GET", "/api/results"),
    "Get Name": async () =&gt; {
        const name = await input({ message: "Name?"});
        await sendRequest("GET", `/api/results?name=${name}`);
    },
    <strong class="screentext">"Get ID": async () =&gt; {</strong>
<strong class="screentext">        const id = await input({ </strong><strong class="screentext">message: "ID?"});</strong>
<strong class="screentext">        await sendRequest("GET", `/api/results/${id}`);</strong>
<strong class="screentext">    },</strong>
<strong class="screentext">    "Store": </strong><strong class="screentext">async () =&gt; {</strong>
<strong class="screentext">        const values = {</strong>
<strong class="screentext">            name: await input({message: "Name?"}),</strong>
<strong class="screentext">            age: await input({</strong><strong class="screentext">message: "Age?"}),</strong>
<strong class="screentext">            years: await input({message: "Years?"})</strong>
<strong class="screentext">        };</strong>
<strong class="screentext">        await sendRequest("POST", "</strong><strong class="screentext">/api/results", values);</strong>
<strong class="screentext">    },</strong>
<strong class="screentext">    "Delete": async () =&gt; {</strong>
<strong class="screentext">        const id = await input({ message: "ID?"});</strong>
<strong class="screentext">        </strong><strong class="screentext">await sendRequest("DELETE", `/api/results/${id}`);</strong>
<strong class="screentext">    },</strong>
    "Exit": () =&gt; process.exit()
}
...
</code></pre>
<p class="normal">Using the command-line client, select the <code class="inlinecode">Get Id</code> option and enter <code class="inlinecode">3</code> when prompted, which will produce the following result:</p>
<pre class="programlisting1"><code class="hljs-con">...
{"id":3,"name":"Alice","age":35,"years":10,"nextage":45}
...
</code></pre>
<p class="normal">The web <a id="_idIndexMarker701" class="calibre3"/>service will return a 404 Not Found<a id="_idIndexMarker702" class="calibre3"/> response for <code class="inlinecode">ID</code>s that don’t exist in the database. Select the <code class="inlinecode">Store</code> option and enter <code class="inlinecode">Drew, 50, and 5</code>, when prompted for the name, age, and years values, and the response will show the new record that is stored:</p>
<pre class="programlisting1"><code class="hljs-con">...
{"id":4,"name":"Drew","age":50,"years":5,"nextage":55}
...
</code></pre>
<p class="normal">Selecting the <code class="inlinecode">Get All</code> option will show the new record along with the existing data in the database (but bear in mind that the database is reset and reseeded every time the server-side application restarts, so don’t make any code changes):</p>
<pre class="programlisting1"><code class="hljs-con">...
<strong class="screentext">{"id":4,"name":"Drew","age":50,"years":5,"nextage":55}</strong>
{"id":3,"name":"Alice","age":35,"years":10,"nextage":45}
{"id":2,"name":"Bob","age":35,"years":10,"nextage":45}
{"id":1,"name":"Alice","age":35,"years":5,"nextage":40}
...
</code></pre>
<p class="normal">Select <a id="_idIndexMarker703" class="calibre3"/>the <strong class="screentext">Delete</strong> option and enter the <code class="inlinecode">ID</code> of the <a id="_idIndexMarker704" class="calibre3"/>newly stored item when prompted. The result is a JSON object with a deleted property that indicates the outcome:</p>
<pre class="programlisting"><code class="hljs-code">...
{"deleted":true}
...
</code></pre>
<p class="normal">Selecting the <strong class="screentext">Get All</strong> option will confirm that the data has been deleted.</p>
<div><p class="normal"><strong class="screentext">Understanding OpenAPI</strong></p>
<p class="normal">The OpenAPI specification (<a href="https://www.openapis.org" class="calibre3">https://www.openapis.org</a>) is a standard for describing web services, which <a id="_idIndexMarker705" class="calibre3"/>can help client-side developers understand how a web service is intended to be used and provides a description of the data to which it provides access. There are tools and packages available that generate client-side code automatically from an OpenAPI description, and some JavaScript packages used to define web services will automatically generate OpenAPI documents. </p>
<p class="normal">OpenAPI is a good idea, but it is often used as a substitute for descriptive documentation, which tends to leave a gap between the features a web service provides and how the developer intended them to be used. If you adopt OpenAPI in your project, you must ensure that you supplement the description it produces with notes that explain how your web service should be consumed.</p>
</div>
<h2 class="heading1" id="_idParaDest-246">Separating the HTTP code</h2>
<p class="normal1">The web service in <em class="italic">Listing 14.15</em> supports<a id="_idIndexMarker706" class="calibre3"/> all the combinations of HTTP method and URL described in <em class="italic">Table 14.4</em>, but the code is difficult to understand. The web service has three tasks to perform: parsing the HTTP request, performing an operation, and preparing the HTTP response. When the same code is responsible for all of these tasks, it can be hard to identify the statements that perform the operations because they get lost in all the HTTP handling.</p>
<p class="normal">The result also tends to be HTTP centric, by which I mean that most developers end up writing code with as few routes as possible, and that further complicates the <a id="_idIndexMarker707" class="calibre3"/>results. You can see this in <em class="italic">Listing 14.14</em>, where the Express <code class="inlinecode">all</code> method is used to match all requests for a URL path, with the HTTP method being identified in the request handler, like this: </p>
<pre class="programlisting"><code class="hljs-code">...
<strong class="screentext">app.all</strong><strong class="screentext">("/api/results/:id", async (req, resp) =&gt; {</strong>
    const id = Number.parseInt(req.params.id);
    if (<strong class="screentext">req.method</strong> == "GET") {
        const result = await repository.getResultById(id);
        if (result == undefined) {
            resp.writeHead(404);
        } else {
            resp.json(result);
        }
    } <strong class="screentext">else if (req.method</strong> == "DELETE") {
        let deleted = await repository.delete(id);
        resp.json({ deleted });
    }
    resp.end();
})
...
</code></pre>
<p class="normal">I end up writing this kind of code all the time. The code compiles, and the web service works, but it is difficult to maintain because different aspects of the web service are intertwined.</p>
<p class="normal">Web services are more easily written and maintained if the code that handles the HTTP requests is extracted into an adapter, with the added benefit that web services that require the same set of HTTP methods and URL formats can use the same adapter code. To describe the functionality of a web service, add a file <a id="_idIndexMarker708" class="calibre3"/>named <code class="inlinecode">http_adapter.ts</code> to the <code class="inlinecode">src/server/api</code> folder with the code in <em class="italic">Listing 14.16</em>.</p>
<p class="packt_figref">Listing 14.16: The contents of the http_adapter.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, Response } from "express";
export interface WebService&lt;T&gt; {
    getOne(id: any) : Promise&lt;T | undefined&gt;;
    getMany(query: any) : Promise&lt;T[]&gt;;
    store(data: any) : Promise&lt;T | undefined&gt;;
    delete(id: any): Promise&lt;boolean&gt;;
}
export function createAdapter&lt;T&gt;(app: Express, ws: WebService&lt;T&gt;, baseUrl: string) {
    app.get(baseUrl, async (req, resp) =&gt; {
        try {
            resp.json(await ws.getMany(req.query));
            resp.end();
        } catch (err) { writeErrorResponse(err, resp) }
    });
    app.get(`${baseUrl}/:id`, async (req, resp) =&gt; {
        try {
            const data = await ws.getOne((req.params.id));
            if (data == undefined) {
                    resp.writeHead(404);
            } else {
                    resp.json(data);
            }
            resp.end();
        } catch (err) { writeErrorResponse(err, resp) }
    });
    app.post(baseUrl, async (req, resp) =&gt; {
        try {
            const data = await ws.store(req.body);
            resp.json(data);
            resp.end();
        } catch (err) { writeErrorResponse(err, resp) }
    });
    app.delete(`${baseUrl}/:id`, async (req, resp) =&gt; {
        try {
            resp.json(await ws.delete(req.params.id));
            resp.end();
        } catch (err) { writeErrorResponse(err, resp) }
    });
    const writeErrorResponse = (err: any, resp: Response) =&gt; {
        console.error(err);
        resp.writeHead(500);
        resp.end();
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">WebService&lt;T&gt;</code> interface describes a web service that operates on type <code class="inlinecode">T</code>, with methods <a id="_idIndexMarker709" class="calibre3"/>that describe the operations required to support the basic web service features. The <code class="inlinecode">createAdapter&lt;T&gt;</code> function creates Express routes that rely on the <code class="inlinecode">WebService&lt;T&gt;</code> methods to produce results. To create an implementation of the <code class="inlinecode">WebService&lt;T&gt;</code> interface for <code class="inlinecode">Result</code> data, add a file named <code class="inlinecode">results_api.ts</code> to the <code class="inlinecode">src/server/api</code> folder with the content shown in <em class="italic">Listing 14.17</em>.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">I generally define JavaScript functions using the fat arrow syntax because it feels more natural to me. However, I used the <code class="inlinecode">function</code> keyword in <em class="italic">Listing 14.16</em> to define the <code class="inlinecode">createAdapter&lt;T&gt;</code> function, because the way that TypeScript type parameters are expressed on fat arrow functions seems awkward to me. The equivalent function signature in fat arrow form is: </p>
<p class="normal"><code class="inlinecode">export const createAdapter = &lt;T&gt;(app: Express, ws: WebService&lt;T&gt;, baseUrl: string) =&gt; {</code></p>
<p class="normal">Putting the type parameter after the equals sign seems jarring to me, although you are free to follow either syntax as your preferences dictate.</p>
</div>
<p class="packt_figref">Listing 14.17: The contents of the results_api.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { WebService } from "./http_adapter";
<strong class="screentext">import { Result } from "../data/repository";</strong>
<strong class="screentext">import repository from "../data";</strong>
<strong class="screentext">export class ResultWebService</strong><strong class="screentext"> implements WebService&lt;Result&gt; {</strong>
<strong class="screentext">    getOne(id: any): Promise&lt;Result | undefined&gt; {</strong>
<strong class="screentext">        return repository.getResultById(Number</strong><strong class="screentext">.parseInt(id));</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    getMany(query: any): Promise&lt;Result[]&gt; {</strong>
<strong class="screentext">        if (query.name) {</strong>
<strong class="screentext">            return repository.getResultsByName(query.name</strong><strong class="screentext">, 10);</strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            return repository.getAllResults(10);</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    async store(data: any): Promise&lt;Result</strong><strong class="screentext"> | undefined&gt; {</strong>
<strong class="screentext">        const { name, age, years} = data;</strong>
<strong class="screentext">        const nextage = Number.parseInt(age) + Number.parseInt(years);</strong>
<strong class="screentext">        const id = await repository.saveResult</strong><strong class="screentext">({ id: 0, name, age,</strong>
<strong class="screentext">            years, nextage});</strong>
<strong class="screentext">        return await repository.getResultById(id);       </strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    delete(id: any): Promise&lt;boolean&gt; {</strong>
<strong class="screentext">        return repository.delete</strong><strong class="screentext">(Number.parseInt(id));</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">ResultWebService</code> class implements the <code class="inlinecode">WebService&lt;Result&gt;</code> interface and implements the methods by using the repository features. <em class="italic">Listing 14.18</em> uses the new adapter to <a id="_idIndexMarker710" class="calibre3"/>register the web service, replacing the mixed code.</p>
<p class="packt_figref">Listing 14.18: Using the adapter in the index.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
<strong class="screentext">//import repository from "../data";</strong>
import { createAdapter } from "./http_adapter";
import { ResultWebService } from "./results_api";
export const createApi = (app: Express) =&gt; {
    <strong class="screentext">createAdapter(app, new ResultWebService(), "/api/results");</strong>
}
</code></pre>
<p class="normal">There is no change in the behavior of the web service, but removing the code that deals with HTTP requests and responses makes the web service easier to understand and maintain.</p>
<h1 class="heading" id="_idParaDest-247">Updating data</h1>
<p class="normal1">There are two ways to support <a id="_idIndexMarker711" class="calibre3"/>updates in web services: replacing <a id="_idIndexMarker712" class="calibre3"/>data and patching data. An HTTP PUT request is sent when the client wants to completely replace data, and the request body contains all of the data the web service will need for the replacement. An HTTP <code class="inlinecode">PATCH</code> method is used when the client wants to modify data, and the request body contains a description of how that data should be modified. </p>
<p class="normal">Supporting updates with PUT requests is simpler to implement but requires the client to provide a complete replacement for the stored data. PATCH requests are more complex but offer more flexibility and can be more efficient because only the changes are sent to the web service.</p>
<div><p class="normal"><strong class="screentext">Tip</strong></p>
<p class="normal">It can be hard to know which approach to adopt at the start of a new project when the types of updates clients will send are unknown. My advice is to start by supporting complete updates because they are simpler to implement and move to partial updates only if you find that the unchanged data values start to outnumber the changed values.</p>
</div>
<p class="normal">This chapter demonstrates both PUT and PATCH requests. To prepare, <em class="italic">Listing 14.19</em> adds a new method to the <code class="inlinecode">ApiRepository</code> interface that will allow data to be updated.</p>
<p class="packt_figref">Listing 14.19: Adding a method in the repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">...
export interface ApiRepository extends Repository {
    getResultById(id: number): Promise&lt;Result | undefined&gt;;
    delete(id: number) : Promise&lt;boolean&gt;;
    <strong class="screentext">update(r: Result) : Promise&lt;Result</strong><strong class="screentext"> | undefined&gt;   </strong>
}
...
</code></pre>
<p class="normal"><em class="italic">Listing 14.20</em> implements this method using the Sequelize ORM package.</p>
<p class="packt_figref">Listing 14.20: Updating data in the orm_repository.ts file in the src/server/data folder</p>
<pre class="programlisting"><code class="hljs-code">import { Sequelize, or } from "sequelize";
import { ApiRepository, Result } from "./repository";
import { addSeedData, defineRelationships,
    fromOrmModel, initializeModels } from "./orm_helpers";
import { Calculation, Person, ResultModel } from "./orm_models";
export class OrmRepository implements ApiRepository {
    sequelize: Sequelize;
    // ...constructor and methods omitted for brevity...
  <strong class="screentext">  async </strong><strong class="screentext">update(r: Result) : Promise&lt;Result | undefined &gt; {</strong>
<strong class="screentext">        const mod = await this.sequelize.</strong><strong class="screentext">transaction(async (transaction) =&gt; {</strong>
<strong class="screentext">            const stored = await ResultModel.findByPk(r.id);</strong>
<strong class="screentext">            if (stored !== null) {</strong>
<strong class="screentext">                const [person] = </strong><strong class="screentext">await Person.findOrCreate({</strong>
<strong class="screentext">                    where: { name : r.name}, transaction</strong>
<strong class="screentext">                });               </strong>
<strong class="screentext">                const [calculation] = await Calculation.findOrCreate({</strong>
<strong class="screentext">                    where: {</strong>
<strong class="screentext">                        </strong><strong class="screentext">age: r.age, years: r.years, nextage: r.nextage</strong>
<strong class="screentext">                    }, transaction</strong>
<strong class="screentext">                });</strong>
<strong class="screentext">                stored.personId = person.id;</strong>
<strong class="screentext">                stored.calculationId = calculation.id;</strong>
<strong class="screentext">                </strong><strong class="screentext">return await stored.save({transaction});</strong>
<strong class="screentext">            }</strong>
<strong class="screentext">        });</strong>
<strong class="screentext">        return mod ? this.getResultById(mod.id) : undefined;</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal">Updating the data <a id="_idIndexMarker713" class="calibre3"/>in the example means changing either the name or calculation associated with a result. The implementation of <a id="_idIndexMarker714" class="calibre3"/>the <code class="inlinecode">update</code> method performs an update in four steps, all of which are performed as a transaction. The first step is to read the data that is to be updated from the database using the <code class="inlinecode">id</code> property of the <code class="inlinecode">Result</code> parameter:</p>
<pre class="programlisting"><code class="hljs-code">...
const stored = await ResultModel.findByPk(r.id);
...
</code></pre>
<p class="normal">If there is a matching entry in the database, the <code class="inlinecode">findOrCreate</code> method is used to locate the <code class="inlinecode">Person</code> and <code class="inlinecode">Calculation</code> data that matches the <code class="inlinecode">Result</code> parameter or create new data if there are no matches. The next step is to update the <code class="inlinecode">ID</code>s so the stored data refers to the new <code class="inlinecode">Person</code> and <code class="inlinecode">Calculation</code> records and write the changes to the database, which is done using the <code class="inlinecode">save</code> method:</p>
<pre class="programlisting"><code class="hljs-code">...
stored.personId = person.id;
stored.calculationId = calculation.id;
return await stored.save({transaction});
...
</code></pre>
<p class="normal">The <code class="inlinecode">save</code> method <a id="_idIndexMarker715" class="calibre3"/>is smart enough to detect changes and <a id="_idIndexMarker716" class="calibre3"/>will only update the database for properties whose values have changed. The final step is performed after the transaction has been committed and returns the modified data using the <code class="inlinecode">getResultById</code> method.</p>
</div>


<div><h2 class="heading1" id="_idParaDest-248">Replacing data with PUT requests</h2>
<p class="normal1">PUT requests are the <a id="_idIndexMarker717" class="calibre3"/> simplest to implement because the<a id="_idIndexMarker718" class="calibre3"/> web service simply uses the data sent by the client to replace the stored data. <em class="italic">Listing 14.21</em> extends the interface that describes web services to add a new method and extends the HTTP wrapper to use the interface method to handle PUT requests. </p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Not every web service uses PUT requests for updates. POST requests are often used both to store new data and update data, using the URL to differentiate between operations, so that the URL used for an update will include a unique <code class="inlinecode">ID</code> (<code class="inlinecode">/api/results/1</code>) and the URL used to store data will not (<code class="inlinecode">/api/results</code>).</p>
</div>
<p class="packt_figref">Listing 14.21: Adding methods in the http_adapter.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, Response } from "express";
export interface WebService&lt;T&gt; {
    getOne(id: any) : Promise&lt;T | undefined&gt;;
    getMany(query: any) : Promise&lt;T[]&gt;;
    store(data: any) : Promise&lt;T | undefined&gt;;
    delete(id: any): Promise&lt;boolean&gt;;
  <strong class="screentext">  replace(id: any, data: any): Promise&lt;T | undefined&gt;;</strong>
}
export function createAdapter&lt;T&gt;(app: Express, ws: WebService&lt;T&gt;, baseUrl: string) {
    // ...routes omitted for brevity...
 <strong class="screentext">   app.put(`${baseUrl}/:id`, async</strong><strong class="screentext"> (req, resp) =&gt; {</strong>
<strong class="screentext">        try {</strong>
<strong class="screentext">            resp.json(await ws.replace(req.params.id, req.body));</strong>
<strong class="screentext">            resp.end();</strong>
<strong class="screentext">        } catch (err) { writeErrorResponse</strong><strong class="screentext">(err, resp) }</strong>
<strong class="screentext">    });</strong>
    const writeErrorResponse = (err: any, resp: Response) =&gt; {
        console.error(err);
        resp.writeHead(500);
        resp.end();
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">replace</code> method added to the <code class="inlinecode">WebService&lt;T&gt;</code> interface accepts an <code class="inlinecode">id</code> and a <code class="inlinecode">data</code> object. The new route matches requests with the PUT method, extracts the <code class="inlinecode">ID</code> from the URL, and uses the request body for the data. Implementing the<a id="_idIndexMarker719" class="calibre3"/> method in the web service is a matter <a id="_idIndexMarker720" class="calibre3"/>of receiving the data from the HTTP wrapper and passing it on to the repository, as shown in <em class="italic">Listing 14.22</em>.</p>
<p class="packt_figref">Listing 14.22: Replacing data in the results_api.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { WebService } from "./http_adapter";
import { Result } from "../data/repository";
import repository from "../data";
export class ResultWebService implements WebService&lt;Result&gt; {
    // ...methods omitted for brevity...
    <strong class="screentext">replace(id: any, data: any): Promise&lt;Result | undefined&gt; {</strong>
<strong class="screentext">        const { name, age, years, nextage } = data;</strong>
<strong class="screentext">        </strong><strong class="screentext">return repository.update({ id, name, age, years, nextage });</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal">The data<a id="_idIndexMarker721" class="calibre3"/> received from the HTTP wrapper is<a id="_idIndexMarker722" class="calibre3"/> deconstructed into constant values that are combined with the <code class="inlinecode">id</code> parameter and passed to the repository’s <code class="inlinecode">update</code> method.</p>
<p class="normal">The last step is to add an operation to the command-line client that will send the PUT request, as shown in <em class="italic">Listing 14.23</em>.</p>
<p class="packt_figref">Listing 14.23: Supporting updates in the operations.mjs file in the src/cmdline folder</p>
<pre class="programlisting"><code class="hljs-code">...
export const ops = {
    // ...properties/functions omitted for brevity...
   <strong class="screentext"> "Replace": async () =&gt; {</strong>
<strong class="screentext">        const id = await input({ message: "ID?"});</strong>
<strong class="screentext">        const values = {</strong>
<strong class="screentext">            name</strong><strong class="screentext">: await input({message: "Name?"}),</strong>
<strong class="screentext">            age: await input({message: "Age?"}),</strong>
<strong class="screentext">            years</strong><strong class="screentext">: await input({message: "Years?"}),</strong>
<strong class="screentext">            nextage: await input({message: "Next Age?"})</strong>
<strong class="screentext">        };</strong>
<strong class="screentext">        await</strong><strong class="screentext"> sendRequest("PUT", `/api/results/${id}`, values);</strong>
<strong class="screentext">    },</strong>
    "Exit": () =&gt; process.exit()
}
...
</code></pre>
<p class="normal">The operation is called <code class="inlinecode">Replace</code> and it prompts for all the values required to store data and sends them to the web service using an HTTP <code class="inlinecode">PUT</code> request. Select the new <strong class="screentext">Replace</strong> option from the command line and enter <code class="inlinecode">1</code>, <code class="inlinecode">Joe</code>, <code class="inlinecode">35</code>, <code class="inlinecode">10</code>, and <code class="inlinecode">45</code> when prompted. This operation will update the result whose <code class="inlinecode">ID</code> is <code class="inlinecode">1</code> with a new name, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Select an operation Replace
? ID? 1
? Name? Joe
? Age? 35
? Years? 10
? Next Age? 45
{"id":1,"name":"Joe","age":35,"years":10,"nextage":45}
? Select an operation Get All
{"id":3,"name":"Alice","age":35,"years":10,"nextage":45}
{"id":2,"name":"Bob","age":35,"years":10,"nextage":45}
<strong class="screentext">{"id":1,"name":"Joe","age":35,"years":10,"nextage":45}</strong>
...
</code></pre>
<p class="normal">The name<a id="_idIndexMarker723" class="calibre3"/> is changed but the other values are the <a id="_idIndexMarker724" class="calibre3"/>same, so the relationship between the result and the calculation in the database remains unchanged.</p>
<h2 class="heading1" id="_idParaDest-249">Modifying data with PATCH requests</h2>
<p class="normal1">PATCH requests <a id="_idIndexMarker725" class="calibre3"/>allow a client to ask a web server to<a id="_idIndexMarker726" class="calibre3"/> apply partial updates, without having to send a complete data record. There is no standard way to describe partial changes in a PATCH request and any data format can be used, just as long as the client and the web service both understand how data is identified and how changes are described. To support PATCH requests, <em class="italic">Listing 14.24</em> adds a new method to the web service interface and defines a route that matches PATCH requests. </p>
<p class="packt_figref">Listing 14.24: Supporting PATCH requests in the http_adapter.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, Response } from "express";
export interface WebService&lt;T&gt; {
    getOne(id: any) : Promise&lt;T | undefined&gt;;
    getMany(query: any) : Promise&lt;T[]&gt;;
    store(data: any) : Promise&lt;T | undefined&gt;;
    delete(id: any): Promise&lt;boolean&gt;;
    replace(id: any, data: any): Promise&lt;T | undefined&gt;;
    <strong class="screentext">modify</strong><strong class="screentext">(id: any, data: any): Promise&lt;T | undefined&gt;;   </strong>
}
export function createAdapter&lt;T&gt;(app: Express, ws: WebService&lt;T&gt;, baseUrl: string) {
    // ...routes omitted for brevity...
    <strong class="screentext">app.patch(`${baseUrl}/:id`, async (req, resp) =&gt; {</strong>
<strong class="screentext">        try {</strong>
<strong class="screentext">            resp.json(await</strong><strong class="screentext"> ws.modify(req.params.id, req.body));</strong>
<strong class="screentext">            resp.end();</strong>
<strong class="screentext">        } catch (err) { writeErrorResponse(err, resp) }</strong>
<strong class="screentext">    });</strong>
    const writeErrorResponse = (err: any, resp: Response) =&gt; {
        console.error(err);
        resp.writeHead(500);
        resp.end();
    }
}
</code></pre>
<p class="normal">The simplest way <a id="_idIndexMarker727" class="calibre3"/>to support partial updates is to<a id="_idIndexMarker728" class="calibre3"/> allow the client to provide a JSON object that contains only replacement values and omits any property that should be left unchanged, as shown in <em class="italic">Listing 14.25</em>.</p>
<p class="packt_figref">Listing 14.25: Modifying data in the results_api.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { WebService } from "./http_adapter";
import { Result } from "../data/repository";
import repository from "../data";
export class ResultWebService implements WebService&lt;Result&gt; {
    // ...methods omitted for brevity...
    async modify(id: any, data: any): Promise&lt;Result | undefined&gt; {
    <strong class="screentext">    const dbData = await this.getOne(id);</strong>
<strong class="screentext">        if (dbData !== undefined) {</strong>
<strong class="screentext">            Object.entries(dbData).</strong><strong class="screentext">forEach(([prop, val]) =&gt; {</strong>
<strong class="screentext">                (dbData as any)[prop] = data[prop] ?? val;</strong>
<strong class="screentext">            });</strong>
<strong class="screentext">            return await this.replace(id, dbData)</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    }</strong>
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker729" class="calibre3"/>implementation method enumerates<a id="_idIndexMarker730" class="calibre3"/> the properties defined by the <code class="inlinecode">Result</code> interface and checks to see whether the data received from the request contains a replacement value. New values are applied to update the existing data, which is then passed to the repository’s <code class="inlinecode">replace</code> method to be stored. Notice that the repository is used in the same way for replacements and updates and that it is the job of the web service to prepare the data for storage. <em class="italic">Listing 14.26</em> adds an operation to the command-line client that sends PATCH requests.</p>
<p class="packt_figref">Listing 14.26: Sending PATCH requests in the operations.mjs file in the src/cmdline folder</p>
<pre class="programlisting"><code class="hljs-code">...
export const ops = {
    // ...properties/functions omitted for brevity...
    <strong class="screentext">"Modify": async () =&gt; {</strong>
<strong class="screentext">        const id = await</strong><strong class="screentext"> input({ message: "ID?"});</strong>
<strong class="screentext">        const values = {</strong>
<strong class="screentext">            name: await input({message: "Name?"</strong><strong class="screentext">}),</strong>
<strong class="screentext">            age: await input({message: "Age?"}),</strong>
<strong class="screentext">            years: await input({message: "Years?"</strong><strong class="screentext">}),</strong>
<strong class="screentext">            nextage: await input({message: "Next Age?"})</strong>
<strong class="screentext">        };</strong>
<strong class="screentext">        await sendRequest("PATCH", `/api/results/${id}`</strong><strong class="screentext">,</strong>
<strong class="screentext">            Object.fromEntries(Object.entries(values)</strong>
<strong class="screentext">                .filter(([p, v]) =&gt; v !== "")));</strong>
<strong class="screentext">    },</strong>
    "Exit": () =&gt; process.exit()
}
...
</code></pre>
<p class="normal">This operation prompts for values in the same way as for PUT requests, but the JavaScript <code class="inlinecode">Object.fromEntries</code>, <code class="inlinecode">Object.entries</code>, and <code class="inlinecode">filter</code> functions are used to exclude any property for which no value is provided so that a partial update is sent to the web service.</p>
<p class="normal">Select the new <strong class="screentext">Modify</strong> option from the command line and enter <code class="inlinecode">2</code> for the <code class="inlinecode">ID</code> and <code class="inlinecode">Clara</code> for the <a id="_idIndexMarker731" class="calibre3"/>name, and then press <em class="italic">Return</em> for<a id="_idIndexMarker732" class="calibre3"/> the other prompts. This operation will update the result whose <code class="inlinecode">ID</code> is <code class="inlinecode">2</code> with a new name, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Select an operation Modify
? ID? 2
? Name? Clara
? Age?
? Years?
? Next Age?
{"id":2,"name":"Clara","age":35,"years":10,"nextage":45}
? Select an operation Get All
{"id":3,"name":"Alice","age":35,"years":10,"nextage":45}
<strong class="screentext">{"id":2,"name":"Clara","age":35,"years":10,"nextage":45}</strong>
{"id":1,"name":"Alice","age":35,"years":5,"nextage":40}
...
</code></pre>
<p class="normal">The client sent only a new name value to the web service and didn’t need to send values for the properties whose values were not changed.</p>
<h3 class="heading2" id="_idParaDest-250">Using JSON Patch</h3>
<p class="normal1">The approach used in the previous section is useful when the only updates sent by the client are changes to existing data values. Many projects fall into this category, and it is a useful technique when the data becomes too complex for replacement requests and the only changes are providing updated values. </p>
<p class="normal">The<a id="_idIndexMarker733" class="calibre3"/> JSON Patch format (<a href="https://jsonpatch.com" class="calibre3">https://jsonpatch.com</a>) can be used for more<a id="_idIndexMarker734" class="calibre3"/> complex updates. A JSON Patch document contains a series of operations that are applied to a JSON document. A JSON Patch document to update the value of the <code class="inlinecode">name</code> property, for example, would look like this:</p>
<pre class="programlisting"><code class="hljs-code">...
[{ "op": "replace", "path": "/name", "value": "Bob" }]
...
</code></pre>
<p class="normal">JSON Patch<a id="_idIndexMarker735" class="calibre3"/> documents contain an array of JSON objects, with <code class="inlinecode">op</code> and <code class="inlinecode">path</code> properties that describe the operation to be performed and the target for that operation. Additional properties are required for some operations, such as the <code class="inlinecode">value</code> property used to specify the new value for the replace operation. <em class="italic">Table 14.5</em> describes the JSON Patch operations. </p>
<p class="packt_figref">Table 14.5: The JSON Patch operations</p>
<table class="table-container" id="table005-6">
<tbody class="calibre8">
<tr class="calibre9">
<td class="table-cell">
<p class="normal">Operation</p>
</td>
<td class="table-cell">
<p class="normal">Description</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">add</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This<a id="_idIndexMarker736" class="calibre3"/> operation adds a property to the JSON document, with the name and value specified by the <code class="inlinecode">path</code> and <code class="inlinecode">value</code> properties.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">remove</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker737" class="calibre3"/>operation removes a property from the JSON document, specified by the <code class="inlinecode">path</code> property.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">replace</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker738" class="calibre3"/>operation changes the property specified by the <code class="inlinecode">path</code> property using the value assigned to the <code class="inlinecode">value</code> property.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">copy</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker739" class="calibre3"/>operation duplicates a property specified by the <code class="inlinecode">from</code> property to the location specified by the <code class="inlinecode">path</code> property.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">move</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker740" class="calibre3"/>operation moves a property specified by the <code class="inlinecode">from</code> property to the location specified by the <code class="inlinecode">path</code> property.</p>
</td>
</tr>
<tr class="calibre9">
<td class="table-cell">
<pre class="programlisting2"><code class="hljs"><code class="inlinecode1">test</code>
</code></pre>
</td>
<td class="table-cell">
<p class="normal">This <a id="_idIndexMarker741" class="calibre3"/>property checks to see that the JSON document contains a property and value specified by the <code class="inlinecode">path</code> and <code class="inlinecode">value</code> properties. No other operations will be performed if this operation fails.</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The <code class="inlinecode">path</code> property is used to identify values in the JSON document using the JSON Pointer syntax, which is described at <a href="https://datatracker.ietf.org/doc/html/rfc6901" class="calibre3">https://datatracker.ietf.org/doc/html/rfc6901</a>, and which can be used to select properties and array elements. The location <code class="inlinecode">/name</code>, for example, denotes a <code class="inlinecode">name</code> property at the top level of the JSON document.</p>
<p class="normal">JSON Patch documents can be parsed and applied using custom code, but it is easier to use one of the available open-source JavaScript packages. Run the command shown<a id="_idIndexMarker742" class="calibre3"/> in <em class="italic">Listing 14.27</em> in the <code class="inlinecode">part2app</code> folder to install the <code class="inlinecode">fast-json-patch</code> package (<a href="https://github.com/Starcounter-Jack/JSON-Patch" class="calibre3">https://github.com/Starcounter-Jack/JSON-Patch</a>), which is a popular <a id="_idIndexMarker743" class="calibre3"/>JSON Patch package. </p>
<p class="packt_figref">Listing 14.27: Installing the JSON Patch package</p>
<pre class="programlisting1"><code class="hljs-con">npm install fast-json-patch@3.1.1
</code></pre>
<p class="normal"><em class="italic">Listing 14.28</em> updates the web service so that the <code class="inlinecode">modify</code> method will treat the data it receives as a JSON Patch document and apply it using the <code class="inlinecode">fast-json-patch</code> package.</p>
<p class="packt_figref">Listing 14.28: Using JSON Patch in the result_api.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { WebService } from "./http_adapter";
import { Result } from "../data/repository";
import repository from "../data";
<strong class="screentext">import * as jsonpatch from "fast-json-patch";</strong>
export class ResultWebService implements WebService&lt;Result&gt; {
    // ...methods omitted for brevity...
    async modify(id: any, data: any): Promise&lt;Result | undefined&gt; {
        const dbData = await this.getOne(id);
        if (dbData !== undefined) {
           <strong class="screentext"> return await this.replace(id,</strong>
<strong class="screentext">                jsonpatch.</strong><strong class="screentext">applyPatch(dbData, data).newDocument);</strong>
        }
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">applyPatch</code> method is used to process the JSON Patch document to an object. The <code class="inlinecode">result</code> object defines a <code class="inlinecode">newDocument</code> property that returns the modified object, which can be stored in the database.</p>
<p class="normal">The HTTP <code class="inlinecode">Content-Type</code> header is set to <code class="inlinecode">application/json-patch+json</code> when sending a JSON Patch document and this type is not decoded automatically by the Express JSON middleware component. <em class="italic">Listing 14.29</em> configures the JSON middleware so that normal JSON payloads and JSON Patch payloads will be decoded. </p>
<p class="packt_figref">Listing 14.29: Enabling JSON Patch decoding in the server.ts file in the src/server folder</p>
<pre class="programlisting"><code class="hljs-code">...
expressApp.use(helmet());
<strong class="screentext">expressApp.use(express.json({</strong>
<strong class="screentext">    type: ["application/json", "application/json-patch+json"]</strong>
<strong class="screentext">}));</strong>
registerFormMiddleware(expressApp);
registerFormRoutes(expressApp);
...
</code></pre>
<p class="normal">The JSON <a id="_idIndexMarker744" class="calibre3"/>middleware accepts a configuration object whose <code class="inlinecode">type</code> property can be configured with an array of content types to decode. The final step is to create a JSON Patch document in the command-line client, as shown in <em class="italic">Listing 14.30</em>.</p>
<p class="packt_figref">Listing 14.30: Using JSON Patch in the operations.mjs file in the src/cmdline folder</p>
<pre class="programlisting"><code class="hljs-code">...
"Modify": async () =&gt; {
    const id = await input({ message: "ID?"});
    const values = {
        name: await input({message: "Name?"}),
        age: await input({message: "Age?"}),
        years: await input({message: "Years?"}),
        nextage: await input({message: "Next Age?"})
    };
   <strong class="screentext"> await sendRequest("PATCH", `/api/results/${id}`,</strong>
<strong class="screentext">        Object.entries(values).filter((</strong><strong class="screentext">[p, v]) =&gt; v !== "")</strong>
<strong class="screentext">            .map(([p, v]) =&gt; ({ op: "replace", path: "/" + p, value</strong><strong class="screentext">: v})),</strong>
<strong class="screentext">            "application/json-patch+json");</strong>
},
...
</code></pre>
<p class="normal">The <code class="inlinecode">fast-json-patch</code> package is capable of generating a JSON Patch document, but it is easier to create patches with custom code than it is to apply them, and the modified statement in <em class="italic">Listing 14.30</em> creates <code class="inlinecode">replace</code> operations for each of the values entered by the user.</p>
<p class="normal">There is no change in the way the client and web service behave, which you can confirm by selecting the <code class="inlinecode">Modify</code> option from the command line and entering <code class="inlinecode">2</code> for the <code class="inlinecode">ID</code> and <code class="inlinecode">Clara</code> for the name, and then pressing return for the other prompts. This is the same change performed earlier in the chapter and it should produce the<a id="_idIndexMarker745" class="calibre3"/> same results, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Select an operation Modify
? ID? 2
? Name? Clara
? Age?
? Years?
? Next Age?
{"id":2,"name":"Clara","age":35,"years":10,"nextage":45}
? Select an operation Get All
{"id":3,"name":"Alice","age":35,"years":10,"nextage":45}
<strong class="screentext">{"id":2,"name":"Clara","age":35,"years":10,"nextage":45}</strong>
{"id":1,"name":"Alice","age":35,"years":5,"nextage":40}
...
</code></pre>
<h1 class="heading" id="_idParaDest-251">Validating client data</h1>
<p class="normal1">Web services <a id="_idIndexMarker746" class="calibre3"/>cannot trust the data that is received from clients<a id="_idIndexMarker747" class="calibre3"/> and are subject to the same kinds of issues that affect HTML forms. Malicious users can craft HTTP requests or alter the client-side JavaScript code to send data values that will cause errors or create unexpected results, similar to the problems with form data described in <em class="italic">Chapter 11</em>. </p>
<p class="normal">The difficulty with web services is validating data in a way that doesn’t undermine the code clarity that came from isolating the statements that handle HTTP requests. If every web service method validates its data directly, the result is a mess of duplicated code statements that bury the web service functionality and are difficult to read and entertain. The best approach to validation is to describe validation requirements and apply them outside of the web service.</p>
<h2 class="heading1" id="_idParaDest-252">Creating the validation infrastructure</h2>
<p class="normal1">Allowing the<a id="_idIndexMarker748" class="calibre3"/> validation requirements of a web service to be expressed clearly and concisely requires infrastructure that hides away the messy implementation details. </p>
<p class="normal">The starting point is to define the types that describe validation for an entire web service, a web service method, and a single validation rule. Add a file named <code class="inlinecode">validation_types.ts</code> to the <code class="inlinecode">src/server/api</code> folder with the content shown in <em class="italic">Listing 14.31</em>. </p>
<p class="packt_figref">Listing 14.31: The contents of the validation_types.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">export interface WebServiceValidation  {
    keyValidator?: ValidationRule;
    getMany?: ValidationRequirements;
    store?: ValidationRequirements;
    replace?: ValidationRequirements;
    modify?: ValidationRequirements;
}
export type ValidationRequirements = {
    [key: string] : ValidationRule
}
export type ValidationRule =
    ((value: any) =&gt; boolean)[] |
    {
        required? : boolean,
        validation: ((value: any) =&gt; boolean)[],
        converter?: (value: any) =&gt; any,
    }
export class ValidationError implements Error {
    constructor(public name: string, public message: string) {}
    stack?: string | undefined;
    cause?: unknown;
}
</code></pre>
<p class="normal">The <code class="inlinecode">WebServiceValidation</code> type describes the validation requirements for a web service. The <code class="inlinecode">keyValidator</code> property specifies the validation requirements for the <code class="inlinecode">ID</code> values that identify data records, using the <code class="inlinecode">ValidationRule</code> type. A <code class="inlinecode">ValidationRule</code> can either be an array of test functions that will be applied to a value, or an object that additionally specifies whether a value is required and a converter that will transform the value into the type expected by the web service method.</p>
<p class="normal">The <a id="_idIndexMarker749" class="calibre3"/>other properties defined by the <code class="inlinecode">WebServiceValidation</code> type correspond to the web service methods that consume data. These properties can be assigned a <code class="inlinecode">ValidationRequirements</code> object, which can specify the shape of the object expected by the web service, and a <code class="inlinecode">ValidationRule</code> for each of them. The <code class="inlinecode">ValidationError</code> class represents a problem validating the data sent by the client in a request.</p>
<p class="normal">The next step is to define functions that will apply the requirements described using the types in <em class="italic">Listing 14.31</em> to validate data. Add a file named <code class="inlinecode">validation_functions.ts</code> to the <code class="inlinecode">src/server/api</code> folder with the code shown in <em class="italic">Listing 14.32</em>.</p>
<p class="packt_figref">Listing 14.32: The contents of the validation_functions.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { ValidationError, ValidationRequirements, ValidationRule,
    WebServiceValidation } from "./validation_types";
export type ValidationResult = [valid: boolean, value: any];
export function validate(data: any, reqs: ValidationRequirements): any {
    let validatedData: any = {};
    Object.entries(reqs).forEach(([prop, rule]) =&gt; {
        const [valid, value] = applyRule(data[prop], rule);
        if (valid) {
            validatedData[prop] = value;
        } else {
            throw new ValidationError(prop, "Validation Error");
        }
    });
    return validatedData;
}
function applyRule(val: any,
        rule: ValidationRule): ValidationResult {
    const required = Array.isArray(rule) ? true : rule.required;
    const checks = Array.isArray(rule) ? rule : rule.validation;
    const convert = Array.isArray(rule) ? (v: any) =&gt; v : rule.converter;
    if (val === null || val == undefined || val === "") {
        return [required ? false : true, val];
    }
    let valid = true;
    checks.forEach(check =&gt; {
        if (!check(val)) {
            valid = false;
        }
    });
    return [valid, convert ? convert(val) : val];
}
export function validateIdProperty&lt;T&gt;(val: any,
        v: WebServiceValidation) : any {
    if (v.keyValidator) {
        const [valid, value] = applyRule(val, v.keyValidator);
        if (valid) {
            return value;
        }
        throw new ValidationError("ID", "Validation Error");               
    }
    return val;
}
</code></pre>
<p class="normal">The <code class="inlinecode">validate</code> function accepts a <code class="inlinecode">data</code> object and a <code class="inlinecode">ValidationRequirements</code> object. Each property specified by the <code class="inlinecode">ValidationRequirements</code> object is read from the <code class="inlinecode">data</code> object and validated. The result is an object that contains validated <code class="inlinecode">data</code> that can be trusted by the web service. <code class="inlinecode">ValidationError</code> is thrown if a data property doesn’t meet its validation requirements.</p>
<p class="normal">To <a id="_idIndexMarker750" class="calibre3"/>integrate the validation process as smoothly as possible, I am going to insert a validation layer between the HTTP adapter and the web service. The validation layer will receive the request and response from the adapter, validate the data, and pass it on to the web service. Add a file named <code class="inlinecode">validation_adapter.ts</code> to the <code class="inlinecode">src/server/api</code> folder with the contents shown in <em class="italic">Listing 14.33</em>.</p>
<p class="packt_figref">Listing 14.33: The validation_adapter.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { WebService } from "./http_adapter";
import { validate, validateIdProperty } from "./validation_functions";
import { WebServiceValidation } from "./validation_types";
export class Validator&lt;T&gt; implements WebService&lt;T&gt; {
    constructor(private ws: WebService&lt;T&gt;,
        private validation: WebServiceValidation) {}
    getOne(id: any): Promise&lt;T | undefined&gt; {
        return this.ws.getOne(this.validateId(id));
    }
    getMany(query: any): Promise&lt;T[]&gt; {
        if (this.validation.getMany) {
            query = validate(query, this.validation.getMany);
        }
        return this.ws.getMany(query);
    }
    store(data: any): Promise&lt;T | undefined&gt; {
        if (this.validation.store) {
            data = validate(data, this.validation.store);
        }
        return this.ws.store(data);
    }
    delete(id: any): Promise&lt;boolean&gt; {
        return this.ws.delete(this.validateId(id));
    }
    replace(id: any, data: any): Promise&lt;T | undefined&gt; {
        if (this.validation.replace) {
            data = validate(data, this.validation.replace);
        }
        return this.ws.replace(this.validateId(id), data);
    }
    modify(id: any, data: any): Promise&lt;T | undefined&gt; {
        if (this.validation.modify) {
            data = validate(data, this.validation.modify);
        }
        return this.ws.modify(this.validateId(id), data);
    }
    validateId(val: any) {
        return validateIdProperty(val, this.validation);
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">ID</code> values<a id="_idIndexMarker751" class="calibre3"/> included in URLs are validated using the <code class="inlinecode">validateIdProperty</code> function, and any additional data is validated using the <code class="inlinecode">validate</code> function. If validation fails, <code class="inlinecode">ValidationError</code> will be thrown. <em class="italic">Listing 14.34</em> updates the HTTP adapter to catch exceptions thrown when a request is handled and generates a <code class="inlinecode">400 Bad Request</code> response for validation errors and a <code class="inlinecode">500 Internal Server Error</code> response for any other issue.</p>
<p class="packt_figref">Listing 14.34: Handling validation errors in the http_adapter.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express, Response } from "express";
<strong class="screentext">import { ValidationError } from "./validation_types";</strong>
export interface WebService&lt;T&gt; {
    getOne(id: any) : Promise&lt;T | undefined&gt;;
    getMany(query: any) : Promise&lt;T[]&gt;;
    store(data: any) : Promise&lt;T | undefined&gt;;
    delete(id: any): Promise&lt;boolean&gt;;
    replace(id: any, data: any): Promise&lt;T | undefined&gt;,
    modify(id: any, data: any): Promise&lt;T | undefined&gt;   
}
export function createAdapter&lt;T&gt;(app: Express, ws: WebService&lt;T&gt;, baseUrl: string) {
    // ...routes omitted for brevity...
    const writeErrorResponse = (err: any, resp: Response) =&gt; {
        console.error(err);
       <strong class="screentext"> resp.writeHead(err </strong><strong class="screentext">instanceof ValidationError ? 400 : 500);</strong>
<strong class="screentext">       </strong> resp.end();
    }
}
</code></pre>
<p class="normal">Notice that no details of the validation problem are included in the result sent to the client. It would be possible to send the client a JSON object that describes the validation issues, but in practical terms, clients are rarely able to make sensible use of such information. Validation requirements are encountered during the development process and are best included in the developer documentation so that the client can validate the data received from the user before sending it to the web service. </p>
<p class="normal">Relying on the web service to provide validation errors that can be presented to the user is a problematic process and one that should be avoided, even when the client and web service are written by the same team. When you publish a web service, you<a id="_idIndexMarker752" class="calibre3"/> should expect to provide support to the client-side developers as they consume the functionality you provide.</p>
<h2 class="heading1" id="_idParaDest-253">Defining validation for the Result API</h2>
<p class="normal1">The <a id="_idIndexMarker753" class="calibre3"/>complexity of validation is in the infrastructure, which allows the validation requirements for a web service to be defined concisely. Add a file named <code class="inlinecode">results_api_validation.ts</code> in the <code class="inlinecode">src/server/api</code> folder with the contents shown in <em class="italic">Listing 14.35</em>. </p>
<p class="packt_figref">Listing 14.35: The contents of the results_api_validation.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { ValidationRequirements, ValidationRule,
    WebServiceValidation } from "./validation_types";
import validator from "validator";
const intValidator : ValidationRule = {
    validation: [val =&gt; validator.isInt(val)],
    converter: (val) =&gt; Number.parseInt(val)
}
const partialResultValidator: ValidationRequirements = {
    name: [(val) =&gt; !validator.isEmpty(val)],
    age: intValidator,
    years: intValidator
}
export const ResultWebServiceValidation: WebServiceValidation = {
    keyValidator: intValidator,
    store: partialResultValidator,
    replace: {
        ...partialResultValidator,
        nextage: intValidator
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">ResultWebServiceValidation</code> object defines the <code class="inlinecode">keyValidator</code>, <code class="inlinecode">store</code>, and <code class="inlinecode">replace</code> properties, which indicates that the web service requires its <code class="inlinecode">ID</code> values to be validated, as well as the data used by the <code class="inlinecode">store</code> and <code class="inlinecode">replace</code> methods.</p>
<p class="normal">The <code class="inlinecode">ValidationRule</code> named <code class="inlinecode">intValidator</code> describes validation for integer values, with<a id="_idIndexMarker754" class="calibre3"/> a <code class="inlinecode">validation</code> property that uses the <code class="inlinecode">validator</code> package to ensure a value is an integer and a <code class="inlinecode">converter</code> function that parses the value to a <code class="inlinecode">number</code>. </p>
<p class="normal">The <code class="inlinecode">intValidator</code> is used on its own as the key validator and in the <code class="inlinecode">ValidationRequirements</code> object named <code class="inlinecode">partialResultValidator</code>, which validates the <code class="inlinecode">name</code>, <code class="inlinecode">age</code>, and <code class="inlinecode">years</code> properties that are required by the <code class="inlinecode">store</code> method. The validation requirements for the <code class="inlinecode">replace</code> method extend those used by the <code class="inlinecode">store</code> method by adding a <code class="inlinecode">nextage</code> property.</p>
<p class="normal">This approach to validation allows a web service’s data requirements to be expressed separately from the application of those requirements. <em class="italic">Listing 14.36</em> wraps the web service in its validator.</p>
<p class="packt_figref">Listing 14.36: Applying validation in the index.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { createAdapter } from "./http_adapter";
import { ResultWebService } from "./results_api";
<strong class="screentext">import { Validator } from "./validation_adapter";</strong>
<strong class="screentext">import { ResultWebServiceValidation } from "</strong><strong class="screentext">./results_api_validation";</strong>
export const createApi = (app: Express) =&gt; {
    <strong class="screentext">createAdapter(app, new Validator(new </strong><strong class="screentext">ResultWebService(),</strong>
       <strong class="screentext"> ResultWebServiceValidation), "/api/results");</strong>
}
</code></pre>
<p class="normal">The final change is a small one, which takes advantage of the type conversion performed by the validation system, as shown in <em class="italic">Listing 14.37</em>.</p>
<p class="packt_figref">Listing 14.37: Relying on type conversion in the results_api.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">...
async store(data: any): Promise&lt;Result | undefined&gt; {
    const { name, age, years} = data;
   <strong class="screentext"> //const nextage = Number.parseInt(age) + Number.parseInt(years);</strong>
<strong class="screentext">    const nextage = age + years;  </strong>     
    const id = await repository.saveResult({ id: 0, name, age,
        years, nextage});
    return await repository.getResultById(id);       
}
...
</code></pre>
<p class="normal">The <code class="inlinecode">store</code> method <a id="_idIndexMarker755" class="calibre3"/>won’t be called unless the <code class="inlinecode">age</code> and <code class="inlinecode">years</code> buttons have been converted to <code class="inlinecode">number</code> values, which means that the <code class="inlinecode">store</code> method doesn’t need to perform its own conversions.</p>
<p class="normal">To test validation, select the command-line client’s Get <code class="inlinecode">ID</code> option and enter <code class="inlinecode">ABC</code> when prompted. The validation check will reject this value, and produce a <code class="inlinecode">400 Bad Request</code> response, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Select an operation Get ID
? ID? ABC
400 Bad Request
...
</code></pre>
<p class="normal">Select the <strong class="screentext">Store</strong> option and enter <code class="inlinecode">Joe</code>, <code class="inlinecode">30</code>, and <code class="inlinecode">Ten</code> when prompted. The last value fails validation and causes another <code class="inlinecode">400</code> response.</p>
<h2 class="heading1" id="_idParaDest-254">Performing model validation</h2>
<p class="normal1">Not all <a id="_idIndexMarker756" class="calibre3"/>validation can be done before the request is passed to the web service method that will generate a response. One example is PATCH requests, where the client can send partial updates that may lead to inconsistent data in the database, such as providing a new <code class="inlinecode">years</code> value without a corresponding <code class="inlinecode">nextage</code> value, so that the calculation result doesn’t make sense. </p>
<p class="normal">Validating this kind of update cannot be done until the update has been applied to the existing stored data, which means that it must be done by the web service method, which is the earliest point in the update process where the changes and the stored data are both available. This is often known as <em class="italic">model validation</em>, although there is no consistent terminology.</p>
<p class="normal"><em class="italic">Listing 14.38</em> defines a new data type that combines the existing validation with a <a id="_idIndexMarker757" class="calibre3"/>new rule that applies to the entire data model object.</p>
<p class="packt_figref">Listing 14.38: Adding a type in the validation_types.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">export interface WebServiceValidation  {
    keyValidator?: ValidationRule;
    getMany?: ValidationRequirements;
    store?: ValidationRequirements;
    replace?: ValidationRequirements;
    modify?: ValidationRequirements;
}
export type ValidationRequirements = {
    [key: string] : ValidationRule
}
export type ValidationRule =
    ((value: any) =&gt; boolean)[] |
    {
        required? : boolean,
        validation: ((value: any) =&gt; boolean)[],
        converter?: (value: any) =&gt; any,
    }
export class ValidationError implements Error {
    constructor(public name: string, public message: string) {}
    stack?: string | undefined;
    cause?: unknown;
}
<strong class="screentext">export type ModelValidation = {</strong>
<strong class="screentext">    modelRule?: ValidationRule,</strong>
<strong class="screentext">    propertyRules?: ValidationRequirements</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal"><em class="italic">Listing 14.39</em> uses the <code class="inlinecode">ModelValidation</code> type in a new function that can be used to <a id="_idIndexMarker758" class="calibre3"/>validate an object before it is stored.</p>
<p class="packt_figref">Listing 14.39: Adding a function in the validation_functions.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { ModelValidation, ValidationError, ValidationRequirements</strong><strong class="screentext">,</strong>
<strong class="screentext">    ValidationRule, WebServiceValidation } from "./validation_types";</strong>
export type ValidationResult = [valid: boolean, value: any];
// ...functions omitted for brevity...
<strong class="screentext">export function validateModel(model: any, rules: ModelValidation) : any {</strong>
<strong class="screentext">    if (rules.propertyRules) {</strong>
<strong class="screentext">        model = validate(model, rules.propertyRules);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    if (rules.modelRule) {</strong>
<strong class="screentext">        </strong><strong class="screentext">const [valid, data] = applyRule(model, rules.modelRule);</strong>
<strong class="screentext">        if (valid) {</strong>
<strong class="screentext">            return data;</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">        throw new ValidationError("Model", "Validation Error");                       </strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">validateModel</code> function applies the rules for each property and then applies the model-wide rule. The property rules may perform type conversions and so the result from the property checks is used as the input for the model-wide validation. <em class="italic">Listing 14.40</em> defines the validation required for a <code class="inlinecode">Result</code> object.</p>
<p class="packt_figref">Listing 14.40: Defining a model validator in the result_api_validation.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { ModelValidation, ValidationRequirements, ValidationRule,</strong>
<strong class="screentext">    WebServiceValidation } from "</strong><strong class="screentext">./validation_types";</strong>
import validator from "validator";
const intValidator : ValidationRule = {
    <strong class="screentext">validation: [val =&gt; validator.isInt(val.</strong><strong class="screentext">toString())],</strong>
    converter: (val) =&gt; Number.parseInt(val)
}
const partialResultValidator: ValidationRequirements = {
    name: [(val) =&gt; !validator.isEmpty(val)],
    age: intValidator,
    years: intValidator
}
export const ResultWebServiceValidation: WebServiceValidation = {
    keyValidator: intValidator,
    store: partialResultValidator,
    replace: {
        ...partialResultValidator,
        nextage: intValidator
    }
}
<strong class="screentext">export const ResultModelValidation : ModelValidation = {</strong>
<strong class="screentext">    propertyRules: { ...partialResultValidator, nextage: intValidator },</strong>
<strong class="screentext">    modelRule</strong><strong class="screentext">: [(m: any) =&gt; m.nextage === m.age + m.years]</strong>
<strong class="screentext">}</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">propertyRules</code> property <a id="_idIndexMarker759" class="calibre3"/>uses the validation rules created for earlier examples. The <code class="inlinecode">modelRule</code> property checks to see that the <code class="inlinecode">nextage</code> value is the sum of the <code class="inlinecode">age</code> and <code class="inlinecode">years</code> properties.</p>
<p class="normal">A small change is required to the rule used to validate integers. The <code class="inlinecode">isInt</code> method provided by the <code class="inlinecode">validator</code> package only operates on string values, but a partial update may combine the <code class="inlinecode">string</code> values received from the HTTP request with <code class="inlinecode">number</code> values read from the database. To avoid exceptions, the value being checked is always converted to a string.</p>
<p class="normal"><em class="italic">Listing 14.41</em> updates the web service to use the model validation feature for the <code class="inlinecode">replace</code> and <code class="inlinecode">modify</code> methods, ensuring that inconsistent data isn’t written to the database.</p>
<p class="packt_figref">Listing 14.41: Validating data in the results_api.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { WebService } from "./http_adapter";
import { Result } from "../data/repository";
import repository from "../data";
import * as jsonpatch from "fast-json-patch";
<strong class="screentext">import { validateModel } from "./validation_functions";</strong>
<strong class="screentext">import { ResultModelValidation } from "./results_api_validation"</strong><strong class="screentext">;</strong>
export class ResultWebService implements WebService&lt;Result&gt; {
    getOne(id: any): Promise&lt;Result | undefined&gt; {
        <strong class="screentext">return repository.getResultById(id);</strong>
    }
    getMany(query: any): Promise&lt;Result[]&gt; {
        if (query.name) {
            return repository.getResultsByName(query.name, 10);
        } else {
            return repository.getAllResults(10);
        }
    }
    async store(data: any): Promise&lt;Result | undefined&gt; {
        const { name, age, years} = data;
        const nextage = age + years;
        const id = await repository.saveResult({ id: 0, name, age,
            years, nextage});
        return await repository.getResultById(id);       
    }
    delete(id: any): Promise&lt;boolean&gt; {
        return repository.delete(Number.parseInt(id));
    }
    replace(id: any, data: any): Promise&lt;Result | undefined&gt; {
        const { name, age, years, nextage } = data;
        <strong class="screentext">const validated = validateModel</strong><strong class="screentext">({ name, age, years, nextage },</strong>
<strong class="screentext">            ResultModelValidation)</strong>
<strong class="screentext">        return repository.update({ id, ...validated });</strong>
    }
    async modify(id: any, data: any): Promise&lt;Result | undefined&gt; {
        const dbData = await this.getOne(id);
        if (dbData !== undefined) {
            return await this.replace(id,
                jsonpatch.applyPatch(dbData, data).newDocument);
        }
    }
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker760" class="calibre3"/>validation can be performed in the <code class="inlinecode">replace</code> method, which allows replacements and updates to be validated consistently.</p>
<p class="normal">Select the command-line client’s <code class="inlinecode">Replace</code> option and enter <code class="inlinecode">1</code>, <code class="inlinecode">Joe</code>, <code class="inlinecode">20</code>, <code class="inlinecode">10</code>, and <code class="inlinecode">25</code> when prompted. This is invalid data because the <code class="inlinecode">nextage</code> value should be <code class="inlinecode">30</code>, so the validation process fails and a <code class="inlinecode">400 Bad Request</code> response is produced, like this:</p>
<pre class="programlisting1"><code class="hljs-con">...
? Select an operation Replace
? ID? 1
? Name? Joe
? Age? 20
? Years? 10
? Next Age? 25
400 Bad Request
...
</code></pre>
<p class="normal">The combination of request and model validation ensures that the web service only receives and stores valid data, while the abstracted HTTP and validation features help simplify the web service implementation so that it is easier to understand and maintain.</p>
<h1 class="heading" id="_idParaDest-255">Using a package for web services</h1>
<p class="normal1">There are excellent packages available for creating web services, although the lack of standardization means that you have to find one that suits your preferences about how web services should function, which may be different from the approach I have taken in this chapter. I like the <a id="_idIndexMarker761" class="calibre3"/>Feathers package (<a href="https://feathersjs.com" class="calibre3">https://feathersjs.com</a>), which works similarly to the custom code in this chapter and has good integrations with popular databases <a id="_idIndexMarker762" class="calibre3"/>and other packages, including Express. </p>
<p class="normal">But there are plenty of good packages available, and a good tip is to search for microservices, which has become such a hot term that some packages position themselves as being part of the microservices ecosystem.</p>
<p class="normal">Run the commands shown in <em class="italic">Listing 14.42</em> in the <code class="inlinecode">part2app</code> folder to install the Feathers package and the integrations with Express. </p>
<p class="packt_figref">Listing 14.42: Installing packages</p>
<pre class="programlisting1"><code class="hljs-con">npm install @feathersjs/feathers@5.0.14
npm install @feathersjs/express@5.0.14
</code></pre>
<p class="normal">The <a id="_idIndexMarker763" class="calibre3"/>Feathers packages contain TypeScript type declarations, but they override the declarations for the Express package. A change to the compiler configuration is required to work around this issue, as shown in <em class="italic">Listing 14.43</em>.</p>
<p class="packt_figref">Listing 14.43: Changing the compiler configuration in the tsconfig.json file in the part2app folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "extends": "@tsconfig/node20/tsconfig.json",
     "compilerOptions": {                      
         "rootDir": "src/server",  
         "outDir": "dist/server/",
         <strong class="screentext">"noImplicitAny": false</strong>
     },
     "include": ["src/server/**/*"]
}
</code></pre>
<p class="normal">The Feathers integration with Express works by extending the existing API, and the type declarations that the package provides are different from those provided by the <code class="inlinecode">@types/express</code> package.</p>
<h2 class="heading1" id="_idParaDest-256">Creating an adaptor for web services</h2>
<p class="normal1">The <a id="_idIndexMarker764" class="calibre3"/>Feathers package describes web <a id="_idIndexMarker765" class="calibre3"/>services using a series of methods, similar to the interface used by the custom code earlier in the chapter. There are some small differences, but the two approaches are similar enough that a simple adapter will allow the custom HTTP-handling code to be replaced with the Feathers package, without needing to make changes to the web service. Add a file named <code class="inlinecode">feathers_adapter.ts</code> to the <code class="inlinecode">src/server/api</code> folder with the contents shown in <em class="italic">Listing 14.44</em>.</p>
<p class="packt_figref">Listing 14.44: The contents of the feathers_adapter.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Id, NullableId, Params } from "@feathersjs/feathers";
import { WebService } from "./http_adapter";
export class FeathersWrapper&lt;T&gt; {
       
    constructor(private ws: WebService&lt;T&gt;) {}
    get(id: Id) {
        return this.ws.getOne(id);
    }
    find(params: Params) {
        return this.ws.getMany(params.query);
    }
    create(data: any, params: Params) {
        return this.ws.store(data);
    }
    remove(id: NullableId, params: Params) {
        return this.ws.delete(id);
    }  
    update(id: NullableId, data: any, params: Params) {
        return this.ws.replace(id, data);
    }
    patch(id: NullableId, data: any, params: Params) {
        return this.ws.modify(id, data);
    }
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker766" class="calibre3"/>Feathers API provides types that<a id="_idIndexMarker767" class="calibre3"/> represent <code class="inlinecode">ID</code> values, request bodies, and query parameters, but there are only so many ways an HTTP request can be represented, so it is a simple process to bridge between the Feathers package and the custom code. Later examples will use the Feathers API directly, but this approach demonstrates how easy it is to adapt existing code to work with third-party packages.</p>
<p class="normal">The Feathers integration with Express assumes that Feathers will extend the Express API to add features. <em class="italic">Listing 14.45</em> uses the Feathers functionality to create a web service without changing the rest of the application.</p>
<p class="packt_figref">Listing 14.45: Using Feathers in the index.ts file in the src/server/api folder</p>
<pre class="programlisting"><code class="hljs-code">import { Express } from "express";
import { createAdapter } from "./http_adapter";
import { ResultWebService } from "./results_api";
import { Validator } from "./validation_adapter";
import { ResultWebServiceValidation } from "./results_api_validation";
<strong class="screentext">import</strong><strong class="screentext"> { FeathersWrapper } from "./feathers_adapter";</strong>
<strong class="screentext">import { feathers } from "@feathersjs/feathers";</strong>
<strong class="screentext">import feathersExpress, { rest } from "@feathersjs/express";</strong>
<strong class="screentext">import</strong><strong class="screentext"> { ValidationError } from "./validation_types";</strong>
export const createApi = (app: Express) =&gt; {
    <strong class="screentext">// createAdapter(app, new Validator(new ResultWebService(),</strong>
<strong class="screentext">    //     ResultWebServiceValidation), "/api/results");</strong>
<strong class="screentext">    const feathersApp = feathersExpress(feathers(), app).configure(rest());</strong>
<strong class="screentext">    const service = new Validator(</strong><strong class="screentext">new ResultWebService(),</strong>
<strong class="screentext">        ResultWebServiceValidation);</strong>
<strong class="screentext">    feathersApp.use('/api/results', new FeathersWrapper(service));</strong>
<strong class="screentext">    feathersApp.hooks({</strong>
<strong class="screentext">        </strong><strong class="screentext">error: {</strong>
<strong class="screentext">            all: [(ctx) =&gt; {                       </strong>
<strong class="screentext">                    if (ctx.error instanceof ValidationError) {</strong>
<strong class="screentext">                        ctx.http = { status: </strong><strong class="screentext">400};</strong>
<strong class="screentext">                        ctx.error = undefined;</strong>
<strong class="screentext">                    }</strong>
<strong class="screentext">                }]</strong>
<strong class="screentext">        }</strong>
<strong class="screentext">    });</strong>
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker768" class="calibre3"/>enhanced version of Express is created by <a id="_idIndexMarker769" class="calibre3"/>this statement:</p>
<pre class="programlisting"><code class="hljs-code">...
const feathersApp = feathersExpress(feathers(), app).configure(rest());
...
</code></pre>
<p class="normal">This incantation enables Feathers and configures it to support RESTful queries. Feathers can be used in different ways, and RESTful requests are only one of the ways that clients can communicate with Feathers’ server-side components.</p>
<p class="normal">Feathers <a id="_idIndexMarker770" class="calibre3"/>supports <em class="italic">hooks</em>, which allow functions<a id="_idIndexMarker771" class="calibre3"/> to be executed at key moments in the request life cycle. Hooks are a useful feature and can be used for tasks <a id="_idIndexMarker772" class="calibre3"/>including validation and error handling. Validation is handled by the custom code in this example, but this statement defines a hook that will be invoked when an exception is thrown while handling a request:</p>
<pre class="programlisting"><code class="hljs-code">...
feathersApp.hooks({
    error: {
        all: [(ctx) =&gt; {
            if (ctx.error instanceof ValidationError) {
                ctx.http = { status: 400};
                ctx.error = undefined;
            }
        }]
    }
});
...
</code></pre>
<p class="normal">The custom code throws <code class="inlinecode">ValidationError</code> when validation fails, which Feathers handles by sending a 500 response. Hooks receives a context object that provides details of the request and its outcome, and this statement changes the response status code if <code class="inlinecode">ValidationError</code> has occurred. There is no change in the way the web service works because it uses the same custom code-handling requests. But, having seen how RESTful web services operate and how they can be created, moving to a package such as Feathers allows the same features to be utilized without the need for custom code.</p>
<h1 class="heading" id="_idParaDest-257">Summary</h1>
<p class="normal1">In this chapter, I demonstrated how the HTTP features provided by Node.js and enhanced by the Express package, can be used to create a RESTful web service.</p>
<ul class="calibre4">
<li class="bulletlist">The HTTP request URL identifies the data and the HTTP method denotes the operation that will be performed.</li>
<li class="bulletlist1">The JSON format is used by most web services, which has replaced XML as the default data format.</li>
<li class="bulletlist1">There is little standardization in the way that web services are implemented, although there are some common conventions that are widely used, particularly relating to the operations that HTTP methods represent.</li>
<li class="bulletlist1">The data received by web services must be validated before it can be safely used.</li>
<li class="bulletlist1">Web services are most easily written by separating the implementation from the code that handles HTTP requests and performs validation.</li>
</ul>
<p class="normal">In the next chapter, I will demonstrate how HTTP requests can be authenticated and how the user’s identity can be used for authorization.</p>
</div>
</body></html>