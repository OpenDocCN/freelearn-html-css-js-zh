<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Building a Podcast Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Building a Podcast Application</h1></div></div></div><p>In this chapter, there will be an interesting twist. All the applications we have built so far have been pretty heavy on the client code, but rather light on the server. The truth is, the web applications you're going to build aren't always going to be this way. Often, you'll have to perform a lot of heavy lifting on the backend as well as on the frontend; and the application we're going to build here will be this way.</p><p>So, in this chapter, we'll focus on the following ideas:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building an application that is both server- and client-intensive</li><li class="listitem" style="list-style-type: disc">Duplicating some of Marionette's functionality, without using Marionette</li><li class="listitem" style="list-style-type: disc">Parsing and simplifying a data file before storing it</li></ul></div><div class="section" title="What are we building?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>What are we building?</h1></div></div></div><p>In this chapter, we'll be <a id="id388" class="indexterm"/>building a podcast-listening application. As you probably know, a podcast feed is very similar to a regular blog's RSS feed. The primary difference is what the fields are; so, even though we're building a basic podcast <span class="strong"><strong>catcher</strong></span><a id="id389" class="indexterm"/>, a lot of it could go towards building <a id="id390" class="indexterm"/>a regular RSS reader. So, here's what we will have: people can make accounts for our application, and then subscribe to podcast feeds. We'll load in all existing episodes, and users can listen to them and see the show notes and links right in our app. Each time a user opens the application, each of the podcasts they subscribe to will be checked for new episodes. They'll be able to listen to episodes, or just mark them as listened to. </p><p>Here's a look at the completed project:</p><div class="mediaobject"><img src="graphics/6997OS_06_04.jpg" alt="What are we building?"/></div><p>It doesn't sound<a id="id391" class="indexterm"/> or look like a lot, maybe, but there's a lot to do, so let's get started.</p></div></div>
<div class="section" title="Building user accounts"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>Building user accounts</h1></div></div></div><p>We'll start<a id="id392" class="indexterm"/> with user accounts. You'll remember that in <a class="link" href="ch02.html" title="Chapter 2. Building a Photo-sharing Application">Chapter 2</a>, <span class="emphasis"><em>Building a Photo-sharing Application</em></span>, when we built<a id="id393" class="indexterm"/> the photo sharing application, we created a <code class="literal">signin.js</code> file; we'll want to use that here. We can set this up by following these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy the template directory to create a new project, and then copy the <code class="literal">signin.js</code> file into the new directory. You'll want to add the following line to the top of the <code class="literal">server.js</code> file:<div class="informalexample"><pre class="programlisting">var signin   = require("./signin");</pre></div></li><li class="listitem">Now, as you might recall, this requires a few more Node.js packages. Go ahead and install <code class="literal">passport</code>, <code class="literal">passport-local</code>, and <code class="literal">bcrypt</code> by using the following command in the terminal:<div class="informalexample"><pre class="programlisting">npm install bcrypt passport passport-local --save</pre></div></li><li class="listitem">The <code class="literal">bcrypt</code> and <code class="literal">passport-local</code> packages are used in the <code class="literal">sigin.js</code> file, but we require <code class="literal">passport</code> in the <code class="literal">server.js</code> file; we'll also create the <code class="literal">users</code> database, as you can see here:<div class="informalexample"><pre class="programlisting">var passport = require("passport");
var users    = new Bourne("users.json");</pre></div></li><li class="listitem">Then, <a id="id394" class="indexterm"/>we need to make<a id="id395" class="indexterm"/> sure our express application is configured for this. Here's the complete <code class="literal">configure</code> block that we saw in our photo sharing application:<div class="informalexample"><pre class="programlisting">app.configure(function () {
  app.use(express.urlencoded());
  app.use(express.json());
  app.use(express.multipart());
  app.use(express.cookieParser());
  app.use(express.session({ secret: 'podcast-app' }));
  app.use(passport.initialize());
  app.use(passport.session());
  app.use(express.static('public'));
});</pre></div></li><li class="listitem">Next, we configure <code class="literal">passport</code> to use the methods that we have in our <code class="literal">signin.js</code> file:<div class="informalexample"><pre class="programlisting">passport.use(signin.strategy(users));
passport.serializeUser(signin.serialize);
passport.deserializeUser(signin.deserialize(users));</pre></div></li><li class="listitem">We need to create the routes for logging in, logging out, and making user accounts. If the user is getting the <code class="literal">/login</code> route, we'll render the <code class="literal">login.ejs</code> (coming soon) file. Once they enter a username and password, the results will be saved to the <code class="literal">/login</code> route with the help of the POST request, where authentication will occur. Then, to log out at <code class="literal">/logout</code>, we'll call the <code class="literal">logout</code> method that <code class="literal">passport</code> has added to the request object, and redirect back to the root. So, here are the routes:<div class="informalexample"><pre class="programlisting">app.get("/login", function (req, res) {
  res.render("login.ejs");
});

app.post('/login', passport.authenticate('local', {
  successRedirect: '/',
  failureRedirect: '/login'
}));

app.get("/logout", function (req, res) {
  req.logout();
  res.redirect('/');
});</pre></div></li><li class="listitem">The last <a id="id396" class="indexterm"/>route related to user accounts is the <code class="literal">/create</code> route; this is the route that will be used to create<a id="id397" class="indexterm"/> new accounts. It's a lot of code, but it's pretty basic. We create an attributes object with the username and hashed password. Then, we check to see if the user exists. If they do, we go back to the root route. Otherwise, we'll create the user account and redirect to the root route, the difference being that we are now logged in. The following is the code for the <code class="literal">/create</code> route:<div class="informalexample"><pre class="programlisting">app.post('/create', function (req, res, next) {
  var userAttrs = {
    username: req.body.username,
    passwordHash: signin.hashPassword(req.body.password)
  };
  users.findOne({ username: userAttrs.username }, 
    function (existingUser) {
      if (!existingUser) {
        users.insert(userAttrs, function (err, user) {
          req.login(user, function (err) {
            res.redirect("/");
          });
        });
      } else {
        res.redirect("/");
      }
    });
});</pre></div></li><li class="listitem">The final flare for this portion is the <code class="literal">login.ejs</code> file, in the <code class="literal">views</code> directory. As you'll see, from all the extra classes and wrapping elements, we will use Twitter Bootstrap again. However, this time, we'll not use the default version. You can go to<a id="id398" class="indexterm"/> Bootswatch (<a class="ulink" href="http://bootswatch.com">http://bootswatch.com</a>) to find other themes based on Bootstrap; all the same classes, but different styling. This way, you can choose any theme from Bootswatch that you'd like and get a different skin to your application, but you don't need to change the HTML code at all. I'm going to choose the Simplex theme (<a class="ulink" href="http://bootswatch.com/simplex">http://bootswatch.com/simplex</a>), but you can choose a different one if you prefer. Download the CSS file and add it to the <code class="literal">public</code> directory. As you can see <a id="id399" class="indexterm"/>from the <a id="id400" class="indexterm"/>following template, we'll also have our own style sheet, <code class="literal">style.css</code> of the <code class="literal">public</code> directory, for a few customizations. We'll add to this file later. <p>Here's what should go inside the <code class="literal">login.ejs</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;&lt;/title&gt;
    &lt;link rel="stylesheet"  href="/bootstrap.min.css" /&gt;
    &lt;link rel="stylesheet"  href="/style.css" /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class='container'&gt;
&lt;div class='row'&gt;
  &lt;h1&gt; Sign In &lt;/h1&gt;
  &lt;form method="post" action="/login"&gt;
    &lt;div class='form-group'&gt;
      &lt;label&gt;Username&lt;/label&gt;
      &lt;input name='username' type='text' class='form-control' /&gt;
    &lt;/div&gt;
    &lt;div class='form-group'&gt;
      &lt;label&gt;Password&lt;/label&gt;
      &lt;input name='password' type='password' class='form-control' /&gt;
    &lt;/div&gt;
    &lt;button class='btn btn-primary'&gt; Login &lt;/button&gt;
  &lt;/form&gt;

  &lt;h1&gt; Create Account &lt;/h1&gt;
  &lt;form method="post" action="/create"&gt;
    &lt;div class='form-group'&gt;
      &lt;label&gt;Username&lt;/label&gt;
      &lt;input name='username' type='text' class='form-control' /&gt;
    &lt;/div&gt;
    &lt;div class='form-group'&gt;
      &lt;label&gt;Password&lt;/label&gt;
      &lt;input name='password' type='password' class='form-control' /&gt;
    &lt;/div&gt;
    &lt;button class='btn btn-primary'&gt; Create &lt;/button&gt;
  &lt;/form&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">The next <a id="id401" class="indexterm"/>step is the root/catch-all route. If a user is logged in, we'll render the <code class="literal">index.ejs</code> file;<a id="id402" class="indexterm"/> otherwise, we'll have to redirect to <code class="literal">/login</code>. This is a good first version of the root route; if the <code class="literal">req.user</code> value is not set, we'll redirect to the login page. Otherwise, we'll render the index template. Here's the code for this route:<div class="informalexample"><pre class="programlisting">app.get('/*', function (req, res) {
  if (!req.user) {
    res.redirect("/login");
    return;
  }
  res.render('index.ejs', { 
    username: req.user.username
  });
});</pre></div></li></ol></div></div>
<div class="section" title="Subscribing to and storing podcasts"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Subscribing to and storing podcasts</h1></div></div></div><p>This application <a id="id403" class="indexterm"/>is a little different from our previous applications in terms of the data that we need to store. Before, we've always stored only data that we get from the user. This time, a user is only going to give us a URL—the path to a podcast feed—and we have to get all the data from that. Then, later, we need to check that same source for updates. This requires a lot more work on our part.</p><p>You might be thinking <a id="id404" class="indexterm"/>about how we're going to get this podcast data. Of course, there are only two places from which we can pull in this data: the client and the server. Both are possible; however, things will go a lot more smoothly if we choose to get this data on the server side. Here's why: to prepare the data on the client side would require us to first get the feed (which is a little more than simple, because it's a cross-domain request); then, we have to parse that to get the podcast and episode data we need, before sending the data back to the server for storage. This could take a rather long time, especially if the podcast has many episodes. If the user closes the application during <a id="id405" class="indexterm"/>this process, <a id="id406" class="indexterm"/>all or part of the data will be lost, and things could get messy. It's much better to do all that work on the server side, where the processing can continue even if the user closes their browser tab. So, we will focus on data processing next.</p><p>Now, there's going to be a fair bit of code involved in getting the podcast data, so we're going to create a custom Node.js module especially to work with podcasts. So, create a <code class="literal">podcasts.js</code> file in the project directory, and let's get started.</p><p>First off, there are two other Node.js packages that we are going to use in this module:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>xml2js</strong></span> (<a class="ulink" href="https://www.npmjs.org/package/xml2js">https://www.npmjs.org/package/xml2js</a>) will <a id="id407" class="indexterm"/>allow us to<a id="id408" class="indexterm"/> convert the podcast feed XML into JSON; it really won't be pretty JSON, but it will be usable.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>q</strong></span> (<a class="ulink" href="https://www.npmjs.org/package/q">https://www.npmjs.org/package/q</a>) is an <a id="id409" class="indexterm"/>asynchronous <a id="id410" class="indexterm"/>promises library.</li></ul></div><p>So, install these two packages by executing this command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install q xml2js --save</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>If you haven't worked with promises before, you can think about them like this: often in JavaScript, you'll pass a callback to a function call so that the function can be run after some data is ready; a <span class="strong"><strong>promise</strong></span> is an object that encapsulates that expected data. You can pass that promise object around and add multiple callbacks to it, all of which will be run when the data is ready. You can even add callbacks after the data is ready (of course, those will be run right away). For a really good introduction and explanation of promises, I recommend you check out the great article <span class="emphasis"><em>JavaScript Promises ... In Wicked Detail</em></span> by Matt Greer (<a class="ulink" href="http://mattgreer.org/articles/promises-in-wicked-detail/">http://mattgreer.org/articles/promises-in-wicked-detail/</a>). It will explain their benefits and how to use them.</p></div></div><p>In the <code class="literal">podcasts.js</code> file, we'll require the following libraries:</p><div class="informalexample"><pre class="programlisting">var http        = require('http');
var Bourne      = require('bourne');
var Q           = require('q');
var parseString = require('xml2js').parseString;
var pcdb = new Bourne('podcasts.json');
var epdb = new Bourne('episodes.json');</pre></div><p>We require the native-to-Node.js <code class="literal">http</code> library so that we can make a request for the podcast feed file. Also, we will create two Bourne databases here: one for podcasts, and the other for episodes. We won't even need to access these databases from the <code class="literal">server.js</code> file.</p><p>The following is the first method we'll write for getting the actual feed file:</p><div class="informalexample"><pre class="programlisting">function get (url) {
  var deferred = Q.defer();
  var req = http.get(url, function (res) {
    var xml = '';
    res.on('data', function (chunk) {
      xml += chunk;
    });
    res.on('end', function () {
      deferred.resolve(xml);
    });
  });
  return deferred.promise;
};</pre></div><p>The method takes a URL and passes it to the <code class="literal">http.get</code> method. The callback we give to that method <a id="id411" class="indexterm"/>gets a response object. We can listen <a id="id412" class="indexterm"/>for the <code class="literal">data</code> event on that object and concatenate the data into a string, which we'll name <code class="literal">xml</code>. Then, when the request is finished (signaled by the <code class="literal">end</code> event), we use the XML string to resolve the <code class="literal">deferred</code> object we create at the top of the method. At the end of the method, we return the <code class="literal">promise</code> object for our <code class="literal">deferred</code> object. Now, we can use this method as shown in the following code:</p><div class="informalexample"><pre class="programlisting">get('http://podcast.com/feed.xml').then(function (xml) {
  // use the xml
});</pre></div><p>The <code class="literal">promise</code> object we return has a <code class="literal">then</code> method. The value that we pass to the <code class="literal">deferred</code> object's <code class="literal">resolve</code> method will be passed as a parameter to the function we pass to the <code class="literal">then</code> method when the request is complete. So this is how we get the XML data for a podcast. Now, we need to convert it to JSON and get the values that we want. The <code class="literal">parse</code> function looks like this:</p><div class="informalexample"><pre class="programlisting">function parse(xml) {
  var deferred = Q.defer();
  parseString(xml, function (err, result) {
    var rss = result.rss.channel[0];
    var episodes = rss.item.map(function (item) {
      return {
        title:       item.title[0],
        duration:    item['itunes:duration'][0],
        audio:       item.enclosure[0].$.url,
        link:        item.link[0],
        description: item['content:encoded'][0], 
        pubDate:     item.pubDate[0],
        listened:    false
      };
    });

    var info = {
      title: rss.title[0],
      link:  rss.link[0],
      image: rss['itunes:image'][0].$.href,
      lastUpdated: +new Date()
    };

    deferred.resolve({ info: info, episodes: episodes });
  });
  return deferred.promise;
}</pre></div><p>The <code class="literal">parse</code> function<a id="id413" class="indexterm"/> takes the XML input. We pass the XML input to the <code class="literal">parseString</code> function<a id="id414" class="indexterm"/> from <code class="literal">xml2js</code> to convert it to JSON. Then, we can start pulling the data we want out of the result. <a id="id415" class="indexterm"/>Unfortunately, <code class="literal">xml2js</code> doesn't give us a very clean JSON structure to work with; almost every value is an array, but most <a id="id416" class="indexterm"/>only have a single value in them. That's why we get the first element of an array in every case. Where the element has attributes instead of child elements, <code class="literal">xml2js</code> uses a property named <code class="literal">$</code>. Once we get the general information about the podcast and the data for each episode, we put them into an object that goes to resolving another promise.</p><p>With these two methods in place, we can now create a <code class="literal">Podcast</code> constructor function as a handy wrapper that is used to manage an individual podcast. This constructor function will need to work in two ways to be most useful in our <code class="literal">server.js</code> file. If we pass it a URL, it will assume we're creating a new podcast record, and will get and store the data. However, if we pass it a number, if will assume that the number is the ID of an already-stored podcast, and get that out of the database. Since storing and fetching this data will be asynchronous operations, we'll use promises to wait for the right time to act.</p><p>So, the <code class="literal">Podcast</code> constructor is a rather large function; we'll take it piece by piece. We will start with the following code:</p><div class="informalexample"><pre class="programlisting">function Podcast(feed, userId) {
  var self      = this;
  var info      = Q.defer();
  var episodes  = Q.defer();
  this.info     = info.promise;
  this.episodes = episodes.promise;
  this.ready    = Q.all([this.info, this.episodes]);
}</pre></div><p>The <code class="literal">feed</code> parameter will be either the URL or the ID, as we discussed earlier. The <code class="literal">userId</code> parameter will be the ID of the user who is subscribing to this podcast. Then, we'll create two <a id="id417" class="indexterm"/>deferred objects called <code class="literal">info</code> and <code class="literal">episodes</code>. We assign their promises as properties of the object we will create with <a id="id418" class="indexterm"/>this function so that we can use them when they are ready. We'll also create a <code class="literal">ready</code> property; this is another promise object that will resolve when all the promises we pass it in an array are resolved. This makes for a nice convenient way to do something when both the <code class="literal">info</code> and <code class="literal">episodes</code> promises are ready. You can see this in the following code, which is the next part of the <code class="literal">Podcast</code> function:</p><div class="informalexample"><pre class="programlisting">if (typeof feed === 'string') {
  get(feed).then(parse).then(function (data) {
    data.info.userId = userId;
    data.info.feed = feed;

    pcdb.insert(data.info, function (err, data) {
      info.resolve(data);
    });

    self.info.then(function (record) {
      data.episodes.forEach(function (e) {
        e.podcastId = record.id;
      });

      epdb.insertAll(data.episodes, function (err, records) {
        episodes.resolve(records);            
      });
    });
  });
}</pre></div><p>If the type of the parameter <code class="literal">feed</code> is a string, we know that we're creating a new podcast record. We'll get and parse the feed, using the methods we created earlier. Then, we add the feed URL and the <code class="literal">userId</code> parameter to the <code class="literal">info</code> property of the data we get back. This <code class="literal">info</code> property is now ready to be stored in the database. We'll store it in <code class="literal">pcdb</code>, the podcasts' database. In the callback for that, we'll resolve the <code class="literal">info</code> deferred object, because the <code class="literal">info</code> property has now been stored (this means our podcast record has an ID in our database).</p><p>One of the <a id="id419" class="indexterm"/>beautiful things about promises is that we can have multiple <code class="literal">then</code> calls to them. So, even though we created the <code class="literal">this.info</code> promise <a id="id420" class="indexterm"/>to be used outside the podcast object, we can wait for its resolution inside as well. That's the next step. When the <code class="literal">info</code> promise resolves, we need to store the episodes. You can see why it's important to wait until the podcast record is stored; we need to add the podcast's ID as the <code class="literal">podcastID</code> property to each episode object. </p><p>Once we have done that, we can insert all the records into the <code class="literal">episodes</code> database, and then use them to resolve the <code class="literal">episodes</code> promise.</p><p>Here's what we do if the <code class="literal">feed</code> parameter isn't a string:</p><div class="informalexample"><pre class="programlisting">else {
  pcdb.findOne({ id: feed }, function (err, record) {
    info.resolve(record);
  });

  epdb.find({ podcastId: feed }, function (err, records) {
    episodes.resolve(records);
  });
}</pre></div><p>If the <code class="literal">feed</code> parameter is not a string, then we have created this podcast record previously, and we need to find it. We start by finding the podcast by that ID, and resolve the <code class="literal">info</code> promise. Then, we find all the episodes with that <code class="literal">podcastID</code> property and use them to resolve the <code class="literal">episodes</code> promise. Believe it or not, that's all we need to do for our <code class="literal">Podcast</code> constructor.</p><p>Next, we'll need to be able to check the feed for new episodes. So for this, we'll need an <code class="literal">update</code> method. This method is a little long and involved, and it actually doesn't do anything too complex. Here's the outer shell:</p><div class="informalexample"><pre class="programlisting">Podcast.prototype.update = function () {
  var deferred = Q.defer();
  this.ready.spread(function (info, oldEpisodes) {
    function resolve () {
      epdb.find({ podcastId: info.id }, function (err, records) {
        deferred.resolve(records);                       
      });
    }

    var now = +new Date();
    if (now - info.lastUpdated &gt; 86400000) {
      // update the podcast
    } else {
      resolve();
    }
  });
  return deferred.promise;
};</pre></div><p>We wait for our <code class="literal">this.ready</code> promise to be resolved; as you'll recall, this means that we're waiting for both <code class="literal">info</code> and <code class="literal">episodes</code> to be resolved. This promise has a <code class="literal">spread</code> method, which will spread the resolved values for these promises out so that each one is received as an individual parameter. As you can see, these are the <code class="literal">info</code> and <code class="literal">oldEpisodes</code> parameters. Then,<a id="id421" class="indexterm"/> we create the <code class="literal">resolve</code> function<a id="id422" class="indexterm"/>, which we'll use in several places inside this method. This function will simply find all the<a id="id423" class="indexterm"/> episodes for this podcast and resolve the deferred with them. So, the promise for the <code class="literal">update</code> method<a id="id424" class="indexterm"/> will return all the episodes for this podcast, not just the new ones.</p><p>Now, we'll call this <code class="literal">update</code> method every time a user loads the applications. However, most podcasts update about once a week, so there's no need to check for new episodes every time they load the page. So, we'll check once a day. When we subscribe to a podcast, we set the <code class="literal">lastUpdated</code> property to the current date and time as a Unix timestamp, using the unary plus operator (the single plus sign at the beginning, which is a shortcut for converting a <code class="literal">Date</code> object to a timestamp. Here, we get the current timestamp subtract to get the difference. If there is a difference of more than 86,400,000 (that's the number of milliseconds in a day), it means that we haven't updated this podcast in the last day, so we'll proceed with the update. Otherwise, we'll call resolve, which will just use the current episodes.</p><p>So, what if we want to do the update? The following code goes in place of the <code class="literal">// update the podcast</code> comment:</p><div class="informalexample"><pre class="programlisting">get(info.feed).then(parse).then(function (data) {
  if (data.episodes.length &gt; oldEpisodes.length) {
    var oldTitles = oldEpisodes.map(function (e) { 
      return e.title; 
    }),
    newEpisodes = data.episodes.filter(function (e) { 
      return oldTitles.indexOf(e.title) === -1; 
    });

    epdb.insertAll(newEpisodes, resolve);
  } else {
    resolve();
  }
  pcdb.update({ id: info.id }, { lastUpdated: now });
});</pre></div><p>As you can see, we begin by getting and parsing the XML feed. Then, we check to see whether the list of retrieved episodes is greater than the list of current episodes. If it is so, we know we have new episodes to store. The next part is to figure out what episodes these are. We start by getting<a id="id425" class="indexterm"/> just the titles from the currently stored episodes, and put that in <code class="literal">oldTitles</code>. The next step is to find all the episodes<a id="id426" class="indexterm"/> with titles that aren't in this array; we just use the array's <code class="literal">filter</code> method. Then, we can insert all the remaining ones into the episodes database, and call the <code class="literal">resolve</code> method. If there aren't any new episodes, we'll call the <code class="literal">resolve</code> method anyway. The last step is to update the <code class="literal">lastUpdated</code> property on the podcast record.</p><p>That's all we need for the <code class="literal">Podcast</code> class. However, since we expect users to subscribe to more than one podcast, let's make a simple <code class="literal">Podcasts</code> class to contain that behavior:</p><div class="informalexample"><pre class="programlisting">function Podcasts (id) {
  this.id = id;
}

Podcasts.prototype.all = function () {
  var d = Q.defer();
  pcdb.find({ userId: this.id }, function (err, records) {
    d.resolve(records);
  });
  return d.promise;
};

Podcasts.prototype.get = function (feed) {
  return new Podcast(feed, this.id);
};

Podcasts.prototype.updateEpisode = function (id, update, cb) {
  epdb.update({ id: id }, update, cb);
};

module.exports = Podcasts;</pre></div><p>When we create a <code class="literal">Podcasts</code> instance, we'll pass it the ID of the user. Then, the <code class="literal">all</code> method will return a promise for all of that user's podcasts, and the <code class="literal">get</code> method will return a single <a id="id427" class="indexterm"/>podcast instance. The <code class="literal">updateEpisode</code> method<a id="id428" class="indexterm"/> is just a quick way to update a single episode; we'll only be <a id="id429" class="indexterm"/>using this to mark an episode as listened to. Finally, in a true Node.js module form, we end by exporting the <code class="literal">Podcasts</code> class. That's all we'll need to be able to access from the <code class="literal">server.js</code> file.</p><p>Speaking of the <code class="literal">server.js</code> file, let's go back there for a moment. First, pull in your <code class="literal">podcasts.js</code> file using the following line of code:</p><div class="informalexample"><pre class="programlisting">var Podcasts = require('./podcasts');</pre></div><p>Then, in the catch-all route, we want to get the podcasts for the current user. Here's the completed version of that route:</p><div class="informalexample"><pre class="programlisting">app.get('/*', function (req, res) {
  if (!req.user) {
    res.redirect("/login");
    return;
  }
  req.user.podcasts = new Podcasts(req.user.id);
  req.user.podcasts.all().then(function (records) {
    res.render('index.ejs', { 
      podcasts: JSON.stringify(records),
      username: req.user.username
    });
  });
});</pre></div><p>If the user is logged in, we can create a property on the user object <code class="literal">podcasts</code>. This is a new <code class="literal">Podcasts</code> object, which receives the user ID as the parameter. Then, we get the users' podcasts and send these records to the <code class="literal">index.ejs</code> file, along with the username we were sending previously.</p></div>
<div class="section" title="Preparing index.ejs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec66"/>Preparing index.ejs</h1></div></div></div><p>We've <a id="id430" class="indexterm"/>already created the <code class="literal">login.ejs</code> template, <a id="id431" class="indexterm"/>which will be displayed before a user is logged in. Once the user is logged in, we'll render the <code class="literal">index.ejs</code> file. Here's what we'll start with:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt; PodcastApp &lt;/title&gt;
  &lt;link rel="stylesheet"  href="/bootstrap.min.css" /&gt;
  &lt;link rel="stylesheet"  href="/style.css" /&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div class='container-fluid' id='main'&gt;
  &lt;div class='row'&gt;
    &lt;div id='podcasts' class='col-md-3'&gt;&lt;/div&gt; 
    &lt;div id='episodes' class='col-md-3'&gt;&lt;/div&gt; 
    &lt;div id='episode' class='col-md-6'&gt;&lt;/div&gt; 
  &lt;/div&gt;
&lt;/div&gt;
&lt;script src="/jquery.js"&gt;&lt;/script&gt;
&lt;script src="/underscore.js"&gt;&lt;/script&gt;
&lt;script src="/backbone.js"&gt;&lt;/script&gt;
&lt;script src="/bootstrap.min.js"&gt;&lt;/script&gt;

&lt;script src="/models.js"&gt;&lt;/script&gt;
&lt;script src="/views.js"&gt;&lt;/script&gt;
&lt;script src="/router.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>As we've done in previous applications, we'll be putting all our content inside the <code class="literal">&lt;div id='#main'&gt;</code> element. This time, however, we'll give it a Bootstrap class: <code class="literal">container-fluid</code>. It's pretty amazing how, just by applying the right Bootstrap classes, our application becomes reasonably responsive; we don't have to do any extra work. This time, we start with a bit of content in the main <code class="literal">&lt;div&gt;</code> element. There will be three columns in our application: the first will list the podcasts, the second will list the episodes for a selected podcast, and the third will show the details of an individual episode.</p><p>At the bottom, <a id="id432" class="indexterm"/>we'll pull in all our script tags; besides the defaults (jQuery, Underscore, and Backbone), we've got the JavaScript components of Bootstrap. This is necessary for the navigation we add later. Then, we have our own three files: <code class="literal">models.js</code>, <code class="literal">views.js</code>, and <code class="literal">router.js</code>.</p></div>
<div class="section" title="Creating our models and collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec67"/>Creating our models and collections</h1></div></div></div><p>We'll start <a id="id433" class="indexterm"/>with the <code class="literal">models.js</code> file. There<a id="id434" class="indexterm"/> are two types of data we're going<a id="id435" class="indexterm"/> to be displaying here: podcasts and episodes. So, we'll have a model and collection for each of these. Let's start with episodes:</p><div class="informalexample"><pre class="programlisting">var Episode = Backbone.Model.extend({
  urlRoot: '/episode',
  listen: function () {
    this.save({ listened: true });
  }
});
var Episodes = Backbone.Collection.extend({
  model: Episode,
  initialize: function (models, options) {
    this.podcast = options.podcast;
  },
  url: function () {
    return this.podcast.url() + '/episodes';
  },
  comparator: function (a, b) {
    return +new Date(b.get('pubDate')) - +new Date(a.get('pubDate'));
  }
});</pre></div><p>Our model class is <a id="id436" class="indexterm"/>called <code class="literal">Episode</code>; we give it a root URL and a <code class="literal">listen</code> method. The <code class="literal">listen</code> method will mark the episode as listened to, by setting the <code class="literal">listened</code> property to true and saving the update to the server. You'll recall that, by default, we set <code class="literal">listened</code> to <code class="literal">false</code> for every episode when subscribing to the podcast.</p><p>Then, the collection class is called <code class="literal">Episodes</code>. A collection of episodes will need to be associated with a podcast, so we'll get that <code class="literal">podcast</code> instance from the <code class="literal">options</code> object passed to the <code class="literal">initialize</code> method. Also, notice that we're setting a <code class="literal">url</code> method on the collection. Often, you'll set a <code class="literal">url</code> method on either the model class or the collection class, but not both. However, we'll need two different URLs here. The collection URL will be used to get all<a id="id437" class="indexterm"/> the episodes of a podcast. The model URL will be used when we mark an episode as listened to. The final portion of the collection class is the <code class="literal">comparator</code>. We want our episodes to show up in the <a id="id438" class="indexterm"/>right order, with the <a id="id439" class="indexterm"/>newest episodes at the top of the list, so we'll use the publishing dates as our comparison. Normally, we'd subtract value A from value B, but by reversing that, we can get the most recent episode at the top.</p><p>The podcast classes are even simpler, as you can see from the following code:</p><div class="informalexample"><pre class="programlisting">var Podcast = Backbone.Model.extend({
  episodes: function () {
    return this.episodes || (this.episodes = new Episodes([], { podcast: this }));
  }
});

var Podcasts = Backbone.Collection.extend({
  model: Podcast,
  url: '/podcasts',
});</pre></div><p>The <code class="literal">Podcast</code> model class's <code class="literal">episodes</code> method is rather interesting. As we already saw, each <code class="literal">Podcast</code> instance will have a related <code class="literal">Episodes</code> collection. This method will return that collection. What we're doing in this one-line method is returning the <code class="literal">this.episodes</code> property if it exists. If it doesn't, we'll create it, assign it, and return it, all in one.</p></div>
<div class="section" title="Building the navigation"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Building the navigation</h1></div></div></div><p>Now, we're <a id="id440" class="indexterm"/>ready to <a id="id441" class="indexterm"/>start building our user interface; we can do this by performing the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">views.js</code> file from the public directory. We'll start with some helper code. You're familiar with the first part, but the <code class="literal">tmpl</code> function is new. It's just a small helper function that we'll use to get our templates. We'll use this method for almost every view. Here's the code:<div class="informalexample"><pre class="programlisting">_.templateSettings = {
  interpolate: /\{\{(.+?)\}\}/g
};

function tmpl(selector) {
  return _.template($(selector).html());
}</pre></div></li><li class="listitem">Funnily<a id="id442" class="indexterm"/> enough, we're not going to use the <code class="literal">tmpl</code> function for the first view; the first view is the navigation view. Instead of creating a <code class="literal">template</code> property and choosing a <code class="literal">tagName</code> property, we're setting the <code class="literal">el</code> property. We make this property<a id="id443" class="indexterm"/> a selector for an element that already exists on the page, and that element will become the element for this view. When we click on the <span class="strong"><strong>Add Podcast</strong></span> link, we'll want to display a form. To display this form, we'll navigate to the <code class="literal">/podcasts/new</code> route. This is the whole class:<div class="informalexample"><pre class="programlisting">var NavView = Backbone.View.extend({
  el: '#navbar',
  events: {
    'click #addPodcast': 'addPodcast'
  },
  addPodcast: function (e) {
    e.preventDefault();
    Backbone.history.navigate('/podcasts/new', 
      { trigger: true });
    return false;
  }
});</pre></div></li><li class="listitem">Now, we need to create the element with the ID <code class="literal">navbar</code>, as this view is expecting. A lot of this is just for Bootstrap, but you can see that we have the <span class="strong"><strong>Add Podcast</strong></span>  and <span class="strong"><strong>Log Out</strong></span> links. Its code is given as follows:<div class="informalexample"><pre class="programlisting">&lt;nav id='navbar' class="navbar navbar-inverse navbar-fixed-top" role="navigation"&gt;
  &lt;div class="container-fluid"&gt;
    &lt;div class="navbar-header"&gt;
      &lt;button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-tools"&gt;
        &lt;span class="sr-only"&gt;Toggle navigation&lt;/span&gt;
        &lt;span class="icon-bar"&gt;&lt;/span&gt;
        &lt;span class="icon-bar"&gt;&lt;/span&gt;
        &lt;span class="icon-bar"&gt;&lt;/span&gt;
      &lt;/button&gt;
      &lt;a class="navbar-brand" href="#"&gt;PodcastApp&lt;/a&gt;
    &lt;/div&gt;

    &lt;div class="collapse navbar-collapse" id="navbar-tools"&gt;
      &lt;ul class="nav navbar-nav"&gt;
        &lt;li&gt;&lt;a id='addPodcast' href="#"&gt;Add Podcast&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;p class="navbar-text"&gt;Logged in as &lt;%= username %&gt;&lt;/p&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href='/logout'&gt;Log Out&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/nav&gt;</pre></div></li></ol></div><p>Since this is <a id="id444" class="indexterm"/>already on the page, we don't have to insert it at any point; we'll just instantiate the <a id="id445" class="indexterm"/>router in the class. We'll do this soon, but the screenshot is a sneak peek to what it will look like when we do so:</p><div class="mediaobject"><img src="graphics/6997OS_06_05.jpg" alt="Building the navigation"/></div><p>One more thing: this navigation bar will be fixed to the top of the screen, so we need to push everything else down a bit so that none of the content is hidden behind it before the user scrolls. It's very simple; open your <code class="literal">style.css</code> file from the <code class="literal">public</code> directory, and add the following line of code:</p><div class="informalexample"><pre class="programlisting">body { padding-top: 60px; }</pre></div></div>
<div class="section" title="Displaying podcasts"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec69"/>Displaying podcasts</h1></div></div></div><p>The<a id="id446" class="indexterm"/> next step will be to display the list of podcasts that the user is subscribed to. We start with the <code class="literal">PodcastListView</code> class<a id="id447" class="indexterm"/>, which will display the collection. Here's that class:</p><div class="informalexample"><pre class="programlisting">var PodcastListView = Backbone.View.extend({
  className: 'list-group',
  initialize: function (options) {
    this.current = options.current || null;
    this.listenTo(this.collection, 'add', this.render);
  },
  render: function () {
    if (this.collection.length === 0) {
      this.el.innerHTML = "&lt;a class='list-group-item'&gt;No Podcasts&lt;/a&gt;";
      return this;
    }
    this.el.innerHTML = '';
    this.collection.forEach(this.renderItem, this);
    return this;
  },
  renderItem: function (model) {
    model.set({ current: this.current === model.get('id') });
    var v = new PodcastListItemView({ model: model });
    this.el.appendChild(v.render().el);
  }
});</pre></div><p>For Bootstrap, we'll add the <code class="literal">list-group</code> class to the view's element. In the <code class="literal">initialize</code> method, we'll <a id="id448" class="indexterm"/>check the <code class="literal">options</code> object for a <code class="literal">current</code> value. If the user has clicked on one of the podcasts in the list to display the episodes, we'll want to highlight that podcast, so <code class="literal">current</code> will be the ID of the selected podcast (if one is selected). Then, we'll also listen to for new additions to the collection we're displaying. If one is added, we'll call the <code class="literal">render</code> method again. The <code class="literal">render</code> method looks for a few different scenarios. If the collection is empty (which it will be, at first), we'll just display <span class="strong"><strong>No Podcasts</strong></span>. Otherwise, we'll clear the element and render each model using the <code class="literal">renderItem</code> method. The <code class="literal">renderItem</code> method<a id="id449" class="indexterm"/> sets a <code class="literal">current</code> property on each model; if this model is the current one, it will be <code class="literal">true</code>; otherwise, it will be <code class="literal">false</code>. Then, we'll create a new <code class="literal">PodcastListItemView</code> instance, render it, and append it to the element. Now, we're ready for this view; this is its code:</p><div class="informalexample"><pre class="programlisting">var PodcastListItemView = Backbone.View.extend({
  tagName: 'a',
  className: 'list-group-item',
  template: tmpl('#podcastItem'),
  initialize: function () {
    this.model.episodes().on('count', this.displayCount, this);   
  },
  events: {
    'click': 'displayEpisodes'
  },
  render: function () {
    this.el.innerHTML = this.template(this.model.toJSON());
    this.el.href = this.model.url();
    this.$el.addClass( this.model.get('current') ? 'active': '');
    this.displayCount();
    return this;
  }
});</pre></div><p>The element for this view is an anchor tag with the <code class="literal">list-group-item</code> class. We get the <code class="literal">podcastItem</code> template, which is fairly simple. Add the following code to the <code class="literal">index.ejs</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;script type='text/template' id='podcastItem'&gt;
  {{ title }} &lt;span class='badge'&gt;&lt;/span&gt;
&lt;/script&gt;</pre></div><p>In this <code class="literal">initialize</code> method<a id="id450" class="indexterm"/>, we'll get the episodes collection for this podcast model and listen for the <code class="literal">count</code> event; when it occurs, we'll call the <code class="literal">displayCount</code> method. But before we write that<a id="id451" class="indexterm"/> method, we'll render the view. First, we'll render the template. Then, we'll set the <code class="literal">href</code> property on this element (remember, it's an anchor); this will be the URL for the podcast instance. If this is the current podcast, we'll add the active class to the element. Finally, we'll call the <code class="literal">displayCount</code> method<a id="id452" class="indexterm"/>. Here's that method:</p><div class="informalexample"><pre class="programlisting">displayCount: function (evt) {
  var eps = this.model.episodes();
  eps.fetch().done(function () {
    var count = eps.pluck('listened')
      .filter(function (u) { return !u; }).length;
    this.$('.badge').text(count);
  }.bind(this));
}</pre></div><p>In this method, we get the episodes collection for the podcast and fetch the data from the server. When it arrives, we pluck the value of the <code class="literal">listened</code> property from each episode model; this will be an array of Boolean values. Then, we filter out all the <code class="literal">true</code> values, so we only have the <code class="literal">false</code> values left. The length of the resulting array is the number of podcasts that have not been listened to. Then, we put that number into the badge element of our template.</p><p>One last thing; if you haven't seen the <code class="literal">.bind(this)</code> trick before, this just keeps the value of <code class="literal">this</code> inside the function the same as it is outside the function.</p><p>Finally, have a look at the <code class="literal">events</code> property. When this view's element is clicked on, we'll redirect to the model's URL, as follows:</p><div class="informalexample"><pre class="programlisting">displayEpisodes: function (evt) {
  evt.preventDefault();
  Backbone.history.navigate(this.model.url(), { trigger: true });
  return false;
}</pre></div></div>
<div class="section" title="Creating a layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec70"/>Creating a layout</h1></div></div></div><p>With<a id="id453" class="indexterm"/> these views in place, we're almost ready to start the router. Open the <code class="literal">router.js</code> file from <a id="id454" class="indexterm"/>the <code class="literal">public</code> directory. Now, in the previous chapter, we were using Marionette, and it gave us regions and layouts to manage where our views went. We don't have them now, but since they were so useful, why don't we make them ourselves? We can create it with the following code:</p><div class="informalexample"><pre class="programlisting">function Region(selector) {
  this.el = $(selector); 
}
Region.prototype.show = function (views) {
  if (!_.isArray(views)) { views = [views]; }
  this.el.empty();
  views.forEach(function (view) {
    this.el.append(view.render().el); 
  }.bind(this));
};</pre></div><p>When we create a region, we'll pass it a selector. Then, the <code class="literal">show</code> method will take one or more views. If we pass only a single view, we'll wrap it in an array. Then, we'll loop and append each view to the element. Notice that we're calling the <code class="literal">render</code> method and getting the element for the views here, so we only have to pass the view instance to this method.</p><p>If duplicating <a id="id455" class="indexterm"/>regions was easy, creating your own layout will be a piece of cake; we will create our layout by using the following code:</p><div class="informalexample"><pre class="programlisting">var layout = {
  podcasts: new Region('#podcasts'),
  episodes: new Region('#episodes'),
  episode:  new Region('#episode')
};</pre></div></div>
<div class="section" title="Beginning the router"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec71"/>Beginning the router</h1></div></div></div><p>Now,<a id="id456" class="indexterm"/> we <a id="id457" class="indexterm"/>are ready to start the router. The following is our <code class="literal">Router</code> code for the <code class="literal">router.js</code> file; we can start with this:</p><div class="informalexample"><pre class="programlisting">var Router = Backbone.Router.extend({
  routes: {
    '': 'index'
  },
  initialize: function (options) {
    this.podcasts = options.podcasts;
    this.nav = new NavView();
  },
  index: function () {
    layout.podcasts.show(new PodcastListView({ 
    collection: this.podcasts 
  }));
  }
});</pre></div><p>When the router is created, we'll accept a <code class="literal">podcasts</code> collection. We'll also create our <code class="literal">NavView</code> instance; remember, since the elements for this are already on the page, we don't have to append them. We're ready to take the root route with the <code class="literal">index</code> method; when that happens, we'll use our <code class="literal">layout.podcasts</code> region to show a <code class="literal">PodcastListView</code> instance.</p><p>To use this router, let's add another script tag to the <code class="literal">index.ejs</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;script&gt;
  var r = new Router({
    podcasts: new Podcasts(&lt;%- podcasts %&gt;)
  });
  Backbone.history.start({ pushState: true });
&lt;/script&gt;</pre></div></div>
<div class="section" title="Subscribing to new podcasts"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec72"/>Subscribing to new podcasts</h1></div></div></div><p>We have all the<a id="id458" class="indexterm"/> functionality we need to display podcasts; now, let's create a form to be used when subscribing to new podcasts. As we determined earlier, in our <code class="literal">Podcast</code> module, all we need to get from the user is the podcast feed URL. So, let's create our <code class="literal">NewPodcastView</code> class. First, here's the template for this view:</p><div class="informalexample"><pre class="programlisting">&lt;script type='text/template' id='newPodcast'&gt;
  &lt;form class='form-inline'&gt;
    &lt;div class="form-group"&gt;
      &lt;input type="text" placeholder="feed url" class="form-control"&gt;
    &lt;/div&gt;
    &lt;button class='btn btn-primary'&gt; Add &lt;/button&gt;
  &lt;/form&gt;
&lt;/script&gt;</pre></div><p>As you can see, it's a simple form with a text input and a button. With this in place, we can now write the actual view:</p><div class="informalexample"><pre class="programlisting">var NewPodcastView = Backbone.View.extend({
  className: 'list-group-item',
  template: tmpl('#newPodcast'),
  events: {
    'click button': 'addPodcast'
  },
  render: function () {
    this.el.innerHTML = this.template();
    return this;
  },
  addPodcast: function (e) {
    e.preventDefault();
    var feed = this.$el.find('input').val();
    this.$el.addClass('loading').text('Loading Podcast . . . ');
    this.collection.create({ feed: feed }, { 
      wait: true,
      success: this.remove.bind(this)
    });
    Backbone.history.navigate('/');
    return false;
  }
});</pre></div><p>We'll give the element a <code class="literal">list-group-item</code> class and get the template. The rendering is very simple, and we're listening for a click on the button. When that happens, we'll get the feed from the field and replace the form with the text <span class="strong"><strong>Loading</strong></span>. Then, we create a new podcast in the collection of podcasts that we'll associate with this view. The only property we need is the feed. Now, remember that our <code class="literal">PodcastListView</code> class will be listening for new models added to this collection. However, we need it to wait until the data has been stored in<a id="id459" class="indexterm"/> the server, so it has an ID and episodes to count. So, we'll add the <code class="literal">wait</code> option to this create call. Also, upon the successful completion of this request, we'll call this view's <code class="literal">remove</code> method to remove it from the UI. Finally, we'll navigate back to the home route (not triggering it, notice, because there's no need; we've just removed the form).</p><p>We're adding the <code class="literal">loading</code> class to the view's element while the data is being fetched on the server. Open the <code class="literal">style.css</code> file from the <code class="literal">public</code> directory, and add the following styling:</p><div class="informalexample"><pre class="programlisting">@keyframes pulse {
  0% {
    background: #fff;
    color: #000;
  }
  100% {
    background: #b81e0d;
    color: #fff;
  }
}

.loading {
  animation: pulse 1s ease-in-out infinite alternate;
}</pre></div><p>We use a bit of CSS3 here; the element will pulse from red to white while the server is doing its work. Note that I'm using the standard CSS3 syntax here. At the time of writing this book, however, some browsers still require proprietary prefixes, so you'll have to add the code for the browsers you want to support. Of course, there are plenty of tools to assist you with this; Compass (<a class="ulink" href="http://compass-style.org/">http://compass-style.org/</a>) is a good place to start.</p><p>Now, we'll update the router with the route for adding a podcast. First, add the route to the route objects using the following line of code:</p><div class="informalexample"><pre class="programlisting">'podcasts/new': 'newPodcast'</pre></div><p>Then, we need to write the <code class="literal">newPodcast</code> method:</p><div class="informalexample"><pre class="programlisting">newPodcast: function () {
  var pv = new PodcastListView({ collection: this.podcasts });
  layout.podcasts.show(pv);
  pv.$el.append(new NewPodcastView({ 
    collection: this.podcasts 
  }).render().el);
}</pre></div><p>It's pretty simple; like we do in the <code class="literal">index</code> method, we'll create and render a new <code class="literal">PodcastListView</code> instance. However, we keep a reference to the view and append our form to it; this way, the form will be displayed like another item in the list.</p><p>The last step in <a id="id460" class="indexterm"/>subscribing to podcasts is the server code. We need to manage the POST request that will occur when the user saves a new feed. In the <code class="literal">server.js</code> file, add the following code:</p><div class="informalexample"><pre class="programlisting">app.post('/podcasts', function (req, res) {
  var podcast = req.user.podcasts.get(req.body.feed);
  podcast.info.then(res.json.bind(res));
});</pre></div><p>We can use the user's <code class="literal">podcasts</code> object to get the new podcast by its feed. We wait until the <code class="literal">info</code> promise is ready, and send the data back to the client. Now, we can successfully subscribe to podcast. Give it a try; start up the application, create a user account, and subscribe to a few podcasts. The result should be similar to the following screenshot:</p><div class="mediaobject"><img src="graphics/6997OS_06_01.jpg" alt="Subscribing to new podcasts"/></div></div>
<div class="section" title="Displaying the list of episodes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec73"/>Displaying the list of episodes</h1></div></div></div><p>Now that we <a id="id461" class="indexterm"/>can subscribe to podcasts, let's work on displaying the list of them. We have the <code class="literal">Episode</code> model and the <code class="literal">Episodes</code> collection. We'll start with the collection view <code class="literal">EpisodesView</code>:</p><div class="informalexample"><pre class="programlisting">var EpisodesView = Backbone.View.extend({
  className: 'list-group',
  initialize: function (options) {
    this.region = options.region; 
  },
  render: function () {
    this.collection.forEach(function (model) {
      var v = new EpisodeListItemView({ 
        model: model,
        layout: this.region
      });
      this.el.appendChild(v.render().el);
    }, this);
    return this;
  }
});</pre></div><p>Once again, this element will have the class <code class="literal">list-group</code>. You'll notice that in the <code class="literal">initialize</code> method, we expect <code class="literal">region</code> as one of the <code class="literal">options</code> object's properties. Keep this in mind, and we'll use it later.</p><p>In the <code class="literal">render</code> method, we loop over the collection and display an <code class="literal">EpisodeListItemView</code> instance. Notice that we pass <code class="literal">region</code> along; that's where we'll need it. Let's create this class next:</p><div class="informalexample"><pre class="programlisting">var EpisodeListItemView = Backbone.View.extend({
  className: 'list-group-item',
  events: {
    'click': 'displayEpisode'
  },
  initialize: function (options) {
    this.layout = options.layout;
    this.listenTo(this.model, 'change:listened', this.markAsListened);
  },
  render: function () {
    this.el.innerText = this.model.get('title');
    if (!this.model.get('listened')) {
      this.$el.addClass('list-group-item-danger');
    }
    return this;
  },
  markAsListened: function () {
    this.$el.removeClass('list-group-item-danger');
  },
  displayEpisode: function (evt) {
    evt.preventDefault();
    this.layout.show(new EpisodeView({ model: this.model }));
    return false;
  }
});</pre></div><p>As we've done <a id="id462" class="indexterm"/>with our previous list item view, we'll give this one the class <code class="literal">list-group-item</code>. There's no template here; we'll just set the title of this model as the text for the element. Then, if this episode has not been listened to, we'll add a class to highlight it, marking it as such. In the <code class="literal">initialize</code> method, notice that we're listening for a change to the <code class="literal">listened</code> property. When that change occurs, we'll call the <code class="literal">markAsListened</code> method, which will remove that class so that the view is no longer highlighted.</p><p>The last method is <code class="literal">displayEpisode</code>, which will call the region's <code class="literal">show</code> method, passing it an <code class="literal">EpisodeView</code> instance for the model that this view is displaying. This won't just be a title, as we're showing here; it will be the entire model. This is why we're passing the region along. Since we're not changing the URL, we have to change the content of the page right here. So, that's what we do.</p><p>There's one more piece for the list of episodes: a toolbar above it. There's only one tool: <span class="strong"><strong>Mark All As Listened</strong></span>, which is a simple button. Its code is as follows:</p><div class="informalexample"><pre class="programlisting">var EpisodesToolsView = Backbone.View.extend({
  className: 'btn-tools btn-group',
  events: {
    'click #mark': 'mark'
  },
  render: function () {
    this.el.innerHTML = "&lt;button id= 'mark' class="btn btn-default"&gt;Mark As Listened&lt;/button&gt;";
    return this;
  },
  mark: function (evt) {
    this.collection.forEach(function (model) {
      model.listen();
    });
    this.collection.trigger('count');
  }
});</pre></div><p>Again, we start with the <code class="literal">className</code> property; the <code class="literal">render</code> method is very simple. In the <code class="literal">events</code> property, we wait for a click on the <code class="literal">#mark</code> button. When that happens, we call the <code class="literal">mark</code> function, <a id="id463" class="indexterm"/>which will loop over the collection and mark them all as listened to. Then, we trigger the <code class="literal">count</code> event on the collection; we listen for this event to occur in the <code class="literal">PodcastListItemView</code> class, where we'll update the podcast count.</p><p>Notice that one of the classes we're using is the <code class="literal">btn-tools</code> class. This is one of our own creations, and it's very simple; it just gives our tool bar a little more breathing room on the bottom:</p><div class="informalexample"><pre class="programlisting">.btn-tools {
  margin-bottom: 20px;
}</pre></div><p>The last step for this is the server component for marking an episode as listened to. Here's the route to add to the <code class="literal">server.js</code> file:</p><div class="informalexample"><pre class="programlisting">app.put('/episode/:id', function (req, res) {
  req.user.podcasts.updateEpisode(parseInt(req.params.id, 10),
    req.body, function (err, data) {
      res.json(data);  
    });
});</pre></div><p>Now, we're ready to show our list of episodes. In the router of the <code class="literal">router.js</code> file, add the following route:</p><div class="informalexample"><pre class="programlisting">'podcasts/:id': 'podcast'</pre></div><p>Now for that <code class="literal">podcast</code> method, here's its code:</p><div class="informalexample"><pre class="programlisting">podcast: function (id) {
  layout.podcasts.show(new PodcastListView({ 
    collection: this.podcasts, 
    current: parseInt(id, 10) 
  }));
  var podcast = this.podcasts.get(id);
  var episodes = podcast.episodes();
  episodes.fetch();
  layout.episodes.show([
    new EpisodesToolsView({
      model: podcast,
      collection: episodes
    }),
    new EpisodesView({
      collection: episodes,
      layout: layout.episode 
    })
  ]);
}</pre></div><p>We first render the podcast list, because it's possible that this page will be loaded directly. Notice that this<a id="id464" class="indexterm"/> time we're setting the <code class="literal">current</code> option so that it will be highlighted in the list. Then, we get the episodes for that podcast from the server. Next, in the <code class="literal">episodes</code> region, we show the views <code class="literal">EpisodesToolsView</code> and <code class="literal">EpisodesView</code>.</p><p>To get the episodes from the server, via <code class="literal">episodes.fetch()</code>, we need another server route, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">app.get('/podcasts/:id/episodes', function (req, res) {
  var podcast = req.user.podcasts.get(parseInt(req.params.id, 10));
  podcast.update().then(res.json.bind(res));
});</pre></div><p>We'll get the <code class="literal">Podcast</code> object, and then call the <code class="literal">update</code> method to check for new episodes. When that returns, we'll send them to the client as JSON.</p><p>With this in place, we can now view a list of episodes, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6997OS_06_02.jpg" alt="Displaying the list of episodes"/></div><p>Now, all that's left is displaying individual podcast episodes.</p></div>
<div class="section" title="Displaying episodes"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Displaying episodes</h1></div></div></div><p>Individual episodes<a id="id465" class="indexterm"/> will be displayed in the <code class="literal">EpisodeView</code> class. Let's start with the template:</p><div class="informalexample"><pre class="programlisting">&lt;script type='text/template' id='episodeView'&gt;
  &lt;div class='btn-group btn-tools'&gt;
    &lt;button id='markOne' class="btn btn-default"&gt;Mark As Listened&lt;/button&gt;
  &lt;/div&gt;
  &lt;div class="panel panel-default"&gt;
    &lt;div class="panel-body"&gt;
      &lt;h1&gt;{{title}}&lt;/h1&gt;
      &lt;p&gt;
        &lt;strong&gt;Duration&lt;/strong&gt;: {{duration}}
        &lt;strong&gt;Date&lt;/strong&gt;: {{pubDate}} 
      &lt;/p&gt; 
      &lt;audio controls='true' src="{{audio}}"&gt;&lt;/audio&gt;
      {{description}}
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p>We start with some tools at the top: a <span class="strong"><strong>Mark As Listened</strong></span> button. Then, we show the details for the episode: title, duration, and date. Next comes the <code class="literal">audio</code> element; this makes it really easy <a id="id466" class="indexterm"/>for users to listen to the podcast right in our application. In our case, we only have a single audio source; however, you'll often want to add multiple sources in different formats (MP3, OGG, and so on) when using the <code class="literal">audio</code> element, for maximum browser and OS coverage. Underneath the <code class="literal">audio</code> element, we'll display the description, which will be the show notes for that episode. Here's the class:</p><div class="informalexample"><pre class="programlisting">var EpisodeView = Backbone.View.extend({
  template: tmpl('#episodeView'),
  events: {
    'click #markOne': 'listen' 
  },
  render: function () {
    this.el.innerHTML = this.template(this.model.toJSON()); 
    this.$('audio')[0].addEventListener('play', this.listen.bind(this), false);
    return this;
  },
  listen: function (evt) {
    this.model.listen();
    this.model.collection.trigger('count');
  }
});</pre></div><p>Most of this view is the standard view code; we get the template, and we render the template with the model data. We also have a <code class="literal">listen</code> method, which will be called when the user clicks on the <span class="strong"><strong>Mark As Listened</strong></span> button. The one difference is that we can't use the <code class="literal">events</code> property to listen for the <code class="literal">play</code> event on the <code class="literal">audio</code> element because of the way the <code class="literal">audio</code> element events works with Backbone. So, we get the element and use the <code class="literal">addEventListener</code> method to listen for that event.</p><p>This is the last piece. Now, you should be able to view and play episodes of the podcast. It looks like <a id="id467" class="indexterm"/>what is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6997OS_06_03.jpg" alt="Displaying episodes"/></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec75"/>Summary</h1></div></div></div><p>This brings us to the end of this chapter. A lot of what we did in this chapter was already familiar to you from previous applications, but there were a few nuggets that you shouldn't ignore. The main aspect is the strong server component. It is easy to forget that a Backbone application will always have the server code behind it, and often that code will be much more than a main template being rendered and a bunch of routes that shuttle JSON back and forth. There's often significant logic, data handling, and other details that will be taken care of on the server. As we saw, it's often possible to perform this logic on either the client or the server—we could have captured the RSS feed and processed it in either position. When building your own applications, it's important to make good decisions about where processes take place. It's often much quicker to do something on the client (no request/response to wait for), but you'll probably have more power and ability on the server, so the time delay might be negligible. The decision will be different for every situation, and there often won't be a single right choice.</p><p>The other interesting thing we did was recreate some of Marionette's behavior. This serves as another reminder that Backbone is just JavaScript, and there's no reason you can't write your own code to make it easier for you. There's no need to do anything fancy; as we saw, something as simple as our regions and layout can really clean up your router.</p><p>Only one chapter left, and that's where we'll have some fun and build a game.</p></div></body></html>