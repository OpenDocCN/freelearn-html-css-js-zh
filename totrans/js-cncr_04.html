<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Lazy Evaluation with Generators</h1></div></div></div><p>Lazy evaluation is a programming technique, which is used when we don't want to compute values until the very last second. This way, we're sure we actually need it. The opposite <a id="id149" class="indexterm"/>approach, eager evaluation, has the potential to compute several values that aren't needed. This generally isn't a problem, until the size and complexity of our applications grow beyond a level where these wasted computations are imperceptible to the user.</p><p>The <code class="literal">Generator</code> is <a id="id150" class="indexterm"/>a new primitive type introduced to JavaScript as a part of the ES6 specification of the language. Generators help us implement lazy evaluation techniques in our code, and as a corollary, help us implement the conserve concurrency principle.</p><p>We'll start the chapter off with some simple introductions to generators, so we can get a feel for how they behave. From there, we'll move onto more advanced lazy evaluation scenarios, wrapping up the chapter with a look at coroutines. Let's get started.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Call stacks and memory allocation</h1></div></div></div><p>Memory allocation is a necessity of any programming language. Without this, we have no data structures to <a id="id151" class="indexterm"/>work with, not even primitive types. Memory is cheap, and it seems that there's plenty of it to go around; this isn't cause for celebration just yet. While it's more feasible today to allocate larger data structures in memory then it was 10 years ago, we still have to deallocate that memory when we're done <a id="id152" class="indexterm"/>with it. JavaScript is a garbage-collected language, which means our code doesn't have to explicitly destroy objects in memory. However, the garbage collector incurs a CPU penalty.</p><p>So there are two factors in play here. We want to conserve two resources here, and we'll try to do so using generators to implement lazy evaluation. We don't want to allocate memory unnecessarily, and if we can avoid this, then we can avoid invoking the garbage collector frequently. In this section, I'll introduce some generator concepts.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Bookmarking function contexts</h2></div></div></div><p>In a normal function call stack, a function returns a value. The <code class="literal">return</code> statement activates a new execution <a id="id153" class="indexterm"/>context and discards the old context because we returned, so we're done with it. Generator functions are a special kind of JavaScript function denoted with their own syntax, and their call stacks aren't so cut-and-dried compared to <code class="literal">return</code> statements. Here's a visualization of what happens when a generator function is invoked, and it starts generating values:</p><div><img src="img/B05133_04_01.jpg" alt="Bookmarking function contexts"/></div><p>Just as the <code class="literal">return</code> statement passes a value to the calling context, the <code class="literal">yield</code> statement passes a value back. However, unlike a regular function, generator function contexts aren't discarded. In fact, they're bookmarked so that when control is given back to the generator context, it can pick up where it left off to continue yielding values until it's done. This bookmarking data is very insignificant, as it just points to a location in our code.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>Sequences instead of arrays</h2></div></div></div><p>In JavaScript, when we need to iterate over a list of things, numbers, strings, objects, and so on, we use <a id="id154" class="indexterm"/>an array. Arrays are general purpose and powerful. The challenge with arrays in the <a id="id155" class="indexterm"/>context of lazy evaluation is that arrays themselves are data that need to be allocated. So we have the elements within the array that need to be allocated somewhere in memory, and we also have metadata about the elements in the array.</p><p>If we're working with a large number of objects, the memory overhead associated with the array is significant. Additionally, we need to somehow put these objects in the array. This is an additional step that adds CPU time. An alternative concept is a sequence. Sequences <a id="id156" class="indexterm"/>aren't a tangible JavaScript language construct. They're an abstract concept—arrays without actually allocating arrays. Sequences help with lazy evaluation. For this exact reason, there's nothing to allocate, and there's no initial population step. Here's a <a id="id157" class="indexterm"/>visualization of the steps involved with iterating over an array:</p><div><img src="img/B05133_04_02.jpg" alt="Sequences instead of arrays"/></div><p>As we can see, before we can iterate over these three objects, we first have to allocate an array, then<a id="id158" class="indexterm"/> populate it with these objects. Let's contrast this approach with the conceptual idea of a sequence with the following diagram:</p><div><img src="img/B05133_04_03.jpg" alt="Sequences instead of arrays"/></div><p>With sequences, we don't have an explicit container structure for the objects that we're interested<a id="id159" class="indexterm"/> in iterating over. The only overhead associated with a sequence is the pointer to the current item. We can use generator functions as a mechanism for generating sequences in JavaScript. As we saw in the preceding section, generators bookmark their execution context when they yield values back to the caller. This is the kind of minimal overhead that we're looking for. It enables us to lazily evaluate objects and iterate over them as a sequence.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Creating generators and yielding values</h1></div></div></div><p>In this section, I'll introduce<a id="id160" class="indexterm"/> the generator function syntax, and<a id="id161" class="indexterm"/> we'll walk through yielding values from<a id="id162" class="indexterm"/> a generator. We'll also look at the two approaches that we can use to iterate over values yielded from generators.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>Generator function syntax</h2></div></div></div><p>The syntax for generator functions is nearly identical to normal functions. The difference in the declaration is that the <code class="literal">function</code> keyword is followed by an asterisk. The more profound difference is<a id="id163" class="indexterm"/> the return value, which is always a generator instance. Moreover, there's no need for the <code class="literal">new</code> keyword, despite a new object being created. Let's take a look at what a generator function looks like:</p><div><pre class="programlisting">// Generator functions use an asterisk to
// denote a that a generator instance is returned.
// We can return values from generators, but instead
// of the caller getting that value, they'll always
// get a generator instance.
function* gen() {
    return 'hello world';
}

// Creates the generator instance.
var generator = gen();

// Let's see what this looks like.
console.log('generator', generator);
// → generator Generator

// Here's how we get the return value. Looks awkward,
// because we would never use a generator function
// that simply returns a single value.
console.log('return', generator.next().value);
// → return hello world</pre></div><p>It's highly unlikely that we'd ever use generators in this fashion, but it's a good way to illustrate the nuances of generator functions. For example, <code class="literal">return</code> statements are perfectly valid within generator functions, and yet, they produce a completely different result for the caller, as we can see. In practice, we're far more likely to encounter <code class="literal">yield</code> statements in generators, so let's look at them next.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Yielding values</h2></div></div></div><p>The common case with generator <a id="id164" class="indexterm"/>functions is to yield values and control<a id="id165" class="indexterm"/> back to the caller. Yielding control back to the caller is a defining characteristic of generators. When we yield, the generator bookmarks our position in the code. It does this because the caller is likely going to request another value from the generator, and when it does, the generator simply picks up where it left off. Let's take a look at a generator function that yields several times:</p><div><pre class="programlisting">// This function yields values, in order. There's no
// container structure, like an array. Instead, each time
// the yield statement is called, control is yielded
// back to the caller, and the position in the function
// is bookmarked.
function* gen() {
    yield 'first';
    yield 'second';
    yield 'third';
}

var generator = gen();

// Each time we call "next()", control is passed back
// to the generator function's execution context. Then,
// the generator looks up the bookmark for where it
// last yielded control.
console.log(generator.next().value);
console.log(generator.next().value);
console.log(generator.next().value);</pre></div><p>The previous code<a id="id166" class="indexterm"/> is what a sequence looks like. We have three <a id="id167" class="indexterm"/>values, and they're sequentially yielded from our function. They're not put in any kind of container structure either. The first call to <code class="literal">yield</code> passes <code class="literal">first</code> to <code class="literal">next()</code>, which is where it's used. The same goes for the other two values. In fact, this is lazy evaluation in action. We have three calls to <code class="literal">console.log()</code>. The eager implementation of <code class="literal">gen()</code> would return a collection of values for us to log. Instead, when we need to log a value, we go and get it from the generator. This is the laziness factor; we conserve our efforts until they're actually required, avoiding allocations and computations.</p><p>The not-so-ideal aspect of our previous example is that we're actually repeating calls to <code class="literal">console.log()</code>, when really, we want to iterate over the sequence, calling <code class="literal">console.log()</code> for each<a id="id168" class="indexterm"/> item in it. Let's iterate over some generator<a id="id169" class="indexterm"/> sequences now.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Iterating over generators</h2></div></div></div><p>The <code class="literal">next()</code> method <a id="id170" class="indexterm"/>gets us, not surprisingly, the next value in the generator sequence. The actual value returned by <code class="literal">next()</code> is an object with two properties: the yielded <code class="literal">value</code> and whether or not the generator is <code class="literal">done</code>. However, we generally don't want to hard-code our calls to <code class="literal">next()</code>. Instead, we want to call it iteratively as values are yielded from the generator. Here's an example that uses a <code class="literal">while</code> loop to iterate over a generator:</p><div><pre class="programlisting">// A basic generator function that yields
// sequential values.
function* gen() {
    yield 'first';
    yield 'second';
    yield 'third';
}

// Creates the generator.
var generator = gen();

// Loop till the sequence is finished.
while(true) {

    // Gets the next item from the sequence.
    let item = generator.next();

    // Is there a next value, or are we done?
    if (item.done) {
        break;
    }

    console.log('while', item.value);
}</pre></div><p>This loop will continue until the <code class="literal">done</code> property of the yielded item is <code class="literal">true</code>; at this point, we know there aren't any items, and thus, we can stop. This allows us to iterate over a sequence of yielded values without the need to create an array for the sole purpose of iterating over it. However, there's a lot of boilerplate code in this loop that has more to do with managing the generator iteration than actually iterating over it. Let's take a look at another approach:</p><div><pre class="programlisting">// The "for..of" loop removes the need to explicitly
// call generator constructs, like "next()", "value",
// and "done".
for (let item of generator) {
    console.log('for..of', item);
}</pre></div><p>This is much better. We've condensed our code down into something that's much more focused on the<a id="id171" class="indexterm"/> task at hand. This code essentially does the exact same thing as our <code class="literal">while</code> loop, except the <code class="literal">for..of</code> statement, which understands what to do when the iterable is a generator. Iterating over generators is a common pattern in concurrent JavaScript applications, so optimizing for compact and readable code here would be a wise decision.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Infinite sequences</h1></div></div></div><p>Some sequences are infinite, prime numbers, Fibonacci numbers, odd numbers, and so on. Infinite <a id="id172" class="indexterm"/>sequences aren't limited to sets of numbers; more<a id="id173" class="indexterm"/> abstract notions can be considered infinite. For example, a set of stings that repeats itself infinitely, a Boolean value that toggles infinitely, and so on. In this section, we'll explore how generators make it possible for us to work with infinite sequences.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>No end in sight</h2></div></div></div><p>Allocating items <a id="id174" class="indexterm"/>from an infinite sequence isn't practical from a memory consumption point of view. In fact, it's not even possible to allocate the whole sequence—it's infinite. Memory is finite. So, it's better to simply sidestep the whole allocation problem entirely and use a generator to yield the values from the sequence as we need them. At any given point in time, our application is only going to use a tiny slice of the infinite sequence. Here's a visualization of what's used from an infinite sequence versus the potential size of these sequences:</p><div><img src="img/B05133_04_04.jpg" alt="No end in sight"/></div><p>As we can see, there are a vast number of items available that we'll never use with this sequence. Let's take<a id="id175" class="indexterm"/> a look at some generator code that lazily produces items from an infinite Fibonacci sequence:</p><div><pre class="programlisting">// Generates an infinite Fibonacci sequence.
function* fib() {
    var seq = [ 0, 1 ],
        next;

    // This loop doesn't actually run infinitely,
    // only as long as items from the sequence
    // are requested using "next()".
    while (true) {

        // Yields the next item in the sequence.
        yield (next = seq[0] + seq[1]);

        // Stores state necessary to compute the
        // item in the next iteration.
        seq[0] = seq[1];
        seq[1] = next;
    }
}

// Launch the generator. This will never be "done"
// generating values. However, it's lazy - it only
// generates what we ask for.
var generator = fib();

// Gets the first 5 items of the sequence.
for (let i = 0; i &lt; 5; i++) {
    console.log('item', generator.next().value);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Alternating sequences</h2></div></div></div><p>A variation on<a id="id176" class="indexterm"/> infinite sequences is either a circular sequence or an alternating sequence. These types of sequences are circular when the end is reached; they start from the beginning. Here's what a sequence that alternates between two values looks like:</p><div><img src="img/B05133_04_05.jpg" alt="Alternating sequences"/></div><p>These types of sequences will continue to generate values infinitely. This becomes useful when we have<a id="id177" class="indexterm"/> a set of rules that determine how the sequence is defined and the set of items that's generated; then, we start this set all over again. Now, let's look at some code to see the implementation of these sequences using generators. Here's a generic generator function that we can use to alternate between values:</p><div><pre class="programlisting">// A generic generator that will infinitely iterate
// over the provided arguments, yielding each item.
function* alternate(...seq) {
    while (true) {
        for (let item of seq) {
            yield item;
        }
    }
}</pre></div><p>This is the first time we've declared a generator function that accepts arguments. In fact, we're using the spread operator to iterate over arguments passed to the function. Unlike arguments, the <code class="literal">seq</code> argument that we've created using the spread operator is a real array. As we iterate over this array, we yield each item from the generator. This may not seem all that useful at first glance, but it's the <code class="literal">while</code> loop that adds the real power here. Since the <code class="literal">while</code> loop will never exit, the <code class="literal">for</code> loop will simply repeat itself. That is, it'll alternate. This<a id="id178" class="indexterm"/> negates the need for explicit bookkeeping code (Have we reached the end of the sequence? How do we reset the counter and move back to the beginning? And so on) Let's see how this generator function works:</p><div><pre class="programlisting">// Create a generator that alternates between
// the provided arguments.
var alternator = alternate(true, false);

console.log('true/false', alternator.next().value);
console.log('true/false', alternator.next().value);
console.log('true/false', alternator.next().value);
console.log('true/false', alternator.next().value);
// → 
// true/false true
// true/false false
// true/false true
// true/false false</pre></div><p>Cool. So the <code class="literal">alternator</code> will continue to generate <code class="literal">true</code>/<code class="literal">false</code> values as long as we continue to ask for them. The main benefit here is that we don't need to know about the next value, <code class="literal">alternator</code> takes care of this for us. Let's look at this generator function with a different sequence to iterate over:</p><div><pre class="programlisting">// Create a new generator instance, with new values
// to alternate with each iteration.
alternator = alternate('one', 'two', 'three');

// Gets the first 10 items from the infinite sequence.
for (let i = 0; i&lt; 10; i++) {
    console.log('one/two/three',
        `"${alternator.next().value}"`);
}
// → 
// one/two/three "one"
// one/two/three "two"
// one/two/three "three"
// one/two/three "one"
// one/two/three "two"
// one/two/three "three"
// one/two/three "one"
// one/two/three "two"
// one/two/three "three"
// one/two/three "one"</pre></div><p>As we can<a id="id179" class="indexterm"/> see, the <code class="literal">alternate()</code> function comes in handy for alternating between any arguments passed to it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Deferring to other generators</h1></div></div></div><p>We've seen how the <code class="literal">yield</code> statement is able to pause the execution context of a <code class="literal">generator</code> function, and yield a value back to the calling context. There's a variation on the <code class="literal">yield</code> statement that allows us to defer to other <code class="literal">generator</code> functions. Another technique involves <a id="id180" class="indexterm"/>creating a mesh of generators by interweaving several generator sources together. In this section, we'll explore both of these ideas.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Selecting a strategy</h2></div></div></div><p>Deferring to<a id="id181" class="indexterm"/> other generators gives our functions the ability to decide at run-time, to hand off control from one generator to another. In other words, it allows the selection of a more appropriate generator function based on a strategy. Here's a visualization of a generator function that makes a decision and defers to one of several other generator functions:</p><div><img src="img/B05133_04_06.jpg" alt="Selecting a strategy"/></div><p>What we have here are three specialized generators that we would like to use throughout our application. That is, they each work in their own unique way. Perhaps, they're tailored for <a id="id182" class="indexterm"/>specific types of inputs. However, these generators simply make assumptions about the input that they're given. It may not be the best tool for the job, and so, we have to figure out which of these generators to use. What we want to avoid is having to implement this strategy selection code all over the place. It would be nice if we were able to encapsulate all of this into a general purpose generator that captures common cases throughout our code.</p><p>Let's say that we have the following generator functions, and they're equally used throughout our application:</p><div><pre class="programlisting">// Generator that maps a collection of objects
// to a specific property name.
function* iteratePropertyValues(collection, property) {
    for (let object of collection) {
        yield object[property];
    }
}

// Generator that yields each value of the given object.
function* iterateObjectValues(collection) {
    for (let key of Object.keys(collection)) {
        yield collection[key];
    }
}

// Generator that yields each item from the given array.
function* iterateArrayElements(collection) {
    for (let element of collection) {
        yield element;
    }
}</pre></div><p>These are small and concise functions, and they are easy to use wherever we need them. The trouble is that each of these functions make assumptions about the collection that's passed in. Is it an<a id="id183" class="indexterm"/> array of objects, each with a specific property? Is it an array of strings? Is it an object instead of an array? Since these generator functions are commonly used throughout our code for a similar purpose, we can implement a more generic iterator, who's job is to determine the best generator function to use, and then to defer to it. Let's see what this function looks like:</p><div><pre class="programlisting">// This generator defers to other generators. But first,
// it executes some logic to determine the best strategy.
function* iterateNames(collection) {

    // Are we dealing with an array?
    if (Array.isArray(collection)) {

        // This is a heuristic where we check the first
        // element of the array. Based on what's there, we
        // make assumptions about the remaining elements.
        let first = collection[0];

        // Here is where we defer to other more specialized
        // generators, based on what we find out about the
        // first array element.
        if (first.hasOwnProperty('name')) {
            yield* iteratePropertyValues(collection,
                'name');
        } else if (first.hasOwnProperty('customerName')) {
            yield* iteratePropertyValues(collection,
                'customerName');
        } else {
            yield* iterateArrayElements(collection);
        }
    } else {
        yield* iterateObjectValues(collection);
    }
}</pre></div><p>Think of the <code class="literal">iterateNames()</code> function as a simple proxy for any one of the other three generators. It examines the input and makes a selection based on the collection. We could have implemented one large generator function, but that would preclude us from use cases where we want to use the smaller generators directly. What if we want to use them to compose new functionality, or if another composite generator wants to use it? It's always a good idea to keep generator functions small and focused. The <code class="literal">yield*</code> syntax allows us to handoff control to a more suitable generator.</p><p>Now, let's see<a id="id184" class="indexterm"/> how this general purpose generator function is put to use by deferring to generators that are best equipped to handle the data:</p><div><pre class="programlisting">var collection;

// Iterates over an array of string names.
collection = [ 'First', 'Second', 'Third' ];

for (let name of iterateNames(collection)) {
    console.log('array element', `"${name}"`);
}

// Iterates over an object, where the names
// are the values - the keys aren't relevant here.
collection = {
    first: 'First',
    second: 'Second',
    third: 'Third'
};

for (let name of iterateNames(collection)) {
    console.log('object value', `"${name}"`);
}

// Iterates over the "name" property of each object
// in the collection.
collection = [
    { name: 'First' },
    { name: 'Second' },
    { name: 'Third' }
];

for (let name of iterateNames(collection)) {
    console.log('property value', `"${name}"`);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Interweaving generators</h2></div></div></div><p>When a generator defers to another generator, control isn't handed back to the first generator until the second generator is completely finished. In the preceding example, our generator simply<a id="id185" class="indexterm"/> looked for a better generator to carry out the work. However, there will be other times when we'll have two or more data sources that we want to use together. So, instead of handing off control to one generator, then to another and so on, we would alternate between the various sources, taking turns consuming data.</p><p>Here's a diagram that illustrates the idea of a generator that interweaves multiple data sources to create a single data source:</p><div><img src="img/B05133_04_07.jpg" alt="Interweaving generators"/></div><p>The idea is to round-robin the data sources, rather than to empty one source, then another, and so on. A generator like this is handy when there isn't a single large collection for <a id="id186" class="indexterm"/>us to work with, but instead, two or more collections. Using this generator technique, we can actually treat multiple data sources as though they were one big source, but without having to allocate the memory for a large structure. Let's look at the following code example:</p><div><pre class="programlisting">'use strict';

// Utility function that converts the input array to a
// generator by yielding each of it's values. If its
// not an array, it assumes it's already a generator
// and defers to it.
function* toGen(array) {
    if (Array.isArray(array)) {
        for (let item of array) {
            yield item;
        }
    } else {
        yield* array;
    }
}

// Interweaves the given data sources (arrays or
// generators) into a single generator source.
function* weave(...sources) {

    // This controls the "while" loop. As long as
    // there's a source that's yielding data, the
    // while loop is still valid.
    var yielding = true;

    // We have to make sure that each of our
    // sources is a generator.
    var generators = sources.map(
        source =&gt;toGen(source));

    // Starts the main weaving loop. It makes it's
    // way through each source, yielding one item
    // from each, then starting over, till every
    // source is empty.
    while (yielding) {
        yielding = false;

        for (let source of generators) {
            let next = source.next();

            // As long as we're yielding data, the
            // "yielding" value is true, and the
            // "while" loop continues. As soon as
            // "done" is true for every source, the
            // "yielding" variable stays false, and
            // the "while loop exits.
            if (!next.done) {
                yielding = true;
                yield next.value;
            }
        }
    }
}

// A basic filter that generates values by
// iterating over the given source, and yielding items
// that are not disabled.
function* enabled(source) {
    for (let item of source) {
        if (!item.disabled) {
            yield item;
        }
    }
}

// These are the two data sources we want to weave
// together into one generator, which can then be
// filtered by another generator.
var enrolled = [
    { name: 'First' },
    { name: 'Sencond' },
    { name: 'Third', disabled: true }
];

var pending = [
    { name: 'Fourth' },
    { name: 'Fifth' },
    { name: 'Sixth', disabled: true }
];

// Creates the generator, which yields user objects
// from two data sources.
var users = enabled(weave(enrolled, pending));

// Actually performs the weaving and filtering.
for (let user of users) {
    console.log('name', `"${user.name}"`);
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Passing data to generators</h1></div></div></div><p>The <code class="literal">yield</code> statement <a id="id187" class="indexterm"/>doesn't just yield control back to the caller, it also returns a value. This value is passed to the generator function through the <code class="literal">next()</code> method. This is how we pass data into<a id="id188" class="indexterm"/> generators after they've been created. In this section, we'll address the bidirectional aspect of generators, and how creating feedback loops can produce some lean code.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Reusing generators</h2></div></div></div><p>Some generators are<a id="id189" class="indexterm"/> general purpose and used frequently throughout our code. This being the case, does it make sense to constantly create and destroy these generator instances? Or can we reuse them? For instance, consider a sequence that's mainly dependent on initial conditions. Let's say we want to generate a sequence of even numbers. We would start at two, and as we iterate over this generator, the value would be incremented. The next time we want to iterate over even numbers, we would have to create a new generator.</p><p>This is kind of wasteful, since all we're doing is resetting a counter. What if we took a different approach, one that would allow us to keep on using the same generator instance for these types of sequences? The <code class="literal">next()</code> method of generators is a possible implementation path for this capability. We could pass it a value, which would then reset our counter. So instead of having to create a new generator instance every time we need to iterate over even numbers, we can simply call <code class="literal">next()</code> with a value that resets the initial conditions of our generator.</p><p>The <code class="literal">yield</code> keyword actually returns a value—the argument that's passed to <code class="literal">next()</code>. Most of the time, this is undefined, such as when the generator is iterated over in a <code class="literal">for..of</code> loop. However, this is how we're able to pass arguments to the generator after it starts running. This is not the same thing as passing arguments to the generator function, which comes in handy for doing the initial configuration of the generator. Values passed to <code class="literal">next()</code> are how we talk to the generator when we need to change something for the next value that's to be generated.</p><p>Let's take a look at how we can use the <code class="literal">next()</code> method to create a reusable even number sequence <a id="id190" class="indexterm"/>generator:</p><div><pre class="programlisting">// This generator will keep generating even numbers.
function* genEvens() {

    // The initial value is 2. But this can change based
    // on the input passed to "next()".
    var value = 2,
        input;

    while (true) {

        // We yield the value, and get the input. If 
        // input is provided, this will serve as the
        // next value.
        input = yield value;

        if (input) {
            value = input;
        } else {
            // Make sure that the next value is even.
            // Handles the case when an odd value is
            // passed to "next()".
            value += value % 2 ? 1 : 2;
        }
    }
}

// Creates the "evens" generator.
var evens = genEvens(),
    even;

// Iterate over evens up to 10.
while ((even = evens.next().value) &lt;= 10) {
    console.log('even', even);
}
// →
// even 2
// even 4
// even 6
// even 8
// even 10

// Resets the generator. We don't need to
// create a new one.
evens.next(999);

// Iterate over evens between 1000 - 1024.
while ((even = evens.next().value) &lt;= 1024) {
    console.log('evens from 1000', even);
}
// → 
// evens from 1000 1000
// evens from 1000 1002
// evens from 1000 1004
// evens from 1000 1006
// evens from 1000 1008
// evens from 1000 1010
// evens from 1000 1012
// evens from 1000 1014
// ...</pre></div><div><div><h3 class="title"><a id="note08"/>Note</h3><p>In case you're wondering why we're not using a <code class="literal">for..of</code> loop in the favor of a <code class="literal">while</code> loop, it's because you use a <code class="literal">for..of</code> loop to iterate over a generator. When you<a id="id191" class="indexterm"/> do so, the generator gets marked as <em>done</em> as soon as the loop exits. Hence, it would no longer be usable.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec59"/>Lightweight map/reduce</h2></div></div></div><p>Something else we can do with the <a id="id192" class="indexterm"/>
<code class="literal">next()</code> method is map one value to another. For example, let's say<a id="id193" class="indexterm"/> we had a collection containing seven items. To map these items, we would iterate over the collection, passing each item to <code class="literal">next()</code>. As we saw in the preceding section, this method can reset the state of a generator, but it can also be used to supply a stream of input data, just as it supplies a stream of output data.</p><p>Let's see if we can write some code that does this—map collection items by feeding them into a <a id="id194" class="indexterm"/>generator through <code class="literal">next()</code>:</p><div><pre class="programlisting">// This generator will keep iterating, as
// long as "next()" is called. It's expecting
// a value as well, so that it can call the
// "iteratee()" function on it, and yield the
// result.
function* genMapNext(iteratee) {
    var input = yield null;

    while (true) {
        input = yield iteratee(input);
    }
}

// Our array of values we want to map.
var array = [ 'a', 'b', 'c', 'b', 'a' ];

// A "mapper" generator. We pass an iteratee
// function as an argument to "genMapNext()".
var mapper = genMapNext(x =&gt;x.toUpperCase());

// Our starting point for the reduction.
var reduced = {};

// We have to call "next()" to bootstrap the
// generator. 
mapper.next();

// Now we can start iterating over the array.
// The "mapped" value is yielded from the
// generator. The value we want mapped is fed
// into the generator by passing it to "next()".
for (let item of array) {
    let mapped = mapper.next(item).value;

    // Our reduction logic takes the mapped value,
    // and adds it to the "reduced" object, counting
    // the number of duplicate keys.
    if (reduced.hasOwnProperty(mapped)) {
        reduced[mapped]++;
    } else {
        reduced[mapped] = 1;
    }
}

console.log('reduced', reduced);
// → reduced { A: 2, B: 2, C: 1 }</pre></div><p>As we can see, this is indeed possible. We're able to perform a lightweight map/reduce job using this approach. The mapper generator has the <code class="literal">iteratee</code> function that's applied to every item in the collection. As we iterate over the array, we're able to feed items into the generator by <a id="id195" class="indexterm"/>passing them to the <code class="literal">next()</code>method as an argument.</p><p>But, there's something about the previous method that just doesn't feel optimal—having to bootstrap the generator like this, and explicitly calling <code class="literal">next()</code>for every iteration feels clunky. In fact, could we not apply the<a id="id196" class="indexterm"/> <code class="literal">iteratee</code> function directly, instead of calling <code class="literal">next()</code>? It's these things that we need to be on the lookout while using generators; in particular, when passing data to generators. Just because we're able to, doesn't mean that it's a good idea.</p><p>Mapping and reducing would probably feel more natural, if we were to simply iterate over the generator just as we do with all other generators. We still want the lightweight mapping that generators give us, to, avoid the memory allocations. Let's try a different approach here—one that doesn't require the <code class="literal">next()</code> method:</p><div><pre class="programlisting">// This generator is a more useful mapper than
// "genMapNext()" because it doesn't rely on values
// coming into the generator through "next()".
//
// Instead, this generator accepts an iterable, and
// an iteratee function. The iterable is then
// iterated-over, and the result of the iteratee
// is yielded.
function* genMap(iterable, iteratee) {
    for (let item of iterable) {
        yield iteratee(item);
    }
}

// Creates our "mapped" generator, using an iterable
// data source, and an iteratee function.
var mapped = genMap(array, x =&gt;x.toUpperCase());
var reduced = {}

// Now we can simply iterate over our genrator, instead
// of calling "next()". The job of each loop iteration
// is to perform the reduction logic, instead of having
// to call "next()".
for (let item of mapped) {
    if (reduced.hasOwnProperty(item)) {
        reduced[item]++;
    } else {
        reduced[item] = 1;
    }
}

console.log('reduce improved', reduced);
// → reduce improved { A: 2, B: 2, C: 1 }</pre></div><p>This looks like an improvement. There's less code, and the flow of the generator is easy to grok. The difference is that we pass our array and <code class="literal">iteratee</code> function to the generator up front. Then, as <a id="id197" class="indexterm"/>we iterate over the generator, each item gets mapped lazily. The code that reduces this array into an object is simpler to read too.</p><p>The <code class="literal">genMap()</code> function<a id="id198" class="indexterm"/> that we've just implemented is generic, which is advantageous to us. In real applications, mappings are going to be more complex than an uppercase transformation. More likely, there will be multiple levels of mappings. That is, we map the collection, then map it N more times before reducing it. If we've done a good job designing our code, then we'll want to compose generators out of smaller iterated functions.</p><p>But how can we keep this generic and lazy? The idea is to have several generators, each serving as the input to the next. This means that as our reducer code iterates over these generators, only one<a id="id199" class="indexterm"/> item makes it's way through the various layers of mappings, to the reduction code. Let's take a stab at implementing this:</p><div><pre class="programlisting">// This function composes a generator
// function out of iteratees. The idea is to create
// a generator for each iteratee, so that each item
// from the original iterable, flows down, through
// each iteratee, before mapping the next item.
function composeGenMap(...iteratees) {

    // We're returning a generator function. That way,
    // the same mapping composition can be used on
    // several iterables, not just one.
    return function* (iterable) {

        // Creates the generator for each iteratee
        // passed to the function. The next generator
        // gets the previous generator as the "iterable"
        // argument.
        for (let iteratee of iteratees) {
            iterable = genMap(iterable, iteratee);
        }

        // Simply defer to the last iterable we created.
        yield* iterable;
    }
}

// Our iterable data source.
var array = [ 1, 2, 3 ];

// Creates a "composed" mapping generator, using 3
// iteratee functions.
var composed = composeGenMap(
    x =&gt; x + 1,
    x =&gt; x * x,
    x =&gt; x - 2
);

// Now we can iterate over the composed generator,
// passing it our iterable, and lazily mapping
// values.
for (let item of composed(array)) {
    console.log('composed', item)
}
// →
// composed 2
// composed 7
// composed 14</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>Coroutines</h1></div></div></div><p>Coroutines are a concurrency technique that allow for cooperative multitasking. What this means is that if one part of our application needs to perform part of a task, it can do so, and then hand control off to another part of the application. Think about a subroutine, or in more recent <a id="id200" class="indexterm"/>times, a function. These subroutines often rely on other subroutines. However, they don't just run in succession, they cooperate with one another.</p><p>In JavaScript, there's no intrinsic coroutine mechanism. Generators aren't coroutines, but they have similar properties. For example, generators can pause the execution of a function, yielding control to another context, then regain control and resume. This gets us partway there, but generators are for generating values, which isn't necessarily what we're after with coroutines. In this section, we'll look at some techniques for implementing coroutines in JavaScript using generators.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec60"/>Creating coroutine functions</h2></div></div></div><p>Generators give us most of what we need to implement <code class="literal">coroutine</code> functions in JavaScript; they can pause<a id="id201" class="indexterm"/> and resume executing. We just need to implement some minor abstractions around generators so that the functions that <a id="id202" class="indexterm"/>we're working with actually feel like calling <code class="literal">coroutine</code> functions, instead of iterating over generators. Here's a rough illustration of how we want our coroutines to behave when called:</p><div><img src="img/B05133_04_08.jpg" alt="Creating coroutine functions"/></div><p>The idea is that invoking the <code class="literal">coroutine</code> function moves from one <code class="literal">yield</code> statement to the next. And we can supply input to the coroutine by passing an argument, which is then returned by the<a id="id203" class="indexterm"/> <code class="literal">yield</code> statement. This is a lot to remember, so<a id="id204" class="indexterm"/> let's generalize these coroutine concepts in a function wrapper:</p><div><pre class="programlisting">// Taken from: http://syzygy.st/javascript-coroutines/
// This utility takes a generator function, and returns
// a coroutine function. Any time the coroutine is invoked,
// it's job is to call "next()" on the generator.
//
// The effect is that the generator function can run
// indefinitely, pausing when it hits "yield" statements.
function coroutine(func) {

    // Creates the generator, and moves the function
    // ahead to the first "yield" statement.
    var gen = func();
    gen.next();

    // The "val" is passed to the generator function
    // through the "yield" statement. It then resumes
    // from there, till it hits another yield.
    return function(val) {
        gen.next(val);
    }
}</pre></div><p>Pretty simple—five lines of code, but it's also powerful. The function returned by Harold's wrapper<a id="id205" class="indexterm"/> simply advances the generator to the next <code class="literal">yield</code> statement, supplying the argument to <code class="literal">next()</code>, if one was provided. It's one thing to make claims of utility, but let's actually use this<a id="id206" class="indexterm"/> thing to make a <code class="literal">coroutine</code> function:</p><div><pre class="programlisting">// Creates a coroutine function that when called,
// advances to the next yield statement.
var coFirst = coroutine(function* () {
    var input;

    // Input comes from the yield statement, and is
    // the argument value passed to "coFirst()".
    input = yield;
    console.log('step1', input);
    input = yield;
    console.log('step3', input);
});

// Works the same as the coroutine created above...
var coSecond = coroutine(function* () {
    var input;
    input = yield;
    console.log('step2', input);
    input = yield;
    console.log('step4', input);
});

// The two coroutines cooperating with one another,
// to produce the expected output. We can see that
// the second call to each coroutine picks up where
// the last yield statement left off.
coFirst('the money');
coSecond('the show');
coFirst('get ready');
coSecond('go');
// → 
// step1 the money
// step2 the show
// step3 get ready
// step4 go</pre></div><p>When there are a series of steps involved with fulfilling some task, we typically require bookkeeping code, temporary values, and so on. These aren't necessary with coroutines because the<a id="id207" class="indexterm"/> function simply pauses, leaving any local state intact. In<a id="id208" class="indexterm"/> other words, there's no need to intertwine concurrency logic with our application logic when coroutines do a decent job of hiding these details for us.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec61"/>Handling DOM events</h2></div></div></div><p>Somewhere else <a id="id209" class="indexterm"/>where we can use coroutines is with the DOM as event handlers. This works by adding the same <code class="literal">coroutine()</code> function as an event listener to several<a id="id210" class="indexterm"/> elements. Let's recall that each call to these coroutine functions talks to a single generator. This means that our coroutines that are setup to handle DOM events get passed in as a stream. It's almost like we're iterating over these events.</p><p>Since these <code class="literal">coroutine</code> functions use the same generator, it's easy for elements to talk to one another using this technique. The typical approach to DOM events involves callback functions that talk to some sort of central source that's shared among elements and maintains state. With coroutines, the state of element communications is implicit inside our function code. Let's use our coroutine wrapper in the context of DOM event handlers:</p><div><pre class="programlisting">// Coroutine function that's used with mousemove
// events.
var onMouseMove = coroutine(function* () {
    var e;

    // This loop continues indefinitely. The event
    // object comes in through the yield statement.
    while (true) {
        e = yield;

        // If the element is disabled, do nothing.
        // Otherwise, log a message.
        if (e.target.disabled) {
            continue;
        }

        console.log('mousemove', e.target.textContent);
    }
});

// Coroutine function that's used with click events.
var onClick = coroutine(function* () {

    // Store references to our two buttons. Since
    // coroutines are stateful, they'll always be 
    // available.
    var first = document.querySelector(
        'button:first-of-type');
    var second = document.querySelector(
        'button:last-of-type'),
    var e;

    while (true) {
        e = yield;

        // Disables the button that was clicked.
        e.target.disabled = true;

        // If the first button was clicked, toggle
        // the state of the second button.
        if (Object.is(e.target, first)) {
            second.disabled = !second.disabled;
            continue;
        }

        // If the second button was clicked, toggle
        // the state of the first button.
        if (Object.is(e.target, second)) {
            first.disabled = !first.disabled;
        }
    }
});

// Sets up the event handlers - our coroutine functions.
for (let button of document.querySelectorAll('button')) {
    button.addEventListener('mousemove', onMouseMove);
    button.addEventListener('click', onClick);
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec62"/>Handling promised values</h2></div></div></div><p>In the preceding section, we saw how the <code class="literal">coroutine()</code> function can be used to process DOM events. Instead of <a id="id211" class="indexterm"/>haphazardly adding callback functions that respond to DOM events, we use the same <code class="literal">coroutine()</code> function, which treats events as a stream of data. It's easier for DOM event <a id="id212" class="indexterm"/>handlers to cooperate with one another since they share the same generator context.</p><p>We can apply this same principle to <code class="literal">then()</code> callbacks of promises, which works in a similar way to the DOM coroutine approach. Instead of passing a regular function, we pass a coroutine to <code class="literal">then()</code>. When the promise resolves, the <code class="literal">coroutine</code> advances to the next <code class="literal">yield</code> statement along with a resolved value. Let's take a look at the following code:</p><div><pre class="programlisting">// An array of promises.
var promises = [];

// Our resolution callback is a coroutine. This means
// that every time it's called, a new resolved promise
// value shows up here.
var onFulfilled = coroutine(function* () {
    var data;

    // Continue to process resolved promise values
    // as they arrive.
    while (true) {
        data = yield;
        console.log('data', data);
    }
});

// Create 5 promises that resolve at random times,
// between 1 and 5 seconds.
for (let i = 0; i&lt; 5; i++) {
    promises.push(new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve(i);
    }, Math.floor(
        Math.random() * (5000 - 1000)) + 1000);
    }));
}

// Attach our fulfillment coroutine as a "then()" callback.
for (let promise of promises) {
    promise.then(onFulfilled);
}</pre></div><p>This is very useful because it provides something that static promise methods do not. The <code class="literal">Promise.all()</code> method forces us to wait for all the promises to resolve before resolving the returned <a id="id213" class="indexterm"/>promise. However, in the case where the resolved promise values aren't dependent on one another, we can simply iterate over them, responding as they resolve in any order.</p><p>We can achieve <a id="id214" class="indexterm"/>something similar by attaching plain functions to <code class="literal">then()</code> as callbacks, but then, we wouldn't have a shared context for promise values as they resolve. Another tactic we can adopt by combining promises with coroutines is to declare a handful of coroutines that respond differently, depending on the type of data they're responding to. These coroutines would then live on throughout the entire duration of the application, being passed to promises as they get created.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>Summary</h1></div></div></div><p>This chapter introduced you to the concept of generators, a new construct as of ES6, which allow us to implement lazy evaluation. Generators help us realize the conserve concurrency principle because we can avoid computations and intermediary memory allocations. There are a few new syntax forms associated with generators. First, there's the generator function, which always returns a generator instance. These are declared differently than regular functions. These functions are responsible for generating values, which rely on the <code class="literal">yield</code> keyword.</p><p>We then explored more advanced generator and lazy evaluation topics, including deferring to other generators, implementing map/reduce functionality, and passing data into generators. We closed the chapter with a look at how to use generators to make coroutine functions.</p><p>In the following chapter, we'll look at web workers—our first glimpse at utilizing parallelism in the browser environment.</p></div></body></html>