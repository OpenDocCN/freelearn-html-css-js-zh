- en: Chapter 11. Visualizing Information Networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine a specific type of layout known as a **force-directed
    graph**. These are a type of visualization that are generally utilized to display
    network information: interconnected nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: A particularly common type of network visualization is of the relationships
    within a social network. A visualization of a social network can help you understand
    how different people have formed various relationships. These include links between
    others as well as the way groups of people form clusters or cliques of friends
    and how those groups interrelate.
  prefs: []
  type: TYPE_NORMAL
- en: D3.js provides extensive capabilities for creating very complex network visualizations
    using force-directed networks. We will overview a number of representative examples
    of these graphs, cover a little bit of the theory of how they operate, and dive
    into a few examples to demonstrate their creation and usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of force-directed graphs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a basic force-directed graph
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying the length of the links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing nodes to move away from each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labeling the nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Forcing nodes to stay in place
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressing directionality and type with link visuals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of force-directed graphs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a number of means of rendering network data. A particularly common
    one, which we will examine in this chapter, is to use a class of algorithms known
    as force-directed layouts.
  prefs: []
  type: TYPE_NORMAL
- en: These algorithms position the nodes in the graph in a two or three dimensional
    space. The positioning is performed by assigning forces along edges and nodes,
    and then these forces are used to simulate moving the nodes into a position where
    the amount of energy in the entire system is minimized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a representative picture of a force-directed graph from a
    Wiki. Nodes are pages, and the lines between the nodes represent the links between
    the pages. Node size varies based on the number of links in/out of a particular
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of force-directed graphs](img/B04320_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The fundamental components of a force-directed graph are the nodes in the graph
    and the relations between those nodes. The graph is iteratively laid out, usually
    animated during the process, and can take quite a few iterations to **stabilize**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The force layout algorithm in D3.js takes into account a number of factors.
    A few of the important parameters of the algorithm and how they influence the
    simulation are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size (width and height)**: This represents an overall size of the diagram,
    and a center of gravity, normally the center of the diagram. Nodes in the diagram
    will tend to move towards this point. If nodes do not have an initial `x` and
    `y` position, then they will be placed randomly in a position between 0 and width
    in the `x` direction and height in the `y` direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Charge**: This describes how much a node attracts other nodes. Negative values
    push away other nodes, and positive numbers attract. The larger the value in either
    direction, the stronger is the force in that direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Charge distance**: This specifies the maximum distance over which charge
    has effect (it defaults to infinity). Smaller values assist in performance of
    the layout, and result in a more localized layout of nodes in clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friction**: Represents an amount of velocity delay. This value should be
    in the range of `[0, 1]`. At each tick of the layout, the velocity of every node
    is multiplied by this value. Using a value of 0 therefore, freezes all nodes in
    place, and `1` is a frictionless environment. Values in between eventually slow
    the nodes to a point where overall motion is small enough, and the simulation
    can be considered complete as the total amount of movement falls below the layout
    threshold at which point the graph is referred to as stable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link distance**: This specifies a desired distance between nodes at the end
    of the simulation. At each tick of the simulation, the distance between linked
    nodes is compared to this value, and nodes move towards or away from each other
    to try to reach the desired distance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Link strength**: This is a value in the range of `[0, 1]`, specifying how
    stretchable the link distance is during the simulation. A value of 0 is rigid
    and `1` is completely flexible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gravity**: This specifies an attraction of each node to the center of the
    layout. This is a weak geometric constraint. That is, the higher the overall gravity,
    the further away it is from the center of the rendering. This value is useful
    for keeping layouts relatively centered in the diagram and in keeping disconnected
    nodes from flying out to infinity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will go over enough of these parameters to get a good feel for making useful
    visualizations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More detail on all the layout parameters is available at [https://github.com/mbostock/d3/wiki/Force-Layout](https://github.com/mbostock/d3/wiki/Force-Layout).
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the parameters that facilitate the actual layout of the nodes,
    it is also possible to use other visual in a force-directed graph to convey various
    values in the underlying information:'
  prefs: []
  type: TYPE_NORMAL
- en: The color of a node can be used to distinguish nodes of particular types, such
    as people versus employers, or by their relation, such as all persons who work
    at a particular employer, or how many degrees of separation the node is from another
    node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of a node, which generally represents the magnitude of importance of
    the node. Often the number of links influence the size of a node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The thickness of the rendering of a link can be used to demonstrate that certain
    links have more influence than others or that the links are of particular types,
    that is, highways versus railways.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The directionality of link, showing that the link has either no directionality
    or is one or bi-directional.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A simple force-directed graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our first example will demonstrate how to construct a force-directed graph.
    The online example is available at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (11.1): [http://goo.gl/ZyxCej](http://goo.gl/ZyxCej)'
  prefs: []
  type: TYPE_NORMAL
- en: All our force-directed graphs will start by loading data that represents a network.
    This example uses the data at [https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/ba3b2e3065ca8eafb375f01155dc99c569fae66b/uni_network.json](https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/ba3b2e3065ca8eafb375f01155dc99c569fae66b/uni_network.json).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the contents of the file at the preceding link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The force-directed layout algorithms in D3.js require the data to be in this
    format. This needs to be an object with a `nodes` and an `edges` property. The
    `nodes` property can be an array of any other objects you like to use. These are
    typically your data items.
  prefs: []
  type: TYPE_NORMAL
- en: The `edges` array must consist of objects with both `source` and `target` properties,
    and the value for each is the index into the `nodes` array of the source and target
    nodes. You can add other properties, but we need to supply at least these two.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start rendering the graph, we load this data and get the main SVG element
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the layout for the graph using `d3.layout.force()`.
    There are many options, several of which we will explore over the course of our
    examples, but we start with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This informs the layout about the location of the nodes and links using the
    `.node()` and `.link()` functions respectively. The call to `.size()` informs
    the layout about the area to constrain the layout within and has two effects on
    the graph: the gravitational center and the initial random position.'
  prefs: []
  type: TYPE_NORMAL
- en: The call to `.start()` begins the simulation, and must be called after the layout
    is created and the nodes and links are assigned. If the nodes and links change
    later, it can be called again to restart the simulation. Note that the simulation
    starts after this function returns, not immediately. So, you can still make other
    changes to the visual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can render the links and nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that we also chained the `.call()` function passing it a reference to the
    `force.drag` function of our layout. This function is provided by the layout object
    to easily allow us a means of dragging the nodes in the network.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more step required. A force layout is a simulation and consists
    of a sequence of **ticks** that we must handle. Each tick represents that the
    layout algorithm has passed over the nodes and recalculated their positions, and
    this gives us the opportunity to reposition the visuals.
  prefs: []
  type: TYPE_NORMAL
- en: 'To hook into the ticks, we can use the `force.on()` function, telling it that
    we want to listen to `tick` events, and on each event, call a function to allow
    us to reposition our visuals. The following is our function for this activity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: On each tick, we need to reposition each node and edge appropriately. Notice
    how we are doing this. D3.js has added to our data `x` and a `y` properties, which
    are the calculated position. It also has added a `px` and `py` property to each
    data node, which represents the previous `x` and `y` position.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use `start` and `end` as parameters of the `on()` method to trap
    when the simulation begins and completes.
  prefs: []
  type: TYPE_NORMAL
- en: 'On running this, the output will be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple force-directed graph](img/B04320_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Every time this example is executed, the nodes will finish in a different position.
    This is due to the algorithm specifying a random start position for each node.
  prefs: []
  type: TYPE_NORMAL
- en: The nodes are very close in this example, to the point where the links are almost
    not visible. But it is possible to drag the nodes with the mouse, which will expose
    the links. Also notice that the layout is executed while you drag and the nodes
    snap back to the middle when the dragged node is released.
  prefs: []
  type: TYPE_NORMAL
- en: Using link distance to spread out the nodes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These nodes in the previous example are a little too close together and we
    have a hard time seeing the edges. To add more distance between the nodes, we
    can specify a link distance. This is demonstrated by the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (11.2): [http://goo.gl/dd1T3O](http://goo.gl/dd1T3O)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The one modification this example makes to the previous one is that it increases
    the link distance to `200` (the default is `20`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This modification results in some better spacing of the nodes at the end of
    the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using link distance to spread out the nodes](img/B04320_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Drag the nodes around. It will demonstrate some of the physics in play:'
  prefs: []
  type: TYPE_NORMAL
- en: No matter where you move any node(s), the graph returns to the center of the
    visualization. This is the effect of gravity on the layout and of it being placed
    in the center.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The nodes always come together, but are always at least the link distance apart.
    The gravity attracts them to the center and the default charge, which is `-30`,
    makes the nodes push away from each other, but not enough to stretch the links
    much or make the nodes escape the center of gravity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding point has an important ramification in the result of the visualization.
    The links between nodes will generally cross each other. In many network visualizations,
    it is desirable to try and make the links not cross each other, as it simplifies
    the ability to follow the links, and hence, the relationships. We will examine
    how to fix this in the next example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding repulsion to nodes for preventing crossed links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The means by which we attempt to prevent crossing links is to apply an amount
    of repulsion to each of the nodes. When the amount of repulsion exceeds the pull
    of the center of gravity, the nodes can move away from this point. They will also
    move away from the other nodes, tending to expand the result graph out to a maximum
    size, with the effect of causing the links to not cross.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates node repulsion:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (11.3): [http://goo.gl/PCHK68](http://goo.gl/PCHK68)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This example makes two modifications to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This creates a charge with a value of `-5000`, meaning that the nodes actually
    repulse each other. There is also a smaller link distance, as the repulsion will
    push the nodes apart quite a bit, therefore stretching the links. Leaving the
    links at `200` would make the links very long.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this simulation completes, you will have a graph that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding repulsion to nodes for preventing crossed links](img/B04320_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice how the nodes now tried to get as far away from each other as possible!
    The links were stretched quite a bit too, event though the link distance is set
    to `1`. Links are, by default, elastic and will be stretched or compressed based
    on the charges and gravity in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Rerun this simulation again and again. You will notice that it almost always
    converges to this same shape with the nodes in the same relative places in the
    graph (the group itself will likely be rotated a different amount each time).
    In a really rare case, there may still be a crossed edge, but the repulsion is
    set high enough to prevent this for most executions.
  prefs: []
  type: TYPE_NORMAL
- en: Labelling the nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Something that has been missing in our force-directed graphs is labelling of
    the nodes so that we can tell what data the nodes represent. The following example
    demonstrates how to add labels to the nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (11.4): [http://goo.gl/31VfSU](http://goo.gl/31VfSU)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference in this preceding example is that instead of representing a
    node by a single circle SVG element, we represent it by a group which contains
    both a circle and a text element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we need one more change during the processing of the tick event. Since
    we now need to position an SVG group instead of a circle, this code needs to translate
    the group into position instead of using the `x` and `y` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this example now looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Labelling the nodes](img/B04320_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Making nodes stick in place
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common—and frustrating—issue when examining nodes in a force network is that
    when you move one node of a clump of other nodes to see it better and then let
    it go, it goes back to where it was. I'll bet you've experienced this madness
    already just while using these examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The can be remidied by using a concept known as making the nodes sticky. The
    following example demonstrates this in operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (11.5): [http://goo.gl/nmQu3d](http://goo.gl/nmQu3d)'
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you drag a node, it will stay where you leave it. Nodes that are fixed
    in place will change to have a thick black border. To release a node, double click
    it and it will be put back into the force layout.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows this with three nodes fixed in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making nodes stick in place](img/B04320_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s examine the modifications needed to make this work. This works by
    adding a few function chains to our code to create the circles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When the circle is first created, in addition to having its fill color specified,
    it will also have a stroke color of black but of width `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, instead of using `.call(force.drag)`, we replace that with a custom drag
    implementation. At the start of the drag, the code sets a property, `fixed,` on
    the data object to `true`. If the force layout object sees that the object has
    this property, and its value is `true`, then it will not attempt to reposition
    the item. And then, the border is set to be three pixels in width.
  prefs: []
  type: TYPE_NORMAL
- en: The last modification is to handle the `dblclick` mouse event, which will set
    the fixed property to `false`, releasing the node to be part of the layout and
    then hiding the thick border.
  prefs: []
  type: TYPE_NORMAL
- en: Adding directionality markers and style to the links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relationships between a node can be one-way or bi-directional. The code we have
    written so far assumed one-way, or perhaps, non-directional. Let's now look at
    how we can express the direction in the relationship by adding arrow heads to
    the lines.
  prefs: []
  type: TYPE_NORMAL
- en: The example we will create will assume that each entry in the edges collection
    of the data represents a one-way link from the source to the target. If there
    is a bi-directional link, there will be an additional entry in `edges` with the
    source and target reversed.
  prefs: []
  type: TYPE_NORMAL
- en: The example will use the data from [https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/8469d2a7da14c1c8180ebb2ea8ddf1e2944f990c/multi_network.html](https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/8469d2a7da14c1c8180ebb2ea8ddf1e2944f990c/multi_network.html),
    which has several bi-directional links added as well as a `type` property to specify
    the type of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The edges collection in this data is the following. The nodes have not changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'bl.ock (11.6): [https://goo.gl/hucTe1](https://goo.gl/hucTe1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image depicts the result of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding directionality markers and style to the links](img/B04320_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's see how the code goes about creating this visualization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that is changed in this example is that it uses styles to color
    the different types of links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code to load the data and to set up the SVG element and the force layout
    is the same as the last example. The other difference is that the code needs to
    determine the specifc link types as they will be used for markers and styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, there are markers created for each of the link types. These will render
    a curved path with an arrow head on each end, created by the last chained function
    to set the `d` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create the edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using a line, the code now uses a path. The `d` property of the path
    is not specified at this time. It will be set at every tick of the simulation.
    This path references one of the styles by using the type as part of the class
    name, and the `marker-end` attributes specifies which marker definition to use
    for this segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The circles are created in the same manner as the previous example, and so
    is the text. The last change is that the tick handler is modified to not only
    reposition the nodes, but to also regenerate paths based on arcs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explained how to use D3.js for generating force-directed
    graphs. These types of graphs are some of the most interesting types of graphs
    and can be used to visualize large sets of interconnected data such as social
    networks.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter started by going over the basic concepts of creating a graph, stepping
    through an example that progressively refined the graph, while making the effort
    to demonstrate how several of the parameters effect the result of the graph.
  prefs: []
  type: TYPE_NORMAL
- en: We then covered several techniques for enhancing and making the graphs more
    usable. These included labeling nodes with text, replacing nodes with images,
    and styling links to show direction and type.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover using D3.js for creating maps. We will also
    learn quite a bit about GeoJSON and TopoJSON, both of which, when combined with
    D3.js, allow us to create complex visuals based on geographic data.
  prefs: []
  type: TYPE_NORMAL
