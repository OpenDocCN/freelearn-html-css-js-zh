<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Object-Oriented Programming with TypeScript</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned how to work with functions and how to take advantage of some asynchronous programming APIs. In this chapter, we are going to learn how to implement TypeScript applications using the <strong>object-oriented programming</strong> (<strong>OOP</strong>) paradigm. We are going to learn about the following topics:</p>
<ul>
<li>Classes</li>
<li>Association, aggregation, and composition</li>
<li>Inheritance</li>
<li>Mixins</li>
<li>Generic classes</li>
<li>Generic constraints</li>
<li>Interfaces</li>
<li>The SOLID principles</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Classes</h1>
                </header>
            
            <article>
                
<p>We should already be familiar with the basics of TypeScript classes, as we have declared some of them in previous chapters. We will now look at some details and OOP concepts through examples. Let's start by declaring a simple class:</p>
<pre>class Person { 
    public name: string; 
    public surname: string; 
    public email: string; 
    public constructor( 
        name: string, surname: string, email: string 
    ) { 
        this.email = email; 
        this.name = name; 
        this.surname = surname; 
    } 
    public greet() { 
        console.log("Hi!"); 
    } 
} </pre>
<p>We use classes to represent the type of an object or entity. A <strong>class</strong> is composed of a name, <strong>properties</strong> (also known as <strong>attributes</strong>), and <strong>methods</strong>. Both methods and properties are known as <strong>members</strong>. Class properties are used to describe the object's characteristics, while class methods are used to describe its behavior.</p>
<p>The class in the preceding example is named <kbd>Person</kbd> and contains three attributes or properties (<kbd>name</kbd>, <kbd>surname</kbd>, and <kbd>email</kbd>) and two methods (<kbd>constructor</kbd> and <kbd>greet</kbd>).</p>
<p>A <strong>constructor</strong> is a special method used by the <kbd>new</kbd> keyword to create <strong>instances</strong> (also known as <strong>objects</strong>) of our class. We have declared a variable named <kbd>me</kbd>, which holds an instance of the <kbd>Person</kbd> class. The <kbd>new</kbd> keyword uses the <kbd>Person</kbd> class's constructor to return an object whose type is <kbd>Person</kbd>:</p>
<pre>const person = new Person( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Strict property initialization</h1>
                </header>
            
            <article>
                
<p>Since the release of TypeScript 2.7, a compile-time error will be thrown if strict mode is enabled and we forget to initialize one of the properties of a class. For example, the following class initializes the property named <kbd>height</kbd> using a method, and the property named <kbd>width</kbd> using its constructor. TypeScript knows that if an instance of the class is created, a value will be assigned to the <kbd>width</kbd> property. However, it has no way to ensure that a value is assigned to the <kbd>height</kbd> property. If strict mode is enabled, an error will be thrown:</p>
<pre>class Rectangle { 
 
    public width: number; 
    public height: number; // Error 
 
    public constructor(width: number) { 
        this.width = width; 
    } 
 
    public setHeight(height: number) { 
        this.height = height; 
    } 
 
} </pre>
<p>We can use the <kbd>!</kbd> operator to let TypeScript know that we don't want an error to be thrown:</p>
<pre>class Rectangle { 
 
    public width: number; 
    public height!: number; // OK 
 
    public constructor(width: number) { 
        this.width = width; 
    } 
 
    public setHeight(height: number) { 
        this.height = height; 
    } 
 
} </pre>
<p>It is very common to encounter this compilation error when we define a class without a constructor:</p>
<pre>class Rectangle { 
    public width: number; // Error 
    public height: number; // Error 
} </pre>
<p>We can use the <kbd>!</kbd> operator to solve the compile-time error when we don't want to define a constructor:</p>
<pre>class Rectangle { 
    public width!: number; // OK 
    public height!: number; // OK 
} </pre>
<p>Alternatively, we can initialize the properties with a default value:</p>
<pre>class Rectangle6 { 
    public width: number = 0; // OK 
    public height: number = 0; // OK 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inheritance</h1>
                </header>
            
            <article>
                
<p>One of the most fundamental OOP features is its capability to extend existing classes. This feature is known as <strong>inheritance</strong> and allows us to create a new class (child class) that inherits all the properties and methods from an existing class (parent class). Child classes can include additional properties and methods that are not available in the parent class.</p>
<p>We are going to use the <kbd>Person</kbd> class that we declared in the preceding section as the parent class of a child class named <kbd>Teacher</kbd>. We can extend the parent class (<kbd>Person</kbd>) by using the reserved keyword <kbd>extends</kbd>:</p>
<pre>class Teacher extends Person { 
    public teach() { 
        console.log("Welcome to class!"); 
    } 
} </pre>
<p>The <kbd>Teacher</kbd> class will inherit all the attributes and methods from its parent class. However, we have also added a new method named <kbd>teach</kbd> to the <kbd>Teacher</kbd> class.</p>
<p>If we create instances of the <kbd>Person</kbd> and <kbd>Teacher</kbd> classes, we will be able to see that both instances share the same attributes and methods except for the <kbd>teach</kbd> method, which is only available for the instance of the <kbd>Teacher</kbd> class:</p>
<pre>const person = new Person( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
const teacher = new Teacher( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
person.greet(); // "Hi!" 
teacher.greet(); // "Hi!" 
person.teach(); // Error 
teacher.teach(); // "Welcome to class!" </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Depth of the inheritance tree (DIT)</h1>
                </header>
            
            <article>
                
<p>We can also declare a new class that inherits from a class, which is already inheriting from another class. In the following code snippet, we declare a class called <kbd>SchoolPrincipal</kbd> that <kbd>extends</kbd> the <kbd>Teacher</kbd> class, which extends the <kbd>Person</kbd> class:</p>
<pre>class SchoolPrincipal extends Teacher { 
    public manageTeachers() { 
        return console.log( 
            `We need to help our students!` 
        ); 
    } 
} </pre>
<p>If we create an instance of the <kbd>SchoolPrincipal</kbd> class, we will be able to access all the properties and methods from its parent classes (<kbd>SchoolPrincipal</kbd>, <kbd>Teacher</kbd>, and <kbd>Person</kbd>):</p>
<pre>const principal = new SchoolPrincipal( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
principal.greet(); // "Hi!" 
principal.teach(); // "Welcome to class!" 
principal.manageTeachers(); // "We need to help our students!" </pre>
<div class="packt_infobox">It is <strong>not recommended to have too many levels in the inheritance tree</strong>. A class situated too deeply in the inheritance tree will be relatively complex to develop, test, and maintain.</div>
<p>Unfortunately, we don't have a specific rule that we can follow when we are unsure whether we should increase the <strong>depth of the inheritance tree</strong> (<strong>DIT</strong>).</p>
<p>We should use inheritance in such a way that it helps us to reduce the complexity of our application and not the opposite. We should try to keep the DIT between zero and four because a value greater than four would compromise encapsulation and increase complexity.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Access modifiers</h1>
                </header>
            
            <article>
                
<p>TypeScript allows us to restrict the access to the properties and methods of a class using the <kbd>public</kbd>, <kbd>private</kbd>, and <kbd>protected</kbd> keywords.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The public access modifier</h1>
                </header>
            
            <article>
                
<p>If we use the <kbd>public</kbd> modifier, the method or property can be accessed by other objects. The following example redeclares the <kbd>Person</kbd> and <kbd>Teacher</kbd> classes that we have used in the preceding section. It is important to note that the <kbd>public</kbd> access modifier is used in all the properties of the class, but for this example, we are going to pay special attention to the property named <kbd>email</kbd>:</p>
<pre><a>class Person {</a> 
    public name: string; 
    public surname: string; 
    public email: string; 
    public constructor( 
        name: string, surname: string, email: string 
    ) { 
        this.email = email; 
        this.name = name; 
        this.surname = surname; 
    } 
    public greet() { 
        console.log("Hi!"); 
    } 
} 
 
class Teacher extends Person { 
    public teach() { 
        console.log("Welcome to class!"); 
    } 
} </pre>
<p>If we create an instance of both the <kbd>Person</kbd> and <kbd>Teacher</kbd> classes, we will be able to confirm that the <kbd>email</kbd> property can be accessed by both instances and by an external object such as the <kbd>console</kbd> object:</p>
<pre><a>const person = new Person(</a> 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
const teacher = new Teacher( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
console.log(person.email); // ""remo.jansen@wolksoftware.com" 
console.log(teacher.email); // ""remo.jansen@wolksoftware.com" </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The private access modifier</h1>
                </header>
            
            <article>
                
<p>If we use the <kbd>private</kbd> modifier, the method or property can only be accessed by the object that owns them.</p>
<p>The following example redeclares, once more, the classes that we declared in the preceding example, but uses the <kbd>private</kbd> access modifier instead of the <kbd>public</kbd> modifier. The example also adds a couple of extra methods to the classes to demonstrate the implications of using a <kbd>private</kbd> access modifier:</p>
<pre>class Person { 
    public name: string; 
    public surname: string; 
    private _email: string; 
    public constructor( 
        name: string, surname: string, email: string 
    ) { 
        this._email = email; 
        this.name = name; 
        this.surname = surname; 
    } 
    public greet() { 
        console.log("Hi!"); 
    } 
    public getEmail() { 
        return this._email; 
    } 
} 
 
class Teacher extends Person { 
    public teach() { 
        console.log("Welcome to class!"); 
    } 
<a>public shareEmail() {</a> 
        console.log(`My email is ${this._email}`); // Error 
    } 
} </pre>
<p>If we create an instance of both the <kbd>Person</kbd> and <kbd>Teacher</kbd> classes, we will be able to observe that the <kbd>getEmail</kbd> method, which belongs to the <kbd>Person</kbd> instance, can access the <kbd>private</kbd> property. However, the <kbd>private</kbd> property, <kbd>email</kbd>, cannot be accessed from the method named <kbd>shareEmail</kbd>, which is declared by the derived  <kbd>Teacher</kbd> <span>class. </span>Also, other objects (such as the <kbd>console</kbd> object) cannot access the <kbd>private</kbd> property. This code snippet confirms that the <kbd>email</kbd> property can only be accessed by the instances of the <kbd>Person</kbd> class:</p>
<pre>const person = new Person( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
const teacher = new Teacher( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
console.log(person._email); // Error 
console.log(teacher._email); // Error 
<a>teacher.getEmail();</a></pre>
<p>We can update the <kbd>Teacher</kbd> class to use the public <kbd>getEmail</kbd> method instead of trying to access the <kbd>private</kbd> property directly:</p>
<pre>class Teacher extends Person { 
    public teach() { 
        console.log("Welcome to class!"); 
    } 
    public shareEmail() { 
        console.log(`My email is ${this.getEmail()}`); // OK 
    } 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The protected access modifier</h1>
                </header>
            
            <article>
                
<p>If we use the <kbd>protected</kbd> modifier, the method or property can only be accessed by the object that owns them or instances of the derived classes.</p>
<p>The following example declares, once more, the classes that we declared in the preceding examples, but uses the <kbd>protected</kbd> access modifier instead of the <kbd>public</kbd> modifier:</p>
<pre>class Person { 
    public name: string; 
    public surname: string; 
    protected _email: string; 
    public constructor( 
        name: string, surname: string, email: string 
    ) { 
        this._email = email; 
        this.name = name; 
        this.surname = surname; 
    } 
    public greet() { 
        console.log("Hi!"); 
    } 
} 
 
class Teacher extends Person { 
    public teach() { 
        console.log("Welcome to class!"); 
    } 
    public shareEmail() { 
        console.log(`My email is ${this._email}`); 
    } 
} </pre>
<p>If we create an instance of both the <kbd>Person</kbd> and <kbd>Teacher</kbd> classes, we will be able to observe that the <kbd>protected</kbd> property, <kbd>email</kbd>, can be accessed from the method named <kbd>shareEmail</kbd>, which is declared by the derived  <kbd>Teacher</kbd> <span>class. </span>However, other objects (such as the <kbd>console</kbd> object) cannot access the <kbd>private</kbd> property. This code snippet confirms that the <kbd>email</kbd> property can only be accessed by the instances of the <kbd>Person</kbd> class or derived classes, but it cannot be accessed by other objects:</p>
<pre>const person = new Person( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
const teacher = new Teacher( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
console.log(person._email); // Error 
console.log(teacher._email); // Error 
teacher.shareEmail(); // "My email is remo.jansen@wolksoftware.com" </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Parameter properties</h1>
                </header>
            
            <article>
                
<p>In TypeScript, when we declare a class, we can define its properties and initialize some or all of the properties using the class constructor:</p>
<pre>class Vector { 
    private x: number; 
    private y: number; 
    public constructor(x: number, y: number) { 
        this.x = x; 
        this.y = y; 
    } 
} </pre>
<p>However, we can use an alternative syntax, which allows us to declare the properties and initialize them using the class constructor in a less verbose way. We only need to remove the property declarations and its initialization, and add access modifiers to the arguments of the constructor of the class.</p>
<p>The preceding code snippet declares a class with an identical behavior to the following class. However, it uses the parameter properties syntax:</p>
<pre>class Vector { 
    public constructor( 
        private x: number, 
        private y: number 
    ) {} 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Class expressions</h1>
                </header>
            
            <article>
                
<p>We can use two different APIs to declare a class. The first one is the class declaration syntax that we used during the preceding section. The second one is an alternative syntax known as a class expression.</p>
<p>The following code snippet redeclares the <kbd>Person</kbd> class that we declared in the preceding section using the class expression syntax:</p>
<pre>const Person = class { 
    public constructor( 
        public name: string, 
        public surname: string, 
        public email: string 
    ) {} 
    public greet() { 
        console.log("Hi!"); 
    } 
}; </pre>
<p>There are no differences between the creation of an instance of a class declared using the class expression syntax and one declared using the class declaration syntax:</p>
<pre>const person = new Person( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Static members</h1>
                </header>
            
            <article>
                
<p>We can use the <kbd>static</kbd> keyword to enable the usage properties and methods in a class without needing to create an instance of it:</p>
<pre>class TemperatureConverter { 
 
    public static CelsiusToFahrenheit( 
        celsiusTemperature: number 
    ) { 
        return (celsiusTemperature * 9 / 5) + 32; 
    } 
 
    public static FahrenheitToCelsius( 
        fahrenheitTemperature: number 
    ) { 
        return (fahrenheitTemperature - 32) * 5 / 9; 
    } 
 
} </pre>
<p>As we can observe in the preceding code snippet, the <kbd>TemperatureConverter</kbd> class has two static methods named <kbd>CelsiusToFahrenheit</kbd> and <kbd>FahrenheitToCelsius</kbd>. We can invoke these methods without creating an instance of the <kbd>TemperatureConverter</kbd> class:</p>
<pre>let fahrenheit = 100; 
let celsius = TemperatureConverter.FahrenheitToCelsius(fahrenheit); 
fahrenheit = TemperatureConverter.CelsiusToFahrenheit(celsius); </pre>
<p>When a method or property is not static, we refer to it as an instance method or an instance property. It is possible to declare classes that have both static and instance methods or properties:</p>
<pre>class Vector3 { 
 
    public static GetDefault() { 
        return new Vector3(0, 0, 0); 
    } 
 
    public constructor( 
        private _x: number, 
        private _y: number, 
        private _z: number 
    ) {} 
 
    public length() { 
        return Math.sqrt( 
            this._x * this._x + 
            this._y * this._y + 
            this._z * this._z 
        ); 
    } 
 
    public normalize() { 
        let len = 1 / this.length(); 
        this._x *= len; 
        this._y *= len; 
        this._z *= len; 
    } 
 
} </pre>
<p>The preceding class declares a vector in a 3D space. The vector class has instance methods to calculate the length of the vector and to normalize it (change its length to <kbd>1</kbd> without changing its direction). We can create instances of the class using the class constructor and the <kbd>new</kbd> keyword:</p>
<pre>const vector2 = new Vector3(1, 1, 1); 
vector2.normalize(); </pre>
<p>However, the class also has a static method named <kbd>GetDefault</kbd>, which can be used to create a default instance:</p>
<pre>const vector1 = Vector3.GetDefault(); 
vector1.normalize(); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Optional members</h1>
                </header>
            
            <article>
                
<p>We can define optional class properties and methods by appending the <kbd>?</kbd> character at the end of the name of a property or method. This behavior is like the behavior that we observed in <a href="82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml">Chapter 3</a>, <em>Working with Functions,</em> when we learned how to use the <kbd>?</kbd> character to declare optional arguments in a function.</p>
<p>The following code snippet defines a class named <kbd>Vector</kbd> with an optional property named <kbd>z</kbd>. When we define a <kbd>Vector</kbd> instance using numeric values for the properties <kbd>x</kbd> and <kbd>y</kbd>, the <kbd>Vector</kbd> has two dimensions. When we define a <kbd>Vector</kbd> instance using numeric values for the properties <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd>, the <kbd>Vector</kbd> has three dimensions:</p>
<pre>class Vector { 
 
    public constructor( 
        public x: number, 
        public y: number, 
        public z?: number 
    ) {} 
 
    public is3D() { 
        return this.z !== undefined; 
    } 
 
    public is2D() { 
        return this.z === undefined; 
    } 
 
} </pre>
<p>The following code snippet declares a <kbd>Vector</kbd> instance using only two constructor arguments. As a result, the optional property, <kbd>z</kbd>, will be <kbd>undefined</kbd>:</p>
<pre>const vector2D = new Vector(0, 0); 
vector2D.is2D(); // true 
vector2D.is3D(); // false 
 
const lenght1 = Math.sqrt( 
    vector2D.x * vector2D.x + 
    vector2D.y * vector2D.y + 
    vector2D.z * vector2D.z // Error 
); </pre>
<p>The following code snippet declares a <kbd>Vector</kbd> instance using three constructor arguments. As a result, the optional property, <kbd>z</kbd>, will be defined:</p>
<pre>const vector3D = new Vector(0, 0, 0); 
vector3D.is2D(); // false 
vector3D.is3D(); // true 
 
const lenght2 = Math.sqrt( 
    vector3D.x * vector3D.x + 
    vector3D.y * vector3D.y + 
    ((vector3D.z !== undefined) ? (vector3D.z * vector3D.z) : 0) // OK 
); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Read-only properties</h1>
                </header>
            
            <article>
                
<p>The <kbd>readonly</kbd> keyword is a modifier that can be applied to the properties of a class. When a property declaration includes a <kbd>readonly</kbd> modifier, assignments to the property can only take place as part of the declaration or in a constructor in the same class.</p>
<p>The following example showcases how the <kbd>readonly</kbd> modifier prevents assignments to the  <kbd>x</kbd>, <kbd>y</kbd>, and <kbd>z</kbd> <span>properties:</span></p>
<pre><a>class Vector3 {</a> 
 
    public constructor( 
        public readonly x: number, 
        public readonly y: number, 
        public readonly z: number 
    ) {} 
 
    public length() { 
        return Math.sqrt( 
            this.x * this.x + 
            this.y * this.y + 
            this.z * this.z 
        ); 
    } 
 
    public normalize() { 
        let len = 1 / this.length(); 
        this.x *= len; // Error 
        this.y *= len; // Error 
        this.z *= len; // Error 
    } 
 
} </pre>
<p>We can fix the compilation errors in the preceding code snippet by modifying the <kbd>normalize</kbd> method so that it returns a new vector (instead of modifying the original vector):</p>
<pre>class Vector3 { 
 
    public constructor( 
        public readonly x: number, 
        public readonly y: number, 
        public readonly z: number 
    ) {} 
 
    public length() { 
        return Math.sqrt( 
            this.x * this.x + 
            this.y * this.y + 
            this.z * this.z 
        ); 
    } 
 
    public normalize() { 
        let len = 1 / this.length(); 
        return new Vector3( 
            this.x * len, // OK 
            this.y * len, // OK 
            this.z * len  // OK 
        ); 
    } 
 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Method overriding</h1>
                </header>
            
            <article>
                
<p>Sometimes, we will need a child class to provide a specific implementation of a method that is already provided by its parent class. We can use the reserved keyword <kbd>super</kbd> for this purpose.</p>
<p>We are going to use, once more, the <kbd>Person</kbd> and <kbd>Teacher</kbd> classes declared during the <em>Inheritance</em> section in this chapter.</p>
<p>Imagine that we want to add a new attribute to list the teacher's subjects, and we want to be able to initialize this attribute through the teacher constructor. We are going to use the <kbd>super</kbd> keyword to explicitly reference the parent class constructor inside the child class constructor:</p>
<pre>class Person { 
    public constructor( 
        public name: string, 
        public surname: string, 
        public email: string 
    ) {} 
    public greet() { 
        console.log("Hi!"); 
    } 
} 
 
<a>class Teacher extends Person {</a> 
    public constructor( 
        name: string, 
        surname: string, 
        email: string, 
        public subjects: string[] 
    ) { 
        super(name, surname, email); 
        this.subjects = subjects; 
    } 
    public greet() { 
        super.greet(); 
        console.log("I teach " + this.subjects.join(" &amp; ")); 
    } 
    public teach() { 
        console.log("Welcome to class!"); 
    } 
} </pre>
<p>We have also used the <kbd>super</kbd> keyword to extend an existing method, such as <kbd>greet</kbd>. This OOP language feature that allows a subclass or child class to provide a specific implementation of a method that is already provided by its parent classes is known as <strong>method overriding</strong>.</p>
<p>At this point, we can create an instance of the <kbd>Person</kbd> and <kbd>Teacher</kbd> classes to observe their differences:</p>
<pre>const person = new Person( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com" 
); 
 
const teacher = new Teacher( 
    "Remo", 
    "Jansen", 
    "remo.jansen@wolksoftware.com<a>",</a> 
    ["math", "physics"] 
); 
 
<a>person.greet(); // "Hi!"</a> 
teacher.greet(); // "Hi! I teach math &amp; physics" 
person.teach(); // Error 
teacher.teach(); // "Welcome to class!" </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic classes</h1>
                </header>
            
            <article>
                
<p>In the previous chapter, we learned how to work with generic functions. Now, we will look at how to work with generic classes.</p>
<p>Just like with generic functions, generic classes can help us to avoid the duplication of code. Let's look at an example:</p>
<pre><a>class User {</a> 
    public name!: string; 
    public surname!: string; 
} </pre>
<p>We have declared a class named <kbd>User</kbd> with two properties named <kbd>name</kbd> and <kbd>password</kbd>. We will now declare a class named <kbd>UserQueue</kbd>. A queue is a data structure that we can use to store a list of items. Items can be added at the end of the list and removed from the beginning of the list. For this reason, a queue is considered a <strong>first-in-first-out</strong> (<strong>FIFO</strong>) data structure. The <kbd>UserQueue</kbd> class doesn't use generics:</p>
<pre>class UserQueue { 
    private _items: User[] = []; 
    public push(item: User) { 
        this._items.push(item); 
    } 
    public pop() { 
        return this._items.shift(); 
    } 
    public size() { 
        return this._items.length; 
    } 
} </pre>
<div class="packt_infobox">Please note the array shift method removes the first element from an array and returns that removed element.</div>
<p>Once we have finished declaring the <kbd>UserQueue</kbd> class, we can create an instance and invoke the <kbd>push</kbd> and <kbd>pop</kbd> methods to add and remove items, respectively:</p>
<pre>const userQueue = new UserQueue(); 
userQueue.push({ name: "Remo", surname: "Jansen" }); 
userQueue.push({ name: "John", surname: "Smith" }); 
const remo = userQueue.pop(); 
const john = userQueue.pop(); </pre>
<p>If we also need to create a new queue with items of a different type, we could end up duplicating a lot of code that looks almost identical:</p>
<pre>class Car { 
    public manufacturer!: string; 
    public model!: string; 
} 
 
class CarQueue { 
    private _items: Car[] = []; 
    public push(item: Car) { 
        this._items.push(item); 
    } 
    public pop() { 
        return this._items.shift(); 
    } 
    public size() { 
        return this._items.length; 
    } 
} 
 
const carQueue = new CarQueue(); 
carQueue.push({ manufacturer: "BMW", model: "M3" }); 
carQueue.push({ manufacturer: "Tesla", model: "S" }); 
const bmw = carQueue.pop(); 
const tesla = carQueue.pop(); </pre>
<p>If the number of entities grows, we will continue to repeatedly duplicate code. We could use the <kbd>any</kbd> type to avoid this problem, but then we would be losing the type checks at compile time:</p>
<pre>class Queue { 
    private _items: any[] = []; 
    public push(item: any) { 
        this._items.push(item); 
    } 
    public pop() { 
        return this._items.shift(); 
    } 
    public size() { 
        return this._items.length; 
    } 
} </pre>
<p>A much better solution is to create a generic queue:</p>
<pre><a>class Queue&lt;T&gt; {</a> 
    private _items: T[] = []; 
    public push(item: T) { 
        this._items.push(item); 
    } 
    public pop() { 
        return this._items.shift(); 
    } 
    public size() { 
        return this._items.length; 
    } 
} </pre>
<p>The generic queue code is identical to <kbd>UserQueue</kbd> and <kbd>CarQueue</kbd>, except for the type of the <kbd>items</kbd> property. We have replaced the hardcoded reference to the <kbd>User</kbd> and <kbd>Car</kbd> entities and replaced them with the generic type <kbd>T</kbd>. We can now declare as many kinds of queues as we might need without duplicating a single line of code:</p>
<pre>class User { 
    public name!: string; 
    public surname!: string; 
} 
 
const userQueue = new Queue&lt;User&gt;(); 
userQueue.push({ name: "Remo", surname: "Jansen" }); 
userQueue.push({ name: "John", surname: "Smith" }); 
const remo = userQueue.pop(); 
const john = userQueue.pop(); 
 
class Car { 
    public manufacturer!: string; 
    public model!: string; 
} 
 
const carQueue = new Queue&lt;Car&gt;(); 
carQueue.push({ manufacturer: "BMW", model: "M3" }); 
carQueue.push({ manufacturer: "Tesla", model: "S" }); 
const bmw = carQueue.pop(); 
const tesla = carQueue.pop(); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic constraints</h1>
                </header>
            
            <article>
                
<p>Sometimes, we might need to restrict the use of a generic class. For example, we can add a new feature to the generic queue. The new feature is going to validate the entities before they are added to the queue.</p>
<p>One possible solution would be to use the <kbd>typeof</kbd> operator to identify the type of the generic type parameter <kbd>T</kbd> within a generic class or function:</p>
<pre>class User { 
    public name!: string; 
    public surname!: string; 
} 
 
class Car { 
    public manufacturer!: string; 
    public model!: string; 
} 
 
class Queue&lt;T&gt; { 
    private _items: T[] = []; 
    public push(item: T) { 
        if (item instanceof User) { 
            if ( 
                item.name === "" || 
                item.surname === "" 
            ) { 
                throw new Error("Invalid user"); 
            } 
        } 
        if (item instanceof Car) { 
            if ( 
                item.manufacturer === "" || 
                item.model === "" 
            ) { 
                throw new Error("Invalid car"); 
            } 
        } 
        this._items.push(item); 
    } 
    public pop() { 
        return this._items.shift(); 
    } 
    public size() { 
        return this._items.length; 
    } 
} 
 
const userQueue = new Queue&lt;User&gt;(); 
userQueue.push({ name: "", surname: "" }); // Runtime Error 
userQueue.push({ name: "Remo", surname: "" }); // Runtime Error 
userQueue.push({ name: "", surname: "Jansen" }); // Runtime Error 
 
const carQueue = new Queue&lt;Car&gt;(); 
carQueue.push({ manufacturer: "", model: "" }); // Runtime Error 
carQueue.push({ manufacturer: "BMW", model: "" }); // Runtime Error 
carQueue.push({ manufacturer: "", model: "M3" }); // Runtime Error </pre>
<p>The problem is that we will have to modify our <kbd>Queue</kbd> class to add extra logic with each new kind of entity. We will not add the validation rules into the <kbd>Queue</kbd> class because a generic class should not know the type used as the generic type.</p>
<p>A better solution is to add a method named <kbd>validate</kbd> to the entities. The method will throw and exception if the entity is invalid:</p>
<pre>class Queue&lt;T&gt; { 
    private _items: T[] = []; 
    public push(item: T) { 
<a>        item.validate(); </a>// Error 
        this._items.push(item); 
    } 
    public pop() { 
        return this._items.shift(); 
    } 
    public size() { 
        return this._items.length; 
    } 
} </pre>
<p>The preceding code snippet throws a compilation error because we can use the generic repository with any type, but not all types have a method named <kbd>validate</kbd>. Fortunately, this issue can easily be resolved by using a generic constraint. Constraints will restrict the types that we can use as the generic type parameter <kbd>T</kbd>. We are going to declare a constraint, so only the types that implement an interface named <kbd>Validatable</kbd> can be used with the generic method. Let's start by declaring the <kbd>Validatable</kbd> interface:</p>
<pre><a>interface Validatable {</a> 
    validate(): void; 
} </pre>
<p>Now, we can proceed to implement the interface. In this case, we must implement the <kbd>validate</kbd> method:</p>
<pre>class User implements Validatable { 
    public constructor( 
        public name: string, 
        public surname: string 
    ) {} 
    public validate() { 
        if ( 
            this.name === "" || 
            this.surname === "" 
        ) { 
            throw new Error("Invalid user"); 
        } 
    } 
} 
 
class Car implements Validatable { 
    public constructor( 
        public manufacturer: string, 
        public model: string 
    ) {} 
    public validate() { 
        if ( 
            this.manufacturer === "" || 
            this.model === "" 
        ) { 
            throw new Error("Invalid car"); 
        } 
    } 
} </pre>
<p>Now, let's declare a generic repository and add a type constraint so that only types that implement the <kbd>Validatable</kbd> interface are accepted:</p>
<pre>class Queue&lt;T extends Validatable&gt; { 
    private _items: T[] = []; 
    public push(item: T) { 
        item.validate(); 
        this._items.push(item); 
    } 
    public pop() { 
        return this._items.shift(); 
    } 
    public size() { 
        return this._items.length; 
    } 
} </pre>
<div class="packt_infobox">Even though we have used an interface, we used the <kbd>extends</kbd> keyword and not the <kbd>implements</kbd> keyword to declare the constraint in the preceding example. There is no special reason for that. This is just the way the TypeScript constraint's syntax works.</div>
<p>At this point, we should be ready to see the new validation feature in action:</p>
<pre>const userQueue = new Queue&lt;User&gt;(); 
userQueue.push(new User("", "")); // Error 
userQueue.push(new User("Remo", "")); // Error 
userQueue.push(new User("", "Jansen")); // Error 
 
const carQueue = new Queue&lt;Car&gt;(); 
carQueue.push(new Car("", "")); // Error 
carQueue.push(new Car("BMW", "")); // Error 
carQueue.push(new Car("", "M3")); // Error </pre>
<p>If we attempt to use a class that doesn't implement the <kbd>Validatable</kbd> as the generic parameter <kbd>T</kbd>, we will get a compilation error.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Multiple types in generic type constraints</h1>
                </header>
            
            <article>
                
<p>We can only refer to one type when declaring a generic type constraint. Let's imagine that we need a generic class to be constrained, so it only allows types that extend the following two interfaces:</p>
<pre>    interface Foo { 
        doSomething(): void; 
    } 
 
    interface Bar { 
        doSomethingElse(): void; 
    } </pre>
<p>We may think that we can define the required generic constraint as follows:</p>
<pre>class Example1&lt;T extends Foo, Bar&gt; { 
    private prop!: T; 
    public doEverything() { 
        this.prop.doSomething(); 
        this.prop.doSomethingElse(); // error 
    } 
} </pre>
<p>However, this code snippet will throw a compilation error. We cannot specify multiple types when declaring a generic type constraint. However, we can work around this issue by using <kbd>Foo</kbd> and <kbd>Bar</kbd> in a superinterface:</p>
<pre>interface FooBar extends Foo, Bar {} </pre>
<p><kbd>Foo</kbd> and <kbd>Bar</kbd> are now superinterfaces because they are the parent interfaces of the <kbd>FooBar</kbd> interface. We can then declare the constraint using the new <kbd>FooBar</kbd> interface:</p>
<pre>class Example2&lt;T extends FooBar&gt; { 
    private prop!: T; 
    public doEverything() { 
        this.prop.doSomething(); 
        this.prop.doSomethingElse(); 
    } 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The new operator in generic types</h1>
                </header>
            
            <article>
                
<p>To create a new object within a generic piece of code, we need to use the constructor function of the type. This means that instead of using <kbd>t: T</kbd> as follows:</p>
<pre>function factory&lt;T&gt;(t: T) { 
    return new t(); // Error 
} </pre>
<p>We should use <kbd>t: { new(): T;}</kbd>, as follows:</p>
<pre>function factory&lt;T&gt;(t: { new(): T }) { 
    return new t(); 
} 
 
class Foo { 
    public name!: "foo"; 
} 
 
class Bar { 
    public name!: "bar"; 
} 
 
const foo = factory&lt;Foo&gt;(Foo); 
const bar = factory&lt;Bar&gt;(Bar); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Association, aggregation, and composition</h1>
                </header>
            
            <article>
                
<p>In OOP, classes can have a relationship with each other. In this section, we are going to talk about three different types of relationships between classes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Association</h1>
                </header>
            
            <article>
                
<p>We call <strong>association</strong> those relationships whose objects have an independent life cycle where there is no ownership of the objects. Let's take a look at an example of a teacher and a student. Multiple students can be associated with a single teacher, and a single student can be associated with multiple teachers, but both have independent life cycles (both can create and delete independently). So, when a teacher leaves the school, we don't need to delete any students, and when a student leaves the school, we don't need to delete any teachers:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-77 image-border" src="Images/cecece17-72dc-449d-a149-21a299988965.png" style="width:38.08em;height:8.75em;" width="457" height="105"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Aggregation</h1>
                </header>
            
            <article>
                
<p>We call <strong>aggregation</strong> those relationships whose objects have an independent life cycle, but there is ownership, and child objects cannot belong to another parent object. Let's take an example of a cell phone and a cell phone battery. A single battery can belong to a phone, but if the phone stops working, and we delete it from our database, the phone battery will not be deleted because it may still be functional. So, in aggregation, while there is ownership, objects have their life cycle:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-78 image-border" src="Images/f95aba88-a80e-4594-acbb-81bbdd3e2f36.png" style="width:38.08em;height:8.83em;" width="457" height="106"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Composition</h1>
                </header>
            
            <article>
                
<p>We use the term <strong>composition</strong> to refer to relationships whose objects don't have an independent life cycle, and if the parent object is deleted, all child objects will also be deleted.</p>
<p>Let's take an example of the relationship between questions and answers. Single questions can have multiple answers, and answers cannot belong to multiple questions. If we delete questions, answers will automatically be deleted.</p>
<p>Objects with a dependent life cycle (answers in the example) are known as <strong>weak entities</strong>.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-79 image-border" src="Images/25cdb92f-3463-4193-8161-f24756777bec.png" style="width:38.58em;height:8.83em;" width="463" height="106"/></div>
<p>Sometimes, it can be a complicated process to decide if we should use association, aggregation, or composition. This difficulty is caused in part because aggregation and composition are subsets of association, which means they are specific cases of association:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-80 image-border" src="Images/851875e3-9a74-4a7e-a9de-fd009c0d5fb7.png" style="width:22.33em;height:21.75em;" width="404" height="393"/></div>
<p>It is also important to mention that, in general, we should try to <strong>use composition over inheritance</strong> whenever it is possible. Inheritance tightly couples derived classes to their respective base classes and it can become a maintainability issue over time. Composition can lead to much less tightly coupled code than inheritance.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Mixins (multiple inheritance)</h1>
                </header>
            
            <article>
                
<p>Sometimes, we will find scenarios in which it would be useful to be able to declare a class that inherits from two or more classes simultaneously (known as <strong>multiple inheritance</strong>).</p>
<p>We are going to create an example to demonstrate how multiple inheritance works. We are going to avoid adding any code to the methods in this example because we want to avoid the possibility of getting distracted by the details. We should focus on the inheritance tree.</p>
<p>We are going to start by declaring a class named <kbd>Animal</kbd> that has only one method, named <kbd>eat</kbd>:</p>
<pre>class Animal { 
  eat() { 
    // ... 
  } 
} </pre>
<p>After declaring the <kbd>Animal</kbd> class, we are going to declare two new classes named <kbd>WingedAnimal</kbd> and <kbd>Mammal</kbd>. Both classes are inherited from the <kbd>Animal</kbd> class:</p>
<pre>class Mammal extends Animal { 
    public breath() { 
        // ... 
    } 
} 
 
class WingedAnimal extends Animal { 
    public fly() { 
        // ... 
    } 
} </pre>
<p>Now that we have our classes ready, we are going to try to implement a class named <kbd>Bat</kbd>. Bats are mammals and have wings. This means that we need to create a new class named <kbd>Bat</kbd>, which will extend both the <kbd>Mammal</kbd> and <kbd>WingedAnimal</kbd> classes. We might think that this seems logical, however, if we attempt to do this, we will encounter a compilation error:</p>
<pre>// Error: Classes can only extend a single class. 
class Bat extends WingedAnimal, Mammal { 
    // ... 
} </pre>
<p>This error is thrown because TypeScript doesn't support multiple inheritance. This means that a class can only extend one class. Most OOP languages such as C# or TypeScript do not support multiple inheritance because it can potentially increase the complexity of applications and lead to a well-defined problem known as the diamond problem.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The diamond problem</h1>
                </header>
            
            <article>
                
<p>Sometimes, a class inheritance diagram can take a diamond-like shape (as seen in the following diagram). This kind of class inheritance diagram can potentially lead us to a design issue known as the <strong>diamond problem</strong>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-81 image-border" src="Images/6671b510-494d-465d-ac95-c9e6f72a073e.png" style="width:27.25em;height:25.92em;" width="536" height="510"/></div>
<p>If multiple inheritance was allowed and we encounter an inheritance tree with a diamond shape, we would not face any problems while using a method that is exclusive to only one of the classes in the inheritance tree:</p>
<pre>var bat = new Bat(); 
bat.fly(); // OK 
bat.eat();// OK 
bat.breath();// OK </pre>
<p>The problem takes place when we try to invoke one of the <kbd>Bat</kbd> class's parent methods, and it is unclear or ambiguous which of the parent's implementations of that method should be invoked. For example, if we could add a method named move to both the <kbd>Mammal</kbd> and the <kbd>WingedAnimal</kbd> classes and try to invoke it from an instance of <kbd>Bat</kbd>, we would get an ambiguous call error.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing mixins</h1>
                </header>
            
            <article>
                
<p>Now that we know why multiple inheritance can be potentially dangerous, we will introduce a feature known as <strong>mixins</strong>. Mixins are an alternative to multiple inheritance with some limitations.</p>
<p>We are going to re-declare the <kbd>Mammal</kbd> and <kbd>WingedAnimal</kbd> classes to showcase how to work with mixins:</p>
<pre>class Mammal { 
    public breath(): string { 
        return "I'm alive!"; 
    } 
} 
 
class WingedAnimal { 
    public fly(): string { 
        return "I can fly!"; 
    } 
} </pre>
<p>The two classes presented in the preceding example are not much different from the ones that we declared in the preceding sections. We have added some logic to the <kbd>breath</kbd> and <kbd>fly</kbd> methods, so we can have some values to help us understand this demonstration. It is also important to note that the <kbd>Mammal</kbd> and <kbd>WingedAnimal</kbd> classes no longer extend the <kbd>Animal</kbd> class.</p>
<p>The <kbd>Bat</kbd> class needs some important additions. We are going to use the <kbd>reserved</kbd> keyword <kbd>implements</kbd> to indicate that <kbd>Bat</kbd> will implement the functionality declared in the <kbd>Mammal</kbd> and <kbd>WingedAnimal</kbd> classes. We are also going to add the signature of each of the methods that the <kbd>Bat</kbd> class will implement:</p>
<pre>class Bat implements Mammal, WingedAnimal { 
    public eat!: () =&gt; string; 
    public breath!: () =&gt; string; 
    public fly!: () =&gt; string; 
} </pre>
<p>We need to copy the following function somewhere in our code to be able to apply mixins:</p>
<pre>function applyMixins(derived: any, bases: any[]) { 
    bases.forEach(base =&gt; { 
        const props = Object.getOwnPropertyNames(base.prototype); 
        props.forEach(name =&gt; { 
            if (name !== "constructor") { 
                derived.prototype[name] = base.prototype[name]; 
            } 
        }); 
    }); 
} </pre>
<div class="packt_infobox">The preceding function is a well-known pattern and can be found in many books and online references, including the official <em>TypeScript Handbook</em>. Don't worry if you don't fully understand it at this point because it uses some concepts (such as <span class="fontstyle0">An iterator is a behavioral design pattern which</span><br/>
porotypes) that will not be covered until <a href="5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml">Chapter 6</a>, <em>Understanding the Runtime</em>.</div>
<p>This function iterates each property of the parent classes (contained in an array named <kbd>bases</kbd>) and copies the implementation to a child class (<kbd>derived</kbd>). We only need to declare this function once in our entire application. Once we have done it, we can use it as follows:</p>
<pre>applyMixins(Bat, [Mammal, WingedAnimal]); </pre>
<p>The child class (<kbd>Bat</kbd>) will then contain each of the properties and methods of the two parent classes (<kbd>WingedAnimal</kbd> and <kbd>Mammal</kbd>):</p>
<pre>const bat = new Bat(); 
bat.breath(); // "I'm alive!" 
bat.fly(); // "I can fly!" </pre>
<p>As we said at the beginning of this section, mixins have some limitations:</p>
<ul>
<li>The first limitation is that we can only inherit the properties and methods from one level in the inheritance tree. This explains why we removed the <kbd>Animal</kbd> class before applying the mixins.</li>
<li>The second limitation is that if two or more of the parent classes contain a method with the same name, the method that is going to be inherited will be taken from the last class passed in the <kbd>bases</kbd> array to the <kbd>applyMixins</kbd> function.</li>
</ul>
<p>We will now see an example that presents both of these limitations.</p>
<p>To show the first limitation, we will re-declare the <kbd>Animal</kbd> class:</p>
<pre>class Animal { 
  public eat(): string { 
    return "I need food!"; 
  } 
} </pre>
<p>We will then declare the <kbd>Mammal</kbd> and <kbd>WingedAnimal</kbd> classes, but this time, they will extend the <kbd>Animal</kbd> class:</p>
<pre>class Mammal extends Animal { 
    public breath() { 
        return "I'm alive!"; 
    } 
    public move() { 
        return "I can move like a mammal!"; 
    } 
} 
 
class WingedAnimal extends Animal { 
    public fly() { 
        return "I can fly!"; 
    } 
    public move() { 
        return "I can move like a bird!"; 
    } 
} </pre>
<p>We will then declare again the <kbd>Bat</kbd> class. This class will implement both the <kbd>Mammal</kbd> and <kbd>WindgedAnimal</kbd> classes:</p>
<pre>class Bat implements Mammal, WingedAnimal { 
    public eat!: () =&gt; string; 
    public breath!: () =&gt; string; 
    public fly!: () =&gt; string; 
    public move!: () =&gt; string; 
} </pre>
<p>We are ready to invoke the <kbd>applyMixins</kbd> function. Notice how we pass <kbd>Mammal</kbd> before <kbd>WingedAnimal</kbd> in the array:</p>
<pre>applyMixins(Bat, [Mammal, WingedAnimal]);  </pre>
<p>We can now create an instance of <kbd>Bat</kbd>, and we will be able to observe that the <kbd>eat</kbd> method has not been inherited from the <kbd>Animal</kbd> class due to the first limitation:</p>
<pre>const bat = new Bat(); 
bat.eat(); // Error: bat.eat is not a function </pre>
<p>Each of the parent class's methods has been inherited without issues:</p>
<pre>bat.breath(); // I'm alive! 
bat.fly();     // I can fly!" </pre>
<p>The <kbd>move</kbd> method has issues because according to the second limitation, only the implementation of the last parent class passed to the <kbd>applyMixins</kbd> method will be implemented. In this case, the implementation is inherited from the <kbd>WingedAnimal</kbd> class:</p>
<pre>bat.move(); // I can move like a bird </pre>
<p>To finalize, we will see the effect of switching the order of the parent classes when invoking the <kbd>applyMixins</kbd> method. Notice how we have passed <kbd>WingedAnimal</kbd> before <kbd>Mammal</kbd> in the array:</p>
<pre>applyMixins(Bat2, [WingedAnimal, Mammal]);  
const bat = new Bat2(); 
bat.eat();     // Error: not a function 
bat.breathe(); // I'm alive! 
bat.fly();     // I can fly! 
bat.move()     // I can move like a mammal </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Iterables</h1>
                </header>
            
            <article>
                
<p>An iterator is a behavioral design pattern that is common in OOP. An iterator is an object that implements an interface such as the following one:</p>
<pre>interface Iterator&lt;T&gt; { 
    next(value?: any): IteratorResult&lt;T&gt;; 
    return?(value?: any): IteratorResult&lt;T&gt;; 
    throw?(e?: any): IteratorResult&lt;T&gt;; 
} </pre>
<p>The preceding interface allows us to retrieve the items available in a collection. The iterator result allows us to know if we have reached the last item in the collection and to access the values in the collection:</p>
<pre>interface IteratorResult&lt;T&gt; { 
    done: boolean; 
    value: T; 
} </pre>
<p>We can create custom iterators by implementing the <kbd>IterableIterator</kbd> interface. We will need to implement the next method and a method named <kbd>Symbol.iterator</kbd>:</p>
<pre>class Fib implements IterableIterator&lt;number&gt; { 
 
  protected fn1 = 0; 
  protected fn2 = 1; 
 
  public constructor(protected maxValue?: number) {} 
 
  public next(): IteratorResult&lt;number&gt; { 
    let current = this.fn1; 
    this.fn1 = this.fn2; 
    this.fn2 = current + this.fn1; 
    if (this.maxValue &amp;&amp; current &lt;= this.maxValue) { 
      return { 
        done: false, 
        value: current 
      }; 
    } else { 
      return { 
        done: true, 
        value: 0 
      }; 
    } 
  } 
 
  public [Symbol.iterator](): IterableIterator&lt;number&gt; { 
    return this; 
  } 
 
} </pre>
<p>We can use brackets to define the name of a property or method using the value of a variable as the name of the method or property. In this case, the <kbd>Symbol.iterator</kbd> is used as the name of the method. The <kbd>Symbol</kbd> iterator contains the unique string <kbd>@@iterator</kbd>. This name is a special name for a method because whenever an object needs to be iterated (such as at the beginning of a <kbd>for...of</kbd> loop), its <kbd>@@iterator</kbd> method is called with no arguments, and the returned iterator is used to obtain the values to be iterated.</p>
<p>After declaring the class, we can create instances and iterate their values:</p>
<pre><a>let fib = new Fib(5);</a> 
 
fib.next(); // { done: false, value: 0 } 
fib.next(); // { done: false, value: 1 } 
fib.next(); // { done: false, value: 1 } 
fib.next(); // { done: false, value: 2 } 
fib.next(); // { done: false, value: 3 } 
fib.next(); // { done: false, value: 5 } </pre>
<p>The preceding iterable never stops returning values, but we can also declare an instance with a fixed number of items and iterate the items using a <kbd>for...of</kbd> loop:</p>
<pre><a>let fibMax21 = new Fib(21);</a> 
 
for (let num of fibMax21) { 
  console.log(num); // Prints fibonacci sequence 0 to 21 
} </pre>
<div class="packt_infobox">Note that some additional types are required by asynchronous iterators if we are targeting ES5 or ES3. You will need to add <kbd>esnext.asynciterable</kbd> to your <kbd>tsconfig.json</kbd> file. We are also going to need to enable an additional setting in our <kbd>tsconfig.json</kbd> to provide full support for iterables (for example, using <kbd>for...of</kbd> control flow statements, the spread operator or object destructuring) when targeting ES3 or ES5:<br/>
<kbd>"lib": [</kbd><br/>
<kbd>              "es2015.promise",</kbd><br/>
<kbd>              "dom",</kbd><br/>
<kbd>              "es5",</kbd><br/>
<kbd>              "es5",</kbd><br/>
<kbd>              "es2015.generator",</kbd><br/>
<kbd>              "es2015.iterable",</kbd><br/>
<kbd>              "esnext.asynciterable" // new</kbd><br/>
<kbd>]</kbd><br/>
<span>You might also need a recent version of Node.js as</span> the preceding example <span>will not work in old versions of Node.js. </span><span>We will learn more about the</span> <kbd>lib</kbd> <span>setting in <a href="ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml">Chapter 9</a>,</span> <em>Automating Your Development Workflow</em><span>.</span><span><br/></span></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Abstract classes</h1>
                </header>
            
            <article>
                
<p>Abstract classes are base classes that can be extended by other classes. The <kbd>abstract</kbd> keyword is used to define abstract classes as well as abstract methods within an abstract class:</p>
<pre>abstract class Department { 
 
    constructor(public name: string) { 
    } 
 
    public printName(): void { 
        console.log("Department name: " + this.name); 
    } 
 
    public abstract printMeeting(): void; // must be implemented in derived classes 
} </pre>
<p>The methods in an abstract class that are preceded by the <kbd>abstract</kbd> keyword cannot contain an implementation and must be implemented by the derived classes.</p>
<p>Abstract methods may look like interface methods. However, an abstract class may contain implementation details for some of its members:</p>
<pre>class AccountingDepartment extends Department { 
 
    public constructor() { 
        super("Accounting and Auditing"); // constructors in derived classes must call super() 
    } 
 
    public printMeeting(): void { 
        console.log("The Accounting Department meets each Monday at 10 am."); 
    } 
 
    public generateReports(): void { 
        console.log("Generating accounting reports..."); 
    } 
} </pre>
<p>It is not possible to create an instance of an abstract class:</p>
<pre>// OK: Create a reference to an abstract type 
let department: Department;  
 
// Error: cannot create an instance of an abstract class 
department = new Department();  
 
// OK: Create and assign a non-abstract subclass 
department = new AccountingDepartment();  
department.printName(); 
department.printMeeting(); 
 
// Error: Method doesn't exist on declared abstract type 
department.generateReports(); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Interfaces</h1>
                </header>
            
            <article>
                
<p>Interfaces are probably the feature that you will miss the most while developing large-scale web applications with JavaScript if you have a background in object-oriented statically-typed programming languages such as Java or C#.</p>
<p>Traditionally, in OOP, we say that a class can extend only one class and implement one or more interfaces. An interface can implement one or more interfaces and cannot extend another class or interface. Wikipedia's definition of interfaces in OOP is as follows:</p>
<div class="packt_quote">"In object-oriented languages, the term interface is often used to define an abstract type that contains no data or code, but defines behaviors as method signatures."</div>
<p>In TypeScript, interfaces don't strictly follow this definition. The two main differences are that in TypeScript:</p>
<ul>
<li>An interface can extend a class</li>
<li>An interface can define data and behaviors as opposed to only behaviors</li>
</ul>
<p>For example, we can define an interface named <kbd>Weapon</kbd>:</p>
<pre>interface Weapon { 
    tryHit(fromDistance: number): boolean; 
} </pre>
<p>The <kbd>Weapon</kbd> interface defines the behavior shared by all weapons (a weapon can be used to try to hit an enemy, but each kind of weapon has a different range). However, the interface does not define the details of each if its implementations (the specific range of each kind of weapon).</p>
<p>Implementing an interface can be understood as signing a contract. An interface is a contract, and when we sign it (implement it), we must follow its rules. The interface rules are the signatures of the methods and properties, and we must implement them:</p>
<pre>class Katana implements Weapon { 
    public tryHit(fromDistance: number) { 
        return fromDistance &lt;= 2; 
    } 
} 
 
class Shuriken implements Weapon { 
    public tryHit(fromDistance: number) { 
        return fromDistance &lt;= 15; 
    } 
} </pre>
<p>The two preceding classes implement the methods defined by the <kbd>Weapon</kbd> interface. Both classes share the same public API but have different internal implementations. We will see many more examples of interfaces through the rest of this chapter.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SOLID principles, encapsulation, and polymorphism</h1>
                </header>
            
            <article>
                
<p>In the early days of software development, developers used to write code with procedural programming languages. In procedural programming languages, the programs follow a top-to-bottom approach, and the logic is wrapped with functions.</p>
<p>New styles of computer programming, such as modular programming or structured programming, emerged when developers realized that procedural computer programs could not provide them with the desired level of abstraction, maintainability, and reusability.</p>
<p>The development community created a series of recommended practices and design patterns to improve the level of abstraction and reusability of procedural programming languages, but some of these guidelines required a certain level of expertise. To facilitate adherence to these guidelines, a new style of computer programming known as <strong>object-oriented programming</strong> (<strong>OOP</strong>) was created.</p>
<p>Developers quickly noticed some common OOP mistakes and came up with five rules that every OOP developer should follow to create a system that is easy to maintain and extend over time. These five rules are known as the SOLID principles. SOLID is an acronym introduced by Michael Feathers. Each of the characters in the acronym represents one of the following principles:</p>
<ul>
<li><strong>Single responsibility principle</strong> (<strong>SRP</strong>): This principle states that a software component (function, class, or module) should focus on one unique task (have only one responsibility).</li>
<li><strong>Open/closed principle</strong> (<strong>OCP</strong>): This principle states that software entities should be designed with application growth (new code) in mind (be open to extension), but that application growth should require as few changes to the existing code as possible (be closed for modification).</li>
<li><strong>Liskov substitution principle</strong> (<strong>LSP</strong>): This principle states that we should be able to replace a class in a program with another class if both classes implement the same interface. After replacing the class, no other changes should be required, and the program should continue to work as it did originally.</li>
<li><strong>Interface segregation principle</strong> (<strong>ISP</strong>): This principle states that we should split interfaces that are very large (general-purpose interfaces) into smaller and more specific ones (many client-specific interfaces) so that clients will only need to know about the methods that are of interest to them.</li>
<li><strong>Dependency inversion principle</strong> (<strong>DIP</strong>): This principle states that entities should depend on abstractions (interfaces) as opposed to depending on concretion (classes).</li>
</ul>
<p>In this chapter, we are going to learn how to write TypeScript code that adheres to these principles so that our applications are easy to maintain and extend over time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SOLID – the single responsibility principle</h1>
                </header>
            
            <article>
                
<p>All our classes should adhere to the <strong>single responsibility principle</strong> (<strong>SRP</strong>). The <kbd>Person</kbd> class declared during the very first example in this chapter represents a person, including all of their characteristics (attributes) and behaviors (methods). We are going to modify the preceding class by adding an <kbd>email</kbd> as validation logic:</p>
<pre>class Person { 
    public name: string; 
    public surname: string; 
    public email: string; 
    public constructor( 
        name: string, surname: string, email: string 
    ) { 
        this.surname = surname; 
        this.name = name; 
        if (this.validateEmail(email)) { 
            this.email = email; 
        } else { 
            throw new Error("Invalid email!"); 
        } 
    } 
    public validateEmail(email: string) { 
        const re = /S+@S+.S+/; 
        return re.test(email); 
    } 
    public greet() { 
        console.log( 
            `Hi! I'm ${this.name}, 
            you can reach me at ${this.email}` 
        ); 
    } 
} </pre>
<p>When an object doesn't follow the SRP and it knows too much (has too many properties) or does too much (has too many methods), we say that the object is a <kbd>God</kbd> object. The <kbd>Person</kbd> class here is a <kbd>God</kbd> object because we have added a method named <kbd>validateEmail</kbd> that is not related to the <kbd>Person</kbd> class's behavior.</p>
<p>Deciding which attributes and methods should or should not be part of a class is a relatively subjective decision. If we spend some time analyzing our options, we should be able to identify ways to improve the design of our classes.</p>
<p>We can refactor the <kbd>Person</kbd> class by declaring an <kbd>Email</kbd> class, which is responsible for email validation, and use it as an attribute in the <kbd>Person</kbd> class:</p>
<pre>class Email { 
    public static validateEmail(email: string) { 
        const re = /S+@S+.S+/; 
        return re.test(email); 
    } 
} </pre>
<p>Now that we have an <kbd>Email</kbd> class, we can remove the responsibility of validating the emails from the <kbd>Person</kbd> class and update its <kbd>email</kbd> attribute to use the  <kbd>Email</kbd> <span>type </span>instead of <kbd>string</kbd>:</p>
<pre>class Person { 
    public name: string; 
    public surname: string; 
    public email: string; 
    public constructor( 
        name: string, surname: string, email: string 
    ) { 
        if (Email.validateEmail(email) === false) { 
            throw new Error("Invalid email!"); 
        } 
        this.email = email; 
        this.name = name; 
        this.surname = surname; 
    } 
    public greet() { 
        console.log( 
            `Hi! I'm ${this.name}, 
            you can reach me at ${this.email.toString()}` 
        ); 
    } 
} </pre>
<p>Making sure that a class has a single responsibility makes it easier to see what it does and how we can extend/improve it.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Encapsulation</h1>
                </header>
            
            <article>
                
<p>We can further improve our <kbd>Person</kbd> and <kbd>Email</kbd> classes declared in the previous section by increasing the level of abstraction of our classes. For example, when we use the <kbd>Email</kbd> class, we don't need to be aware of the existence of the <kbd>validateEmail</kbd> method; this method could be invisible from outside the <kbd>Email</kbd> class. As a result, the <kbd>Email</kbd> class would be much simpler to understand.</p>
<p>When we increase the level of abstraction of an object, we can say that we are encapsulating some logic. Encapsulation is also known as <strong>information hiding</strong>. For example, the <kbd>Email</kbd> class allows us to use emails without having to worry about email validation because the class will deal with it for us. We can make this clearer by using access modifiers (<kbd>public</kbd> or <kbd>private</kbd>) to flag all the class attributes and methods that we want to abstract from the use of the <kbd>Email</kbd> class as <kbd>private</kbd>:</p>
<pre>class Email { 
    private _email: string; 
    public constructor(email: string) { 
        if (this._validateEmail(email)) { 
            this._email = email; 
        } else { 
            throw new Error("Invalid email!"); 
        } 
    } 
    public toString(): string { 
        return this._email; 
    } 
    private _validateEmail(email: string) { 
        const re = /S+@S+.S+/; 
        return re.test(email); 
    } 
} 
 
class Person { 
    public name: string; 
    public surname: string; 
    public email: Email; 
    public constructor( 
        name: string, surname: string, email: Email 
    ) { 
        this.email = email; 
        this.name = name; 
        this.surname = surname; 
    } 
    public greet() { 
        console.log( 
            `Hi! I'm ${this.name}, 
            you can reach me at ${this.email.toString()}` 
        ); 
    } 
} </pre>
<p>We can then simply use the <kbd>Email</kbd> class without needing to explicitly perform any kind of validation:</p>
<pre>let person: Person = new Person( 
    "Remo", 
    "Jansen", 
    new Email("remo.jansen@wolksoftware.com") 
); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SOLID – the open/closed principle</h1>
                </header>
            
            <article>
                
<p>The <strong>open/closed principle</strong> (<strong>OCP</strong>)  recommends that we design our classes and methods in a way that enables us to extend their behavior (open for extension) in the future without modifying their current behavior (closed for modification).</p>
<p>The following code snippet is not great because it does not adhere to the open/closed principle:</p>
<pre>class Rectangle { 
    public width!: number; 
    public height!: number; 
} 
 
class AreaCalculator { 
    public area(shapes: Rectangle[] ) { 
        return shapes.reduce( 
            (p, c) =&gt; { 
                return p + (c.height * c.width); 
            }, 
            0 
        ); 
    } 
} </pre>
<p>The preceding code does not adhere to the open/closed principle because if we need to extend our program to also support circles, we will need to modify the existing <kbd>AreaCalculator</kbd> class:</p>
<pre>class Circle { 
    public radius!: number; 
} 
 
class AreaCalculator { 
    public area(shapes: Array&lt;Rectangle|Circle&gt;) { 
        return shapes.reduce( 
            (p, c) =&gt; { 
                if (c instanceof Rectangle) { 
                    return p + (c.width * c.height); 
                } else { 
                    return p + (c.radius * c.radius * Math.PI); 
                } 
            }, 
            0 
        ); 
    } 
} </pre>
<p>A better solution is to add the area calculation as a method of the shapes so that when we add a new shape (extension), we don't need to change the existing <kbd>AreaCalculator</kbd> class (modification):</p>
<pre>abstract class Shape { 
    public abstract area(): number; 
} 
 
class Rectangle extends Shape { 
    public width!: number; 
    public height!: number; 
    public area() { 
        return this.width * this.height; 
    } 
} 
 
class Circle implements Shape { 
    public radius!: number; 
    public area() { 
        return (this.radius * this.radius * Math.PI); 
    } 
} 
 
class AreaCalculator { 
    public area(shapes: Shape[]) { 
        return shapes.reduce( 
            (p, c) =&gt; p + c.area(), 
            0 
        ); 
    } 
} </pre>
<p>The second approach follows the second SOLID principle, the open/closed principle, as we can create new entities, and the generic repository will continue to work (open for extension), but no additional changes to it will be required (closed for modification).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Polymorphism</h1>
                </header>
            
            <article>
                
<p>Polymorphism is the ability to present the same interface for differing underlying forms (data types). Polymorphism is often referred to as the third pillar of object-oriented programming, after encapsulation and inheritance.</p>
<p>Polymorphism is what enabled us to implement the LSP in the preceding section:</p>
<pre>class AreaCalculator { 
    public area(shapes: Shape[]) { 
        return shapes.reduce( 
            (p, c) =&gt; p + c.area(), 
            0 
        ); 
    } 
} </pre>
<p>Objects of the derived class (<kbd>Circle</kbd> and <kbd>Rectangle</kbd>) may be treated as objects of a base class (<kbd>Shape</kbd>) in places such as method parameters (such  as the <kbd>area</kbd> method). Base classes may define and implement abstract methods, and derived classes can override them, which means they provide their definition and <span class="NormalPACKTChar">implementation.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SOLID – the Liskov substitution principle </h1>
                </header>
            
            <article>
                
<p>The <strong>Liskov substitution principle</strong> (<strong>LSP</strong>) states, <em>Subtypes must be substitutable for their base types</em>. Let's look at an example to understand what this means.</p>
<p>We will declare a class named <kbd>PersistanceService</kbd>, the responsibility of which is to persist some object into some sort of storage. We will start by declaring the following interface:</p>
<pre>interface PersistanceServiceInterface { 
    save(value: string): string; 
} </pre>
<p>After declaring the <kbd>PersistanceServiceInterface</kbd> interface, we can implement it. We will use cookies as the storage for the application's data:</p>
<pre>function getUniqueId() { 
    return Math.random().toString(36).substr(2, 9); 
} 
 
class CookiePersitanceService implements PersistanceServiceInterface { 
    public save(value: string): string { 
        let id = getUniqueId(); 
        document.cookie = `${id}=${value}`; 
        return id; 
    } 
} </pre>
<p>We will continue by declaring a class named <kbd>FavouritesController</kbd>, which has a dependency on <kbd>PersistanceServiceInterface</kbd>:</p>
<pre>class FavouritesController { 
    private _persistanceService: PersistanceServiceInterface; 
    public constructor(persistanceService: PersistanceServiceInterface) { 
        this._persistanceService = persistanceService; 
    } 
    public saveAsFavourite(articleId: string) { 
        return this._persistanceService.save(articleId); 
    } 
} </pre>
<p>We can finally create an instance of <kbd>FavouritesController</kbd> and pass an instance of <kbd>CookiePersitanceService</kbd> via its constructor:</p>
<pre>const favController1 = new FavouritesController( 
    new CookiePersitanceService() 
); </pre>
<p>The LSP allows us to replace a dependency with another implementation if both implementations are based in the same base type; so, if we decide to stop using cookies as storage and use the HTML5 local storage API instead, we can declare a new implementation:</p>
<pre>class LocalStoragePersitanceService implements PersistanceServiceInterface { 
    public save(value: string): string { 
        const id = getUniqueId(); 
        localStorage.setItem(`${id}`, value); 
        return id; 
    } 
} </pre>
<p>We can then replace it without having to add any changes to the <kbd>FavouritesController</kbd> controller class:</p>
<pre>const favController = new FavouritesController( 
    new LocalStoragePersitanceService() 
); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SOLID – the interface segregation principle</h1>
                </header>
            
            <article>
                
<p>Interfaces are used to declare how two or more software components cooperate and exchange information with each other. This declaration is known as an <strong>application programming interface</strong> (<strong>API</strong>). In the previous example, our interface was <kbd>PersistanceServiceInterface</kbd>, and it was implemented by the classes <kbd>LocalStoragePersitanceService</kbd> and <kbd>CookiePersitanceService</kbd>. The interface was consumed by the <kbd>FavouritesController</kbd> class, so we say that this class is a client of the <kbd>PersistanceServiceInterface</kbd> API.</p>
<p>The <strong>interface segregation principle</strong> (<strong>ISP</strong>) states that no client should be forced to depend on methods it does not use. To adhere to the ISP, we need to keep in mind that when we declare the API (how two or more software components cooperate and exchange information with each other) of our application's components, the declaration of many client-specific interfaces is better than the declaration of one general-purpose interface. Let's look at an example.</p>
<p>If we design an API to control all the elements in a vehicle (engine, radio, heating, navigation, and lights), we could have one general-purpose interface, that allows us to control every single element of the vehicle:</p>
<pre>interface VehicleInterface { 
    getSpeed(): number; 
    getVehicleType(): string; 
    isTaxPayed(): boolean; 
    isLightsOn(): boolean; 
    isLightsOff(): boolean; 
    startEngine(): void; 
    accelerate(): number; 
    stopEngine(): void; 
    startRadio(): void; 
    playCd(): void; 
    stopRadio(): void; 
} </pre>
<p>If a class has a dependency (client) in the <kbd>VehicleInterface</kbd> interface but it only wants to use the radio methods, we would be facing a violation of the ISP because, as we have already seen, a client shouldn't  be forced to depend on methods it does not use.</p>
<p>The solution is to split the <kbd>VehicleInterface</kbd> interface into many client-specific interfaces so that our class can adhere to the ISP by depending only on the <kbd>RadioInterface</kbd> interface:</p>
<pre>interface VehicleInterface { 
    getSpeed(): number; 
    getVehicleType(): string; 
    isTaxPayed(): boolean; 
    isLightsOn(): boolean; 
} 
 
interface LightsInterface { 
    isLightsOn(): boolean; 
    isLightsOff(): boolean; 
} 
 
interface RadioInterface { 
    startRadio(): void; 
    playCd(): void; 
    stopRadio(): void; 
} 
 
interface EngineInterface { 
    startEngine(): void; 
    accelerate(): number; 
    stopEngine(): void; 
} </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SOLID – the dependency inversion principle</h1>
                </header>
            
            <article>
                
<p>The <strong>dependency inversion</strong> (<strong>DI</strong>) principle states, <em>Depend upon abstractions. Do not depend upon concretions</em>. In the LSP, we implemented a class named <kbd>FavouritesController</kbd>. In the example, it was possible to replace an implementation of <kbd>PersistanceServiceInterface</kbd> with another without having to perform any additional change to <kbd>FavouritesController</kbd>.</p>
<p>We followed the DI principle, as <kbd>FavouritesController</kbd> has a dependency upon <kbd>PersistanceServiceInterface</kbd> (abstraction):</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-82 image-border" src="Images/438ea4e3-82fe-4d79-a90f-cfae68e79262.png" style="width:85.50em;height:8.92em;" width="1026" height="107"/></div>
<p>The preceding can be implemented as follows:</p>
<pre>class FavouritesController { 
    private _persistanceService: PersistanceServiceInterface; 
    public constructor(persistanceService: PersistanceServiceInterface) { 
        this._persistanceService = persistanceService; 
    } 
    public saveAsFavourite(articleId: string) { 
        return this._persistanceService.save(articleId); 
    } 
} </pre>
<p>Rather than <kbd>FavouritesController</kbd> having a dependency on <kbd>LocalStoragePersitanceService</kbd> or <kbd>CookiePersitanceService</kbd> (concretions) directly:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-83 image-border" src="Images/3538b3eb-29c5-409e-96c4-1ccd68bde2a0.png" style="width:86.08em;height:9.50em;" width="1033" height="114"/></div>
<p>The preceding can be implemented as follows:</p>
<pre>class FavouritesController { 
    private _persistanceService: CookiePersitanceService; 
    public constructor(persistanceService: CookiePersitanceService) { 
        this._persistanceService = persistanceService; 
    } 
    public saveAsFavourite(articleId: string) { 
        return this._persistanceService.save(articleId); 
    } 
} </pre>
<p>If we compare the two diagrams, we will notice that the direction arrow that links the dependent and the dependency has been inverted thanks to the introduction of the interface (abstraction). This should help us to understand why this principle is known as the dependency inversion principle.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned how to work with classes and interfaces in depth. We were able to make our application more maintainable by using techniques such as encapsulation and dependency inversion. In the next chapter, we will learn how to work with dependencies.</p>


            </article>

            
        </section>
    </div>



  </body></html>