<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. The JavaScript Execution Model</h1></div></div></div><p>The first chapter of this book explored the state of JavaScript concurrency. Generally speaking, dealing with concurrency in JavaScript applications is anything but a trivial matter. There's a lot to think about when writing concurrent JavaScript code, and the kind of solutions that we come up with are often unorthodox. There's a lot of callbacks, and wading through all of them is enough to drive a person insane. We also caught a glimpse of how our pattern of writing concurrent JavaScript code has started to change with existing concurrency components. Web workers have started to mature, and JavaScript language concurrency constructs have only just been introduced.</p><p>The language and the runtime environment only get us partway there. We need to think about concurrency at the design level, rather than after the fact. Concurrency should be the default. This is easy to say and very difficult to do. Throughout this book, we're going to explore all that the JavaScript concurrency features have to offer, and how we can best use them to our advantage as design tools. But, before we do this, we need to go into depth on what's really happening when our JavaScript runs. This knowledge is an essential input to designing concurrent applications, because we'll know exactly what to expect when choosing one concurrency mechanism over another.</p><p>In this chapter, we'll start with the browser environment, by looking at all the subsystems that our code touches—such as the JavaScript interpreter, the task queue, and the DOM itself. Then we'll walk through some code that will shed some light on what's really happening behind the scenes to orchestrate our code. We'll close the chapter with a discussion on the challenges that we face with this model.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Everything is a task</h1></div></div></div><p>When we visit a web page, a whole environment is created for us within the browser. This environment has several subsystems that enable the webpage we're looking at to look and behave as it should according to<a id="id49" class="indexterm"/> <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>) specs. Tasks are the fundamental abstraction inside a web browser. Anything that happens is either a task itself, or a smaller part of a larger task.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>If you're reading any of the W3C specifications, the term "user agent" is used instead of  "web browser". In 99.9% of  cases, the major browser vendors are what we're reading about.</p></div></div><p>In this section, we'll look at the major components of these environments, and how task queues and event loops facilitate the communication between these components, to realize the overall appearance and behavior of the web page.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Meet the players</h2></div></div></div><p>Let's introduce some terminology that will help us throughout the various sections in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Execution environment</strong>: This <a id="id50" class="indexterm"/>container gets created whenever a new web page is opened. It's the all-encompassing environment, which has everything that our JavaScript code will interact with. It also serves as a sandbox—our JavaScript code can't reach outside of this environment.</li><li class="listitem" style="list-style-type: disc"><strong>JavaScript interpreter</strong>: This is the<a id="id51" class="indexterm"/> component that's responsible for parsing and executing our JavaScript source code. It's the browser's job to augment the interpreter with globals, such as <code class="literal">window</code>, and <code class="literal">XMLHttpRequest</code>.</li><li class="listitem" style="list-style-type: disc"><strong>Task queue</strong>: Tasks are<a id="id52" class="indexterm"/> queued whenever something needs to happen. An execution environment has at least one of these queues, but typically, it has several of them.</li><li class="listitem" style="list-style-type: disc"><strong>Event loop</strong>: An <a id="id53" class="indexterm"/>execution environment has a single event loop that's responsible for servicing all task queues. There's only one event loop, because there's only one thread.</li></ul></div><p>Take a look at the following visualization of an execution environment created within a web browser. The task queues are the entry points for anything that happens in the browser. For example, one task can be used to execute a script by passing it to the JavaScript interpreter, while another task is used to render pending DOM changes. Now we'll dig into the parts that make up the environment.</p><div><img src="img/B05133_02_01.jpg" alt="Meet the players"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>The Execution environment</h2></div></div></div><p>Perhaps the most revealing aspect of the web browser<a id="id54" class="indexterm"/> execution environment is the relatively minor role played by our JavaScript code and the interpreter that executes it. Our code is simply a cog in a much larger machine. There's certainly a lot going on within these environments, because the platform that browsers implement serve an enormous purpose. It's not simply a matter of rendering elements on the screen, then enhancing these elements with style properties. The DOM itself is similar to a micro platform, just as networking facilities, file access, security, and so on. All these pieces are essential for a functioning web economy of sites, and more recently, applications.</p><p>In a concurrency context, we're mostly interested in the mechanics that tie all these platform pieces together. Our application is written mainly in JavaScript, and the interpreter knows how to parse and run it. But, how does this ultimately translate into visual changes on the page? How does the networking component of the browser know to make an HTTP request, and how does it invoke the JavaScript interpreter once the response has arrived?</p><p>It's the coordination of <a id="id55" class="indexterm"/>these moving parts that restricts our concurrency options in JavaScript. These restrictions are necessary, because without them, programming web applications would become too complex.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Event loops</h2></div></div></div><p>Once an execution<a id="id56" class="indexterm"/> environment is in place, the event loop is one of the first components to start. Its job is to service one or more task queues in the environment. Browser vendors are free to implement queues as they see fit, but there has to be at least one queue. Browsers can place every task in one queue if they please, and treat every task with equal priority. The problem with doing so would mean that if the queue is getting backlogged, tasks that must receive priority, such as mouse or keyboard events, are stuck in line.</p><p>In practice, it makes sense to have a handful of queues, if for no other reason than to separate tasks by priority. This is all the more important because there's only one thread of control—meaning only one CPU—that will process these queues. Here's what an event loop that services several queues by varying levels of priorities looks like:</p><div><img src="img/B05133_02_02.jpg" alt="Event loops"/></div><p>Even though the <a id="id57" class="indexterm"/>event loop is started along with the execution environment, this doesn't mean that there's always tasks for it to consume. If there were always tasks to process, there would never be any CPU time for the actual application. The event loop will sit and wait for more tasks, and the queue with the highest priority gets serviced first. For example, with the queues used in the preceding image, the <em>interactive </em>queue will always be serviced first. Even if the event loop is making its way through the <em>render</em> queue tasks, if an <em>interactive</em> task is queued, the event loop will handle this task before resuming with render tasks.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Task queues</h2></div></div></div><p>The concept of queued tasks<a id="id58" class="indexterm"/> is essential to understand how web browsers work. The term browser is actually misleading. We used them to browse static web pages in an earlier, sparser web. Now, large and complex applications run in browsers—it's really more of a web platform. The task queues and event loops that service them are probably the best design to handle so many moving parts.</p><p>We saw earlier in this chapter that the JavaScript interpreter, along with the code that it parses and runs, is really just a black box when viewed from the perspective of an execution environment. In fact, invoking the interpreter is itself a task, and is reflective of the run-to-completion nature of JavaScript. Many tasks involve the invocation of the JavaScript interpreter, as visualized here:</p><div><img src="img/B05133_02_03.jpg" alt="Task queues"/></div><p>Any one of these events—the<a id="id59" class="indexterm"/> user clicking an element, a script loading in the page, or data from a prior API call arriving in the browser—creates a task that invokes the JavaScript interpreter. It tells the interpreter to run a specific piece of code, and it'll continue to run it until it completes. This is the run-to-completion nature of JavaScript. Next, we'll dig into the execution contexts created by these tasks.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Execution contexts</h1></div></div></div><p>Now it's time to look at the JavaScript <a id="id60" class="indexterm"/>interpreter itself—the component that takes over from other browser components when events take place and code needs to run. There's always an active JavaScript context, and within the interpreter, we'll find a stack of contexts. This is similar to many programming languages where stacks control the active context.</p><p>Think of the active context as a snapshot of what's happening right now in our JavaScript code. A stack structure is used because the active context can change to something else, such as when a function is called. When this happens, a new snapshot is pushed onto the stack, becoming the active context. When it's done running, it's popped from the stack, leaving the next context as the active context.</p><p>In this section, we'll take a look at how the JavaScript interpreter handles context switching, and the internal job queue that manages the context stack.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Maintaining execution state</h2></div></div></div><p>The stack of contexts within the <a id="id61" class="indexterm"/>JavaScript interpreter isn't a static structure—it's constantly changing. There's two important things that happen throughout the lifetime of this stack. First, at the top of the stack, we have the active context. This is the code that currently executes as the interpreter moves through its instructions. Here's an idea of what a JavaScript execution context stack looks like with the active context always at the top:</p><div><img src="img/B05133_02_04.jpg" alt="Maintaining execution state"/></div><p>The other important responsibility of the call stack is to bookmark the state of an active context when it's deactivated. For example, let's say that after a few statements, <code class="literal">func1()</code> calls <code class="literal">func2()</code>. At this point, the context is bookmarked to the spot directly after the call to <code class="literal">func2()</code>. Then, it's replaced with the new active context—<code class="literal">func2()</code>. When it completes, the process is repeated and <code class="literal">func1()</code>again becomes the active context.</p><p>This kind of context <a id="id62" class="indexterm"/>switching happens all over our code. For example, there's a global context, which is the entry point into our code, there's the functions themselves which have their own context. There are also more recent additions to the language, which have their own contexts, such as modules and generators. Next, we'll look at the job queues responsible for creating new execution contexts.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Job queues</h2></div></div></div><p>Jobs queues<a id="id63" class="indexterm"/> are similar to the task queues that we looked at earlier. The difference is that job queues are specific to the JavaScript interpreter. That is, they're encapsulated within the interpreter—the browser doesn't interact directly with these queues. However, when the interpreter is invoked by the browser, in response to a loaded script or event callback task for example, new jobs are created by the interpreter.</p><div><img src="img/B05133_02_05.jpg" alt="Job queues"/></div><p>The job queues within the JavaScript interpreter are actually much more straightforward than the task queues that are used to coordinate all the web browser components. There are only two essential queues. One is for creating new execution context stacks (call stacks). The other is specific to promise resolution callback functions.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>We'll go into more depth on how the promise resolution callback job works in the next chapter.</p></div></div><p>Given the restricted<a id="id64" class="indexterm"/> responsibilities of these internal JavaScript job queues, one might draw the conclusion that they're unnecessary—an act of over engineering. That's not true, because while today there's limited responsibilities found in these jobs, the job queue design allows for much easier expansion and refinement of the language. In particular, the job queue mechanism is favorable when considering new concurrency constructs in future versions of the language.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Creating tasks using timers</h1></div></div></div><p>So far in this chapter, we've<a id="id65" class="indexterm"/> had a look at all the inner workers of the web<a id="id66" class="indexterm"/> browser environment, and where the JavaScript interpreter fits in this environment. What does all this have to do with applying concurrency principles to our code? With the knowledge of what's happening under the hood, we have a greater insight into what's happening when a given chunk of our code is run. Particularly, we know what's happening relative to other code chunks; time ordering is a crucial concurrency property.</p><p>This being said, let's actually write some code. In this section, we'll use timers to explicitly add tasks to the task queue. We'll also learn when and where the JavaScript interpreter jumps in and starts executing our code.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Using setTimeout()</h2></div></div></div><p>The <code class="literal">setTimeout()</code> function<a id="id67" class="indexterm"/> is staple in any JavaScript code. It's used to execute code at some point in the future. New JavaScript programmers often trip over the <code class="literal">setTimeout()</code> function because it's a timer. At a set point in the future, say 3 seconds from now, a callback function will be invoked. When we call <code class="literal">setTimeout()</code>, we will get the <code class="literal">atimer</code> ID in return, which can be cleared later on using <code class="literal">clearTimeout()</code>. Here's what the basic usage of <code class="literal">setTimeout()</code> looks like:</p><div><pre class="programlisting">// Creates a timer that calls our function in no less
// than 300MS. We can use the "console.time()" and the
// "console.timeEnd()" functions to see how long it actually
// takes.
//
// This is typically around 301MS, which isn't at all 
// noticeable by the user, but is unreliable for
// accurately scheduling function calls.
var timer = setTimeout(() =&gt; {
    console.timeEnd('setTimeout');
}, 300);

console.time('setTimeout');</pre></div><p>Here's the part<a id="id68" class="indexterm"/> that's misunderstood by JavaScript newcomers; it's a best effort timer. The only guarantee we have when using <code class="literal">setTimeout()</code> is that our callback function will never be called sooner than the allotted time that we pass it. So if we said call this function in 300 milliseconds, it'll never call it in 275 milliseconds. Once the 300 milliseconds have elapsed, a new task is queued. If there's nothing waiting in line before this task, the callback is run right on time. Even if there are a few things in the queue in front of it, the effects are hardly noticeable—it appears to run at the correct time.</p><p>But as we've seen, JavaScript is single threaded and run-to-completion. This means that once the JavaScript interpreter starts, it doesn't stop until it's finished; even if there's a task waiting for a timer event callback. So, it's entirely possible that even though we asked the timer to execute the callback in 300 milliseconds, it executes it in 500 milliseconds. Let's take a look at an example to see how this is possible:</p><div><pre class="programlisting">// Be careful, this function hogs the CPU...
function expensive(n = 25000) {
    var i = 0;
    while (++i &lt; n * n) {}
    return i;
}

// Creates a timer, the callback uses
// "console.timeEnd()" to see how long we
// really waited, compared to the 300MS
// we were expecting.
var timer = setTimeout(() =&gt; {
    console.timeEnd('setTimeout');
}, 300);

console.time('setTimeout');

// This takes a number of seconds to
// complete on most CPUs. All the while, a
// task has been queued to run our callback
// function. But the event loop can't get
// to that task until "expensive()" completes.
expensive();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Using setInterval()</h2></div></div></div><p>The cousin of <code class="literal">setTimeout()</code> is the <code class="literal">setInterval()</code> function. As the name suggests, it accepts a callback function that's to<a id="id69" class="indexterm"/> be called at a regular interval. In fact, <code class="literal">setInterval()</code> takes the exact same arguments as <code class="literal">setTimeout()</code>. The only difference is that it will keep calling the function every x milliseconds until the timer is cleared using <code class="literal">clearInterval()</code>.</p><p>This function is handy when we want to keep calling the same function, over and over. For example, if we poll an API endpoint, <code class="literal">setInterval()</code> is a good candidate solution. However, keep in mind that the scheduling of the callbacks is fixed. That is, once we call <code class="literal">setInterval()</code> with, say, 1000 milliseconds, there's no changing that 1000 milliseconds without first clearing the timer. For cases where the interval needs to be dynamic, using <code class="literal">setTimeout()</code> works better. The callback schedules the next interval, which allows the interval to be dynamic. For example, backing off from polling an API too frequently by increasing the interval.</p><p>In the <code class="literal">setTimeout()</code> example that we last looked at, we saw how running JavaScript code can mess with the event loop. That is, it prevents the event loop from consuming the task that invokes the JavaScript interpreter with our callback function. This allows us to defer code execution till some point in the future, but with no promises of accuracy. Let's see what happens when we schedule tasks using <code class="literal">setInterval()</code>. There's also some blocking JavaScript code that runs afterward:</p><div><pre class="programlisting">// A counter for keeping track of which
// interval we're on.
var cnt = 0;

// Set up an interval timer. The callback will
// log which interval scheduled the callback.
var timer = setInterval(() =&gt; {
    console.log('Interval', ++cnt);
}, 3000);

// Block the CPU for a while. When we're no longer
// blocking the CPU, the first interval is called,
// as expected. Then the second, when expected. And
// so on. So while we block the callback tasks, we're
// also blocking tasks that schedule the next interval.
expensive(50000);</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Responding to DOM events</h1></div></div></div><p>In the preceding section, we saw <a id="id70" class="indexterm"/>how to schedule JavaScript code to run at a later time. This is done explicitly by other JavaScript code. Most of the time, our code runs in response to user interactions. In this section, we'll look at the common interface that's used not only by DOM events, but also by things such as network and web worker events. We'll also look at a technique for dealing with large volumes of similar events—called <a id="id71" class="indexterm"/>debouncing.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Event targets</h2></div></div></div><p>The <code class="literal">EventTarget</code> interface<a id="id72" class="indexterm"/> is used by many browser components, including DOM elements. It's how we dispatch events to elements as well as listen to events and respond by executing a callback function. It's actually a very straightforward interface that's easy to follow. This is crucial since many different types of components use this same interface for event management. We'll see as we progress through the book.</p><p>The same task queue mechanisms that execute the callback functions for the timers that we used in the preceding section are relevant for <code class="literal">EventTarget</code> events. That is, if an event has taken place, a task to invoke the JavaScript interpreter with the appropriate callback is queued. The same limitations faced with using <code class="literal">setTimeout()</code> are imposed here. Here's what a task queue looks like when there's long-running JavaScript code that's blocking user events:</p><div><img src="img/B05133_02_06.jpg" alt="Event targets"/></div><p>In addition to attaching <a id="id73" class="indexterm"/>listener functions to event targets that react to user interaction, we can trigger these events manually, as the following code illustrates:</p><div><pre class="programlisting">// A generic event callback, logs the event timestamp.
function onClick(e) {
    console.log('click', new Date(e.timeStamp));
}

// The element we're going to use as the event
// target.
var button = document.querySelector('button');

// Setup our "onClick" function as the
// event listener for "click" events on this target.
button.addEventListener('click', onClick);

// In addition to users clicking the button, the
// EventTarget interface lets us manually dispatch
// events.
button.dispatchEvent(new Event('click'));</pre></div><p>It's good practice to<a id="id74" class="indexterm"/> name functions that are used in callbacks where possible. This way, when our code breaks, it's much easier to trace down the problem. It's not impossible with anonymous functions, it's just more time consuming. On the other hand, arrow functions are more concise and have more binding flexibility. Choose your trade-offs wisely.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Managing event frequency</h2></div></div></div><p>One challenge with user <a id="id75" class="indexterm"/>interaction events is that there can be lots of them, in a very short amount of time. For instance, when the user moves the mouse around on the screen, hundreds of events are dispatched. If we had event targets listening for these events, the task queue would quickly fill up, and the user experience would bog down.</p><p>Even when we do have event listeners in place for high frequency events, such as mouse moves, we don't necessarily need to respond to all of them. For example, if there's 150 mouse move events that take place in 1-2 seconds, chances are, we only care about the last move—the most recent position of the mouse pointer. That is, the JavaScript interpreter is being invoked with our event callback code 149 times more than it needs to.</p><p>To deal with these types of event frequency scenarios, we can utilize a technique called <em>debouncing</em>. A debounced function means that if it's called in succession more than once within a given time frame, only the last call is actually used and the earlier calls are ignored. Let's walk through an example of how we can implement this:</p><div><pre class="programlisting">// Keeps track of the number of "mousemove" events.
var events = 0;

// The "debounce()" takes the provided "func" an limits
// the frequency at which it is called using "limit"
// milliseconds.
function debounce(func, limit) {
    var timer;

    return function debounced(...args) {
        // Remove any existing timers.
        clearTimeout(timer);

        // Call the function after "limit" milliseconds.
        timer = setTimeout(() =&gt; {
            timer = null;
            func.apply(this, args);
        }, limit);
    };
}

// Logs some information about the mouse event. Also log
// the total number of events.
function onMouseMove(e) {
    console.log(`X ${e.clientX} Y ${e.clientY}`);
    console.log('events', ++events);
}

// Log what's being typed into the text input.
function onInput(e) {
    console.log('input', e.target.value);
}

// Listen to the "mousemove" event using the debounced
// version of the "onMouseMove()" function. If we 
// didn't wrap this callback with "debounce()"
window.addEventListener('mousemove', debounce(onMouseMove, 300));

// Listen to the "input" event using the debounced version
// of the "onInput()" function to prevent triggering events
// on every keystroke.
document.querySelector('input')
    .addEventListener('input', debounce(onInput, 250));</pre></div><p>Using the debounce<a id="id76" class="indexterm"/> technique to avoid giving the CPU more work than necessary is an example of the conserve principle in action. By ignoring 149 events, we save (conserve) the CPU instructions that would otherwise be executed and provide no real value. We also save on any kind of memory allocation that would otherwise happen in these event handlers.</p><p>The JavaScript concurrency principles were introduced at the end of <a class="link" href="ch01.html" title="Chapter 1. Why JavaScript Concurrency?">Chapter 1</a>, <em>Why JavaScript Concurrency?</em>, and they'll be pointed out throughout the code examples in the remainder of the book.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Responding to network events</h1></div></div></div><p>Another critical piece<a id="id77" class="indexterm"/> of any front-end application is network interactions, fetching data, issuing commands, and so forth. Since network communications are an inherently asynchronous activity, we have to rely on events—the <code class="literal">EventTarget</code> interface to be precise.</p><p>We'll start by looking at the generic mechanism that hooks up our callback functions with requests and getting responses from the back-end. Then, we'll look at how trying to synchronize several network requests creates a seemingly hopeless concurrency scenario.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Making requests</h2></div></div></div><p>To interact with the <a id="id78" class="indexterm"/>network, we create a new instance of <code class="literal">XMLHttpRequest</code>. We then tell it the type of request that we want to make—GET versus POST and the request endpoint. These request objects also implement the <code class="literal">EventTarget</code> interface so that we can listen for data arriving from the network. Here's an example of what this code looks like:</p><div><pre class="programlisting">// Callback for successful network request,
// parses JSON data.
function onLoad(e) {
    console.log('load', JSON.parse(this.responseText));
}

// Callback for problematic network request,
// logs error.
function onError() {
    console.error('network', this.statusText || 
        'unknown error');
}

// Callback for a cancelled network request,
// logs warning.
function onAbort() {
    console.warn('request aborted...');
}

var request = new XMLHttpRequest();

// Uses the "EventTarget" interface to attach event 
// listeners, for each of the potential conditions.
request.addEventListener('load', onLoad);
request.addEventListener('error', onError);
request.addEventListener('abort', onAbort);

// Sends a "GET" request for "api.json".
request.open('get', 'api.json');
request.send();</pre></div><p>We can see here <a id="id79" class="indexterm"/>that there are a number of possible states for network requests. The successful path is the server responding with the data we need and we're able to parse it as JSON. The error state is when something went wrong, maybe the server isn't reachable. The final state that we're concerned with here is when the request is cancelled or aborted. This means that we no longer care about the successful path because something in our application changed while the request was in flight. The user navigated to another section, for example.</p><p>While the previous code was easy enough to use and understand, it's not always the case. We're looking at a single request and a few callbacks. Very seldom do our application components consist of a<a id="id80" class="indexterm"/> single network request.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Coordinating requests</h2></div></div></div><p>In the preceding section, we<a id="id81" class="indexterm"/> saw what the basic interaction with <code class="literal">XMLHttpRequest </code>instances looks like for making a network request. The challenge surfaces when there are several requests. Most of the time, we make multiple network requests so that we have the data necessary for rendering a UI component. The responses from the back-end will all arrive at different times, and are likely dependent on one another.</p><p>Somehow, we need to synchronize the responses of these asynchronous network requests. Let's take a look at how we can go about doing this using the <code class="literal">EventTaget</code> callback functions:</p><div><pre class="programlisting">// The function that's called when a response arrives ,
// it's also responsible for coordinating responses.
function onLoad() {

    // When the response is ready, we push the parsed
    // response onto the "responses" array, so that we
    // can use responses later on when the rest of them
    // arrive.
    responses.push(JSON.parse(this.responseText));

    // Have all the respected responses showed up yet?
    if (responses.length === 3) {
        // How we can do whatever we need to, in order
        // to render the UI component because we have
        // all the data.
        for (let response of responses) {
            console.log('hello', response.hello);
        }
    }
}

// Creates our API request instances, and a "responses"
// array used to hold out-of-sync responses.
var req1 = new XMLHttpRequest(),
    req2 = new XMLHttpRequest(),
    req3 = new XMLHttpRequest(),
    responses = [];

// Issue network requests for all our network requests.
for (let req of [ req1, req2, req3 ]) {
    req.addEventListener('load', onLoad);

    req.open('get', 'api.json');
    req.send();
}</pre></div><p>There's a lot of <a id="id82" class="indexterm"/>extra bits to consider when there's more than one request. Since they all arrive at different times, we need to store the parsed responses in an array, and with the arrival of every response, we need to check if we have everything we expect. This simplified example doesn't even take into consideration failed or cancelled requests. As this code alludes, the callback function approach to synchronization is limiting. In the coming chapters, we'll learn how to overcome this limitation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Concurrency challenges with this model</h1></div></div></div><p>We'll wrap this chapter up with a <a id="id83" class="indexterm"/>discussion on the challenges that this execution model poses with JavaScript concurrency. There are two fundamental obstacles. The first is the fact that no matter what, any JavaScript code that runs will block anything else from happening. The second obstacle is trying to synchronize asynchronous actions with callback functions, leading to callback hell.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Limited opportunity for parallelism</h2></div></div></div><p>It used to be that the lack <a id="id84" class="indexterm"/>of parallelism in JavaScript wasn't really an issue. Nobody missed it because JavaScript was viewed as a progressive enhancement tool for HTML pages. This changed when the front-end started taking on more responsibilities. These days, the majority of the application actually resides in the front-end. This allows back-end components to focus on problems that can't be solved by JavaScript (from a browser perspective, NodeJS is another matter entirely that we'll look at later in the book).</p><p>For example, mapping and reducing API data sources into some representation required by a feature can be implemented in the back-end. This means that the front-end JavaScript code just needs to query for this endpoint. The problem is that this API endpoint is created for some specific UI feature, not as an essential supporting pillar of our data model. If we can perform these tasks in the front-end, we keep the UI features and the data transformations they need, tightly coupled together. This frees up the back-end to stay focused on more pressing issues like replication and load balancing.</p><p>We can perform these<a id="id85" class="indexterm"/> types of data transformations in the front-end, but they wreak havoc on the usability of the interface. This is largely due to all the moving parts competing for the same compute resource. This model, in other words, makes it impossible for us to implement the parallelize principle and take advantage of more than one resource. We will overcome this web browser limitation with the help of Web workers, covered in further chapters.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Synchronization through callbacks</h2></div></div></div><p>Synchronization through callbacks <a id="id86" class="indexterm"/>is hard to implement and doesn't scale well. It's callback hell, which is a term popular among JavaScript programmers. Needless to say, endless synchronization through callbacks in our code creates problems. We often have to create some kind of state tracking mechanism, such as global variables. And when problems do arise, a nest of callback functions is very time consuming to traverse mentally.</p><p>Generally speaking, the callback approach to synchronizing multiple asynchronous actions requires a lot of overhead. That is, the boilerplate code that exists for the sole purpose of dealing with asynchronous actions. The synchronize concurrency principle is about writing concurrent code that doesn't embed the main goal in a maze of synchronization handling logic. Promises help us write concurrent code consistently throughout our application by lessening the use of callback functions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>The focus of this chapter has been the web browser platform and JavaScript's place within it. There are a lot of events taking place whenever we view and interact with web pages. These are processed as tasks, taken from queues. One such task is invoking the JavaScript interpreter with code to run.</p><p>When the JavaScript interpreter runs, it contains an execution context stack. A function, a module, and global script code—these are all examples of JavaScript execution contexts. The interpreter also has it's own internal job queues; one is used to create new execution context stacks, and another is used for calling promise resolution callback functions.</p><p>We wrote some code that manually created tasks using the <code class="literal">setTImeout()</code> function and explicitly demonstrated how long-running JavaScript code can be problematic for these tasks. We then looked at the <code class="literal">EventTarget</code> interface, used to listen to DOM events, and to network requests, amongst other things we didn't look at in this chapter, like web workers and file readers.</p><p>We wrapped up with a look at some of the challenges that JavaScript programmers face when using this model. In particular, it's hard to follow our JavaScript concurrency principles. We can't parallelize, and trying to synchronize using nothing but callbacks is a nightmare.</p><p>In the next chapter, we'll look at a new way of thinking about synchronization using promises. This will allow us to start designing and building concurrent JavaScript applications in earnest.</p></div></body></html>