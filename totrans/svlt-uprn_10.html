<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-125"><a id="_idTextAnchor125"/>10</h1>
<h1 id="_idParaDest-126"><a id="_idTextAnchor126"/>Managing Static Assets</h1>
<p>When it comes to managing static assets, SvelteKit has little to do with the process. In fact, the entire process is handed over to the bundling tool Vite. By leveraging Vite for the management of static assets, we as developers don’t have to learn yet another framework-specific strategy. Instead, we can lean on Vite’s highly performant bundling and build processes. Because Vite automatically manages imported assets, we don’t have to worry about hashing files for caches. In this chapter, we’ll look at how we can leverage Vite to manage static assets such as images, fonts, audio, video, and CSS files. Once we examine <em class="italic">how</em> this is done, we’ll discuss some of the finer points surrounding static assets.</p>
<p>This chapter will be divided into the following sections:</p>
<ul>
<li>Importing Assets</li>
<li>Additional Information</li>
</ul>
<p>By the time we’re done, we’ll have a firm grasp of the best practices to use when including files that can be served <em class="italic">as is</em> within SvelteKit applications.</p>
<h1 id="_idParaDest-127"><a id="_idTextAnchor127"/>Technical requirements</h1>
<p>The complete code for this chapter is available on GitHub at: <a href="https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter10">https://github.com/PacktPublishing/SvelteKit-Up-and-Running/tree/main/chapters/chapter10</a>.</p>
<h1 id="_idParaDest-128"><a id="_idTextAnchor128"/>Importing Assets</h1>
<p>If you have worked in web development<a id="_idIndexMarker228"/> for the past decade, then you’ll remember a time when<a id="_idIndexMarker229"/> styles were written either inline or in a <strong class="bold">Cascading Style Sheet</strong> (<strong class="bold">CSS</strong>). These <strong class="bold">CSS</strong> files are helpful for creating a consistent look and feel for an application. Of course, their centralized nature comes with its own drawbacks. They often become large and difficult to navigate, which can lead to the inclusion of unused style rules. When precious milliseconds can mean the difference between converting a user or losing a sale, it’s important not to ship unused assets to clients. Besides, if we’re building a web application with SvelteKit, we really should use the Svelte approach and keep styles isolated within each component. But there are times when it’s useful to keep a style sheet that applies some global styles. For instance, imagine having to apply a specific style to each and every paragraph element. Incorporating the same simple style rule into every component across the application could lead to repetitive code. There may even be instances where we forget to include a rule, leading<a id="_idIndexMarker230"/> to inconsistent styles across<a id="_idIndexMarker231"/> the app. And while projects such as <strong class="bold">Tailwind CSS</strong> or <strong class="bold">Bootstrap</strong> are wonderful, they may not be appropriate for every project, which is why we’re going to cover how to include a global style sheet in our SvelteKit application.</p>
<p>To begin, we’ll need some styles. Keep<a id="_idIndexMarker232"/> in mind that these styles will apply to the entirety of the application. Normally, when creating styles within Svelte components, those styles are isolated to that specific component, meaning they are not applied to parent or child components. Many modern browsers apply their own default styles to HTML elements, and so, to unify the experience of an application, it’s common practice to create a <code>reset.css</code> file. This file ensures the experience is consistent across different browsers by resetting the styles applied by browsers of common elements to something predictable. For our example, we’ll use<a id="_idIndexMarker233"/> a slightly modified version of the concise yet thorough <strong class="bold">Custom CSS Reset</strong> by <em class="italic">Josh W. Comeau</em>. See the resources at the end of this chapter for links to the article explaining exactly how it works:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/reset.css</p>
<pre class="source-code">
/* https://www.joshwcomeau.com/css/custom-css-reset/ */
*, *::before, *::after {
  box-sizing: border-box;
}
* {
  margin: 0;
}
html, body {
  height: 100%;
  font-family: sans-serif;
}
body {
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
}
img, picture, video, canvas, svg {
  display: block;
  max-width: 100%;
}
input, button, textarea, select {
  font: inherit;
}
p, h1, h2, h3, h4, h5, h6 {
  overflow-wrap: break-word;
}</pre>
<p>In essence, the rules of this CSS file are setting more sane and predictable default styles for various HTML elements. For instance, <code>box-sizing</code> is set to <code>border-box</code>, which applies to all elements, as well as the <code>::before</code> and <code>::after</code> pseudo-elements. This rule means that the padding of elements will be included when calculating that element’s width. These CSS rules<a id="_idIndexMarker234"/> allow a consistent and reliable experience across browsers. Of course, we’re free to make any additions to this CSS. To make our changes slightly more noticeable, we’ve also set <code>font-family: sans-serif;</code> on both the <code>html</code> and <code>body</code> elements.</p>
<p>To include this CSS in our application, we’ll open <code>src/routes/+layout.svelte</code> and import it just as we would a JS module. If you remember back to <a href="B19024_02_Final_AM.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, we used the same method to import an image path!</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/routes/+layout.svelte</p>
<pre class="source-code">
&lt;script&gt;
  import '/src/reset.css';
  import Nav from '$lib/Nav.svelte';
  import Notify from '$lib/Notify.svelte';
  export let data;
&lt;/script&gt;
...</pre>
<p>Noticeably, the only change we need to make in this file is the very first line where we import <code>reset.css</code>. The remaining code has been omitted from the file for the sake of brevity. After importing the CSS file, notice that our styles are immediately applied. We don’t need to create <code>&lt;link&gt;</code> or <code>&lt;style&gt;</code> tags as Vite recognizes the style sheet for what it is and automatically applies it for us. Conveniently, the file import path can be relative or absolute as Vite makes no distinction between the two.</p>
<p>To highlight the benefits of importing<a id="_idIndexMarker235"/> a stylesheet with this method, let’s compare it with another method for including global style sheets. This method was applied to pre-1.0 releases of SvelteKit and worked by manually adding a <code>&lt;link&gt;</code> tag to the <code>&lt;head&gt;</code> section of <code>src/app.html</code>. It then referenced a file within the <code>static/</code> directory using the <code>%sveltekit.assets%</code> placeholder. This method is ill-advised but let’s analyze it to consider its faults:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">src/app.html</p>
<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8" /&gt;
    &lt;link rel="icon" href="%sveltekit.assets%/favicon.png" /&gt;
    &lt;meta name="viewport" content="width=device-width" /&gt;
    &lt;link rel="stylesheet" href="%sveltekit.assets%/global.css" /&gt;
      %sveltekit.head%
  &lt;/head&gt;
  &lt;body data-sveltekit-preload-data="hover"&gt;
    &lt;div style="display: contents"&gt;%sveltekit.body%&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
<p>As we can see, this method includes the <code>static/global.css</code> file inside the head tag of <code>src/app.html</code>, the application entry point. The <code>app.html</code> file works as scaffolding for the rest of the application to build off of, so it stands to reason that we could include any extraneous scripts or external assets here, just as the favicon is included. This method relies on the <code>%sveltekit.assets%</code> placeholder to include the CSS file from the <code>static/</code> directory. However, this method fails to consider Vite’s HMR features. Whenever changes are made to <code>static/global.css</code>, the entire development server will need to be restarted to reflect those changes as Vite does not process any of the files included in the static assets. Also consider the common scenario of applying minification to <code>.css</code> and preprocessing to <code>.scss</code>, <code>.sass</code>, or <code>.less</code> files. In each of these instances, we would need Vite to take a more hands-on approach than it does for files included from SvelteKit’s <code>static/</code> directory. And because Vite can manage cached files by appending hashes to the filenames of static assets, it is clear that importing files just as we would import a JS module is in our best interest.</p>
<p>In <a href="B19024_02_Final_AM.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, we saw how we could import<a id="_idIndexMarker236"/> an image URL. We’ve now also seen how Vite allows us to import a global CSS file directly into our Svelte components. Now that we’ve shown how to best utilize static assets dynamically with our applications, let’s discuss some more of the details surrounding this process.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor129"/>Additional Information</h1>
<p>We now know <em class="italic">how</em> we can import static files, but there are a few details to keep in mind when doing so. Here’s a breakdown of the various items we still need to cover:</p>
<ul>
<li>Images versus Styles</li>
<li>Customizing Imports</li>
<li>File Paths</li>
<li>SvelteKit Configuration Options</li>
<li>Vite Configuration Options</li>
</ul>
<p>Now let’s go over some important information about what went on behind the scenes with each of our imports.</p>
<h2 id="_idParaDest-130"><a id="_idTextAnchor130"/>Images versus Styles</h2>
<p>When we imported an image in <a href="B19024_02_Final_AM.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a>, we received the URL, which<a id="_idIndexMarker237"/> we then referenced<a id="_idIndexMarker238"/> in the <code>src</code> attribute of an <code>&lt;img&gt;</code> tag. When we imported the CSS file, we only needed to import it to apply the styles. This is because Vite is pre-configured to automatically inject the styles from CSS files into the component performing the import. Hence why the import was performed in the root <code>+layout.svelte</code> file. Vite also supports CSS <code>@import</code> and <code>url()</code> statements as well as CSS modules. CSS modules can be useful for importing style rules as objects within code whereas <code>@import</code> and <code>url()</code> allow developers to build a central CSS file that can reference smaller CSS files located elsewhere. When importing a CSS file, no other action needs to be taken other than the import. When importing other media such as fonts, audio, or video files, we’ll need to set the imported asset URL as the <code>src</code> attribute on the appropriate HTML element.</p>
<h2 id="_idParaDest-131"><a id="_idTextAnchor131"/>Customizing Imports</h2>
<p>When importing static assets<a id="_idIndexMarker239"/> from Vite, we can customize how they are imported by appending the appropriate suffix to the file import names. For instance, to import a file as a string, we can append <code>?raw</code> to the filename. As expected, this will give us the raw content of the imported file. For the <code>reset.css</code> example shown earlier, it could be included via <code>import reset from '/src/reset.css?raw';</code> where the reset variable contains the content from <code>reset.css</code>. We would then need to find a way to include that content inside of <code>&lt;style&gt;</code> tags. In a similar fashion, if we want to import a file as a URL that is not found in the standard media types, we can append <code>?url</code> to the file import<a id="_idIndexMarker240"/> statement. This can be helpful for including files served from a <code>?worker</code> to the filename!</p>
<h2 id="_idParaDest-132"><a id="_idTextAnchor132"/>File Paths</h2>
<p>When running Vite’s development<a id="_idIndexMarker242"/> server, we can observe the network requests in our browser’s developer tools and notice that imported files are served from their location within the project source code. For example, the image from <a href="B19024_02_Final_AM.xhtml#_idTextAnchor032"><em class="italic">Chapter 2</em></a> is located at <code>src/lib/images/demo.svg</code> and is also served from that very same location. However, when we run <code>npm run build</code> followed by <code>npm run preview</code>, we’ll observe that the path has changed. It is given the path <code>_app/immutable/assets/demo.dd76856a.svg</code>. This path is specific to the built SvelteKit application and, normally, we won’t edit it after the application has been built. But take a moment to notice that a hash has been included in the filename. Should the file contents change, we’ll notice the built asset will include a different hash appended to the file’s name.</p>
<p>We can also take this moment to observe the included favicon file. We’ll see that in both <code>dev</code> and <code>build</code>/<code>preview</code>, it is served from the domain root directory <code>/</code>. This is because it was located in the <code>static/</code> directory and Vite serves and builds the application so that any files located there will be served from the root level of the application.</p>
<h2 id="_idParaDest-133"><a id="_idTextAnchor133"/>SvelteKit Configuration Options</h2>
<p>These options can be customized in <code>svelte.config.js</code>:</p>
<ul>
<li><code>files.assets</code> – This option specifies the directory for which static assets will be stored. SvelteKit<a id="_idIndexMarker243"/> automatically sets this option to <code>static</code> and overrides the Vite sibling setting specified as <code>publicDir</code> (which defaults to <code>public</code>). Files that normally fit here are <code>robots.txt</code> or <code>favicon.ico</code> as they rarely change. To reference files located here in the source code, simply prefix the filename with <code>/</code>. For instance, we can show the default favicon by adding <code>&lt;img src='/favicon.png' /&gt;</code> to any component.</li>
<li><code>paths.assets</code> – This option takes a string that specifies<a id="_idIndexMarker244"/> the absolute path from where application files are served. It defaults to an empty string.</li>
<li><code>paths.base</code> – This option also defaults to an empty<a id="_idIndexMarker245"/> string. If your application is being served from a sub-directory, you can specify the root-relative path here. Then, you may use the <code>base</code> module imported from <code>$app/paths</code> to modify hardcoded paths appropriately.</li>
<li><code>paths.relative</code> – This option accepts a Boolean<a id="_idIndexMarker246"/> value. When <code>true</code>, the values provided by <code>base</code> and <code>assets</code> from the <code>$app/paths</code> module will be relative to built assets. When <code>false</code>, those same values with be root-relative.</li>
</ul>
<h2 id="_idParaDest-134"><a id="_idTextAnchor134"/>Vite Configuration Options</h2>
<p>This option can be customized in a project’s <code>vite.config.js</code>:</p>
<ul>
<li><code>assetsInclude</code> – Many common media types<a id="_idIndexMarker247"/> are automatically handled by Vite but this option can be useful if a project needs to extend the default list to treat uncommon file types as assets. This option allows for the customization<a id="_idIndexMarker248"/> of allowable static asset file types. It can be a string, regular expression, or <strong class="bold">picomatch</strong> pattern.</li>
</ul>
<p>We’ve just seen how we can customize the importing of static assets. If we need to force an asset to be imported as a URL, we know that we append <code>?url</code> to the end of the imported file. We’ve also learned how CSS files are automatically injected into the component they are imported to. Along with a few configuration options, these details provide insight into how we can make the management of static assets stress-free in our SvelteKit applications.</p>
<h1 id="_idParaDest-135"><a id="_idTextAnchor135"/>Summary</h1>
<p>When including images, CSS files, or other media types in SvelteKit applications, it is clear that we should leverage Vite to import the asset just as we would import a JS module. Doing so comes with the advantage of being simple but also allowing for optimized caches. It keeps our development experience smooth as Vite’s HMR will automatically show changes in the browser. It’s also flexible in that it allows for various media types to be imported either by URL or raw content.</p>
<p>Now that we know how to manage static assets, we should circle back to how we manage secrets. If you recall the previous chapter, we added a personal access token to the <code>.env</code> file, which allowed us to authenticate with the GitHub API. In the next chapter, we’ll explore this further and cover the various modules that make managing secrets a breeze.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor136"/>Resources</h1>
<ul>
<li>Tailwind CSS – <a href="https://tailwindcss.com/">https://tailwindcss.com/</a></li>
<li>Bootstrap – <a href="https://getbootstrap.com/">https://getbootstrap.com/</a></li>
<li>Josh W. Comeau’s Custom CSS Reset – <a href="https://www.joshwcomeau.com/css/custom-css-reset/">https://www.joshwcomeau.com/css/custom-css-reset/</a></li>
<li>Vite Configuration Options – <a href="https://vitejs.dev/config/">https://vitejs.dev/config/</a></li>
<li>CSS Modules – <a href="https://github.com/css-modules/css-modules">https://github.com/css-modules/css-modules</a></li>
<li>picomatch – <a href="https://github.com/micromatch/picomatch">https://github.com/micromatch/picomatch</a></li>
</ul>
</div>
</body></html>