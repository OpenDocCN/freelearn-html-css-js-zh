<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Hello, Three.js</h1></div></div></div><p>This chapter will take you from zero to sixty with a new Three.js project. We'll cover what Three.js is, how to get started with writing code for it, and the components of a basic scene.</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec08"/>The wonderful world of Three.js</h1></div></div></div><p>Three.js<a class="indexterm" id="id0"/> is a JavaScript library that simplifies displaying 3D graphics in web browsers. Artists, major brands, and many others are increasingly using Three.js to power immersive online experiences that can reach millions of people across many platforms. There are many inspiring demos of the technology at <a class="ulink" href="http://threejs.org/">http://threejs.org/</a>.</p><p>Three.js is usually used with a new technology called <strong>WebGL</strong><a class="indexterm" id="id1"/>, a JavaScript API for rendering graphics without plugins. The API is based on <strong>OpenGL</strong><a class="indexterm" id="id2"/>, a desktop graphics API <strong>(GL</strong><a class="indexterm" id="id3"/> stands for <strong>graphics library</strong>). Because it uses the client's graphics processing unit to accelerate rendering, WebGL is fast! However, many mobile browsers as well as Internet Explorer 10 and below do not support WebGL. Luckily, Three.js supports rendering with the <strong>HTML5 Canvas API</strong><a class="indexterm" id="id4"/> as well as other technologies such as <strong>Scalable Vector Graphics</strong><a class="indexterm" id="id5"/> instead.</p><div><div><h3 class="title"><a id="note02"/>Note</h3><p>You can find up-to-date information on browser support at <a class="ulink" href="http://caniuse.com/webgl">http://caniuse.com/webgl</a>.</p></div></div><p>Three.js is originally written and maintained by <em>Ricardo Cabello</em>, who is also known as <em>Mr.Doob</em>. The library is open source (MIT-licensed) and is available from its GitHub page, <a class="ulink" href="https://github.com/mrdoob/three.js">https://github.com/mrdoob/three.js</a>. The documentation of Three.js is available online<a class="indexterm" id="id6"/> at <a class="ulink" href="http://threejs.org/docs/">http://threejs.org/docs/</a>. When the documentation is insufficient, the best place to look is the <code class="literal">examples</code> folder of the project, which contains a large collection of examples demonstrating different features. You can browse the examples online<a class="indexterm" id="id7"/> at <a class="ulink" href="http://threejs.org/examples/">http://threejs.org/examples/</a>. The source code in the <code class="literal">src</code> folder is also worth browsing if you need to know how a certain class works or what methods and properties it exposes.<a class="indexterm" id="id8"/> Developers respond to questions about Three.js on the Q&amp;A site <strong>StackOverflow</strong><a class="indexterm" id="id9"/>, so if you are confused about something, you can browse questions with the <code class="literal">three.js</code> tag or ask your own.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>This book was written with Version r61 of the Three.js project. Certain parts of the API are still under development, but anything that is likely to change will be pointed out when it is introduced.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Let's code!</h1></div></div></div><p>Because Three.js runs in web browsers, it can run on—and be developed on—many different platforms. In fact, we're going to build<a class="indexterm" id="id10"/> our first Three.js project directly in a browser!</p><p>Open up <a class="ulink" href="http://mrdoob.com/projects/htmleditor/">http://mrdoob.com/projects/htmleditor/</a>. You should see HTML and JavaScript code overlaid on top of a spinning sphere-like shape, as shown in the following screenshot:</p><div><img alt="Let's code!" src="img/8539_01_01.jpg"/><div><p>The online Three.js editor</p></div></div><p>This is the <code class="literal">Hello, World</code> program of Three.js—the minimum code required to get a spinning shape rendering in the browser. The preview will automatically update when you change any code, so go ahead and play with it and see what happens. For example, try changing <code class="literal">THREE.MeshBasicMaterial</code> to <code class="literal">THREE.MeshNormalMaterial</code>. What happens if you change <code class="literal">IcosahedronGeometry</code> to <code class="literal">TorusKnotGeometry</code>? Try fiddling with some numbers. Can you make <a class="indexterm" id="id11"/>the shape rotate faster or slower?</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Been there, scene that</h1></div></div></div><p>Let's dig deeper into our spinning-shape world and explain how it all works. You can follow along with<a class="indexterm" id="id12"/> this section in<a class="indexterm" id="id13"/> the online editor or type the code into a new HTML file.</p><p>First, there's the HTML template:</p><div><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;style&gt;
      body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
      }
    &lt;/style&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src="img/three.min.js"&gt;&lt;/script&gt;
    &lt;script&gt; /* …your code here… */ &lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Nothing surprising here. We're basically just including Three.js and removing the browser's default page margins. The <code class="literal">&lt;canvas&gt;</code> element<a class="indexterm" id="id14"/>, onto which we'll render our scene, will be added into the DOM by our JavaScript.</p><div><div><h3 class="title"><a id="note03"/>Note</h3><p>Instead of using the Three.js file from the GitHub CDN, you should download the latest Three.js build and include the local copy in your projects. The full Three.js script can be found in the <code class="literal">build</code> folder of the project or can be downloaded from <a class="ulink" href="https://raw.github.com/mrdoob/three.js/master/build/three.js">https://raw.github.com/mrdoob/three.js/master/build/three.js</a>. In production, you will want to use the minified version (<code class="literal">three.min.js</code>).</p></div></div><p>Now comes the fun part: telling Three.js to<a class="indexterm" id="id15"/> display something. First, let's declare the objects we'll need:</p><div><pre class="programlisting">var camera, scene, renderer;
var geometry, material, mesh;</pre></div><p>Then, let's give them values and explain what they do:</p><div><pre class="programlisting">  scene = new THREE.Scene();</pre></div><p>A <code class="literal">Scene</code> class<a class="indexterm" id="id16"/> represents a list of objects that affect what is displayed on the screen,<a class="indexterm" id="id17"/> such as 3D models and lights. (Each class provided by Three.js is invoked as a property of the global <code class="literal">THREE</code> variable<a class="indexterm" id="id18"/>.) A scene isn't very useful by itself, so let's put something in it.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p><strong>Downloading the example code</strong></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>A <code class="literal">mesh</code> object<a class="indexterm" id="id19"/> can be displayed in a scene, instantiated using the <code class="literal">THREE.Mesh</code> constructor<a class="indexterm" id="id20"/>. It consists of <code class="literal">geometry</code>, which is the object's shape, and a <code class="literal">material</code>, which is a color, image, or other texture that defines how the faces of the shape appear. In this case, the geometry we'll use is <code class="literal">IcosahedronGeometry</code>, <a class="indexterm" id="id21"/>which is based on a 20-sided shape approximating a sphere. The constructor takes a radius and detail, where detail is the number of times to split each edge of the icosahedron to add more faces and make the shape closer to a sphere:</p><div><pre class="programlisting">  geometry = new THREE.IcosahedronGeometry(200, 1);
  material = new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true, wireframeLinewidth: 2 });
  mesh = new THREE.Mesh(geometry, material);</pre></div><p><code class="literal">MeshBasicMaterial</code> <a class="indexterm" id="id22"/>is a type of material that is not affected by the surrounding lighting. The options we're passing include the color in hex format (like you'd use in CSS), whether to display the shape as a solid color or highlight the edges, and how thick to draw the wireframe, respectively.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>There are many other types of geometry and materials. <a class="link" href="ch02.html" title="Chapter 2. Building a World">Chapter 2</a>, <em>Building a World</em> describes them in detail.</p></div></div><p>Now we can add our mesh to the scene:</p><div><pre class="programlisting">  scene.add(mesh);</pre></div><p>We've put together what we<a class="indexterm" id="id23"/> want to display, so the next step is to actually display it. Three.js accomplishes this with <strong>renderers</strong><a class="indexterm" id="id24"/>, which take the objects in a scene, perform some calculations, and then ask the browser to display the result in a specific format like WebGL. The renderer creates a new <code class="literal">&lt;canvas&gt;</code> element<a class="indexterm" id="id25"/> by default that should be added to the DOM:</p><div><pre class="programlisting">  renderer = new THREE.CanvasRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);</pre></div><p>Here, we're using the <code class="literal">CanvasRenderer</code> <a class="indexterm" id="id26"/>as our method of displaying the scene. (We'll cover other renderers such as <code class="literal">WebGLRenderer</code> in <a class="link" href="ch02.html" title="Chapter 2. Building a World">Chapter 2</a>, <em>Building a World</em>.) We're also telling the renderer to display the scene at the full size of the browser window with our <a class="indexterm" id="id27"/>
<code class="literal">setSize()</code> call. Then we will add the renderer's <a class="indexterm" id="id28"/>canvas to the DOM with <code class="literal">appendChild(renderer.domElement)</code>.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Avoid changing the canvas' size with CSS; use the renderer's <code class="literal">setSize</code> method instead, which sets the<a class="indexterm" id="id29"/> <code class="literal">width</code> and <a class="indexterm" id="id30"/>
<code class="literal">height</code> HTML attributes on the canvas element. This is because CSS describes the display size but not the render size. That is, if the canvas is rendered at 800 x 600, but the CSS shows it at 1024 x 768, the rendering will be stretched to fill the space just like if you specified the CSS size of an image to be larger than its true size. This can result in distortion and difficulty converting between "screen space" and "canvas space."</p></div></div><p>The one last thing we need is a <code class="literal">camera</code> object<a class="indexterm" id="id31"/> as shown in the following code snippet, which is something Three.js uses to tell the renderer from what perspective the scene should be displayed. If the player was standing in your virtual world and their screen represented what they could see, <code class="literal">camera</code> would be their eyes, <code class="literal">renderer</code> would be their brain, and <code class="literal">scene</code> would be their universe.</p><div><pre class="programlisting">  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
  camera.position.z = 500;</pre></div><p>A <code class="literal">PerspectiveCamera</code> instance<a class="indexterm" id="id32"/> displays the world from a single point in space, just like your eyes. This creates a little bit of distortion due to distance (objects that are farther away appear smaller). There is also an <code class="literal">OrthographicCamera</code> class<a class="indexterm" id="id33"/> which is like looking out from a plane. Orthographic cameras are sometimes used for <strong>isometric</strong><a class="indexterm" id="id34"/> (also known as <strong>2.5D</strong>) games and level editors to get accurate views of objects' relative sizes. You<a class="indexterm" id="id35"/> can see the<a class="indexterm" id="id36"/> difference in the following figure:</p><div><img alt="Been there, scene that" src="img/8539_01_02.jpg"/><div><p>Camera projections. Top is perspective and bottom is orthographic.</p></div></div><p>The <code class="literal">PerspectiveCamera</code> object's<a class="indexterm" id="id37"/> parameters are field of view (in degrees), which controls how wide the camera lens is; aspect ratio, the ratio of the canvas' width to its height; near-plane frustum,the closest an object can be to the camera and still be seen; and far-plane frustum, the farthest <a class="indexterm" id="id38"/>an object can be from the camera and still be rendered. You'll rarely need to change these values</p><p>Also notice that we change the camera's location by assigning to <code class="literal">camera.position.z</code>. Three.js uses a <strong>spatial coordinate system</strong><a class="indexterm" id="id39"/> in which, by default, the x-axis increases from left to right, the z-axis increases from back to front, and the y-axis increases upward. Most objects have a <em>position</em> and <em>scale</em>, both of which are represented by a three-dimensional vector (specifically <code class="literal">THREE.Vector3</code>). They also have a <em>rotation</em> represented by a <code class="literal">THREE.Euler</code> instance, which is an abstraction that allows treating rotation much like a vector. All objects are initialized at the position (0, 0, 0), also called the <strong>origin</strong><a class="indexterm" id="id40"/>. Rotation also starts at (0, 0, 0), and scale starts at (1, 1, 1). Vectors are very versatile, but usually all you'll need to do with them is assign to the<a class="indexterm" id="id41"/> <code class="literal">x</code>,<a class="indexterm" id="id42"/> <code class="literal">y</code>, and <a class="indexterm" id="id43"/>
<code class="literal">z</code> properties. For example, if we wanted to move the camera upward, we could increase <code class="literal">camera.position.y</code>.</p><p>Finally, we can display the scene by asking the renderer to display it from the camera's perspective:</p><div><pre class="programlisting">  renderer.render(scene, camera);</pre></div><p>Hooray, a static 3D display! If you<a class="indexterm" id="id44"/> have been following along by rebuilding our <a class="indexterm" id="id45"/>scene from scratch, now is the point at which<a class="indexterm" id="id46"/> you can actually see the results of your work. Just open the HTML file in a browser. (If you're loading the <code class="literal">three.js</code> file from GitHub instead of locally, you'll need to be connected to the Internet.)</p><p>A static scene isn't very fun though, so let's add animation by constructing a <a class="indexterm" id="id47"/>render loop:</p><div><pre class="programlisting">animate();

function animate() {

  requestAnimationFrame(animate);

  mesh.rotation.x = Date.now() * 0.00005;
  mesh.rotation.y = Date.now() * 0.0001;

  renderer.render(scene, camera);

}</pre></div><p>The key here is <code class="literal">requestAnimationFrame()</code>,<a class="indexterm" id="id48"/> which executes the function passed to it when the browser is ready to paint a new frame. In that function, we perform any necessary updates to the scene (in this case, changing the mesh's <code class="literal">rotation</code> vector<a class="indexterm" id="id49"/> just like we changed the camera's <code class="literal">position</code> vector<a class="indexterm" id="id50"/> earlier) and then ask the renderer to repaint the canvas as before.</p><p>Putting it all together (and also wrapping our setup code in a function for clarity), we get:</p><div><pre class="programlisting">var camera, scene, renderer;
var geometry, material, mesh;

init();
animate();

function init() {
  
  camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );
  camera.position.z = 500;

  scene = new THREE.Scene();

  geometry = new THREE.IcosahedronGeometry( 200, 1 );
  material = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, wireframeLinewidth: 2 } );

  mesh = new THREE.Mesh( geometry, material );
  scene.add( mesh );

  renderer = new THREE.CanvasRenderer();
  renderer.setSize( window.innerWidth, window.innerHeight );

  document.body.appendChild( renderer.domElement );

}

function animate() {

  requestAnimationFrame( animate );

  mesh.rotation.x = Date.now() * 0.00005;
  mesh.rotation.y = Date.now() * 0.0001;

  renderer.render( scene, camera );

}</pre></div><p>It's animating! You've<a class="indexterm" id="id51"/> now built <a class="indexterm" id="id52"/>your first 3D world in the browser. Because it's in JavaScript, you can also easily send it to your friends. (In the online editor, click on the stacked bars icon <img alt="Been there, scene that" src="img/8539_01_04.jpg"/> at the upper-right, click on the <strong>Download</strong> button<a class="indexterm" id="id53"/>, and then rename the downloaded file with a <code class="literal">.html</code> extension.)</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>Both within the Three.js repository and online, most of the Three.js examples you'll find will have all their code in a single HTML file. This is convenient for small projects but unhealthy for larger ones. Even though most of the code in this book is small enough to be manageable in a single file, we will try to use patterns that make the code maintainable. <a class="link" href="ch05.html" title="Chapter 5. Design and Development">Chapter 5</a>, <em>Design and Development</em> specifically addresses designs that work well at scale.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Choosing your environment</h1></div></div></div><p>The Google Chrome browser<a class="indexterm" id="id54"/> is usually considered to be on<a class="indexterm" id="id55"/> the leading edge of WebGL support, so many Three.js developers work mainly in either the latest stable version of Chrome or the alpha-release branch, named <strong>Canary</strong><a class="indexterm" id="id56"/>. Chrome has a lot of other advantages too, such as advanced performance profiling, the ability to emulate touch events, and support for inspecting canvas frames. (You can access these features through the Chrome Developer Tools settings. Canvas inspection<a class="indexterm" id="id57"/> is explained well at <a class="ulink" href="http://www.html5rocks.com/en/tutorials/canvas/inspection/">http://www.html5rocks.com/en/tutorials/canvas/inspection/</a>.) If you want to experiment with WebGL features that are still in development, you can enable some of them in Canary's <a class="indexterm" id="id58"/>
<strong>about:flags</strong> page.</p><p>When it comes to coding, the online Three.js editor is great for testing small, isolated concepts, but it quickly gets cumbersome for more complex projects. Most programming environments have solid JavaScript support, but some are better than others.</p><p>Chrome also has a script-editing environment that works well for some people. If you open the Chrome Developer Tools (<em>Ctrl</em> / <em>Cmd</em> + <em>Shift</em> + <em>I</em>) and switch to the <strong>Sources</strong> tab<a class="indexterm" id="id59"/>, you can configure Chrome to edit files from your local filesystem. This environment includes syntax highlighting, debugging, autocompletion, source mapping for minified files, revision control that visually shows changes, and the ability to run the code instantly without reloading the page. Additionally, you can store snippets for reuse as described at <a class="ulink" href="https://developers.google.com/chrome-developer-tools/docs/authoring-development-workflow#snippets">https://developers.google.com/chrome-developer-tools/docs/authoring-development-workflow#snippets</a>.</p><p>You can see what the editor looks like in the following screenshot:</p><div><img alt="Choosing your environment" src="img/8539_01_03.jpg"/><div><p>Google Chrome Developer Tools</p></div></div><p>If you prefer to work outside of the <a class="indexterm" id="id60"/>Chrome editor, it can be tedious to constantly switch windows and reload the page. There are several tools that attempt to solve this. LiveReload<a class="indexterm" id="id61"/> (<a class="ulink" href="http://livereload.com/">http://livereload.com/</a>) and Tin.cr<a class="indexterm" id="id62"/> (<a class="ulink" href="http://tin.cr/">http://tin.cr/</a>) are the best known; they are browser extensions that automatically reload the page when <a class="indexterm" id="id63"/>you save a file. You may also want to try LightTable<a class="indexterm" id="id64"/> (<a class="ulink" href="http://www.lighttable.com/">http://www.lighttable.com/</a>), an experimental IDE that also autoreloads and additionally includes tools for visually manipulating your code.</p><p>If you use Sublime Text as <a class="indexterm" id="id65"/>your editor, you can install autocompletion support for Three.js commands through the package manager or from the Three.js repository itself (in <code class="literal">/utils/editors</code>).</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Summary</h1></div></div></div><p>We have constructed our first 3D world with Three.js. In this chapter, we learned what Three.js is and does, reviewed the basic components of a Three.js scene, and set up our editing environment. We used the <code class="literal">scene</code>, <code class="literal">renderer</code>, <code class="literal">camera</code>, <code class="literal">mesh</code>, <code class="literal">geometry</code>, and <code class="literal">material</code> components for the first time.</p><p>In the next chapter, we will cover these components in more detail, including the different kinds of the renderer, geometry, and material components. We will also add lighting to the mix and make a more advanced scene.</p></div></body></html>