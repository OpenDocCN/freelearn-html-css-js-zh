["```js\n    <script>\n      import Child from './Child.svelte';\n      let message = 'Hello from Parent';\n    </script>\n    <Child message={message} />\n    Child component and passed the message prop to it. The child component, implemented in the following code snippet, then uses this message prop to display text within a <p> element:\n    ```", "```js\n    <script>\n      export let message;\n    </script>\n    <p>{message}</p>\n    ```", "```js\n    <script>\n      import Child from './Child.svelte';\n      import { setContext } from 'svelte';\n      setContext('message', 'Hello from parent');\n    </script>\n    <Child />\n    ```", "```js\n    <script>\n      import { getContext } from 'svelte';\n      const message = getContext('message');\n    </script>\n    <p>{message}</p>\n    ```", "```js\n<!-- filename: Card.svelte -->\n<div class=\"card\">\n  <slot></slot>\n</div>\n```", "```js\n<script>\n  import Card from './Card.svelte';\n</script>\n<Card>\n  <h1>Special headline</h1>\n</Card>\n```", "```js\n<div class=\"card\">\n  <slot>\n    <div>this is the default content</div>\n  </slot>\n</div>\n```", "```js\n<script>\n  import Card from './Card.svelte';\n</script>\n<Card />\n```", "```js\n<!-- filename: Card.svelte -->\n<div class=\"card\">\n  <header>\n    <slot name=\"header\"></slot>\n  </header>\n  <footer>\n    <slot name=\"footer\"></slot>\n  </footer>\n</div>\n```", "```js\n<script>\n  import Card from './Card.svelte';\n</script>\n<Card>\n  <svelte:fragment slot=\"header\">\n    <h1>Special headline</h1>\n  </svelte:fragment>\n  <svelte:fragment slot=\"footer\">\n    Custom footer\n  </svelte:fragment>\n</Card>\n```", "```js\n<!-- filename: Card.svelte -->\n<div class=\"card\">\n  <header>\n    <slot name=\"header\" width={30} height={50}></slot>\n  </header>\n</div>\n```", "```js\n<script>\n  import Card from './Card.svelte';\n</script>\n<Card>\n  <svelte:fragment slot=\"header\" let:width let:height>\n    <h1>Dimension: {width} x {height}</h1>\n  </svelte:fragment>\n</Card>\n```", "```js\n<script>\n  import Input from './Input.svelte';\n  import Checkbox from './Checkbox.svelte';\n  import Select from './Select.svelte';\n  let type = \"input\"; // Could be \"checkbox\" or \"select\"\n</script>\n{#if type === \"input\"}\n  <Input value={value} onChange={onChange} />\n{:else if type === \"checkbox\"}\n  <Checkbox value={value} onChange={onChange} />\n{:else}\n  <Select value={value} onChange={onChange} />\n{/if}\n```", "```js\n<script>\n  import Input from './Input.svelte';\n  import Checkbox from './Checkbox.svelte';\n  import Select from './Select.svelte';\n  let type = \"input\"; // Could be \"checkbox\" or \"select\"\n  let DynamicComponent;\n  if (type === \"input\") {\n    DynamicComponent = Input;\n  } else if (type === \"checkbox\") {\n    DynamicComponent = Checkbox;\n  } else {\n    DynamicComponent = Select;\n  }\n</script>\n<svelte:component\n  this={DynamicComponent}\n  value={value}\n  onChange={onChange}\nDynamicComponent variable is used to hold the type of component that will be rendered. This component type is then passed to the this attribute within the <svelte:component> element. The <svelte:component> element also accepts other props such as value and onChange.\nWith the preceding code, what happens is that `<svelte:component>` renders the designated component stored in the `this` attribute, simultaneously forwarding any props passed to `<svelte:component>` to this dynamically rendered component. For example, if the value of `DynamicComponent` is the `Select` component, then the preceding code is effectively the same as this code:\n\n```", "```js\n\n By using `<svelte:component>`, we simplify the code and make it more maintainable. It’s also easier to extend; adding another form element type would only require an additional condition and assignment.\nNow that we’ve explored the use of `<svelte:component>`, let’s look at `<svelte:element>`, which follows a similar pattern. The following is a sample code snippet that demonstrates the usage of `<svelte:element>`:\n\n```", "```js\n\n In the preceding code snippet, the `type` variable holds the type of HTML element we want to render – in this example, it’s `button`. The `<svelte:element>` tag dynamically creates an HTML element of the type specified by `type`. So, if `type` is `'button'`, this will render as a `<button>` element, containing the text `\"``Click Me\"`.\nThis approach is particularly useful when you want to switch the type of an HTML element, based on some condition, without having to rewrite the entire block of code. All you need to do is change the value of `type`.\nTo summarize, `<svelte:element>` and `<svelte:component>` offer a more efficient and maintainable way to handle dynamic rendering needs. They provide a robust alternative to multiple `{#if}` blocks, making your Svelte applications more flexible and easier to manage.\nSometimes, when designing Svelte components for data visualization, we encounter recursive data structures. In such cases, we need to build components that can recursively render themselves. Let’s delve into how we can accomplish this next.\nCreating recursive components for recursive data\nA **recursive data structure** is a data structure that is defined in terms of itself, meaning that it can be composed of smaller instances of the same type of structure. Recursive data is everywhere – think of a comment section where replies can have their own sub-replies, or a filesystem with nested folders. Creating a component to display them in a frontend application can be challenging.\nImagine we have a variable called `folder`, which is an array containing either files or additional folders. In this example, the `folder` variable could look like this:\n\n```", "```js\n\n Currently, our `folder` variable is two levels deep. To represent this structure in a Svelte component, you might think to use nested `{#``each}` blocks:\n\n```", "```js\n\n In the preceding code snippet, we used an `{#each}` block to iterate over the items in the `folder` variable, rendering either a file or a folder based on `item.type`. If `item.type` is a folder, we use another nested `{#each}` block to go through its contents.\nHowever, here’s the catch – the inner folder could also contain files or additional folders, making it recursive. As a result, we end up with repeated code for the inner and outer `{#each}` blocks. This works fine for a folder structure that’s only two levels deep, but what if it’s more complex? How can we avoid duplicating the same code for each level of nesting?\nSvelte offers an elegant solution to handle such recursive structures with the `<svelte:self>` element. The `<svelte:self>` element allows a component to embed itself within its own markup, thus making it easier to handle recursive data.\nHere’s the updated code using the `<``svelte:self>` element:\n\n```", "```js\n\n In the updated code snippet, we replaced the nested `{#each}` block with `<svelte:self folder={item.children} />`. This effectively re-renders the current component, passing `item.children` as the `folder` prop.\nThe beauty of this is that it eliminates the need to initiate a new `<ul>` element and duplicate `{#each}` blocks for each nesting level. Instead, the component simply reuses itself, making it capable of handling nested structures of any depth.\nWhen comparing this with the previous code snippet, you can immediately see the advantage – it’s much cleaner and avoids repetitive code, making it easier to read and maintain, and it scales naturally to handle any level of nested folders.\nNow that we’ve discussed how to tackle recursive data with `<svelte:self>`, let’s look at a practical example in the following section, where we will create a Svelte-based JSON tree viewer.\nExample – a JSON tree viewer\nIn this section, we will walk you through building a JSON tree viewer component in Svelte. The JSON tree viewer component helps you visualize JSON data in a tree-like format. Along the way, we’ll make use of some of the advanced Svelte features we’ve covered in this chapter, including `<svelte:self>`, `<svelte:component>`, and slots.\nBefore we start, let’s think about what our JSON Tree Viewer should look like and how it should behave. Essentially, a JSON object is made up of key-value pairs, where the values can be either primitives, arrays, or other nested objects. Our goal is to display these key-value pairs in a way that clearly represents the hierarchical structure of the JSON object.\nSo, let’s create a `JsonTree` component for our JSON tree viewer:\n\n```", "```js\n\n In the preceding code snippet, we defined a `JsonTree` component that accepts data as a prop. Inside this component, we utilize Svelte’s `{#each}` block to generate a list of `<li>` elements. Each element displays a key-value pair from the `data` object.\nHowever, these values can vary. They could be primitive types or nested objects. Take the following example:\n\n```", "```js\n\n In the preceding `data` object, the `name` key has a primitive string value, while the value for the `address` key is an object. For nested objects like this, we will need to use our `JsonTree` component recursively to render that nested object. This is where `<svelte:self>` comes into play.\nHere’s the updated code:\n\n```", "```js\n\n In this updated code snippet, we introduced an `{#if}` block that renders differently based on whether the value is a primitive type or a nested object. For nested objects, we recursively render another `JsonTree` component using `<svelte:self>`. This allows us to elegantly handle JSON objects of any depth.\nNow, in our current implementation, we haven’t made distinctions between different types of primitive values. Suppose you’d like to render various primitive types using specialized Svelte components. In that case, you could dynamically switch between different component types using `<svelte:component>`.\nLet’s assume you have three separate Svelte components – `StringValue` for strings, `NumberValue` for numbers, and `JsonValue` for others (such as Booleans, `null`, and `undefined`). Here is how you can update the code to use `<svelte:component>`:\n\n```", "```js\n\n In the updated code snippet, we created a utility function named `getComponent` to determine which component to render, based on the type of the primitive value. We then used `<svelte:component this={getComponent(typeof value)} />` to dynamically load the appropriate component for each primitive type, allowing our `JsonTree` component to switch to different components for different types of data.\nLastly, to make our JSON tree viewer more versatile, we can introduce named slots to customize the appearance of keys and values. By doing so, users can easily tailor the look of these elements according to their needs, while keeping our current design as the default fallback. Let’s update the code to add the two named slots:\n\n```", "```js\n\n In the updated code, we added two named slots – one to customize keys, called `\"obj-key\"`, and another to customize values, called `\"obj-value\"`. These slots receive the current `key` and `value` as slot props, enabling you to tailor their appearance in the parent component.\nFor instance, if you wish to change how keys and values are displayed, here’s how you can write in your parent component:\n\n```", "```js\n\n Here, we use Svelte’s `<svelte:fragment>` special element to target the named slots, `\"obj-key\"` and `\"obj-value\"`, in our `JsonTree` component. The `let:key` and `let:value` syntax allows us to access the current key and value being rendered, respectively.\nIn the `<svelte:fragment>` element, we wrapped the key in an `<em>` tag and the value in a `<u>` tag, offering custom styling for these elements. This customization overrides the default rendering provided by the `JsonTree` component. If you don’t specify any custom content, the component will fall back to its default rendering, offering both robustness and flexibility.\nBy combining `<svelte:self>` for recursion, `<svelte:component>` for dynamic behavior, and slots for customization, we have created a flexible and powerful JSON tree viewer. This not only demonstrates Svelte’s capability to handle complex UI patterns but also serves as a practical example of component composition in Svelte.\nYou can find the complete code for this exercise here: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04/06-exercise-svelte-json-tree](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter04/06-exercise-svelte-json-tree%0D).\nBefore we wrap up this chapter, let us take a moment to discuss a helpful common pattern to organize our components, the Container/Presentational pattern.\nThe Container/Presentational pattern\nAs your application scales in complexity, you may find it beneficial to adopt specific design patterns or guidelines to structure components. One such approach is the **Container/Presentational pattern**, which divides a component into two categories, the Container component and the Presentational component:\n\n*   *Container components* focus on functionality. They handle data fetching, state management, and user interactions. While they usually don’t render **Document Object Model** (**DOM**) elements themselves, they wrap around Presentational components and supply them with data and actions.\n*   *Presentational components* are all about the user interface. They get their data and event-handling functions exclusively through props, making them highly reusable and straightforward to test.\n\nA common scenario where you’ll see this pattern in action is when using a UI component library. In this case, the library’s components serve as the presentational elements, focusing solely on how things look. Meanwhile, the components you create that utilize these library elements act as Container components, managing data and handling interactions such as clicks, typing, and dragging.\nThe Component/Presentational pattern is useful in a few aspects:\n\n*   **Simplicity**: Separating behavior from appearance makes your codebase easier to understand and maintain\n*   **Reusability**: Since Presentational components are agnostic about data sources or user actions, you can reuse them in different parts of your application\n*   **Collaboration**: With this division, designers can work on the Presentational components while developers focus on the Container components, streamlining development\n\nAs you come to appreciate the benefits of the Component/Presentational pattern, there are specific situations where I think you should consider using it, such as the following:\n\n*   **When your application starts to grow**: Managing everything in a single component can become confusing as complexity increases\n*   **When you find yourself repeating the same UI patterns**: Creating reusable Presentational components can save time in the long run\n*   **When your team scales**: As your development team grows, having a standardized way of building components can reduce learning curves and prevent code conflicts\n\nWhile the Container/Presentational pattern offers a structured approach to organizing your components, it’s not always the best fit – especially for smaller applications, where it might be overkill. Hopefully, with the insights provided, you’ll be better equipped to make informed decisions.\nSummary\nIn this chapter, we delved into various strategies for component composition in Svelte, each offering its own set of advantages and applicable scenarios. Mastering these techniques will equip you to build Svelte applications that are not only more dynamic but also easier to maintain and scale.\nWe kicked off by discussing multiple ways to influence a child component. These ranged from controlling props or using Svelte’s context to customizing styles via CSS custom properties, and even dynamically passing content through slots.\nThen, we turned our attention to some of Svelte’s special elements. We explored `<svelte:element>` and `<svelte:component>` to dynamically render various HTML elements and Svelte components. We also learned about `<svelte:self>`, which allows a component to reference itself, thereby facilitating the creation of recursive UI structures. We then applied these newfound skills to build a JSON tree viewer as an illustrative example.\nFinally, we touched upon a popular design pattern – the Container/Presentational pattern. We examined its advantages and considered scenarios where it would be beneficial to employ this approach.\nArmed with these advanced techniques, you are now better prepared to tackle complex challenges in your Svelte projects. As we conclude our four-chapter exploration of writing Svelte components, we’ll shift our focus in the upcoming chapter to another fundamental feature of Svelte – Svelte actions.\n\n```"]