- en: '[CHAPTER 3](toc.xhtml#c03)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Overview of Express.js](toc.xhtml#c03)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Introduction](toc.xhtml#s76a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js is a highly recognized and frequently utilized open-source framework
    of Node.js that facilitates the creation of web applications and REST APIs. It
    is a robust and adaptable framework that is favored by developers seeking to construct
    efficient and expandable web applications.
  prefs: []
  type: TYPE_NORMAL
- en: It is a very popular framework due to its simplicity, flexibility, and scalability.
    Its popularity can be observed by looking at the average downloads per week. According
    to the npm registry, the Express.js package has been downloaded on average over
    27 million times per week.
  prefs: []
  type: TYPE_NORMAL
- en: '[Structure](toc.xhtml#s77a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining Express.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advantages and Limitations of Express.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js Installation and Creating a Basic Application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core Features of Express.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and Performance Best Practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Defining Express.js](toc.xhtml#s78a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, a **framework** is a pre-written code that provides
    a set of generic functionality, tools, and guidelines for building applications.
    It is essentially a structured and standardized way of organizing and developing
    software, which helps to reduce development time and effort by providing pre-existing
    components and patterns that can be reused across multiple projects.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js is one of the most popular open source, fast, and flexible frameworks
    of Node.js. It follows the “*unopinionated*” approach, which means that it does
    not enforce any specific architecture or patterns and allows developers to build
    their applications using their preferred tools and techniques. It provides a set
    of tools and features for building web applications and APIs using Node.js, including
    handling HTTP requests and responses, routing, middleware, templating engines,
    static file serving, and more. It has a large and active community of developers
    contributing to its development and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js is also known for its performance and scalability, with a lightweight
    and efficient core that allows it to handle high-traffic loads. Overall, Express.js
    is a powerful framework of Node.js that has all the required features to develop
    secure and scalable web applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[Advantages of Express.js](toc.xhtml#s79a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Express.js has several advantages over other web application frameworks, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Minimalist**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js has a straightforward design that helps to reduce the learning curve
    for developers who are new to the framework, enabling them to get up and running
    with their projects more quickly and easily.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Flexible**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js is a highly customizable and flexible framework. One such example
    of its flexibility is the middleware system, which allows developers to add custom
    logic to incoming requests or outgoing responses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Scalable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js provides built-in support for asynchronous programming using JavaScript
    promises and `**async**`/`**await**` syntax, which enables developers to write
    scalable code that can handle a large number of concurrent requests. It is well-suited
    for building large, complex applications that can handle high levels of traffic
    and data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Compatibility with Node.js**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js is built specifically to work with Node.js, which means that it is
    highly compatible with Node.js and its related libraries. Express.js is designed
    to leverage the features and capabilities of Node.js, such as its event-driven
    architecture and non-blocking I/O model. It is also able to seamlessly integrate
    with other Node.js libraries and tools.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Collaborative community**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a very large and active community which is a key advantage of it. It
    ensures that the framework is constantly evolving and improving. Moreover, it
    provides valuable support for developers, making it easier for them to troubleshoot
    issues and learn from the experience of others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Express.js not only offers the aforementioned benefits, but also provides numerous
    additional advantages.
  prefs: []
  type: TYPE_NORMAL
- en: '[Limitations of Express.js](toc.xhtml#s80a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like every coin has two sides, Express.js also has its limitations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incompatible with client-side application**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js is primarily focused on server-side web development, so it is not
    used for building complex client-side applications. However, it can be used in
    conjunction with other tools and frameworks to build full-stack applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Lack of built-in features**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express.js is a minimalist framework, which means that it does not come with
    all the built-in features and tools that some other frameworks provide. Developers
    may need to install and configure additional modules or libraries to add certain
    functionalities to their applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Inconsistency**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Express.js is a minimalist framework, it does not enforce any standard
    way to structure an application or organize its code. As a result, developers
    are free to design their structures, which can pose a challenge for new developers
    trying to contribute to any existing project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Express.js has fewer limitations compared to other frameworks and offers more
    benefits, making it an easily approachable framework for developers.
  prefs: []
  type: TYPE_NORMAL
- en: '[Express.js Installation and Creating a Basic Application](toc.xhtml#s81a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To install Express.js, prior make sure you have Node.js installed on your machine,
    then you can perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new project directory and navigate into it using the command prompt
    or terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ mkdir my-express-app`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ cd my-express-app`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initialize a new Node.js project. This will create a `**package**`**.**`**json**`
    file in your project directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ npm init`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install `**Express.js**` and typescript dependency with run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm install express typescript --save`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `--save` option will automatically update your `**package.json**` file with
    the installed package and its version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install development dependency as dev dependency for typescript with express.js
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ npm install @types/express @types/node --save-dev`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a new file called `**app.ts**` in the root directory of your project,
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`import * as express from ''express'';`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import { Request, Response } from ''express'';`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`const app: express.Application = express();`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.get(''/'', (req: Request, res: Response) => {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.send(''Hello World!'');`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.listen(3000, () => {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`console.log(''Server listening on port 3000'');`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Compile the TypeScript code into JavaScript using the `**tsc**` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ tsc app.ts`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the server with the `**node**` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$ node app.js`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/3.1.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Figure 3.1:** Compile and Run Express Application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you should be able to visit `**http://localhost:3000**` in your web browser
    and see the message `"**Hello World!**"` displayed on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.2:** Launch Express Application'
  prefs: []
  type: TYPE_NORMAL
- en: '[Core Features of Express.js](toc.xhtml#s82a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Express.js is equipped with several fundamental features, some of which are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[REST APIs](toc.xhtml#s83a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A RESTful API is a web-based API that follows the principles of Representational
    State Transfer (REST) architectural style. It is a way of designing web services
    that are lightweight, maintainable, and scalable. RESTful APIs use HTTP methods
    to interact with resources that are identified by URIs.
  prefs: []
  type: TYPE_NORMAL
- en: There are certain principles which should be followed while building REST APIs.
    These principles are a set of guidelines for designing an application.
  prefs: []
  type: TYPE_NORMAL
- en: '[REST Principles](toc.xhtml#s84a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a total of six guiding principles. In general, not all of these are
    mandatory to be followed to build applications; however, using these principles
    ensures better performance, efficiency, and scalability. These principles are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Client-Server Architecture**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system should be divided into client and server. The client should communicate
    to the server over the network. Server-side and Client-side responsibilities must
    be independent and to be implemented by respective sides. This allows the evolution
    of both client and server independently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Stateless Design**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a client needs any data from the server it sends a request to the backend
    server. This principle says that each request from client to server must contain
    all of the information that server would need to understand the request. Server
    must not store the state of the session about the client.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Cacheable**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, there are responses which do not change too frequently. Such responses
    can be cached to improve performance. Responses should be defined as cacheable
    so that client can also know if it can reuse the same data or should request again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Uniform Interface**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The uniform interface simplifies the architecture by making it more modular,
    and allows easier development and deployment. There are four constraints which
    define a uniform interface :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Resource Identification**: Resources can be identified through request URIs.
    For example, /projects clearly says that we are requesting the list of projects.
    A URI /projects/23 says that we are requesting a project using unique id 23.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource Manipulation through Representations**: A resource is a conceptual
    entity identified by URI and the representation is the form of the resource when
    it is transferred over the network. The representation can be as JSON, XML, HTML,
    and so on. By sending or receiving these representations, clients manipulate resources.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A project can be represented (in JSON format) as
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"name":"Mobile App",`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"description":"This project is to manage development of Mobile App"`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`}`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Self-descriptive Messages**: The messages being transferred between server
    and client should include enough information to describe how to process the message.
    This helps in decoupling of the client and server. Let us consider a request:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET /projects/23 HTTP/1.1`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Host: example.com`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Accept: application/json`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The above can be a request from client to server. This clearly shows that we
    are making a GET request over HTTP for host example.com and it desires the response
    in JSON format using the Accept header. Let us see a sample response to this:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`HTTP/1.1 200 OK`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Content-Type: application/json`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Content-Length: 122`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"id": 23,`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"name":"Mobile App",`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"description":"This project is to manage development of Mobile App"`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`}`'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The preceding response shows that the status of the request was `**200 OK**`,
    the returned data is in JSON format and the body contains the requested project.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Hypermedia as the Engine of Application State (HATEOAS)**: The principle
    says that the client should interact with a RESTful application entirely through
    the hypermedia provided dynamically by the application servers. The client would
    have only the initial URI of the application. The hyperlinks needed further should
    be inside the response. This allows the dynamic discovery of actions and helps
    to decouple the client from the server. Each communication here would have self-descriptive
    messages.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layered Architecture**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This principle insists that the application architecture should be divided
    into hierarchical layers. Each layer performs specific tasks. Let us consider
    a simple web application. The layers in it can be:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client Layer**: User interacts with this layer, for example, web app or mobile
    app.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**API Gateway Layer**: Entry point, every request goes through this layer.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Layer**: Handles the business logic of processing the user requests.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service Layer**: Contains helper services such as notification service, and
    so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data Access Layer**: Contains logic needed to fetch, store or update data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database Layer**: The layer which communicates with the database to fetch
    or store data.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These layers should give an idea about the principle. This is an example and
    the layers can vary depending on the system being developed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Code on Demand**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an optional principle. This allows the client to extend the client functionality
    by providing the code in response. In this case, the client makes a request and
    server responses with a code which is usually a script which can be run at the
    client side. This principle allows flexibility and on-the-fly customization of
    the client application. However, we must be careful and should consider the security
    aspects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While it is true that REST principles enhance the scalability, performance,
    and maintainability of the APIs, not each principle is mandatory in all contexts.
    The last principle — Code on Demand is optional. However, to achieve the full
    benefits of the REST architecture, it is recommended that these principles should
    be followed as closely as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[Building REST API](toc.xhtml#s85a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js is well-suited for building RESTful APIs, with support for HTTP.
    It allows developers to easily handle HTTP requests and responses. There are different
    types of HTTP methods such as `**GET**`, `**POST**`, `**PUT**`, `**DELETE**`,
    `**PATCH**`, `**HEAD**`.
  prefs: []
  type: TYPE_NORMAL
- en: Let us build a rest api to get a list of users using the GET Method of HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: We have already created a basic-typescript-project in the previous chapter,
    so let us take that as a starting point and install `**express**` in that project.
  prefs: []
  type: TYPE_NORMAL
- en: '`$ npm install express --save`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a REST API `**body-parser**` is a very useful npm package that is used as
    Node.js parsing middleware. It extracts the body portion of the incoming request
    and parses it based on the `**Content-Type**` request header. The parsed body
    data is then made available through the `**req.body**` property. Let us install
    it using the npm package manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ npm install body-parser --save`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, let us install the TypeScript definitions for Express and `**body-parser**`
    as dev dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ npm install -D @types/express @types/body-parser`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let us update the `**main.ts**` file in the root directory of the project
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import express from ''express'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import * as bodyParser from ''body-parser'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { users } from "./users/user";`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { Application } from ''express'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const app: Application = express();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.use(bodyParser.json());`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/api/users'', (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.json(users);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.listen(3000, () => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''Server listening on port 3000'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a `**user.ts**` file in the user directory inside the `**lib**`
    directory and put the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`interface User {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`id: number;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`name: string;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`email: string;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export const users: User[] = [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ id: 1, name: ''John'', email: ''john@example.com'' },`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ id: 2, name: ''Jane'', email: ''jane@example.com'' },`'
  prefs: []
  type: TYPE_NORMAL
- en: '`];`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the server, we need to compile the TypeScript code with `**tsc**` and
    start the server with node:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ tsc`'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ node dist/main.js`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test the API using a tool like Postman/curl or directly open the
    browser with url `http://localhost:3000/api/users`, it gives the following JSON
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[{"id":1,"name":"John","email":"john@example.com"},{"id":2,"name":"Jane","email":"jane@example.com"}]`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.3:** Get API Users'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we created an API endpoint `/api/users` which returned
    us the users list. We also used `**body-parser**` middleware. We will learn about
    middlewares later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Routing](toc.xhtml#s86a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js provides a simple and flexible routing system that allows developers
    to define URL routes for handling incoming HTTP requests. Routing in Express.js
    refers to the mechanism of defining and handling endpoints (URL paths) for web
    applications and APIs.
  prefs: []
  type: TYPE_NORMAL
- en: It is a crucial aspect of any web framework, as it helps to determine how the
    application responds to client requests. In Express.js, routing is accomplished
    using the `**express.Router()**` class, which creates modular, mountable route
    handlers. The router consists of route method, route path, and callback handler.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.METHOD(PATH, HANDLER)`'
  prefs: []
  type: TYPE_NORMAL
- en: '`**app**` : It is an instance of express.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**METHOD**` : It is an HTTP request method, in lowercase.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**PATH**` : It is a path on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**HANDLER**` : It is the function executed when the route is matched.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Route Methods](toc.xhtml#s87a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are most commonly used methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**GET**` : It is used for retrieving data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**POST**` : It is used for creating or adding new data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**PUT**` : It is used to update an existing data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**DELETE**` : It is used to delete data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**PATCH**` : It is used to partially update an existing data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**OPTIONS**` : It is used to retrieve information about available options
    for data.'
  prefs: []
  type: TYPE_NORMAL
- en: '`**HEAD**` : It is similar to the `GET` method but only retrieves the response
    headers without the response body.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `**app.all()**` to handle all HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.all(''/'', (req, res, next) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''all method…'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '`next() // pass control to the next handler`'
  prefs: []
  type: TYPE_NORMAL
- en: '`})`'
  prefs: []
  type: TYPE_NORMAL
- en: '[Route Paths](toc.xhtml#s88a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A path can be string, string pattern, or a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: This route path will match requests to `**/users**` specific string.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/users, (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.send(''users'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '`})`'
  prefs: []
  type: TYPE_NORMAL
- en: This route path will be matched with string patterns such as `**abcd**`, `**abbcd**`,
    `**abbbcd**`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/ab+cd'', (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.send(''ab+cd'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '`})`'
  prefs: []
  type: TYPE_NORMAL
- en: This route path will match blueberries and strawberries, raspberries, but not
    `**blueberriesfruit**`, `**strawberriesfruit**`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(/.*berries$/, (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.send(''/.*berries$/'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '`})`'
  prefs: []
  type: TYPE_NORMAL
- en: These are different ways of defining route paths.
  prefs: []
  type: TYPE_NORMAL
- en: '[Route Parameters](toc.xhtml#s89a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js treats certain characters differently in string-based paths compared
    to their regular expression counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ?, +, *, and () are all subsets of their regular expression counterparts.
    On the other hand, the hyphen (-) and the dot (.) are interpreted literally when
    used in string-based paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/projects/:projectCode'', function(req, res) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var projectCode = req.params.projectCode;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Do something with the project code`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.send(''project code: '' + projectCode);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/users/:user-email'', function(req, res) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var userEmail = req.params[''user-email''];`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Do something with the user email`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.send(''User email: '' + userEmail);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/files/:file_name.pdf'', function(req, res) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`var fileName = req.params[''file_name''];`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Do something with the file name`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.send(''File name: '' + fileName);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, there are three routes with hyphens and dots in their parameters.
    The first route `**/projects/:projectCode**` accepts a project code parameter,
    which can contain hyphens. The second route `**/users/:user-email**` accepts a
    user email parameter, which can contain hyphens. The third route `**/files/:file_name.pdf**`
    accepts a file name parameter, which can contain hyphens and ends with .pdf.
  prefs: []
  type: TYPE_NORMAL
- en: '[Route Handlers](toc.xhtml#s90a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a route is matched in Express.js, it can have one or more handler functions
    associated with it, which are executed. Route handlers are responsible for processing
    requests, accessing data, and returning responses to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/api/users'', (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.json(users);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the route handler function is `**(req, res) => {…}**`, which
    is executed when a `**GET**` request is received with a URL path that matches
    the pattern `**/api/users**`. The `**req**` parameter contains information about
    the incoming request, such as the request headers and parameters, while the `**res**`
    parameter is used to send a response back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: '[Middleware](toc.xhtml#s91a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js supports middleware functions that can modify incoming requests or
    outgoing responses as per the required custom logic. Middleware in Express.js
    refers to a series of functions that are executed in a specific order when a client
    sends a request to a server. These functions have access to the request and response
    objects and can modify them as needed. Middleware functions can be used for a
    variety of purposes such as logging, authentication, error handling, and more.
  prefs: []
  type: TYPE_NORMAL
- en: In Express.js, middleware functions can be added to the application or specific
    routes using the ``**use()**`` method.
  prefs: []
  type: TYPE_NORMAL
- en: Previously we already used body-parser as middleware while building rest api.
    This middleware is for each route as passed in `**app.use()**`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.use(bodyParser.json());`'
  prefs: []
  type: TYPE_NORMAL
- en: There is another **example of middleware in which you do not wish to use it**
    for each route such as user validation on a specific route. They are executed
    in the order in which they are added and can be chained together using the `**next()**`
    function to pass control to the next middleware function in the stack.
  prefs: []
  type: TYPE_NORMAL
- en: '`// Validation middleware`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const validate = (req, res, next) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const { name } = req.body;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (!name) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return res.status(400).send(''Name is required'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`next();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`};`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Route`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.post(''/users'', validate, (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const { name } = req.body;`'
  prefs: []
  type: TYPE_NORMAL
- en: '``res.send(`Hello, ${name}!`);``'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the validate middleware function is defined to check if the
    name parameter is present in the body string. If it is not present, the middleware
    sends a 400 Bad Request response with an error message. If the name parameter
    is present, the middleware calls the `**next()**` function to pass control to
    the next middleware or route handler.
  prefs: []
  type: TYPE_NORMAL
- en: The validate middleware is then used in the ``**/user**`` route handler as the
    second argument to ensure that the name parameter is present before generating
    a user’s response.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.4:** Post API User Bad Request'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Figure 3.5](#fig3_5)* shows the result `"**Hello, Yamini!**"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.5:** Post API User Valid Input Name'
  prefs: []
  type: TYPE_NORMAL
- en: '[Error Handling](toc.xhtml#s92a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Error handling is an important aspect of building robust applications. The
    framework provides a few ways to handle errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Built-in Error Handling](toc.xhtml#s93a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express.js provides a built-in error-handling middleware function that can be
    used to handle errors in the application. This middleware function can be used
    to catch any unhandled errors that occur during the execution of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Express.js, another way to handle errors is by utilizing middleware functions
    with error-first callbacks or functions. Here is an example demonstrating how
    it can be implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import express, { Request, Response, NextFunction } from ''express'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const app = express();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/'', (req: Request, res: Response) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`throw new Error(''Oops! Something went wrong.'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.use((err: Error, req: Request, res: Response, next: NextFunction) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.status(500).send(''Something went wrong!'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.listen(3000, () => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''Server listening on port 3000!'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have defined an Express app with a single route that throws
    an error. We then use the built-in error handling middleware function `**app.use**`
    to catch the error and send a `**500**` status code with a message to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error-handling middleware function takes four arguments: err, req, res,
    and next. The first argument (`**err**`) is the error that was thrown, the second
    argument (`**req**`) is the request object, the third argument (`**res**`) is
    the response object, and the fourth argument (`**next**`) is a function that is
    used to pass control to the next middleware function in the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: If an error is thrown within any middleware or route handler function, Express.js
    will automatically call the error handling middleware function with the thrown
    error object as the first argument.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.6:** Error Handling'
  prefs: []
  type: TYPE_NORMAL
- en: '[Custom Error Handling](toc.xhtml#s94a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers can also create their own custom error-handling middleware to handle
    specific types of errors. This middleware function can be added to the middleware
    stack and used to catch errors that are specific to the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us update the `**main.ts**` file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`import express, { Application, Request, Response, NextFunction } from ''express'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { HttpException, NotFoundException } from ''./utils/errorHandler'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import * as bodyParser from ''body-parser'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`import { users, Users } from "./users/user";`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const app: Application = express();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.use(bodyParser.json());`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/api/users'', (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.json(users);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/users/:id'', (req, res, next) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const userId = req.params.id;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const user = new Users();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const isUserExist = user.getUserById(userId);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (!isUserExist) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '``return next(new NotFoundException(`User with ID ${userId} not found`));``'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.status(200).json(user);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.use((err: HttpException, req: Request, res: Response, next: NextFunction)
    => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const status = err.status || 500;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const message = err.message || ''Internal server error'';`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.status(status).json({ error: message });`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.listen(3000, () => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.log(''Server listening on port 3000!'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `utils` folder and create `**errorHandler.ts**` file into that directory
    the paste the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`export class HttpException extends Error {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`status: number;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`message: string;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor(status: number, message: string) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`super(message);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.status = status;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`this.message = message;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export class NotFoundException extends HttpException {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`constructor(message: string = ''Not Found'') {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`super(404, message);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now update the `**user.ts**` file in users directory with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`interface User {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`id: number;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`name: string;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`email: string;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export const users: User[] = [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ id: 1, name: ''John'', email: ''john@example.com'' },`'
  prefs: []
  type: TYPE_NORMAL
- en: '`{ id: 2, name: ''Jane'', email: ''jane@example.com'' },`'
  prefs: []
  type: TYPE_NORMAL
- en: '`];`'
  prefs: []
  type: TYPE_NORMAL
- en: '`export class Users {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`public getUserById(userId) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`if (users.find(i => i.id == userId)) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return true;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`} else {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`return false;`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, there is a custom `**HttpException**` class that extends the
    Error class and adds a status property. There is also a `**NotFoundException**`
    class that extends the `**HttpException**` class and sets the status to 404 by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: In the route handler for `**/users/:id**`, if the requested user is not found,
    a `**NotFoundException**` is thrown and passed to the next function, which triggers
    the custom error handling middleware.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.7:** User Not Found Exception'
  prefs: []
  type: TYPE_NORMAL
- en: The custom error handling middleware checks if the error is an instance of `**HttpException**`
    and uses the status and message properties to send a JSON response with the appropriate
    HTTP status code. If the error is not an instance of `**HttpException**`, it sends
    a generic 500 error response.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.8:** Sample code in VsCode Editor'
  prefs: []
  type: TYPE_NORMAL
- en: '[Async Error Handling](toc.xhtml#s95a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Express.js, asynchronous errors can be handled using try-catch blocks or
    by returning a rejected Promise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code in `**main.ts**` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Async function that throws an error`'
  prefs: []
  type: TYPE_NORMAL
- en: '`async function asyncFunction(): Promise<void> {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`throw new Error(''Async error'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Async route handler that calls the async function`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/async-error'', async (req: Request, res: Response, next: NextFunction)
    => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`try {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`await asyncFunction();`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.send(''Success'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`} catch (error) {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`next(error);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: '`// Error handling middleware`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.use((err: Error, req: Request, res: Response, next: NextFunction) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`console.error(err.message);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.status(500).send(''Something broke!'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: Now compile and run the code with `**$ tsc**` and then `**$ node dist/main.js**`.
    After that open browser with `**http://localhost:3000/async-error**`it displays
    as Something broke!
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have an async function called `**asyncFunction**` that throws
    an error. We have a route handler that calls this function and catches any errors
    that occur using a try-catch block. If an error occurs, the next function is called
    with the error parameter to pass the error to the error-handling middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The error-handling middleware function takes four parameters: `err`, `req`,
    `res`, and `next`. If an error occurs in any middleware or route handler before
    this function, it will be passed to this middleware function. The middleware function
    logs the error to the console and sends a `**500 Internal Server Error**` response
    to the client.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `**async**` keyword is used before the route handler function
    to indicate that it is an asynchronous function. Also, the `**await**` keyword
    is used before the call to the `**asyncFunction**` to wait for the function to
    complete before proceeding to the next line of code.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.9:** Async Error API'
  prefs: []
  type: TYPE_NORMAL
- en: '*[Figure 3.10](#fig3_10)* shows the terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.10:** Async Error Terminal Output'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to handle errors properly in an Express.js application to ensure
    that the application is robust and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: '[Static File Serving](toc.xhtml#s96a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Express.js, we can serve static files, such as images, CSS, JavaScript files,
    and more, using the `**express.static()**` middleware function, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '`app.use(express.static(''public''));`'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we are serving static files from the public directory.
    The `**express.static()**` middleware function takes one argument, which is the
    name of the directory that contains the static files.
  prefs: []
  type: TYPE_NORMAL
- en: Once the middleware is set up, you can access your static files by specifying
    their URL relative to the public directory. For example, if you have a file called
    `**profilePic.png**` in the `**public/images**` directory, you can access it at
    `**http://localhost:3000/images/profilePic.png**`
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.11:** Static Serving Image File'
  prefs: []
  type: TYPE_NORMAL
- en: '[Templating Engines](toc.xhtml#s97a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Express.js, templating engines are used to generate HTML markup and dynamically
    render views. Templating engines allow you to create templates with placeholders
    for dynamic data that can be replaced with real data when the template is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the popular templating engines supported by Express.js include:'
  prefs: []
  type: TYPE_NORMAL
- en: EJS (Embedded JavaScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pug (formerly Jade)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handlebars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mustache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use a templating engine in an Express.js application, you need to install
    the engine using npm and set it as the default view engine in the app configuration.
    Then you can create views using the syntax and features of the chosen templating
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the terminal and install dependency for `**ejs**` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ npm install ejs --save`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `**ejs**` is installed, we can try the following example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.set(''view engine'', ''ejs'');`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.set(''views'', path.join(__dirname, ''views''));`'
  prefs: []
  type: TYPE_NORMAL
- en: '`app.get(''/ejs'', (req, res) => {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`const data = {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`title: ''My App'',`'
  prefs: []
  type: TYPE_NORMAL
- en: '`message: ''Hello, I am from EJS !!''`'
  prefs: []
  type: TYPE_NORMAL
- en: '`};`'
  prefs: []
  type: TYPE_NORMAL
- en: '`res.render(''index'', data);`'
  prefs: []
  type: TYPE_NORMAL
- en: '`});`'
  prefs: []
  type: TYPE_NORMAL
- en: Create `**index.ejs**` file and paste html code.
  prefs: []
  type: TYPE_NORMAL
- en: '`<!DOCTYPE html>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<html>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<head>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<title><%= title %></title>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`</head>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<body>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`<h1><%= message %></h1>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`</body>`'
  prefs: []
  type: TYPE_NORMAL
- en: '`</html>`'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use the `**<%= %>**` syntax to output the `"**title**"`
    and `"**message**"` variables that were passed to the view in the route handler.
    When the view is rendered, these variables will be replaced with their respective
    values.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler handles the task of generating JavaScript files and
    transferring them to the `**dist**` folder. However, it does not handle the copying
    of other necessary project files like EJS view templates. To address this, you
    can create a build script responsible for copying all additional files to the
    `**dist**` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To automatically copy files from the views folder to the `**dist**` folder after
    compiling your TypeScript code, you can use a build tool like `**copyfiles**`
    or copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the `**copyfiles**` package as a dev dependency with the following
    command executed in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$npm install --save-dev copyfiles`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now update the scripts in `**package.json**` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"scripts": {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"build": "tsc && npm run copy-views",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`"copy-views": "cpy ''views/*'' dist/views/ --recursive"`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then execute script from the terminal with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ npm run build`'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.12:** Build Application'
  prefs: []
  type: TYPE_NORMAL
- en: After running the application, you can open your web browser and navigate to
    `**http://localhost:3000/ejs**`. This will display the HTML output in the browser,
    as shown in the following image.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 3.13:** Browser EJS Template'
  prefs: []
  type: TYPE_NORMAL
- en: '[Security and Performance Best Practices](toc.xhtml#s98a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several security best practices to follow when developing applications
    with Express.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Use secure HTTP protocols**: Always use HTTPS instead of HTTP to ensure secure
    communication between client and server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the latest version**: Keep your Express.js version up to date, and apply
    security patches as soon as they become available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Avoid using deprecated or vulnerable packages**: Use only up-to-date, well-maintained
    packages and avoid deprecated or vulnerable ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Validate user input**: Always validate user input to prevent injection attacks,
    cross-site scripting (XSS) attacks, and other malicious activities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use a Content Security Policy (CSP)**: Implement a Content Security Policy
    (CSP) to protect against XSS attacks by limiting the resources that a page can
    load.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.use((req, res, next) => {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.setHeader(`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''Content-Security-Policy'',`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"default-src ''self''; script-src ''self''` `''unsafe-inline''; img-src ''self''
    data:; font-src ''self'' data:;"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`);`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`next();`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The CSP header is then set in a middleware function that is added to the Express
    app. The CSP policy in this example allows scripts to be loaded from the same
    domain (‘`` `**unsafe-inline**` ``**’). Images and fonts are allowed from the
    same domain as well as from the data: protocol.**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '***   **Implement rate limiting**: Implement rate limiting to prevent brute
    force attacks and other types of attacks that involve repeated requests.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, install the `**express-rate-limit**` package using npm:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$ npm install express-rate-limit`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, require the package and create a new rate limiter object with the desired
    options:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`const rateLimit = require("express-rate-limit");`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`const limiter = rateLimit({`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`windowMs: 15 * 60 * 1000, // 15 minutes`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`max: 100 // limit each IP to 100 requests per windowMs`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, we are creating a rate limiter that limits each IP address
    to 100 requests every 15 minutes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, apply the rate limiter middleware to the desired routes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.use(limiter);`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.get("/", (req, res) => {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.send("Hello World!");`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, each incoming request to the root route (`"`/`"`) will be checked against
    the rate limiter. If the IP address has exceeded the maximum number of requests
    within the specified time window, the middleware will return a 429 `"**Too Many
    Requests**"` error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Use helmet**: Use the helmet middleware to add additional security headers
    to HTTP responses, such as the X-XSS-Protection, X-Content-Type-Options, and X-Frame-Options
    headers.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import helmet from "helmet";`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`// Use Helmet middleware`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.use(helmet());`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`// Add routes to the app`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.get("/", (req, res) => {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.send("Hello, world!");`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, the helmet middleware is imported from the helmet package and
    used in the application using `**app.use(helmet())**`. This will automatically
    add security headers to HTTP responses, such as setting the X-Content-Type-Options
    header to `**nosniff**` to prevent browsers from interpreting response content
    as a different MIME type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that this is just a basic example, and additional configuration may be
    necessary depending on the specific security needs of your application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Use secure cookies**: When using cookies, set the secure and `**httpOnly**`
    flags to prevent cross-site scripting (XSS) and cross-site request forgery (CSRF)
    attacks.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Example:**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`import cookieParser from ''cookie-parser'';`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.use(cookieParser(''secret''));`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`app.get(''/set-cookie'', (req, res) => {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.cookie(''myCookie'', ''someValue'', {`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`httpOnly: true,`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sameSite: ''strict'',`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`secure: true`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`res.send(''Cookie set successfully!'');`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`});`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, the cookie-parser middleware is used to parse cookies in incoming
    requests. The secret argument is used to sign and encrypt the cookies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `**/set-cookie**` route sets a new cookie with the `**res.cookie()**` method.
    The httpOnly option prevents the cookie from being accessed by JavaScript code,
    making it more difficult for an attacker to steal the cookie using a cross-site
    scripting (XSS) attack. The sameSite option limits the scope of the cookie to
    the same site that set it, reducing the risk of cross-site request forgery (CSRF)
    attacks. The secure option ensures that the cookie is only sent over HTTPS, protecting
    it from interception by network attackers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By following these best practices for secure cookie handling, you can significantly
    improve the security of your Express.js application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Implement a secure deployment process**: Implement a secure deployment process
    that includes secure configurations, code review, and testing to prevent security
    vulnerabilities from being introduced into production.*   **Use a linter and security
    scanner**: Use a linter and security scanner to detect and fix potential security
    issues in your code. The best example is `**EsLint**`.**'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**By following these security best practices, you can help ensure that your
    Express.js applications are secure and protected against common security threats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some performance best practices to follow when developing applications
    with Express.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Avoid the use of synchronous functions**: It is recommended to use asynchronous
    code because synchronous code in production slows down the application, so try
    to avoid unnecessary synchronous functions and use `**async**`/`**await**` with
    promises.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exception handling**: Use always try catch to handle the exception at the
    code level so it does not break the application on run time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduce middleware usage**: Use only the required middleware and avoid excessive
    usage. Middleware can be resource-intensive and may slow down the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: Implement caching for frequently requested data such as static
    files or API responses. By caching this data, you can reduce the number of requests
    that the server has to process and significantly improve the response times of
    your application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use cluster**: Use Node.js Cluster mode to utilize all available CPU cores
    and distribute the load evenly across all cores which improves the performance
    of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto restart application**: Make sure that if anytime application crashes
    then it automatically restarts so use a process manager or packages such as PM2
    or Forever for that.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By following these recommended practices, you can enhance the performance of
    your Express.js application, resulting in a faster and more efficient user experience.
  prefs: []
  type: TYPE_NORMAL
- en: '[Conclusion](toc.xhtml#s99a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Express.js, a popular and powerful web application
    framework for Node.js. We learned about its offerings, upsides, and limitations.
    While it has a few limitations, the benefits of Express.js, such as its active
    community, extensive documentation, and support for REST API development, make
    it an excellent choice for web development projects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start building a project management system application.
    We will take this as a big exercise to learn the concepts of TypeScript and Express.Js.
  prefs: []
  type: TYPE_NORMAL
- en: '[Multiple Choice Questions](toc.xhtml#s100a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Express.js primarily used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Database management
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Front-end development
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Building web applications and APIs
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Machine learning
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What advantages and drawbacks are associated with the Express.js framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantages encompass its lightweight and minimalist design, while drawbacks
    involve the absence of built-in features for complex applications.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantages comprise a wide range of built-in features for complex applications,
    while drawbacks pertain to suboptimal performance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantages include automated scaling for high-traffic applications, while drawbacks
    involve a challenging learning curve.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Advantages entail effortless integration with databases, while drawbacks concern
    the absence of routing support.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the Express.js Router object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To define routes for multiple applications
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To create middleware functions
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To handle errors in the application
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To define routes for a specific part of the application
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What role does middleware play in an Express.js application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To host static files
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To establish routes
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To manage incoming requests and responses
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To facilitate authentication
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you handle routing parameters in Express.js?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `req.routeParams` object
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: By defining separate route handlers for each parameter
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing them directly from the URL
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `req.params` object
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `next()` function do in Express.js middleware?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ends the request-response cycle
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Passes control to the next middleware function
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sends a response to the client
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Logs information to the console
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you handle errors in an Express.js application using middleware?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `catchError` middleware function
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrap the code in `try-catch` blocks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the error event on the app object
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Define an error-handling middleware with four parameters
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following Express.js middleware is commonly used for parsing JSON
    requests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`express-static`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`body-parser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cookie-parser`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`express-session`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the primary purpose of the `"cookie-parser"` middleware in an Express.js
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To generate random cookies for user sessions.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To parse and handle incoming HTTP requests.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To parse cookies attached to incoming HTTP requests.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To set secure HTTP headers for cookie handling.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which middleware is used for handling Cross-Origin Resource Sharing (CORS) in
    Express.js applications?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`express-cors`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cors-express`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cross-origin`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`cors`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Answers](toc.xhtml#s101a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: b
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: c
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: d
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Further Readings](toc.xhtml#s102a)'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://expressjs.com](https://expressjs.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blog.dreamfactory.com/rest-apis-an-overview-of-basic-principles/](https://blog.dreamfactory.com/rest-apis-an-overview-of-basic-principles/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://restfulapi.net/](https://restfulapi.net/)**'
  prefs: []
  type: TYPE_NORMAL
