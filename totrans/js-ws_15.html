<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-552"><a id="_idTextAnchor611"/>15. Asynchronous Tasks</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to implement asynchronous programming and its different techniques; explore the pitfalls of callback hell and the pyramid of doom; illustrate the use of promises to execute code upon operation completion; use the new <code>async</code>/<code>await</code> syntax to make asynchronous code look and feel almost sequential; and apply the Fetch API to make remote service calls.</p>
			<h1 id="_idParaDest-553"><a id="_idTextAnchor612"/>Introduction</h1>
			<p>Asynchronous tasks allow the execution of the main thread of a program to proceed even while waiting for data, an event, or the result of another process, and achieve snappier UIs as well as allowing some types of multitasking.</p>
			<p>Unlike other languages that can have many concurrent threads executing, JavaScript typically runs in a single thread. So far, you have already learned in detail about how JavaScript's single-threaded model is enabled by the <strong class="bold">event loop</strong> and the associated <strong class="bold">event queue</strong>. Under the hood, the browser or the Node.js runtime has background threads that listen for events or issue service calls, and when a new event is captured or a service call responds, it is pushed into the event queue. JavaScript continually scans the event queue and triggers the handlers for those events when available. Event handlers are most commonly callback methods, but there are other types as well, such as <em class="italic">Promises</em>, which you will learn about in this chapter.</p>
			<p>Some threads take longer than others. In a restaurant, preparing a steak takes more time than fulfilling an order for a glass of wine. However, since there is no dependency between these items, they can each be performed concurrently. But even if the wine was ordered minutes after the steak, there is a good chance the wine will be brought over before the steak, even by the same worker. This is essentially the idea of asynchronous processing. (To take the analogy a bit further, when each item is ready to be served to the customer, they will be placed in the worker's <em class="italic">queue</em> by the kitchen staff. The worker constantly checks their queue for more things to bring to the restaurant's patrons.)</p>
			<p>The early versions of JavaScript mostly used callbacks to achieve asynchrony, but the negative consequences of creating callback hell soon became apparent, as you will see. Then, in ECMAScript 2015, an alternative was introduced, called Promises, which helped a lot but still left a bit to be desired. More recently, new keywords and syntax known as <code>async</code>/<code>await</code> were added in ECMAScript 2017, which simplified asynchronous code even further and made it resemble regular sequential code in many respects. You will explore each of these in the sections that follow.</p>
			<p>In this chapter, you will also revisit <em class="italic">TheSportsAPI</em> that was introduced in <em class="italic">Chapter 10</em>, <em class="italic">Accessing External Resources</em>, which you used to query and retrieve sports-related data regarding teams, game scores, players, and upcoming events. It may be a good idea to reread that chapter to refresh your memory, as we will be expanding upon the material there.</p>
			<h1 id="_idParaDest-554"><a id="_idTextAnchor613"/>Callbacks</h1>
			<p>As you explored in <em class="italic">Chapter 10</em>, <em class="italic">Accessing External Resources</em>, callbacks are the oldest and simplest means of executing asynchronous functionality in JavaScript. A callback is a specified function to be called once the result of an operation is ready. You saw this with the jQuery <code>$.ajax()</code> and <code>$.getJSON()</code> methods, where a function is called once a successful service call response is available; for example:</p>
			<pre>$.getJSON('https:/www.somesite.com/someservice',
      function(data) {
      // this function is a callback and is called once
             // the response to the service call is received
      }
    );</pre>
			<p>Another area where callbacks are heavily used is for event handlers. Events can be considered asynchronous, as they can happen at unpredictable times and in any order. The callbacks to handle events are typically registered with the browser runtime and added to the event queue when calling <code>addEventListener()</code>. </p>
			<h2 id="_idParaDest-555"><a id="_idTextAnchor614"/>setTimeout()</h2>
			<p>The <code>setTimeout()</code> function is the traditional way of scheduling code to run asynchronously at some point in the future. It is most commonly called with a parameter that specifies the number of milliseconds to wait before execution.</p>
			<h2 id="_idParaDest-556"><a id="_idTextAnchor615"/>Exercise 15.01: Asynchronous Execution with setTimeout()</h2>
			<p>This exercise demonstrates how execution flows when using <code>setTimeout()</code> if that parameter is specified as <code>0</code> or just omitted:</p>
			<ol>
				<li>In the Google Chrome browser, go into <code>Developer Tools</code> (the menu with three dots at the upper-right corner of the screen) | <code>More Tools</code> | <code>Developer Tools</code>, or just hit the <em class="italic">F12</em> key).</li>
				<li>In the <code>Console</code> tab, paste the code from the following file, but do not hit <em class="italic">Enter</em> yet. You can find the code in the file <code>exercise1.js</code>.<pre>console.log("start");
setTimeout(function() {
        console.log("in setTimeout");
    }, 0);
console.log("at end of code");</pre><p>Consider the code you pasted. You might think the function in the <code>setTimeout()</code> block would execute right away since it was specified to execute after zero milliseconds. But, in fact, this is not what happens. So, let's see the output.</p></li>
				<li>Press the <em class="italic">Enter</em> key in the console to execute the code. The output will be the following:<pre>start
at end of code
in setTimeout</pre><p>Due to the way asynchronous processing works, the callback in <code>setTimeout()</code> is placed in the event queue to schedule it for later processing, while the execution of the main code proceeds. The callback will not get executed until the main code completes.</p><p>The overuse of <code>setTimeout()</code> can also lead to bad coding practices, as we will see in the next section.</p></li>
			</ol>
			<h2 id="_idParaDest-557"><a id="_idTextAnchor616"/>Callback Hell and the Pyramid of Doom</h2>
			<p>Callbacks are perhaps the simplest and most straightforward approach to handling asynchronous requests, but if you are not careful, your code can get messy and unmanageable very quickly. This is especially true if you need to make a series of nested asynchronous service calls that depend on data returned from the previous call.</p>
			<p>Recall <em class="italic">TheSportsDB</em> from <em class="italic">Chapter 10</em>, <em class="italic">Accessing External Resources</em>. Let's say you have a requirement to obtain a list of honors granted to the players of your favorite team.</p>
			<p>In most cases, you would not know the identifiers for the player <code>id</code> parameter required by the API in advance. Consequently, you would need to first use an API service call to look at the team ID up, in order to obtain the player list. But there's a further caveat, it turns out that in order to do that, you now need to also know the identifier for the league of which the team is a part. Since you don't know the league ID, you need to find the league ID itself using yet another service.</p>
			<p>For such requirements, you may end up with code that looks like the following code snippet (don't worry if you don't understand the code yet, as it will be covered in depth later). You will find the code of file <code>pyramid_of_doom_example.html</code> on GitHub in the following location: </p>
			<pre>// Pyramid of DOOM!!!
$.getJSON(ALL_LEAGUES_URL, function(leagueData) {
    const leagueId = findLeagueId(leagueData, LEAGUE_NAME);
    $.getJSON(ALL_TEAMS_URL, {id: leagueId}, function(teamData) {
        const teamId = findTeamId(teamData, TEAM_NAME);
        $.getJSON(ALL_PLAYERS_URL, {id: teamId}, function(playerData) {
            playerData.player.forEach(player =&gt; {
                $.getJSON(PLAYER_HONORS_URL, {id: player.idPlayer},
                    function(honorData) {
                        printHonors(honorData);
                    }
                );
            });
        });
    });
});</pre>
			<p>In other words, here is a case where, in order to get one piece of data in one call, there are dependencies on the results of other calls. Each callback uses the result of the previous call to invoke further calls.</p>
			<p>Notice all the nested blocks that resulted from using callbacks. It starts with one function, which then includes another function, and then multiple levels of more functions within functions, and this results in a series of unruly end-bracket and end-parenthesis characters. The shape of this code resembles a pyramid rotated on its side, and therefore has the slang term of the <em class="italic">pyramid of doom</em>:</p>
			<p>In this section, you revisited how asynchronous logic is traditionally implemented in JavaScript, and how using callbacks can get you into trouble and result in hard-to-manage spaghetti code. You also familiarized yourself with <em class="italic">TheSportsDB</em> API and implemented some new functionality that makes requests of it.</p>
			<p>There are several alternatives to using callbacks for asynchronous processing that have been developed in recent years, including promises and the new <code>async</code>/<code>await</code> syntax. The next section will explore promises, which are a major improvement over callbacks, as you will see.</p>
			<h1 id="_idParaDest-558"><a id="_idTextAnchor617"/>Promises and the Fetch API</h1>
			<p>In a nutshell, a promise is an object that wraps asynchronous logic and provides methods to access the results or errors once operation completes. It is a proxy for the result value until it is known, and allows you to associate handler functions rather than using callbacks. It is a <em class="italic">promise</em> to supply the value once it is known and available.</p>
			<p>To get a good feel for how promises are used, you will first be introduced to the Fetch API, which uses promises heavily. Then, we will backtrack and dive into a detailed description of the promises themselves.</p>
			<p>Fetch is another API that enables you to make network requests and REST service calls, similar to jQuery's AJAX methods or the native <code>XMLHttpRequest</code>. The main difference is that the Fetch API uses promises, which has a cleaner and more concise syntax that helps you avoid callback hell.</p>
			<p>Typical Fetch API usage for a JSON request looks something like this:</p>
			<pre>fetch(someURL)
      .then(response =&gt;response.json())
      .then(jsonData =&gt;parseSomeDataFromResponse(jsonData))
      .then(someData =&gt;doSomethingWithDataObtained(someData))
      .catch(error =&gt; console.log(error));</pre>
			<p>The <code>fetch()</code> call invokes the service call in the URL. Once a valid response is available, the function in the first <code>then()</code> block is executed. It receives the response as an argument, and, in this case, runs the <code>json()</code> method on it to convert the text into an object. The result of this method call is then made available to subsequent <code>then()</code> methods down the chain. Errors can also be handled by <code>catch()</code> methods.</p>
			<h2 id="_idParaDest-559"><a id="_idTextAnchor618"/>Using the Fetch API to Get Player Honors</h2>
			<p>In this section, we will discard the jQuery callback methods used earlier to obtain player honor data and instead take an approach that utilizes promises (this gets us out of the callback Pyramid of Doom).</p>
			<p>The Fetch API is relatively low-level and does not offer as many freebies as jQuery's <code>$.ajax()</code> and <code>$.getJSON()</code> functions, so we'll create a wrapper function called <code>myFetch()</code> to make the usage a bit nicer for our use case; specifically:</p>
			<ul>
				<li>Fetch only takes a full URL and does not encode parameters for you. The <code>myFetch()</code> function will include an optional second parameter for params as key-value pairs, which, if specified, will encode the parameter values and append the resulting query string to the URL.</li>
				<li>Fetch does not automatically parse the JSON response, so you'll include this in <code>myFetch()</code>.</li>
				<li>Fetch does not consider an HTTP status code as an error condition unless the code is 500 or above. But for our purposes, any response other than <code>200 (OK)</code> should be considered an error. You'll add a check for this.<p class="callout-heading">Note</p><p class="callout">This wrapper is not appropriate for all use cases. You should tailor it to your particular needs.</p></li>
			</ul>
			<h2 id="_idParaDest-560"><a id="_idTextAnchor619"/>Exercise 15.02: Refactoring the Honors List to Use the Fetch API</h2>
			<p>In this exercise, we will refactor the code to obtain a list of honors granted to the players of your favorite team. We will refactor it to use the Fetch API:</p>
			<ol>
				<li value="1">First, we will create a file that contains common pieces of code that will be used throughout this chapter. In a text editor or IDE, enter the following initial chunk of code. You can also find the code of file <code>players.js</code> on GitHub in the file location: <a href="https://packt.live/2KUdBY4">https://packt.live/2KUdBY4</a><pre>// hard coded data for purposes of illustration
const LEAGUE_NAME = "English Premier League";
const TEAM_NAME = "Arsenal";
const BASE_URL = "https://www.thesportsdb.com/api/v1/json/1/";
const ALL_LEAGUES_URL = BASE_URL + "all_leagues.php";
const ALL_TEAMS_URL = BASE_URL + "lookup_all_teams.php";
const ALL_PLAYERS_URL = BASE_URL + "lookup_all_players.php";
const PLAYER_HONORS_URL = BASE_URL + "lookuphonors.php";</pre><p>This code has the URLs and data values for remote services we will be calling of <em class="italic">TheSportsDB</em> API.</p></li>
				<li>Enter the following <code>myFetch()</code> method:<pre>Function myFetch(url, params) {
    if (params) {
        url += "?" + encodeParams(params);
    }
    return fetch(url)
        .then(response =&gt; {
            if (!response.ok) {
                throw new Error(response.status);
            }
            Return response.json()
        }
    );
}</pre><p>This is the implementation of the wrapper function to <code>fetch()</code> that was mentioned earlier.  First, if one or more or more parameter key-value pairs are specified, they are encoded into a query string and appended to the URL.  After this, the <code>fetch()</code> function is called, and <code>then()</code> is executed when the response is available. If the HTTP status code is anything other than <code>200 (OK)</code>, an error is thrown. This causes it to be caught by the <code>catch()</code> function (if defined in the promise call chain). Finally, if all is okay, it calls <code>response.json()</code> to parse the JSON response into an object, which is returned as another promise to be passed along and resolved in the subsequent <code>then()</code> function.</p></li>
				<li>Use the following helper function, which encodes the key-value pair parameters to be appended to the query string of the URL:<pre>Function encodeParams(params) {
    return Object.keys(params)
        .map(k =&gt; encodeURIComponent(k) + '=' +
                  encodeURIComponent(params[k]))
        .join('&amp;');
}</pre></li>
				<li>Now, write the <code>findLeagueId()</code> function:<pre>Function findLeagueId(leagueData, leagueName) {
    const league = leagueData.leagues.find(l =&gt; l.strLeague === leagueName);
    return league ? league.idLeague : null;
}</pre><p>This code takes the result of the <code>ALL_LEAGUES_URL</code> service call and utilizes <code>find()</code> to locate the result that matches the desired league name. Once found, it returns the ID for that league (or <code>null</code> if there was no match found).</p></li>
				<li>Write the <code>findTeamId()</code> function as follows:<pre>Function findTeamId(teamData, teamName) {
    const team = teamData.teams.find(t =&gt; t.strTeam === teamName);
    return team ? team.idTeam : null;
} </pre><p>Similar to the last function, this code takes the result of the <code>ALL_TEAMS_URL</code> service call and uses <code>find()</code> to locate the desired team.</p></li>
				<li>Enter the <code>printHonors()</code> function:<pre>Function printHonors(honorData) {
    if (honorData.honors != null) {
        var playerLI = document.createElement("li");
        document.getElementById("honorsList").append(playerLI);
        var playerName =
            document.createTextNode(honorData.honors[0].strPlayer);
        playerLI.appendChild(playerName);
        var honorsUL= document.createElement("ul");
        playerLI.appendChild(honorsUL);
        honorData.honors.forEach(honor =&gt; {
            var honorLI = document.createElement("li");
            honorsUL.appendChild(honorLI);
            var honorText = document.createTextNode(
                `${honor.strHonour} - ${honor.strSeason}`);
            honorLI.appendChild(honorText);
        });
    }
}</pre><p>This function takes the result of the <code>PLAYER_HONORS_URL</code> service call and creates a list of player honors comprising the <code>&lt;ul&gt;</code> and <code>&lt;li&gt;</code> HTML tags.</p></li>
				<li>We have now completed the common functions. Save this file with the filename <code>players.js</code>.</li>
				<li>Create a new file in your editor or IDE. Enter the initial chunk of code from the following file. You can find the code on GitHub in the file location: <a href="https://packt.live/2XRGLMO">https://packt.live/2XRGLMO</a><pre>&lt;html&gt;
&lt;head&gt;
    &lt;meta charset="utf-8"/&gt;
    &lt;script src="img/players.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
Arsenal Player Honors:
&lt;ul id="honorsList"&gt;&lt;/ul&gt;
&lt;script&gt;</pre></li>
				<li>Enter the following, which starts to replace the jQuery <code>$.getJSON</code> code with calls to the Fetch API:<pre>myFetch(ALL_LEAGUES_URL)
  .then(leagueData =&gt; {
      const leagueId = findLeagueId(leagueData, LEAGUE_NAME);
      return myFetch(ALL_TEAMS_URL, {id: leagueId});
  })</pre><p>Processing begins with calling the <code>myFetch()</code> wrapper function to invoke the service call that retrieves a list of all leagues. Once the response is available, the function specified in the <code>then()</code> method is invoked.</p><p class="callout-heading">Note</p><p class="callout">There is no need to check for HTTP errors and you can assume the response was valid since error checking was already done in the implementation of the <code>myFetch()</code> function call outlined above. You also do not need to parse the JSON to an object.</p><p>The <code>findLeagueId()</code> function is then called to find the ID of the league you are interested in, which is needed for the next service call to get the teams in the league. Once found, <code>myFetch()</code> is then called again. The promise returned by the <code>myFetch()</code> function call is then returned, to be passed along for processing by the following <code>then()</code> block.</p></li>
				<li>Enter the next <code>then()</code> clause to obtain the team ID:<pre>  .then(teamData =&gt; {
      const teamId = findTeamId(teamData, TEAM_NAME);
      return myFetch(ALL_PLAYERS_URL, {id: teamId});
  })</pre><p>In a similar fashion, once the response to the second service call is available, the function in the <code>then()</code> block is invoked. The response is searched to find the team ID needed for the next call, and <code>myFetch()</code> is called again to get all the players on the team.</p></li>
				<li>Enter the next <code>then()</code> block to acquire the list of players on the team, which is needed to then query the honors of each player in turn:<pre>    .then(playerData =&gt; {</pre><p>The browser (and JavaScript runtime) is more than capable of handling the invocation of multiple service calls simultaneously.</p><p class="callout-heading">Note</p><p class="callout">A naive approach would be to invoke all the service calls in a serial or synchronous fashion one after another, but doing this would cause the browser (or JavaScript runtime) to lock up until all the service calls are done since JavaScript has a single-threaded model.</p></li>
				<li>The <code>map()</code> function is called on the <code>playerData.player</code> list, which results in the list being iterated and a <code>myFetch()</code> call being invoked on each player on the list, and, hence, a number of new REST calls to <em class="italic">TheSportsDB</em> API. The resulting promises from each service call are collected in the <code>honorRequests</code> variable:<pre>      const honorReqests = playerData.player.map(player =&gt;
          myFetch(PLAYER_HONORS_URL, {id: player.idPlayer}));</pre></li>
				<li>The <code>Promise.all()</code> method waits for all the service calls to complete before the associated promises are returned to be processed in the next <code>then()</code> block. Once available, the promises are returned as an array in the order the service calls were invoked. This array is iterated upon via <code>forEach()</code> to call <code>printHonors()</code> for each response:<pre>      return Promise.all(honorReqests);
  })
  .then(honorResponses =&gt; honorResponses.forEach(printHonors))</pre></li>
				<li>Finally, there is a <code>catch()</code> method in case errors occur during the processing of the promise:<pre>.catch(error =&gt; console.log(error));</pre><p>This simply logs the error to the console (in a real application, you should consider somehow indicating to the user that an error occurred, such as by showing an error message in the UI).</p></li>
				<li>Closeout the file with the following:<pre>&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></li>
			</ol>
			<p>The code from the exercise has resulted in the browser such as the following:</p>
			<div><div><img alt="Figure 15.1: Sample output of player honors&#13;&#10;" src="img/C14377_15_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">F<a id="_idTextAnchor620"/>igure 15.1: Sample output of player honors</p>
			<p>In this exercise, we refactored the code to use the Fetch API. This was processed differently. <em class="italic">TheSportsDB</em> API only offers a service call to retrieve the honors for one player at a time. Consequently, to get the honors of all players on the team, you need to invoke many service calls, one for each player on the team. Here's where asynchrony comes in handy. Thus, the browser (and JavaScript runtime) is more than capable of handling the invocation of multiple service calls simultaneously. We will improve this in the next section.</p>
			<h2 id="_idParaDest-561"><a id="_idTextAnchor621"/>An Improvement for Better Performance</h2>
			<p>The preceding code works, but there is still another improvement worth making. As a consequence of using <code>Promise.all()</code>, no results will display until all the requests to get player honors have returned. This produces a pause longer than necessary when loading the list.</p>
			<p>You can improve perceived performance if you begin to display the list entries the moment the honor data of the first player is available, then the honors of the second player, and so on. You can do this even if the data for the rest of the players have not arrived yet, as long as you maintain the correct player order while displaying the list of entries.</p>
			<p>To accomplish this, the basic approach is to create a promise to which a sequence of events are attached. You would take the promises returned by <code>myFetch()</code> for the respective players and attach them one by one to the sequence, as in the following pseudo-code:</p>
			<pre>promise
  .then(createPromiseForPlayer1())
  .then(printDataForPlayer1())     // print once data for player 1 is loaded
  .then(createPromiseForPlayer2()) // etc
  .then(printDataForPlayer2())
  .then(createPromiseForPlayer3())
  .then(printDataForPlayer3())
  .then(createPromiseForPlayer4())
  .then(printDataForPlayer4())</pre>
			<p>Our actual implementation will use <code>forEach()</code> to loop over the players to add them to the sequence. The promise for the sequence itself is created with <code>Promise.resolve()</code>, which results in a promise that resolves right away with no return value. But that's fine since this promise just serves as a placeholder to chain other items with a series of <code>then()</code> calls.</p>
			<p>The earlier code that looked like this:</p>
			<pre> .then(playerData =&gt; {
      const honorReqests = playerData.player.map(player =&gt;
          myFetch(PLAYER_HONORS_URL, {id: player.idPlayer}));
      return Promise.all(honorReqests);
  })
  .then(honorResponses =&gt; honorResponses.forEach(printHonors))
  .catch(error =&gt; console.log(error));</pre>
			<p>Is now replaced with the following. You can find the code on GitHub in the file <code>other/fetch_example_improved.html</code></p>
			<pre>  .then(playerData =&gt; {
      const sequence = Promise.resolve();
 
      playerData.player.forEach(player =&gt;
          sequence
            .then(() =&gt; myFetch(PLAYER_HONORS_URL, {id: player.idPlayer}))
            .then(printHonors));
      return sequence;
  })
  .catch(error =&gt; console.log(error));</pre>
			<p>The resulting sequence will end up with a chain of <code>then()</code> clauses to fetch and print the honor data for each player, in the manner explained in the preceding pseudo-code.</p>
			<p>For those more inclined to functional-style code, here is an alternate implementation. I'll let you decide which one of the two is more straightforward and clear.</p>
			<pre>  .then(playerData =&gt;playerData.player.reduce((sequence, player) =&gt;
          sequence
            .then(() =&gt;myFetch(PLAYER_HONORS_URL, {id: player.idPlayer}))
            .then(printHonors)
    , Promise.resolve())
  )</pre>
			<h2 id="_idParaDest-562"><a id="_idTextAnchor622"/>Tidying Up Fetch Code</h2>
			<p>The preceding code presented to process promises with the <code>then()</code> and <code>catch()</code> methods executes correctly but is admittedly rather verbose and unwieldy. Could we do better? Let's try to make each <code>then()</code> and <code>catch()</code> into one-liners by refactoring the processing of each block into its own method.</p>
			<p>The following code replaces the promise code that starts with <code>myFetch()</code> contained above. You can find the code on GitHub in the file <code>other/fetch_tidied.html</code></p>
			<pre>myFetch(ALL_LEAGUES_URL)
  .then(leagueData =&gt;getTeamsInLeague(leagueData, LEAGUE_NAME))
  .then(teamData =&gt;getPlayersOnTeam(teamData, TEAM_NAME))
  .then(playerData =&gt;getPlayerHonors(playerData))
  .catch(console.log);</pre>
			<p>Note how much more clean the code now reads, and you can more clearly see the progression of what the code is doing just from how the functions are named (that is, first get all leagues, then the correct league, then the right team, and so on).</p>
			<p>The supporting functions you need to add are as follows. These basically have the code that was formerly in each corresponding <code>then()</code> block, which is restructured into their own functions:</p>
			<pre>function getTeamsInLeague(leagueData, leagueName) {
    const leagueId = findLeagueId(leagueData, leagueName);
    return myFetch(ALL_TEAMS_URL, {id: leagueId});
}
Function getPlayersOnTeam(teamData, teamName) {
    const teamId = findTeamId(teamData, teamName);
    return myFetch(ALL_PLAYERS_URL, {id: teamId});
}
function getPlayerHonors(playerData) {
    const sequence = Promise.resolve();
    playerData.player.forEach(player =&gt;
        sequence
          .then(() =&gt; myFetch(PLAYER_HONORS_URL, {id: player.idPlayer}))
          .then(printHonors));
    return sequence;
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Stay tuned for the activity at the end of the chapter, where this code will be cleaned up and simplified even further using other advanced techniques such as currying.</p>
			<h2 id="_idParaDest-563"><a id="_idTextAnchor623"/>Some Fetch API Usage Details</h2>
			<p>This section briefly summarizes some details of the Fetch API, which was introduced earlier.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some of the settings are noteworthy, but their full details are not within the scope of this chapter. These settings will be indicated since they might be important for you if your use case requires them.</p>
			<p>The full method signature for the <code>fetch()</code> method is the following:</p>
			<pre>fetchResponsePromise = fetch(resource, init);</pre>
			<p>The <code>init</code> parameter allows you to assign certain custom settings to the request. Some of the available options include:</p>
			<ul>
				<li><code>method</code>: The request method, for example, <code>GET</code> and <code>POST</code>.</li>
				<li><code>headers</code>: Any headers that should be sent along with your request, contained within a <code>Headers</code> object (as shown in the following code snippet).</li>
				<li><code>body</code>: Anything, such as a <code>string</code>, <code>Blob</code>, or <code>BufferSource</code>, that you want to add to your request. Typically used for <code>POST</code> requests.</li>
				<li><code>credentials</code>: If the resource you are accessing requires credentials for authentication/authorization, you would specify this setting. Possible values are <code>omit</code>, <code>same-origin</code>, and <code>include</code> (the full details of <code>credentials</code> are not within the scope of this chapter).</li>
				<li><code>cache</code>: The cache mode to be used for the request. Valid values are <code>default</code>, <code>no-cache</code>, <code>no-store</code>, <code>reload</code>, <code>force-cache</code>, and <code>only-if-cached</code> (the full details of caching are not within the scope of this chapter).<p>An example usage for a <code>POST</code> request is as follows:</p><pre>const url = "http://mysite.com/myservice";
const data = {param1: 1234};
let responsePromise = fetch(url, {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
    },
    body: JSON.stringify(data)
})
.then(response =&gt; response.json());</pre><p>The <code>fetch()</code> method returns a promise that resolves to a <code>response</code> object that represents details pertaining to the response returned from the request. The following are the most important properties of the <code>response </code>object; all the properties are read-only:</p></li>
				<li><code>Response.headers</code>: Contains the headers associated with the response as an object with key-value pairs. The <code>headers</code> object contains methods to access them, such as using <code>Headers.get()</code> to retrieve the value for a given key, or <code>Headers.forEach()</code> to iterate over the key/value entries and call a function for each; for example:<pre>var headerVal = response.get("Content-Type");
 <a id="_idTextAnchor624"/>     // application/json
response.headers.forEach((val, key) =&gt; { 
    console.log(key, val); 
});</pre><p class="callout-heading">Note</p><p class="callout">For cross-domain requests, there are restrictions on what headers are visible.</p></li>
				<li><code>Response.ok</code>: A <code>Boolean</code> indicating whether the response was successful. A response is considered successful if the status code is in the range of <code>200-299</code>.</li>
				<li><code>Response.status</code>: The status code of the response, such as <code>404</code> to indicate a <code>Not Found</code> error.</li>
				<li><code>Response.statusText</code>: The status message text that corresponds to the status code, such as <code>OK</code> for <code>200</code>.</li>
			</ul>
			<p>In this section, you were introduced to promises and how they are used in the Fetch API. You saw how to retrieve remote data and how to handle errors.</p>
			<p>Some developers feel that Fetch is a bit low-level and prefer other alternatives for remote requests. One popular library is the Axios library. As an example, where they feel Fetch is not ideal, Axios automatically transforms JSON responses to objects, whereas the transformation must be done explicitly in Fetch. There are also differences as to what statuses are considered errors to be handled in the <code>catch()</code> blocks (as Fetch only considers status codes of <code>500</code> or above to be errors, but for many use cases, any status code that is not <code>200</code> should be an error condition).</p>
			<p>In most cases, there is no need to introduce another dependency into our code. The shortcomings mentioned can be overcome by creating simple wrappers around Fetch specific for your use cases, such as how you implemented the <code>myFetch()</code> wrapper function. Accessing the API though the wrapper offers most of the same functionality Axios would provide, however, you have more control.</p>
			<p>In the next section, you will explore promises in detail.</p>
			<h1 id="_idParaDest-564"><a id="_idTextAnchor625"/>Some Details Concerning Promises</h1>
			<p>You will now dig into the details of what promises are and how they are used in general, not necessarily in the context of service calls.</p>
			<p>The constructor of a promise looks like this:</p>
			<pre>new Promise(function(resolve, reject) {
});</pre>
			<p>You would pass in an executor function that takes two arguments: <code>resolve</code> and (optionally) <code>reject</code>. When the promise is instantiated, this function is executed immediately. Your implementation of the executor function would typically initiate some asynchronous operation. Once the return value is available, it should then call the passed-in <code>resolve</code> function or <code>reject</code> if there is an error or other invalid condition. If an error is thrown in the executor function, it also causes the promise to be rejected (even if <code>reject</code> is not called explicitly).</p>
			<p>Put into pseudo-code, this is similar to the following:</p>
			<pre>const promise = new Promise((resolve, reject) =&gt; {
    // do something asynchronous, which eventually calls either:
    //   resolve(someValue);  // fulfilled
    // or
  //   reject("failure reason");  // rejected
});</pre>
			<p>A promise can be in one of three possible states: <strong class="bold">fulfilled</strong>, <strong class="bold">rejected</strong>, or <strong class="bold">pending</strong> (not yet fulfilled or rejected). A promise is said to be settled once it is no longer in the pending state (either fulfilled or rejected).</p>
			<p>As a simple example, consider a promise whose purpose is to introduce a deliberate 3-second delay to your processing. You could implement this using <code>setTimeout()</code> as follows:</p>
			<pre>const timeoutPromise = new Promise((resolve, reject) =&gt; { 
    setTimeout(() =&gt; {
        // call resolve() to signal that async operation is complete
        resolve("Called after three seconds!");
    }, 3000);
});
timeoutPromise.then(console.log);</pre>
			<p>This would result in the message <code>Called after three seconds</code> printing to the console. Note that <code>reject()</code> is not explicitly called in this instance (and the <code>reject</code> parameter can actually even be omitted if you wish).</p>
			<p>Now for some details concerning what happens depending on the return value of the executor function. If the function:</p>
			<ul>
				<li><code>then</code> gets resolved with the returned value as its value.</li>
				<li><code>then</code> gets resolved with an <code>undefined</code> value.</li>
				<li><code>then</code> gets rejected with the thrown error as its value.</li>
			</ul>
			<h2 id="_idParaDest-565"><a id="_idTextAnchor626"/>Exercise 15.03: Creating a Utility Function to Delay Execution</h2>
			<p>In this exercise, you will produce a utility function for the creation of a promise to add a delay after another promise completes before the execution proceeds. This can be used if you want to do an async operation such as a service call, but do not want to process the result right away. This function will then be tested by making a service call and printing the result after a delay:</p>
			<ol>
				<li value="1">In the Google Chrome browser, go into <code>Developer Tools</code> (the menu with three dots at the upper-right corner of the screen) | <code>More Tools</code> | <code>Developer Tools</code>, or just hit the <em class="italic">F12</em> key).</li>
				<li>In the <code>Console</code> tab, paste in the following and hit <em class="italic">Enter</em>: You can find the code on GitHub in the file location: <a href="https://packt.live/2XM98vE">https://packt.live/2XM98vE</a><pre>function addDelay(ms, promise) {
    return promise.then(returnVal =&gt;
        new Promise(resolve =&gt;
            setTimeout(() =&gt; resolve(returnVal), ms)
        )
    );
}</pre><p>This is our first attempt at a solution for this simple case, and the implementation resembles the preceding <code>timeoutPromise</code> code.</p></li>
				<li>You will test it by calling the service in <em class="italic">TheSportsDB</em> that gets the next event for a league and print the result to the console (the league ID is hardcoded in the URL for the purposes of this test). Paste the following code into the console and hit <em class="italic">Enter</em>. <pre>const BASE_URL = "https://www.thesportsdb.com/api/v1/json/1/";
constnextEventUrl = BASE_URL + "eventsnextleague.php?id=4328";
addDelay(3000, fetch(nextEventUrl))
  .then(response =&gt;response.json())
  .then(nextEvents =&gt; console.log(nextEvents.events[0].strEvent));</pre><p>The preceding code results in the message <code>Bournemouth vs Norwich</code> in the console after 3 seconds, though your event will likely be different.</p><p class="callout-heading">Note</p><p class="callout">You could have used the more robust <code>myFetch()</code> wrapper from the previous sections rather than <code>fetch()</code> as well.</p></li>
			</ol>
			<div><div><img alt="Figure 15.2: Screenshot of the result&#13;&#10;" src="img/C14377_15_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.2: Screenshot of the result</p>
			<p>In this exercise, we learned how to add a delay to processing using the <code>addDelay() </code>function. This can be used if you want to do an <code>async</code> operation such as a service call, but do not want to process the result right away. In the next section, we will refine this function further.</p>
			<h2 id="_idParaDest-566"><a id="_idTextAnchor627"/>Further Refinements to addDelay()</h2>
			<p>Now, by way of a bonus, let's see if you can think of different use cases for the <code>addDelay()</code> utility function presented in the preceding exercise, and how you can specify different parameter options to support these use cases.</p>
			<p>The code in the preceding exercise works fine, but what if you wanted to make it more seamless and simply introduce a delay instruction as one of the <code>then()</code> clauses? For example:</p>
			<pre>fetch(nextEventUrl)
  .then(addDelay(1000))
  .then(response =&gt;response.json())
  .then(nextEvents =&gt; console.log(nextEvents.events[1].strEvent));</pre>
			<p>This form is a bit cleaner and easier to see the flow (that is, fetch the response, add a delay of 1 second, and then process).</p>
			<p>In order to support this, you now have two ways in which the parameters can be specified:</p>
			<ul>
				<li>If two parameters are present, this is a simple case and a promise is returned that completes when the delay is over.</li>
				<li>If only one parameter is present, there was no promise passed in at all. Here, rather than returning a promise, you will return a function that takes the promise as a parameter, with the expectation that the <code>then()</code> invocation will supply the promise when invoking the function. This function then makes a recursive call to the same <code>addDelay()</code> function with two parameters.</li>
			</ul>
			<p>Our code now becomes the following:</p>
			<pre>function addDelay(ms, promise) {
    if (promise === undefined) {
        // In this case, only one param was specified.  Since you don't have
        // the promise yet, return a function with the promise as a param and
        // call addDelay() recursively with two params
        return promise =&gt;addDelay(ms, promise);
    }
    // if you reached this far, there were two parameters
    return promise.then(returnVal =&gt;
        new Promise(resolve =&gt;
setTimeout(() =&gt; resolve(returnVal), ms)
        )
    );
}</pre>
			<p>There is one other use case you should consider that would make the utility function even more versatile. Let's say you don't start out with a promise at all and just want to return a value after a delay.</p>
			<p>You can support this by calling <code>Promise.resolve()</code> with the value to convert it to a promise, which essentially treats it as an immediately fulfilled promise for that value. In the case that the value is already a promise, this call would have no effect.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Calling <code>Promise.resolve()</code> on promise parameters is mentioned as a best practice anyway in the promise specification guide.</p>
			<p>In general, when an argument is expected to be a promise, you should also allow thenables and non-promise values by resolving the argument to a promise before using it. You should never do type detection on the incoming value, overload between promises and other values, or put promises in a union type.</p>
			<p>The final code looks like the following. You can find the code on GitHub in the file <code>other/addDelay.js</code></p>
			<pre>function addDelay(ms, promise) {
    if (promise === undefined) {</pre>
			<p>In this case, only one parameter was specified. Since you don't have the promise yet, return a function with the promise as a parameter and call <code>addDelay()</code> recursively with two parameters:</p>
			<pre>        return promise =&gt;addDelay(ms, promise);
    }</pre>
			<p>If you reached this far, there were two parameters:</p>
			<pre>    return Promise.resolve(promise).then(returnVal =&gt;
        new Promise(resolve =&gt;
setTimeout(() =&gt; resolve(returnVal), ms)
        )
    );
}</pre>
			<p>And here's the code to test the three scenarios:</p>
			<pre>const BASE_URL = "https://www.thesportsdb.com/api/v1/json/1/";
const nextEventUrl = BASE_URL + "eventsnextleague.php?id=4328";</pre>
			<p>Use case one is where two parameters are specified, so it executes a promise after a delay:</p>
			<pre>let p1 = addDelay(3000, fetch(nextEventUrl))
  .then(response =&gt; response.json())
  .then(nextEvents =&gt; console.log("Use 1: " + nextEvents.events[0].strEvent));</pre>
			<p>Use case two is where only one parameter is specified, so it returns a function that takes the promise as a parameter with the expectation that the <code>then()</code> invocation will supply the promise when invoking the function:</p>
			<pre>let p2 = fetch(nextEventUrl)
  .then(addDelay(1000))
  .then(response =&gt;response.json())
  .then(nextEvents =&gt; console.log("Use 2: " + nextEvents.events[1].strEvent));</pre>
			<p>Use case three is where we just want to return a value after a delay:</p>
			<pre>let p3 = addDelay(2000, "This is a passed in value")
  .then(result =&gt; console.log("Use 3: " + result));</pre>
			<p>The output <code>All done!</code> should be written as follows:</p>
			<pre>Promise.all([p1, p2, p3])
  .then(() =&gt; console.log("All done!"));</pre>
			<p>The order of the output from the preceding code would be as follows:</p>
			<pre>    Use 2    (after 1 second)
    Use 3    (after 2 seconds)
    Use 1    (after 3 seconds)</pre>
			<p>The expected output will be as follows:</p>
			<div><div><img alt="Figure 15.3: Screenshot of output&#13;&#10;" src="img/C14377_15_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.3: Screenshot of output</p>
			<p>Remember, this is not a sequential code, even though it reads that way. It is important to wrap your head around this when working with asynchronous logic:</p>
			<ul>
				<li>When the code that sets up <code>Use 1</code> executes, it schedules the function to be called back after three seconds. But the main thread of execution continues immediately to set up <code>Use 2</code> and does not wait for 3 seconds to complete.</li>
				<li><code>Use 2</code> is then scheduled for 1 second in the future and will end up being triggered way before <code>Use 1</code>, so it is output first. Before this even happens, though, once again, the main thread of execution continues immediately to <code>Use 3</code>.</li>
				<li><code>Use 3</code> is then scheduled for 2 seconds in the future. This is the second one to trigger and produce output, as <code>Use 1</code> won't trigger until 3 seconds have passed.</li>
				<li>Finally, <code>Use 1</code> triggers and outputs when the third second is reached:</li>
			</ul>
			<div><div><img alt="Figure 15.4: Use cases shown in a diagram&#13;&#10;&#13;&#10;" src="img/C14377_15_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.4: Use cases shown in a diagram</p>
			<p>In this section, you learned the details of how promises are created and used. Promises have become an important part of JavaScript and many libraries and APIs use them. Promises have also become a basis for extending the language further and supporting them directly with new keywords, as you will soon see.</p>
			<p>The next section will explore <code>async/await</code>, which expands the use of promises with a new syntax.</p>
			<h1 id="_idParaDest-567"><a id="_idTextAnchor628"/>Async/Await</h1>
			<p>New additions to recent versions of JavaScript (since ES2017-ES8) make working with asynchronous logic easier, more transparent, and result in your code looking almost as if it were synchronous. This is the <code>async/await</code> syntax, which is one of the most exciting and useful additions to the language in recent years. We'll just dive right in and get a feel for how the <code>async</code> and <code>await</code> keywords are used by way of an example.</p>
			<p>We will now present the changes you would make to refactor the promise code as you left it in the <em class="italic">Further Refinements to addDelay()</em> section to use <code>async/await</code> instead. Firstly, recall the main processing code that looked like this:</p>
			<pre>myFetch(ALL_LEAGUES_URL)
  .then(leagueData =&gt; getTeamsInLeague(leagueData, LEAGUE_NAME))
  .then(teamData =&gt; getPlayersOnTeam(teamData, TEAM_NAME))
  .then(playerData =&gt; getPlayerHonors(playerData))
  .catch(console.log)</pre>
			<p>When refactored to use the <code>await</code> syntax, it will look like the following. You can find the code on GitHub in the file <code>other/async_await.html</code></p>
			<pre>    try {
        let leagueData = await myFetch(ALL_LEAGUES_URL);
        let teamData = await getTeamsInLeague(leagueData, LEAGUE_NAME);
        let playerData = await getPlayersOnTeam(teamData, TEAM_NAME);
        await getPlayerHonors(playerData);
    } catch (err) {
        console.log("caught error: " + err);
    }</pre>
			<p>The <code>await</code> keyword indicates that the function that follows returns a promise, and signals to the browser or JavaScript runtime to wait until the promise resolves and returns a result.</p>
			<p>Using <code>await</code> is really just syntactic sugar as an alternative to calling <code>promise.then()</code>, and the result is the same as the value that would be passed as a parameter if <code>promise.then()</code> were called. But using <code>await</code> allows you to capture the result in a variable and looks as if you were writing synchronous code.</p>
			<p>Also, notice how error handling is done using a typical <code>try...catch</code> block rather than a <code>catch()</code> function. This is another way in which <code>await</code> enables asynchronous code to be more seamless.</p>
			<p>Another method we will refactor is <code>myFetch()</code>. Previously, it looked like this:</p>
			<pre>function myFetch(url, params) {
    if (params) {
        url += "?" + encodeParams(params);
    }
    return fetch(url)
        .then(response =&gt; {
            if (!response.ok) {
                throw new Error(response.status);
            }
            return response.json()
        }
    );
}</pre>
			<p>Refactored, it will now look like this:</p>
			<pre>async function myFetch(url, params) {
    if (params) {
        url += "?" + encodeParams(params);
    } 
    let response = await fetch(url);
    if (!response.ok) {
        throw new Error(response.status);
    }
    return response.json()
}</pre>
			<p>The <code>async</code> keyword before the function definition indicates that the function always returns a promise. Even if the actual value the function returns is not a promise, JavaScript will take care of wrapping that value in a promise automatically. In this case, the return value is the object resulting from the <code>response.json()</code> call, but what actually gets returned is a promise that wraps this. (The <code>await</code> keyword on the caller end would typically be used to unwrap the value again, but there are use cases where there is a need to work with the promise directly as well.)</p>
			<p>Also notice how the <code>fetch()</code> function call now has an <code>await</code> keyword in front of it, rather than processing it utilizing the typical promise API with <code>then()</code>.</p>
			<p>There is another function you can refactor as well from a previous section: <code>getPlayerHonors()</code>. This is what it looked like before:</p>
			<pre>function getPlayerHonors(playerData) {
   const sequence = Promise.resolve();
    playerData.player.forEach(player =&gt;
        sequence
          .then(() =&gt; myFetch(PLAYER_HONORS_URL, {id: player.idPlayer}))
          .then(printHonors));
    return sequence;
}</pre>
			<p>Remember that the purpose of this code is to make a REST service call to get player honor data for multiple players. Refactoring the code to use <code>async/await</code>, you can simplify it a bit and remove the sequence. Here's the new code:</p>
			<pre>async function getPlayerHonors(playerData) {
    const playerPromises = playerData.player.map(async player =&gt;
        myFetch(PLAYER_HONORS_URL, {id: player.idPlayer}));
    for (constplayerPromise of playerPromises) {
        printHonors(await playerPromise);
    }
}</pre>
			<p>The <code>array.map()</code> function affects an iteration of all the players and calls <code>myFetch()</code> for each to get the honor data, resulting in an array of promises. Notice that you used the <code>async</code> keyword on the left of the arrow function. This is perfectly valid and just signals to <code>array.map()</code> that the function returns a promise. During processing, the execution of <code>array.map()</code> will not wait for the first function to complete before calling the next one. This makes the technique of utilizing <code>array.map()</code> with <code>async</code> well suited for launching concurrent requests.</p>
			<p>Afterward, there is a second iteration using a standard <code>for...loop</code>, this time, of the promises produced earlier. The <code>await</code> keyword when calling <code>printHonors</code> would result in the execution waiting until the promise resolves before printing the available result. Also, since you are in a loop, you ensure the output is printed in the correct order.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There is another important caveat to be aware of when using the <code>await</code> keyword: it only works if it is used within a function that is marked with the <code>async</code> keyword in front of it. Attempting to use it in a regular function or in top-level code will result in a syntax error. (For this reason, in the code that follows, notice that you will place the main processing code in an anonymous <code>async</code> function.)</p>
			<h2 id="_idParaDest-568"><a id="_idTextAnchor629"/>Asynchronous Generators and Iterators</h2>
			<p>There is another implementation technique for the preceding <code>getPlayerHonors()</code> function to consider using it. This makes use of generator functions, which were described in <em class="italic">Chapter 5</em>, <em class="italic">Beyond the Fundamentals</em>. Generators, in general, are a recent and rather complex addition to the JavaScript language, and iterators are even newer, so not all browsers and runtime environments support them yet. We will therefore not spend a lot of time explaining them. But we just want to touch on them and explain very briefly how generators and iterators could be used with <code>async</code>.</p>
			<p>Here's the implementation. You can fnd the code on GitHub in the file <code>other/async_generator_impl.html</code></p>
			<pre>async function* getPlayerHonorsGenerator(playerData) {
 
    const playerPromises = playerData.player.map(async player =&gt;
        myFetch(PLAYER_HONORS_URL, {id: player.idPlayer}));
 
    for (const playerPromise of playerPromises) {
        yield playerPromise;
    }
}
async function getPlayerHonors(playerData) {
    for await(const player of getPlayerHonorsGenerator(playerData)) {
        printHonors(player);
    }
}</pre>
			<p>The first <code>getPlayerHonorsGenerator()</code> function should look mostly familiar, as it is similar to the previous implementation, but with some important differences. The asterisk (<code>*</code>) that follows the <code>function</code> keyword indicates that it is a generator function, which means it returns multiple values via subsequent calls.</p>
			<p>Notice the <code>yield</code> keyword in the loop. When <code>yield</code> is reached, execution passes back to the caller (which is actually the second function). When the generator function is called again, the execution picks up from where it left off in the middle of the loop and returns the next value. Once the loop ends, all the values have been returned, and the generator signals that it is done.</p>
			<p>The second function calls the generator function using the <code>for-await...of</code> iterator syntax. The <code>await</code> keyword right after <code>for</code> makes it an <code>async</code> iterator. While performing the iteration, the execution will wait for each promise returned by the generator (via <code>yield</code>) to resolve in turn before executing the body of the loop.</p>
			<p>Generators are a complex topic. However, by adopting this technique, you are able to access the results of multiple asynchronous calls in a clean looping syntax.</p>
			<h2 id="_idParaDest-569"><a id="_idTextAnchor630"/>Activity 15.01: Refactoring Promise Code to await/async Syntax</h2>
			<p>Over the course of this chapter, you have explored how to take synchronous code and refactor it to use callbacks, promises, and <code>async/await</code> syntax. This activity will tie up some loose ends and challenge you to make some aspects of the code even better, partially by using the skills you learned in previous chapters.</p>
			<p>The steps for completion are as follows:</p>
			<ol>
				<li value="1">Fi<a id="_idTextAnchor631"/>rstly, recall the following code from <em class="italic">Exercise 15.03</em>, <em class="italic">Creating a Utility Function to Delay Execution</em> of this chapter, which uses promises to test three different uses of our <code>addDelay</code> function.</li>
				<li>Rewrite it to use the <code>async/await</code> syntax.</li>
				<li>For the purposes of this activity, you are not permitted to use <code>Promise.all()</code> (even though, in normal programming, it would be a good way to wait for the completion of multiple promises).<p class="callout-heading">Hint</p><p class="callout">Be careful where you place your <code>await</code> keywords, as the three cases do not resolve in order.</p></li>
			</ol>
			<p>The expected output is:</p>
			<div><div><img alt="Figure 15.5: Sample output of player honors&#13;&#10;" src="img/C14377_15_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 15.5: Sample output of player honors</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 763.</p>
			<p>Before we move on to the next activity, we will review briefly what currying is. Currying is taking a function with multiple arguments and breaking it down into one or more additional functions that take just one argument and eventually resolve to a value. The initial function call does not take all the arguments but returns a function whose input is the remaining arguments and whose output is the intended result of all the arguments.</p>
			<h2 id="_idParaDest-570"><a id="_idTextAnchor632"/>Activity 15.02: Further Simplifying Promise Code to Remove Function Parameters</h2>
			<p>Shifting back to promises, we concluded the <code>async/await</code> section by tidying up the promise code to make the <code>then()</code> clauses one-liners. Here's the code again to refresh your memory:</p>
			<pre>myFetch(ALL_LEAGUES_URL)
  .then(leagueData =&gt;getTeamsInLeague(leagueData, LEAGUE_NAME))
  .then(teamData =&gt;getPlayersOnTeam(teamData, TEAM_NAME))
  .then(playerData =&gt;getPlayerHonors(playerData))
  .catch(console.log)</pre>
			<p>This is pretty good, but could you do even better?</p>
			<p>Now, we need to think of a way to simplify the code and remove the function parameters entirely, so it would look like this:</p>
			<pre>myFetch(ALL_LEAGUES_URL)
  .then(getTeamsInLeague(LEAGUE_NAME))
  .then(getPlayersOnTeam(TEAM_NAME))
  .then(getPlayerHonors)
  .catch(console.log)</pre>
			<p class="callout-heading">Hint</p>
			<p class="callout">Think about how you might defer the processing of the first parameter of <code>getTeamsInLeague()</code> and <code>getPlayersOnTeam()</code>. Refactor those functions to return another function that finally processes this parameter instead using currying techniques, which you learned about in <em class="italic">Chapter 14</em>, <em class="italic">Understanding Functional Programming</em>.</p>
			<p>The original code is repeated here for your convenience (the <code>getPlayerHonors()</code> function already takes only one parameter and, therefore, has no need to be further simplified for this purpose):</p>
			<pre>function getTeamsInLeague(leagueData, leagueName) {
constleagueId = findLeagueId(leagueData, leagueName);
    return myFetch(ALL_TEAMS_URL, {id: leagueId});
}
function getPlayersOnTeam(teamData, teamName) {
constteamId = findTeamId(teamData, teamName);
    return myFetch(ALL_PLAYERS_URL, {id: teamId});
}</pre>
			<p>The steps for completion are as follows:</p>
			<ol>
				<li value="1">In technique #1, refactor <code>getTeamsInLeague</code> so that it now only takes one parameter, <code>(leagueName)</code>, rather than two parameters that are actually needed to determine the full result <code>(leagueData, leagueName)</code>. The other parameter is deferred till later.</li>
				<li>In technique #1, instead of returning the promise from <code>myFetch</code> directly, you return another curried function that takes <code>leagueData</code> as its parameter. It is only a partially applied function at this point.</li>
				<li>Technique #2 is really the same idea but uses a function variable and multiple levels of arrow functions rather than a regular function.</li>
				<li>Finally, when <code>getTeamsInLeague(LEAGUE_NAME)</code> is invoked in the <code>then()</code> clause, the function returned above would be fully applied, with the resolved value from the previous promise passed in as the implied <code>leagueData</code> parameter.</li>
				<li>The process when calling <code>getTeamsInLeague(LEAGUE_NAME)</code> is incomplete at that point and returns another function to complete it. So, call a partially applied function.<p>The expected output of the activity is the same as in <em class="italic">Exercise 15.02</em>, <em class="italic">Refactoring the Honors List to Use the Fetch API</em>, which gives a sample output of player honors.</p><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found on page 765.</p></li>
			</ol>
			<h1 id="_idParaDest-571"><a id="_idTextAnchor633"/>Summary</h1>
			<p>Like promises, <code>async/await</code> has become very important in JavaScript. You saw how this syntax helps your code appear almost like a synchronous code and can make your code clearer with regard to your desired intent. It even enables error handling in a more standard way with <code>try/catch</code>.</p>
			<p>But this is sometimes deceptive and can get you into trouble if you are not careful. It is important to understand how an asynchronous code differs from sequential code, in particular, how asynchronous code is triggered by event loops and does not block the main execution thread. The same is true with promises themselves, but with <code>async/await</code> looking so similar to synchronous code, it could be easy to forget this fact.</p>
			<p>That said, <code>async/await</code> is still very powerful and worth using. We have reached the end of this book. By now, you have gained a comprehensive understanding of the foundations and basics of JavaScript. You have also fully understood JavaScript syntax and structures for the web and beyond. Now, you are ready to build out intellectually challenging development problems to apply in everyday work.</p>
		</div>
	</body></html>