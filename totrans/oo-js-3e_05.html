<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. ES6 Iterators and Generators</h1></div></div></div><p>So far, we have discussed language constructs of JavaScript without looking at any specific language version. In this chapter, however, we will primarily focus on a few language features introduced in ES6. These features have a big impact on how you write JavaScript code. Not only do they improve the language significantly, they also offer several functional programming constructs unavailable to JavaScript programmers thus far.</p><p>In this chapter, we will take a look at newly introduced iterators and generators in ES6. With that knowledge, we will proceed to take a detailed look at the enhanced Collections constructs.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>For...of loop</h1></div></div></div><p>
<code class="literal">For...of</code> loops are introduced in ES6 along with the iterable and iterator constructs. This new loop constructs replaces both the <code class="literal">for...in</code> and <code class="literal">for...each</code> loop constructs of ES5. As the <code class="literal">for...of</code> loop supports the iteration protocol, it can be used on built-in objects such as arrays, strings, maps, sets, and so on, and custom objects that are iterables. Consider the following piece of code as an example:</p><pre class="programlisting">    const iter = ['a', 'b']; &#13;
    for (const i of iter) { &#13;
      console.log(i); &#13;
    } &#13;
    "a" &#13;
    "b" &#13;
</pre><p>The <code class="literal">for...of</code> loop works with iterables and built-ins like arrays are iterables. If you notice, we are using <code class="literal">const</code> instead of <code class="literal">var</code> when we define the loop variable. This is a good practice because when you use <code class="literal">const</code>, a fresh variable is created with a new binding and storage space. You should use <code class="literal">const</code> over a <code class="literal">var</code> declaration with the <code class="literal">for...of</code> loop when you don't intend to modify the value of the loop variable inside the block.</p><p>Other collections support <code class="literal">for...of</code> loop too. For example, as a string is a sequence of Unicode characters, <code class="literal">for...of</code> loop works just fine:</p><pre class="programlisting">    for (let c of "String"){ &#13;
      console.log(c); &#13;
    } &#13;
    //"s" "t" "r" "i" "n" "g" &#13;
</pre><p>The main difference between the <code class="literal">for...in</code> and <code class="literal">for...of</code> loop is that the <code class="literal">for...in</code> loop iterates through all enumerable properties of an object. <code class="literal">For...of</code> loop has a specific purpose, and that is to follow the iteration behavior based on how the object defines the iterable protocol.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Iterators and iterables</h1></div></div></div><p>ES6 introduces a new mechanism of iterating over data. Traversing a list of data and doing something with it is a very common operation. ES6 enhances the iteration constructs. There are two primary concepts involved with this change-iterators and iterables.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Iterators</h2></div></div></div><p>A JavaScript iterator is an object that exposes the <code class="literal">next()</code> method. This method returns the next item from the collection in the form of an object that has two properties-<code class="literal">done</code> and <code class="literal">value</code>. In the following example, we will return an iterator from an array by exposing the <code class="literal">next()</code> method:</p><pre class="programlisting">    //Take an array and return an iterator &#13;
    function iter(array){ &#13;
      var nextId= 0; &#13;
      return { &#13;
        next: function() { &#13;
          if(nextId &lt; array.length) { &#13;
            return {value: array[nextId++], done: false}; &#13;
          } else { &#13;
            return {done: true}; &#13;
          } &#13;
        } &#13;
      } &#13;
    } &#13;
    var it = iter(['Hello', 'Iterators']); &#13;
    console.log(it.next().value); // 'Hello' &#13;
    console.log(it.next().value); // 'Iterators' &#13;
    console.log(it.next().done);  // true &#13;
</pre><p>In the preceding example, we are returning <code class="literal">value</code> and <code class="literal">done</code> till we have elements in the array. When we exhaust elements in the array to return, we will return <code class="literal">done</code> as <code class="literal">true</code>, indicating that the iteration has no more values. Elements from an iterator are accessed using the <code class="literal">next()</code> method repeatedly.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Iterables</h2></div></div></div><p>An iterable is an object that defines its iteration behavior or internal iteration. Such objects can be used in the <code class="literal">for...of</code> loops introduced in ES6. Built-in types such as arrays and strings define default iteration behavior. For an object to be iterable, it must implement the <code class="literal">@@iterator</code> method, meaning the object must have a property with <code class="literal">'Symbol.iterator'</code> as key.</p><p>An object becomes iterable if it implements a method whose key is <code class="literal">'Symbol.iterator'</code>. This method must return an iterator via the <code class="literal">next()</code> method. Let's take a look at the following example to clarify this:</p><pre class="programlisting">    //An iterable object &#13;
    //1. Has a method with key has 'Symbol.iterator' &#13;
    //2. This method returns an iterator via method 'next' &#13;
    let iter = { &#13;
      0: 'Hello', &#13;
      1: 'World of ', &#13;
      2: 'Iterators', &#13;
      length: 3, &#13;
      [Symbol.iterator]() { &#13;
        let index = 0; &#13;
        return { &#13;
          next: () =&gt; { &#13;
            let value = this[index]; &#13;
            let done = index &gt;= this.length; &#13;
            index++; &#13;
            return { value, done }; &#13;
          } &#13;
        }; &#13;
      } &#13;
    }; &#13;
    for (let i of iter) { &#13;
      console.log(i);  &#13;
    } &#13;
    "Hello" &#13;
    "World of " &#13;
    "Iterators" &#13;
</pre><p>Let's break this example down into smaller pieces. We are creating an iterable object. We will create an <code class="literal">iter</code> object using object literal syntax that we are already familiar with. One special aspect of this object is a <code class="literal">[Symbol.iterator]</code> method. This method definition uses a combination of computed properties and ES6 shorthand method definition syntax, which we already discussed in the last chapter. As this object contains a <code class="literal">[Symbol.iterator]</code> method, this object is iterable, or it follows an iterable protocol. This method also returns the iterator object that defines the iteration behavior via exposing the <code class="literal">next()</code> method. Now this object can be used with the <code class="literal">for...of</code> loop.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Generators</h1></div></div></div><p>Closely linked with iterators and iterables, generators are one of the most talked about features of ES6. Generator functions return a generator object; this term sounds confusing at first. When you write a function, you also instinctively understand its behavior-the function starts execution, line-by-line, and finishes execution when the last line is executed. Once the function is linearly executed this way, the rest of the code that follows the function is executed.</p><p>In languages where multithreading is supported, such flow of execution can be interrupted and partially finished tasks can be shared between different threads, processes, and channels. JavaScript is single-threaded, and you don't need to deal with challenges around multithreading at the moment.</p><p>However, generator functions can be paused and resumed later. The important idea here is that the generator function chooses to pause itself, it cannot be paused by any external code. During execution, the function uses the <code class="literal">yield</code> keyword to pause. Once a generator function is paused, it can only be resumed by code outside the function.</p><p>You can pause and resume a generator function as many times you want to. With generator functions, a popular pattern is to write infinite loops and pause and resume them when needed. There are pros and cons of doing this, but the pattern has caught up already.</p><p>Another important point to understand is that generator functions also allow two-way message passing, in and out of it. Whenever you pause the function using <code class="literal">yield</code> keyword, the message is sent out of the generator function, and when the function is resumed, the message is passed back to the generator function.</p><p>Let's look at the following example to clarify how the generator functions work:</p><pre class="programlisting">    function* generatorFunc() { &#13;
      console.log('1'); //-----------&gt; A &#13;
      yield;            //-----------&gt; B &#13;
      console.log('2'); //-----------&gt; C &#13;
    } &#13;
    const generatorObj = generatorFunc(); &#13;
    console.log(generatorObj.next());   &#13;
    //"1" &#13;
    //Object { &#13;
    // "done": false, &#13;
    // "value": undefined &#13;
    //} &#13;
</pre><p>This is a very simple generator function. However, there are several interesting aspects that need careful understanding.</p><p>First, notice an asterix <code class="literal">*</code> immediately after the keyword function, this is the syntax to indicate that the function is a generator function. It is also okay to keep the asterix immediately preceding the function name. Both of the following are valid declarations:</p><pre class="programlisting">    function *f(){ }  &#13;
    function* f(){ } &#13;
</pre><p>Inside the function, the real magic is around the <code class="literal">yield</code> keyword. When the <code class="literal">yield</code> keyword is encountered, the function pauses itself. Before we move further, let's see how the function is invoked:</p><pre class="programlisting">    const generatorObj = generatorFunc(); &#13;
    generatorObj.next();  //"1" &#13;
</pre><p>When we invoke the generator function, it is not executed like a normal function, but it returns a generator object. You can use this generator object to control the execution of the generator function. The <code class="literal">next()</code> method on the generator object resumes the execution of the function.</p><p>When we call <code class="literal">next()</code> the first time, the execution proceeds up until the first line of the function (marked by 'A'), and pauses when the <code class="literal">yield</code> keyword is encountered. If we call the <code class="literal">next()</code> function again, it will resume the execution to the next line from the point the execution was paused last time:</p><pre class="programlisting">    console.log(generatorObj.next());   &#13;
    //"2" &#13;
    //Object { &#13;
    // "done": true, &#13;
    // "value": undefined &#13;
    //} &#13;
</pre><p>Once the entire function body is executed, any calls to <code class="literal">next()</code> on the generator object have no effect. We talked about generator functions allowing a two-way message passing. How does that work? In the previous example, you can see that whenever we resume the generator function, we receive an object with two values, <code class="literal">done</code> and <code class="literal">value</code>; in our case, we received <code class="literal">undefined</code> as the value. This is because we did not return any value with the <code class="literal">yield</code> keyword. When you return a value with the <code class="literal">yield</code> keyword, the calling function receives it. Consider the following example:</p><pre class="programlisting">    function* logger() { &#13;
      console.log('start') &#13;
      console.log(yield) &#13;
      console.log(yield) &#13;
      console.log(yield) &#13;
      return('end') &#13;
    } &#13;
 &#13;
    var genObj = logger(); &#13;
 &#13;
    // the first call of next executes from the &#13;
      start of the function until the first yield statement &#13;
    console.log(genObj.next())         &#13;
    // "start", Object {"done": false,"value": undefined} &#13;
    console.log(genObj.next('Save'))   &#13;
    // "Save", Object {"done": false,"value": undefined} &#13;
    console.log(genObj.next('Our'))    &#13;
    // "Our", Object {"done": false,"value": undefined} &#13;
    console.log(genObj.next('Souls'))  &#13;
    // "Souls",Object {"done": true,"value": "end"} &#13;
</pre><p>Let's trace the flow of execution of this example step by step. The generator function has three pauses or yields. We can create the generator object by writing the following line of code:</p><pre class="programlisting">    var genObj = logger(); &#13;
</pre><p>We will start the execution of the generator function by calling the <code class="literal">next</code> method; this method starts the execution till the first yield. If you notice, we are not passing any value to the <code class="literal">next()</code> method in the first call. The purpose of this <code class="literal">next()</code> method is just to start the generator function. We will call the <code class="literal">next()</code> method again, but this time with a <code class="literal">"Save"</code> value passed as a parameter. This value is received by <code class="literal">yield</code> when the function execution is resumed, and we can see the value printed on console:</p><pre class="programlisting">    "Save", Object {"done": false,"value": undefined} &#13;
</pre><p>We will call the <code class="literal">next()</code> method again with two different values, and the output is similar to the one in the preceding code. When we call the <code class="literal">next()</code> method the last time, the execution ends and the generator function returns an <code class="literal">end</code> value to the calling piece of code. At the end of the execution, you will see <code class="literal">done</code> set as <code class="literal">true</code> and <code class="literal">value</code> assigned the value returned by the function, that is, <code class="literal">end</code>:</p><pre class="programlisting">    "Souls",Object {"done": true,"value": "end"} &#13;
</pre><p>It is important to note that the purpose of the first <code class="literal">next()</code> method is to start the execution of the generator function-it takes us to the first <code class="literal">yield</code> keyword and hence, any value passed to the first <code class="literal">next()</code> method is ignored.</p><p>From the discussion so far, it is apparent that generator objects conform to the iterator contract:</p><pre class="programlisting">    function* logger() { &#13;
      yield 'a' &#13;
      yield 'b' &#13;
    } &#13;
    var genObj = logger(); &#13;
    //the generator object is built using generator function &#13;
    console.log(typeof genObj[Symbol.iterator] === 'function')    //true &#13;
    // it is an iterable &#13;
    console.log(typeof genObj.next === 'function') //true &#13;
    // and an iterator (has a next() method) &#13;
    console.log(genObj[Symbol.iterator]() === genObj) //true &#13;
</pre><p>This example confirms that generator functions also conform to the iterables contract.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>Iterating over generators</h2></div></div></div><p>Generators are iterators, and like all ES6 constructs that support iterables, they can be used to iterate over generators.</p><p>The first method is to use the <code class="literal">for...of</code> loop, as shown in the following code:</p><pre class="programlisting">    function* logger() { &#13;
      yield 'a' &#13;
      yield 'b' &#13;
    } &#13;
    for (const i of logger()) { &#13;
      console.log(i) &#13;
    } &#13;
    //"a" "b" &#13;
</pre><p>We are not creating a generator object here. The <code class="literal">For...of</code> loop has support for iterables and generators naturally fall into this loop.</p><p>The spread operator can be used to turn iterables into arrays. Consider the following example:</p><pre class="programlisting">    function* logger() { &#13;
      yield 'a' &#13;
      yield 'b' &#13;
    } &#13;
    const arr = [...logger()] &#13;
    console.log(arr) //["a","b"] &#13;
</pre><p>Finally, you can use the destructuring syntax with generators, as follows:</p><pre class="programlisting">    function* logger() { &#13;
      yield 'a' &#13;
      yield 'b' &#13;
    } &#13;
    const [x,y] = logger() &#13;
    console.log(x,y) //"a" "b" &#13;
</pre><p>Generators play an important role in asynchronous programming. Shortly, we will look at asynchronous programming and promises in ES6. JavaScript and Node.js offer a great environment to write asynchronous programs. Generators can help you write cooperative multitasking functions.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Collections</h1></div></div></div><p>ES6 introduces four data structures-<code class="literal">Map</code>, <code class="literal">WeakMap</code>, <code class="literal">Set</code>, and <code class="literal">WeakSet</code>. JavaScript, when compared to other languages such as Python and Ruby, had a very weak standard library to support hash or Map data structures or dictionaries. Several hacks were invented to somehow achieve the behavior of a <code class="literal">Map</code> by mapping a string key with an object. There were side effects of such hacks. Language support for such data structures was sorely needed.</p><p>ES6 supports standard dictionary data structures; we will look at more details around these in the next section.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Map</h2></div></div></div><p>
<code class="literal">Map</code> allows arbitrary values as <code class="literal">keys</code>. The <code class="literal">keys</code> are mapped to values. Maps allow fast access to values. Let's look at some examples of maps:</p><pre class="programlisting">    const m = new Map(); //Creates an empty Map &#13;
    m.set('first', 1);   //Set a value associated with a key &#13;
    console.log(m.get('first'));  //Get a value using the key &#13;
</pre><p>We will create an empty <code class="literal">Map</code> using the constructor. You can use the <code class="literal">set()</code> method to add an entry to the <code class="literal">Map</code> associating key with value, and overwriting any existing entry with the same key. Its counterpart method, <code class="literal">get()</code>, gets the value associated with a key, or <code class="literal">undefined</code> if there is no such entry in the map.</p><p>There are other helper methods available with maps, which are as follows:</p><pre class="programlisting">    console.log(m.has('first')); //Checks for existence of a key &#13;
    //true &#13;
    m.delete('first'); &#13;
    console.log(m.has('first')); //false &#13;
 &#13;
    m.set('foo', 1); &#13;
    m.set('bar', 0); &#13;
 &#13;
    console.log(m.size); //2 &#13;
    m.clear(); //clears the entire map &#13;
    console.log(m.size); //0 &#13;
</pre><p>You can create a <code class="literal">Map</code> using the following iterable <em>[key, value]</em> pairs as well:</p><pre class="programlisting">    const m2 = new Map([ &#13;
        [ 1, 'one' ], &#13;
        [ 2, 'two' ], &#13;
        [ 3, 'three' ], &#13;
    ]); &#13;
</pre><p>You can chain the <code class="literal">set()</code> method for a compact syntax as follows:</p><pre class="programlisting">    const m3 = new Map().set(1, 'one').set(2, 'two').set(3, 'three'); &#13;
</pre><p>We can use any value as a key. For objects, the key can only be strings, but with collections, this limitation is removed. We can use an object as a key as well, though such use is not very popular:</p><pre class="programlisting">    const obj = {} &#13;
    const m2 = new Map([ &#13;
      [ 1, 'one' ], &#13;
      [ "two", 'two' ], &#13;
      [ obj, 'three' ], &#13;
    ]); &#13;
    console.log(m2.has(obj)); //true &#13;
</pre><div><div><div><div><h3 class="title"><a id="ch05lvl3sec51"/>Iterating over maps</h3></div></div></div><p>One important thing to remember is that order is important with maps. Maps retain the order in which elements were added.</p><p>There are three iterables you can use to iterate over a <code class="literal">Map</code>, that is, <code class="literal">keys</code>, <code class="literal">values</code>, and <code class="literal">entries</code>.</p><p>The <code class="literal">keys()</code> method returns iterable over the keys of a <code class="literal">Map</code> as follows:</p><pre class="programlisting">    const m = new Map([ &#13;
      [ 1, 'one' ], &#13;
      [ 2, 'two' ], &#13;
      [ 3, 'three' ], &#13;
    ]); &#13;
    for (const k of m.keys()){ &#13;
      console.log(k);  &#13;
    } &#13;
    //1 2 3 &#13;
</pre><p>Similarly, the <code class="literal">values()</code> method returns iterable over the values of a <code class="literal">Map</code>, as shown in the following example:</p><pre class="programlisting">    for (const v of m.values()){ &#13;
      console.log(v);  &#13;
    } &#13;
    //"one" &#13;
    //"two" &#13;
    //"three" &#13;
</pre><p>The <code class="literal">entries()</code> method returns entries of the <code class="literal">Map</code> in form of a <em>[key,value]</em> pair, as you can see in the following code:</p><pre class="programlisting">    for (const entry of m.entries()) { &#13;
      console.log(entry[0], entry[1]); &#13;
    } &#13;
    //1 "one" &#13;
    //2 "two" &#13;
    //3 "three" &#13;
</pre><p>You can use destructuring to make this concise as follows:</p><pre class="programlisting">    for (const [key, value] of m.entries()) { &#13;
      console.log(key, value); &#13;
    } &#13;
    //1 "one" &#13;
    //2 "two" &#13;
    //3 "three" &#13;
</pre><p>An even more succinct:</p><pre class="programlisting">    for (const [key, value] of m) { &#13;
      console.log(key, value); &#13;
    } &#13;
    //1 "one" &#13;
    //2 "two" &#13;
    //3 "three" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec52"/>Converting maps to arrays</h3></div></div></div><p>The spread operator (<code class="literal">...</code>) comes in handy if you want to convert a <code class="literal">Map</code> to an array:</p><pre class="programlisting">    const m = new Map([ &#13;
      [ 1, 'one' ], &#13;
      [ 2, 'two' ], &#13;
      [ 3, 'three' ], &#13;
    ]); &#13;
    const keys = [...m.keys()] &#13;
    console.log(keys) &#13;
    //Array [ &#13;
    //1, &#13;
    //2, &#13;
    //3 &#13;
    //] &#13;
</pre><p>As maps are iterable, you can convert the entire <code class="literal">Map</code> into an array using spread operators:</p><pre class="programlisting">    const m = new Map([ &#13;
      [ 1, 'one' ], &#13;
      [ 2, 'two' ], &#13;
      [ 3, 'three' ], &#13;
    ]); &#13;
    const arr = [...m] &#13;
    console.log(arr) &#13;
    //Array [ &#13;
    //[1,"one"], &#13;
    //[2,"two"], &#13;
    //[3,"three"] &#13;
    //] &#13;
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Set</h2></div></div></div><p>A <code class="literal">Set</code> is a collection of values. You can add and remove values from it. Although this sounds similar to arrays, sets don't allow the same value twice. Value in a <code class="literal">Set</code> can be of any type. So far, you must be wondering how different is this from an Array? A <code class="literal">Set</code> is designed to do one thing quickly-membership testing. Arrays are relatively slower at this. <code class="literal">Set</code> operations are similar to <code class="literal">Map</code> operations:</p><pre class="programlisting">    const s = new Set(); &#13;
    s.add('first'); &#13;
    s.has('first'); // true &#13;
    s.delete('first'); //true &#13;
    s.has('first'); //false &#13;
</pre><p>Similar to maps, you can create a <code class="literal">Set</code> via an iterator:</p><pre class="programlisting">    const colors = new Set(['red', white, 'blue']); &#13;
</pre><p>When you add a value to the <code class="literal">Set</code>, and the value already existed, nothing happens. Similarly, if you delete a value from the <code class="literal">Set</code>, and the value didn't exist in the first place, nothing happens. There is no way to catch this scenario.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec81"/>WeakMap and WeakSet</h2></div></div></div><p>
<code class="literal">WeakMap</code> and <code class="literal">WeakSet</code> have the similar, but restricted, APIs as the <code class="literal">Map</code> and <code class="literal">Set</code> respectively, and they work mostly like their strong counterparts. There are a few differences though, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">WeakMap</code> only supports the <code class="literal">new</code>, <code class="literal">has()</code>, <code class="literal">get()</code>, <code class="literal">set()</code>, and <code class="literal">delete()</code> methods</li><li class="listitem" style="list-style-type: disc"><code class="literal">WeakSet</code> only supports <code class="literal">new</code>, <code class="literal">has()</code>, <code class="literal">add()</code>, and <code class="literal">delete()</code></li><li class="listitem" style="list-style-type: disc">Keys of a <code class="literal">WeakMap</code> must be objects</li><li class="listitem" style="list-style-type: disc">Values of a <code class="literal">WeakSet</code> must be objects</li><li class="listitem" style="list-style-type: disc">You can't iterate over <code class="literal">WeakMap</code>; the only way you can access a value is via its key</li><li class="listitem" style="list-style-type: disc">You can't iterate over a <code class="literal">WeakSet</code></li><li class="listitem" style="list-style-type: disc">You can't clear a <code class="literal">WeakMap</code> or a <code class="literal">WeakSet</code></li></ul></div><p>Let's understand <code class="literal">WeakMap</code> first. The difference between a <code class="literal">Map</code> and a <code class="literal">WeakMap</code> is that a <code class="literal">WeakMap</code> allows itself to be garbage collected. The keys in a <code class="literal">WeakMap</code> are weakly held. <code class="literal">WeakMap</code> keys are not counted when the garbage collector does a reference count (a technique to see all alive references), and they are garbage collected when possible.</p><p>WeakMaps are useful when you don't have any control over the life cycle of the object you are keeping in the Map. You don't need to worry about memory leak when using WeakMaps because the objects will not keep the memory occupied even if their life cycle is long.</p><p>Same implementation details apply to <code class="literal">WeakSet</code> as well. However, as you cannot iterate over a <code class="literal">WeakSet,</code> there are not many use cases for a <code class="literal">WeakSet.</code>
</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Summary</h1></div></div></div><p>In this chapter, we took a detailed look at ES6 Generators. Generators are one of the most anticipated features of ES6. The ability to pause and resume execution of a function opens up a lot of possibilities around co-operative programming. The primary strength of generators is that they provide a single-threaded, synchronous-looking code style, while hiding the asynchronous nature away. This makes it easier for us to express in a very natural way what the flow of our program's steps/statements is without simultaneously having to navigate asynchronous syntax and gotchas. We achieve separation of concern using generators due to this.</p><p>Generators work hand-in-hand with the iterators and iterables contract. These are welcome addition to ES6 and significantly boosts the data structures the language offers. Iterators provide a simple way to return a (potentially unbounded) sequence of values. The <code class="literal">@@iterator</code> symbol is used to define default iterators for objects, making them an iterable.</p><p>The most important use case for iterators becomes evident when we want to use it in a construct that consumes iterables, such as the <code class="literal">for...of</code> loop. In this chapter we also looked at a new loop construct <code class="literal">for...of</code> introduced in ES6. <code class="literal">for...of</code> works with a lot of native objects because they have default <code class="literal">@@iterator</code> methods defined. We looked at new additions to the ES6 collections like-Maps, Sets, WeakMaps, and Weak Sets. These collections have additional iterator methods-<code class="literal">.entries()</code>, <code class="literal">.values()</code> and <code class="literal">.keys()</code>.</p><p>The next chapter will take a detailed look at JavaScript Prototypes.</p></div></body></html>