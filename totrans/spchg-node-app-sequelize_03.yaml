- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Validating Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证模型
- en: It is important to maintain consistency and integrity within databases. Databases
    often use some form of constraint stipulation to ensure consistency. Typically,
    these constraints consist of checking for a range of values, such as minimum string
    length, uniqueness, or existence. Integrity for databases involves managing the
    associations and relations between symbiotic records. This involves cascading
    updates and deletions of referenced records (for example, setting the associated
    identity columns to `NULL` when the referenced record has been deleted). Consistency
    and integrity are not mutually exclusive to one another, but the two patterns
    help to ensure organization.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中保持一致性和完整性非常重要。数据库通常使用某种形式的约束规定来确保一致性。通常，这些约束包括检查值范围，例如最小字符串长度、唯一性或存在性。数据库的完整性涉及管理共生记录之间的关联和关系。这包括级联更新和删除引用记录（例如，当引用记录被删除时，将关联的标识列设置为`NULL`）。一致性和完整性不是相互排斥的，但这两个模式有助于确保组织。
- en: Note
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term consistency refers to ensuring that only valid data will be written
    and read from the database (especially within the context of accessing data concurrently).
    Integrity refers to data that conforms to a set of rules, constraints, or triggers
    before it is inserted or read.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性这个术语指的是确保只有有效数据会被写入和从数据库中读取（尤其是在并发访问数据的情况下）。完整性指的是在插入或读取之前符合一组规则、约束或触发器的数据。
- en: While most database engines handle both consistency and integrity, there are
    some limitations as far as consistency is concerned. If you wanted to perform
    validations against a third-party source outside of the database’s scope, you
    would need to either build (or install) an extension for the database that adds
    support or use a central code base to help manage these validations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数数据库引擎都处理一致性和完整性，但在一致性方面存在一些限制。如果您想要对数据库范围之外的第三方源执行验证，您可能需要为数据库构建（或安装）一个扩展来添加支持，或者使用一个中央代码库来帮助管理这些验证。
- en: Sequelize offers built-in validation for various data types to help with the
    ergonomics of a project. Some validations require manual configuration, such as
    checking to see whether a text value matches an email pattern, or manual input
    for certain validations, such as numerical (or date) ranges.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize为各种数据类型提供了内置验证，以帮助提高项目的易用性。某些验证需要手动配置，例如检查文本值是否匹配电子邮件模式，或者某些验证需要手动输入，例如数值（或日期）范围。
- en: 'Validations can be performed using two methodologies within Sequelize:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sequelize中，可以使用两种方法执行验证：
- en: We can execute validations across the entire record involving multiple attributes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在涉及多个属性的整个记录上执行验证
- en: We can invoke validations for each specific attribute
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为每个特定的属性调用验证
- en: 'We will explore how Sequelize performs validations in this chapter to maintain
    consistency and integrity within databases. This chapter will cover the following
    topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Sequelize如何执行验证，以在数据库中保持一致性和完整性。本章将涵盖以下主题：
- en: Using validations as constraints
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用验证作为约束
- en: Creating custom validation methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义验证方法
- en: Executing validations while performing asynchronous operations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行异步操作时执行验证
- en: Handling validation errors
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理验证错误
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sequelize will internally use a validation library called `validator.js`. This
    chapter will go over the validations that Sequelize extends explicitly. For a
    complete list of validations that can be used, you may refer to the `validator.js`
    repository at [https://github.com/validatorjs/validator.js](https://github.com/validatorjs/validator.js).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize将内部使用一个名为`validator.js`的验证库。本章将介绍Sequelize明确扩展的验证。有关可以使用完整验证列表，您可以参考`validator.js`存储库[https://github.com/validatorjs/validator.js](https://github.com/validatorjs/validator.js)。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files for this chapter at: [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch3](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch3)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到本章的代码文件：[https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch3](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch3)
- en: Using validations as constraints
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用验证作为约束
- en: There are certain validations that Sequelize will use as both a validation and
    a constraint. These parameters are configurable in the attribute’s options as
    a sibling to the `validate` parameters. Constraints are defined and guarded by
    the database, whereas a validation will be handled by Sequelize and the Node.js
    runtime exclusively. Here is a list of constraints made available from Sequelize.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有些验证Sequelize既用作验证又用作约束。这些参数可以在属性的选项中作为`validate`参数的兄弟进行配置。约束由数据库定义并受保护，而验证将由Sequelize和Node.js运行时独家处理。以下是Sequelize提供的约束列表。
- en: allowNull
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: allowNull
- en: 'The `allowNull` option will determine whether to apply `NOT NULL` to the definitions
    of columns for the database. The default value is `true`, which will allow columns
    to have a value of `null`. There are a couple of caveats to keep in mind when
    using validations with the `allowNull` constraint:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`allowNull`选项将确定是否将`NOT NULL`应用于数据库列的定义。默认值是`true`，这将允许列具有`null`值。在使用带有`allowNull`约束的验证时，有几个注意事项需要记住：'
- en: If the `allowNull` parameter is set to `false` and the attribute’s value is
    `null`, then the custom validations will not run. Instead, a **ValidationError**
    will be returned without making a request to the database.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果将`allowNull`参数设置为`false`且属性的值为`null`，则自定义验证将不会运行。相反，将返回一个**ValidationError**，而无需向数据库发出请求。
- en: If the `allowNull` parameter is set to `true` and the attribute’s value is `null`,
    then the built-in validators will not be invoked, but the custom validators will
    still execute.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`allowNull`参数设置为`true`且属性的值为`null`，则内置验证器将不会被调用，但自定义验证器仍然会执行。
- en: 'The following is an illustration of the various validation states that will
    cause Sequelize to behave accordingly, depending on the `allowNull` parameter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对各种验证状态的解释，这些状态将根据`allowNull`参数的设置导致Sequelize相应地表现：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the previous example, in the first column, `age`, Sequelize will perform
    a validation check to make sure the numerical value is not less than one. The
    next column, `name`, will invoke a custom validation function that checks whether
    the attribute’s new value is `null` and checks for the user’s age if so. The last
    column, `email`, demonstrates that Sequelize will not invoke validations if the
    `allowNull` flag is set to `false` and the value itself is `null`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在第一列`age`中，Sequelize将执行验证检查以确保数值不低于一。下一列`name`将调用一个自定义验证函数，该函数检查属性的新值是否为`null`，如果是，则检查用户的年龄。最后一列`email`演示了如果将`allowNull`标志设置为`false`且值本身为`null`，Sequelize将不会调用验证。
- en: 'You can customize NOT NULL errors by adjusting the `notNull` parameter in the
    validate config of the attribute as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过调整属性验证配置中的`notNull`参数来自定义`NOT NULL`错误，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Otherwise, Sequelize will return the error message that was sent from the database.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，Sequelize将返回数据库发送的错误消息。
- en: unique
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: unique
- en: 'Setting this parameter to `true` will have Sequelize build a unique constraint
    on the applicable column within the database if you are using Sequelize’s `sync`
    option. If there was a unique constraint violation, Sequelize will return an error
    type of `SequelizeUniqueConstraintError`. Here’s a quick example of how to use
    `unique` (you may allow nullable values for uniqueness as well):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将此参数设置为`true`将在数据库中为适用列构建一个唯一约束，如果您正在使用Sequelize的`sync`选项。如果存在唯一约束违规，Sequelize将返回一个类型为`SequelizeUniqueConstraintError`的错误。以下是如何使用`unique`的快速示例（您还可以为唯一性允许可空值）：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As a general rule of thumb, you should use constraints over validations, wherever
    applicable, since this option will be applied to the database as well. In cases
    where a constraint is not applicable, we can use one of Sequelize’s built-in validations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，您应该在适用的情况下使用约束而不是验证，因为此选项也将应用于数据库。在约束不适用的场合，我们可以使用Sequelize的内置验证之一。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'When setting `allowNull` to `true` on a `unique` attribute, the database will
    allow multiple records with the same `NULL` value on that attribute. This is intentional
    from the DBMS’s side and can be mitigated by explicitly adding constraints to
    a `unique` index such as the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当在`unique`属性上将`allowNull`设置为`true`时，数据库将允许在该属性上具有相同`NULL`值的多个记录。这是数据库管理系统方面的故意行为，可以通过显式地向`unique`索引添加约束来缓解，如下所示：
- en: CREATE UNIQUE INDEX idx_tbl_uniq ON tbl (a, (b IS NULL)) WHERE b IS NULL
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE UNIQUE INDEX idx_tbl_uniq ON tbl (a, (b IS NULL)) WHERE b IS NULL`'
- en: Built-in validations
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内置验证
- en: These validations are performed within the Node.js runtime and not from the
    database. Sequelize will extend the functionality of `validator.js` with its own
    set of validators.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些验证是在 Node.js 运行时内执行的，而不是从数据库中执行。Sequelize 将通过其自己的验证器集扩展 `validator.js` 的功能。
- en: is (regex), not (notRegex), and equals
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: is (regex), not (notRegex), 和 equals
- en: The `is` and `not` validation parameters can either be a literal regular expression
    or an array, with the first entry as a string literal for the regular expression
    and the second entry for regular expression flags. The `equals` parameter is a
    string value that performs a strict comparison check for exact matching.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`is` 和 `not` 验证参数可以是字面量正则表达式或一个数组，其中第一个条目是正则表达式的字符串字面量，第二个条目是正则表达式标志。`equals`
    参数是一个字符串值，用于执行严格的匹配检查。'
- en: 'The following is an example of how to use all three for a model:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个如何使用这三个验证器的模型示例：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: isEmail
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isEmail
- en: This validation will ensure that the attribute’s value matches the rules according
    to RFC 2822, which can be reviewed at [https://datatracker.ietf.org/doc/html/rfc2822](https://datatracker.ietf.org/doc/html/rfc2822).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证将确保属性值符合 RFC 2822 规则，该规则可在 [https://datatracker.ietf.org/doc/html/rfc2822](https://datatracker.ietf.org/doc/html/rfc2822)
    查阅。
- en: isUrl
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isUrl
- en: This will validate whether the attribute’s value is an actual URL with various
    protocols, hostnames (IP and FQDN), and a maximum length.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将验证属性值是否是一个实际的 URL，具有各种协议、主机名（IP 和 FQDN）以及最大长度。
- en: isIP, isIPv4, or isIPv6
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isIP, isIPv4, 或 isIPv6
- en: This validates whether the attribute’s value matches how an IP value should
    look. The `isIP` validation accepts both v4 and v6 formats.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证属性值是否与 IP 值的外观相匹配。`isIP` 验证接受 v4 和 v6 格式。
- en: isAlphanumeric, isNumeric, isInt, isFloat, and isDecimal
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isAlphanumeric, isNumeric, isInt, isFloat, 和 isDecimal
- en: All inputs for validations are sent to the `validator.js` library as a literal
    string. These validators will ensure the input can parse into the respective validation.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于验证的输入都作为字面量字符串发送到 `validator.js` 库。这些验证器将确保输入可以解析为相应的验证。
- en: max or min
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: max 或 min
- en: These apply to numerical attributes only. They add a maximum or minimum numerical
    value respectively for the attribute’s validations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仅适用于数值属性。它们分别为属性验证添加最大或最小数值值。
- en: isLowercase or isUppercase
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isLowercase 或 isUppercase
- en: These check to see whether every letter in the attribute’s value uses the proper
    case.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些检查属性值中的每个字母是否都使用了正确的格式。
- en: isNull, notNull, or notEmpty
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isNull, notNull, 或 notEmpty
- en: This validates whether the value is `null` or not. The `notEmpty` validator
    will validate whether there are any spaces, tabs, or newlines within the value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这验证值是否为 `null` 或不是。`notEmpty` 验证器将验证值中是否有任何空格、制表符或换行符。
- en: contains, notContains, isIn, or notIn
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: contains, notContains, isIn, 或 notIn
- en: 'These contain-related validators will perform a substring check on the value.
    The in-related validators accept any value within an array parameter. For example,
    see the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相关验证器将对值执行子字符串检查。相关验证器接受数组参数内的任何值。例如，请参见以下内容：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: len
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: len
- en: 'The `len` validator accepts an array with two parameters for its input. The
    parameters are for checking the value’s length against a minimum and maximum number
    respectively. To create a validation for a value’s length with a minimum length
    of `1` and a maximum length of `40`, it would look as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`len` 验证器接受一个包含两个参数的数组作为其输入。这些参数用于检查值长度与最小和最大数值分别对应。要创建一个具有最小长度为 `1` 和最大长度为
    `40` 的值长度验证，它看起来如下所示：'
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: isUUID
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isUUID
- en: This validator can check whether a value is in accordance with being a unique
    identifier. You can specify the version (3, 4, or 5) as the input parameter or
    a literal string value of `all` to accept any UUID version.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此验证器可以检查一个值是否符合唯一标识符的要求。您可以指定版本（3、4 或 5）作为输入参数，或者使用字面量字符串值 `all` 以接受任何 UUID
    版本。
- en: isDate, isAfter, or isBefore
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: isDate, isAfter, 或 isBefore
- en: 'The `isDate` validator will determine whether a value is *date-like*. The `isAfter`
    and `isBefore` validators will perform a temporal comparison against the date
    that you are trying to validate against. The default input for comparison is `new
    Date()`. The following is a quick example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`isDate` 验证器将确定一个值是否类似于日期。`isAfter` 和 `isBefore` 验证器将执行与您尝试验证的日期的时间比较。默认输入比较是
    `new Date()`。以下是一个快速示例：'
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: 'The input for `isBefore` and `isAfter` is a string that conforms to any applicable
    date that can be parsed by JavaScript. For examples in compatible formats, you
    may refer to this link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`isBefore`和`isAfter`的输入是一个符合任何适用日期的字符串，该日期可以被JavaScript解析。有关兼容格式的示例，您可以参考此链接：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse)。'
- en: Now that we have gone through several examples of how validations are applied
    to a Sequelize model’s attributes, we can update several files within the Avalon
    Airlines project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过几个示例了解了如何将验证应用于Sequelize模型的属性，我们可以更新Avalon Airlines项目中的几个文件。
- en: Applying validations to our project
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的项目中应用验证
- en: 'In the following example, we will add validations for our Airplane model’s
    `planeModel` and `totalSeats` attributes. We can begin by opening the `models/airplane.js`
    file and adding the following validations:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将为我们的Airplane模型的`planeModel`和`totalSeats`属性添加验证。我们可以从打开`models/airplane.js`文件并添加以下验证开始：
- en: For the `planeModel` attribute, add a `notEmpty` validation since all plane
    models require a value that is not `null` nor an empty string.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`planeModel`属性，添加一个`notEmpty`验证，因为所有飞机型号都需要一个非`null`且非空字符串的值。
- en: On the `totalSeats` attribute, add a minimum validation of `1` as the argument’s
    value since every plane must have at least one seat available for customers.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`totalSeats`属性上，添加一个最小验证值为`1`作为参数值，因为每架飞机都必须至少有一个座位可供顾客使用。
- en: 'The updated file should look something similar to this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的文件应类似于以下内容：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will want to modify the `models/boardingticket.js` file, and add a
    `notEmpty` validator as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将想要修改`models/boardingticket.js`文件，并添加以下`notEmpty`验证器：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The last file to edit within this section will be the `models/customer.js`
    file. The name attribute will require a `notEmpty` validator and the email attribute
    will need an `isEmail` validator as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中最后要编辑的文件将是`models/customer.js`文件。名称属性将需要一个`notEmpty`验证器，而电子邮件属性将需要一个`isEmail`验证器，如下所示：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After going through the list of built-in validations, we can now learn how to
    build our own validations, and how to use custom validations across the entire
    model.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在经过内置验证列表之后，我们现在可以学习如何构建自己的验证，以及如何在整个模型中使用自定义验证。
- en: Creating custom validation methods
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义验证方法
- en: Sequelize gives us the ability to create our own validations simply by adding
    a function to the `validate` parameter on attributes or within the `validate`
    parameter on the model’s options (the second input parameter for the `Model.init()`
    function).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Sequelize允许我们通过向属性或模型选项的`validate`参数（`Model.init()`函数的第二个输入参数）中添加一个函数来创建自己的验证。
- en: 'If we wanted to create our own validation to restrict our users from using
    `password` as a password, we would write a solution similar to this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建自己的验证来限制用户不能使用`password`作为密码，我们会编写一个类似以下的解决方案：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Even though you can check the value on other attributes within a custom attribute
    validator, it is considered good practice to declare a model custom validator,
    which we will demonstrate shortly, when involving more than one attribute for
    validation, which we will demonstrate shortly.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以在自定义属性验证器中的其他属性上检查值，但在涉及多个属性进行验证时，声明一个模型自定义验证器被认为是良好的实践，我们将在稍后演示这一点。
- en: 'We have one more model file to add validations for. The `models/flightschedule.js`
    file will need to validate that the origin airport is not the same as the destination
    airport. First, we will need to import Sequelize and add a list of available airports:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个模型文件需要添加验证。`models/flightschedule.js`文件需要验证出发机场不能与目的地机场相同。首先，我们需要导入Sequelize并添加一个可用机场列表：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, add in the module exports and model class extension lines:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加模块导出和模型类扩展行：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating custom attribute validators
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义属性验证器
- en: 'Then, we can initialize our model with attribute definitions that have validations
    associated with them. We will want to add the `isIn` validator to the `originAirport`
    and `destinationAirport` attributes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用具有相关验证的属性定义初始化我们的模型。我们希望向`originAirport`和`destinationAirport`属性添加`isIn`验证器：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Adding a custom model validator
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加自定义模型验证器
- en: 'Now, we can add our custom model validator here. We will create a function
    that will check the values against the `originAirport` and `destinationAirport`
    attributes. If both of the values are identical, then we will mark the destination
    as invalid and throw an error:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在这里添加我们的自定义模型验证器。我们将创建一个函数，该函数将检查值是否与 `originAirport` 和 `destinationAirport`
    属性匹配。如果两个值都相同，我们将标记目的地为无效并抛出错误：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For the last step, we will close any objects or functions, and return the class
    back to the export:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一步，我们将关闭任何对象或函数，并将类返回到导出：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You may have noticed that we pass through the `validDestination` validator if
    both values are `null`. The `isIn` validator will still execute and return an
    error due to there not being a valid value.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，如果两个值都是 `null`，我们就会跳过 `validDestination` 验证器。`isIn` 验证器仍然会执行并返回一个错误，因为没有有效的值。
- en: Executing validations while performing asynchronous operations
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在执行异步操作时执行验证
- en: Sometimes, your validations will require you to fetch an associated model’s
    record, call a third-party application, or some other form of request that waits
    for a response.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你的验证可能需要你获取关联模型的记录，调用第三方应用程序，或进行其他形式的请求，这些请求需要等待响应。
- en: 'Suppose we were in a situation where we have to ensure that there was a completed
    and active payment before creating or updating a customer’s membership points.
    As long as any payment was still considered in good standing, that customer should
    be able to update their membership. We would use the `async` and `await` keywords
    to help us execute these requests and wait for the responses for validation:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们处于这样一种情况，我们必须确保在创建或更新客户的会员积分之前，有一个完成且活跃的付款。只要任何付款仍然被认为是良好的，该客户应该能够更新他们的会员资格。我们会使用
    `async` 和 `await` 关键字来帮助我们执行这些请求并等待验证的响应：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `async` and `await` keywords work on custom attribute validators as well.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 关键字同样适用于自定义属性验证器。'
- en: 'It is important to note that if you run Sequelize queries within a life cycle
    event, then those queries will execute under a different transaction than the
    parent model. For instance, if we started a transaction and inside its scope,
    we created the payment entry and then tried to create the membership entry, the
    `await Payments.find(…)` line would not be able to see the recently created record.
    To remedy this issue, we can pass a Sequelize transaction to the `transaction`
    parameter when calling `create`. The following is a very generic but high-level
    example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果你在生命周期事件中运行 Sequelize 查询，那么这些查询将在与父模型不同的事务下执行。例如，如果我们开始了一个事务，并在其作用域内创建了付款条目，然后尝试创建会员条目，那么
    `await Payments.find(…)` 这一行将无法看到最近创建的记录。为了解决这个问题，我们可以在调用 `create` 时将 Sequelize
    事务传递给 `transaction` 参数。以下是一个非常通用但高级的示例：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Handling validation errors
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理验证错误
- en: 'Using `FlightSchedule` from the *Creating custom validation methods* section,
    we will go over how to handle validation errors when invoking the `validate`,
    `update`, and `create` methods. Let’s presume that we called a `createFlightSchedule`
    method that looks as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自 *创建自定义验证方法* 部分的 `FlightSchedule`，我们将介绍如何在调用 `validate`、`update` 和 `create`
    方法时处理验证错误。假设我们调用了一个 `createFlightSchedule` 方法，其外观如下：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'By default, the returned error from `ValidationError` should be similar to
    this (you may see additional fields listed):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，从 `ValidationError` 返回的错误应该类似于以下内容（你可能还会看到列出的其他字段）：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, we could manually check for validation before attempting to
    create or modify the record using the instance’s `validate()` method as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以在尝试使用实例的 `validate()` 方法创建或修改记录之前手动检查验证，如下所示：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The result would return an error object similar to this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将返回一个类似于以下错误对象：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, now that our data is *consistent*, what about *integrity*? In the next chapter,
    we will go over what Sequelize has to offer us for creating (and manipulating)
    associations and the various ways of relating models.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的数据已经 *一致*，那么 *完整性* 呢？在下一章中，我们将介绍 Sequelize 为我们提供创建（以及操作）关联和模型之间各种关联方式的功能。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we added validations to our models using some of Sequelize’s
    built-in validators and adding our own custom validation methods. We then moved
    on to handling and performing asynchronous methods inside of custom validations.
    Once we were able to invoke validations properly, we were then able to practice
    handling errors for validations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用 Sequelize 内置验证器以及添加我们自己的自定义验证方法，对我们的模型添加了验证。然后，我们转向在自定义验证中处理和执行异步方法。一旦我们能够正确调用验证，我们就能练习处理验证错误。
- en: In the next chapter, we will be covering another part of adding consistency
    and integrity to our database, which is handling relations and associations for
    our models. Validations will ensure integrity on a database row level and associations
    can be used to ensure integrity across tables and other rows.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍另一个为我们的数据库添加一致性和完整性的部分，即处理和关联我们的模型。验证将确保数据库行级别的完整性，而关联可以用来确保跨表和其他行的完整性。
