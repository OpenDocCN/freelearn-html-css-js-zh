- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validating Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to maintain consistency and integrity within databases. Databases
    often use some form of constraint stipulation to ensure consistency. Typically,
    these constraints consist of checking for a range of values, such as minimum string
    length, uniqueness, or existence. Integrity for databases involves managing the
    associations and relations between symbiotic records. This involves cascading
    updates and deletions of referenced records (for example, setting the associated
    identity columns to `NULL` when the referenced record has been deleted). Consistency
    and integrity are not mutually exclusive to one another, but the two patterns
    help to ensure organization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The term consistency refers to ensuring that only valid data will be written
    and read from the database (especially within the context of accessing data concurrently).
    Integrity refers to data that conforms to a set of rules, constraints, or triggers
    before it is inserted or read.
  prefs: []
  type: TYPE_NORMAL
- en: While most database engines handle both consistency and integrity, there are
    some limitations as far as consistency is concerned. If you wanted to perform
    validations against a third-party source outside of the database’s scope, you
    would need to either build (or install) an extension for the database that adds
    support or use a central code base to help manage these validations.
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize offers built-in validation for various data types to help with the
    ergonomics of a project. Some validations require manual configuration, such as
    checking to see whether a text value matches an email pattern, or manual input
    for certain validations, such as numerical (or date) ranges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Validations can be performed using two methodologies within Sequelize:'
  prefs: []
  type: TYPE_NORMAL
- en: We can execute validations across the entire record involving multiple attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can invoke validations for each specific attribute
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will explore how Sequelize performs validations in this chapter to maintain
    consistency and integrity within databases. This chapter will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using validations as constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom validation methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing validations while performing asynchronous operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling validation errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Sequelize will internally use a validation library called `validator.js`. This
    chapter will go over the validations that Sequelize extends explicitly. For a
    complete list of validations that can be used, you may refer to the `validator.js`
    repository at [https://github.com/validatorjs/validator.js](https://github.com/validatorjs/validator.js).
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files for this chapter at: [https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch3](https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch3)'
  prefs: []
  type: TYPE_NORMAL
- en: Using validations as constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are certain validations that Sequelize will use as both a validation and
    a constraint. These parameters are configurable in the attribute’s options as
    a sibling to the `validate` parameters. Constraints are defined and guarded by
    the database, whereas a validation will be handled by Sequelize and the Node.js
    runtime exclusively. Here is a list of constraints made available from Sequelize.
  prefs: []
  type: TYPE_NORMAL
- en: allowNull
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `allowNull` option will determine whether to apply `NOT NULL` to the definitions
    of columns for the database. The default value is `true`, which will allow columns
    to have a value of `null`. There are a couple of caveats to keep in mind when
    using validations with the `allowNull` constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: If the `allowNull` parameter is set to `false` and the attribute’s value is
    `null`, then the custom validations will not run. Instead, a **ValidationError**
    will be returned without making a request to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the `allowNull` parameter is set to `true` and the attribute’s value is `null`,
    then the built-in validators will not be invoked, but the custom validators will
    still execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an illustration of the various validation states that will
    cause Sequelize to behave accordingly, depending on the `allowNull` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, in the first column, `age`, Sequelize will perform
    a validation check to make sure the numerical value is not less than one. The
    next column, `name`, will invoke a custom validation function that checks whether
    the attribute’s new value is `null` and checks for the user’s age if so. The last
    column, `email`, demonstrates that Sequelize will not invoke validations if the
    `allowNull` flag is set to `false` and the value itself is `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize NOT NULL errors by adjusting the `notNull` parameter in the
    validate config of the attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise, Sequelize will return the error message that was sent from the database.
  prefs: []
  type: TYPE_NORMAL
- en: unique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting this parameter to `true` will have Sequelize build a unique constraint
    on the applicable column within the database if you are using Sequelize’s `sync`
    option. If there was a unique constraint violation, Sequelize will return an error
    type of `SequelizeUniqueConstraintError`. Here’s a quick example of how to use
    `unique` (you may allow nullable values for uniqueness as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As a general rule of thumb, you should use constraints over validations, wherever
    applicable, since this option will be applied to the database as well. In cases
    where a constraint is not applicable, we can use one of Sequelize’s built-in validations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'When setting `allowNull` to `true` on a `unique` attribute, the database will
    allow multiple records with the same `NULL` value on that attribute. This is intentional
    from the DBMS’s side and can be mitigated by explicitly adding constraints to
    a `unique` index such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: CREATE UNIQUE INDEX idx_tbl_uniq ON tbl (a, (b IS NULL)) WHERE b IS NULL
  prefs: []
  type: TYPE_NORMAL
- en: Built-in validations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These validations are performed within the Node.js runtime and not from the
    database. Sequelize will extend the functionality of `validator.js` with its own
    set of validators.
  prefs: []
  type: TYPE_NORMAL
- en: is (regex), not (notRegex), and equals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `is` and `not` validation parameters can either be a literal regular expression
    or an array, with the first entry as a string literal for the regular expression
    and the second entry for regular expression flags. The `equals` parameter is a
    string value that performs a strict comparison check for exact matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of how to use all three for a model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: isEmail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This validation will ensure that the attribute’s value matches the rules according
    to RFC 2822, which can be reviewed at [https://datatracker.ietf.org/doc/html/rfc2822](https://datatracker.ietf.org/doc/html/rfc2822).
  prefs: []
  type: TYPE_NORMAL
- en: isUrl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This will validate whether the attribute’s value is an actual URL with various
    protocols, hostnames (IP and FQDN), and a maximum length.
  prefs: []
  type: TYPE_NORMAL
- en: isIP, isIPv4, or isIPv6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This validates whether the attribute’s value matches how an IP value should
    look. The `isIP` validation accepts both v4 and v6 formats.
  prefs: []
  type: TYPE_NORMAL
- en: isAlphanumeric, isNumeric, isInt, isFloat, and isDecimal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All inputs for validations are sent to the `validator.js` library as a literal
    string. These validators will ensure the input can parse into the respective validation.
  prefs: []
  type: TYPE_NORMAL
- en: max or min
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These apply to numerical attributes only. They add a maximum or minimum numerical
    value respectively for the attribute’s validations.
  prefs: []
  type: TYPE_NORMAL
- en: isLowercase or isUppercase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These check to see whether every letter in the attribute’s value uses the proper
    case.
  prefs: []
  type: TYPE_NORMAL
- en: isNull, notNull, or notEmpty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This validates whether the value is `null` or not. The `notEmpty` validator
    will validate whether there are any spaces, tabs, or newlines within the value.
  prefs: []
  type: TYPE_NORMAL
- en: contains, notContains, isIn, or notIn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'These contain-related validators will perform a substring check on the value.
    The in-related validators accept any value within an array parameter. For example,
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: len
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `len` validator accepts an array with two parameters for its input. The
    parameters are for checking the value’s length against a minimum and maximum number
    respectively. To create a validation for a value’s length with a minimum length
    of `1` and a maximum length of `40`, it would look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: isUUID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This validator can check whether a value is in accordance with being a unique
    identifier. You can specify the version (3, 4, or 5) as the input parameter or
    a literal string value of `all` to accept any UUID version.
  prefs: []
  type: TYPE_NORMAL
- en: isDate, isAfter, or isBefore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `isDate` validator will determine whether a value is *date-like*. The `isAfter`
    and `isBefore` validators will perform a temporal comparison against the date
    that you are trying to validate against. The default input for comparison is `new
    Date()`. The following is a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The input for `isBefore` and `isAfter` is a string that conforms to any applicable
    date that can be parsed by JavaScript. For examples in compatible formats, you
    may refer to this link: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/parse).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have gone through several examples of how validations are applied
    to a Sequelize model’s attributes, we can update several files within the Avalon
    Airlines project.
  prefs: []
  type: TYPE_NORMAL
- en: Applying validations to our project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the following example, we will add validations for our Airplane model’s
    `planeModel` and `totalSeats` attributes. We can begin by opening the `models/airplane.js`
    file and adding the following validations:'
  prefs: []
  type: TYPE_NORMAL
- en: For the `planeModel` attribute, add a `notEmpty` validation since all plane
    models require a value that is not `null` nor an empty string.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the `totalSeats` attribute, add a minimum validation of `1` as the argument’s
    value since every plane must have at least one seat available for customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The updated file should look something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will want to modify the `models/boardingticket.js` file, and add a
    `notEmpty` validator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The last file to edit within this section will be the `models/customer.js`
    file. The name attribute will require a `notEmpty` validator and the email attribute
    will need an `isEmail` validator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: After going through the list of built-in validations, we can now learn how to
    build our own validations, and how to use custom validations across the entire
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom validation methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sequelize gives us the ability to create our own validations simply by adding
    a function to the `validate` parameter on attributes or within the `validate`
    parameter on the model’s options (the second input parameter for the `Model.init()`
    function).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to create our own validation to restrict our users from using
    `password` as a password, we would write a solution similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Even though you can check the value on other attributes within a custom attribute
    validator, it is considered good practice to declare a model custom validator,
    which we will demonstrate shortly, when involving more than one attribute for
    validation, which we will demonstrate shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one more model file to add validations for. The `models/flightschedule.js`
    file will need to validate that the origin airport is not the same as the destination
    airport. First, we will need to import Sequelize and add a list of available airports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add in the module exports and model class extension lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom attribute validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Then, we can initialize our model with attribute definitions that have validations
    associated with them. We will want to add the `isIn` validator to the `originAirport`
    and `destinationAirport` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding a custom model validator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, we can add our custom model validator here. We will create a function
    that will check the values against the `originAirport` and `destinationAirport`
    attributes. If both of the values are identical, then we will mark the destination
    as invalid and throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last step, we will close any objects or functions, and return the class
    back to the export:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that we pass through the `validDestination` validator if
    both values are `null`. The `isIn` validator will still execute and return an
    error due to there not being a valid value.
  prefs: []
  type: TYPE_NORMAL
- en: Executing validations while performing asynchronous operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, your validations will require you to fetch an associated model’s
    record, call a third-party application, or some other form of request that waits
    for a response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we were in a situation where we have to ensure that there was a completed
    and active payment before creating or updating a customer’s membership points.
    As long as any payment was still considered in good standing, that customer should
    be able to update their membership. We would use the `async` and `await` keywords
    to help us execute these requests and wait for the responses for validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `async` and `await` keywords work on custom attribute validators as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that if you run Sequelize queries within a life cycle
    event, then those queries will execute under a different transaction than the
    parent model. For instance, if we started a transaction and inside its scope,
    we created the payment entry and then tried to create the membership entry, the
    `await Payments.find(…)` line would not be able to see the recently created record.
    To remedy this issue, we can pass a Sequelize transaction to the `transaction`
    parameter when calling `create`. The following is a very generic but high-level
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Handling validation errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using `FlightSchedule` from the *Creating custom validation methods* section,
    we will go over how to handle validation errors when invoking the `validate`,
    `update`, and `create` methods. Let’s presume that we called a `createFlightSchedule`
    method that looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the returned error from `ValidationError` should be similar to
    this (you may see additional fields listed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could manually check for validation before attempting to
    create or modify the record using the instance’s `validate()` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would return an error object similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, now that our data is *consistent*, what about *integrity*? In the next chapter,
    we will go over what Sequelize has to offer us for creating (and manipulating)
    associations and the various ways of relating models.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we added validations to our models using some of Sequelize’s
    built-in validators and adding our own custom validation methods. We then moved
    on to handling and performing asynchronous methods inside of custom validations.
    Once we were able to invoke validations properly, we were then able to practice
    handling errors for validations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be covering another part of adding consistency
    and integrity to our database, which is handling relations and associations for
    our models. Validations will ensure integrity on a database row level and associations
    can be used to ensure integrity across tables and other rows.
  prefs: []
  type: TYPE_NORMAL
