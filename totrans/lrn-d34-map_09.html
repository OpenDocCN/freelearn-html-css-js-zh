<html><head></head><body>
        

                            
                    <h1 class="header-title">Mapping with Canvas and D3</h1>
                
            
            
                
<p>It's time to leave our house and tree. I know it's sad, but we'll move on to potentially more exciting things to build. You covered a lot of ground in the previous chapter. You learned how to draw with Canvas, how to animate with Canvas, and a pattern to combine the D3 life cycle with Canvas. As D3 is usually in cahoots with SVG, you also learned about a few key differences between SVG and Canvas. Understanding the advantages and limitations of either approach is key to making informed decisions about which mode of rendering to use. Here's what we will go through in this chapter:</p>
<ul>
<li>We'll start off with a summary of the key reasons for using either SVG or Canvas.</li>
<li>We will then move on to review steps to build a flight path visualization with SVG, before building one with Canvas.</li>
<li>Along the way, we will focus on measuring the performance to get a good understanding of how far we can go with either approach.</li>
</ul>
<p>This will further contrast and compare the two approaches conceptually and technically. It will also allow us to demonstrate the main reason for choosing Canvas over SVG – animation of a great many points.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing Canvas or SVG</h1>
                
            
            
                
<p>You have already seen some benefits and some challenges to overcome when working with either of the two rendering methods. This section is supposed to summarize the most important differences. As such, it should give you a good understanding of what to use in which circumstance. Note, that I am juxtaposing SVG and Canvas rather than HTML and SVG with Canvas. It seems appropriate to focus on SVG as it is D3's main building block due to its visualization advantages. However, the same logic applies to the equally retained HTML.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reasons to choose SVG</h1>
                
            
            
                
<p>Let's first look at the SVG benefits:</p>
<ul>
<li>SVG is a vector-based graphics system. It allows resolution independent drawings you can scale without affecting quality.</li>
<li>You can easily access elements in the DOM to move, change, or add interactivity.</li>
<li>You can style with CSS.</li>
<li>D3 works closely with the DOM, allowing for concise operations such as element selection and styling in a single pass and declarative animations with SVG.</li>
<li>SVG is accessible to screen-readers and SEO bots out of the box. Canvas requires fallback text or a sub-DOM to provide some level of accessibility.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Reasons to choose Canvas</h1>
                
            
            
                
<p>While SVG might be easier to handle, Canvas has advantages when it comes to showing and animating more elements:</p>
<ul>
<li>SVG allows you to draw roughly 10,000 elements and animate 1,000 or so elements. With Canvas you can animate around 10,000 points. Why? First of all, Canvas is lower level and has fewer abstraction layers to keep and manage in memory. Secondly, browsers (like most monitors) mostly support a frame rate of 60 frames per second, meaning the screen is updated 60 times per second. This leaves <em>1000 / 60 = 16.67</em> milliseconds to finish all necessary rendering and housekeeping activities. As human brains are fooled into perceiving fluid animation at a mere 16 frames per second, the maximum time for rendering a frame is <em>1000 / 16 = 62.5</em> milliseconds — but you should strive for a shorter time. For SVG these activities include DOM parsing, render tree production, layout and screen painting, to name the most important. The path between Canvas changes and image is shorter. The browser turns the context instructions into an array of pixel values before painting it to the canvas.</li>
<li>If you need more elements to render or animate, accessing the alternative WebGL context is as easy as defining <kbd>canvas.getContext(‘webgl')</kbd>. WebGL allows you to animate 100k elements and more. While WebGL code is close to GPU programming and hence not for the faint-hearted, abstraction libraries like <kbd>Three.js</kbd>, <kbd>Pixi.js</kbd>, or <kbd>regl</kbd> make it more accessible.</li>
</ul>
<p>Check out Peter Beshai's excellent tutorial on animating 100,000 points with WebGl and regl at <a href="https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html">https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html</a>.</p>
<ul>
<li>Canvas is a <strong>rasterized</strong> graphics system. This just means the image consists of a <em>raster</em> (we could also say a <em>matrix</em>) of pixels. As a result, scaling can lead to blur, but in turn it's simple to download your canvas as an image. A further problem are high <strong>Dots Per Inch</strong> (<strong>DPI</strong>) or retina screens, that can make Canvas blur. You can use the following setup to support retina displays on Canvas:</li>
</ul>
<pre style="padding-left: 60px">var devicePixelRatio = window.devicePixelRatio || 1<br/>var canvas = d3.select(‘body').append(‘canvas')<br/>    .attr(‘width', width * devicePixelRatio)<br/>    .attr(‘height', height * devicePixelRatio)<br/>    .style(‘width', width + ‘px')<br/>    .style(‘height', height + ‘px');<br/>var context = canvas.getContext(‘2d');<br/>context.scale(devicePixelRatio, devicePixelRatio);</pre>
<p>Considering this, it seems a wise choice to stick to SVG for as long as possible and pull Canvas out of the hat when many elements need to be drawn or moved around. You might want to keep things simple until they can't be. One not-so-simple case could be the animation of a great many points. Let's look at an example that demonstrates the performance benefits Canvas has by building an element-heavy, animated application first with SVG and then with Canvas.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Visualizing flight paths with Canvas and D3</h1>
                
            
            
                
<p>Data can come with a great many number of individual data points. Maps especially can be the playground for large datasets. While it might be tempting to visualize features of a dataset as individual elements, in explanatory data visualization especially it often makes sense to aggregate data to bring across a single point well. While Canvas allows you to show and animate many points, it is power you might want to use responsibly.</p>
<p>Having said that, it can often be mesmerizing to watch dynamic data unfold as well as bringing across a specific point. Combining user engagement with concise learnings is of course a great plus you should leverage if possible. Considering map data, there are a great many examples of dynamic visualizations with numerous animated elements, such as natural elements like winds or ocean currents, cultural elements like spreading ideas or inventions, as well technical elements like cars, ships, or airplanes. In this section, we will jump on the latter and visualize flight paths.</p>
<p>Our aim will be two-fold. Firstly, we want to build a map visualization with many animated elements – not just for the sake of showing many elements, but the detail we show should facilitate the understanding of the visual. Secondly, we want to compare the performance between SVG and Canvas. We have described it theoretically in a previous section, but let's get practical now.</p>
<p>Here's what we will build:</p>
<div><img height="376" width="738" src="img/15f41f3a-8672-433a-88c4-8a0c805a3659.png"/></div>
<p>1,000 flight paths visualized. Each red dot is an animated plane (promise!)</p>
<p>There are three main element categories we will draw: <em>the world, airports</em> (the white dots, consciously kept in the background as they are of only supporting importance), and the <em>planes</em> (the red dots). Representing real planes, our red dots are animated along their very own flight path flying from their origin to their destination. Here's an image showing the paths our planes follow:</p>
<div><img height="411" width="775" src="img/6df407f2-f612-4734-adc7-16dc5c59dc86.png"/></div>
<p>100 flights showing the route paths and their respective planes</p>
<p>The source data for this visual includes over 65,000 worldwide routes flying to and from just over 7,000 airports. We won't be able to animate all these routes, not even with Canvas. The aim of our visualization will rather be to show as many as we can to convey an immediate visual understanding of active versus less active flight regions as well as oft-used versus lesser-used routes.</p>
<p>At the bottom of the visual we will show a row of buttons:</p>
<div><img height="50" width="772" src="img/c602cbc1-4402-4fb7-a5b0-0d0e0bf040af.png"/></div>
<p>Buttons to kick off the animation</p>
<p>These buttons will allow the user to set the number of flights to be displayed at once. Importantly, this will not be real time or replayed time. We won't bring in any flight schedules, showing flights at the time of day/date they depart or arrive, we will show all flights at the same time! Firstly, this supports the visualization aims described previously and secondly, it will help test performance because as many elements as possible are being animated at the same time.</p>
<p>To test browser performance, we shall add a small information box from <kbd>stats.js</kbd> at the top left of our app. Once dropped into your code, this nifty info tool displays page performance measures on your page, of which we will be mainly interested in <strong>frames per second</strong> (<strong>FPS</strong>). You will see it soon in action, but this is how it looks magnified indicating 60 frames per second:</p>
<div><img height="49" width="81" src="img/e03b7b04-6e56-407e-b2cd-8536647e006d.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">The data</h1>
                
            
            
                
<p>According to the three element categories we want to represent, we need three data sources to build the visual. The map data, data about airport locations, as well as flight data, showing origins and destinations for each flight. We will call this the <strong>route data</strong>. Both datasets come from <a href="https://openflights.org/">openflights.org</a> which offers a tool you can use to map flights as well as databases for flights worldwide including routes and airport location data. This is exactly what we're after.</p>
<p class="mce-root">After light cleaning and minor modifications, the first 10 entries of the route data and the airport location data with 100 flights look as follows:</p>
<div><img height="266" width="488" src="img/09edba9a-51fb-4a11-a87f-a4a9421e33a5.png"/></div>
<p>The route and the airport data</p>
<p>All variable names are self-explanatory. Note that the first variable in the airport data, <em>i</em><em>ata</em><em>,</em> represents the official three-letter airport code from the <strong>International Air Transport Association</strong> (<strong>IATA</strong>). Also note that we had to remove some flights per dataset as not every airport location was available, which in fact leads to a lower number (less than 2-3%) of flights than the buttons suggest.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the flight path map in SVG</h1>
                
            
            
                
<p>Our focus in this chapter will be on mapping with Canvas as well as on a benchmark of Canvas against SVG animation. In order to spend our time and effort wisely, I have pre-built an SVG map we can use as a benchmark, leaving us the rest of the chapter to focus on how to build the Canvas flight path app. The chapter is called <em>Mapping with <strong>Canvas</strong> and D3</em> after all...</p>
<p>Nonetheless, let's have a quick look at the steps we would take to build this app with SVG. There are roughly eight logical steps to follow:</p>
<ol>
<li>You set up the map with a container SVG, as well as the projection and the path generator for the map</li>
<li>You load the map data and draw the map</li>
<li>You listen to button events and load in the appropriate dataset depending on the button pressed</li>
<li>You draw the airports</li>
<li>You calculate each plane’s origin and destination position as well as compute a path from origin to destination</li>
<li>You sample points along each plane’s path and store them in an array (we’ll call them <em>way points</em>)</li>
<li>Using D3, you transition each plane along its path</li>
<li>Once each plane has reached its destination, you let the transition start again</li>
</ol>
<p>Now that we have conjured up our SVG flight path visual, let's see how many planes we can set off without any problems.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Measuring the performance</h1>
                
            
            
                
<p>So here it is – let's make some planes fly. We should start modestly and try with 100 routes:</p>
<div><img height="478" width="751" src="img/3a6bcd3b-ff61-4ea7-9fde-77ffc0c51fab.png"/></div>
<p>SVG visualization of 100 flight paths at 60 FPS</p>
<p>See the frame rate in the top-left corner? It's a bit small but we're still very happy with it! Displaying 60 frames per second is perfect. 1,000 flights will give us up to 40 frames per seconds. This is a drop, but the animation remains smooth. However, even at 1,000 flights we can’t really see any major clusters of flight activity. So, let’s try 5,000 flights at the same time:</p>
<div><img height="461" width="751" src="img/e2e784cf-5c22-4ced-b89e-9770c8f440fc.png"/></div>
<p>SVG visualization of 5,000 flight paths at 6 FPS</p>
<p>Our performance crashed to 6 FPS. While this static image brings us closer to our visualization aim of identifying regions of high flight traffic, it's no fun to view the janking animation. Canvas to the rescue.</p>
<p>View this step in the browser at: <a href="https://larsvers.github.io/learning-d3-mapping-9-1">https://larsvers.github.io/learning-d3-mapping-9-1</a>. Code example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_01.html">09_01.html</a>. I recommend to use a recent version of Chrome to view and work on the examples of this chapter. </p>
<div><p>At the conclusion of each step you will find two links in an info box close to the the relevant image. The first link brings you to a working implementation of this step that you can view in the browser. The second <em>code example</em> link brings you to the full code. If you're reading the print version, you can find all code examples at <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping">https://github.com/larsvers/Learning-D3.js-4-Mapping</a> in their relevant chapter.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Building the flight path map in Canvas</h1>
                
            
            
                
<p>Let's start with an overview of our Canvas application before we take it apart.</p>
<p>It's best to quickly get the HTML out of the way as it couldn't be much simpler. We have a <kbd>div</kbd> for the canvas at hand as well as our buttons:</p>
<pre>&lt;div id="canvas-map"&gt;&lt;/div&gt;<br/>&lt;div id="controls"&gt;<br/>    &lt;div class="flight-select" id="button-header"&gt;Pick number of flights:&lt;/div&gt;<br/>    &lt;button class="flight-select" data-flights="100"&gt;100&lt;/button&gt;<br/>    &lt;button class="flight-select" data-flights="1000"&gt;1,000&lt;/button&gt;<br/>    &lt;button class="flight-select" data-flights="5000"&gt;5,000&lt;/button&gt;<br/>    &lt;button class="flight-select" data-flights="10000"&gt;10,000&lt;/button&gt;<br/>    &lt;button class="flight-select" data-flights="15000"&gt;15,000&lt;/button&gt;<br/>    &lt;button class="flight-select" data-flights="20000"&gt;20,000&lt;/button&gt;<br/>    &lt;button class="flight-select" data-flights="25000"&gt;25,000&lt;/button&gt;<br/>    &lt;button class="flight-select" data-flights="30000"&gt;30,000&lt;/button&gt;<br/>&lt;/div&gt;</pre>
<p>Note that each button gets the same class selector as well as a <kbd>data-flights</kbd> attribute to pass on the number of flights each button represents. You will use this in a moment to load the right dataset!</p>
<p>Now let's look at the steps we take in the JavaScript to build this app in Canvas and see what changes to the flow we described previously for the SVG app. I have <strong>highlighted</strong> the parts we change for the Canvas flow and have removed the SVG parts (in brackets):</p>
<ol>
<li>You set up the <strong>Canvas and the context</strong> (instead of a container SVG), as well as the projection and the path generator for the map</li>
<li>You load the map data and draw the map</li>
<li>You listen to button events and load in the appropriate dataset depending on the button pressed</li>
<li>You draw the airports <strong>and the world</strong>, as they are on the same Canvas and a redraw is cheap</li>
<li>You calculate each plane’s origin and destination position as well as compute a path from origin to destination</li>
<li>You sample <em>way points</em> along each plane’s path and store them in an array</li>
<li><strong>You set off the game loop </strong>(instead of using D3 transitions)<strong>:</strong>
<ol>
<li>clear the Canvas</li>
<li>update the position</li>
<li>draw the planes </li>
</ol>
</li>
</ol>
<ol start="8">
<li>In the SVG example we restart a transition, once each plane has reached its destination. In our Canvas app this is part of the <strong>update step in the game loop</strong>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the map</h1>
                
            
            
                
<p>First, we set up a few global variables:</p>
<pre>var width = 1000,<br/>    height = 600,<br/>    countries,<br/>    airportMap,<br/>    requestID;</pre>
<p><kbd>width</kbd> and <kbd>height</kbd> speak for themselves. Countries will hold the GeoJSON data to draw the globe, which needs to be reached from various function scopes. Hence, it's easier to define it as a global variable in this small app. <kbd>airportMap</kbd> will allow us to join the airport with the routes data by the three-letter IATA code. <kbd>requestID</kbd> will be filled by our loop function <kbd>requestAnimationFrom()</kbd> and used to cancel the current loop. We shall get to this in no time.</p>
<p>We then set up the two contexts: a context for the world and a context for the planes. This little extra work at the beginning makes our life much easier later. If we drew the world and the planes on the same context, we would have to update both the world and the planes every time a plane flies a short distance. Keeping the world on a separate canvas means we only have to draw the world once and can leave that image/context untouched:</p>
<pre>var canvasWorld = d3.select('#canvas-map').append('canvas')<br/>  .attr('id', 'canvas-world')<br/>  .attr('width', width)<br/>  .attr('height', height);<br/><br/>var contextWorld = canvasWorld.node().getContext('2d');<br/><br/>var canvasPlane = d3.select('#canvas-map').append('canvas')<br/>  .attr('id', 'canvas-plane')<br/>  .attr('width', width)<br/>  .attr('height', height);<br/><br/>var contextPlane = canvasPlane.node().getContext('2d');</pre>
<p>We use absolute CSS positioning for the canvases to stack them perfectly on top of each other:</p>
<pre>#canvas-world, #canvas-plane {<br/>  position: absolute;<br/>  top: 0;<br/>  left: 0;<br/>}</pre>
<p>Next, we set up the <kbd>projection</kbd>:</p>
<pre>var projection = d3.geoRobinson()<br/>    .scale(180)<br/>    .translate([width / 2, height / 2]);<br/><br/></pre>
<p>Please note that instead of playing with <kbd>.scale()</kbd> and <kbd>.translate()</kbd> to center and fit your projection, you can use the D3 convenience methods  <kbd>.fitExtent()</kbd> or <kbd>.fitSize()</kbd>. You pass them your viz dimensions and the GeoJSON object you want to project and it calculates the best scale and translation for you.</p>
<p>Also notice that we don't use the omnipresent <em>Mercator</em> projection but the <em>Robinson</em> projection for our world map. It has the advantage of drawing the world in a slightly more realistic way in terms of country size proportions. The <em>Robinson </em>and many more non-standard projections can be found in the additional <em>d3-geo-projection module</em>. </p>
<p>Now we need a path generator. In fact, you will need to build two path generators:</p>
<pre>var pathSVG = d3.geoPath()<br/>    .projection(projection);<br/><br/>var pathCanvas = d3.geoPath()<br/>    .projection(projection)<br/>    .pointRadius(1)<br/>    .context(contextWorld);</pre>
<p><kbd>pathSVG</kbd> will be used to generate the flight path in memory. We want to do that in SVG as it comes with handy methods to calculate its length and sample points from it. <kbd>pathCanvas</kbd> will be used to draw our <kbd>geo</kbd> data to the screen. Note that we add <kbd>d3.geoPath()</kbd>'s <kbd>.context()</kbd> method and pass it our <kbd>contextWorld</kbd>. If we pass a Canvas context to this <kbd>.context()</kbd> method, the path generator will return a Canvas path for the passed context. If it's not specified it will return an SVG path string. You can think of it as a switch button to tell D3 which renderer to use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing the map and listening for user input</h1>
                
            
            
                
<p>As with the SVG process, we start by loading the data in:</p>
<pre>d3.json('data/countries.topo.json', function(error, world) {<br/>  if (error) throw error;<br/>  d3.select('div#controls').style('top', height + 'px');<br/>  countries = topojson.feature(world, world.objects.countries); // GeoJSON;<br/>  drawMap(countries);</pre>
<p>We then do a bit of housekeeping and move the buttons in the <kbd>div#controls</kbd> below the canvases. You recode the TopoJSON to GeoJSON features and save the data as a global variable before you draw the map:</p>
<pre>function drawMap(world) {<br/>  countries.features.forEach(function(el, i) {<br/><br/>    contextWorld.beginPath();<br/>    pathCanvas(el);<br/>    contextWorld.fillStyle = '#ccc';<br/>    contextWorld.fill();<br/>    <br/>    contextWorld.beginPath();<br/>    pathCanvas(el);<br/>    contextWorld.strokeStyle = '#fff';<br/>    contextWorld.lineWidth = 1;<br/>    contextWorld.stroke();<br/><br/>  });<br/>}</pre>
<p>Thanks to D3's versatile path generator, this is all it needs to draw the world. Easy!</p>
<p>Back in our asynchronous <kbd>d3.json()</kbd> data load function, you'll handle the button events next. Remember, nothing has happened yet, but as soon as the user hits a button, the animation should kick off.</p>
<p>You attach a mouse-down listener to all buttons:</p>
<pre>d3.selectAll('button.flight-select').on('mousedown', handleFlights);</pre>
<p>Proceed with writing the handler:</p>
<pre>function handleFlights() {<br/>  d3.selectAll('button').style('background-color', '#f7f7f7');<br/>  d3.select(this).style('background-color', '#ddd');<br/><br/>  if (requestID) cancelAnimationFrame(requestID);<br/>    var flights = this.dataset.flights;<br/>          <br/>    d3.queue()<br/>      .defer(d3.csv, 'data/routes_' + flights + '.csv')<br/>      .defer(d3.csv, 'data/airports_' + flights + '.csv')<br/>      .await(ready);<br/>  }</pre>
<p>The button colors are handled in the first two lines. The next line will stop the current loop. We haven't even got a loop yet, so let's get back to this as soon as we have.</p>
<p>Finally, we retrieve the number of flights the button represents and load the respective route and airport location data from the server. That's it for the <kbd>d3.json()</kbd> callback, as the <kbd>ready()</kbd> function will take over as soon as the data is loaded.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparing and drawing with Canvas</h1>
                
            
            
                
<p>With Canvas, we want to achieve three things in the <kbd>ready()</kbd> function:</p>
<pre>function ready(error, routes, airports) {<br/>  if (error) throw error;<br/><br/>  // 1) Draw the background scene<br/>  // 2) Calculate plane positions<br/>  // 3) Animate and render the planes<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing the background scene</h1>
                
            
            
                
<p>Before we draw the airports, we manipulate the airport locations data. We create an array holding one GeoJSON point <kbd>geometry</kbd> object per airport:</p>
<pre>var airportLocation = [];<br/>airports.forEach(function(el) {<br/>  var obj = {};<br/>  obj.type = 'Feature';<br/>  obj.id = el.iata;<br/>  obj.geometry = {<br/>    type: 'Point',<br/>    coordinates: [+el.long, +el.lat]<br/>  };<br/>  obj.properties = {};<br/>  airportLocation.push(obj);<br/>});<br/>airportMap = d3.map(airportLocation, function(d) { return d.id; });</pre>
<p>Then we fill the global <kbd>airportMap</kbd> variable with a map we produce with <kbd>d3.map()</kbd>. <kbd>d3.map()</kbd> is a utility function that takes an array of objects to produce key-value pairs we can access with its own <kbd>map.get()</kbd> method. We won't use the map immediately but will get to it in a moment.</p>
<p>Every time we call the <kbd>ready()</kbd> function, that is every time the user presses a new button, we will redraw airports and the world. Both are drawn on the same canvas. If we want to change one thing on a canvas, we need to change everything on a canvas. There are ways to only update regions with clip-paths but with complex animations of multiple elements, this can become a mess real quick. So we erase and rebuild:</p>
<pre>contextWorld.clearRect(0, 0, width, height);<br/>drawMap(countries);<br/>drawAirports(airportLocation);</pre>
<p>Note, we're on the first canvas we've drawn – accessible via <kbd>contextWorld.</kbd> We've seen <kbd>drawMap()</kbd> a few paragraphs ago, <kbd>drawAirports()</kbd> is even simpler and speaks for itself:</p>
<pre>function drawAirports(airports) {<br/>  airports.forEach(function(el,i) {<br/><br/>    contextWorld.beginPath();<br/>    pathCanvas(el);<br/>    contextWorld.fillStyle = '#fff';<br/>    contextWorld.fill();<br/><br/>  });<br/>}</pre>
<p>That's it. This background scene will be drawn with every button press updating the airports shown.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining the planes</h1>
                
            
            
                
<p>Next, we build the fundament for our animation. Essentially, we want an array of points on each plane's route. We will call them <strong>way points</strong> and here's how they will look for the flight path <strong>Frankfurt to Atlanta</strong> as an array and as points on the path:</p>
<div><img height="558" width="805" src="img/b4039708-d1d0-461c-848b-dfc51e19590f.png"/></div>
<p>Way points in an array (showing the first 10 of 733) and on the map (an illustration, not exact)</p>
<p>The <strong>way points</strong> are the core ingredient, the fuel for our animation. When we animate the first frame, we will:</p>
<ol>
<li>Clear the plane's own canvas <kbd>contextPlane</kbd>.</li>
<li>Pull out the very first way point for each plane.</li>
<li>Draw that plane in this position.</li>
</ol>
<p>When we draw the second frame we do the same, but in <em>step 2</em> pull out the second way point. For the third frame, we shall pull out the third way point, and so on.</p>
<p>We don't want to hold up the browser with complex calculations in between each frame, so we shall calculate all positions for all planes before we animate. Note, this is not always possible, positions might be dependent on user input or arbitrary charges in your force-directed graph or the like. However, whatever you can pre-calculate, you should.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Calculating the plane's positions</h1>
                
            
            
                
<p>How do we get to the <kbd>wayPoints</kbd> array? Conceptually, we've said it all already. We now express it in code. First, you need to create an array for all planes, depending on the route data the respective button press has loaded in:</p>
<pre>var routeFromTo = [];<br/>  routes.forEach(function(el) {<br/>    var arr = [el.source_airport, el.destination_airport];<br/>    routeFromTo.push(arr);<br/>  });</pre>
<p>This is a simple array of elements representing the three-letter origin and the destination IATA airport codes.</p>
<p>Next, you iterate through this array of start and end points to calculate the <kbd>wayPoints</kbd>. You will create an object called <kbd>planes</kbd> holding the data as well as two helper functions to calculate the data. But before this, have a look at the simple algorithm to produce the planes:</p>
<pre>routeFromTo.forEach(function(el, i) {<br/>  var plane = planes.getPlane(el);<br/>  plane.route = planes.getPath(el);<br/>  plane.wayPoints = planes.getWayPoints(plane);<br/>  planes.items.push(plane);<br/>});</pre>
<p>Conceptually, you produce a plane for each route. Then you get this plane's route path and store it within the plane. Next, you sample the path for a number of <em>x</em>, <em>y</em> coordinates – our <kbd>wayPoints</kbd> – and also store it in the <kbd>plane</kbd>. Lastly, you add the <kbd>plane</kbd> with all the information you need in the <kbd>planes.items</kbd> array. That's all the calculation magic in an overview. As soon as that's done, you can animate the points.</p>
<p>Now, let's have a brief look at the <kbd>planes</kbd> object. Note the plural! This is different to the <kbd>plane</kbd> object we build for each route. It is the home of all our <kbd>plane</kbd> objects. <kbd>planes.items</kbd> will keep all <kbd>plane</kbd> objects, <kbd>planes.getPlane()</kbd> will produce them, <kbd>planes.getPath()</kbd> will create the route's path, and <kbd>planes.getWayPoints()</kbd> will sample our way points from the path:</p>
<pre>var planes = {<br/>  items: [],<br/>  getPlane: function(planeRoute) { },<br/>  getPath: function(planeRoute) { },<br/>  getWayPoints: function(plane) { }<br/>}</pre>
<p>Let's look at what each <kbd>planes</kbd> function does. There are three simple steps: first, we build the plane, then we draw each plane's path, and finally we sample points from that path we can iterate through to make the plane move: </p>
<ul>
<li><strong>Manufacturing a plane</strong>:<strong> </strong>the <kbd>getPlane()</kbd> function takes the <kbd>planeRoute</kbd> – the three-letter airport codes for origin and destination – and uses it to initialize the plane's position:</li>
</ul>
<pre style="padding-left: 60px">getPlane: function(planeRoute) {<br/><br/>  var origin = planeRoute[0], destination = planeRoute[1];<br/><br/>  var obj = {};<br/><br/>  obj.od = [origin, destination];<br/><br/>  obj.startX = projection(airportMap.get(origin).geometry.coordinates)[0];<br/>  obj.startY = projection(airportMap.get(origin).geometry.coordinates)[1];<br/><br/>  obj.x = projection(airportMap.get(origin).geometry.coordinates)[0];<br/>  obj.y = projection(airportMap.get(origin).geometry.coordinates)[1];<br/><br/>  obj.route = null;<br/>  obj.wayPoints = [];<br/>  obj.currentIndex = 0;<br/><br/>  return obj;<br/><br/>}</pre>
<p style="padding-left: 60px">It returns an object holding the <kbd>startX</kbd> and <kbd>startY</kbd> positions it retrieves from the <kbd>airportMap</kbd> lookup you created earlier. It also has <kbd>x</kbd> and <kbd>y</kbd> coordinates representing the current position of the plane. For the first frame this is the same as <kbd>startX</kbd> and <kbd>startY.</kbd> It also holds an as yet empty object for the <kbd>route</kbd> path and the <kbd>wayPoints</kbd> we calculate next. Lastly, it has a <kbd>currentIndex</kbd> keeping track of the way point the plane is at when we change its position (this will become clearer very soon).</p>
<ul>
<li><strong>Drawing each plane's path</strong>:<strong> </strong>plane initialized. Now, let's get the path. Remember that we created two path generators during setup? One was a Canvas path to draw worlds, the airport, and plane circles. The other one – <kbd>pathSVG</kbd> – was for creating the route as an SVG path. Why would you want to do that? Because SVG paths have the great <kbd>.getTotalLength()</kbd> and <kbd>.getPointAtLength()</kbd> methods that make it easy to sample points from that path. Here's how to use D3 to create the path:</li>
</ul>
<pre style="padding-left: 60px">getPath: function(planeRoute) {<br/>  var origin = planeRoute[0], destination = planeRoute[1];<br/>  var pathElement = document.createElementNS(d3.namespaces.svg,<br/>  'path');<br/><br/>  var route = d3.select(pathElement)<br/>    .datum({<br/>      type: 'LineString',<br/>      coordinates: [<br/>         airportMap.get(origin).geometry.coordinates,<br/>         airportMap.get(destination).geometry.coordinates<br/>       ]<br/>    })<br/>    .attr('d', pathSVG);<br/><br/>    return route.node();<br/>}</pre>
<p style="padding-left: 60px">You won't create the path in the DOM, but only in memory and save it in the <kbd>pathElement</kbd> variable. As it's an SVG and not an HTML element, you need to specify the SVG namespace which you can do with D3's <kbd>.namespaces.svg</kbd> utility function. Then you create the path before returning the raw element rather than the D3 selection as <kbd>route.node()</kbd>.</p>
<ul>
<li><strong>Retrieving the way points</strong>:<strong> </strong>all set to calculate the way points. <kbd>getWayPoints()</kbd> takes the plane which by now has its path stored in the <kbd>plane.route</kbd> property. We use the path sampling functions we just praised on its path and return an array holding all way points for this specific plane's route path:</li>
</ul>
<pre style="padding-left: 90px">getWayPoints: function(plane) {<br/>  var arr = [];<br/>  var points = Math.floor(plane.route.getTotalLength() * 2.5);<br/><br/>  d3.range(points).forEach(function(el, i) {<br/>    var DOMPoints = plane.route.getPointAtLength(i/2.5);<br/>    arr.push({ x: DOMPoints.x, y: DOMPoints.y });<br/>  });<br/><br/>  return arr;<br/>}</pre>
<p style="padding-left: 60px">First, you create an empty array called <kbd>arr</kbd> which will hold all your way points. Then, you produce an integer saved in the <kbd>points</kbd> variable. This integer will represent the number of points we want to sample from the path. You get the total length of the path, which is represented by the number of pixels the path will take up. This, you multiply by <kbd>2.5</kbd>. This very factor is important and controls how many points will be sampled and hence how fast or slow the animation will be. The higher the number, the more points it will sample and the slower the animation will appear. If you choose a low number or even a fraction such as <em>0.1</em>, few points will be sampled and the animation will appear faster.</p>
<p style="padding-left: 60px">You use <kbd>d3.range(points).forEach()</kbd> to retrieve the coordinates returned as so-called <kbd>DOMPoints</kbd> by <kbd>.getPointAtLength()</kbd> at each point of the path. Then you push each of them into the array and voila, you have your way points.</p>
<p>Congratulations. You have just built a plane. In fact, you have built a plane and its route and all the points you need to make it jump to so that a viewer would think it flies. This is how it looks inside:</p>
<div><img height="237" width="228" src="img/ca50163d-84e0-461b-babd-943c3e5fe0f0.png"/></div>
<p>The plane flying from Frankfurt to Atlanta</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Animating the plane</h1>
                
            
            
                
<p>The rest is simple. You just need to apply the game loop to the canvas. We've already encountered this a few times; you create a function called <kbd>animate()</kbd> and let it run in a continuous loop:</p>
<pre>function animate() {<br/>  planes.clearPlanes(contextPlane);<br/>  planes.items.forEach(function(el) {<br/>    planes.updatePlane(el);<br/>    planes.drawPlane(contextPlane, el.x, el.y);<br/>  });<br/>  requestID = requestAnimationFrame(animate);<br/>}<br/><br/>requestAnimationFrame(animate);</pre>
<p>Note, that we added the used functions to the planes object as well, to keep all plane-related function code together.</p>
<p>First, we clear the canvas. <kbd>planes.clearPlanes()</kbd> literally just clears the context we pass to it.</p>
<p>Then we iterate through the <kbd>planes.items</kbd> array holding all planes and update each plane with <kbd>planes.updatePlane()</kbd>. We pass it the respective plane and it either moves the <kbd>x</kbd> and <kbd>y</kbd> coordinates to the start if the plane has reached its destination or it moves them to the next way point coordinate:</p>
<pre>updatePlane: function(plane) {<br/>  plane.currentIndex++;<br/>  if (plane.currentIndex &gt;= plane.wayPoints.length) {<br/>    plane.currentIndex = 0;<br/>    plane.x = plane.startX;<br/>    plane.y = plane.startY;<br/>  } else {<br/>    plane.x = plane.wayPoints[plane.currentIndex].x;<br/>    plane.y = plane.wayPoints[plane.currentIndex].y;<br/>  }<br/>}</pre>
<p>The use of <kbd>currentIndex</kbd> should become clearer here. It keeps track of where each plane is on its path as well as moving the plane forward by one way point on each update.</p>
<p>Finally, we draw the plane (this is where we realize we haven't built an actual plane but a <kbd>tomato</kbd> colored circle):</p>
<pre>drawPlane: function(ctx, x, y) {<br/>  ctx.beginPath();<br/>  ctx.fillStyle = 'tomato';<br/>  ctx.arc(x, y, 1, 0, 2*Math.PI);<br/>  ctx.fill();<br/>}</pre>
<p>Finally, you kick it off with <kbd>requestAnimationFrame()</kbd>. You can use <kbd>setInterval()</kbd> but you should use <kbd>requestAnimationFrame()</kbd> instead. It will allow the browser to choose the best time to trigger its callback before the next repaint. This is much more economical compared to the brute force <kbd>setInterval()</kbd>. It also has the additional benefit of interrupting the loop when the browser tab the app runs on is not in focus. Note also, that we save the <kbd>requestID</kbd> of each loop. You might remember that we use this unique ID to cancel the current loop with <kbd>cancelAnimationFrame(requestID)</kbd> when the user presses a button to set off a new loop.</p>
<p>Done. Well done.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Measuring the performance</h1>
                
            
            
                
<p>So far so good. But does it work? And if it works, does it work better than the SVG example? Let's recall that the SVG flight path visual gave us a whopping 60 FPS for 100 animated circles and a meager 6 FPS for some 5,000 animated circles. Let's start with 100 circles and focus on the <kbd>stats.js</kbd> measure in the top-left corner:</p>
<div><img height="486" width="770" src="img/d1367c00-7bfd-4a2b-b49f-a90f3d1a74d7.png"/></div>
<p>Canvas visualization of 100 flight paths at 60 FPS </p>
<p>View this step in the browser at: <a href="https://larsvers.github.io/learning-d3-mapping-9-2a">https://larsvers.github.io/learning-d3-mapping-9-2a</a>. Code example <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02a.html">09_02a.html</a>.</p>
<p>We expected 60 FPS. Let's go to 1,000 flights:</p>
<div><img height="487" width="770" src="img/2e04a0e3-eac8-4a50-a4ec-62b7ea6f2203.png"/></div>
<p>Canvas visualization of 1,000 flight paths at 60 FPS</p>
<p>Again, 60 FPS! 5,000 planes?</p>
<div><img height="483" width="771" src="img/a914d46d-9c9a-4d7c-9062-1c4b4f0f8c22.png"/></div>
<p>Canvas visualization of 5,000 flight paths at 45 FPS</p>
<p>It's going down, but still at 45 FPS keeping the animation fluid. Let's look at 10,000 flights:</p>
<div><img height="477" width="771" src="img/8fccd0c7-df9c-4e14-a37b-810eaae2305d.png"/></div>
<p>Canvas visualization of 10,000 flight paths at 23 FPS</p>
<div><p>We still see a frame rate similar to what you see when watching a movie with 23 FPS. However, let's try and squeeze out a bit more.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Optimizing performance</h1>
                
            
            
                
<div><p>Remember that we've used two canvases for this visual, one canvas to draw the static background scene with the map and the airports and one canvas for the dynamic flight animation. We did this because it kept drawing concerns separate.</p>
<p>Another reason for using an additional canvas is increased performance. We can use one canvas as an <strong>in-memory buffer</strong> to pre-render elements and just copy its contents onto the main visible canvas. This saves render costs as drawing on a visible canvas is less performant than drawing on a non-visible canvas to then copy over the image to the main canvas. Performance further rejoices as the context's <kbd>drawImage()</kbd> method we will use to copy over the image from the buffer to the display canvas, is hardware accelerated (meaning it uses the parallel processing powers of the GPU) by default.</p>
<p>For our little app, the animated elements are the plane circles. Instead of drawing them with the <kbd>drawPlane()</kbd> function for each update, we can first create a single image of a circle on a small buffer canvas and then use <kbd>drawImage()</kbd> to port it over to the <kbd>canvasPlane.</kbd></p>
<p>We create a single plane image in global scope:</p>
<pre>function createPlaneImage() {<br/>  var planeImg = document.createElement('canvas');<br/>  planeImg.width = planeImg.height = 2;<br/>  var contextPlaneImg = planeImg.getContext('2d');<br/>  contextPlaneImg.beginPath();<br/>  contextPlaneImg.fillStyle = 'tomato';<br/>  contextPlaneImg.arc(planeImg.width/2, planeImg.height/2, 1, 0,<br/>  2*Math.PI);<br/>  contextPlaneImg.fill();<br/>  return planeImg;<br/>}</pre>
<p>We create our buffer canvas called <kbd>planeImg</kbd> in thin air, set its <kbd>width</kbd> and <kbd>height</kbd> to <kbd>2</kbd> (double the plane's desired radius of <kbd>1</kbd>), and retrieve its context. We'll draw a <kbd>tomato</kbd> colored circle on it before we return it.</p>
<p>We call this function once when initializing the <kbd>planes</kbd> object and store it as an image in the <kbd>planes</kbd> object:</p>
<pre>var planes = {<br/>  items: [],<br/>  icon: createPlaneImage(),<br/>  getPlane: function(planeRoute) {<br/>  // ...</pre>
<p>Finally, we just have to remove our <kbd>drawPlane()</kbd> function we used to draw the circle on every update. Instead, we add a new function called <kbd>drawPlaneImage()</kbd> to the <kbd>planes</kbd> object that uses <kbd>drawImage()</kbd> to add our plane icon (the circle) to the context we determine:</p>
<pre>drawPlaneImage: function(ctx, x, y) {<br/>  ctx.drawImage(this.icon, x, y);   <br/>}</pre>
<p>Lastly, we don't call <kbd>drawImage()</kbd> in the <kbd>animate()</kbd> function, but <kbd>drawPlaneImage()</kbd>:</p>
<pre>function animate() {<br/>  planes.clearPlanes(contextPlane);<br/>  planes.items.forEach(function(el) {<br/>    planes.updatePlane(el);<br/>    planes.drawPlaneImage(contextPlane, el.x, el.y);<br/>  });<br/><br/>  requestID = requestAnimationFrame(animate);<br/>}</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuing with measuring performance</h1>
                
            
            
                
<p>Now let's check the frame rate for animating 10,000 points:</p>
<div><img height="484" width="770" src="img/aff3f428-0751-4728-842b-44d1d7b9bc84.png"/></div>
<p>Canvas visualization of 10,000 flight paths at 36 instead of 23 FPS </p>
<p>View complete app at: <a href="https://larsvers.github.io/learning-d3-mapping-9-2b">https://larsvers.github.io/learning-d3-mapping-9-2b</a>. Code example: <a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02b.html">09_02b.html</a>.</p>
<p>That's great, boosting performance by about +57% compared to not using the powers of <kbd>drawImage()</kbd>. It's not shown here, but 5,000 points were animated at 60 FPS instead of 45 FPS. Yay.</p>
<p>Moving on, 15,000 flights fly with 24 FPS and 20,000 with up to 18 FPS. This is still just beyond the 16 FPS generally considered the lowest possible frame rate for fooling the brain into believing a fluid animation. Even 25,000 planes still move with around 14 frames per second conveying a mild jank, while 30,000 flights stutter still only modestly at 12 FPS.</p>
<div><img height="485" width="771" src="img/0e1e2049-a745-45f5-a39b-dc83b29464cc.png"/></div>
<p>Canvas visualization of 30,000 flight paths at 12 FPS</p>
<p>While performance can vary with different browsers, CPU’s and GPU’s the jump from SVG to Canvas is significant!</p>
<p>With Canvas we have achieved our narrative mission to visualize regions of heavy flight activity. All of Europe seems to be in the air, as well as the east and west of the US and the east of China. Other continents show a line of increased air-activity along their costs. You might be surprised by the band of planes moving down through Thailand and Indonesia, although this is a densely-populated area.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, you have learned how to build a flight path visualization in SVG and in Canvas, bringing together much of what you have learned before. You have seen how it requires a different mental model to program animations with Canvas, probably best summarized by the game loop: process your data, clear the drawing, re-draw the animation. You have used D3 to set up the visualizations, but you have also seen that due to the different coding concept, Canvas might require you to step away a little from D3 core functionality like transitions. However, all that paid off by witnessing the power of Canvas when it comes to animation. Instead of being able to fluidly animate 1,000 points we managed to animate 15,000 points safely and 20,000 points still gracefully with optimized Canvas techniques.</p>
<p>After having seen the benefits of Canvas, let's now find a workaround for one of its caveats: interactivity!</p>


            

            
        
    </body></html>