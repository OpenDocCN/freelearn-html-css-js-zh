<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Mapping with Canvas and D3</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's time to leave our house and tree. </span><span class="koboSpan" id="kobo.2.2">I know it's sad, but we'll move on to potentially more exciting things to build. </span><span class="koboSpan" id="kobo.2.3">You covered a lot of ground in the previous chapter. </span><span class="koboSpan" id="kobo.2.4">You learned how to draw with Canvas, how to animate with Canvas, and a pattern to combine the D3 life cycle with Canvas. </span><span class="koboSpan" id="kobo.2.5">As D3 is usually in cahoots with SVG, you also learned about a few key differences between SVG and Canvas. </span><span class="koboSpan" id="kobo.2.6">Understanding the advantages and limitations of either approach is key to making informed decisions about which mode of rendering to use. </span><span class="koboSpan" id="kobo.2.7">Here's what we will go through in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">We'll start off with a summary of the key reasons for using either SVG or Canvas.</span></li>
<li><span class="koboSpan" id="kobo.4.1">We will then move on to review steps to build a flight path visualization with SVG, before building one with Canvas.</span></li>
<li><span class="koboSpan" id="kobo.5.1">Along the way, we will focus on measuring the performance to get a good understanding of how far we can go with either approach.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.6.1">This will further contrast and compare the two approaches conceptually and technically. </span><span class="koboSpan" id="kobo.6.2">It will also allow us to demonstrate the main reason for choosing Canvas over SVG – animation of a great many points.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Choosing Canvas or SVG</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">You have already seen some benefits and some challenges to overcome when working with either of the two rendering methods. </span><span class="koboSpan" id="kobo.2.2">This section is supposed to summarize the most important differences. </span><span class="koboSpan" id="kobo.2.3">As such, it should give you a good understanding of what to use in which circumstance. </span><span class="koboSpan" id="kobo.2.4">Note, that I am juxtaposing SVG and Canvas rather than HTML and SVG with Canvas. </span><span class="koboSpan" id="kobo.2.5">It seems appropriate to focus on SVG as it is D3's main building block due to its visualization advantages. </span><span class="koboSpan" id="kobo.2.6">However, the same logic applies to the equally retained HTML.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Reasons to choose SVG</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's first look at the SVG benefits:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">SVG is a vector-based graphics system. </span><span class="koboSpan" id="kobo.3.2">It allows resolution independent drawings you can scale without affecting quality.</span></li>
<li><span class="koboSpan" id="kobo.4.1">You can easily access elements in the DOM to move, change, or add interactivity.</span></li>
<li><span class="koboSpan" id="kobo.5.1">You can style with CSS.</span></li>
<li><span class="koboSpan" id="kobo.6.1">D3 works closely with the DOM, allowing for concise operations such as element selection and styling in a single pass and declarative animations with SVG.</span></li>
<li><span class="koboSpan" id="kobo.7.1">SVG is accessible to screen-readers and SEO bots out of the box. </span><span class="koboSpan" id="kobo.7.2">Canvas requires fallback text or a sub-DOM to provide some level of accessibility.</span></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Reasons to choose Canvas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">While SVG might be easier to handle, Canvas has advantages when it comes to showing and animating more elements:</span></p>
<ul>
<li><span><span class="koboSpan" id="kobo.3.1">SVG allows you to draw roughly 10,000 elements and animate 1,000 or so elements. </span><span class="koboSpan" id="kobo.3.2">With Canvas you can animate around 10,000 points. </span><span class="koboSpan" id="kobo.3.3">Why? </span><span class="koboSpan" id="kobo.3.4">First of all, </span></span><span class="koboSpan" id="kobo.4.1">Canvas is lower level and has fewer abstraction layers to keep and manage in memory. </span><span class="koboSpan" id="kobo.4.2">Secondly, browsers (like most monitors) mostly support a frame rate of 60 frames per second, meaning the screen is updated 60 times per second. </span><span class="koboSpan" id="kobo.4.3">This leaves</span><span><span class="koboSpan" id="kobo.5.1"> </span></span><em><span class="koboSpan" id="kobo.6.1">1000 / 60 = 16.67</span></em><span><span class="koboSpan" id="kobo.7.1"> </span></span><span class="koboSpan" id="kobo.8.1">milliseconds to finish all necessary rendering and housekeeping activities. </span><span class="koboSpan" id="kobo.8.2">As human brains are fooled into perceiving fluid animation at a mere 16 frames per second, the maximum time for rendering a frame is</span><span><span class="koboSpan" id="kobo.9.1"> </span></span><em><span class="koboSpan" id="kobo.10.1">1000 / 16 = 62.5</span></em><span><span class="koboSpan" id="kobo.11.1"> </span></span><span class="koboSpan" id="kobo.12.1">milliseconds — but you should strive for a shorter time. </span><span class="koboSpan" id="kobo.12.2">For SVG these activities include DOM parsing, render tree production, layout and screen painting, to name the most important. </span><span class="koboSpan" id="kobo.12.3">The path between Canvas changes and image is shorter. </span><span class="koboSpan" id="kobo.12.4">The browser turns the context instructions into an array of pixel values before painting it to the canvas.</span></li>
<li><span class="koboSpan" id="kobo.13.1">If you need more elements to render or animate, accessing the alternative WebGL context is as easy as defining</span><span><span class="koboSpan" id="kobo.14.1"> </span></span><kbd><span class="koboSpan" id="kobo.15.1">canvas.getContext(‘webgl')</span></kbd><span class="koboSpan" id="kobo.16.1">. </span><span class="koboSpan" id="kobo.16.2">WebGL allows you to animate 100k elements and more. </span><span class="koboSpan" id="kobo.16.3">While WebGL code is close to GPU programming and hence not for the faint-hearted, abstraction libraries like</span><span><span class="koboSpan" id="kobo.17.1"> </span></span><kbd><span class="koboSpan" id="kobo.18.1">Three.js</span></kbd><span class="koboSpan" id="kobo.19.1">,</span><span><span class="koboSpan" id="kobo.20.1"> </span></span><kbd><span class="koboSpan" id="kobo.21.1">Pixi.js</span></kbd><span class="koboSpan" id="kobo.22.1">,</span><span><span class="koboSpan" id="kobo.23.1"> </span></span><span class="koboSpan" id="kobo.24.1">or</span><span><span class="koboSpan" id="kobo.25.1"> </span></span><kbd><span class="koboSpan" id="kobo.26.1">regl</span></kbd><span><span class="koboSpan" id="kobo.27.1"> </span></span><span class="koboSpan" id="kobo.28.1">make it more accessible.</span></li>
</ul>
<div class="packt_tip"><span><span class="koboSpan" id="kobo.29.1">Check out Peter Beshai's excellent tutorial on animating 100,000 points with WebGl and regl at </span></span><a href="https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html"><span class="koboSpan" id="kobo.30.1">https://peterbeshai.com/beautifully-animate-points-with-webgl-and-regl.html</span></a><span><span class="koboSpan" id="kobo.31.1">.</span></span></div>
<ul>
<li><span class="koboSpan" id="kobo.32.1">Canvas is a </span><strong><span class="koboSpan" id="kobo.33.1">rasterized</span></strong><span class="koboSpan" id="kobo.34.1"> graphics system. </span><span class="koboSpan" id="kobo.34.2">This just means the image consists of a </span><em><span class="koboSpan" id="kobo.35.1">raster</span></em><span class="koboSpan" id="kobo.36.1"> (we could also say a </span><em><span class="koboSpan" id="kobo.37.1">matrix</span></em><span class="koboSpan" id="kobo.38.1">) of pixels. </span><span class="koboSpan" id="kobo.38.2">As a result, scaling can lead to blur, but in turn it's simple to download your canvas as an image. </span><span class="koboSpan" id="kobo.38.3">A further problem are high </span><span><strong><span class="koboSpan" id="kobo.39.1">Dots Per Inch</span></strong><span class="koboSpan" id="kobo.40.1"> (</span></span><strong><span class="koboSpan" id="kobo.41.1">DPI</span></strong><span class="koboSpan" id="kobo.42.1">) or retina screens, that can make Canvas blur. </span><span class="koboSpan" id="kobo.42.2">You can use the following setup to support retina displays on Canvas:</span></li>
</ul>
<pre style="padding-left: 60px"><span><span class="koboSpan" id="kobo.43.1">var devicePixelRatio = window.devicePixelRatio || 1</span><br/></span><span><span class="koboSpan" id="kobo.44.1">var canvas = d3.select(‘body').append(‘canvas')</span><br/></span><span><span class="koboSpan" id="kobo.45.1">    .attr(‘width', width * devicePixelRatio)</span><br/></span><span><span class="koboSpan" id="kobo.46.1">    .attr(‘height', height * devicePixelRatio)</span><br/></span><span><span class="koboSpan" id="kobo.47.1">    .style(‘width', width + ‘px')</span><br/></span><span><span class="koboSpan" id="kobo.48.1">    .style(‘height', height + ‘px');</span><br/></span><span><span class="koboSpan" id="kobo.49.1">var context = canvas.getContext(‘2d');</span><br/></span><span><span class="koboSpan" id="kobo.50.1">context.scale(devicePixelRatio, devicePixelRatio);</span></span></pre>
<p><span class="koboSpan" id="kobo.51.1">Considering this, it seems a wise choice to stick to SVG for as long as possible and pull Canvas out of the hat when many elements need to be drawn or moved around. </span><span class="koboSpan" id="kobo.51.2">You might want to keep things simple until they can't be. </span><span class="koboSpan" id="kobo.51.3">One not-so-simple case could be the animation of a great many points. </span><span class="koboSpan" id="kobo.51.4">Let's look at an example that demonstrates the performance benefits Canvas has by building an element-heavy, animated application first with SVG and then with Canvas.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Visualizing flight paths with Canvas and D3</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Data can come with a great many number of individual data points. </span><span class="koboSpan" id="kobo.2.2">Maps especially can be the playground for large datasets. </span><span class="koboSpan" id="kobo.2.3">While it might be tempting to visualize features of a dataset as individual elements, in explanatory data visualization especially it often makes sense to aggregate data to bring across a single point well. </span><span class="koboSpan" id="kobo.2.4">While Canvas allows you to show and animate many points, it is power you might want to use responsibly.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Having said that, it can often be mesmerizing to watch dynamic data unfold as well as bringing across a specific point. </span><span class="koboSpan" id="kobo.3.2">Combining user engagement with concise learnings is of course a great plus you should leverage if possible. </span><span class="koboSpan" id="kobo.3.3">Considering map data, there are a great many examples of dynamic visualizations with numerous animated elements, such as natural elements like winds or ocean currents, cultural elements like spreading ideas or inventions, as well technical elements like cars, ships, or airplanes. </span><span class="koboSpan" id="kobo.3.4">In this section, we will jump on the latter and visualize flight paths.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Our aim will be two-fold. </span><span class="koboSpan" id="kobo.4.2">Firstly, we want to build a map visualization with many animated elements – not just for the sake of showing many elements, but the detail we show should facilitate the understanding of the visual. </span><span class="koboSpan" id="kobo.4.3">Secondly, we want to compare the performance between SVG and Canvas. </span><span class="koboSpan" id="kobo.4.4">We have described it theoretically in a previous section, but let's get practical now.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Here's what we will build:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1"><img height="376" width="738" src="assets/15f41f3a-8672-433a-88c4-8a0c805a3659.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1">1,000 flight paths visualized. </span><span class="koboSpan" id="kobo.7.2">Each red dot is an animated plane (promise!)</span></div>
<p><span class="koboSpan" id="kobo.8.1">There are three main element categories we will draw: </span><em><span class="koboSpan" id="kobo.9.1">the world, airports</span></em><span class="koboSpan" id="kobo.10.1"> (the white dots, consciously kept in the background as they are of only supporting importance), and the </span><em><span class="koboSpan" id="kobo.11.1">planes</span></em><span class="koboSpan" id="kobo.12.1"> (the red dots). </span><span class="koboSpan" id="kobo.12.2">Representing real planes, our red dots are animated along their very own flight path flying from their origin to their destination. </span><span class="koboSpan" id="kobo.12.3">Here's an image showing the paths our planes follow:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img height="411" width="775" src="assets/6df407f2-f612-4734-adc7-16dc5c59dc86.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1">100 flights showing the route paths and their respective planes</span></div>
<p><span class="koboSpan" id="kobo.15.1">The source data for this visual includes over 65,000 worldwide routes flying to and from just over 7,000 airports. </span><span class="koboSpan" id="kobo.15.2">We won't be able to animate all these routes, not even with Canvas. </span><span class="koboSpan" id="kobo.15.3">The aim of our visualization will rather be to show as many as we can to convey an immediate visual understanding of active versus less active flight regions as well as oft-used versus lesser-used routes.</span></p>
<p><span class="koboSpan" id="kobo.16.1">At the bottom of the visual we will show a row of buttons:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img height="50" width="772" src="assets/c602cbc1-4402-4fb7-a5b0-0d0e0bf040af.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1"> Buttons to kick off the animation</span></div>
<p><span class="koboSpan" id="kobo.19.1">These buttons will allow the user to set the number of flights to be displayed at once. </span><span class="koboSpan" id="kobo.19.2">Importantly, this will not be real time or replayed time. </span><span class="koboSpan" id="kobo.19.3">We won't bring in any flight schedules, showing flights at the time of day/date they depart or arrive, we will show all flights at the same time! </span><span class="koboSpan" id="kobo.19.4">Firstly, this supports the visualization aims described previously and secondly, it will help test performance because as many elements as possible are being animated at the same time.</span></p>
<p><span class="koboSpan" id="kobo.20.1">To test browser performance, we shall add a small information box from </span><kbd><span class="koboSpan" id="kobo.21.1">stats.js</span></kbd><span class="koboSpan" id="kobo.22.1"> at the top left of our app. </span><span class="koboSpan" id="kobo.22.2">Once dropped into your code, this nifty info tool displays page performance measures on your page, of which we will be mainly interested in </span><strong><span class="koboSpan" id="kobo.23.1">frames per second</span></strong><span class="koboSpan" id="kobo.24.1"> (</span><strong><span class="koboSpan" id="kobo.25.1">FPS</span></strong><span class="koboSpan" id="kobo.26.1">). </span><span class="koboSpan" id="kobo.26.2">You will see it soon in action, but this is how it looks magnified indicating 60 frames per second:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.27.1"><img height="49" width="81" src="assets/e03b7b04-6e56-407e-b2cd-8536647e006d.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The data</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">According to the three element categories we want to represent, we need three data sources to build the visual. </span><span class="koboSpan" id="kobo.2.2">The map data, data about airport locations, as well as flight data, showing origins and destinations for each flight. </span><span class="koboSpan" id="kobo.2.3">We will call this the </span><strong><span class="koboSpan" id="kobo.3.1">route data</span></strong><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Both datasets come from </span><a href="https://openflights.org/"><span class="koboSpan" id="kobo.5.1">openflights.org</span></a><span class="koboSpan" id="kobo.6.1"> which offers a tool you can use to map flights as well as databases for flights worldwide including routes and airport location data. </span><span class="koboSpan" id="kobo.6.2">This is exactly what we're after.</span></p>
<p class="mce-root"><span class="koboSpan" id="kobo.7.1">After light cleaning and minor modifications, the first 10 entries of the route data and the airport location data with 100 flights look as follows:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1"><img height="266" width="488" src="assets/09edba9a-51fb-4a11-a87f-a4a9421e33a5.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.9.1"> The route and the airport data</span></div>
<p><span class="koboSpan" id="kobo.10.1">All variable names are self-explanatory. </span><span class="koboSpan" id="kobo.10.2">Note that the first variable in the airport data, </span><em><span class="koboSpan" id="kobo.11.1">i</span></em><em><span class="koboSpan" id="kobo.12.1">ata</span></em><em><span class="koboSpan" id="kobo.13.1">,</span></em><span class="koboSpan" id="kobo.14.1"> represents the official three-letter airport code from the </span><strong><span class="koboSpan" id="kobo.15.1">International Air Transport Association</span></strong><span class="koboSpan" id="kobo.16.1"> (</span><strong><span class="koboSpan" id="kobo.17.1">IATA</span></strong><span class="koboSpan" id="kobo.18.1">). </span><span class="koboSpan" id="kobo.18.2">Also note that we had to remove some flights per dataset as not every airport location was available, which in fact leads to a lower number (less than 2-3%) of flights than the buttons suggest.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Building the flight path map in SVG</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Our focus in this chapter will be on mapping with Canvas as well as on a benchmark of Canvas against SVG animation. </span><span class="koboSpan" id="kobo.2.2">In order to spend our time and effort wisely, I have pre-built an SVG map we can use as a benchmark, leaving us the rest of the chapter to focus on how to build the Canvas flight path app. </span><span class="koboSpan" id="kobo.2.3">The chapter is called </span><em><span class="koboSpan" id="kobo.3.1">Mapping with </span><strong><span class="koboSpan" id="kobo.4.1">Canvas</span></strong><span class="koboSpan" id="kobo.5.1"> and D3</span></em><span class="koboSpan" id="kobo.6.1"> after all...</span></p>
<p><span class="koboSpan" id="kobo.7.1">Nonetheless, let's have a quick look at the steps we would take to build this app with SVG. </span><span class="koboSpan" id="kobo.7.2">There are roughly eight logical steps to follow:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.8.1">You set up the map with a container SVG, as well as the projection and the path generator for the map</span></li>
<li><span class="koboSpan" id="kobo.9.1">You load the map data and draw the map</span></li>
<li><span class="koboSpan" id="kobo.10.1">You listen to button events and load in the appropriate dataset depending on the button pressed</span></li>
<li><span class="koboSpan" id="kobo.11.1">You draw the airports</span></li>
<li><span class="koboSpan" id="kobo.12.1">You calculate each plane’s origin and destination position as well as compute a path from origin to destination</span></li>
<li><span class="koboSpan" id="kobo.13.1">You sample points along each plane’s path and store them in an array (we’ll call them </span><em><span class="koboSpan" id="kobo.14.1">way points</span></em><span class="koboSpan" id="kobo.15.1">)</span></li>
<li><span class="koboSpan" id="kobo.16.1">Using D3, you transition each plane along its path</span></li>
<li><span class="koboSpan" id="kobo.17.1">Once each plane has reached its destination, you let the transition start again</span></li>
</ol>
<p><span class="koboSpan" id="kobo.18.1">Now that we have conjured up our SVG flight path visual, let's see how many planes we can set off without any problems.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Measuring the performance</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So here it is – let's make some planes fly. </span><span class="koboSpan" id="kobo.2.2">We should start modestly and try with 100 routes:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="478" width="751" src="assets/3a6bcd3b-ff61-4ea7-9fde-77ffc0c51fab.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1">SVG visualization of 100 flight paths at 60 FPS</span></div>
<p><span class="koboSpan" id="kobo.5.1">See the frame rate in the top-left corner? </span><span class="koboSpan" id="kobo.5.2">It's a bit small but we're still very happy with it! </span><span class="koboSpan" id="kobo.5.3">Displaying 60 frames per second is perfect. </span><span class="koboSpan" id="kobo.5.4">1,000 flights will give us up to 40 frames per seconds. </span><span class="koboSpan" id="kobo.5.5">This is a drop, but the animation remains smooth. </span><span class="koboSpan" id="kobo.5.6">However, even at 1,000 flights we can’t really see any major clusters of flight activity. </span><span class="koboSpan" id="kobo.5.7">So, let’s try 5,000 flights at the same time:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1"><img height="461" width="751" src="assets/e2e784cf-5c22-4ced-b89e-9770c8f440fc.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1">SVG visualization of 5,000 flight paths at 6 FPS</span></div>
<p><span class="koboSpan" id="kobo.8.1">Our performance crashed to 6 FPS. </span><span class="koboSpan" id="kobo.8.2">While this static image brings us closer to our visualization aim of identifying regions of high flight traffic, it's no fun to view the janking animation. </span><span class="koboSpan" id="kobo.8.3">Canvas to the rescue.</span></p>
<div class="packt_infobox"><span class="koboSpan" id="kobo.9.1">View this step in the browser at: </span><a href="https://larsvers.github.io/learning-d3-mapping-9-1"><span class="koboSpan" id="kobo.10.1">https://larsvers.github.io/learning-d3-mapping-9-1</span></a><span class="koboSpan" id="kobo.11.1">. </span><span><span class="koboSpan" id="kobo.12.1">Code example </span></span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_01.html"><span class="koboSpan" id="kobo.13.1">09_01.html</span></a><span><span class="koboSpan" id="kobo.14.1">. </span><span class="koboSpan" id="kobo.14.2">I recommend to use a recent version of Chrome to view and work on the examples of this chapter. </span></span></div>
<div class="packt_tip">
<p><span class="koboSpan" id="kobo.15.1">At </span><span><span class="koboSpan" id="kobo.16.1">the conclusion of each step you will find two links in an info box close to the the relevant image</span></span><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">The first link brings you to a working implementation of this step that you can view in the browser. </span><span class="koboSpan" id="kobo.17.3">The second</span><span><span class="koboSpan" id="kobo.18.1"> </span></span><em><span class="koboSpan" id="kobo.19.1">code example</span></em><span><span class="koboSpan" id="kobo.20.1"> </span></span><span class="koboSpan" id="kobo.21.1">link brings you to the full code. </span><span class="koboSpan" id="kobo.21.2">If you're reading the print version, you can find all code examples at</span><span><span class="koboSpan" id="kobo.22.1"> </span></span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping"><span class="koboSpan" id="kobo.23.1">https://github.com/larsvers/Learning-D3.js-4-Mapping</span></a><span><span class="koboSpan" id="kobo.24.1"> </span></span><span class="koboSpan" id="kobo.25.1">in their relevant chapter.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Building the flight path map in Canvas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's start with an overview of our Canvas application before we take it apart.</span></p>
<p><span class="koboSpan" id="kobo.3.1">It's best to quickly get the HTML out of the way as it couldn't be much simpler. </span><span class="koboSpan" id="kobo.3.2">We have a </span><kbd><span class="koboSpan" id="kobo.4.1">div</span></kbd><span class="koboSpan" id="kobo.5.1"> for the canvas at hand as well as our buttons:</span></p>
<pre><span class="koboSpan" id="kobo.6.1">&lt;div id="canvas-map"&gt;&lt;/div&gt;</span><br/><span class="koboSpan" id="kobo.7.1">&lt;div id="controls"&gt;</span><br/><span class="koboSpan" id="kobo.8.1">    &lt;div class="flight-select" id="button-header"&gt;Pick number of flights:&lt;/div&gt;</span><br/><span class="koboSpan" id="kobo.9.1">    &lt;button class="flight-select" data-flights="100"&gt;100&lt;/button&gt;</span><br/><span class="koboSpan" id="kobo.10.1">    &lt;button class="flight-select" data-flights="1000"&gt;1,000&lt;/button&gt;</span><br/><span class="koboSpan" id="kobo.11.1">    &lt;button class="flight-select" data-flights="5000"&gt;5,000&lt;/button&gt;</span><br/><span class="koboSpan" id="kobo.12.1">    &lt;button class="flight-select" data-flights="10000"&gt;10,000&lt;/button&gt;</span><br/><span class="koboSpan" id="kobo.13.1">    &lt;button class="flight-select" data-flights="15000"&gt;15,000&lt;/button&gt;</span><br/><span class="koboSpan" id="kobo.14.1">    &lt;button class="flight-select" data-flights="20000"&gt;20,000&lt;/button&gt;</span><br/><span class="koboSpan" id="kobo.15.1">    &lt;button class="flight-select" data-flights="25000"&gt;25,000&lt;/button&gt;</span><br/><span class="koboSpan" id="kobo.16.1">    &lt;button class="flight-select" data-flights="30000"&gt;30,000&lt;/button&gt;</span><br/><span class="koboSpan" id="kobo.17.1">&lt;/div&gt;</span></pre>
<p><span class="koboSpan" id="kobo.18.1">Note that each button gets the same class selector as well as a </span><kbd><span class="koboSpan" id="kobo.19.1">data-flights</span></kbd><span class="koboSpan" id="kobo.20.1"> attribute to pass on the number of flights each button represents. </span><span class="koboSpan" id="kobo.20.2">You will use this in a moment to load the right dataset!</span></p>
<p><span class="koboSpan" id="kobo.21.1">Now let's look at the steps we take in the JavaScript to build this app in Canvas and see what changes to the flow we described previously for the SVG app. </span><span class="koboSpan" id="kobo.21.2">I have </span><strong><span class="koboSpan" id="kobo.22.1">highlighted</span></strong><span class="koboSpan" id="kobo.23.1"> the parts we change for the Canvas flow and have removed the SVG parts (</span><span><span class="koboSpan" id="kobo.24.1">in </span></span><span class="koboSpan" id="kobo.25.1">brackets):</span></p>
<ol>
<li><span class="koboSpan" id="kobo.26.1">You set up the </span><strong><span class="koboSpan" id="kobo.27.1">Canvas and the context</span></strong><span class="koboSpan" id="kobo.28.1"> (instead of a container SVG), as well as the projection and the path generator for the map</span></li>
<li><span class="koboSpan" id="kobo.29.1">You load the map data and draw the map</span></li>
<li><span class="koboSpan" id="kobo.30.1">You listen to button events and load in the appropriate dataset depending on the button pressed</span></li>
<li><span class="koboSpan" id="kobo.31.1">You draw the airports </span><strong><span class="koboSpan" id="kobo.32.1">and the world</span></strong><span class="koboSpan" id="kobo.33.1">, as they are on the same Canvas and a redraw is cheap</span></li>
<li><span class="koboSpan" id="kobo.34.1">You calculate each plane’s origin and destination position as well as compute a path from origin to destination</span></li>
<li><span class="koboSpan" id="kobo.35.1">You sample </span><em><span class="koboSpan" id="kobo.36.1">way points</span></em><span class="koboSpan" id="kobo.37.1"> along each plane’s path and store them in an array</span></li>
<li><strong><span class="koboSpan" id="kobo.38.1">You set off the game loop </span></strong><span class="koboSpan" id="kobo.39.1">(instead of using D3 transitions)</span><strong><span class="koboSpan" id="kobo.40.1">:</span></strong>
<ol>
<li><span class="koboSpan" id="kobo.41.1">clear the Canvas</span></li>
<li><span class="koboSpan" id="kobo.42.1">update the position</span></li>
<li><span class="koboSpan" id="kobo.43.1">draw the planes </span></li>
</ol>
</li>
</ol>
<ol start="8">
<li><span class="koboSpan" id="kobo.44.1">In the SVG example we restart a transition, once each plane has reached its destination. </span><span class="koboSpan" id="kobo.44.2">In our Canvas app this is part of the </span><strong><span class="koboSpan" id="kobo.45.1">update step in the game loop</span></strong><span class="koboSpan" id="kobo.46.1">.</span></li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Setting up the map</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">First, we set up a few global variables:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">var width = 1000,</span><br/><span class="koboSpan" id="kobo.4.1">    height = 600,</span><br/><span class="koboSpan" id="kobo.5.1">    countries,</span><br/><span class="koboSpan" id="kobo.6.1">    airportMap,</span><br/><span class="koboSpan" id="kobo.7.1">    requestID;</span></pre>
<p><kbd><span class="koboSpan" id="kobo.8.1">width</span></kbd><span class="koboSpan" id="kobo.9.1"> and </span><kbd><span class="koboSpan" id="kobo.10.1">height</span></kbd><span class="koboSpan" id="kobo.11.1"> speak for themselves. </span><span class="koboSpan" id="kobo.11.2">Countries will hold the GeoJSON data to draw the globe, which needs to be reached from various function scopes. </span><span class="koboSpan" id="kobo.11.3">Hence, it's easier to define it as a global variable in this small app. </span><kbd><span class="koboSpan" id="kobo.12.1">airportMap</span></kbd><span class="koboSpan" id="kobo.13.1"> will allow us to join the airport with the routes data by the three-letter IATA code. </span><kbd><span class="koboSpan" id="kobo.14.1">requestID</span></kbd><span class="koboSpan" id="kobo.15.1"> will be filled by our loop function </span><kbd><span class="koboSpan" id="kobo.16.1">requestAnimationFrom()</span></kbd><span class="koboSpan" id="kobo.17.1"> and used to cancel the current loop. </span><span class="koboSpan" id="kobo.17.2">We shall get to this in no time.</span></p>
<p><span class="koboSpan" id="kobo.18.1">We then set up the two contexts: a context for the world and a context for the planes. </span><span class="koboSpan" id="kobo.18.2">This little extra work at the beginning makes our life much easier later. </span><span class="koboSpan" id="kobo.18.3">If we drew the world and the planes on the same context, we would have to update both the world and the planes every time a plane flies a short distance. </span><span class="koboSpan" id="kobo.18.4">Keeping the world on a separate canvas means we only have to draw the world once and can leave that image/context untouched:</span></p>
<pre><span class="koboSpan" id="kobo.19.1">var canvasWorld = d3.select('#canvas-map').append('canvas')</span><br/><span class="koboSpan" id="kobo.20.1">  .attr('id', 'canvas-world')</span><br/><span class="koboSpan" id="kobo.21.1">  .attr('width', width)</span><br/><span class="koboSpan" id="kobo.22.1">  .attr('height', height);</span><br/><br/><span class="koboSpan" id="kobo.23.1">var contextWorld = canvasWorld.node().getContext('2d');</span><br/><br/><span class="koboSpan" id="kobo.24.1">var canvasPlane = d3.select('#canvas-map').append('canvas')</span><br/><span class="koboSpan" id="kobo.25.1">  .attr('id', 'canvas-plane')</span><br/><span class="koboSpan" id="kobo.26.1">  .attr('width', width)</span><br/><span class="koboSpan" id="kobo.27.1">  .attr('height', height);</span><br/><br/><span class="koboSpan" id="kobo.28.1">var contextPlane = canvasPlane.node().getContext('2d');</span></pre>
<p><span class="koboSpan" id="kobo.29.1">We use absolute CSS positioning for the canvases to stack them perfectly on top of each other:</span></p>
<pre><span class="koboSpan" id="kobo.30.1">#canvas-world, #canvas-plane {</span><br/><span class="koboSpan" id="kobo.31.1">  position: absolute;</span><br/><span class="koboSpan" id="kobo.32.1">  top: 0;</span><br/><span class="koboSpan" id="kobo.33.1">  left: 0;</span><br/><span class="koboSpan" id="kobo.34.1">}</span></pre>
<p><span class="koboSpan" id="kobo.35.1">Next, we set up the </span><kbd><span class="koboSpan" id="kobo.36.1">projection</span></kbd><span class="koboSpan" id="kobo.37.1">:</span></p>
<pre><span class="koboSpan" id="kobo.38.1">var projection = d3.geoRobinson()</span><br/><span class="koboSpan" id="kobo.39.1">    .scale(180)</span><br/><span class="koboSpan" id="kobo.40.1">    .translate([width / 2, height / 2]);</span><br/><br/></pre>
<p><span class="koboSpan" id="kobo.41.1">Please note that instead of playing with </span><kbd><span class="koboSpan" id="kobo.42.1">.scale()</span></kbd><span class="koboSpan" id="kobo.43.1"> and </span><kbd><span class="koboSpan" id="kobo.44.1">.translate()</span></kbd><span class="koboSpan" id="kobo.45.1"> to center and fit your projection, you can use the D3 convenience methods  </span><kbd><span class="koboSpan" id="kobo.46.1">.fitExtent()</span></kbd><span class="koboSpan" id="kobo.47.1"> or </span><kbd><span class="koboSpan" id="kobo.48.1">.fitSize()</span></kbd><span class="koboSpan" id="kobo.49.1">. </span><span class="koboSpan" id="kobo.49.2">You pass them your viz dimensions and the GeoJSON object you want to project and it calculates the best scale and translation for you.</span></p>
<p><span class="koboSpan" id="kobo.50.1">Also notice that we don't use the omnipresent </span><em><span class="koboSpan" id="kobo.51.1">Mercator</span></em><span class="koboSpan" id="kobo.52.1"> projection but the </span><em><span class="koboSpan" id="kobo.53.1">Robinson</span></em><span class="koboSpan" id="kobo.54.1"> projection for our world map. </span><span class="koboSpan" id="kobo.54.2">It has the advantage of drawing the world in a slightly more realistic way in terms of country size proportions. </span><span class="koboSpan" id="kobo.54.3">The </span><em><span class="koboSpan" id="kobo.55.1">Robinson </span></em><span class="koboSpan" id="kobo.56.1">and many more non-standard projections can be found in the additional </span><em><span class="koboSpan" id="kobo.57.1">d3-geo-projection module</span></em><span class="koboSpan" id="kobo.58.1">. </span></p>
<p><span class="koboSpan" id="kobo.59.1">Now we need a path generator. </span><span class="koboSpan" id="kobo.59.2">In fact, you will need to build two path generators:</span></p>
<pre><span class="koboSpan" id="kobo.60.1">var pathSVG = d3.geoPath()</span><br/><span class="koboSpan" id="kobo.61.1">    .projection(projection);</span><br/><br/><span class="koboSpan" id="kobo.62.1">var pathCanvas = d3.geoPath()</span><br/><span class="koboSpan" id="kobo.63.1">    .projection(projection)</span><br/><span class="koboSpan" id="kobo.64.1">    .pointRadius(1)</span><br/><span class="koboSpan" id="kobo.65.1">    .context(contextWorld);</span></pre>
<p><kbd><span class="koboSpan" id="kobo.66.1">pathSVG</span></kbd><span class="koboSpan" id="kobo.67.1"> will be used to generate the flight path in memory. </span><span class="koboSpan" id="kobo.67.2">We want to do that in SVG as it comes with handy methods to calculate its length and sample points from it. </span><kbd><span class="koboSpan" id="kobo.68.1">pathCanvas</span></kbd><span class="koboSpan" id="kobo.69.1"> will be used to draw our </span><kbd><span class="koboSpan" id="kobo.70.1">geo</span></kbd><span class="koboSpan" id="kobo.71.1"> data to the screen. </span><span class="koboSpan" id="kobo.71.2">Note that we add </span><kbd><span class="koboSpan" id="kobo.72.1">d3.geoPath()</span></kbd><span class="koboSpan" id="kobo.73.1">'s </span><kbd><span class="koboSpan" id="kobo.74.1">.context()</span></kbd><span class="koboSpan" id="kobo.75.1"> method and pass it our </span><kbd><span class="koboSpan" id="kobo.76.1">contextWorld</span></kbd><span class="koboSpan" id="kobo.77.1">. </span><span class="koboSpan" id="kobo.77.2">If we pass a Canvas context to this </span><kbd><span class="koboSpan" id="kobo.78.1">.contex</span><span><span class="koboSpan" id="kobo.79.1">t</span></span><span class="koboSpan" id="kobo.80.1">()</span></kbd><span class="koboSpan" id="kobo.81.1"> method, the path generator will return a Canvas path for the passed context. </span><span class="koboSpan" id="kobo.81.2">If it's not specified it will return an SVG path string. </span><span class="koboSpan" id="kobo.81.3">You can think of it as a switch button to tell D3 which renderer to use.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing the map and listening for user input</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">As with the SVG process, we start by loading the data in:</span></p>
<pre><span class="koboSpan" id="kobo.3.1">d3.json('data/countries.topo.json', function(error, world) {</span><br/><span class="koboSpan" id="kobo.4.1">  if (error) throw error;</span><br/><span class="koboSpan" id="kobo.5.1">  d3.select('div#controls').style('top', height + 'px');</span><br/><span class="koboSpan" id="kobo.6.1">  countries = topojson.feature(world, world.objects.countries); // GeoJSON;</span><br/><span class="koboSpan" id="kobo.7.1">  drawMap(countries);</span></pre>
<p><span class="koboSpan" id="kobo.8.1">We then do a bit of housekeeping and move the buttons in the </span><kbd><span class="koboSpan" id="kobo.9.1">div#controls</span></kbd><span class="koboSpan" id="kobo.10.1"> below the canvases. </span><span class="koboSpan" id="kobo.10.2">You recode the TopoJSON to GeoJSON features and save the data as a global variable before you draw the map:</span></p>
<pre><span class="koboSpan" id="kobo.11.1">function drawMap(world) {</span><br/><span class="koboSpan" id="kobo.12.1">  countries.features.forEach(function(el, i) {</span><br/><br/><span class="koboSpan" id="kobo.13.1">    contextWorld.beginPath();</span><br/><span class="koboSpan" id="kobo.14.1">    pathCanvas(el);</span><br/><span class="koboSpan" id="kobo.15.1">    contextWorld.fillStyle = '#ccc';</span><br/><span class="koboSpan" id="kobo.16.1">    contextWorld.fill();</span><br/>    <br/><span class="koboSpan" id="kobo.17.1">    contextWorld.beginPath();</span><br/><span class="koboSpan" id="kobo.18.1">    pathCanvas(el);</span><br/><span class="koboSpan" id="kobo.19.1">    contextWorld.strokeStyle = '#fff';</span><br/><span class="koboSpan" id="kobo.20.1">    contextWorld.lineWidth = 1;</span><br/><span class="koboSpan" id="kobo.21.1">    contextWorld.stroke();</span><br/><br/><span class="koboSpan" id="kobo.22.1">  });</span><br/><span class="koboSpan" id="kobo.23.1">}</span></pre>
<p><span class="koboSpan" id="kobo.24.1">Thanks to D3's versatile path generator, this is all it needs to draw the world. </span><span class="koboSpan" id="kobo.24.2">Easy!</span></p>
<p><span class="koboSpan" id="kobo.25.1">Back in our asynchronous </span><kbd><span class="koboSpan" id="kobo.26.1">d3.json()</span></kbd><span class="koboSpan" id="kobo.27.1"> data load function, you'll handle the button events next. </span><span class="koboSpan" id="kobo.27.2">Remember, nothing has happened yet, but as soon as the user hits a button, the animation should kick off.</span></p>
<p><span class="koboSpan" id="kobo.28.1">You attach a mouse-down listener to all buttons:</span></p>
<pre><span class="koboSpan" id="kobo.29.1">d3.selectAll('button.flight-select').on('mousedown', handleFlights);</span></pre>
<p><span class="koboSpan" id="kobo.30.1">Proceed with writing the handler:</span></p>
<pre><span class="koboSpan" id="kobo.31.1">function handleFlights() {</span><br/><span class="koboSpan" id="kobo.32.1">  d3.selectAll('button').style('background-color', '#f7f7f7');</span><br/><span class="koboSpan" id="kobo.33.1">  d3.select(this).style('background-color', '#ddd');</span><br/><br/><span class="koboSpan" id="kobo.34.1">  if (requestID) cancelAnimationFrame(requestID);</span><br/><span class="koboSpan" id="kobo.35.1">    var flights = this.dataset.flights;</span><br/>          <br/><span class="koboSpan" id="kobo.36.1">    d3.queue()</span><br/><span class="koboSpan" id="kobo.37.1">      .defer(d3.csv, 'data/routes_' + flights + '.csv')</span><br/><span class="koboSpan" id="kobo.38.1">      .defer(d3.csv, 'data/airports_' + flights + '.csv')</span><br/><span class="koboSpan" id="kobo.39.1">      .await(ready);</span><br/><span class="koboSpan" id="kobo.40.1">  }</span></pre>
<p><span class="koboSpan" id="kobo.41.1">The button colors are handled in the first two lines. </span><span class="koboSpan" id="kobo.41.2">The next line will stop the current loop. </span><span class="koboSpan" id="kobo.41.3">We haven't even got a loop yet, so let's get back to this as soon as we have.</span></p>
<p><span class="koboSpan" id="kobo.42.1">Finally, we retrieve the number of flights the button represents and load the respective route and airport location data from the server. </span><span class="koboSpan" id="kobo.42.2">That's it for the </span><kbd><span class="koboSpan" id="kobo.43.1">d3.json()</span></kbd><span class="koboSpan" id="kobo.44.1"> callback, as the </span><kbd><span class="koboSpan" id="kobo.45.1">ready()</span></kbd><span class="koboSpan" id="kobo.46.1"> function will take over as soon as the data is loaded.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Preparing and drawing with Canvas</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">With Canvas, we want to achieve three things in the </span><kbd><span class="koboSpan" id="kobo.3.1">ready()</span></kbd><span class="koboSpan" id="kobo.4.1"> function:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">function ready(error, routes, airports) {</span><br/><span class="koboSpan" id="kobo.6.1">  if (error) throw error;</span><br/><br/><span class="koboSpan" id="kobo.7.1">  // 1) Draw the background scene</span><br/><span class="koboSpan" id="kobo.8.1">  // 2) Calculate plane positions</span><br/><span class="koboSpan" id="kobo.9.1">  // 3) Animate and render the planes</span><br/><span class="koboSpan" id="kobo.10.1">}</span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Drawing the background scene</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Before we draw the airports, we manipulate the airport locations data. </span><span class="koboSpan" id="kobo.2.2">We create an array holding one GeoJSON point </span><kbd><span class="koboSpan" id="kobo.3.1">geometry</span></kbd><span class="koboSpan" id="kobo.4.1"> object per airport:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">var airportLocation = [];</span><br/><span class="koboSpan" id="kobo.6.1">airports.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.7.1">  var obj = {};</span><br/><span class="koboSpan" id="kobo.8.1">  obj.type = 'Feature';</span><br/><span class="koboSpan" id="kobo.9.1">  obj.id = el.iata;</span><br/><span class="koboSpan" id="kobo.10.1">  obj.geometry = {</span><br/><span class="koboSpan" id="kobo.11.1">    type: 'Point',</span><br/><span class="koboSpan" id="kobo.12.1">    coordinates: [+el.long, +el.lat]</span><br/><span class="koboSpan" id="kobo.13.1">  };</span><br/><span class="koboSpan" id="kobo.14.1">  obj.properties = {};</span><br/><span class="koboSpan" id="kobo.15.1">  airportLocation.push(obj);</span><br/><span class="koboSpan" id="kobo.16.1">});</span><br/><span class="koboSpan" id="kobo.17.1">airportMap = d3.map(airportLocation, function(d) { return d.id; });</span></pre>
<p><span class="koboSpan" id="kobo.18.1">Then we fill the global </span><kbd><span class="koboSpan" id="kobo.19.1">airportMap</span></kbd><span class="koboSpan" id="kobo.20.1"> </span><span><span class="koboSpan" id="kobo.21.1">variable</span></span><span><span class="koboSpan" id="kobo.22.1"> </span></span><span><span class="koboSpan" id="kobo.23.1">with a map we produce with</span></span> <kbd><span class="koboSpan" id="kobo.24.1">d3.map()</span></kbd><span><span class="koboSpan" id="kobo.25.1">.</span></span> <kbd><span class="koboSpan" id="kobo.26.1">d3.map()</span></kbd> <span><span class="koboSpan" id="kobo.27.1">is a utility function that takes an array of objects to produce key-value pairs we can access with its own</span></span> <kbd><span class="koboSpan" id="kobo.28.1">map.get()</span></kbd> <span><span class="koboSpan" id="kobo.29.1">method. </span><span class="koboSpan" id="kobo.29.2">We won't use the map immediately but will get to it in a moment.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">Every time we call the </span><kbd><span class="koboSpan" id="kobo.31.1">ready()</span></kbd><span class="koboSpan" id="kobo.32.1"> function, that is every time the user presses a new button, we will redraw airports and the world. </span><span class="koboSpan" id="kobo.32.2">Both are drawn on the same canvas. </span><span class="koboSpan" id="kobo.32.3">If we want to change one thing on a canvas, we need to change everything on a canvas. </span><span class="koboSpan" id="kobo.32.4">There are ways to only update regions with clip-paths but with complex animations of multiple elements, this can become a mess real quick. </span><span class="koboSpan" id="kobo.32.5">So we erase and rebuild:</span></p>
<pre><span class="koboSpan" id="kobo.33.1">contextWorld.clearRect(0, 0, width, height);</span><br/><span class="koboSpan" id="kobo.34.1">drawMap(countries);</span><br/><span class="koboSpan" id="kobo.35.1">drawAirports(airportLocation);</span></pre>
<p><span class="koboSpan" id="kobo.36.1">Note, we're on the first canvas we've drawn – accessible via </span><kbd><span class="koboSpan" id="kobo.37.1">contextWorld.</span></kbd><span class="koboSpan" id="kobo.38.1"> We've seen </span><kbd><span class="koboSpan" id="kobo.39.1">drawMap()</span></kbd><span class="koboSpan" id="kobo.40.1"> a few paragraphs ago, </span><kbd><span class="koboSpan" id="kobo.41.1">drawAirports()</span></kbd><span class="koboSpan" id="kobo.42.1"> is even simpler and speaks for itself:</span></p>
<pre><span class="koboSpan" id="kobo.43.1">function drawAirports(airports) {</span><br/><span class="koboSpan" id="kobo.44.1">  airports.forEach(function(el,i) {</span><br/><br/><span class="koboSpan" id="kobo.45.1">    contextWorld.beginPath();</span><br/><span class="koboSpan" id="kobo.46.1">    pathCanvas(el);</span><br/><span class="koboSpan" id="kobo.47.1">    contextWorld.fillStyle = '#fff';</span><br/><span class="koboSpan" id="kobo.48.1">    contextWorld.fill();</span><br/><br/><span class="koboSpan" id="kobo.49.1">  });</span><br/><span class="koboSpan" id="kobo.50.1">}</span></pre>
<p><span class="koboSpan" id="kobo.51.1">That's it. </span><span class="koboSpan" id="kobo.51.2">This background scene will be drawn with every button press updating the airports shown.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Defining the planes</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Next, we build the fundament for our animation. </span><span class="koboSpan" id="kobo.2.2">Essentially, we want an array of points on each plane's route. </span><span class="koboSpan" id="kobo.2.3">We will call them </span><strong><span class="koboSpan" id="kobo.3.1">way points</span></strong><span class="koboSpan" id="kobo.4.1"> and here's how they will look for the flight path </span><strong><span class="koboSpan" id="kobo.5.1">Frankfurt to Atlanta</span></strong><span class="koboSpan" id="kobo.6.1"> as an array and as points on the path:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img height="558" width="805" src="assets/b4039708-d1d0-461c-848b-dfc51e19590f.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1">Way points in an array (showing the first 10 of 733) and on the map (an illustration, not exact)</span></div>
<p><span class="koboSpan" id="kobo.9.1">The </span><strong><span class="koboSpan" id="kobo.10.1">way points</span></strong><span class="koboSpan" id="kobo.11.1"> are the core ingredient, the fuel for our animation. </span><span class="koboSpan" id="kobo.11.2">When we animate the first frame, we will:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.12.1">Clear the plane's own canvas </span><kbd><span class="koboSpan" id="kobo.13.1">contextPlane</span></kbd><span class="koboSpan" id="kobo.14.1">.</span></li>
<li><span class="koboSpan" id="kobo.15.1">Pull out the very first way point for each plane.</span></li>
<li><span class="koboSpan" id="kobo.16.1">Draw that plane in this position.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.17.1">When we draw the second frame we do the same, but in </span><em><span class="koboSpan" id="kobo.18.1">step 2</span></em><span class="koboSpan" id="kobo.19.1"> pull out the second way point. </span><span class="koboSpan" id="kobo.19.2">For the third frame, we shall pull out the third way point, and so on.</span></p>
<p><span class="koboSpan" id="kobo.20.1">We don't want to hold up the browser with complex calculations in between each frame, so we shall calculate all positions for all planes before we animate. </span><span class="koboSpan" id="kobo.20.2">Note, this is not always possible, positions might be dependent on user input or arbitrary charges in your force-directed graph or the like. </span><span class="koboSpan" id="kobo.20.3">However, whatever you can pre-calculate, you should.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Calculating the plane's positions</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">How do we get to the </span><kbd><span class="koboSpan" id="kobo.3.1">wayPoints</span></kbd><span class="koboSpan" id="kobo.4.1"> array? </span><span class="koboSpan" id="kobo.4.2">Conceptually, we've said it all already. </span><span class="koboSpan" id="kobo.4.3">We now express it in code. </span><span class="koboSpan" id="kobo.4.4">First, you need to create an array for all planes, depending on the route data the respective button press has loaded in:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">var routeFromTo = [];</span><br/><span class="koboSpan" id="kobo.6.1">  routes.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.7.1">    var arr = [el.source_airport, el.destination_airport];</span><br/><span class="koboSpan" id="kobo.8.1">    routeFromTo.push(arr);</span><br/><span class="koboSpan" id="kobo.9.1">  });</span></pre>
<p><span class="koboSpan" id="kobo.10.1">This is a simple array of elements representing the three-letter origin and the destination IATA airport codes.</span></p>
<p><span class="koboSpan" id="kobo.11.1">Next, you iterate through this array of start and end points to calculate the </span><kbd><span class="koboSpan" id="kobo.12.1">wayPoints</span></kbd><span class="koboSpan" id="kobo.13.1">. </span><span class="koboSpan" id="kobo.13.2">You will create an object called </span><kbd><span class="koboSpan" id="kobo.14.1">planes</span></kbd><span class="koboSpan" id="kobo.15.1"> holding the data as well as two helper functions to calculate the data. </span><span class="koboSpan" id="kobo.15.2">But before this, have a look at the simple algorithm to produce the planes:</span></p>
<pre><span class="koboSpan" id="kobo.16.1">routeFromTo.forEach(function(el, i) {</span><br/><span class="koboSpan" id="kobo.17.1">  var plane = planes.getPlane(el);</span><br/><span class="koboSpan" id="kobo.18.1">  plane.route = planes.getPath(el);</span><br/><span class="koboSpan" id="kobo.19.1">  plane.wayPoints = planes.getWayPoints(plane);</span><br/><span class="koboSpan" id="kobo.20.1">  planes.items.push(plane);</span><br/><span class="koboSpan" id="kobo.21.1">});</span></pre>
<p><span class="koboSpan" id="kobo.22.1">Conceptually, you produce a plane for each route. </span><span class="koboSpan" id="kobo.22.2">Then you get this plane's route path and store it within the plane. </span><span class="koboSpan" id="kobo.22.3">Next, you sample the path for a number of </span><em><span class="koboSpan" id="kobo.23.1">x</span></em><span class="koboSpan" id="kobo.24.1">, </span><em><span class="koboSpan" id="kobo.25.1">y</span></em><span class="koboSpan" id="kobo.26.1"> coordinates – our </span><kbd><span class="koboSpan" id="kobo.27.1">wayPoints</span></kbd><span class="koboSpan" id="kobo.28.1"> – and also store it in the </span><kbd><span class="koboSpan" id="kobo.29.1">plane</span></kbd><span class="koboSpan" id="kobo.30.1">. </span><span class="koboSpan" id="kobo.30.2">Lastly, you add the </span><kbd><span class="koboSpan" id="kobo.31.1">plane</span></kbd><span class="koboSpan" id="kobo.32.1"> with all the information you need in the </span><kbd><span class="koboSpan" id="kobo.33.1">planes.items</span></kbd><span class="koboSpan" id="kobo.34.1"> array. </span><span class="koboSpan" id="kobo.34.2">That's all the calculation magic in an overview. </span><span class="koboSpan" id="kobo.34.3">As soon as that's done, you can animate the points.</span></p>
<p><span class="koboSpan" id="kobo.35.1">Now, let's have a brief look at the </span><kbd><span class="koboSpan" id="kobo.36.1">planes</span></kbd><span class="koboSpan" id="kobo.37.1"> object. </span><span class="koboSpan" id="kobo.37.2">Note the plural! </span><span class="koboSpan" id="kobo.37.3">This is different to the </span><kbd><span class="koboSpan" id="kobo.38.1">plane</span></kbd><span class="koboSpan" id="kobo.39.1"> object we build for each route. </span><span class="koboSpan" id="kobo.39.2">It is the home of all our </span><kbd><span class="koboSpan" id="kobo.40.1">plane</span></kbd><span class="koboSpan" id="kobo.41.1"> objects. </span><kbd><span class="koboSpan" id="kobo.42.1">planes.items</span></kbd><span class="koboSpan" id="kobo.43.1"> will keep all </span><kbd><span class="koboSpan" id="kobo.44.1">plane</span></kbd><span class="koboSpan" id="kobo.45.1"> objects, </span><kbd><span class="koboSpan" id="kobo.46.1">planes.getPlane()</span></kbd><span class="koboSpan" id="kobo.47.1"> will produce them, </span><kbd><span class="koboSpan" id="kobo.48.1">planes.getPath()</span></kbd><span class="koboSpan" id="kobo.49.1"> will create the route's path, and </span><kbd><span class="koboSpan" id="kobo.50.1">planes.getWayPoints()</span></kbd><span class="koboSpan" id="kobo.51.1"> will sample our way points from the path:</span></p>
<pre><span class="koboSpan" id="kobo.52.1">var planes = {</span><br/><span class="koboSpan" id="kobo.53.1">  items: [],</span><br/><span class="koboSpan" id="kobo.54.1">  getPlane: function(planeRoute) { },</span><br/><span class="koboSpan" id="kobo.55.1">  getPath: function(planeRoute) { },</span><br/><span class="koboSpan" id="kobo.56.1">  getWayPoints: function(plane) { }</span><br/><span class="koboSpan" id="kobo.57.1">}</span></pre>
<p><span class="koboSpan" id="kobo.58.1">Let's look at what each </span><kbd><span class="koboSpan" id="kobo.59.1">planes</span></kbd><span class="koboSpan" id="kobo.60.1"> function does. </span><span class="koboSpan" id="kobo.60.2">There are three simple steps: first, we build the plane, then we draw each plane's path, and finally we sample points from that path we can iterate through to make the plane move: </span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.61.1">Manufacturing a plane</span></strong><span class="koboSpan" id="kobo.62.1">:</span><strong><span class="koboSpan" id="kobo.63.1"> </span></strong><span class="koboSpan" id="kobo.64.1">the </span><kbd><span class="koboSpan" id="kobo.65.1">getPlane()</span></kbd><span class="koboSpan" id="kobo.66.1"> function takes the </span><kbd><span class="koboSpan" id="kobo.67.1">planeRoute</span></kbd><span class="koboSpan" id="kobo.68.1"> – the three-letter airport codes for origin and destination – and uses it to initialize the plane's position:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.69.1">getPlane: function(planeRoute) {</span><br/><br/><span class="koboSpan" id="kobo.70.1">  var origin = planeRoute[0], destination = planeRoute[1];</span><br/><br/><span class="koboSpan" id="kobo.71.1">  var obj = {};</span><br/><br/><span class="koboSpan" id="kobo.72.1">  obj.od = [origin, destination];</span><br/><br/><span class="koboSpan" id="kobo.73.1">  obj.startX = projection(airportMap.get(origin).geometry.coordinates)[0];</span><br/><span class="koboSpan" id="kobo.74.1">  obj.startY = projection(airportMap.get(origin).geometry.coordinates)[1];</span><br/><br/><span class="koboSpan" id="kobo.75.1">  obj.x = projection(airportMap.get(origin).geometry.coordinates)[0];</span><br/><span class="koboSpan" id="kobo.76.1">  obj.y = projection(airportMap.get(origin).geometry.coordinates)[1];</span><br/><br/><span class="koboSpan" id="kobo.77.1">  obj.route = null;</span><br/><span class="koboSpan" id="kobo.78.1">  obj.wayPoints = [];</span><br/><span class="koboSpan" id="kobo.79.1">  obj.currentIndex = 0;</span><br/><br/><span class="koboSpan" id="kobo.80.1">  return obj;</span><br/><br/><span class="koboSpan" id="kobo.81.1">}</span></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.82.1">It returns an object holding the </span><kbd><span class="koboSpan" id="kobo.83.1">startX</span></kbd><span class="koboSpan" id="kobo.84.1"> and </span><kbd><span class="koboSpan" id="kobo.85.1">startY</span></kbd><span class="koboSpan" id="kobo.86.1"> positions it retrieves from the </span><kbd><span class="koboSpan" id="kobo.87.1">airportMap</span></kbd><span class="koboSpan" id="kobo.88.1"> lookup you created earlier. </span><span class="koboSpan" id="kobo.88.2">It also has </span><kbd><span class="koboSpan" id="kobo.89.1">x</span></kbd><span class="koboSpan" id="kobo.90.1"> and </span><kbd><span class="koboSpan" id="kobo.91.1">y</span></kbd><span class="koboSpan" id="kobo.92.1"> coordinates representing the current position of the plane. </span><span class="koboSpan" id="kobo.92.2">For the first frame this is the same as </span><kbd><span class="koboSpan" id="kobo.93.1">startX</span></kbd><span class="koboSpan" id="kobo.94.1"> and </span><kbd><span class="koboSpan" id="kobo.95.1">startY.</span></kbd><span class="koboSpan" id="kobo.96.1"> It also holds an as yet empty object for the </span><kbd><span class="koboSpan" id="kobo.97.1">route</span></kbd><span class="koboSpan" id="kobo.98.1"> path and the </span><kbd><span class="koboSpan" id="kobo.99.1">wayPoints</span></kbd><span class="koboSpan" id="kobo.100.1"> we calculate next. </span><span class="koboSpan" id="kobo.100.2">Lastly, it has a </span><kbd><span class="koboSpan" id="kobo.101.1">currentIndex</span></kbd><span class="koboSpan" id="kobo.102.1"> keeping track of the way point the plane is at when we change its position (this will become clearer very soon).</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.103.1">Drawing each plane's path</span></strong><span class="koboSpan" id="kobo.104.1">:</span><strong><span class="koboSpan" id="kobo.105.1"> </span></strong><span class="koboSpan" id="kobo.106.1">plane initialized. </span><span class="koboSpan" id="kobo.106.2">Now, let's get the path. </span><span class="koboSpan" id="kobo.106.3">Remember that we created two path generators during setup? </span><span class="koboSpan" id="kobo.106.4">One was a Canvas path to draw worlds, the airport, and plane circles. </span><span class="koboSpan" id="kobo.106.5">The other one – </span><kbd><span class="koboSpan" id="kobo.107.1">pathSVG</span></kbd><span class="koboSpan" id="kobo.108.1"> – was for creating the route as an SVG path. </span><span class="koboSpan" id="kobo.108.2">Why would you want to do that? </span><span class="koboSpan" id="kobo.108.3">Because SVG paths have the great </span><kbd><span class="koboSpan" id="kobo.109.1">.getTotalLength()</span></kbd><span class="koboSpan" id="kobo.110.1"> and </span><kbd><span class="koboSpan" id="kobo.111.1">.getPointAtLength()</span></kbd><span class="koboSpan" id="kobo.112.1"> methods that make it easy to sample points from that path. </span><span class="koboSpan" id="kobo.112.2">Here's how to use D3 to create the path:</span></li>
</ul>
<pre style="padding-left: 60px"><span class="koboSpan" id="kobo.113.1">getPath: function(planeRoute) {</span><br/><span class="koboSpan" id="kobo.114.1">  var origin = planeRoute[0], destination = planeRoute[1];</span><br/><span class="koboSpan" id="kobo.115.1">  var pathElement = document.createElementNS(d3.namespaces.svg,</span><br/><span class="koboSpan" id="kobo.116.1">  'path');</span><br/><br/><span class="koboSpan" id="kobo.117.1">  var route = d3.select(pathElement)</span><br/><span class="koboSpan" id="kobo.118.1">    .datum({</span><br/><span class="koboSpan" id="kobo.119.1">      type: 'LineString',</span><br/><span class="koboSpan" id="kobo.120.1">      coordinates: [</span><br/><span class="koboSpan" id="kobo.121.1">         airportMap.get(origin).geometry.coordinates,</span><br/><span class="koboSpan" id="kobo.122.1">         airportMap.get(destination).geometry.coordinates</span><br/><span class="koboSpan" id="kobo.123.1">       ]</span><br/><span class="koboSpan" id="kobo.124.1">    })</span><br/><span class="koboSpan" id="kobo.125.1">    .attr('d', pathSVG);</span><br/><br/><span class="koboSpan" id="kobo.126.1">    return route.node();</span><br/><span class="koboSpan" id="kobo.127.1">}</span></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.128.1">You won't create the path in the DOM, but only in memory and save it in the </span><kbd><span class="koboSpan" id="kobo.129.1">pathElement</span></kbd><span class="koboSpan" id="kobo.130.1"> variable. </span><span class="koboSpan" id="kobo.130.2">As it's an SVG and not an HTML element, you need to specify the SVG namespace which you can do with D3's </span><kbd><span class="koboSpan" id="kobo.131.1">.namespaces.svg</span></kbd><span class="koboSpan" id="kobo.132.1"> utility function. </span><span class="koboSpan" id="kobo.132.2">Then you create the path before returning the raw element rather than the D3 selection as </span><kbd><span class="koboSpan" id="kobo.133.1">route.node()</span></kbd><span class="koboSpan" id="kobo.134.1">.</span></p>
<ul>
<li><strong><span class="koboSpan" id="kobo.135.1">Retrieving the way points</span></strong><span class="koboSpan" id="kobo.136.1">:</span><strong><span class="koboSpan" id="kobo.137.1"> </span></strong><span class="koboSpan" id="kobo.138.1">all set to calculate the way points. </span><kbd><span class="koboSpan" id="kobo.139.1">getWayPoints()</span></kbd><span class="koboSpan" id="kobo.140.1"> takes the plane which by now has its path stored in the </span><kbd><span class="koboSpan" id="kobo.141.1">plane.route</span></kbd><span class="koboSpan" id="kobo.142.1"> property. </span><span class="koboSpan" id="kobo.142.2">We use the path sampling functions we just praised on its path and return an array holding all way points for this specific plane's route path:</span></li>
</ul>
<pre style="padding-left: 90px"><span class="koboSpan" id="kobo.143.1">getWayPoints: function(plane) {</span><br/><span class="koboSpan" id="kobo.144.1">  var arr = [];</span><br/><span class="koboSpan" id="kobo.145.1">  var points = Math.floor(plane.route.getTotalLength() * 2.5);</span><br/><br/><span class="koboSpan" id="kobo.146.1">  d3.range(points).forEach(function(el, i) {</span><br/><span class="koboSpan" id="kobo.147.1">    var DOMPoints = plane.route.getPointAtLength(i/2.5);</span><br/><span class="koboSpan" id="kobo.148.1">    arr.push({ x: DOMPoints.x, y: DOMPoints.y });</span><br/><span class="koboSpan" id="kobo.149.1">  });</span><br/><br/><span class="koboSpan" id="kobo.150.1">  return arr;</span><br/><span class="koboSpan" id="kobo.151.1">}</span></pre>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.152.1">First, you create an empty array called </span><kbd><span class="koboSpan" id="kobo.153.1">arr</span></kbd><span class="koboSpan" id="kobo.154.1"> which will hold all your way points. </span><span class="koboSpan" id="kobo.154.2">Then, you produce an integer saved in the </span><kbd><span class="koboSpan" id="kobo.155.1">points</span></kbd><span class="koboSpan" id="kobo.156.1"> variable. </span><span class="koboSpan" id="kobo.156.2">This integer will represent the number of points we want to sample from the path. </span><span class="koboSpan" id="kobo.156.3">You get the total length of the path, which is represented by the number of pixels the path will take up. </span><span class="koboSpan" id="kobo.156.4">This, you multiply by </span><kbd><span class="koboSpan" id="kobo.157.1">2.5</span></kbd><span class="koboSpan" id="kobo.158.1">. </span><span class="koboSpan" id="kobo.158.2">This very factor is important and controls how many points will be sampled and hence how fast or slow the animation will be. </span><span class="koboSpan" id="kobo.158.3">The higher the number, the more points it will sample and the slower the animation will appear. </span><span class="koboSpan" id="kobo.158.4">If you choose a low number or even a fraction such as </span><em><span class="koboSpan" id="kobo.159.1">0.1</span></em><span class="koboSpan" id="kobo.160.1">, few points will be sampled and the animation will appear faster.</span></p>
<p style="padding-left: 60px"><span class="koboSpan" id="kobo.161.1">You use </span><kbd><span class="koboSpan" id="kobo.162.1">d3.range(points).forEach()</span></kbd><span class="koboSpan" id="kobo.163.1"> to retrieve the coordinates returned as so-called </span><kbd><span class="koboSpan" id="kobo.164.1">DOMPoints</span></kbd><span class="koboSpan" id="kobo.165.1"> by </span><kbd><span class="koboSpan" id="kobo.166.1">.getPointAtLength()</span></kbd><span class="koboSpan" id="kobo.167.1"> at each point of the path. </span><span class="koboSpan" id="kobo.167.2">Then you push each of them into the array and voila, you have your way points.</span></p>
<p><span><span class="koboSpan" id="kobo.168.1">Congratulations. </span><span class="koboSpan" id="kobo.168.2">You have just built a plane. </span><span class="koboSpan" id="kobo.168.3">In fact, you have built a plane and its route and all the points you need to make it jump to so that a viewer would think it flies. </span><span class="koboSpan" id="kobo.168.4">This is how it looks inside:</span></span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.169.1"><img height="237" width="228" src="assets/ca50163d-84e0-461b-babd-943c3e5fe0f0.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.170.1">The plane flying from Frankfurt to Atlanta</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Animating the plane</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The rest is simple. </span><span class="koboSpan" id="kobo.2.2">You just need to apply the game loop to the canvas. </span><span class="koboSpan" id="kobo.2.3">We've already encountered this a few times; you create a function called </span><kbd><span class="koboSpan" id="kobo.3.1">animate()</span></kbd><span class="koboSpan" id="kobo.4.1"> and let it run in a continuous loop:</span></p>
<pre><span class="koboSpan" id="kobo.5.1">function animate() {</span><br/><span class="koboSpan" id="kobo.6.1">  planes.clearPlanes(contextPlane);</span><br/><span class="koboSpan" id="kobo.7.1">  planes.items.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.8.1">    planes.updatePlane(el);</span><br/><span class="koboSpan" id="kobo.9.1">    planes.drawPlane(contextPlane, el.x, el.y);</span><br/><span class="koboSpan" id="kobo.10.1">  });</span><br/><span class="koboSpan" id="kobo.11.1">  requestID = requestAnimationFrame(animate);</span><br/><span class="koboSpan" id="kobo.12.1">}</span><br/><br/><span class="koboSpan" id="kobo.13.1">requestAnimationFrame(animate);</span></pre>
<p><span class="koboSpan" id="kobo.14.1">Note, that we added the used functions to the planes object as well, to keep all plane-related function code together.</span></p>
<p><span class="koboSpan" id="kobo.15.1">First, we clear the canvas. </span><kbd><span class="koboSpan" id="kobo.16.1">planes.clearPlanes()</span></kbd><span class="koboSpan" id="kobo.17.1"> literally just clears the context we pass to it.</span></p>
<p><span class="koboSpan" id="kobo.18.1">Then we iterate through the </span><kbd><span class="koboSpan" id="kobo.19.1">planes.items</span></kbd><span class="koboSpan" id="kobo.20.1"> array holding all planes and update each plane with </span><kbd><span class="koboSpan" id="kobo.21.1">planes.updatePlane()</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">We pass it the respective plane and it either moves the </span><kbd><span class="koboSpan" id="kobo.23.1">x</span></kbd><span class="koboSpan" id="kobo.24.1"> and </span><kbd><span class="koboSpan" id="kobo.25.1">y</span></kbd><span class="koboSpan" id="kobo.26.1"> coordinates to the start if the plane has reached its destination or it moves them to the next way point coordinate:</span></p>
<pre><span class="koboSpan" id="kobo.27.1">updatePlane: function(plane) {</span><br/><span class="koboSpan" id="kobo.28.1">  plane.currentIndex++;</span><br/><span class="koboSpan" id="kobo.29.1">  if (plane.currentIndex &gt;= plane.wayPoints.length) {</span><br/><span class="koboSpan" id="kobo.30.1">    plane.currentIndex = 0;</span><br/><span class="koboSpan" id="kobo.31.1">    plane.x = plane.startX;</span><br/><span class="koboSpan" id="kobo.32.1">    plane.y = plane.startY;</span><br/><span class="koboSpan" id="kobo.33.1">  } else {</span><br/><span class="koboSpan" id="kobo.34.1">    plane.x = plane.wayPoints[plane.currentIndex].x;</span><br/><span class="koboSpan" id="kobo.35.1">    plane.y = plane.wayPoints[plane.currentIndex].y;</span><br/><span class="koboSpan" id="kobo.36.1">  }</span><br/><span class="koboSpan" id="kobo.37.1">}</span></pre>
<p><span class="koboSpan" id="kobo.38.1">The use of </span><kbd><span class="koboSpan" id="kobo.39.1">currentIndex</span></kbd><span class="koboSpan" id="kobo.40.1"> should become clearer here. </span><span class="koboSpan" id="kobo.40.2">It keeps track of where each plane is on its path as well as moving the plane forward by one way point on each update.</span></p>
<p><span class="koboSpan" id="kobo.41.1">Finally, we draw the plane (this is where we realize we haven't built an actual plane but a </span><kbd><span class="koboSpan" id="kobo.42.1">tomato</span></kbd><span class="koboSpan" id="kobo.43.1"> colored circle):</span></p>
<pre><span class="koboSpan" id="kobo.44.1">drawPlane: function(ctx, x, y) {</span><br/><span class="koboSpan" id="kobo.45.1">  ctx.beginPath();</span><br/><span class="koboSpan" id="kobo.46.1">  ctx.fillStyle = 'tomato';</span><br/><span class="koboSpan" id="kobo.47.1">  ctx.arc(x, y, 1, 0, 2*Math.PI);</span><br/><span class="koboSpan" id="kobo.48.1">  ctx.fill();</span><br/><span class="koboSpan" id="kobo.49.1">}</span></pre>
<p><span class="koboSpan" id="kobo.50.1">Finally, you kick it off with </span><kbd><span class="koboSpan" id="kobo.51.1">requestAnimationFrame()</span></kbd><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">You can use </span><kbd><span class="koboSpan" id="kobo.53.1">setInterval()</span></kbd><span class="koboSpan" id="kobo.54.1"> but you should use </span><kbd><span class="koboSpan" id="kobo.55.1">requestAnimationFrame()</span></kbd><span class="koboSpan" id="kobo.56.1"> instead. </span><span class="koboSpan" id="kobo.56.2">It will allow the browser to choose the best time to trigger its callback before the next repaint. </span><span class="koboSpan" id="kobo.56.3">This is much more economical compared to the brute force </span><kbd><span class="koboSpan" id="kobo.57.1">setInterval()</span></kbd><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">It also has the additional benefit of interrupting the loop when the browser tab the app runs on is not in focus. </span><span class="koboSpan" id="kobo.58.3">Note also, that we save the </span><kbd><span class="koboSpan" id="kobo.59.1">requestID</span></kbd><span class="koboSpan" id="kobo.60.1"> of each loop. </span><span class="koboSpan" id="kobo.60.2">You might remember that we use this unique ID to cancel the current loop with </span><kbd><span class="koboSpan" id="kobo.61.1">cancelAnimationFrame(requestID)</span></kbd><span class="koboSpan" id="kobo.62.1"> when the user presses a button to set off a new loop.</span></p>
<p><span class="koboSpan" id="kobo.63.1">Done. </span><span class="koboSpan" id="kobo.63.2">Well done.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Measuring the performance</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">So far so good. </span><span class="koboSpan" id="kobo.2.2">But does it work? </span><span class="koboSpan" id="kobo.2.3">And if it works, does it work better than the SVG example? </span><span class="koboSpan" id="kobo.2.4">Let's recall that the SVG flight path visual gave us a whopping 60 FPS for 100 animated circles and a meager 6 FPS for some 5,000 animated circles. </span><span class="koboSpan" id="kobo.2.5">Let's start with 100 circles and focus on the </span><kbd><span class="koboSpan" id="kobo.3.1">stats.js</span></kbd><span class="koboSpan" id="kobo.4.1"> measure in the top-left corner:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.5.1"><img height="486" width="770" src="assets/d1367c00-7bfd-4a2b-b49f-a90f3d1a74d7.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.6.1"> Canvas visualization of 100 flight paths at 60 FPS </span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span><span class="koboSpan" id="kobo.7.1">View this step in the browser at: </span></span><a href="https://larsvers.github.io/learning-d3-mapping-9-2a"><span class="koboSpan" id="kobo.8.1">https://larsvers.github.io/learning-d3-mapping-9-2a</span></a><span class="koboSpan" id="kobo.9.1">. </span><span class="koboSpan" id="kobo.9.2">Code example </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02a.html"><span class="koboSpan" id="kobo.10.1">09_02a.html</span></a><span class="koboSpan" id="kobo.11.1">.</span></div>
<p><span class="koboSpan" id="kobo.12.1">We expected 60 FPS. </span><span class="koboSpan" id="kobo.12.2">Let's go to 1,000 flights:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img height="487" width="770" src="assets/2e04a0e3-eac8-4a50-a4ec-62b7ea6f2203.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1">Canvas visualization of 1,000 flight paths at 60 FPS</span></div>
<p><span><span class="koboSpan" id="kobo.15.1">Again, </span></span><span class="koboSpan" id="kobo.16.1">60 FPS! </span><span class="koboSpan" id="kobo.16.2">5,000 planes?</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img height="483" width="771" src="assets/a914d46d-9c9a-4d7c-9062-1c4b4f0f8c22.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1">Canvas visualization of 5,000 flight paths at 45 FPS</span></div>
<p><span class="koboSpan" id="kobo.19.1">It's going down, but still at 45 FPS keeping the animation fluid. </span><span class="koboSpan" id="kobo.19.2">Let's look at 10,000 flights:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.20.1"><img height="477" width="771" src="assets/8fccd0c7-df9c-4e14-a37b-810eaae2305d.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.21.1">Canvas visualization of 10,000 flight paths at 23 FPS</span></div>
<div>
<p><span class="koboSpan" id="kobo.22.1">We still see a frame rate similar to what you see when watching a movie with 23 FPS. </span><span class="koboSpan" id="kobo.22.2">However, let's try and squeeze out a bit more.</span></p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Optimizing performance</span></h1>
                </header>
            
            <article>
                
<div>
<p><span class="koboSpan" id="kobo.2.1">Remember that we've used two canvases for this visual, one canvas to draw the static background scene with the map and the airports and one canvas for the dynamic flight animation. </span><span class="koboSpan" id="kobo.2.2">We did this because it kept drawing concerns separate.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Another reason for using an additional canvas is increased performance. </span><span class="koboSpan" id="kobo.3.2">We can use one canvas as an </span><strong><span class="koboSpan" id="kobo.4.1">in-memory buffer</span></strong><span class="koboSpan" id="kobo.5.1"> to pre-render elements and just copy its contents onto the main visible canvas. </span><span class="koboSpan" id="kobo.5.2">This saves render costs as drawing on a visible canvas is less performant than drawing on a non-visible canvas to then copy over the image to the main canvas. </span><span class="koboSpan" id="kobo.5.3">Performance further rejoices as the context's </span><kbd><span class="koboSpan" id="kobo.6.1">drawImage()</span></kbd><span class="koboSpan" id="kobo.7.1"> method we will use to copy over the image from the buffer to the display canvas, is hardware accelerated (meaning it uses the parallel processing powers of the GPU) by default.</span></p>
<p><span class="koboSpan" id="kobo.8.1">For our little app, the animated elements are the plane circles. </span><span class="koboSpan" id="kobo.8.2">Instead of drawing them with the </span><kbd><span class="koboSpan" id="kobo.9.1">drawPlane()</span></kbd><span class="koboSpan" id="kobo.10.1"> function for each update, we can first create a single image of a circle on a small buffer canvas and then use </span><kbd><span class="koboSpan" id="kobo.11.1">drawImage()</span></kbd><span class="koboSpan" id="kobo.12.1"> to port it over to the </span><kbd><span class="koboSpan" id="kobo.13.1">canvasPlane.</span></kbd></p>
<p><span class="koboSpan" id="kobo.14.1">We create a single plane image in global scope:</span></p>
<pre><span class="koboSpan" id="kobo.15.1">function createPlaneImage() {</span><br/><span class="koboSpan" id="kobo.16.1">  var planeImg = document.createElement('canvas');</span><br/><span class="koboSpan" id="kobo.17.1">  planeImg.width = planeImg.height = 2;</span><br/><span class="koboSpan" id="kobo.18.1">  var contextPlaneImg = planeImg.getContext('2d');</span><br/><span class="koboSpan" id="kobo.19.1">  contextPlaneImg.beginPath();</span><br/><span class="koboSpan" id="kobo.20.1">  contextPlaneImg.fillStyle = 'tomato';</span><br/><span class="koboSpan" id="kobo.21.1">  contextPlaneImg.arc(planeImg.width/2, planeImg.height/2, 1, 0,</span><br/><span class="koboSpan" id="kobo.22.1">  2*Math.PI);</span><br/><span class="koboSpan" id="kobo.23.1">  contextPlaneImg.fill();</span><br/><span class="koboSpan" id="kobo.24.1">  return planeImg;</span><br/><span class="koboSpan" id="kobo.25.1">}</span></pre>
<p><span class="koboSpan" id="kobo.26.1">We create our buffer canvas called </span><kbd><span class="koboSpan" id="kobo.27.1">planeImg</span></kbd><span class="koboSpan" id="kobo.28.1"> in thin air, set its </span><kbd><span class="koboSpan" id="kobo.29.1">width</span></kbd><span class="koboSpan" id="kobo.30.1"> and </span><kbd><span class="koboSpan" id="kobo.31.1">height</span></kbd><span class="koboSpan" id="kobo.32.1"> to </span><kbd><span class="koboSpan" id="kobo.33.1">2</span></kbd><span class="koboSpan" id="kobo.34.1"> (double the plane's desired radius of </span><kbd><span class="koboSpan" id="kobo.35.1">1</span></kbd><span class="koboSpan" id="kobo.36.1">), and retrieve its context. </span><span class="koboSpan" id="kobo.36.2">We'll draw a </span><kbd><span class="koboSpan" id="kobo.37.1">tomato</span></kbd><span class="koboSpan" id="kobo.38.1"> colored circle on it before we return it.</span></p>
<p><span class="koboSpan" id="kobo.39.1">We call this function once when initializing the </span><kbd><span class="koboSpan" id="kobo.40.1">planes</span></kbd><span class="koboSpan" id="kobo.41.1"> object and store it as an image in the </span><kbd><span class="koboSpan" id="kobo.42.1">planes</span></kbd><span class="koboSpan" id="kobo.43.1"> object:</span></p>
<pre><span class="koboSpan" id="kobo.44.1">var planes = {</span><br/><span class="koboSpan" id="kobo.45.1">  items: [],</span><br/><span class="koboSpan" id="kobo.46.1">  icon: createPlaneImage(),</span><br/><span class="koboSpan" id="kobo.47.1">  getPlane: function(planeRoute) {</span><br/><span class="koboSpan" id="kobo.48.1">  // ...</span></pre>
<p><span class="koboSpan" id="kobo.49.1">Finally, we just have to remove our </span><kbd><span class="koboSpan" id="kobo.50.1">drawPlane()</span></kbd><span class="koboSpan" id="kobo.51.1"> function we used to draw the circle on every update. </span><span class="koboSpan" id="kobo.51.2">Instead, we add a new function called </span><kbd><span class="koboSpan" id="kobo.52.1">drawPlaneImage()</span></kbd><span class="koboSpan" id="kobo.53.1"> to the </span><kbd><span class="koboSpan" id="kobo.54.1">planes</span></kbd><span class="koboSpan" id="kobo.55.1"> object that uses </span><kbd><span class="koboSpan" id="kobo.56.1">drawImage()</span></kbd><span class="koboSpan" id="kobo.57.1"> to add our plane icon (the circle) to the context we determine:</span></p>
<pre><span class="koboSpan" id="kobo.58.1">drawPlaneImage: function(ctx, x, y) {</span><br/><span class="koboSpan" id="kobo.59.1">  ctx.drawImage(this.icon, x, y);   </span><br/><span class="koboSpan" id="kobo.60.1">}</span></pre>
<p><span class="koboSpan" id="kobo.61.1">Lastly, we don't call </span><kbd><span class="koboSpan" id="kobo.62.1">drawImage()</span></kbd><span class="koboSpan" id="kobo.63.1"> in the </span><kbd><span class="koboSpan" id="kobo.64.1">animate()</span></kbd><span class="koboSpan" id="kobo.65.1"> function, but </span><kbd><span class="koboSpan" id="kobo.66.1">drawPlaneImage()</span></kbd><span class="koboSpan" id="kobo.67.1">:</span></p>
<pre><span class="koboSpan" id="kobo.68.1">function animate() {</span><br/><span class="koboSpan" id="kobo.69.1">  planes.clearPlanes(contextPlane);</span><br/><span class="koboSpan" id="kobo.70.1">  planes.items.forEach(function(el) {</span><br/><span class="koboSpan" id="kobo.71.1">    planes.updatePlane(el);</span><br/><span class="koboSpan" id="kobo.72.1">    planes.drawPlaneImage(contextPlane, el.x, el.y);</span><br/><span class="koboSpan" id="kobo.73.1">  });</span><br/><br/><span class="koboSpan" id="kobo.74.1">  requestID = requestAnimationFrame(animate);</span><br/><span class="koboSpan" id="kobo.75.1">}</span></pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Continuing with measuring performance</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now let's check the frame rate for animating 10,000 points:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.3.1"><img height="484" width="770" src="assets/aff3f428-0751-4728-842b-44d1d7b9bc84.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1"> Canvas visualization of 10,000 flight paths at 36 instead of 23 FPS </span></div>
<div class="packt_figref CDPAlignLeft CDPAlign packt_infobox"><span class="koboSpan" id="kobo.5.1">View complete app at: </span><a href="https://larsvers.github.io/learning-d3-mapping-9-2b"><span class="koboSpan" id="kobo.6.1">https://larsvers.github.io/learning-d3-mapping-9-2b</span></a><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">Code example: </span><a href="https://github.com/larsvers/Learning-D3.js-4-Mapping/blob/master/Chapter%2009%20-%20Mapping%20with%20D3%20and%20Canvas/09_02b.html"><span class="koboSpan" id="kobo.8.1">09_02b.html</span></a><span class="koboSpan" id="kobo.9.1">.</span></div>
<p><span class="koboSpan" id="kobo.10.1">That's great, boosting performance by about +57% compared to not using the powers of </span><kbd><span class="koboSpan" id="kobo.11.1">drawImage()</span></kbd><span class="koboSpan" id="kobo.12.1">. </span><span class="koboSpan" id="kobo.12.2">It's not shown here, but 5,000 points were animated at 60 FPS instead of 45 FPS. </span><span class="koboSpan" id="kobo.12.3">Yay.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Moving on, 15,000 flights fly with 24 FPS and 20,000 with up to 18 FPS. </span><span class="koboSpan" id="kobo.13.2">This is still just beyond the 16 FPS generally considered the lowest possible frame rate for fooling the brain into believing a fluid animation. </span><span class="koboSpan" id="kobo.13.3">Even 25,000 planes still move with around 14 frames per second conveying a mild jank, while 30,000 flights stutter still only modestly at 12 FPS.</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.14.1"><img height="485" width="771" src="assets/0e1e2049-a745-45f5-a39b-dc83b29464cc.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.15.1"> Canvas visualization of 30,000 flight paths at 12 FPS</span></div>
<p><span class="koboSpan" id="kobo.16.1">While performance can vary with different browsers, CPU’s and GPU’s the jump from SVG to Canvas is significant!</span></p>
<p><span class="koboSpan" id="kobo.17.1">With Canvas we have achieved our narrative mission to visualize regions of heavy flight activity. </span><span class="koboSpan" id="kobo.17.2">All of Europe seems to be in the air, as well as the east and west of the US and the east of China. </span><span class="koboSpan" id="kobo.17.3">Other continents show a line of increased air-activity along their costs. </span><span class="koboSpan" id="kobo.17.4">You might be surprised by the band of planes moving down through Thailand and Indonesia, although this is a densely-populated area.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, you have learned how to build a flight path visualization in SVG and in Canvas, bringing together much of what you have learned before. </span><span class="koboSpan" id="kobo.2.2">You have seen how it requires a different mental model to program animations with Canvas, probably best summarized by the game loop: process your data, clear the drawing, re-draw the animation. </span><span class="koboSpan" id="kobo.2.3">You have used D3 to set up the visualizations, but you have also seen that due to the different coding concept, Canvas might require you to step away a little from D3 core functionality like transitions. </span><span class="koboSpan" id="kobo.2.4">However, all that paid off by witnessing the power of Canvas when it comes to animation. </span><span class="koboSpan" id="kobo.2.5">Instead of being able to fluidly animate 1,000 points we managed to animate 15,000 points safely and 20,000 points still gracefully with optimized Canvas techniques.</span></p>
<p><span class="koboSpan" id="kobo.3.1">After having seen the </span><span><span class="koboSpan" id="kobo.4.1">benefits of </span></span><span><span class="koboSpan" id="kobo.5.1">Canvas, let's now find a workaround for one of its caveats: interactivity!</span></span></p>


            </article>

            
        </section>
    </body></html>