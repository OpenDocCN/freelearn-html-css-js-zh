- en: Chapter 3. Testing Frontend Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 测试前端代码
- en: Testing JavaScript browser code has been notoriously considered hard, and although
    there are many complications while dealing with cross-browser testing, the most
    common problem is not with the testing process but rather that the application
    code itself is not testable.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试JavaScript浏览器代码一直被认为很难，尽管在处理跨浏览器测试时有许多复杂性，但最常见的问题不是测试过程，而是应用代码本身不可测试。
- en: Since every element in the browser's document is accessible globally, it is
    easy to write a monolithic piece of JavaScript code, which deals with the whole
    page. This leads to a number of problems, and the biggest one is that it is pretty
    hard to test.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器文档中的每个元素都是全局可访问的，因此很容易编写一个处理整个页面的单一JavaScript代码块。这导致了一系列问题，其中最大的问题是很难进行测试。
- en: In this chapter, we are going to get the best practices on how to write maintainable
    and testable browser code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何编写可维护和可测试的浏览器代码的最佳实践。
- en: To implement the user interface, we are going to use jQuery, a well-known JavaScript
    library that abstracts the browser's DOM in a clean and simple API that works
    across different browsers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现用户界面，我们将使用jQuery，这是一个知名的JavaScript库，它通过一个干净简单的API抽象了浏览器的DOM，并在不同的浏览器中工作。
- en: 'To make the writing of the specs easier, we''re going to use Jasmine jQuery,
    a Jasmine extension that adds new matchers to perform assertions on jQuery objects.
    To install it and its jQuery dependency, download the following files:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使编写规格说明更容易，我们将使用Jasmine jQuery，这是一个向Jasmine添加新匹配器的Jasmine扩展，用于对jQuery对象进行断言。为了安装它及其jQuery依赖项，请下载以下文件：
- en: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/lib/jasmine-jquery.js)'
- en: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js](https://raw.githubusercontent.com/velesin/jasmine-jquery/2.1.0/vendor/jquery/jquery.js)'
- en: 'Save these files as `jasmine-jquery.js` and `jquery.js` respectively inside
    the `lib` folder, and add them to `SpecRunner.html`, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些文件分别保存为`jasmine-jquery.js`和`jquery.js`，存放在`lib`文件夹中，并将它们添加到`SpecRunner.html`中，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As seen until now, we have already created separate abstractions to handle both
    an investment and its associated stock. Now, it is time to develop this application's
    user interface and achieve a good result, which is all a matter of organization
    and good practices.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如至今所见，我们已创建了处理投资及其相关股票的独立抽象。现在，是时候开发这个应用的用户界面并取得良好的结果了，这完全是组织良好和良好实践的问题。
- en: The same principles of software engineering that we apply on the server-side
    code must not be left behind when writing frontend JavaScript code. It is still
    important to think about components and proper separation of concerns.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写前端JavaScript代码时，我们应用于服务器端代码的软件工程原则不应被忽视。考虑组件和适当的关注点分离仍然很重要。
- en: Thinking in terms of components (Views)
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从组件（视图）的角度思考
- en: We've talked about the monolithic JavaScript code bases that plague most of
    the Web, which that are code bases that are impossible to test. And the best way
    not to fall into this trap is by coding the application driven by tests.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了困扰大多数Web应用的单一JavaScript代码库，这些代码库是无法测试的。避免陷入这个陷阱的最佳方法是通过测试驱动的应用开发来编写代码。
- en: 'Consider the mockup interface of our Investment Tracker application:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们的投资跟踪应用的原型界面：
- en: '![Thinking in terms of components (Views)](img/B04138_03_01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![从组件（视图）的角度思考](img/B04138_03_01.jpg)'
- en: This shows the Investment Tracker application's mockup interface
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了投资跟踪应用的原型界面
- en: 'How would we go about implementing it? It is easy to see that this application
    has two different responsibilities:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何实现它？很容易看出这个应用有两个不同的职责：
- en: One responsibility is to add an investment
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个职责是添加投资
- en: Another responsibility is to list the added investments
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个职责是列出已添加的投资
- en: So, we could start by breaking this interface into two different components.
    To better describe them, we are going to borrow a concept from **MVC frameworks**,
    such as `Backbone.js`, and call them **Views**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以从将这个界面拆分为两个不同的组件开始。为了更好地描述它们，我们将借鉴**MVC框架**（如`Backbone.js`）的概念，并称它们为**视图**。
- en: 'So, here it is, at the top level of the interface, with two base components:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是它，在接口的最高级别，有两个基本组件：
- en: '`NewInvestmentView`: This will be responsible for creating new investments'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`: 这将负责创建新的投资'
- en: '`InvestmentListView`: This is going to be a list of all added investments'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvestmentListView`: 这将是一个所有添加的投资列表'
- en: The module pattern
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块模式
- en: So, we understand how we must break up the code, but how do we organize it?
    Until now, we have created a file for each new function. This is a good practice,
    and we are going to see how we can improve on that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们理解了如何拆分代码，但我们应该如何组织它？到目前为止，我们为每个新函数创建了一个文件。这是一个好的做法，我们将看到我们如何改进这一点。
- en: 'Let''s start by thinking about our `NewInvestmentView` component. We can follow
    the pattern we''ve used until now and create a new file, `NewInvestmentView.js`,
    and place it in the `src` folder, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先思考一下我们的`NewInvestmentView`组件。我们可以遵循到目前为止使用的模式，创建一个新的文件，`NewInvestmentView.js`，并将其放置在`src`文件夹中，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that this JavaScript file is more robust than the examples shown
    until now. We have wrapped all the `NewInvestmentView` code inside an **immediately
    invoked function expression** (**IIFE**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这个JavaScript文件比到目前为止展示的例子更健壮。我们已经在**立即调用的函数表达式**（**IIFE**）中包装了所有的`NewInvestmentView`代码。
- en: It is called an IIFE because it declares a function and immediately invokes
    it, effectively creating new scope to declare local variables in.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为IIFE，因为它声明了一个函数并立即调用它，有效地创建了一个新的作用域来声明局部变量。
- en: 'A good practice is to use only local variables inside the IIFE. If it needs
    to use a global dependency, pass it through as a parameter. In this example, it
    is already passing three dependencies to the `NewInvestmentView` code: `jQuery`,
    `Investment`, and `Stock`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的做法是在IIFE内部只使用局部变量。如果它需要使用全局依赖项，可以通过参数传递。在这个例子中，它已经将三个依赖项传递给`NewInvestmentView`代码：`jQuery`、`Investment`和`Stock`。
- en: 'You can see this at the function declaration:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在函数声明中看到这一点：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And immediate invocation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 立即调用：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The biggest advantage of this practice is that we no longer need to worry about
    polluting the global namespace since everything we declare inside the IIFE will
    be local. This makes it much harder to mess with the global scope.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的最大优点是，我们不再需要担心污染全局命名空间，因为我们声明的所有内容都在IIFE内部是局部的。这使得干扰全局作用域变得更加困难。
- en: 'If we need to make anything global, we do that explicitly by attaching it with
    the global object, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使任何内容成为全局的，我们可以通过将全局对象附加来实现，如下所示：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Another advantage is the explicit dependency declaration. We know all about
    a file's external dependencies by glancing at its first line.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个优点是显式依赖项声明。通过查看文件的第一行，我们可以了解一个文件的所有外部依赖项。
- en: Although this practice does not have a great advantage right now (since all
    of the components are being exposed globally), we are going to see how to benefit
    from it in [Chapter 8](ch08.html "Chapter 8. Build Automation"), *Build Automation*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种做法现在没有很大的优势（因为所有组件都被公开为全局的），但我们将看到如何在[第8章](ch08.html "第8章。构建自动化") *构建自动化*
    中从中受益。
- en: This pattern is also known as the **module pattern**, and we will use it throughout
    the rest of the book (even though sometimes it is omitted for simplification purposes).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式也被称为**模块模式**，我们将在本书的其余部分使用它（尽管有时为了简化目的会省略）。
- en: Using HTML fixtures
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTML fixtures
- en: 'Continuing with the development of the `NewInvestmentView` component, we can
    write some basic acceptance criteria, such as the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 继续开发`NewInvestmentView`组件，我们可以编写一些基本的验收标准，如下所示：
- en: '`NewInvestmentView` should allow the input of the stock symbol'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`应允许输入股票代码'
- en: '`NewInvestmentView` should allow the input of shares'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`应允许输入股份'
- en: '`NewInvestmentView` should allow the input of the share price'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView`应允许输入股价'
- en: There are many more, but this is a good start.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多，但这是一个好的开始。
- en: 'Create a new spec file for this component in the new file `NewInvestmentViewSpec.js`
    inside the `spec` folder, and we can start to translate those specs, as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec`文件夹中的新文件`NewInvestmentViewSpec.js`中为这个组件创建一个新的规范文件，然后我们可以开始翻译这些规范，如下所示：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, before we can start to implement these, we must first understand the
    concept of **HTML fixtures**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们开始实施这些之前，我们首先必须理解**HTML fixtures**的概念。
- en: Test fixtures provide the base state in which the tests run. It could be a class
    instantiation, the definition of an object, or a piece of HTML. In other words,
    to test JavaScript code that handles a form submission, we need to have the form
    available when running the tests. The HTML code containing the form is an HTML
    fixture.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 测试固定文件提供了测试运行的基态。这可能是一个类的实例化、对象的定义或一段 HTML。换句话说，为了测试处理表单提交的 JavaScript 代码，在运行测试时我们需要有可用的表单。包含表单的
    HTML 代码是一个 HTML 固定文件。
- en: 'One way to handle this requirement is to manually append the required DOM element
    inside a setup function, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此要求的一种方法是在设置函数中手动附加所需的 DOM 元素，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, remove it during teardown, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在拆卸过程中将其移除，如下所示：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Otherwise, the spec would append a lot of garbage inside the document, and it
    could interfere with the results of other specs.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，规格可能会在文档内部附加大量垃圾，这可能会干扰其他规格的结果。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is important to know that specs should be independent, and that they can
    be run in any particular order. So, as a rule, treat specs completely in isolation
    from each other.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，规格应该是独立的，并且它们可以以任何特定的顺序运行。因此，通常情况下，将规格完全独立于彼此处理。
- en: 'A better approach is to have a container in the document where we always put
    the HTML fixtures, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是，在文档中有一个容器，我们总是将 HTML 固定文件放在那里，如下所示：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Change the code to the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码更改为以下内容：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That way, the next time a spec runs, it automatically overwrites the previous
    fixture with its own.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，下次运行规格时，它会自动用其自己的内容覆盖之前的固定文件。
- en: 'But, this can soon escalate into an incomprehensible mess as the fixtures get
    more complex:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，随着固定文件变得更加复杂，这可能会很快变成难以理解的混乱：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Wouldn't it be great if this fixture could be loaded from an external file?
    That is exactly what the Jasmine jQuery extension does with its **HTML fixture**
    module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个固定文件可以从外部文件加载，那岂不是很好？这正是 Jasmine jQuery 扩展程序通过其 **HTML 固定** 模块所做的事情。
- en: 'We can place that HTML code in an external file and load it in the document
    with a simple call to `loadFixtures`, passing the fixture file path, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将该 HTML 代码放在一个外部文件中，并通过简单的 `loadFixtures` 调用将其加载到文档中，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By default, the extension looks for files inside the `spec/javascripts/fixtures`
    folder (for the previous example, it would be `spec/javascripts/fixtures/MyFixture.html`)
    and loads its content inside a container, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，扩展程序会在 `spec/javascripts/fixtures` 文件夹内查找文件（对于前面的示例，将是 `spec/javascripts/fixtures/MyFixture.html`），并在容器内加载其内容，如下所示：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can also use another of the extension''s global functions to recreate the
    first example. The `setFixtures(html)` function accepts a parameter with the content
    to be placed in the container:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用扩展程序的另一个全局函数来重新创建第一个示例。`setFixtures(html)` 函数接受一个参数，其中包含要放置在容器中的内容：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The other available functions are as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的函数如下：
- en: '`appendLoadFixtures(fixtureUrl[, fixtureUrl, …])`: Instead of overwriting the
    content of the fixture container, this appends it'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendLoadFixtures(fixtureUrl[, fixtureUrl, …])`：而不是覆盖固定容器的内容，它会将其附加到内容上'
- en: '`readFixtures(fixtureUrl[, fixtureUrl, …])`: This reads a fixture container''s
    content, but instead of appending it to the document, it returns a string with
    its contents'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readFixtures(fixtureUrl[, fixtureUrl, …])`：这个函数读取一个固定容器的内容，但不是将其附加到文档中，而是返回一个包含其内容的字符串'
- en: '`appendSetFixtures(html)`: This is the same as `appendLoadFixtures` but with
    an HTML string instead of a file'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`appendSetFixtures(html)`：这与 `appendLoadFixtures` 相同，但使用 HTML 字符串而不是文件'
- en: The Jasmine jQuery fixture module caches each file, so we can load the same
    fixture multiple times without penalty at the test suite's speed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine jQuery 固定模块缓存每个文件，因此我们可以在测试套件的速率下多次加载相同的固定文件，而不会受到惩罚。
- en: It loads the fixtures using AJAX, and sometimes, a test might want to modify
    the inner workings of JavaScript or jQuery AJAX, as we will see in [Chapter 6](ch06.html
    "Chapter 6. Light Speed Unit Testing"), *Light Speed Unit Testing*, which would
    break the loading of a fixture. A workaround for this issue is to preload the
    required fixtures on the cache using the `preloadFixtures()` function.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 AJAX 加载固定文件，有时，一个测试可能想要修改 JavaScript 或 jQuery AJAX 的内部工作方式，正如我们将在第 6 章（“Light
    Speed Unit Testing”）中看到的，这可能会破坏固定文件的加载。解决此问题的方法是使用 `preloadFixtures()` 函数在缓存中预加载所需的固定文件。
- en: The `preloadFixtures(fixtureUrl[, fixtureUrl, …])` function loads one or more
    files in the cache without appending them to the document.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`preloadFixtures(fixtureUrl[, fixtureUrl, …])` 函数在缓存中加载一个或多个文件，但不将它们附加到文档中。'
- en: There is an issue, though, while using HTML. Jasmine jQuery loads the HTML fixtures
    using AJAX, but because of the **same origin policy** (**SOP**), modern browsers
    will block all AJAX requests when opening the `SpecRunner.html` with a `file://`
    protocol.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用HTML时存在一个问题。Jasmine jQuery使用AJAX加载HTML固定装置，但由于**同源策略**（**SOP**），现代浏览器在用`file://`协议打开`SpecRunner.html`时将阻止所有AJAX请求。
- en: A solution to this problem is to serve the spec runner through an HTTP server,
    as described in [Chapter 4](ch04.html "Chapter 4. Asynchronous Testing – AJAX"),
    *Asynchronous Testing – AJAX*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是通过HTTP服务器提供spec运行器，如第4章[异步测试 – AJAX](ch04.html "第4章。异步测试 – AJAX")中所述。
- en: For now, there is a workaround available in Chrome through the **command-line
    interface** (**CLI**) argument `--allow-file-access-from-files`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在Chrome中，可以通过**命令行界面**（**CLI**）参数`--allow-file-access-from-files`找到一个解决方案。
- en: 'As an example, in Mac OS X, it would require the following command in bash
    to open Chrome with this flag:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Mac OS X中，需要以下bash命令来以该标志打开Chrome：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: More details on this issue can be seen at the GitHub ticket [https://github.com/velesin/jasmine-jquery/issues/4](https://github.com/velesin/jasmine-jquery/issues/4).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于这个问题的细节可以在GitHub问题跟踪[https://github.com/velesin/jasmine-jquery/issues/4](https://github.com/velesin/jasmine-jquery/issues/4)中查看。
- en: Coming back to the `NewInvestmentView` component, we can start the development
    of the spec with the help of this HTML fixture plugin.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`NewInvestmentView`组件，我们可以借助这个HTML固定装置插件开始spec的开发。
- en: 'Create a folder named `fixtures` inside the `spec` folder. Based on the mockup
    interface, we can create a new HTML fixture called `NewInvestmentView.html` inside
    the `fixtures` folder, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spec`文件夹内创建一个名为`fixtures`的文件夹。根据模拟界面，我们可以在`fixtures`文件夹内创建一个新的HTML固定装置，名为`NewInvestmentView.html`，如下所示：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is an HTML fixture because it would otherwise be rendered by a server and
    the JavaScript code would simply attach to it and add behavior.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个HTML固定装置，因为它否则会被服务器渲染，JavaScript代码将简单地附加到它并添加行为。
- en: 'Because we are not saving this fixture at the plugin''s default path, we need
    to add a new configuration at the end of the `SpecHelper.js` file, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有在插件的默认路径上保存这个固定装置，我们需要在`SpecHelper.js`文件的末尾添加一个新的配置，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `NewInvestmentSpec.js` file, add a call to load the fixture:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NewInvestmentSpec.js`文件中，添加一个调用以加载固定装置：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And finally, add both the spec and the source to the runner after the `Stock.js`
    and `Investment.js` files are added, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在添加`Stock.js`和`Investment.js`文件之后，将spec和源代码添加到运行器中，如下所示：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Basic View coding rules
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本视图编码规则
- en: 'Now, it is time to start coding the first View component. To help us through
    the process, we are going to lay two basic rules for View coding happiness:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始编写第一个视图组件的代码了。为了帮助我们完成这个过程，我们将为视图编码制定两个基本规则：
- en: The View should encapsulate a DOM element
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图应该封装一个DOM元素
- en: Integrate Views with observers
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将视图与观察者集成
- en: So, let's see how they work individually.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看它们是如何单独工作的。
- en: The View should encapsulate a DOM element
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图应该封装一个DOM元素
- en: 'As mentioned earlier, a View is the behavior associated with a DOM element,
    so it makes sense to have this element related to the View. A good pattern is
    to pass a CSS `selector` in the View instantiation that indicates the element
    to which it should refer. Here is the spec for the `NewInvestmentView` component:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，视图是与DOM元素关联的行为，因此将此元素与视图相关联是有意义的。一个好的模式是在视图实例化时传递一个CSS`选择器`，以指示它应该引用的元素。以下是`NewInvestmentView`组件的spec：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the constructor function at the NewInvestmentView.js file, it uses jQuery
    to get the element for this selector and to store it in an instance variable `$element`
    (source), as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NewInvestmentView.js`文件的构造函数中，它使用jQuery获取此选择器的元素并将其存储在实例变量`$element`（来源）中，如下所示：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To make sure this code works, we should write the following test for it in
    the `NewInvestmentViewSpec.js` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保这段代码能正常工作，我们应该在`NewInvestmentViewSpec.js`文件中为它编写以下测试：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `toExist` matcher is a custom matcher provided by the Jasmine jQuery extension
    to check whether an element exists in the document. It validates the existence
    of the property on the JavaScript object and also the successful association with
    the DOM element.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`toExist`匹配器是Jasmine jQuery扩展提供的自定义匹配器，用于检查元素是否存在于文档中。它验证JavaScript对象上属性的存在性，以及与DOM元素的关联是否成功。'
- en: Passing the `selector` pattern to the View allows it to be instantiated multiple
    times to different elements on the document.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将`selector`模式传递给视图允许它被实例化多次，以不同的文档元素。
- en: Another advantage of having an explicit association is knowing that this View
    is not changing anything else on the document, as we will see next.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 明确关联的一个优点是知道这个视图不会改变文档中的其他任何内容，正如我们接下来将要看到的。
- en: A View is the behavior associated with a DOM element, so it shouldn't be messing
    around everywhere on the page. It should only change or access the element associated
    with it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是与DOM元素关联的行为，因此它不应该在页面的任何地方胡乱操作。它应该只更改或访问与其关联的元素。
- en: 'To demonstrate this concept, let''s implement another acceptance criterion
    regarding the default state of the View, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个概念，让我们实现另一个关于视图默认状态的验收标准，如下所示：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A naive implementation of the `getSymbolInput` method might use a global jQuery
    lookup to find the input and return its value:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`getSymbolInput`方法的简单实现可能会使用全局jQuery查找来找到输入并返回其值：'
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: However, that could lead to a problem; if there is another input with that class
    name somewhere else in the document, it might get the wrong result.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能会导致问题；如果文档的另一个地方有相同类名的输入，它可能会得到错误的结果。
- en: 'A better approach is to use the View''s associated element to perform a scoped
    lookup, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是使用视图关联的元素来执行范围查找，如下所示：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `find` function will only look for elements that are children of `this.$element`.
    It is as if `this.$element` represents the entire document for the View.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`函数将只查找`this.$element`的子元素。就像`this.$element`代表视图的整个文档一样。'
- en: 'Since we will use this pattern everywhere inside the View code, we can create
    a function and use it instead, as shown in the following code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在视图代码的每个地方使用这个模式，我们可以创建一个函数并使用它，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let''s suppose that from somewhere else in the application, we want to
    change the value of a `NewInvestmentView` form input. We know its class name,
    so it could be as simple as this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们从应用程序的另一个地方想要更改`NewInvestmentView`表单输入的值。我们知道它的类名，所以这可能就像这样简单：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: However, that simplicity hides a serious problem of encapsulation. This one
    line of code is creating a coupling with what should be an implementation detail
    of `NewInvestmentView`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种简单性隐藏了一个严重的封装问题。这一行代码正在创建与`NewInvestmentView`的实现细节应该分离的耦合。
- en: If another developer changes `NewInvestmentView`, renaming the input class name
    from `.new-investment-stock-symbol` to `.new-investment-symbol`, that one line
    would be broken.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个开发者更改`NewInvestmentView`，将输入类的名称从`.new-investment-stock-symbol`更改为`.new-investment-symbol`，那么这一行就会出错。
- en: To fix this, the developer would need to look at the entire code base for references
    to that class name.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，开发者需要查看整个代码库中对该类名的引用。
- en: 'A much safer approach is to respect the View and use its APIs, as shown in
    the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更安全的做法是尊重视图并使用其API，如下面的代码所示：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When implemented, that would look like the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当实施时，它看起来如下所示：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: That way, when the code gets refactored, there is only one point to perform
    the change—inside the `NewInvestmentView` implementation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当代码被重构时，只有一个地方需要执行更改——在`NewInvestmentView`实现内部。
- en: Since there is no sandboxing in the browser's document, which means that from
    anywhere in the JavaScript code, we can make a change anywhere in the document,
    there is not much that we can do, besides good practice, to prevent these mistakes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器文档中没有沙箱机制，这意味着从JavaScript代码的任何地方，我们都可以在文档的任何地方进行更改，因此除了良好的实践之外，我们几乎无法做任何事情来防止这些错误。
- en: Integrating Views with observers
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将视图与观察者集成
- en: Following the development of the Investment Tracker application, we would eventually
    need to implement the list of investments. But how would you go about integrating
    `NewInvestmentView` and `InvestmentListView`?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 随着投资跟踪应用程序的开发，我们最终需要实现投资列表。但你是如何将`NewInvestmentView`和`InvestmentListView`集成的呢？
- en: 'You could write an acceptance criterion for `NewInvestmentView`, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为`NewInvestmentView`编写一个验收标准，如下所示：
- en: Given the new investment View, when its add button is clicked, then it should
    add an investment to the list of investments.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 给定新的投资视图，当其添加按钮被点击时，它应该将投资添加到投资列表中。
- en: 'This is very straightforward thinking, and you can see by the writing that
    we are creating a direct relationship between the two Views. Translating this
    into a spec clarifies this perception, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种思考方式非常直接，从写作中我们可以看到我们正在在两个视图之间创建直接关系。将此转化为规范可以澄清这一认识，如下所示：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This solution creates a dependency between the two Views. The `NewInvestmentView`
    constructor now receives an instance of `InvestmentListView` as its `listView`
    parameter.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案在两个视图之间创建了一个依赖关系。`NewInvestmentView` 构造函数现在接收一个 `InvestmentListView` 实例作为其
    `listView` 参数。
- en: 'On its implementation, `NewInvestmentView` calls the `addInvestment` method
    of the `listView` object when its form is submitted:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在其实施过程中，`NewInvestmentView` 在表单提交时会调用 `listView` 对象的 `addInvestment` 方法：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To better clarify how this code works, here is a diagram of how the integration
    is done:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地阐明这段代码的工作原理，以下是集成是如何进行的图示：
- en: '![Integrating Views with observers](img/B04138_03_02.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![集成视图与观察者](img/B04138_03_02.jpg)'
- en: This shows a direct relationship between the two Views
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了两个视图之间的直接关系。
- en: Although very simple, this solution introduces a number of architectural problems.
    The first, and most obvious, is the increased complexity of the `NewInvestmentView`
    specs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很简单，但这个解决方案引入了许多架构问题。首先，也是最明显的，是 `NewInvestmentView` 规范的复杂性增加。
- en: Secondly, it makes evolving these components even more difficult due to the
    tight coupling.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于紧密耦合，这使得这些组件的演变变得更加困难。
- en: 'To better clarify this last problem, imagine that in the future, we want to
    list investments in a table too. This would impose a change in `NewInvestmentView`
    to support both the list and table Views, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地阐明最后一个问题，想象一下，在未来，我们还想在表格中列出投资。这将要求对 `NewInvestmentView` 进行更改以支持列表和表格视图，如下所示：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Rethinking on the acceptance criterion, we can get into a much better, future-proof
    solution. Let''s rewrite it as:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 重新思考验收标准，我们可以得到一个更好、更具前瞻性的解决方案。让我们将其重写如下：
- en: Given the Investment Tracker application, when a new investment is created,
    then it should add the investment to the list of investments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在投资跟踪器应用程序中，当创建新的投资时，它应该将投资添加到投资列表中。
- en: 'We can see by the acceptance criterion that it has introduced a new subject
    to be tested: Investment Tracker. This implies a new source and spec file. After
    creating both the files accordingly and adding them to the runner, we can write
    this acceptance criterion as a spec, as shown in the following code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过验收标准，我们可以看到它引入了一个新的待测试主题：投资跟踪器。这暗示了新的源文件和规范文件。在相应地创建这两个文件并将它们添加到运行器之后，我们可以将此验收标准作为规范编写，如下面的代码所示：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can see the same setup code that once was inside the `NewInvestmentView`
    spec. It loads the fixtures required by both Views, instantiates both `InvestmentListView`
    and `NewInvestmentView`, and creates a new instance of `InvestmentTracker`, passing
    both Views as parameters.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到之前在 `NewInvestmentView` 规范中曾有的相同设置代码。它加载了两个视图所需的固定数据，实例化了 `InvestmentListView`
    和 `NewInvestmentView`，并创建了一个新的 `InvestmentTracker` 实例，将两个视图作为参数传递。
- en: Later on, while describing the behavior `when a new investment is created`,
    we can see the function call to the `newView.create` function to create a new
    investment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在后来描述行为 `when a new investment is created` 时，我们可以看到调用 `newView.create` 函数来创建新的投资。
- en: Later, it checks that a new item was added to the `listView` object by checking
    that `listView.count()` is equal to `1`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，它通过检查 `listView.count()` 是否等于 `1` 来确认是否向 `listView` 对象添加了新项。
- en: 'But how does the integration happen? We can see that by looking at the `InvestmentTracker`
    implementation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但集成是如何发生的呢？我们可以通过查看 `InvestmentTracker` 的实现来了解：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It uses the `onCreate` function to register an observer function as a callback
    at `newView`. This observer function will be invoked later when a new investment
    is created.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用 `onCreate` 函数在 `newView` 上注册一个观察函数作为回调。这个观察函数将在创建新投资时被调用。
- en: 'The implementation inside `NewInvestmentView` is quite simple. The `onCreate`
    method stores the `callback` parameter as an attribute of the object, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 内部的实现相当简单。`onCreate` 方法将 `callback` 参数存储为对象的属性，如下所示：'
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The naming convention of the `_callback` attribute might sound strange, but
    it is a good convention to indicate it as a private member.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`_callback` 属性的命名约定可能听起来有些奇怪，但将其作为私有成员的约定是一个好习惯。'
- en: Although the prepended underline character won't actually change the visibility
    of the attribute, it at least informs a user of this object that the `_callback`
    attribute might change or even be removed in the future.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前置的下划线字符实际上不会改变属性的可见性，但它至少会通知用户这个对象，`_callback` 属性可能会在未来更改或甚至被删除。
- en: 'Later, when the `create` method is invoked, it invokes `_callback`, passing
    the new investment as a parameter, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `create` 方法时，它会调用 `_callback`，并将新的投资作为参数传递，如下所示：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: A more complete implementation would need to allow multiple calls to `onCreate`,
    storing every passed callback.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更完整的实现需要允许多次调用 `onCreate`，并存储每个传递的回调。
- en: 'Here is the solution illustrated for better understanding:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于更好理解的解决方案图示：
- en: '![Integrating Views with observers](img/B04138_03_03.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![将视图与观察者集成](img/B04138_03_03.jpg)'
- en: Using callbacks to integrate the two Views
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用回调来集成两个视图
- en: Later, in [Chapter 7](ch07.html "Chapter 7. Testing React Applications"), *Testing
    React.js Applications*, we will see how the implementation of this `NewInvestmentView`
    spec turned out to be.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的 [第 7 章](ch07.html "第 7 章。测试 React 应用程序")，*测试 React.js 应用程序* 中，我们将看到 `NewInvestmentView`
    规范的实现结果。
- en: Testing Views with jQuery matchers
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jQuery 匹配器测试视图
- en: Besides its HTML fixture module, the Jasmine jQuery extension comes with a set
    of custom matchers, which help in writing expectations with the DOM elements.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其 HTML 固件模块之外，Jasmine jQuery 扩展还附带了一套自定义匹配器，这些匹配器有助于使用 DOM 元素编写期望。
- en: The biggest advantage of using these custom matchers, as demonstrated, is that
    they generate better error messages. So, although we can write all specs without
    using any of these matchers, it would get us much more useful information when
    an error happens if we used the matchers.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，使用这些自定义匹配器的最大优势是它们生成更好的错误信息。因此，尽管我们可以编写所有规范而不使用这些匹配器，但如果我们在出错时使用匹配器，我们会得到更多有用的信息。
- en: 'To better understand this advantage, we can revisit the example of the `should
    expose a property with its DOM element` spec. There, it uses the `toExist` matcher:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个优势，我们可以回顾一下 `should expose a property with its DOM element` 规范的示例。在那里，它使用了
    `toExist` 匹配器：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If this spec fails, we get a nice error message, as shown in the following
    screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个规范失败，我们会得到一个如以下截图所示的错误信息：
- en: '![Testing Views with jQuery matchers](img/B04138_03_04.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![使用 jQuery 匹配器测试视图](img/B04138_03_04.jpg)'
- en: This shows a nice custom matcher error message
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了自定义匹配器错误信息的示例
- en: 'Now, we rewrite this spec without the custom matcher (still making the same
    validation):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们重写这个规范，不使用自定义匹配器（仍然进行相同的验证）：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This time, the error message gets less informative:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，错误信息变得不那么有信息量：
- en: '![Testing Views with jQuery matchers](img/B04138_03_05.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![使用 jQuery 匹配器测试视图](img/B04138_03_05.jpg)'
- en: Upon reading the error, we can't understand what it is truly testing
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 读取错误后，我们无法理解它真正测试的是什么
- en: 'So, use these matchers whenever you can to get better error messages. Let''s
    go over some of the available custom matchers, demonstrated by example, with these
    acceptance criteria of the `NewInvestmentView` class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当可能的时候，使用这些匹配器来获取更好的错误信息。让我们通过一些示例来回顾一下可用的自定义匹配器，这些示例展示了 `NewInvestmentView`
    类的验收标准：
- en: '`NewInvestmentView` should allow the input of the stock symbol'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该允许输入股票符号'
- en: '`NewInvestmentView` should allow the input of shares'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该允许输入股份'
- en: '`NewInvestmentView` should allow the input of the share price'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该允许输入股价'
- en: '`NewInvestmentView` should have an empty stock symbol'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该有一个空的股票符号'
- en: '`NewInvestmentView` should have its shares'' value at zero'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该将其股份值设置为零'
- en: '`NewInvestmentView` should have its share price value at zero'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 应该将其股价值设置为零'
- en: '`NewInvestmentView` should have its stock symbol input on focus'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 的股票符号输入应该在获得焦点时'
- en: '`NewInvestmentView` should not allow to add'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NewInvestmentView` 不应该允许添加'
- en: It is important that you understand that these next examples, although useful
    to demonstrate how the Jasmine jQuery matchers work, are not really testing any
    JavaScript code but only the HTML elements that were loaded by the HTML fixture
    module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，尽管以下示例对于演示 Jasmine jQuery 匹配器的工作方式很有用，但它们实际上并没有测试任何 JavaScript 代码，只是测试了由
    HTML 固件模块加载的 HTML 元素。
- en: The toBeMatchedBy jQuery matcher
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toBeMatchedBy jQuery 匹配器
- en: 'This matcher checks whether the element matches the passed CSS selector, as
    follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个匹配器检查元素是否匹配传递的 CSS 选择器，如下所示：
- en: '[PRE38]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The toContainHtml jQuery matcher
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toContainHtml jQuery 匹配器
- en: 'This matcher checks whether the content of the element matches the passed HTML,
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器检查元素的内容是否与传递的HTML匹配，如下所示：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The toContainElement jQuery matcher
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The toContainElement jQuery matcher
- en: This matcher checks whether the element contains any child element matching
    the passed CSS selector, as follows
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器检查元素是否包含任何匹配传递的CSS选择器的子元素，如下所示
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The toHaveValue jQuery matcher
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The toHaveValue jQuery matcher
- en: 'Only valid for inputs, this validates the expected value against the element''s
    value attribute with the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 仅对输入有效，此验证将预期值与元素的值属性进行比较，以下代码为：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The toHaveAttr jQuery matcher
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The toHaveAttr jQuery matcher
- en: 'This matcher tests whether the element has any attribute with the name and
    value specified. The following example shows how to use this matcher to test an
    input for its value attribute, an expectation that could have been written with
    the `toHaveValue` matcher:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器测试元素是否具有指定的名称和值的任何属性。以下示例展示了如何使用此匹配器测试输入的值属性，这可以用`toHaveValue`匹配器来编写预期：
- en: '[PRE42]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The toBeFocused jQuery matcher
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The toBeFocused jQuery matcher
- en: 'The following code illustrates how the matcher checks whether the input element
    is focused:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码说明了如何检查输入元素是否聚焦：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The toBeDisabled jQuery matcher
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The toBeDisabled jQuery matcher
- en: 'This matcher checks whether the element is disabled with the following code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 此匹配器检查元素是否被禁用，以下代码为：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: More matchers
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多匹配器
- en: The extension has many more available matchers; make sure to check the documentation
    of the project at [https://github.com/velesin/jasmine-jquery#jquery-matchers](https://github.com/velesin/jasmine-jquery#jquery-matchers).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 该扩展提供了更多可用的匹配器；请确保检查项目的文档，[https://github.com/velesin/jasmine-jquery#jquery-matchers](https://github.com/velesin/jasmine-jquery#jquery-matchers)。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how testing can become so much easier once you
    drive the application development by tests. You saw how to use the module pattern
    to better organize the project code and how the View pattern can help create a
    more maintainable browser code.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解到一旦通过测试驱动应用程序开发，测试可以变得多么简单。你看到了如何使用模块模式更好地组织项目代码，以及视图模式如何帮助创建更易于维护的浏览器代码。
- en: You learned how to use HTML fixtures, making your specs much more readable and
    understandable. I also showed you how to test code that interacts with the browser's
    DOM by the use of custom jQuery matchers.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你学习了如何使用HTML固定文件，使你的规格更加可读和易懂。我还展示了如何通过使用自定义jQuery匹配器来测试与浏览器DOM交互的代码。
- en: In the next chapter, we will go a step further and start testing server integration
    and asynchronous code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更进一步，开始测试服务器集成和异步代码。
