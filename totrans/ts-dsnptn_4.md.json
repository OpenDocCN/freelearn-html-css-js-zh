["```js\nif (type === 'value') { \n  // ... \n} else if (type === 'increment') { \n  // ... \n} else if (type === 'set') { \n  // ... \n} \n\n```", "```js\nlet strategy = strategies[type]; \nstrategy.operation(); \n\n```", "```js\ntype TargetType = 'a' | 'b'; \n\ninterface Target { \n  type: TargetType; \n} \n\ninterface TargetA extends Target { \n  type: 'a'; \n  result: string; \n} \n\ninterface TargetB extends Target { \n  type: 'b'; \n  value: number; \n} \n\ninterface Strategy<TTarget extends Target> { \n  operationX(target: TTarget): void; \n  operationY(target: TTarget): void; \n} \n\n```", "```js\nlet strategyA: Strategy<TargetA> = { \n  operationX(target) { \n    target.result = target.result + target.result; \n  }, \n  operationY(target) { \n    target.result = target \n      .result \n      .substr(Math.floor(target.result.length / 2)); \n  } \n}; \n\nlet strategyB: Strategy<TargetB> = { \n  operationX(target) { \n    target.value = target.value * 2; \n  }, \n  operationY(target) { \n    target.value = Math.floor(target.value / 2); \n  } \n}; \n\n```", "```js\nlet strategies: { \n  [type: string]: Strategy<Target> \n} = { \n  a: strategyA, \n  b: strategyB \n}; \n\n```", "```js\nlet targets: Target[] = [ \n  { type: 'a' }, \n  { type: 'a' }, \n  { type: 'b' } \n]; \n\nfor (let target of targets) { \n  let strategy = strategies[target.type]; \n\n  strategy.operationX(target); \n  strategy.operationY(target); \n} \n\n```", "```js\ninterface State { \n  render(hover: boolean): void; \n  click(): void; \n} \n\n```", "```js\nclass Context { \n  $element: JQuery; \n\n  state: State; \n\n  private render(hover: boolean): void { \n    this.state.render(hover); \n  } \n\n  private click(): void { \n    this.state.click(); \n  } \n\n  onclick(): void { \n    console.log('I am clicked.'); \n  } \n} \n\n```", "```js\nclass StateEnabled implements State { \n  constructor( \n    public context: Context \n  ) { } \n\n  render(hover: boolean): void { \n    this \n      .context \n      .$element \n      .removeClass('disabled') \n      .toggleClass('hover', hover); \n  } \n\n  click(): void { \n    this.context.onclick(); \n  } \n} \n\n```", "```js\nclass StateDisabled implements State { \n  constructor( \n    public context: Context \n  ) { } \n\n  render(): void { \n    this \n      .context \n      .$element \n      .addClass('disabled') \n      .removeClass('hover'); \n  } \n\n  click(): void { \n    // Do nothing. \n  } \n} \n\n```", "```js\nclass Context { \n  ... \n\n  private stateEnabled = new StateEnabled(this); \n  private stateDisabled = new StateDisabled(this); \n\n  state: State = this.stateEnabled; \n\n  ... \n} \n\n```", "```js\nconstructor() { \n  this \n    .$element \n    .hover( \n      () => this.render(true), \n      () => this.render(false) \n    ) \n    .click(() => this.click()); \n\n  this.render(false); \n} \n\n```", "```js\nabstract class TextReader { \n  async readAllText(): Promise<string> { \n    let bytes = await this.readAllBytes(); \n    let text = this.decodeBytes(bytes); \n\n    return text; \n  } \n\n  abstract async readAllBytes(): Promise<Buffer>; \n\n  abstract decodeBytes(bytes: Buffer): string; \n} \n\n```", "```js\nabstract class AsciiTextReader extends TextReader { \n  decodeBytes(bytes: Buffer): string { \n    return bytes.toString('ascii'); \n  } \n} \n\n```", "```js\nimport * as FS from 'fs'; \n\nclass FileAsciiTextReader extends AsciiTextReader { \n  constructor( \n    public path: string \n  ) { \n    super(); \n  } \n\n  async readAllBytes(): Promise<Buffer> { \n    return new Promise<Buffer>((resolve, reject) => { \n      FS.readFile(this.path, (error, bytes) => { \n        if (error) { \n          reject(error); \n        } else { \n          resolve(bytes); \n        } \n      }); \n    }); \n  } \n} \n\n```", "```js\nimport * as request from 'request'; \n\nclass HttpAsciiTextReader extends AsciiTextReader { \n  constructor( \n    public url: string \n  ) { \n    super(); \n  } \n\n  async readAllBytes(): Promise<Buffer> { \n    return new Promise<Buffer>((resolve, reject) => { \n      request(this.url, { \n        encoding: null \n      }, (error, bytes, body) => { \n        if (error) { \n          reject(error); \n        } else { \n          resolve(body); \n        } \n      }); \n    }); \n  } \n} \n\n```", "```js\nlet button = document.getElementById('do-button'); \n\nlet connected = false; \nlet loaded = false; \n\nfunction updateButton() { \n  let disabled = !connected && !loaded; \n  button.disabled = disabled; \n} \n\nconnection.on('statuschange', event => { \n  connected = event.connected; \n  updateButton(); \n}); \n\nactiveItem.on('statuschange', event => { \n  loaded = event.loaded; \n  updateButton(); \n}); \n\n```", "```js\nlet stateManager = new StateManager({ \n  connected: false, \n  loaded: false, \n  foo: 'abc', \n  bar: 123 \n}); \n\nstateManager.on(['connected', 'loaded'], () => { \n  let disabled = \n    !stateManager.connected && !stateManager.loaded; \n  button.disabled = disabled; \n}); \n\n```", "```js\ntype Observer = () => void; \n\nclass StateManager extends EventEmitter{ \n  constructor( \n    private state: any \n  ) { \n    super(); \n  } \n\n  set(key: string, value: any): void { } \n\n  get(key: string): any { } \n\n  on(state: string, listener: Observer): this; \n  on(states: string[], listener: Observer): this; \n  on(states: string | string[], listener: Observer): this { } \n} \n\n```", "```js\nprivate _get(identifiers: string[]): any { \n  let node = this.state; \n\n  for (let identifier of identifiers) { \n    node = node[identifier]; \n  } \n\n  return node; \n} \n\n```", "```js\nget(key: string): any { \n  let identifiers = key.split('.'); \n  return this._get(identifiers); \n} \n\n```", "```js\nset(key: string, value: any): void { \n  let identifiers = key.split('.'); \n  let lastIndex = identifiers.length - 1; \n\n  let node = this._get(identifiers.slice(0, lastIndex)); \n\n  node[identifiers[lastIndex]] = value; \n} \n\n```", "```js\nset(key: string, value: any): void { \n  let identifiers = key.split('.'); \n  let lastIndex = identifiers.length - 1; \n\n  let node = this._get(identifiers.slice(0, lastIndex)); \n\n  node[identifiers[lastIndex]] = value; \n\n  for (let i = identifiers.length; i > 0; i--) { \n    let key = identifiers.slice(0, i).join('.'); \n    this.emit(key); \n  } \n} \n\n```", "```js\non(state: string, listener: Observer): this; \non(states: string[], listener: Observer): this; \non(states: string | string[], listener: Observer): this { \n  if (typeof states === 'string') { \n    super.on(states, listener); \n  } else { \n    for (let state of states) { \n      super.on(state, listener); \n    } \n  } \n\n  return this; \n} \n\n```", "```js\n[ \n  Text { \n    content: \"Hello, \" \n  }, \n  BoldText { \n    content: \"TypeScript\" \n  }, \n  Text { \n    content: \"! Popular editors:\\n\" \n  }, \n  UnorderedList { \n    items: [ \n      ListItem { \n        content: \"Visual Studio Code\" \n      }, \n      ListItem { \n        content: \"Visual Studio\" \n      }, \n      ListItem { \n        content: \"WebStorm\" \n      } \n    ] \n  } \n] \n\n```", "```js\ninterface Node { \n  appendTo(visitor: NodeVisitor): void; \n} \n\ninterface NodeVisitor { \n  appendText(text: Text): void; \n  appendBold(text: BoldText): void; \n  appendUnorderedList(list: UnorderedList): void; \n  appendListItem(item: ListItem): void; \n} \n\n```", "```js\nclass Text implements Node { \n  constructor( \n    public content: string \n  ) { } \n\n  appendTo(visitor: NodeVisitor): void { \n    visitor.appendText(this); \n  } \n} \n\nclass BoldText implements Node { \n  constructor( \n    public content: string \n  ) { } \n\n  appendTo(visitor: NodeVisitor): void { \n    visitor.appendBold(this); \n  } \n} \n\n```", "```js\nclass UnorderedList implements Node { \n  constructor( \n    public items: ListItem[] \n  ) { } \n\n  appendTo(visitor: NodeVisitor): void { \n    visitor.appendUnorderedList(this); \n  } \n} \n\nclass ListItem implements Node { \n  constructor( \n    public content: string \n  ) { } \n\n  appendTo(visitor: NodeVisitor): void { \n    visitor.appendListItem(this); \n  } \n} \n\n```", "```js\nclass HTMLVisitor implements NodeVisitor { \n  output = ''; \n\n  appendText(text: Text) { \n    this.output += text.content; \n  } \n\n  appendBold(text: BoldText) { \n    this.output += `<b>${text.content}</b>`; \n  } \n\n  appendUnorderedList(list: UnorderedList) { \n    this.output += '<ul>'; \n\n    for (let item of list.items) { \n      item.appendTo(this); \n    } \n\n    this.output += '</ul>'; \n  } \n\n  appendListItem(item: ListItem) { \n    this.output += `<li>${item.content}</li>`; \n  } \n} \n\n```", "```js\nclass MarkdownVisitor implements NodeVisitor { \n  output = ''; \n\n  appendText(text: Text) { \n    this.output += text.content; \n  } \n\n  appendBold(text: BoldText) { \n    this.output += `**${text.content}**`; \n  } \n\n  appendUnorderedList(list: UnorderedList) { \n    this.output += '\\n'; \n\n    for (let item of list.items) { \n      item.appendTo(this); \n    } \n  } \n\n  appendListItem(item: ListItem) { \n    this.output += `- ${item.content}\\n`; \n  } \n} \n\n```", "```js\nlet nodes = [ \n  new Text('Hello, '), \n  new BoldText('TypeScript'), \n  new Text('! Popular editors:\\n'), \n  new UnorderedList([ \n    new ListItem('Visual Studio Code'), \n    new ListItem('Visual Studio'), \n    new ListItem('WebStorm') \n  ]) \n]; \n\n```", "```js\nlet htmlVisitor = new HTMLVisitor(); \nlet markdownVisitor = new MarkdownVisitor(); \n\nfor (let node of nodes) { \n  node.appendTo(htmlVisitor); \n  node.appendTo(markdownVisitor); \n} \n\nconsole.log(htmlVisitor.output); \nconsole.log(markdownVisitor.output); \n\n```"]