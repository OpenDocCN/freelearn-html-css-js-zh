- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Intermediate JavaScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中级JavaScript
- en: The concepts and solution approaches presented up to this point in the book
    are not the only way to think about solving issues. In this chapter, we will challenge
    you to look a little deeper, be curious, and practice the good habit of optimizing
    solutions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书到目前为止所提出的概念和解决方案方法并不是解决问题的关键途径。在本章中，我们将挑战你深入思考，保持好奇心，并练习优化解决方案的良好习惯。
- en: 'In previous chapters, you were promised great things about this chapter because
    the optimal use of some built-in methods require knowledge of regular expressions,
    which we will cover in this chapter. There is a lot more fun to be had though—here
    is a list of topics that we''ll cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们承诺在本章中会有很多精彩的内容，因为一些内置方法的最佳使用需要了解正则表达式，我们将在本章中介绍。还有更多有趣的内容——以下是我们将要涵盖的主题列表：
- en: Regular expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Functions and the arguments object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数和参数对象
- en: JavaScript hoisting
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript提升
- en: Strict mode
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格模式
- en: Debugging
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Using cookies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用cookie
- en: Local storage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地存储
- en: JSON
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: As you can see, a selection of diverse topics, but all advanced and fun. The
    sections in this chapter are not as related to each other as you might have gotten
    used to by now. They are mostly individual topics that can help to really enhance
    your understanding and improve your JavaScript knowledge a lot.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一系列多样化的主题，但都是高级且有趣的。本章中的部分内容并不像你现在可能已经习惯的那样相互关联。它们大多是独立的话题，可以帮助真正增强你的理解，并大大提高你的JavaScript知识。
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: Regular expressions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: '**Regular expressions**, also known as **regex**, are simply ways to describe
    text patterns. You can consider them next-level strings. There are different regex
    implementations. This means that depending on the interpreter, regex might differ
    a bit in the way they''re written. However, they are somewhat standardized, so
    you write them (almost) the same for all versions of regex. We are going to use
    regex for JavaScript.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**正则表达式**，也称为**regex**，只是描述文本模式的一种方式。你可以把它们看作是更高级的字符串。存在不同的正则表达式实现。这意味着根据解释器的不同，正则表达式的写法可能会有所不同。然而，它们在一定程度上是标准化的，所以你几乎可以用相同的方式为所有版本的正则表达式编写它们。我们将使用正则表达式进行JavaScript编程。'
- en: Regex can be very useful in many situations, for example when you need to look
    for errors in a large file or retrieve the browser agent a user is using. They
    can also be used for form validation, as with regex you can specify valid patterns
    for field entries such as email addresses or phone numbers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式在许多情况下非常有用，例如当你需要在大文件中查找错误或检索用户正在使用的浏览器代理时。它们也可以用于表单验证，因为使用正则表达式，你可以指定字段条目（如电子邮件地址或电话号码）的有效模式。
- en: 'Regex is not only useful for finding strings, but can also be used for replacing
    strings. By now you might think, *so regex is amazing, but is there a catch?*
    And yes, unfortunately, there is a catch. At first, regex might kind of look like
    your neighbor''s cat walked over your keyboard and just typed some random characters
    by accident. This regex checks for a valid email, for example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式不仅用于查找字符串，还可以用于替换字符串。到目前为止，你可能认为，“正则表达式真是太神奇了，但有没有什么陷阱呢？”是的，不幸的是，确实有陷阱。一开始，正则表达式可能看起来就像你邻居的猫走过了你的键盘，不小心输入了一些随机的字符。例如，这个正则表达式检查有效的电子邮件：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Fear not, after this section, you will be able to decipher the secret patterns
    within the regex. We are not going to go through everything there is to say about
    regex, but we will establish a solid level of familiarity that will allow you
    to work with them and expand your knowledge as you go.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕，在本节之后，你将能够解读正则表达式中的秘密模式。我们不会详细介绍正则表达式的所有内容，但我们将建立一个坚实的基础，这将使你能够使用它们，并在实践中扩展你的知识。
- en: 'Let''s start off easy. The regex pattern is specified between two slashes.
    This is a valid regex expression:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单开始。正则表达式模式指定在两个斜杠之间。这是一个有效的正则表达式表达式：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The above expression will match if a given string contains the word `JavaScript`.
    When it matches, this means the result is positive. And this can be used to do
    many things.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式将匹配如果给定的字符串包含单词`JavaScript`。当它匹配时，这意味着结果是正的。这可以用来做很多事情。
- en: We can use the JavaScript built-in `match()` function for this. This function
    returns the regex match on the result (if there is one) in the form of the substring
    that matched the starting position of this string and the input string.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 JavaScript 内置的 `match()` 函数来做这件事。这个函数返回正则表达式在结果（如果有）上的匹配（如果有的话），以匹配字符串的起始位置和输入字符串的子字符串形式。
- en: 'There are actually other built-in functions that use regex, but we will see
    them later. `match()` is just a convenient function to demonstrate how regex works.
    You can see it in action here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上还有其他使用正则表达式的内置函数，但我们会稍后介绍。`match()` 只是一个方便的函数，用来演示正则表达式是如何工作的。你可以在下面看到它的实际应用：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This logs null because it is case-sensitive by default and therefore is not
    a match. If we had looked for `/ava/` or simply `/a/`, it would have matched because
    it contains `ava` and `a`. If you want it to be case-insensitive, you can specify
    this using an `i` after the slash. In this case-insensitive example, the expression
    will match the previous string:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这记录了 `null`，因为它默认是大小写敏感的，因此不匹配。如果我们搜索 `/ava/` 或简单地搜索 `/a/`，它就会匹配，因为它包含 `ava`
    和 `a`。如果你想让它不区分大小写，你可以在斜杠后指定一个 `i`。在这个不区分大小写的例子中，表达式将匹配前面的字符串：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will actually log the result, because it is now case-insensitive, and
    from that point of view, our string does contain `javascript`. Here is the result:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上会记录结果，因为它现在是大小写不敏感的，从这个角度来看，我们的字符串确实包含 `javascript`。以下是结果：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The result is an object, containing the found match and the index it started
    on, as well as the input that was looked through. The groups are undefined. You
    can create groups with round parentheses, as you'll see when we get to the section
    on groups.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个对象，包含找到的匹配项及其开始索引，以及被检查的输入。组是未定义的。你可以使用圆括号创建组，就像我们在关于组的章节中看到的那样。
- en: You can often find regex in JavaScript in combination with the built-in search
    and replace method on strings, which we'll cover next.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你经常可以在 JavaScript 中找到正则表达式与字符串的内置搜索和替换方法的结合，我们将在下一节中介绍。
- en: Specifying multiple options for words
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定多个单词选项
- en: 'In order to specify a certain range of options, we can use this syntax:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定一定范围的选项，我们可以使用这种语法：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, the expression matches either `javascript`, `nodejs`, or `react`. At
    this point, we are only matching for the first encounter and then we quit. So
    this is not going to find two or more matches right now—it will output the same
    thing as before:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，表达式匹配 `javascript`、`nodejs` 或 `react`。到目前为止，我们只匹配第一次出现，然后退出。所以这现在不会找到两个或更多的匹配项——它将输出与之前相同的内容：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It logs this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 它记录了以下内容：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we wanted to find all matches, we could specify the global modifier, `g`.
    It is very similar to what we did for case-insensitive searches. In this example,
    we are checking for all matches, and it is case-insensitive. All the modifiers
    are behind the last slash. You can use multiple modifiers at the same time as
    we do below, or you could decide to only use `g`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要找到所有匹配项，我们可以指定全局修饰符 `g`。它与我们在大小写不敏感搜索中所做的是非常相似的。在这个例子中，我们正在检查所有匹配项，并且它是大小写不敏感的。所有修饰符都在最后一个斜杠之后。你可以像我们下面这样做，同时使用多个修饰符，或者你可以决定只使用
    `g`：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This returns both `React` and `JavaScript` as a result:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回了 `React` 和 `JavaScript` 作为结果：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, the result looks very different now. As soon as you specify
    `g`, the match function will just return an array of the matching words. This
    is not too exciting in this case, since these are the words we asked for. But
    it can be more of a surprise with a more complex pattern. This is exactly what
    we'll learn next.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果现在看起来非常不同。一旦你指定了 `g`，匹配函数将只返回一个匹配单词的数组。在这种情况下，这并不太令人兴奋，因为这些正是我们要求的单词。但与更复杂的模式相比，这可能会更令人惊讶。这正是我们接下来要学习的。
- en: Character options
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符选项
- en: 'So far, our expressions are quite readable, right? The character options are
    where things start to look, well, intense. Say we want to search for a string
    of only one character equal to `a`, `b`, or `c`. We would write it like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的表达式相当易于阅读，对吧？字符选项是事情开始看起来，嗯，很复杂的地方。比如说我们想要搜索一个只包含一个字符等于 `a`、`b` 或 `c`
    的字符串。我们会这样写：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will return `null` because `d` is not `a`, `b`, or `c`. We can include
    `d` like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回 `null`，因为 `d` 不是 `a`、`b` 或 `c`。我们可以这样包含 `d`：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will log:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录以下内容：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since this is a range of characters, we can write it shorter, like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个字符范围，我们可以将其写得更短，就像这样：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And if we wanted any letter, lowercase or uppercase, we would write this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要任何字母，无论是大写还是小写，我们会这样写：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We could actually also use the case-insensitive modifier to achieve the same
    thing, but this would apply to the regex pattern as a whole, and you might only
    need it to apply for the specific character:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上也可以使用不区分大小写的修饰符来实现相同的效果，但这将应用于整个正则表达式模式，而你可能只需要它应用于特定的字符：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We would get a match on both of the preceding options. If we wanted to include
    numbers as well, we would write:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这两个前面的选项上得到匹配。如果我们还想包括数字，我们将写：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we can just concatenate ranges to specify one character, much
    like we could concatenate possible options for that specific character, like `[abc]`.
    The example above specifies three possible ranges. It will match any lowercase
    or uppercase letter from a to z and all numeric characters as well.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们只需连接范围来指定一个字符，就像我们可以为特定字符的可能选项连接起来一样，例如`[abc]`。上面的例子指定了三个可能的范围。它将匹配任何从a到z的小写或大写字母以及所有数字字符。
- en: 'It doesn''t mean that it can only match a one-character string by the way;
    it will just match the first matching character in this case because we didn''t
    add the global modifier. However, these special characters won''t match:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着它只能匹配一个字符的字符串；在这种情况下，它只会匹配第一个匹配的字符，因为我们没有添加全局修饰符。然而，这些特殊字符不会匹配：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To address the difficulty of complex characters not matching an expression,
    the dot functions as a special wildcard character in regex that can match any
    character. So what do you think this does?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决复杂字符不匹配表达式的问题，点在正则表达式中作为特殊通配符使用，可以匹配任何字符。那么你认为这会做什么？
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Since it has the global modifier, it is going to match any character. This
    is the result:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它具有全局修饰符，它将匹配任何字符。这是结果：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'But what if you only wanted to find a match for the dot character itself? If
    you want a special character (one that is used in regex to specify a pattern)
    to have a normal meaning, or a normal character to have a special meaning, you
    can escape it using the backslash:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你只想找到点字符本身的匹配呢？如果你想使特殊字符（在正则表达式中用于指定模式的字符）具有普通含义，或者使普通字符具有特殊含义，你可以使用反斜杠来转义它：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this example, we escape the dot by adding a preceding backslash. Therefore,
    it doesn''t function as a wildcard and it is going to look for a literal match.
    This is what it will return:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过添加前导反斜杠来转义点。因此，它不作为通配符使用，它将寻找字面匹配。这就是它将返回的内容：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are some normal characters that get a special meaning by adding a backslash
    before them. We are not going to cover them in depth, but let''s have a look at
    some examples:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有些普通字符在它们前面加上反斜杠后会获得特殊含义。我们不会深入探讨它们，但让我们看看一些例子：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If we escape the d, `\d`, it matches any digit. We are doing a global search
    so it will specify any digit. This is the result:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们转义`d`，`\d`，它匹配任何数字。我们正在进行全局搜索，所以它将指定任何数字。这是结果：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also escape the s, `\s`, which matches all whitespace characters:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以转义`s`，`\s`，它匹配所有空白字符：
- en: '[PRE24]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The above example will just return a few spaces, but tabs and other types of
    whitespace are also included:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子将只返回几个空格，但制表符和其他类型的空白也被包括在内：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A very useful one is `\b`, which matches text only when it''s at the beginning
    of a word. So, in the following example, it is not going to match the instances
    of `in` in `beginning`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有用的一种是`\b`，它只在单词的开头匹配文本。所以，在下面的例子中，它不会匹配`beginning`中的`in`实例：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is what it will end up logging:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它最终记录的内容：
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Even though you can check for characters being numbers, the `match()` method
    belongs to the `string` object, so you implement it on numeric variables. For
    example, try the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以检查字符是否为数字，但`match()`方法属于`string`对象，所以你在数值变量上实现它。例如，尝试以下操作：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You should receive a `TypeError` saying that `nr.match()` is not a function.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收到一个`TypeError`，表示`nr.match()`不是一个函数。
- en: Groups
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组
- en: 'There are many reasons to group your regex. Whenever you want to match a group
    of characters, you can surround them with parentheses. Have a look at this example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多理由将正则表达式分组。无论何时你想匹配一组字符，你都可以用括号将它们括起来。看看这个例子：
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here it is going to look for either `love` or `dislike`, followed by a whitespace
    character, followed by `javascript` or `spiders`, and it will do so for all occurrences
    while ignoring whether they are in uppercase or lowercase. This is what it will
    log:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它将寻找`love`或`dislike`，后面跟着一个空格字符，然后是`javascript`或`spiders`，并且它会匹配所有出现的情况，而忽略它们是大写还是小写。这就是它将记录的内容：
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s just say we can match on roughly four combinations here. Two of them
    seem to make more sense to me personally:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 就说我们在这里可以匹配大约四种组合。其中两种对我来说个人感觉更有意义：
- en: Love spiders
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 喜爱蜘蛛
- en: Dislike spiders
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不喜欢蜘蛛
- en: Love JavaScript
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 喜爱JavaScript
- en: Dislike JavaScript
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不喜欢JavaScript
- en: 'Groups are very powerful when we know how to repeat them. Let''s see how to
    do that. Very often, you''ll find yourself in need of repeating a certain regex
    piece. We have several options for this. For example, if we want to match any
    four alphanumeric characters in a sequence, we could just write this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们知道如何重复它们时，组非常强大。让我们看看如何做到这一点。你经常会发现自己需要重复某个正则表达式片段。我们为此有几个选项。例如，如果我们想匹配一个序列中的任何四个字母数字字符，我们可以简单地写下这个：
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will produce the following as output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is a terrible way to go about repeating a block: let''s look for better
    options. If we only want it to be present 0 or 1 times, we can use the question
    mark. So this is for optional characters, for example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于重复的糟糕方法：让我们看看更好的选项。如果我们只想让它出现0次或1次，我们可以使用问号。所以这是可选字符的例子：
- en: '[PRE33]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This looks for a `g` character that may or not may be preceded by an `n`. Therefore,
    this will log:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这在 `g` 字符之前可能或可能没有 `n`。因此，这将记录：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Arguably, one time is not really an example of repeating. Let''s look at getting
    more repetitions. If you want something at least once, but optionally more often,
    you can use the plus sign: `+`. Here is an example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 争论起来，一次并不是重复的例子。让我们看看如何获得更多的重复。如果你想至少出现一次，但也可以更频繁地出现，你可以使用加号：`+`。以下是一个示例：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is going to match for the group `123` one or more times. And since this
    string is present, it will find a match. This is what will be logged:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将匹配组 `123` 一次或多次。由于这个字符串存在，它将找到匹配。这就是将被记录的内容：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It matches the whole string in this case, since it is just `123` repeated.
    There are also situations where you want to have a certain piece of regex match
    any number of times, which can be indicated with the asterisk: `*`. Here is an
    example regex pattern:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它匹配整个字符串，因为这里只是 `123` 的重复。也有这样的情况，你想要某个正则表达式片段匹配任意次数，这可以用星号 `*` 表示。以下是一个正则表达式模式的示例：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It will match with any `a` preceded by `123` any number of times. So it will
    match on the following, for example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它将匹配任何由 `123` 开头，后面跟着任意数量的 `a`。所以它将匹配以下内容，例如：
- en: 123123123a
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 123123123a
- en: 123a
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 123a
- en: a
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: a
- en: ba
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ba
- en: 'The last thing to note about repeating is that we can be more specific as well.
    We do this using this syntax `{min, max}`. Here is an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于重复的最后一件事是，我们可以更具体一些。我们使用这种语法 `{min, max}` 来做这件事。以下是一个示例：
- en: '[PRE38]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This will log:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录：
- en: '[PRE39]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It does this because it will match on `abc` both once and twice. As you can
    see, we have been using groups, but `groups` is still `undefined` in the output.
    In order to specify groups, we''ll have to name them. Here''s an example of how
    to do it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它这样做是因为它会匹配 `abc` 一次和两次。正如你所见，我们一直在使用组，但输出中的 `groups` 仍然是 `undefined`。为了指定组，我们必须给它们命名。以下是一个如何做到这一点的示例：
- en: '[PRE40]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There is more to say about regex, but this should already enable you to do quite
    a lot of cool things with it. Let's have a look at some practical examples.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 关于正则表达式，还有更多要说的，但这应该已经能够让你用它做很多酷的事情。让我们看看一些实际例子。
- en: Practical regex
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际的正则表达式
- en: Regex can be of great use in many situations—anywhere you need to match certain
    string patterns, regex will come in handy. We are going to discuss how you can
    use regex in combination with other string methods, and how you can use it to
    validate email addresses and IPv4 addresses.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式在许多情况下非常有用——任何你需要匹配特定字符串模式的地方，正则表达式都会派上用场。我们将讨论如何将正则表达式与其他字符串方法结合使用，以及如何使用它来验证电子邮件地址和IPv4地址。
- en: Searching and replacing strings
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 搜索和替换字符串
- en: In *Chapter 8*, *Built-In JavaScript Methods*, we saw the search and replace
    methods on strings. We would have liked our search to be case-insensitive, though.
    Guess what—we can use regex for this!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第8章*，*内置JavaScript方法* 中，我们看到了字符串上的搜索和替换方法。我们原本希望我们的搜索是不区分大小写的。猜猜看——我们可以使用正则表达式来实现这一点！
- en: '[PRE42]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Adding the `i` modifier here ignores the distinction between uppercase and lowercase.
    This code returns `15`, which is the starting index position of the match. This
    cannot be done using the normal string input.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里添加 `i` 修饰符会忽略大小写之间的区别。此代码返回 `15`，这是匹配的起始索引位置。这不能使用正常的字符串输入来完成。
- en: 'How do you think we can alter the behavior of the replace method using regex
    in such a way that we can replace all instances rather than the first instance
    of a string? Again, with a modifier! We use the global modifier (`g`) for this.
    To get a feel for the difference, look at this expression without `g`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为我们如何使用正则表达式来改变替换方法的行怍，以便我们可以替换字符串的所有实例而不是第一个实例？再次，使用修饰符！我们使用全局修饰符（`g`）来做这件事。为了感受一下区别，看看没有
    `g` 的这个表达式：
- en: '[PRE43]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This is what it outputs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它的输出结果：
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Without regex, it only replaces the first encounter. This time, let''s see
    it with the `g` global modifier:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用正则表达式时，它只替换第一次遇到的内容。这次，让我们用带有 `g` 全局修饰符的例子来看一下：
- en: '[PRE45]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The result is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As you can see, all occurrences are replaced.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有实例都被替换了。
- en: Practice exercise 12.1
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.1
- en: Find and replace strings. The following exercise involves replacing characters
    in a specified string value. The first input field will indicate which character
    string will be replaced, and the second input field will indicate which characters
    will replace them once the button is clicked.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 查找和替换字符串。以下练习涉及在指定的字符串值中替换字符。第一个输入字段将指示哪个字符串将被替换，第二个输入字段将指示点击按钮后用哪些字符替换它们。
- en: 'Use the HTML below as a template, and add the JavaScript needed to complete
    the task:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下面的HTML作为模板，并添加完成任务的JavaScript：
- en: '[PRE47]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Take the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Select each of the three page elements using JavaScript and assign the element
    objects as variables so that they can be easily referenced in your code.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JavaScript选择三个页面元素中的每一个，并将元素对象分配给变量，以便在您的代码中轻松引用。
- en: Add an event listener to the button to invoke a function when clicked.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加事件监听器，以便在点击时调用函数。
- en: Create a function named `lookup()` that will find and replace the text in the
    output element. Assign the output element's text content to a variable named `s`,
    and then assign the value of the input we are replacing to another variable named
    `rt`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `lookup()` 的函数，该函数将在输出元素中查找并替换文本。将输出元素的文本内容分配给名为 `s` 的变量，然后将我们要替换的输入值分配给另一个名为
    `rt` 的变量。
- en: Create a new regex with the value of the first input field, which will allow
    you to replace the text. Using the regex, check for a match with the `match()`
    method. Wrap this with a condition that will execute a block of code if matches
    are found.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用第一个输入字段的值创建一个新的正则表达式，这将允许您替换文本。使用正则表达式，使用 `match()` 方法检查匹配。将此与一个条件包装起来，如果找到匹配项，则执行代码块。
- en: If the match is found, use `replace()` to set the new value.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果找到匹配项，使用 `replace()` 来设置新值。
- en: Update the output area with the newly created and updated text output.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新创建和更新的文本输出更新输出区域。
- en: Email validation
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电子邮件验证
- en: In order to create a regex pattern, we need to be able to describe the pattern
    with words first. Email addresses consist of five parts, in the form of `[name]@[domain].[extension]`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个正则表达式模式，我们首先需要能够用文字描述该模式。电子邮件地址由五个部分组成，形式为 `[name]@[domain].[extension]`。
- en: 'Here are the five parts explained:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是五个部分的解释：
- en: '`name`: One or more alphanumerical characters, underscores, dashes, or dots'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`name`: 一个或多个字母数字字符、下划线、破折号或点'
- en: '`@`: Literal character'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@`: 文字字符'
- en: '`domain`: One or more alphanumerical characters, underscores, dashes, or dots'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`domain`: 一个或多个字母数字字符、下划线、破折号或点'
- en: '`.`: Literal dot'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`.`: 文字点'
- en: '`extension`: One or more alphanumerical characters, underscores, dashes, or
    dots'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`extension`: 一个或多个字母数字字符、下划线、破折号或点'
- en: 'So, let''s do the steps for regex:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们按照正则表达式的步骤来做：
- en: '`[a-zA-Z0-9._-]+`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[a-zA-Z0-9._-]+`'
- en: '`@`'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@`'
- en: '`[a-zA-Z0-9._-]+`'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[a-zA-Z0-9._-]+`'
- en: '`\.` (remember, the dot is a special character in regex, so we need to escape
    it)'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`\.`（记住，点在正则表达式中是一个特殊字符，所以我们需要转义它）'
- en: '`[a-zA-Z0-9._-]+`'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`[a-zA-Z0-9._-]+`'
- en: 'Putting it all together:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起：
- en: '[PRE48]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s look at this regex in action:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个正则表达式在实际中的应用：
- en: '[PRE49]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We tested the pattern on both a valid and an invalid email address, and this
    is the output:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在有效和无效的电子邮件地址上测试了该模式，这是输出结果：
- en: '[PRE50]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, it returns a result for the valid email and it returns null
    (no match) for the invalid email.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它为有效的电子邮件返回结果，对于无效的电子邮件返回 null（没有匹配）。
- en: Practice exercise 12.2
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习12.2
- en: 'Create an application that uses JavaScript to check whether the string value
    of an input is a validly formatted email using regex. Look at the following template:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个使用JavaScript检查输入字符串值是否使用正则表达式正确格式化的电子邮件的应用程序。查看以下模板：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Take the following steps:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Use the above template code to start creating your application. Within the JavaScript
    code, select the `input`, `output`, and `button` elements from the page as JavaScript
    objects.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上述模板代码开始创建你的应用程序。在JavaScript代码中，选择页面上的`input`、`output`和`button`元素作为JavaScript对象。
- en: Add an event listener to the button to run a block of code when clicked that
    will get the current value in the input field. Create a blank response value that
    will populate the output `div` element contents.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加事件监听器，当点击时运行一段代码，该代码将获取输入字段中的当前值。创建一个空白的响应值，用于填充输出`div`元素的 内容。
- en: Add a test with the string value from the input field and the expression for
    email format. If the test result is `false`, update the response output to say
    `Invalid Email` and change the output color to `red`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用输入字段中的字符串值和电子邮件格式表达式添加一个测试。如果测试结果为`false`，则更新响应输出为`无效电子邮件`，并将输出颜色更改为`红色`。
- en: If the condition of the test returns `true`, add a response that confirms the
    email format is correct and change the text color of output to `green`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试条件返回`true`，则添加一个确认电子邮件格式正确的响应，并将输出文本颜色更改为`绿色`。
- en: Output the response value into the output element.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应值输出到输出元素中。
- en: Functions and the arguments object
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和参数对象
- en: 'JavaScript deals with arguments in functions by adding them to a custom object
    called `arguments`. This object works a lot like an array, and we can use it instead
    of using the name of the parameter. Consider the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript通过将参数添加到名为`arguments`的自定义对象中来处理函数中的参数。这个对象非常像数组，我们可以用它来代替参数名。考虑以下代码：
- en: '[PRE52]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This outputs:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE53]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When you update one of the parameters, the argument gets changed accordingly.
    The same goes for the other way around;
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更新其中一个参数时，参数对象会相应地改变。反之亦然；
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This is going to change both `arguments[0]` and `b`, as they are related to
    `a` and `arguments[1]`, respectively, as you can see in the output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将同时改变`arguments[0]`和`b`，因为它们分别与`a`和`arguments[1]`相关，如输出所示：
- en: '[PRE55]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the function is called with more arguments than were declared in the function
    signature, this is the way to access them. However, the modern way is to use the
    rest parameter `(…param)` instead of the `arguments` object.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数调用时传递的参数多于函数签名中声明的参数，可以通过这种方式访问它们。然而，现代的方式是使用剩余参数`(…param)`而不是`arguments`对象。
- en: In case you've forgotten what the rest parameter is, you can revisit the rest
    parameter in *Chapter 6*, *Functions*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你忘记了剩余参数是什么，可以回顾一下*第6章*，*函数*。
- en: Practice exercise 12.3
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.3
- en: 'This exercise will demonstrate using the array-like `arguments` object and
    extracting values from it. Using the `arguments` length property, we will iterate
    through the items in the arguments and return the last item in the list:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示如何使用类似数组的`arguments`对象并从中提取值。使用`arguments`的长度属性，我们将遍历参数中的项，并返回列表中的最后一个项：
- en: Create a function without any parameters. Create a loop to iterate through the
    length of the `arguments` object. This will allow an iteration of each item of
    the arguments in the function.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个不带参数的函数。创建一个循环来遍历`arguments`对象的长度。这将允许遍历函数中参数的每个项。
- en: Set up a variable called `lastOne` with a blank value.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个名为`lastOne`的变量，并赋予其空值。
- en: As you loop through the arguments, set `lastOne` to the current value of the
    argument using the index of `i` to return the argument value. The argument will
    have an index value that can be used to reference the value as you iterate through
    the `arguments` object.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遍历参数时，使用`i`的索引将`lastOne`设置为当前参数的值。参数将有一个索引值，可以用来在遍历`arguments`对象时引用值。
- en: Return the value of `lastOne`, which should only return the last argument value
    as the response.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`lastOne`的值，它应该只返回最后一个参数值作为响应。
- en: Output the response from the function, pass a number of arguments into the function,
    and console log the response result. You should see only the last item in the
    list. If you want to see each one, you can output them separately to the console
    as you look through the values, or construct an array that can then be returned,
    adding each one as you go through the arguments.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出函数的响应，向函数传递多个参数，并在控制台中记录响应结果。你应该只看到列表中的最后一个项。如果你想看到每一个，可以在查看值时分别将它们输出到控制台，或者构建一个数组，然后在遍历参数时添加每个值。
- en: JavaScript hoisting
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript提升
- en: 'In *Chapter 6*, *Functions*, we discussed that we have three different variables,
    `const`, `let`, and `var`, and we highly recommended that you should use `let`
    instead of `var` because of their different scopes. JavaScript **hoisting** is
    why. Hoisting is the principle of moving declarations of variables to the top
    of the scope in which they are defined. This allows you to do things that you
    cannot do in many other languages, and for good reason by the way. This should
    look normal:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第6章*，*函数*中，我们讨论了我们有三种不同的变量，`const`，`let`和`var`，我们强烈建议你应该使用`let`而不是`var`，因为它们的范围不同。JavaScript
    **提升**是原因。提升是将变量的声明移动到它们定义的作用域顶部的原则。这允许你做许多其他语言中不能做的事情，而且有很好的理由。这应该看起来很正常：
- en: '[PRE56]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'It just logs `5`. But thanks to hoisting, so does this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是输出`5`。但是多亏了提升，这也一样：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If you try to do this with `let`, you'll get a `ReferenceError`. This is why
    it is better to use `let`. Because clearly, this behavior is very hard to read,
    unpredictable, and you don't really need it.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用`let`来做这件事，你会得到一个`ReferenceError`。这就是为什么最好使用`let`的原因。因为很明显，这种行为很难阅读，不可预测，而且你实际上并不需要它。
- en: The reason this happens is that the JavaScript interpreter moves all the `var`
    declarations to the top of the file before processing the file. Only the declarations,
    not the initializations. This is why you get a result of `undefined` if you use
    it before having initialized it. And this is why it should be initialized before
    it has been declared. It was designed this way for memory allocation, but the
    side effects are undesirable.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 发生这种情况的原因是JavaScript解释器在处理文件之前将所有的`var`声明移动到文件的顶部。只有声明，不是初始化。这就是为什么如果你在使用它之前没有初始化它，你会得到一个`undefined`的结果。这就是为什么它应该在声明之前初始化。它是为了内存分配而设计的，但副作用是不希望的。
- en: However, there is a way to turn this behavior off. Let's see how we can do so
    in the next section!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种方法可以关闭这种行为。让我们在下一节中看看我们如何做到这一点！
- en: Using strict mode
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用严格模式
- en: 'We can change the understanding and forgiving behavior of JavaScript to some
    extent using strict mode. You can switch on strict mode with the following command
    in your code. This needs to be the first command of your code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在代码中使用以下命令在一定程度上改变JavaScript的理解和宽容行为。这需要成为你代码的第一个命令：
- en: '[PRE58]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Here is something that works when we don''t use strict mode:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在我们不使用严格模式时可以正常工作的事情：
- en: '[PRE59]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We forgot to declare `greeting`, so JavaScript did it for us by adding a `greeting`
    variable to the top level and it will log `Hello!`. If we enable strict mode,
    however, this will give an error:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忘记声明`greeting`，所以JavaScript通过在顶层添加一个`greeting`变量来为我们做了这件事，它将输出`Hello!`。然而，如果我们启用严格模式，这将给出一个错误：
- en: '[PRE60]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The error:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 错误：
- en: '[PRE61]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can also use strict mode only in a particular function: simply add it to
    the top of the function and it gets enabled for that function only. Strict mode
    alters a few other things too; for example, when using strict mode, there are
    fewer words that can be used as names for your variables and functions because
    they are likely to become reserved keywords in the future that JavaScript will
    need for its own language.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以只在特定的函数中使用严格模式：只需将其添加到函数的顶部，它就只为该函数启用。严格模式还会改变一些其他事情；例如，当使用严格模式时，可用作变量和函数名称的单词更少，因为它们很可能会成为JavaScript未来需要为其自身语言保留的关键字。
- en: Using strict mode is a great way of getting used to using JavaScript in the
    setting of frameworks or even for writing TypeScript later. It is typically considered
    a good practice nowadays, so we would encourage you to use this in your own code
    when you have the chance. This is often not an (easy) option when working with
    existing older code though.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用严格模式是习惯在框架环境中使用JavaScript或稍后编写TypeScript的好方法。如今，这通常被认为是一种良好的实践，因此我们鼓励你在有机会时在自己的代码中使用它。然而，当与现有的较老代码一起工作时，这通常不是一个（容易的）选项。
- en: 'Now we have seen strict mode, it''s time to dive into a whole different mode:
    debug mode! Debug mode is for when you are not busy writing or running your application,
    but are running it in a special way to spot the locations of any errors.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了严格模式，是时候深入探讨另一种完全不同的模式：调试模式！调试模式是在你忙于编写或运行应用程序，但以特殊方式运行它以定位任何错误的位置时使用的。
- en: Debugging
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试
- en: Debugging is a delicate art. In the beginning, it usually is very hard to spot
    what's wrong with your code. If you are using JavaScript in the browser and it
    is not behaving as you would expect, step 1 is always to open the console in the
    browser. Often it will contain errors that can help you further.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是一种精细的艺术。一开始，通常很难发现你的代码有什么问题。如果你在浏览器中使用JavaScript，并且它没有按预期运行，第一步总是打开浏览器的控制台。通常它将包含可以帮助你进一步了解的错误。
- en: If that doesn't solve it, you can log to the console in every step of your code,
    and also log the variables. This will give you some insight as to what is going
    on. It might just be that you are relying on a certain variable that happens to
    be undefined. Or perhaps you are expecting a certain value from a mathematical
    computation, but you've made an error and the result is something completely different
    from what you thought. Using `console.log()` during development to see what's
    happening is rather common.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这不能解决问题，你可以在代码的每一步中记录到控制台，并记录变量。这将给你一些关于正在发生什么的洞察。可能只是你依赖于某个恰好未定义的变量。或者也许你期望从数学计算中得到某个特定的值，但你犯了一个错误，结果与你的预期完全不同。在开发过程中使用`console.log()`来查看正在发生的事情是很常见的。
- en: Breakpoints
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点
- en: A more professional way to go about debugging is to use breakpoints. This can
    be done from most browsers and IDEs. You click on the line before your code (in
    the **Sources** panel in Chrome, but this may be different for different browsers),
    and a dot or arrow will appear. When your application is running, it will pause
    at this point to give you the opportunity to inspect the values of variables and
    walk through the code line by line from there.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 调试的一种更专业的方法是使用断点。这可以在大多数浏览器和集成开发环境中完成。你点击代码前的行（在Chrome的**源**面板中，但不同浏览器可能有所不同），就会出现一个点或箭头。当你的应用程序运行时，它会在这一点暂停，给你机会检查变量的值并从那里逐行检查代码。
- en: 'This way, you will get a good clue of what is going on and how to fix it. Here
    is how to use breakpoints in Chrome, and most other browsers have something like
    this. In Chrome, go to the **Sources** tab of the **Inspect** panel. Select the
    file you want to set a breakpoint in. Then you just click on the line number and
    it sets the breakpoint:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你将得到一个好的线索，了解发生了什么以及如何修复它。以下是使用Chrome中的断点的方法，大多数其他浏览器也有类似的功能。在Chrome中，转到**检查**面板的**源**选项卡。选择你想要设置断点的文件。然后你只需点击行号即可设置断点：
- en: '![Text'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '![文本'
- en: Description automatically generated](img/B16682_12_01.png)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_12_01.png)
- en: 'Figure 12.1: Breakpoints in the browser'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1：浏览器中的断点
- en: 'Then try to trigger the line of code, and when it gets triggered, it pauses.
    On the very right of the screen I can inspect all the variables and values:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后尝试触发代码行，当它被触发时，它会暂停。在屏幕的非常右侧，我可以检查所有变量和值：
- en: '![Graphical user interface, application'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![图形用户界面，应用程序'
- en: Description automatically generated](img/B16682_12_02.png)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 自动生成的描述](img/B16682_12_02.png)
- en: 'Figure 12.2: Inspecting breakpoint variables'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2：检查断点变量
- en: 'You can now go through your code with a fine-toothed comb: with the play icon
    on top, you can resume script execution (until it hits the next breakpoint or
    runs in to the same breakpoint again). With the round arrow icon at the top, I
    can go to the next line and inspect the values on the next line again.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以用细齿梳子一样的方式检查你的代码：使用顶部的播放图标，你可以恢复脚本执行（直到遇到下一个断点或再次遇到相同的断点）。使用顶部的圆形箭头图标，我可以跳到下一行并再次检查下一行的值。
- en: 'There are many options with breakpoints that we don''t have space to cover
    here. For more detail on how you can debug your code with breakpoints, look in
    your chosen code editor''s documentation or check the relevant Google Chrome documentation
    here: [https://developer.chrome.com/docs/devtools/javascript/breakpoints/](https://developer.chrome.com/docs/devtools/javascript/breakpoints/).'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 断点有很多选项，我们在这里没有空间全部涵盖。关于如何使用断点调试代码的更多细节，请查看你选择的代码编辑器的文档，或者查看这里的相关Google Chrome文档：[https://developer.chrome.com/docs/devtools/javascript/breakpoints/](https://developer.chrome.com/docs/devtools/javascript/breakpoints/)。
- en: Practice exercise 12.4
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 12.4
- en: Variable values can be tracked in the editor while debugging. The following
    exercise will demonstrate how to use the editor's breakpoints to check a value
    of a variable at a certain point in the running of the script. This is a simple
    example, but the same process can be used to find out information about larger
    scripts at specific points during execution, or establish where a problem may
    lie.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试过程中，可以在编辑器中跟踪变量值。以下练习将演示如何使用编辑器的断点来检查脚本运行过程中某个点的变量值。这是一个简单的例子，但可以使用相同的过程在执行过程中特定点查找有关较大脚本的信息，或确定问题可能存在的地方。
- en: There are minor differences and nuances in the way breakpoints operate in different
    editors, so please refer to the documentation of your environment for more of
    a detailed walk-through—this is intended to give you an idea of what breakpoints
    offer when it comes to debugging.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 不同编辑器中断点的操作方式存在细微差别和细微差别，因此请参阅您环境的文档以获取更详细的说明——这旨在让您了解断点在调试时能提供什么。
- en: 'You can use the following short script as an example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下简短脚本作为示例：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Remember to add `<script>` tags and open the script as an HTML document if you're
    testing this in your browser console.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在浏览器控制台中测试此脚本，请记住添加`<script>`标签并将脚本作为HTML文档打开。
- en: 'This exercise has been tested in a desktop editor but it is equally relevant
    to browser consoles and other environments. Take the following steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习已在桌面编辑器中测试过，但它同样适用于浏览器控制台和其他环境。请按照以下步骤操作：
- en: Open your script in your chosen editor, or the **Sources** tab of your browser's
    **Inspect** panel. Click to the left of the line of code where you want to add
    a breakpoint. A dot or other indicator will appear to indicate the breakpoint
    is set:![A screenshot of a computer
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的编辑器中打开您的脚本，或打开浏览器**Inspect**面板的**Sources**标签页。点击您想要添加断点的代码行左侧。将出现一个点或其他指示器，以表示已设置断点：![计算机屏幕截图
- en: Description automatically generated with low confidence](img/B16682_12_03.png)
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成低置信度的描述](img/B16682_12_03.png)
- en: 'Figure 12.3: Setting breakpoints'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.3：设置断点
- en: 'Run the code with your new breakpoints: I have selected **Run** | **Start Debugging**,
    but this will vary depending on your editor. You can simply reload the web page
    if you''re using the browser console to rerun the code with your new breakpoints
    accounted for:![Graphical user interface, text, application'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的新断点运行代码：我已经选择了**运行** | **开始调试**，但具体操作可能因您的编辑器而异。如果您正在使用浏览器控制台，可以通过简单地重新加载网页来重新运行代码，并考虑您的新断点：![图形用户界面，文本，应用程序
- en: Description automatically generated](img/B16682_12_04.png)
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成描述](img/B16682_12_04.png)
- en: 'Figure 12.4: Running code with breakpoints added'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.4：添加断点后运行代码
- en: You should now see the debugging console. There will be a tab that lists the
    variables in the code and the current values at the first breakpoint. It's called
    **VARIABLES** in my editor, but it's the **Scope** tab in the Chrome browser console.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在应该能看到调试控制台。将有一个标签页列出代码中的变量和第一个断点处的当前值。在我的编辑器中，它被称为**VARIABLES**，但在Chrome浏览器控制台中，它是**Scope**标签页。
- en: You can use the menu options to move to the next breakpoint, stop debugging,
    or restart the breakpoint sequence. Press the play icon to move to the next breakpoint.
    It will update to have a value of 5, as specified by line 1, and pause at the
    first breakpoint. Note that the highlighted line has not been run yet:![A screenshot
    of a computer
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用菜单选项来移动到下一个断点、停止调试或重新启动断点序列。按播放图标移动到下一个断点。它将更新为5的值，如第1行指定，并在第一个断点处暂停。请注意，突出显示的行尚未运行：![计算机屏幕截图
- en: Description automatically generated with medium confidence](img/B16682_12_05.png)
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成中等置信度的描述](img/B16682_12_05.png)
- en: 'Figure 12.5: Viewing variables in the console'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.5：在控制台中查看变量
- en: Press the play icon once more, and the script will run until it hits the next
    breakpoint, at which point the value of the variable will update as a result of
    the code on line 2:![Text
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按播放图标，脚本将运行，直到遇到下一个断点，此时变量的值将因第2行的代码而更新：![文本
- en: Description automatically generated](img/B16682_12_06.png)
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成描述](img/B16682_12_06.png)
- en: 'Figure 12.6: Progressing through breakpoints in a script'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.6：在脚本中通过断点前进
- en: Press play again to move to the next breakpoint, which increases the value of
    `val` once more:![Text
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按播放图标以移动到下一个断点，这将使`val`的值再次增加：![文本
- en: Description automatically generated](img/B16682_12_07.png)
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成描述](img/B16682_12_07.png)
- en: 'Figure 12.7: The final breakpoint'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.7：最后的断点
- en: Once the last breakpoint is reached you will only see options to restart or
    stop the debugger. If you press stop, it will end the debugging process:![Text
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦达到最后一个断点，你将只会看到重新启动或停止调试器的选项。如果你按停止，它将结束调试过程：![Text
- en: Description automatically generated](img/B16682_12_08.png)
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[自动生成的描述](img/B16682_12_08.png)'
- en: 'Figure 12.8: Breakpoints in the browser'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：浏览器中的断点
- en: The final value of `val` after the third breakpoint was revealed as `135`. Write
    down the values of `val` after the first and second calls to the `adder()` function,
    which were revealed to you by using breakpoints.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三次断点之后，`val` 的最终值被揭示为 `135`。写下 `adder()` 函数第一次和第二次调用后的 `val` 值，这些值是通过使用断点揭示给你的。
- en: This was a basic exercise, but we invite you to test out using breakpoints on
    some larger scripts and get more comfortable in your understanding of how your
    code works during runtime.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的练习，但我们邀请你测试使用断点在一些更大的脚本上，并更熟悉你在运行时如何理解你的代码。
- en: Error handling
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: We have seen a lot of errors appear already. Until now, we let the program crash
    when it encountered an error. There are other ways to deal with errors. When we
    are dealing with code that depends on some sort of outside input, such as an API,
    user input, or a file we will need to deal with the errors that this input can
    cause.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到很多错误已经出现了。到目前为止，当程序遇到错误时，我们让它崩溃。处理错误还有其他方法。当我们处理依赖于某种外部输入的代码时，例如API、用户输入或我们需要读取的文件，我们必须处理这些输入可能引起的错误。
- en: If we expect a certain piece of code to throw an error, we can surround this
    code with a `catch` block. The error it might throw will be caught in this block.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们期望某段代码抛出错误，我们可以用 `catch` 块包围这段代码。它可能抛出的错误将在这个块中被捕获。
- en: You have to be careful not to use this too much, and you usually don't want
    to do this when you can just write better code to avoid the error in the first
    place.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须小心不要过度使用它，通常当你能够写出更好的代码来避免最初就出现错误时，你通常不想这样做。
- en: 'Here is an example of a piece of code that throws an error, and is surrounded
    with a `try` and `catch` block. Let''s assume the `somethingVeryDangerous()` function
    might throw errors:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个抛出错误并围绕 `try` 和 `catch` 块的代码示例。假设 `somethingVeryDangerous()` 函数可能会抛出错误：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: If it throws an error, it will end up in the `catch` block. Since `Error` could
    mean many different errors, we are going to check for the exact error we are dealing
    with and write a specific handling of this error. We check the exact error class
    with the `instanceof` operator. After the error handling, the rest of the code
    will continue to execute normally.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它抛出错误，它将结束于 `catch` 块。由于 `Error` 可能意味着许多不同的错误，我们将检查我们正在处理的特定错误，并为此错误编写特定的处理程序。我们使用
    `instanceof` 运算符检查确切的错误类。错误处理之后，其余的代码将继续正常执行。
- en: 'You can do one more thing with a `try` `catch` block, and that is add a `finally`
    block. This `finally` block gets executed irrespective ofwhether errors are thrown.
    This is great for cleanup purposes. Here is a simple example:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `try` `catch` 块做一件事，那就是添加一个 `finally` 块。这个 `finally` 块会无条件执行，无论是否抛出错误。这对于清理工作非常有用。这里有一个简单的例子：
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We don't know the output of this code, since `trySomething()` is not defined.
    If it were to throw an error, it would log `Oh oh` to the console and then `Error
    or no error, I will be logged!`. If `trySomething()` didn't throw an error, it
    would only log the last part.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不知道这段代码的输出，因为 `trySomething()` 没有定义。如果它抛出错误，它会在控制台记录 `Oh oh`，然后记录 `Error or
    no error, I will be logged!`。如果 `trySomething()` 没有抛出错误，它只会记录最后一部分。
- en: 'Lastly, if, for whatever reason, you need to throw an error, you can do so
    with the `throw` keyword, like this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你出于任何原因需要抛出错误，你可以使用 `throw` 关键字，如下所示：
- en: '[PRE65]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This can be of great use whenever you need to deal with things out of your control,
    such as an API response, user input, or input from reading a file. If unexpected
    things happen, sometimes you'll have to throw an error to deal with it appropriately.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这在需要处理超出你控制范围的事物时非常有用，例如API响应、用户输入或从文件读取的输入。如果发生意外情况，有时你必须抛出一个错误来适当地处理它。
- en: Practice exercise 12.5
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习12.5
- en: Using `throw`, `try`, and `catch`, check if the value is a number, and if it's
    not, then create a custom error.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `throw`、`try` 和 `catch`，检查值是否为数字，如果不是，则创建一个自定义错误。
- en: Create a function with one argument called `val`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `val` 的带有一个参数的函数。
- en: Use `try`, and within it add a condition that checks whether `val` is a number
    using `isNaN`. If true, then throw an error that states that it is not a number.
    Otherwise, output `Got a number` to the console.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`try`，并在其中添加一个条件来检查`val`是否为数字，使用`isNaN`。如果是真的，那么抛出一个错误，说明它不是一个数字。否则，在控制台中输出`Got
    a number`。
- en: Use `catch` to catch any errors and output the error values to the console.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`catch`捕获任何错误并将错误值输出到控制台。
- en: Add `finally` to run and output the value, and when the function has completed,
    also include the value of `val`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数执行并输出值后添加`finally`，当函数完成时，也包括`val`的值。
- en: Create one request to the function with a string argument and another with a
    number. See the results in the console.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向函数发送一个字符串参数和一个数字参数的请求。在控制台中查看结果。
- en: Using cookies
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用cookies
- en: '**Cookies** are small data files that are stored on your own computer and used
    by websites. Cookies were invented to store things about the user of the website.
    Cookies are strings with a special pattern. They contain key-value pairs, and
    these key-value pairs are separated by semi-colons.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cookies**是存储在您的计算机上并由网站使用的小型数据文件。Cookies是为了存储有关网站用户的信息而发明的。Cookies是具有特殊模式的字符串。它们包含键值对，这些键值对由分号分隔。'
- en: 'You can create a cookie and use it again later. Here is how you can create
    a cookie:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个cookie并在以后再次使用它。以下是创建cookie的方法：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This does not work in all browsers when you run it on the client side (such
    as in your `<script>` tag). In Chrome, for example, you cannot set the cookies
    from the client side. You have to run the code from a server. (I have used Safari
    instead to do this here, but there are no guarantees about future support.) An
    alternative is the web storage API.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在客户端运行它时（例如在您的`<script>`标签中），这并不在所有浏览器中都有效。例如，在Chrome中，您无法从客户端设置cookie。您必须从服务器运行代码。（我在这里使用了Safari，但无法保证未来的支持。）另一种选择是web存储API。
- en: 'It is also possible to start Chrome from the command line with certain settings
    enabled, or to enable the cookies in the settings under privacy preferences. Careful
    to turn this off afterward if you don''t want it, though. This is how you can
    read from the cookie:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过启用某些设置从命令行启动Chrome，或者在隐私首选项下的设置中启用cookie。不过，如果您不想这样做，请小心将其关闭。这是从cookie中读取的方法：
- en: '[PRE67]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This example gets all the cookies using `decodeURIComponent()`, and then splits
    them on the `;`. This leaves us with an array, `cookieList`, with key-value pairs
    as strings. Next, we loop over all the key-value pairs. Trim them (remove the
    whitespace in front and at the back), and see whether they start with `name`.
    This was the name of our cookie key.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用`decodeURIComponent()`获取所有cookie，然后使用`;`分割它们。这给我们留下了一个包含键值对的字符串的数组`cookieList`。接下来，我们遍历所有的键值对。修剪它们（移除前后空白），并查看它们是否以`name`开头。这就是我们的cookie键的名称。
- en: 'If we want to get the value, we have to start reading after the key, so at
    least the length of the key, which is 4 (name) in this case. This brings us to
    index 3 already. We also want to skip the equal sign on index 4, so we start at
    index 5\. In this case, we are adding an alert to the name. Here is an example
    of a simple website that uses a cookie to greet the user:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要获取值，我们必须从键之后开始读取，所以至少是键的长度，在这个例子中是4（name）。这已经把我们带到了索引3。我们还想跳过索引4上的等号，所以我们从索引5开始。在这种情况下，我们正在添加一个关于名称的警告。以下是一个使用cookie问候用户的简单网站示例：
- en: '[PRE68]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: If you are writing a new website, you probably should not be using this. However,
    whenever you need to work with older code, chances are you'll come across this.
    And now you know what it means and how to adjust it. Good for you!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写一个新的网站，您可能不应该使用这种方法。然而，无论何时您需要处理旧代码，您很可能会遇到这种情况。现在您知道了它的含义以及如何调整它。这对您来说是个好消息！
- en: Practice exercise 12.6
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.6
- en: 'Let''s make a cookie builder. Create several functions that will allow you
    to interact with page cookies, including reading a cookie value by name, creating
    a new cookie using a name and setting it for a set number of days, and deleting
    a cookie. You can use the following HTML template to get you started:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个cookie构建器。创建几个函数，允许您与页面cookie交互，包括通过名称读取cookie值、使用名称创建新cookie并为其设置一定数量的天数，以及删除cookie。您可以使用以下HTML模板开始：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Take the following steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Set up your webpage, and in the JavaScript code, output the value of `document.cookie`.
    It should be blank.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置您的网页，并在JavaScript代码中输出`document.cookie`的值。它应该是空的。
- en: Create a function that will take the parameters for `cookieName`, `cookieValue`,
    and the number of days you want to set the cookie.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，该函数将接受`cookieName`、`cookieValue`以及你想要设置cookie的天数作为参数。
- en: Check if `days` is valid, and within the block of valid code, get the current
    date. Set a `setTime` value for the cookie to expire in milliseconds by multiplying
    the days into milliseconds.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`days`是否有效，并在有效代码块中获取当前日期。通过将天数乘以毫秒来为cookie设置一个`setTime`值，使其在毫秒数后过期。
- en: Change the date object of milliseconds until the cookie expires to a UTC string
    value.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将cookie过期时间的毫秒数对象转换为UTC字符串值。
- en: Set `document.cookie` to `cookieName = cookieValue`, plus add the expiry details
    and lastly specify `path=/`.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`document.cookie`设置为`cookieName = cookieValue`，然后添加过期详情，最后指定`path=/`。
- en: Create a function to create a test cookie with a value and expiry set after
    a number of days. Create a second cookie the same way, and when you refresh your
    page, you should see at least two cookies in the console.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数，在指定天数后创建一个带有值和过期的测试cookie。以相同的方式创建第二个cookie，当你刷新你的页面时，你应该在控制台看到至少两个cookie。
- en: Create a second function to read a cookie value, set the value as `false`, and
    then create an array of the cookies split by semi-colons.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个函数来读取cookie值，将值设置为`false`，然后创建一个由分号分割的cookie数组。
- en: Loop through all the cookies and split again where the equal signs are. This
    will give you the first item with index 0 as the name of the cookie. Add a condition
    to check if the name is equal to the name that was requested in the function parameters.
    If it matches, assign the value of the second item in the index, which will be
    the value of the cookie with the selected name. Return `cookievalue` in the function.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有cookie，并在等号处再次分割。这将给出索引为0的第一个项，作为cookie的名称。添加一个条件来检查名称是否等于函数参数中请求的名称。如果匹配，则分配索引中第二个项的值，这将是要删除的选定名称的cookie的值。在函数中返回`cookievalue`。
- en: Add two console log messages using the function to read both cookies you have
    set earlier. Output the values of the cookies in the console.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数添加两个控制台日志消息，以读取你之前设置的cookie。在控制台输出cookie的值。
- en: To delete a cookie, you need to set a date prior to the current date. You can
    create a cookie with a `-1` date and send the cookie with its selected name to
    be deleted by invoking the cookie creation function.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要删除cookie，你需要设置一个早于当前日期的日期。你可以创建一个带有`-1`日期的cookie，并通过调用cookie创建函数发送带有其选定名称的cookie以进行删除。
- en: Try deleting a cookie by name.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试通过名称删除cookie。
- en: Local storage
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地存储
- en: 'We have looked at cookies as a way to save user data, but there is actually
    a more modern way to do this: **local storage**. Local storage is an amazing fun
    topic that will add to your ability to make smart websites. With local storage,
    we can save key-value pairs in our web browser and use them again in a new session
    (when the browser is opened again later). The information is typically stored
    in a folder on the computer of the user, but this differs a bit by browser.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将cookie视为保存用户数据的一种方式，但实际上有一种更现代的方法来做这件事：**本地存储**。本地存储是一个令人兴奋的话题，它将增强你制作智能网站的能力。使用本地存储，我们可以在我们的网络浏览器中保存键值对，并在新会话中再次使用它们（当浏览器稍后再次打开时）。信息通常存储在用户的计算机上的一个文件夹中，但这一点因浏览器而异。
- en: This allows the website to store some information and retrieve it later, even
    after refreshing the page or closing the browser. The advantage of local storage
    over cookies is that they don't need to be passed around with every HTTP request,
    which is the case with cookies. Local storage just lives there and waits to be
    accessed.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得网站能够存储一些信息并在稍后检索它，即使是在刷新页面或关闭浏览器之后。与cookie相比，本地存储的优势在于它们不需要在每次HTTP请求中传递，这是cookie的情况。本地存储只是在那里等待被访问。
- en: 'The `localStorage` object is a property of the `window` object that we have
    seen before. There are a few methods on the `localStorage` object that we need
    to know to use it effectively. First of all, we need to be able to get and set
    key-value pairs on local storage. We use `setItem()` whenever we want to save
    something and `getItem()` whenever we want to retrieve the value later. Here is
    how to do it:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`localStorage`对象是我们之前见过的`window`对象的一个属性。我们需要了解`localStorage`对象上的一些方法才能有效地使用它。首先，我们需要能够在本地存储上获取和设置键值对。每次我们想要保存某物时，我们使用`setItem()`，每次我们想要稍后检索值时，我们使用`getItem()`。以下是这样做的方法：'
- en: '[PRE70]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: If you go back to your code and turn off the `setItem()` line before loading
    the page a second time, it still will output that value, since the information
    was stored when running the script the first time and never got deleted. Local
    storage doesn't expire, though it can be manually deleted.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回到代码中，在第二次加载页面之前关闭`setItem()`行，它仍然会输出该值，因为信息是在第一次运行脚本时存储的，并且从未被删除。尽管如此，本地存储不会过期，但可以手动删除。
- en: 'We can also retrieve a key using the index. This is useful whenever we need
    to loop through the key-value pairs and we don''t know the names of the keys.
    This is how to retrieve a key by index:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用索引来检索一个键。这在我们需要遍历键值对，但不知道键的名称时非常有用。以下是按索引检索键的方法：
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In this case, the key is `name`. In order to get the associated value, we can
    do this:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，键是`name`。为了获取关联的值，我们可以这样做：
- en: '[PRE73]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We can also remove key-value pairs like this:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样删除键值对：
- en: '[PRE74]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'And we can remove all the key-value pairs from the local storage in one call:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一次调用中从本地存储中删除所有键值对：
- en: '[PRE75]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: So, with local storage you can save values even after closing the browser. This
    allows for a lot of "smart" behavior, since your app is now able to remember things,
    such as what you've entered in a form, which settings you've toggled on a website,
    and what you've looked at previously.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用本地存储，你可以在关闭浏览器后保存值。这允许许多“智能”行为，因为现在你的应用能够记住事情，比如你在表单中输入的内容，你在网站上切换的设置，以及你之前查看的内容。
- en: Please don't see this as an alternative that you can use to bypass the problems
    with cookies and privacy. Local storage raises the exact same issues as cookies,
    it's just less known. You will still have to mention on your website that you
    are tracking users and storing information, just like you need to do for cookies.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 请不要将此视为一个可以用来绕过cookies和隐私问题的替代方案。本地存储与cookies引发的问题完全相同，只是知名度较低。你仍然需要在网站上提及你正在跟踪用户并存储信息，就像你需要为cookies做的那样。
- en: Practice exercise 12.7
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.7
- en: 'Let''s create a local storage shopping list that will store values in the browser''s
    local storage. This is an example of using JavaScript to convert from strings
    to useable JavaScript objects and back to strings that can be stored in local
    storage. You can use the following template:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个本地存储购物清单，它将在浏览器本地存储中存储值。这是一个使用JavaScript将字符串转换为可使用JavaScript对象，然后再将其转换回可以存储在本地存储中的字符串的示例。你可以使用以下模板：
- en: '[PRE76]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Take the following steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 采取以下步骤：
- en: In the JavaScript code, select all the page elements as JavaScript objects.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript代码中，选择所有页面元素作为JavaScript对象。
- en: Create a `tasks` array with a value of the local `tasklist` storage if it exists,
    otherwise set the `tasks` array to an empty array. Using `JSON.parse`, you can
    convert the string value to a useable object in JavaScript.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在本地`tasklist`存储，则创建一个`tasks`数组，其值为本地存储，否则将`tasks`数组设置为空数组。使用`JSON.parse`，你可以将字符串值转换为JavaScript中的可使用对象。
- en: Loop through all the items in the `tasklist` array; they will be stored as objects,
    with a name and a Boolean value for their checked status. Create a separate function
    to build the task item, adding it to the page from the list.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`tasklist`数组中的所有项；它们将被存储为对象，具有名称和布尔值表示其选中状态。创建一个单独的函数来构建任务项，并将其添加到页面列表中。
- en: In the task generation function, create a new list item and a `textNode`. Append
    `textNode` to the list item. Append the list item to the page output area. If
    the task is marked complete with a Boolean value of `true`, then add the `style`
    class of `ready`.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任务生成函数中，创建一个新的列表项和一个`textNode`。将`textNode`附加到列表项上。将列表项附加到页面输出区域。如果任务被标记为完成，布尔值为`true`，则添加`style`类的`ready`。
- en: Add an event listener to the list item that will toggle the `ready` class when
    clicked. Every time there is a change to any list item, you will also need to
    store that to the local storage. Create a task builder function that will store
    and ensure the visual list is the same as the local storage list. You will need
    to clear the current task list array and rebuild from the visual data, so create
    a function to handle the list building.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为列表项添加一个事件监听器，当点击时切换`ready`类。每次任何列表项发生变化时，你也需要将其存储到本地存储中。创建一个任务构建函数，该函数将存储并确保可视列表与本地存储列表相同。你需要清除当前任务列表数组，并从可视数据中重建，因此需要创建一个处理列表构建的函数。
- en: The task builder function will clear the current `tasks` array, and select all
    the `li` elements on the page. Loop through all the list items, getting the text
    value from the element, and checking if it contains the class of `ready`. If it
    contains the `ready` class, then mark the checked condition as true. Add the results
    to the `tasks` array, and this will rebuild the array to ensure it matches with
    what the user sees visually. Send to a save tasks function to save the `tasks`
    array in local storage, so if the page is refreshed, you will see the same list.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务构建函数将清除当前的`tasks`数组，并选择页面上的所有`li`元素。遍历所有列表项，从元素中获取文本值，并检查它是否包含`ready`类。如果包含`ready`类，则将勾选条件标记为true。将结果添加到`tasks`数组中，这将重建数组以确保它与用户视觉上看到的一致。将数据发送到保存任务函数以将`tasks`数组保存在本地存储中，这样如果页面被刷新，你将看到相同的列表。
- en: In the save tasks function, set the `localstorage` item to the tasks array.
    You will need to stringify the object so that it can go into the string parameter
    of local storage.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存任务函数中，将`localstorage`项设置为任务数组。你需要将对象序列化，以便它可以放入本地存储的字符串参数中。
- en: Now, when you refresh the page, you will see the list of tasks. They can be
    crossed out by clicking them and new items can be added in the input field by
    pressing the button to submit new items.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当你刷新页面时，你会看到任务列表。你可以通过点击它们来勾选任务，也可以通过按下提交新项的按钮在输入字段中添加新项。
- en: JSON
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON
- en: '**JSON** stands for **JavaScript Object Notation**, which is nothing more than
    a data format. We saw this notation when we were creating our objects in JavaScript;
    however, JSON doesn''t mean JavaScript objects, it''s just a way of representing
    data using a similar format as JavaScript objects. It can also be easily converted
    to a JavaScript object.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表**JavaScript对象表示法**，这仅仅是一种数据格式。我们在创建JavaScript对象时看到了这种表示法；然而，JSON并不意味着JavaScript对象，它只是使用与JavaScript对象类似格式的数据表示方法。它也可以轻松地转换为JavaScript对象。'
- en: 'JSON is a standard used to communicate with APIs, including APIs that aren''t
    written in JavaScript! APIs can accept data, for example, the data from a form
    on a website, in JSON format. And nowadays, APIs almost always send data back
    in JSON. Sending data from an API happens, for example, when you enter a web shop—the
    products typically come from a call to an API that is connected to a database.
    This data gets converted to JSON and is sent back to the website. Here is an example
    of JSON:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种用于与API通信的标准，包括不是用JavaScript编写的API！API可以接受数据，例如，来自网站表单的数据，以JSON格式。如今，API几乎总是以JSON格式发送数据。例如，当你进入网上商店时，产品通常来自连接到数据库的API调用。这些数据被转换为JSON并返回到网站。以下是一个JSON的示例：
- en: '[PRE77]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is an object that seems to describe a person. It has key-value pairs. The
    keys always have to be between quotes, but the values only have to be between
    quotes when they are strings. So, the first key is `name` and the first value
    is `Malika`.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个似乎描述一个人的对象。它包含键值对。键总是必须用引号括起来，但值只有在它们是字符串时才必须用引号括起来。因此，第一个键是`name`，第一个值是`Malika`。
- en: Lists of values (or JavaScript arrays) are indicated with `[]`. The JSON object
    contains a list of `languages`, which has the square brackets, and another object,
    `address`. You can tell this by the curly brackets.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 值列表（或JavaScript数组）用`[]`表示。JSON对象包含一个`languages`列表，它有方括号，还有一个对象`address`。你可以通过大括号来判断这一点。
- en: 'There are actually only a few flavours in JSON:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，JSON中只有几种类型：
- en: 'Key-value pairs with values of the following types: string, number, Boolean,
    and null'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值为以下类型的键值对：字符串、数字、布尔值和null
- en: Key-value pairs with lists, which have `[` and `]` that contain the items in
    the list
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含`[`和`]`的列表键值对，这些列表包含列表中的项
- en: Key-value pairs with other objects, which have `{` and `}` that contain other
    JSON elements
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含其他JSON元素的`{`和`}`之间的键值对，这些元素是其他对象
- en: These three options can be combined, so an object can contain other objects
    and a list can contain other lists. We saw this already in the above example.
    Our object contained a nested address object.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个选项可以组合使用，因此一个对象可以包含其他对象，一个列表可以包含其他列表。我们已经在上面的例子中看到了这一点。我们的对象包含一个嵌套的地址对象。
- en: But this can be nested even further. A list can also contain objects, which
    can contain lists with objects, with lists, and so on. This might sound a bit
    complicated and that's exactly the point. Even though it is very simple, nesting
    all these options can still complicate JSON a bit. There is a reason we've placed
    it in our advanced topic chapter.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 但这可以进一步嵌套。列表也可以包含对象，这些对象可以包含带有对象的列表、列表，以此类推。这听起来可能有点复杂，这正是重点。尽管它非常简单，但所有这些选项的嵌套仍然会使
    JSON 稍微复杂一些。这就是为什么我们将它放在高级主题章节中的原因。
- en: 'Let''s now have a look at a slightly more complex example:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看一个稍微复杂一点的例子：
- en: '[PRE78]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This is a list of companies, with two company objects on it. The companies
    have two key-value pairs: a name and an address list. Each of the address lists
    contains two addresses, and each address consists of three key-value pairs: `street`,
    `zipcode` and `city`.'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个公司列表，上面有两个公司对象。公司有两个键值对：名称和地址列表。每个地址列表包含两个地址，每个地址由三个键值对组成：`street`、`zipcode`
    和 `city`。
- en: Practice exercise 12.8
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.8
- en: 'This exercise will demonstrate how you can create a valid JSON object that
    can be used as a JavaScript object. You will create a simple list of names and
    statuses that can be looped through and output the results to the console. You
    will load JSON data to JavaScript and output the results of the object''s contents:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示如何创建一个有效的 JSON 对象，该对象可以用作 JavaScript 对象。您将创建一个简单的包含名称和状态的列表，可以遍历并将结果输出到控制台。您将加载
    JSON 数据到 JavaScript 并输出对象的详细内容：
- en: Create a JavaScript object that contains JSON formatted data. The object should
    contain at least two items and each item should be an object with at least two
    paired values.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含 JSON 格式数据的 JavaScript 对象。该对象应包含至少两个项目，并且每个项目应是一个包含至少两个配对值的对象。
- en: Create a function that can be invoked that will loop through each item in the
    JavaScript JSON object and output the result to the console. Output each item
    of data to the console using `console.log`.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可以调用的函数，该函数将遍历 JavaScript JSON 对象中的每个项目，并将结果输出到控制台。使用 `console.log` 将数据项输出到控制台。
- en: Invoke the function and launch the JavaScript code.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用函数并启动 JavaScript 代码。
- en: Parsing JSON
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析 JSON
- en: 'There are many libraries and tools available for parsing a JSON string into
    an object. A JavaScript string can be converted to a JSON object using the `JSON.parse()`
    function. Data that is received from another place is always of value `string`,
    so in order to treat it as an object, it needs to be converted. This is how to
    do it:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多库和工具可以将 JSON 字符串解析为对象。可以使用 `JSON.parse()` 函数将 JavaScript 字符串转换为 JSON 对象。从其他地方接收的数据始终是
    `string` 类型的值，因此为了将其视为对象，需要将其转换。以下是这样做的方法：
- en: '[PRE79]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: After parsing, it can be treated as an object. Therefore it will log `Maaike
    is 30` to the console.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 解析后，它可以被视为一个对象。因此，它将在控制台输出 `Maaike is 30`。
- en: 'The other way around is also necessary sometimes. Objects can be converted
    to a JSON string using the `JSON.stringify()` method. It converts the object or
    value from JavaScript to a JSON string. You can see it in action here:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 有时也需要反过来操作。可以使用 `JSON.stringify()` 方法将对象转换为 JSON 字符串。它将 JavaScript 对象或值转换为 JSON
    字符串。您可以在以下操作中看到它的作用：
- en: '[PRE80]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The type of `strdog` becomes a string because it is being stringified. And
    it no longer has the properties `name` and `breed`. These will be undefined. This
    code snippet will log the following to the console:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`strdog` 的类型变为字符串，因为它正在被字符串化。它不再具有 `name` 和 `breed` 属性。这些将变为未定义。此代码片段将在控制台输出以下内容：'
- en: '[PRE81]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This can be useful for storing JSON data directly in a database, for example.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于将 JSON 数据直接存储在数据库中非常有用，例如。
- en: Practice exercise 12.9
  id: totrans-364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 12.9
- en: 'This exercise will demonstrate the use of JSON methods to parse JSON and convert
    string values to JSON. Using JSON methods with JavaScript, convert a JSON formatted
    string value to a JavaScript object and convert a JavaScript object into a string
    representation of the JSON object:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将演示使用 JSON 方法解析 JSON 并将字符串值转换为 JSON。使用 JavaScript 中的 JSON 方法，将 JSON 格式的字符串值转换为
    JavaScript 对象，并将 JavaScript 对象转换为 JSON 对象的字符串表示：
- en: Create a JSON object with several items and objects. You can use the JSON object
    from the previous lesson.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含多个项目和对象的 JSON 对象。您可以使用上一课中的 JSON 对象。
- en: Using the JSON `stringify()` method, convert the JSON JavaScript object into
    a string version and assign it to a variable named `newStr [{"name":"Learn JavaScript","status":true},{"name":"Try
    JSON","status":false}]`.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JSON 的 `stringify()` 方法，将 JSON JavaScript 对象转换为字符串版本，并将其分配给名为 `newStr` 的变量：`[{"name":"Learn
    JavaScript","status":true},{"name":"Try JSON","status":false}]`。
- en: Using `JSON.parse()`, convert the `newStr` value back into an object and assign
    it to a variable named `newObj`.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `JSON.parse()`，将 `newStr` 值转换回对象，并将其分配给名为 `newObj` 的变量。
- en: Iterate through the items in the `newObj` and output the results to the console.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历 `newObj` 中的项目，并将结果输出到控制台。
- en: Practice exercise 12.9 answers
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习 12.9 答案
- en: '[PRE82]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Chapter projects
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Email extractor
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邮件提取器
- en: 'Use the following HTML as a starter template and add the JavaScript code to
    make an email extractor function:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 HTML 作为起始模板，并添加 JavaScript 代码以创建电子邮件提取器函数：
- en: '[PRE83]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Take the following steps:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: In JavaScript, select both text areas and the button and set them as JavaScript
    objects.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JavaScript 中选择两个文本区域和按钮，并将它们设置为 JavaScript 对象。
- en: Add an event listener to the button that will invoke a function that gets the
    content of the first `textarea` and filters it to only accept email addresses.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加一个事件监听器，该监听器将调用一个函数，该函数获取第一个 `textarea` 的内容，并过滤出仅接受电子邮件地址。
- en: Within the extracting function, get the content of the first input field. Using
    `match()`, return an array of the email addresses that were matched from within
    the content from the first `textarea`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提取函数中，获取第一个输入字段的内容。使用 `match()`，从第一个 `textarea` 的内容中返回匹配的电子邮件地址数组。
- en: To remove any duplicates, create a separate array that will hold only unique
    values.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了去除任何重复项，创建一个单独的数组，该数组将只包含唯一值。
- en: Loop through all the email addresses found and check whether each one is already
    in the `holder` array, and if not, add it.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有找到的电子邮件地址，并检查每个地址是否已经在 `holder` 数组中，如果没有，则添加它。
- en: Using the `join()` array method, you can now join together the results of the
    email addresses found within the content and output it into the second `textarea`.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `join()` 数组方法，现在可以将找到的电子邮件地址的结果合并在一起，并将其输出到第二个 `textarea`。
- en: Form validator
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单验证器
- en: 'This project is an example of a typical form structure where you check the
    values inputted into the form and validate them before the content gets submitted.
    A response is returned to the user if the values do not meet the validation criteria
    in the code. Use the following HTML and CSS as a starting template:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目是一个典型的表单结构示例，其中您检查表单中输入的值，并在内容提交之前进行验证。如果值不符合代码中的验证标准，则向用户返回响应。使用以下 HTML
    和 CSS 作为起始模板：
- en: '[PRE84]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Take the following steps:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Using JavaScript, select all the page elements and set them as JavaScript objects
    so they are easier to select within the code. Also select all the page elements
    that have the `error` class as an object.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JavaScript 选择所有页面元素，并将它们设置为 JavaScript 对象，以便在代码中更容易选择。同时选择所有具有 `error` 类的页面元素作为对象。
- en: Add an event listener to submit and capture the click, preventing the default
    form action.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为提交添加事件监听器并捕获点击，防止默认表单操作。
- en: Loop through all the page elements that have a class `error` and add the `hide`
    class, which will remove them from view since this is a new submission.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有具有类 `error` 的页面元素，并添加 `hide` 类，这将使它们从视图中消失，因为这是一个新的提交。
- en: Using the regular expression for valid emails, test the results against the
    input value of the email field.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用有效的电子邮件的正则表达式，将结果与电子邮件字段的输入值进行测试。
- en: Create a function to respond to errors, which removes the `hide` class from
    the element next to the element that triggered the event. Apply focus to that
    element within the function.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个函数来响应错误，该函数将从触发事件的元素旁边的元素中移除 `hide` 类。在函数内将该元素设置为焦点。
- en: If there is an error that an input does not match the desired regex, pass the
    parameters to the error handling function you just created.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有错误，即输入不匹配所需的正则表达式，将参数传递给您刚刚创建的错误处理函数。
- en: Check the password field input value to ensure only letters and numbers are
    used. Also check the length to ensure that it is 3-8 characters. If either are
    false, then add the error with the error function and create a message for the
    user. Set the error Boolean to `true`.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查密码字段输入值，确保只使用字母和数字。还要检查长度，确保它是 3-8 个字符。如果任一条件不满足，则使用错误函数添加错误，并为用户创建一条消息。将错误布尔值设置为
    `true`。
- en: Add in an object to track the form data creation and add values to the object
    by looping through all the inputs, setting the property name to be the same as
    the input name, and the value the same as the input value.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个对象来跟踪表单数据创建，并通过遍历所有输入，将属性名称设置为与输入名称相同，将值设置为与输入值相同来向对象中添加值。
- en: Before the end of the validation function, check if an error is still present,
    and if it is not, submit the form object.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证函数结束之前，检查是否仍然存在错误，如果不存在，则提交表单对象。
- en: Simple math quiz
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单数学测验
- en: 'In this project, we will create a math quiz that will allow the user to respond
    to math questions. The application will check the responses and score the accuracy
    of the user''s answers to the questions. You can use the following HTML template:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将创建一个数学测验，允许用户回答数学问题。应用程序将检查用户的回答并评分用户对问题的回答准确性。你可以使用以下HTML模板：
- en: '[PRE85]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Take the following steps:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: In JavaScript, wrap the code within a function, `app`. Within the app function,
    create variable objects to contain all the page elements so they can be used in
    the script, and create a blank object called `game`.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JavaScript中，将代码包裹在一个名为`app`的函数中。在`app`函数内部，创建变量对象来包含所有页面元素，以便在脚本中使用，并创建一个名为`game`的空对象。
- en: Add a `DOMContentLoaded` event listener that invokes the app initialization
    once the page loads.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面加载完成后，添加一个`DOMContentLoaded`事件监听器，调用应用初始化。
- en: Within an `init()` function, add an event listener to the button, listen for
    a click, and track the event into a function called `checker`. Also within the
    `init` function, load another function called `loadQuestion()`.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init()`函数中，给按钮添加一个事件监听器，监听点击事件，并将事件跟踪到名为`checker`的函数中。同样在`init`函数中，加载另一个名为`loadQuestion()`的函数。
- en: Create a function to load the questions, and another function that can generate
    a random number from min and max values in the arguments.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于加载问题的函数，以及另一个可以生成从参数中的最小值和最大值之间的随机数的函数。
- en: In the `loadQuestion()` function, generate two random values and add them to
    the game object. Calculate the result of both values added together and assign
    that value within the game object as well.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`loadQuestion()`函数中，生成两个随机值并将它们添加到游戏对象中。计算这两个值相加的结果，并将该值分配到游戏对象中。
- en: Assign and update the `textContent` of the page elements that require the dynamic
    number values for the calculation question.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为需要动态数值计算问题的页面元素分配和更新`textContent`。
- en: When the button is clicked, use a ternary operator to determine whether the
    answer to the question was correct or incorrect. Set the color to `green` for
    correct, and to `red` for incorrect.
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当按钮被点击时，使用三元运算符确定问题的答案是否正确。对于正确答案，颜色设置为`green`，对于错误答案，颜色设置为`red`。
- en: Create a page element to output all the questions and keep track of the results.
    Within the `checker()` function, append a new element to the HTML with a style
    color to indicate a correct or incorrect response. Display the first and second
    values as well as the answer, and show the user's response within brackets.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个页面元素来输出所有问题并跟踪结果。在`checker()`函数中，向HTML中添加一个新的元素，并使用样式颜色来指示正确或错误的响应。显示第一个和第二个值以及答案，并在括号内显示用户的响应。
- en: Clear the input field and load the next question.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除输入字段并加载下一个问题。
- en: Self-check quiz
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: What will the following regex expression return from the following words?
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下正则表达式表达式将从以下单词中返回什么？
- en: '[PRE86]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Are cookies part of the document object?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cookie是文档对象的一部分吗？
- en: What will the following code do to a JavaScript cookie?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码将对JavaScript cookie做什么？
- en: '[PRE87]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: What is the output in the console from the following code?
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码在控制台中的输出是什么？
- en: '[PRE88]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: What is the output in the console from the following code?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码在控制台中的输出是什么？
- en: '[PRE89]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: What is the output of the following code?
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码的输出是什么？
- en: '[PRE90]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Summary
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had some important, more advanced topics that we still had
    to cover, but that you were probably not ready for earlier in the book. After
    this chapter, you should have deepened your understanding of JavaScript in several
    areas, first and foremost, regular expressions. With regex, we can specify patterns
    of strings and we can use these to search other strings for matches to our patterns.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有一些重要且更高级的主题，我们仍然需要覆盖，但你可能在前面的书中还没有准备好。在本章之后，你应该在几个方面加深了对JavaScript的理解，首先是正则表达式。使用正则表达式，我们可以指定字符串的模式，并可以使用这些模式来搜索其他字符串以匹配我们的模式。
- en: We also considered functions and the `arguments` object, with which we can access
    arguments by their index. We continued with a look at JavaScript hoisting and
    strict mode, which enables us to use JavaScript with a few more rules. Getting
    used to JavaScript in strict mode is generally a good practice and is great preparation
    for working with JavaScript frameworks.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考虑了函数和`arguments`对象，通过它们我们可以通过索引访问参数。我们继续探讨了JavaScript的提升和严格模式，这使我们能够在使用JavaScript时遵循更多规则。习惯在严格模式下使用JavaScript通常是一种良好的实践，并且是使用JavaScript框架工作的良好准备。
- en: 'Debugging and tweaking were also discussed: we can use breakpoints or log our
    output to the console to get an idea of what is going on. Handling errors well
    can prevent unnecessary crashes of our program. Finally, we looked at JavaScript
    cookie creation and the use of local storage, along with the use of JSON, a syntax
    for sending data around. We saw the different types of key-value pairs and how
    to parse JSON. We also saw how to store key-value pairs in the `localStorage`
    object of `window`.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和微调也被讨论了：我们可以使用断点或将输出记录到控制台来了解正在发生的事情。妥善处理错误可以防止程序不必要的崩溃。最后，我们探讨了JavaScript的cookie创建和本地存储的使用，以及JSON的使用，这是一种发送数据的语法。我们看到了不同类型的键值对以及如何解析JSON。我们还看到了如何将键值对存储在`window`对象的`localStorage`中。
- en: 'This chapter has deepened our understanding of JavaScript, and we learned some
    new things we need to know for modern JavaScript, but also a lot for when dealing
    with old (legacy) code. In the next chapter, we''ll dive into an even more advanced
    topic: concurrency. This topic is about multitasking with your JavaScript code.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 本章加深了我们对JavaScript的理解，我们学习了一些现代JavaScript所需了解的新知识，同时也为处理旧（遗留）代码提供了很多知识。在下一章中，我们将深入探讨一个更高级的主题：并发。这个主题是关于使用JavaScript代码进行多任务处理。
