- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Intermediate JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concepts and solution approaches presented up to this point in the book
    are not the only way to think about solving issues. In this chapter, we will challenge
    you to look a little deeper, be curious, and practice the good habit of optimizing
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In previous chapters, you were promised great things about this chapter because
    the optimal use of some built-in methods require knowledge of regular expressions,
    which we will cover in this chapter. There is a lot more fun to be had though—here
    is a list of topics that we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions and the arguments object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript hoisting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strict mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using cookies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, a selection of diverse topics, but all advanced and fun. The
    sections in this chapter are not as related to each other as you might have gotten
    used to by now. They are mostly individual topics that can help to really enhance
    your understanding and improve your JavaScript knowledge a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: exercise, project and self-check quiz answers can be found in the *Appendix*.'
  prefs: []
  type: TYPE_NORMAL
- en: Regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Regular expressions**, also known as **regex**, are simply ways to describe
    text patterns. You can consider them next-level strings. There are different regex
    implementations. This means that depending on the interpreter, regex might differ
    a bit in the way they''re written. However, they are somewhat standardized, so
    you write them (almost) the same for all versions of regex. We are going to use
    regex for JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Regex can be very useful in many situations, for example when you need to look
    for errors in a large file or retrieve the browser agent a user is using. They
    can also be used for form validation, as with regex you can specify valid patterns
    for field entries such as email addresses or phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regex is not only useful for finding strings, but can also be used for replacing
    strings. By now you might think, *so regex is amazing, but is there a catch?*
    And yes, unfortunately, there is a catch. At first, regex might kind of look like
    your neighbor''s cat walked over your keyboard and just typed some random characters
    by accident. This regex checks for a valid email, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Fear not, after this section, you will be able to decipher the secret patterns
    within the regex. We are not going to go through everything there is to say about
    regex, but we will establish a solid level of familiarity that will allow you
    to work with them and expand your knowledge as you go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off easy. The regex pattern is specified between two slashes.
    This is a valid regex expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The above expression will match if a given string contains the word `JavaScript`.
    When it matches, this means the result is positive. And this can be used to do
    many things.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the JavaScript built-in `match()` function for this. This function
    returns the regex match on the result (if there is one) in the form of the substring
    that matched the starting position of this string and the input string.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually other built-in functions that use regex, but we will see
    them later. `match()` is just a convenient function to demonstrate how regex works.
    You can see it in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This logs null because it is case-sensitive by default and therefore is not
    a match. If we had looked for `/ava/` or simply `/a/`, it would have matched because
    it contains `ava` and `a`. If you want it to be case-insensitive, you can specify
    this using an `i` after the slash. In this case-insensitive example, the expression
    will match the previous string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will actually log the result, because it is now case-insensitive, and
    from that point of view, our string does contain `javascript`. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The result is an object, containing the found match and the index it started
    on, as well as the input that was looked through. The groups are undefined. You
    can create groups with round parentheses, as you'll see when we get to the section
    on groups.
  prefs: []
  type: TYPE_NORMAL
- en: You can often find regex in JavaScript in combination with the built-in search
    and replace method on strings, which we'll cover next.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying multiple options for words
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to specify a certain range of options, we can use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the expression matches either `javascript`, `nodejs`, or `react`. At
    this point, we are only matching for the first encounter and then we quit. So
    this is not going to find two or more matches right now—it will output the same
    thing as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It logs this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to find all matches, we could specify the global modifier, `g`.
    It is very similar to what we did for case-insensitive searches. In this example,
    we are checking for all matches, and it is case-insensitive. All the modifiers
    are behind the last slash. You can use multiple modifiers at the same time as
    we do below, or you could decide to only use `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns both `React` and `JavaScript` as a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the result looks very different now. As soon as you specify
    `g`, the match function will just return an array of the matching words. This
    is not too exciting in this case, since these are the words we asked for. But
    it can be more of a surprise with a more complex pattern. This is exactly what
    we'll learn next.
  prefs: []
  type: TYPE_NORMAL
- en: Character options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, our expressions are quite readable, right? The character options are
    where things start to look, well, intense. Say we want to search for a string
    of only one character equal to `a`, `b`, or `c`. We would write it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return `null` because `d` is not `a`, `b`, or `c`. We can include
    `d` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is a range of characters, we can write it shorter, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And if we wanted any letter, lowercase or uppercase, we would write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We could actually also use the case-insensitive modifier to achieve the same
    thing, but this would apply to the regex pattern as a whole, and you might only
    need it to apply for the specific character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We would get a match on both of the preceding options. If we wanted to include
    numbers as well, we would write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we can just concatenate ranges to specify one character, much
    like we could concatenate possible options for that specific character, like `[abc]`.
    The example above specifies three possible ranges. It will match any lowercase
    or uppercase letter from a to z and all numeric characters as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn''t mean that it can only match a one-character string by the way;
    it will just match the first matching character in this case because we didn''t
    add the global modifier. However, these special characters won''t match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To address the difficulty of complex characters not matching an expression,
    the dot functions as a special wildcard character in regex that can match any
    character. So what do you think this does?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Since it has the global modifier, it is going to match any character. This
    is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if you only wanted to find a match for the dot character itself? If
    you want a special character (one that is used in regex to specify a pattern)
    to have a normal meaning, or a normal character to have a special meaning, you
    can escape it using the backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we escape the dot by adding a preceding backslash. Therefore,
    it doesn''t function as a wildcard and it is going to look for a literal match.
    This is what it will return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some normal characters that get a special meaning by adding a backslash
    before them. We are not going to cover them in depth, but let''s have a look at
    some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we escape the d, `\d`, it matches any digit. We are doing a global search
    so it will specify any digit. This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also escape the s, `\s`, which matches all whitespace characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example will just return a few spaces, but tabs and other types of
    whitespace are also included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'A very useful one is `\b`, which matches text only when it''s at the beginning
    of a word. So, in the following example, it is not going to match the instances
    of `in` in `beginning`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what it will end up logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though you can check for characters being numbers, the `match()` method
    belongs to the `string` object, so you implement it on numeric variables. For
    example, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: You should receive a `TypeError` saying that `nr.match()` is not a function.
  prefs: []
  type: TYPE_NORMAL
- en: Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many reasons to group your regex. Whenever you want to match a group
    of characters, you can surround them with parentheses. Have a look at this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here it is going to look for either `love` or `dislike`, followed by a whitespace
    character, followed by `javascript` or `spiders`, and it will do so for all occurrences
    while ignoring whether they are in uppercase or lowercase. This is what it will
    log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s just say we can match on roughly four combinations here. Two of them
    seem to make more sense to me personally:'
  prefs: []
  type: TYPE_NORMAL
- en: Love spiders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dislike spiders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Love JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dislike JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Groups are very powerful when we know how to repeat them. Let''s see how to
    do that. Very often, you''ll find yourself in need of repeating a certain regex
    piece. We have several options for this. For example, if we want to match any
    four alphanumeric characters in a sequence, we could just write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following as output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a terrible way to go about repeating a block: let''s look for better
    options. If we only want it to be present 0 or 1 times, we can use the question
    mark. So this is for optional characters, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks for a `g` character that may or not may be preceded by an `n`. Therefore,
    this will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguably, one time is not really an example of repeating. Let''s look at getting
    more repetitions. If you want something at least once, but optionally more often,
    you can use the plus sign: `+`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to match for the group `123` one or more times. And since this
    string is present, it will find a match. This is what will be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'It matches the whole string in this case, since it is just `123` repeated.
    There are also situations where you want to have a certain piece of regex match
    any number of times, which can be indicated with the asterisk: `*`. Here is an
    example regex pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'It will match with any `a` preceded by `123` any number of times. So it will
    match on the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: 123123123a
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 123a
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ba
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last thing to note about repeating is that we can be more specific as well.
    We do this using this syntax `{min, max}`. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It does this because it will match on `abc` both once and twice. As you can
    see, we have been using groups, but `groups` is still `undefined` in the output.
    In order to specify groups, we''ll have to name them. Here''s an example of how
    to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: There is more to say about regex, but this should already enable you to do quite
    a lot of cool things with it. Let's have a look at some practical examples.
  prefs: []
  type: TYPE_NORMAL
- en: Practical regex
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regex can be of great use in many situations—anywhere you need to match certain
    string patterns, regex will come in handy. We are going to discuss how you can
    use regex in combination with other string methods, and how you can use it to
    validate email addresses and IPv4 addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Searching and replacing strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *Chapter 8*, *Built-In JavaScript Methods*, we saw the search and replace
    methods on strings. We would have liked our search to be case-insensitive, though.
    Guess what—we can use regex for this!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Adding the `i` modifier here ignores the distinction between uppercase and lowercase.
    This code returns `15`, which is the starting index position of the match. This
    cannot be done using the normal string input.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do you think we can alter the behavior of the replace method using regex
    in such a way that we can replace all instances rather than the first instance
    of a string? Again, with a modifier! We use the global modifier (`g`) for this.
    To get a feel for the difference, look at this expression without `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what it outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Without regex, it only replaces the first encounter. This time, let''s see
    it with the `g` global modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all occurrences are replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.1
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Find and replace strings. The following exercise involves replacing characters
    in a specified string value. The first input field will indicate which character
    string will be replaced, and the second input field will indicate which characters
    will replace them once the button is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the HTML below as a template, and add the JavaScript needed to complete
    the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select each of the three page elements using JavaScript and assign the element
    objects as variables so that they can be easily referenced in your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener to the button to invoke a function when clicked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function named `lookup()` that will find and replace the text in the
    output element. Assign the output element's text content to a variable named `s`,
    and then assign the value of the input we are replacing to another variable named
    `rt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new regex with the value of the first input field, which will allow
    you to replace the text. Using the regex, check for a match with the `match()`
    method. Wrap this with a condition that will execute a block of code if matches
    are found.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the match is found, use `replace()` to set the new value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the output area with the newly created and updated text output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Email validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to create a regex pattern, we need to be able to describe the pattern
    with words first. Email addresses consist of five parts, in the form of `[name]@[domain].[extension]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the five parts explained:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: One or more alphanumerical characters, underscores, dashes, or dots'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@`: Literal character'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`domain`: One or more alphanumerical characters, underscores, dashes, or dots'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`.`: Literal dot'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`extension`: One or more alphanumerical characters, underscores, dashes, or
    dots'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, let''s do the steps for regex:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[a-zA-Z0-9._-]+`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`@`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[a-zA-Z0-9._-]+`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`\.` (remember, the dot is a special character in regex, so we need to escape
    it)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`[a-zA-Z0-9._-]+`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Putting it all together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at this regex in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We tested the pattern on both a valid and an invalid email address, and this
    is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it returns a result for the valid email and it returns null
    (no match) for the invalid email.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.2
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Create an application that uses JavaScript to check whether the string value
    of an input is a validly formatted email using regex. Look at the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the above template code to start creating your application. Within the JavaScript
    code, select the `input`, `output`, and `button` elements from the page as JavaScript
    objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener to the button to run a block of code when clicked that
    will get the current value in the input field. Create a blank response value that
    will populate the output `div` element contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a test with the string value from the input field and the expression for
    email format. If the test result is `false`, update the response output to say
    `Invalid Email` and change the output color to `red`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the condition of the test returns `true`, add a response that confirms the
    email format is correct and change the text color of output to `green`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the response value into the output element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Functions and the arguments object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript deals with arguments in functions by adding them to a custom object
    called `arguments`. This object works a lot like an array, and we can use it instead
    of using the name of the parameter. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: When you update one of the parameters, the argument gets changed accordingly.
    The same goes for the other way around;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This is going to change both `arguments[0]` and `b`, as they are related to
    `a` and `arguments[1]`, respectively, as you can see in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If the function is called with more arguments than were declared in the function
    signature, this is the way to access them. However, the modern way is to use the
    rest parameter `(…param)` instead of the `arguments` object.
  prefs: []
  type: TYPE_NORMAL
- en: In case you've forgotten what the rest parameter is, you can revisit the rest
    parameter in *Chapter 6*, *Functions*.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will demonstrate using the array-like `arguments` object and
    extracting values from it. Using the `arguments` length property, we will iterate
    through the items in the arguments and return the last item in the list:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a function without any parameters. Create a loop to iterate through the
    length of the `arguments` object. This will allow an iteration of each item of
    the arguments in the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a variable called `lastOne` with a blank value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you loop through the arguments, set `lastOne` to the current value of the
    argument using the index of `i` to return the argument value. The argument will
    have an index value that can be used to reference the value as you iterate through
    the `arguments` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the value of `lastOne`, which should only return the last argument value
    as the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the response from the function, pass a number of arguments into the function,
    and console log the response result. You should see only the last item in the
    list. If you want to see each one, you can output them separately to the console
    as you look through the values, or construct an array that can then be returned,
    adding each one as you go through the arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JavaScript hoisting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In *Chapter 6*, *Functions*, we discussed that we have three different variables,
    `const`, `let`, and `var`, and we highly recommended that you should use `let`
    instead of `var` because of their different scopes. JavaScript **hoisting** is
    why. Hoisting is the principle of moving declarations of variables to the top
    of the scope in which they are defined. This allows you to do things that you
    cannot do in many other languages, and for good reason by the way. This should
    look normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It just logs `5`. But thanks to hoisting, so does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If you try to do this with `let`, you'll get a `ReferenceError`. This is why
    it is better to use `let`. Because clearly, this behavior is very hard to read,
    unpredictable, and you don't really need it.
  prefs: []
  type: TYPE_NORMAL
- en: The reason this happens is that the JavaScript interpreter moves all the `var`
    declarations to the top of the file before processing the file. Only the declarations,
    not the initializations. This is why you get a result of `undefined` if you use
    it before having initialized it. And this is why it should be initialized before
    it has been declared. It was designed this way for memory allocation, but the
    side effects are undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a way to turn this behavior off. Let's see how we can do so
    in the next section!
  prefs: []
  type: TYPE_NORMAL
- en: Using strict mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can change the understanding and forgiving behavior of JavaScript to some
    extent using strict mode. You can switch on strict mode with the following command
    in your code. This needs to be the first command of your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is something that works when we don''t use strict mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We forgot to declare `greeting`, so JavaScript did it for us by adding a `greeting`
    variable to the top level and it will log `Hello!`. If we enable strict mode,
    however, this will give an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use strict mode only in a particular function: simply add it to
    the top of the function and it gets enabled for that function only. Strict mode
    alters a few other things too; for example, when using strict mode, there are
    fewer words that can be used as names for your variables and functions because
    they are likely to become reserved keywords in the future that JavaScript will
    need for its own language.'
  prefs: []
  type: TYPE_NORMAL
- en: Using strict mode is a great way of getting used to using JavaScript in the
    setting of frameworks or even for writing TypeScript later. It is typically considered
    a good practice nowadays, so we would encourage you to use this in your own code
    when you have the chance. This is often not an (easy) option when working with
    existing older code though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have seen strict mode, it''s time to dive into a whole different mode:
    debug mode! Debug mode is for when you are not busy writing or running your application,
    but are running it in a special way to spot the locations of any errors.'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging is a delicate art. In the beginning, it usually is very hard to spot
    what's wrong with your code. If you are using JavaScript in the browser and it
    is not behaving as you would expect, step 1 is always to open the console in the
    browser. Often it will contain errors that can help you further.
  prefs: []
  type: TYPE_NORMAL
- en: If that doesn't solve it, you can log to the console in every step of your code,
    and also log the variables. This will give you some insight as to what is going
    on. It might just be that you are relying on a certain variable that happens to
    be undefined. Or perhaps you are expecting a certain value from a mathematical
    computation, but you've made an error and the result is something completely different
    from what you thought. Using `console.log()` during development to see what's
    happening is rather common.
  prefs: []
  type: TYPE_NORMAL
- en: Breakpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A more professional way to go about debugging is to use breakpoints. This can
    be done from most browsers and IDEs. You click on the line before your code (in
    the **Sources** panel in Chrome, but this may be different for different browsers),
    and a dot or arrow will appear. When your application is running, it will pause
    at this point to give you the opportunity to inspect the values of variables and
    walk through the code line by line from there.
  prefs: []
  type: TYPE_NORMAL
- en: 'This way, you will get a good clue of what is going on and how to fix it. Here
    is how to use breakpoints in Chrome, and most other browsers have something like
    this. In Chrome, go to the **Sources** tab of the **Inspect** panel. Select the
    file you want to set a breakpoint in. Then you just click on the line number and
    it sets the breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_12_01.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Breakpoints in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then try to trigger the line of code, and when it gets triggered, it pauses.
    On the very right of the screen I can inspect all the variables and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application'
  prefs: []
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_12_02.png)
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Inspecting breakpoint variables'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now go through your code with a fine-toothed comb: with the play icon
    on top, you can resume script execution (until it hits the next breakpoint or
    runs in to the same breakpoint again). With the round arrow icon at the top, I
    can go to the next line and inspect the values on the next line again.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many options with breakpoints that we don''t have space to cover
    here. For more detail on how you can debug your code with breakpoints, look in
    your chosen code editor''s documentation or check the relevant Google Chrome documentation
    here: [https://developer.chrome.com/docs/devtools/javascript/breakpoints/](https://developer.chrome.com/docs/devtools/javascript/breakpoints/).'
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variable values can be tracked in the editor while debugging. The following
    exercise will demonstrate how to use the editor's breakpoints to check a value
    of a variable at a certain point in the running of the script. This is a simple
    example, but the same process can be used to find out information about larger
    scripts at specific points during execution, or establish where a problem may
    lie.
  prefs: []
  type: TYPE_NORMAL
- en: There are minor differences and nuances in the way breakpoints operate in different
    editors, so please refer to the documentation of your environment for more of
    a detailed walk-through—this is intended to give you an idea of what breakpoints
    offer when it comes to debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following short script as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Remember to add `<script>` tags and open the script as an HTML document if you're
    testing this in your browser console.
  prefs: []
  type: TYPE_NORMAL
- en: 'This exercise has been tested in a desktop editor but it is equally relevant
    to browser consoles and other environments. Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your script in your chosen editor, or the **Sources** tab of your browser's
    **Inspect** panel. Click to the left of the line of code where you want to add
    a breakpoint. A dot or other indicator will appear to indicate the breakpoint
    is set:![A screenshot of a computer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Description automatically generated with low confidence](img/B16682_12_03.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.3: Setting breakpoints'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the code with your new breakpoints: I have selected **Run** | **Start Debugging**,
    but this will vary depending on your editor. You can simply reload the web page
    if you''re using the browser console to rerun the code with your new breakpoints
    accounted for:![Graphical user interface, text, application'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_12_04.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.4: Running code with breakpoints added'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should now see the debugging console. There will be a tab that lists the
    variables in the code and the current values at the first breakpoint. It's called
    **VARIABLES** in my editor, but it's the **Scope** tab in the Chrome browser console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use the menu options to move to the next breakpoint, stop debugging,
    or restart the breakpoint sequence. Press the play icon to move to the next breakpoint.
    It will update to have a value of 5, as specified by line 1, and pause at the
    first breakpoint. Note that the highlighted line has not been run yet:![A screenshot
    of a computer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Description automatically generated with medium confidence](img/B16682_12_05.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.5: Viewing variables in the console'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press the play icon once more, and the script will run until it hits the next
    breakpoint, at which point the value of the variable will update as a result of
    the code on line 2:![Text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_12_06.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.6: Progressing through breakpoints in a script'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Press play again to move to the next breakpoint, which increases the value of
    `val` once more:![Text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_12_07.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.7: The final breakpoint'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once the last breakpoint is reached you will only see options to restart or
    stop the debugger. If you press stop, it will end the debugging process:![Text
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Description automatically generated](img/B16682_12_08.png)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.8: Breakpoints in the browser'
  prefs: []
  type: TYPE_NORMAL
- en: The final value of `val` after the third breakpoint was revealed as `135`. Write
    down the values of `val` after the first and second calls to the `adder()` function,
    which were revealed to you by using breakpoints.
  prefs: []
  type: TYPE_NORMAL
- en: This was a basic exercise, but we invite you to test out using breakpoints on
    some larger scripts and get more comfortable in your understanding of how your
    code works during runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have seen a lot of errors appear already. Until now, we let the program crash
    when it encountered an error. There are other ways to deal with errors. When we
    are dealing with code that depends on some sort of outside input, such as an API,
    user input, or a file we will need to deal with the errors that this input can
    cause.
  prefs: []
  type: TYPE_NORMAL
- en: If we expect a certain piece of code to throw an error, we can surround this
    code with a `catch` block. The error it might throw will be caught in this block.
  prefs: []
  type: TYPE_NORMAL
- en: You have to be careful not to use this too much, and you usually don't want
    to do this when you can just write better code to avoid the error in the first
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a piece of code that throws an error, and is surrounded
    with a `try` and `catch` block. Let''s assume the `somethingVeryDangerous()` function
    might throw errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: If it throws an error, it will end up in the `catch` block. Since `Error` could
    mean many different errors, we are going to check for the exact error we are dealing
    with and write a specific handling of this error. We check the exact error class
    with the `instanceof` operator. After the error handling, the rest of the code
    will continue to execute normally.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do one more thing with a `try` `catch` block, and that is add a `finally`
    block. This `finally` block gets executed irrespective ofwhether errors are thrown.
    This is great for cleanup purposes. Here is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We don't know the output of this code, since `trySomething()` is not defined.
    If it were to throw an error, it would log `Oh oh` to the console and then `Error
    or no error, I will be logged!`. If `trySomething()` didn't throw an error, it
    would only log the last part.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, if, for whatever reason, you need to throw an error, you can do so
    with the `throw` keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This can be of great use whenever you need to deal with things out of your control,
    such as an API response, user input, or input from reading a file. If unexpected
    things happen, sometimes you'll have to throw an error to deal with it appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using `throw`, `try`, and `catch`, check if the value is a number, and if it's
    not, then create a custom error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function with one argument called `val`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `try`, and within it add a condition that checks whether `val` is a number
    using `isNaN`. If true, then throw an error that states that it is not a number.
    Otherwise, output `Got a number` to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `catch` to catch any errors and output the error values to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `finally` to run and output the value, and when the function has completed,
    also include the value of `val`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one request to the function with a string argument and another with a
    number. See the results in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using cookies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Cookies** are small data files that are stored on your own computer and used
    by websites. Cookies were invented to store things about the user of the website.
    Cookies are strings with a special pattern. They contain key-value pairs, and
    these key-value pairs are separated by semi-colons.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a cookie and use it again later. Here is how you can create
    a cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This does not work in all browsers when you run it on the client side (such
    as in your `<script>` tag). In Chrome, for example, you cannot set the cookies
    from the client side. You have to run the code from a server. (I have used Safari
    instead to do this here, but there are no guarantees about future support.) An
    alternative is the web storage API.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to start Chrome from the command line with certain settings
    enabled, or to enable the cookies in the settings under privacy preferences. Careful
    to turn this off afterward if you don''t want it, though. This is how you can
    read from the cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This example gets all the cookies using `decodeURIComponent()`, and then splits
    them on the `;`. This leaves us with an array, `cookieList`, with key-value pairs
    as strings. Next, we loop over all the key-value pairs. Trim them (remove the
    whitespace in front and at the back), and see whether they start with `name`.
    This was the name of our cookie key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to get the value, we have to start reading after the key, so at
    least the length of the key, which is 4 (name) in this case. This brings us to
    index 3 already. We also want to skip the equal sign on index 4, so we start at
    index 5\. In this case, we are adding an alert to the name. Here is an example
    of a simple website that uses a cookie to greet the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: If you are writing a new website, you probably should not be using this. However,
    whenever you need to work with older code, chances are you'll come across this.
    And now you know what it means and how to adjust it. Good for you!
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s make a cookie builder. Create several functions that will allow you
    to interact with page cookies, including reading a cookie value by name, creating
    a new cookie using a name and setting it for a set number of days, and deleting
    a cookie. You can use the following HTML template to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up your webpage, and in the JavaScript code, output the value of `document.cookie`.
    It should be blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that will take the parameters for `cookieName`, `cookieValue`,
    and the number of days you want to set the cookie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if `days` is valid, and within the block of valid code, get the current
    date. Set a `setTime` value for the cookie to expire in milliseconds by multiplying
    the days into milliseconds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the date object of milliseconds until the cookie expires to a UTC string
    value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set `document.cookie` to `cookieName = cookieValue`, plus add the expiry details
    and lastly specify `path=/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to create a test cookie with a value and expiry set after
    a number of days. Create a second cookie the same way, and when you refresh your
    page, you should see at least two cookies in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a second function to read a cookie value, set the value as `false`, and
    then create an array of the cookies split by semi-colons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through all the cookies and split again where the equal signs are. This
    will give you the first item with index 0 as the name of the cookie. Add a condition
    to check if the name is equal to the name that was requested in the function parameters.
    If it matches, assign the value of the second item in the index, which will be
    the value of the cookie with the selected name. Return `cookievalue` in the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two console log messages using the function to read both cookies you have
    set earlier. Output the values of the cookies in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To delete a cookie, you need to set a date prior to the current date. You can
    create a cookie with a `-1` date and send the cookie with its selected name to
    be deleted by invoking the cookie creation function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try deleting a cookie by name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Local storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have looked at cookies as a way to save user data, but there is actually
    a more modern way to do this: **local storage**. Local storage is an amazing fun
    topic that will add to your ability to make smart websites. With local storage,
    we can save key-value pairs in our web browser and use them again in a new session
    (when the browser is opened again later). The information is typically stored
    in a folder on the computer of the user, but this differs a bit by browser.'
  prefs: []
  type: TYPE_NORMAL
- en: This allows the website to store some information and retrieve it later, even
    after refreshing the page or closing the browser. The advantage of local storage
    over cookies is that they don't need to be passed around with every HTTP request,
    which is the case with cookies. Local storage just lives there and waits to be
    accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `localStorage` object is a property of the `window` object that we have
    seen before. There are a few methods on the `localStorage` object that we need
    to know to use it effectively. First of all, we need to be able to get and set
    key-value pairs on local storage. We use `setItem()` whenever we want to save
    something and `getItem()` whenever we want to retrieve the value later. Here is
    how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: If you go back to your code and turn off the `setItem()` line before loading
    the page a second time, it still will output that value, since the information
    was stored when running the script the first time and never got deleted. Local
    storage doesn't expire, though it can be manually deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also retrieve a key using the index. This is useful whenever we need
    to loop through the key-value pairs and we don''t know the names of the keys.
    This is how to retrieve a key by index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the key is `name`. In order to get the associated value, we can
    do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also remove key-value pairs like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'And we can remove all the key-value pairs from the local storage in one call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: So, with local storage you can save values even after closing the browser. This
    allows for a lot of "smart" behavior, since your app is now able to remember things,
    such as what you've entered in a form, which settings you've toggled on a website,
    and what you've looked at previously.
  prefs: []
  type: TYPE_NORMAL
- en: Please don't see this as an alternative that you can use to bypass the problems
    with cookies and privacy. Local storage raises the exact same issues as cookies,
    it's just less known. You will still have to mention on your website that you
    are tracking users and storing information, just like you need to do for cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a local storage shopping list that will store values in the browser''s
    local storage. This is an example of using JavaScript to convert from strings
    to useable JavaScript objects and back to strings that can be stored in local
    storage. You can use the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript code, select all the page elements as JavaScript objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `tasks` array with a value of the local `tasklist` storage if it exists,
    otherwise set the `tasks` array to an empty array. Using `JSON.parse`, you can
    convert the string value to a useable object in JavaScript.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through all the items in the `tasklist` array; they will be stored as objects,
    with a name and a Boolean value for their checked status. Create a separate function
    to build the task item, adding it to the page from the list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the task generation function, create a new list item and a `textNode`. Append
    `textNode` to the list item. Append the list item to the page output area. If
    the task is marked complete with a Boolean value of `true`, then add the `style`
    class of `ready`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener to the list item that will toggle the `ready` class when
    clicked. Every time there is a change to any list item, you will also need to
    store that to the local storage. Create a task builder function that will store
    and ensure the visual list is the same as the local storage list. You will need
    to clear the current task list array and rebuild from the visual data, so create
    a function to handle the list building.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task builder function will clear the current `tasks` array, and select all
    the `li` elements on the page. Loop through all the list items, getting the text
    value from the element, and checking if it contains the class of `ready`. If it
    contains the `ready` class, then mark the checked condition as true. Add the results
    to the `tasks` array, and this will rebuild the array to ensure it matches with
    what the user sees visually. Send to a save tasks function to save the `tasks`
    array in local storage, so if the page is refreshed, you will see the same list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the save tasks function, set the `localstorage` item to the tasks array.
    You will need to stringify the object so that it can go into the string parameter
    of local storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, when you refresh the page, you will see the list of tasks. They can be
    crossed out by clicking them and new items can be added in the input field by
    pressing the button to submit new items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON** stands for **JavaScript Object Notation**, which is nothing more than
    a data format. We saw this notation when we were creating our objects in JavaScript;
    however, JSON doesn''t mean JavaScript objects, it''s just a way of representing
    data using a similar format as JavaScript objects. It can also be easily converted
    to a JavaScript object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is a standard used to communicate with APIs, including APIs that aren''t
    written in JavaScript! APIs can accept data, for example, the data from a form
    on a website, in JSON format. And nowadays, APIs almost always send data back
    in JSON. Sending data from an API happens, for example, when you enter a web shop—the
    products typically come from a call to an API that is connected to a database.
    This data gets converted to JSON and is sent back to the website. Here is an example
    of JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: This is an object that seems to describe a person. It has key-value pairs. The
    keys always have to be between quotes, but the values only have to be between
    quotes when they are strings. So, the first key is `name` and the first value
    is `Malika`.
  prefs: []
  type: TYPE_NORMAL
- en: Lists of values (or JavaScript arrays) are indicated with `[]`. The JSON object
    contains a list of `languages`, which has the square brackets, and another object,
    `address`. You can tell this by the curly brackets.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually only a few flavours in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key-value pairs with values of the following types: string, number, Boolean,
    and null'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-value pairs with lists, which have `[` and `]` that contain the items in
    the list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Key-value pairs with other objects, which have `{` and `}` that contain other
    JSON elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three options can be combined, so an object can contain other objects
    and a list can contain other lists. We saw this already in the above example.
    Our object contained a nested address object.
  prefs: []
  type: TYPE_NORMAL
- en: But this can be nested even further. A list can also contain objects, which
    can contain lists with objects, with lists, and so on. This might sound a bit
    complicated and that's exactly the point. Even though it is very simple, nesting
    all these options can still complicate JSON a bit. There is a reason we've placed
    it in our advanced topic chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at a slightly more complex example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a list of companies, with two company objects on it. The companies
    have two key-value pairs: a name and an address list. Each of the address lists
    contains two addresses, and each address consists of three key-value pairs: `street`,
    `zipcode` and `city`.'
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This exercise will demonstrate how you can create a valid JSON object that
    can be used as a JavaScript object. You will create a simple list of names and
    statuses that can be looped through and output the results to the console. You
    will load JSON data to JavaScript and output the results of the object''s contents:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JavaScript object that contains JSON formatted data. The object should
    contain at least two items and each item should be an object with at least two
    paired values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function that can be invoked that will loop through each item in the
    JavaScript JSON object and output the result to the console. Output each item
    of data to the console using `console.log`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke the function and launch the JavaScript code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parsing JSON
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many libraries and tools available for parsing a JSON string into
    an object. A JavaScript string can be converted to a JSON object using the `JSON.parse()`
    function. Data that is received from another place is always of value `string`,
    so in order to treat it as an object, it needs to be converted. This is how to
    do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: After parsing, it can be treated as an object. Therefore it will log `Maaike
    is 30` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way around is also necessary sometimes. Objects can be converted
    to a JSON string using the `JSON.stringify()` method. It converts the object or
    value from JavaScript to a JSON string. You can see it in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of `strdog` becomes a string because it is being stringified. And
    it no longer has the properties `name` and `breed`. These will be undefined. This
    code snippet will log the following to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful for storing JSON data directly in a database, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 12.9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This exercise will demonstrate the use of JSON methods to parse JSON and convert
    string values to JSON. Using JSON methods with JavaScript, convert a JSON formatted
    string value to a JavaScript object and convert a JavaScript object into a string
    representation of the JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JSON object with several items and objects. You can use the JSON object
    from the previous lesson.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the JSON `stringify()` method, convert the JSON JavaScript object into
    a string version and assign it to a variable named `newStr [{"name":"Learn JavaScript","status":true},{"name":"Try
    JSON","status":false}]`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using `JSON.parse()`, convert the `newStr` value back into an object and assign
    it to a variable named `newObj`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate through the items in the `newObj` and output the results to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Practice exercise 12.9 answers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Chapter projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Email extractor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the following HTML as a starter template and add the JavaScript code to
    make an email extractor function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, select both text areas and the button and set them as JavaScript
    objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener to the button that will invoke a function that gets the
    content of the first `textarea` and filters it to only accept email addresses.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the extracting function, get the content of the first input field. Using
    `match()`, return an array of the email addresses that were matched from within
    the content from the first `textarea`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To remove any duplicates, create a separate array that will hold only unique
    values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through all the email addresses found and check whether each one is already
    in the `holder` array, and if not, add it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `join()` array method, you can now join together the results of the
    email addresses found within the content and output it into the second `textarea`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Form validator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This project is an example of a typical form structure where you check the
    values inputted into the form and validate them before the content gets submitted.
    A response is returned to the user if the values do not meet the validation criteria
    in the code. Use the following HTML and CSS as a starting template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using JavaScript, select all the page elements and set them as JavaScript objects
    so they are easier to select within the code. Also select all the page elements
    that have the `error` class as an object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an event listener to submit and capture the click, preventing the default
    form action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loop through all the page elements that have a class `error` and add the `hide`
    class, which will remove them from view since this is a new submission.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the regular expression for valid emails, test the results against the
    input value of the email field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to respond to errors, which removes the `hide` class from
    the element next to the element that triggered the event. Apply focus to that
    element within the function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is an error that an input does not match the desired regex, pass the
    parameters to the error handling function you just created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the password field input value to ensure only letters and numbers are
    used. Also check the length to ensure that it is 3-8 characters. If either are
    false, then add the error with the error function and create a message for the
    user. Set the error Boolean to `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add in an object to track the form data creation and add values to the object
    by looping through all the inputs, setting the property name to be the same as
    the input name, and the value the same as the input value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before the end of the validation function, check if an error is still present,
    and if it is not, submit the form object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simple math quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, we will create a math quiz that will allow the user to respond
    to math questions. The application will check the responses and score the accuracy
    of the user''s answers to the questions. You can use the following HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Take the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In JavaScript, wrap the code within a function, `app`. Within the app function,
    create variable objects to contain all the page elements so they can be used in
    the script, and create a blank object called `game`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `DOMContentLoaded` event listener that invokes the app initialization
    once the page loads.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within an `init()` function, add an event listener to the button, listen for
    a click, and track the event into a function called `checker`. Also within the
    `init` function, load another function called `loadQuestion()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function to load the questions, and another function that can generate
    a random number from min and max values in the arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `loadQuestion()` function, generate two random values and add them to
    the game object. Calculate the result of both values added together and assign
    that value within the game object as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign and update the `textContent` of the page elements that require the dynamic
    number values for the calculation question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the button is clicked, use a ternary operator to determine whether the
    answer to the question was correct or incorrect. Set the color to `green` for
    correct, and to `red` for incorrect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a page element to output all the questions and keep track of the results.
    Within the `checker()` function, append a new element to the HTML with a style
    color to indicate a correct or incorrect response. Display the first and second
    values as well as the answer, and show the user's response within brackets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clear the input field and load the next question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-check quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What will the following regex expression return from the following words?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Are cookies part of the document object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What will the following code do to a JavaScript cookie?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output in the console from the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output in the console from the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the output of the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had some important, more advanced topics that we still had
    to cover, but that you were probably not ready for earlier in the book. After
    this chapter, you should have deepened your understanding of JavaScript in several
    areas, first and foremost, regular expressions. With regex, we can specify patterns
    of strings and we can use these to search other strings for matches to our patterns.
  prefs: []
  type: TYPE_NORMAL
- en: We also considered functions and the `arguments` object, with which we can access
    arguments by their index. We continued with a look at JavaScript hoisting and
    strict mode, which enables us to use JavaScript with a few more rules. Getting
    used to JavaScript in strict mode is generally a good practice and is great preparation
    for working with JavaScript frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Debugging and tweaking were also discussed: we can use breakpoints or log our
    output to the console to get an idea of what is going on. Handling errors well
    can prevent unnecessary crashes of our program. Finally, we looked at JavaScript
    cookie creation and the use of local storage, along with the use of JSON, a syntax
    for sending data around. We saw the different types of key-value pairs and how
    to parse JSON. We also saw how to store key-value pairs in the `localStorage`
    object of `window`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter has deepened our understanding of JavaScript, and we learned some
    new things we need to know for modern JavaScript, but also a lot for when dealing
    with old (legacy) code. In the next chapter, we''ll dive into an even more advanced
    topic: concurrency. This topic is about multitasking with your JavaScript code.'
  prefs: []
  type: TYPE_NORMAL
