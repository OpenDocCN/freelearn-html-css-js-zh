<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Nesting Rules</h1></div></div></div><p>If you have spent any time developing with preprocessors, then you will likely have come across nested properties—instead of writing multiple style rules with repeated references to the same elements, we can use nesting to create concise style rules that compile to valid CSS.</p><p>In this chapter, we'll delve into using the power of nesting, show you how you can transition from using preprocessors such as SASS or Less, and explore some of the tricks we can use that are not available with preprocessors such as SASS:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Exploring the use of BEM (Block, Element, Modifier) or standard nesting</li><li class="listitem" style="list-style-type: disc">Creating nested rules and BEM equivalents using existing preprocessors</li><li class="listitem" style="list-style-type: disc">Transitioning to using PostCSS plugins</li><li class="listitem" style="list-style-type: disc">Understanding the pitfalls of nesting and how we can improve our code</li></ul></div><p>Let's make a start…!</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Introducing nesting</h1></div></div></div><p>The concept of <a id="id106" class="indexterm"/>nesting is nothing new when using processors such as Less CSS or SASS; it's a useful technique to help reduce the amount of code we need to write, and to organize code in a more human-readable format.</p><p>The flipside of the coin is that it is frequently abused—when using processors for the first time, many developers fall into the trap of thinking that everything should be nested. One can get away with it if the code is very simple; it is more likely to result in fragile code that is difficult to read and easily broken with simple changes to one or more styles in the code.</p><p>If nesting is done correctly, then it can be very effective; it helps avoid the need to repeat parent selectors, and allows us to group together rules that apply to the same selector, together. To see what is meant by this, take a look at this simple example for SASS:</p><div><pre class="programlisting">#main p {
  color: #00ff00;
  width: 97%;

  .redbox {
    background-color: #ff0000;
    color: #000000;
  }
}</pre></div><p>If this is compiled using <a id="id107" class="indexterm"/>a GUI application or via the command line, it results in these styles:</p><div><pre class="programlisting">#main p { 
  color: #00ff00; 
  width: 97%;
}

#main p .redbox { 
  background-color: #ff0000; 
  color: #000000; 
}</pre></div><p>The great thing about this code is that we've not tried to cram in every single rule that applies to the same parent selector, or a descendant; this is something we should consider when working with nesting.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Notice how, in our SASS example, the nesting was at the end of the code? It's considered good practice to include nested statements at the end, before the closing bracket.</p></div></div><p>Some developers counsel against using nesting though, as it causes real issues for elements that have been styled in specific contexts; it becomes harder to change the code if we need to change the style. We will explore more of the reasons why nesting is fraught with risks later in this chapter.</p><p>Leaving aside the risks of nesting for the moment, we can use the same basic principle of nesting when using PostCSS—for this, we need to use the <code class="literal">postcss-nesting</code> plugin by Jonathan Neal, which is available from <a class="ulink" href="https://github.com/jonathantneal/postcss-nesting">https://github.com/jonathantneal/postcss-nesting</a>. To give you a flavor of what nesting looks like in PostCSS, take a look at this screenshot—this is an online playground provided by the author for trialing nested statements, where we can see the results automatically on the right:</p><div><img src="img/BO5194_03_01.jpg" alt="Introducing nesting"/></div><p>The key line is on the left, fifth from the bottom: the <code class="literal">postcss-nesting</code> plugin uses <code class="literal">@nest &amp;</code> as the placeholder for nesting code.</p><p>To help illustrate how the <a id="id108" class="indexterm"/>
<code class="literal">postcss-nesting</code> plugin works, we will use it to create a somewhat unique navigation system. Our navigation will use a mix of jQuery and CSS to style and flip some demo pages, with the animation effects provided by CSS3 styling. Intrigued? Let's dive in and take a look.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Navigating through pages</h1></div></div></div><p>I've always had a <a id="id109" class="indexterm"/>desire to do something a little different; doing the same thing as everyone else becomes so passé! With this in mind, when researching for this book, I came across an intriguing demo by Nikolay Talanov, where pages are flipped over from one to the next, using either CSS3 animation if supported, or falling back to standard jQuery.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>You can see the original pen demo at <a class="ulink" href="http://codepen.io/suez/pen/LCHlA">http://codepen.io/suez/pen/LCHlA</a>.</p></div></div><p>This has provided a perfect base for this chapter. For the purpose of the demos, I've stripped back the vendor prefixes (as these will be covered by <code class="literal">Autoprefixer</code>), tweaked the design of the first page, and switched to just using nesting throughout. The jQuery fall-back code has also been removed, as most modern browsers will support the animations with little <a id="id110" class="indexterm"/>difficulty.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Preparing our demo</h2></div></div></div><p>For our demo, we will <a id="id111" class="indexterm"/>have four pages—the navigation will flip between each page, using standard CSS3 animation:</p><div><img src="img/BO5194_03_02.jpg" alt="Preparing our demo"/></div><p>The design may be a little unique, but to help illustrate how it could be used, I've added a simple wireframe sketch to the front page, which could easily be expanded to the remaining pages and developed into something more substantial.</p><p>To see it in action, extract a copy of the <code class="literal">Tutorial5</code> folder from the code download that accompanies this book, then run <code class="literal">index.html</code> in a browser, and click on the dots or arrow icons to the right—you will see it flip up or down, depending on which direction you click.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Converting from existing processors</h2></div></div></div><p>At present, our <a id="id112" class="indexterm"/>demo is using plain CSS, and nothing is wrong with this, but I suspect some of you will likely be using an existing processor, such as SASS or less CSS. The real benefit of using PostCSS is its ability to mimic existing tools, without the dependencies.</p><p>With this in mind, there are copies of the demo, available in the code download, which use Less CSS and SASS. If you prefer using SASS, then go ahead and extract <code class="literal">Tutorial6A</code> from the code download folder; for Less, use <code class="literal">Tutorial6B</code>. The code can easily be compiled using the <code class="literal">gulpfile.js</code> file from <code class="literal">Tutorial1A</code> in <a class="link" href="ch02.html" title="Chapter 2. Creating Variables and Mixins">Chapter 2</a>, <em>Creating Variables and Mixins</em> (for SASS), or <code class="literal">Tutorial 1B</code> (for Less CSS, in the same chapter folder).</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>You will need to install the plugins listed—most of these will already be present from previous demos, but <code class="literal">gulp-sass</code> and <code class="literal">gulp-less</code> will need to be installed using NPM, in the same manner.</p></div></div><p>Both will produce identical results to the vanilla CSS version, once compiled, and the contents of the <code class="literal">dest</code> <a id="id113" class="indexterm"/>folder have been copied to the <code class="literal">css</code> sub-folder in the tutorial folder. With the base demo in place, we are now ready to make the conversion—let's make a start by installing the <code class="literal">postcss-nesting</code> plugin.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Transitioning to using PostCSS plugins</h1></div></div></div><p>We've seen that <a id="id114" class="indexterm"/>adapting code to use nesting is a simple principle, but the real art is getting the balance right, many developers fall into the trap of nesting everything in their code when using the technique for the first time.</p><p>With this in mind, let's explore how we can convert our code to using PostCSS. We'll start by installing the <code class="literal">postcss-nesting</code> plugin, which will perform most of the work for us:</p><div><ol class="orderedlist arabic"><li class="listitem">Fire up a Node.js command prompt, then change the working directory to our project area.</li><li class="listitem">At the command prompt, enter the following command, then press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install --save-dev postcss-nesting</strong>
</pre></div></li><li class="listitem">Node.js will go away and install the plugin—it is ready for use when we see something akin to this screenshot:<div><img src="img/BO5194_03_03.jpg" alt="Transitioning to using PostCSS plugins"/></div></li><li class="listitem">With the plugin installed, we need to configure PostCSS to use it—open up a copy of <code class="literal">gulpfile.js</code> from the project area, ready for editing.</li><li class="listitem">We need to make a few changes—the first is to assign a variable that references the plugin. Add the highlighted line in immediately below the last variable statement:<div><pre class="programlisting">var cssnano = require('cssnano');
var nesting = require('postcss-nesting');</pre></div></li><li class="listitem">The <code class="literal">autoprefixer</code> task needs to be altered—this time around, we will start with compiling our <a id="id115" class="indexterm"/>nested code and adding the appropriate vendor prefixes. Alter the first line of this task, as indicated:<div><pre class="programlisting">gulp.task('autoprefixer', function() {
        return gulp.src('src/*.css')</pre></div></li><li class="listitem">Next, add in the nesting configuration call:<div><pre class="programlisting">     .pipe(postcss([ autoprefixer, nesting({ /* options */ }) ]))</pre></div></li><li class="listitem">SASS normally compresses any code on compilation by default—as we're no longer using it, we need to provide an alternative. For this, we will reuse the <code class="literal">cssnano</code> plugin from <a class="link" href="ch02.html" title="Chapter 2. Creating Variables and Mixins">Chapter 2</a>, <em>Creating Variables and Mixins</em>. Go ahead and add this at line 20:<div><pre class="programlisting">.pipe(postcss([ cssnano() ]))</pre></div></li><li class="listitem">The lint-styles task should then run once the vendor prefixes have been added; to make this happen, add the constraint as shown:<div><pre class="programlisting">gulp.task("lint-styles", ['autoprefixer'], function() {</pre></div></li><li class="listitem">We no longer have any need for the <code class="literal">sass</code> task, so go ahead and remove it in its entirety, and from the default task entry—we should be left with this:<div><pre class="programlisting">gulp.task('default', ['lint-styles', 'autoprefixer', 'rename']);</pre></div></li><li class="listitem">Last, but by no means least, go ahead and switch the order of the rename task. Instead of running it immediately after the <code class="literal">autoprefixer</code> task, we'll run it once the lint-styles task has been completed:<div><pre class="programlisting">gulp.task('rename', ['lint-styles'], function () {</pre></div></li></ol></div><p>At this stage, our gulp task file is now ready for use. We can begin to convert our style sheet to use PostCSS nesting as a replacement for SASS. Let's make a start on converting it, as part of the next exercise.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>If you get stuck, there is a completed version of <code class="literal">gulpfile.js</code> in the code download that accompanies this book—simply extract a copy and place it in the root of our project area to use it.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Converting our demo to PostCSS</h2></div></div></div><p>Altering our code to use <a id="id116" class="indexterm"/>PostCSS is very simple. Even if it requires a few changes, the format does not change significantly when compared to processors such as SASS; let's take a look at what is involved:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll begin by opening a copy of <code class="literal">style.scss</code> from the <code class="literal">Tutorial6A</code> folder in the code download that accompanies this book—save it to the <code class="literal">src</code> folder of our project area. Rename it to <code class="literal">style.css</code>.</li><li class="listitem">On line 19, add <code class="literal">@nest</code> immediately before <code class="literal">&amp;:</code>, as indicated—this is required to allow the <code class="literal">postcss-nesting</code> plugin to correctly compile each nesting statement:<div><pre class="programlisting">@nest &amp;:before, &amp;:after {</pre></div></li><li class="listitem">On line 53, add <code class="literal">@nest &amp;</code> immediately before <code class="literal">h2</code>, as shown:<div><pre class="programlisting">@nest &amp; h2 {</pre></div></li><li class="listitem">On line 61, add <code class="literal">@nest</code> immediately before <code class="literal">&amp;.</code>, as shown:<div><pre class="programlisting"><strong>@nest</strong> &amp;.page1 {</pre></div><p>Repeat step 4 for lines 65, 69 and 73.</p></li><li class="listitem">On line 119, add <code class="literal">@nest</code> immediately before <code class="literal">&amp;.</code>, as shown:<div><pre class="programlisting"><strong>@nest</strong> &amp;.invisible {</pre></div></li><li class="listitem">On line 123, add <code class="literal">@nest</code> immediately before <code class="literal">ul</code>, as shown:<div><pre class="programlisting"><strong>@nest</strong> &amp; ul {</pre></div></li><li class="listitem">On line 125, add <code class="literal">@nest</code> immediately before <code class="literal">&amp; li</code>, as shown:<div><pre class="programlisting"><strong>@nest</strong> &amp; li {</pre></div></li><li class="listitem">On line 136, add <code class="literal">@nest</code> immediately before <code class="literal">&amp;.</code>, as shown:<div><pre class="programlisting"><strong>@nest</strong> &amp;:after {</pre></div><p>Repeat the same process for lines 150 and 155.</p></li><li class="listitem">On lines 179, add <code class="literal">@nest</code> immediately before <code class="literal">&amp;.</code>, as shown:<div><pre class="programlisting">
<code class="literal">@nest</code> &amp;.up {</pre></div><p>Repeat the same process for lines 183 and 187, then save the file.</p></li></ol></div><p>Our style sheet is now converted; to prove it works, we need to run it through PostCSS, so let's do that now as part of the next exercise.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Compiling our code</h2></div></div></div><p>With the changes made <a id="id117" class="indexterm"/>to our code, we need to compile it—let's go ahead and do that now, using the same process we saw back in <a class="link" href="ch02.html" title="Chapter 2. Creating Variables and Mixins">Chapter 2</a>, <em>Creating Variables and Mixins</em>:</p><div><ol class="orderedlist arabic"><li class="listitem">Fire up a Node.js command prompt session, or use the one from earlier if you still have it open, and change the working folder to the project area.</li><li class="listitem">At the prompt, enter this command, then press <em>Enter</em>:<div><pre class="programlisting"><strong>gulp</strong>
</pre></div></li><li class="listitem">If all is well, we <a id="id118" class="indexterm"/>should see something akin to this screenshot:<div><img src="img/BO5194_03_04.jpg" alt="Compiling our code"/></div></li><li class="listitem">A quick peek in the <code class="literal">dest</code> folder of our project area should reveal the relevant compiled CSS and source map files, produced by PostCSS.</li><li class="listitem">At this point, we need to extract a copy of the <code class="literal">Tutorial7</code> folder from the code download that accompanies this book—save this to our project area.</li><li class="listitem">Copy the contents of the <code class="literal">dest</code> folder from our project area to the <code class="literal">css</code> folder under <code class="literal">Tutorial7</code>—if all is well, our demo should continue to work, but without the dependency of SASS.<div><div><h3 class="title"><a id="note20"/>Note</h3><p>Note, make sure you expand the demo to the full width of the screen to view it properly!</p></div></div></li></ol></div><p>Try previewing the results in a browser—if all is well, we should see the same results appear as before, but this time using PostCSS, and without the dependency on SASS. We can now apply the same techniques to any project, safe in the knowledge that using the postcss-nesting plugin will allow us to compile to valid CSS code—or will it?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Exploring the pitfalls of nesting</h1></div></div></div><p>It has to be said that <a id="id119" class="indexterm"/>although nesting is a simple technique to understand, it can be difficult to get right, as shown in our SASS version of the demo:</p><div><img src="img/BO5194_03_05.jpg" alt="Exploring the pitfalls of nesting"/></div><p>The issues we have here are twofold—the multiple levels of nesting result in a high level of code specificity; if we wanted to change the styling for <code class="literal">.nav-panel ul li</code> (the compiled version of line <a id="id120" class="indexterm"/>
<strong>125</strong>), it would likely break the appearance of our front end code. To see what I mean, let's take an example HTML page that any developer might create:</p><div><pre class="programlisting">&lt;body&gt;
  &lt;div class="container"&gt;
    &lt;div class="content"&gt;
      &lt;div class="articles"&gt;
        &lt;div class="post"&gt;
          &lt;div class="title"&gt;
            &lt;h1&gt;&lt;a href="#"&gt;Hello World&lt;/a&gt;
          &lt;/div&gt;
          &lt;div class="content"&gt;
            &lt;p&gt;&lt;/p&gt;
            &lt;ul&gt;
              &lt;li&gt;...&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/div&gt;
          &lt;div class="author"&gt;
            &lt;a href="#" class="display"&gt;&lt;img src="img/..." /&gt;&lt;/a&gt;
            &lt;h4&gt;&lt;a href="#"&gt;...&lt;/a&gt;&lt;/h4&gt;
            &lt;p&gt;
              &lt;a href="#"&gt;...&lt;/a&gt;
              &lt;ul&gt;
                &lt;li&gt;...&lt;/li&gt;
              &lt;/ul&gt;
            &lt;/p&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/body&gt;</pre></div><p>Now, before you all scream, <em>Yuk, I would never do that!</em> at me, and claim (quite rightly) that we should use semantic elements such as <code class="literal">&lt;header&gt;</code>, <code class="literal">&lt;section&gt;</code>, <code class="literal">&lt;article&gt;</code>, and / or <code class="literal">&lt;footer&gt;</code> to provide context and meaning, instead of all of these <code class="literal">&lt;div&gt;</code> statements, then stop! There is a point in <a id="id121" class="indexterm"/>producing that ugly mix of code. Let me explain:</p><p>The example HTML we have just seen is likely to result in this nested CSS:</p><div><pre class="programlisting">body {
  div.container {
    div.content {
      div.articles {
        &amp; &gt; div.post {
          div.title {
            h1 {
              a {
              }
            }
          }
          div.content {
            p { ... }
            ul {
              li { ... }
            }
          }
          div.author {
            a.display {
              img { ... }
            }
            h4 {
              a { ... }
            }
            p {
              a { ... }
            }
            ul {
              li { ... }
            }
          }
        }
      }
    }
  }
}</pre></div><p>Some developers might think this is perfectly acceptable—after all, they know no different, so why should it be an issue, right? Wrong—this code, while it may <em>technically</em> fit the styles in our HTML document, has several issues with it:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>It is awkward to read</strong> at best, and enough to give anyone a headache when trying to decipher it.</li><li class="listitem" style="list-style-type: disc">Try compiling it; it will <a id="id122" class="indexterm"/>result in a lot of <strong>duplicated parent selectors</strong>, with code stretching to around 20 lines.</li><li class="listitem" style="list-style-type: disc"><strong>Rendering performance</strong> is likely to be poor—if for example, a tool such as Google's Page Speed is installed, then it is likely to trigger the <strong>Prioritize Visible Content</strong> rule, where additional round trips are needed to render content on-screen above the fold.</li><li class="listitem" style="list-style-type: disc"><strong>Size</strong> is likely to be an issue—even though we live in an age of broadband connections, it is bad manners to take a cavalier attitude to content, and not create something in as small a footprint as possible.</li><li class="listitem" style="list-style-type: disc"><strong>Maintainability</strong> will become a problem—our example code has bound styles too tightly, which defeats the purpose of cascading style sheets, where we should be able to place common styles in a parent selector and allow these to cascade down to children, or be overridden as required.</li></ul></div><p>How can we get around it? The simplest answer is to be sensible about the number of levels we use when nesting code—some developers argue no more than four; I would argue from experience that two should be sufficient (which in this case would be <code class="literal">body div.content</code>, had we compiled our monster CSS style sheet).</p><p>There is nothing to stop us from using four levels if we absolutely have no other way of achieving our desired result; if we're doing this regularly, then we clearly need to revisit our code!</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Taking a better approach</h2></div></div></div><p>If, when working on code, we <a id="id123" class="indexterm"/>are forced to regularly use nested styles that are more than two or three levels deep, then there are some tricks we can use to reduce both the CSS specificity over time, and the need to use nesting more than two to three levels deep. Let's take a look at a few:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Can you give yourself the class you need? Specificity can creep in if we're overriding an existing selector:<div><pre class="programlisting">.section-header {
  /* normal styles */
}

body.about-page .section-header {
  /* override with higher specificity */
}</pre></div><p>To avoid specificity, can a class be emitted through the use of server-side code or functions, which we can use to style the element instead?</p><div><pre class="programlisting">&lt;header class="&lt;%= header_class %&gt;"&gt;</pre></div><p>Which could output one class, or both, as desired:</p><div><pre class="programlisting">&lt;/header&gt;
.section-header {
  /* normal styles */
}

.about-section-header {
  /* override with same specificity */
  /* possibly extend the standard class */
}</pre></div></li><li class="listitem" style="list-style-type: disc">The order of your <a id="id124" class="indexterm"/>style sheets can play an important role here, even though you might use a single class to override styles:<div><pre class="programlisting">&lt;header class="section-header section-header-about"&gt;
...
&lt;/header&gt;</pre></div><p>Your existing class may be overriding your override; both selectors have the same specificity, so the last rule(s) to be applied will take precedence. The fix for this is simply to rework the order in which your style rules are applied, so that overriding classes can be applied later.</p></li><li class="listitem" style="list-style-type: disc">Consider reducing the specificity of the element you're trying to style; can the element be replaced, or removed in its entirety? If, however, it's being used within JavaScript (or jQuery) code, then it is preferable to leave it as-is, and add a second class (or use an existing class already applied, if one exists).</li><li class="listitem" style="list-style-type: disc">Where possible, aim to use as flat a structure as possible for your code; it is too easy to style an element such as this:<div><pre class="programlisting">.module &gt; h2 {

}</pre></div><p>In this example, we're styling all <code class="literal">h2</code> elements that are direct children of the parent <code class="literal">.module</code> class. However, this will work until we need to assign a different style for the <code class="literal">h2</code> element. If the markup looks similar to this example:</p><div><pre class="programlisting">&lt;div class="module"&gt;
  &lt;h2 class="unique"&gt;
    Special Header
  &lt;/h2&gt;
&lt;/div&gt;</pre></div><p>…it will be difficult to apply styles easily, due to CSS specificity creeping in:</p><div><pre class="programlisting">.module &gt; h2 {
  /* normal styles */
}
.unique {
  /* I'm going to lose this specificity battle */
}
.module .unique {
  /* I'll work, but specificity creep! */
}</pre></div></li><li class="listitem" style="list-style-type: disc">To avoid this, using as <a id="id125" class="indexterm"/>flat a structure as possible is recommended—it will be worth the extra effort required to set it up:<div><pre class="programlisting">&lt;div class="module"&gt;
  &lt;h2 class="module-header"&gt;
  &lt;/h2&gt;
  &lt;div class="module-content"&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div></li><li class="listitem" style="list-style-type: disc">Consider using an established pattern library, or atomic design (such as the one at <a class="ulink" href="http://patternlab.io/">http://patternlab.io/</a>), to help guide you through how a site should be built—they are likely to be built using minimal CSS specificity, and with hopefully little need to override existing code.</li><li class="listitem" style="list-style-type: disc">Be careful if you decide to use cascading when applying CSS styles—if we apply a base style to an element (or class) that is reused multiple times, this will cause issues. To avoid this, try to avoid using cascading if it isn't really needed; consider limiting it to 2-3 levels only, to reduce risk of odd or unexpected styles being applied.</li><li class="listitem" style="list-style-type: disc">Sometimes code is outside of your control—in instances such as this, we have to work with it; we can either try using low specificity selectors where possible, or use the <code class="literal">!important</code> keyword to override the code. For now, we may have to leave comments in the code to explain why the selectors are set as such; in an ideal world, we would try to contact the authors to see if they can update or alter the code to remove these issues.</li><li class="listitem" style="list-style-type: disc">As a last resort, if you <a id="id126" class="indexterm"/>must get into the realms of CSS specificity, then try to only apply a light touch, and not take the sledgehammer approach, such as using a selector ID or <code class="literal">!important</code>.<p>We can try applying a single class to an existing tag, but this may not feel right for some; an alternative is to use two classes:</p><div><pre class="programlisting">.nav .override {
}
.override .override {
}
.nav {
}</pre></div><p>The key here, though, is to not use more than one additional class!</p></li><li class="listitem" style="list-style-type: disc">Nesting styles can lead to writing overly specific selectors in our code—some developers discourage its use for this reason, even though nesting can help make our code visually easier to read and digest. Instead of using compound selectors, we can emulate a form of name-spacing by using the ampersand symbol:<div><pre class="programlisting">.somestyle {
    color: darkred;
   &amp;-so {
      color: blue;
      &amp;-ever {
        color: green;
      }
   }
}</pre></div><p>…which will compile to this:</p><div><pre class="programlisting">.somestyle { color: darkred; }
. somestyle-so { color: blue; }
.somestyle-so-ever { color: green; }</pre></div></li><li class="listitem" style="list-style-type: disc">If your style is overriding a style that is already an override—stop: Why are you doing this? Overriding a class or selector element can be an efficient way of styling, but applying a second override will only cause confusion.</li></ul></div><p>We've seen a number of ways of avoiding, or reducing CSS specificity issues that are inherent with nesting; the key <a id="id127" class="indexterm"/>message, though, is that we are not forced to have to nest our code, and that, to paraphrase the front-end architect Roy Tomeij—nested code doesn't create bad code; bad coders do!</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>You can see the original article by Roy Tomeij at <a class="ulink" href="http://www.thesassway.com/editorial/sass-doesnt-create-bad-code-bad-coders-do">http://www.thesassway.com/editorial/sass-doesnt-create-bad-code-bad-coders-do</a>
</p></div></div><p>There is one method, though, that we've not touched on, and for good reason: it's a route many developers new to using processing will likely take for the first time. Intrigued? It has something to do with using conversion tools, and more specifically, how we use them to convert from plain CSS to code suitable for compiling using PostCSS.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Reconsidering our code</h2></div></div></div><p>Imagine this <a id="id128" class="indexterm"/>scenario, if you will:</p><p>You've taken over a website, and are keen to make use of PostCSS to help with maintaining your code. The code uses plain vanilla CSS, so as a step to converting it, you happen to know of a number of sites that will convert plain CSS to SASS. After all, there are some similarities between PostCSS and SASS code, so why not?</p><p>You extract the results into a text file, save it, and put it through a SASS compilation process. Out comes some newly compiled CSS, which you drop into the relevant location on your server, and voilà! You have a working site that now uses SASS. A working site, and a perfect basis for converting to PostCSS…or is it?</p><p>The short answer should be no, but the longer one is that it will depend on your code. Let me explain why:</p><p>Simply pushing code through a conversion process isn't enough—granted, it will give you code that works, but unless it is very simple, it is likely <strong>not to give code that is concise and efficient</strong>. To see what I mean, take a close look at the CSS style sheet from <code class="literal">Tutorial5</code>—and specifically, the style rules for <code class="literal">.nav-panel</code>, from around line 132.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>For reasons of space, the style sheet is too long to print in full—I would recommend taking a look at the file from the code download in a text editor!</p></div></div><p>A conversion process will have no problem processing it to produce valid SASS, but it won't look pretty—as an example, try copying lines 114 to 197 into the converter hosted at <a class="ulink" href="http://css2sass.herokuapp.com/">http://css2sass.herokuapp.com/</a>. Doesn't look great, does it? There is definitely room for improvement—I've already made some changes to the code, but we can do more; let's take a look at what <a id="id129" class="indexterm"/>can be done to improve the code.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Updating our code</h2></div></div></div><p>When using a CSS to <a id="id130" class="indexterm"/>SASS convertor, the one key point that should always be at the back of our minds is that the converted code should <strong>not</strong> be considered the final article.</p><p>It doesn't matter how simple or complex your code is—it should be the first step in our conversion process. It's just a matter of how little or how much we have to do, once the code has been through the converter! As an example, take a look at this block of code:</p><div><img src="img/BO5194_03_06.jpg" alt="Updating our code"/></div><p>It's a direct copy of lines 234 to 239 of the compiled version of the pen by Nikolay, which we used as a basis for our earlier demos. Now take a quick look at the equivalent code that I tweaked from the original and used in my version:</p><div><img src="img/BO5194_03_07.jpg" alt="Updating our code"/></div><p>Notice any differences? The vendor prefix version of the <code class="literal">transform</code> attribute has been stripped out—most modern browsers (certainly within the last year to eighteen months), should handle this code without the need for vendor prefixes. The original version also suffered from a high degree of CSS specificity—this will become even more apparent if the code is nested!</p><p>To improve it, I've switched in <code class="literal">.nav-panel ul li</code> as a direct replacement for <code class="literal">.nav-panel ul .nav-btn</code>—the code is relatively simple in that it does not need a second class to identify elements for styling purposes. The next logical step is to break up the large nesting block within the source file; it is tempting to include a single large block, but this will be at the expense of readability, maintenance, and performance.</p><p>We could potentially go even further, and consider removing the leading <code class="literal">.nav-panel</code>; not only will it make the <a id="id131" class="indexterm"/>code infinitely easier to read, but it will also reduce the issues around CSS specificity. Of course, this kind of change will depend on what is in your code; the point here is to examine your code thoroughly, and look to reduce any CSS specificity as much as possible, so that your nesting won't look so bad!</p><p>There is an alternative means we can use though, which removes issues around CSS specificity—using <strong>Block Element Modifier</strong> notation (or <strong>BEM</strong> for short). It's a great way to systematically style elements using CSS, and it is worth taking time to get accustomed to how it works. Let's dive in and take a look.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Making the switch to BEM</h1></div></div></div><p>So what is BEM, and why can it help with reducing or removing CSS specificity issues?</p><p>
<strong>BEM</strong>, or <strong>Block Element Modifier</strong>, helps us style elements using a systematic naming convention, which is <a id="id132" class="indexterm"/>structured thus:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">.block</code>: top-level containing the element we're going to change</li><li class="listitem" style="list-style-type: disc"><code class="literal">.block__modifier</code>: the style assigned when the state of an element is changed</li><li class="listitem" style="list-style-type: disc"><code class="literal">.block__element</code>: an element inside a top-level container</li><li class="listitem" style="list-style-type: disc"><code class="literal">.block__element__modifier</code>: alternate representation of an element, when its state has been changed</li></ul></div><p>The idea behind this style of coding is to make it portable and easier to maintain. The basis for this is that, while standard, non-BEM CSS is more concise, it is harder to infer what each rule does. We frequently have to assign multiple classes to an element, which introduces a degree of CSS specificity, and reduces the reusability of CSS rules. Using BEM allows us to combine the constituent names into one style class name, and remove any concern around CSS specificity.</p><p>If we use this concept, we can use it to write style rules such as this:</p><div><pre class="programlisting">.block {
  &amp;__element {
  }
  &amp;__modifier {
  }
}</pre></div><p>This will compile to the following:</p><div><pre class="programlisting">.block {}
.block__element {}
.block__modifier {}</pre></div><p>The preceding code uses plain BEM format, but from within a processor environment such as SASS to construct <a id="id133" class="indexterm"/>BEM rules in PostCSS, we can use the <code class="literal">postcss-bem</code> plugin (available from <a class="ulink" href="https://github.com/ileri/postcss-bem">https://github.com/ileri/postcss-bem</a>) to produce our BEM CSS using <code class="literal">@-rules</code>. For example:</p><div><pre class="programlisting">@component ComponentName {
  color: cyan;
 
  @modifier modifierName {
    color: purple;
  }
 
  @descendent descendentName {
    color: darkred;
  }
 
  @when stateName {
    color: yellow;
  }
}</pre></div><p>In this instance, <code class="literal">@component</code> signifies our Block, <code class="literal">@descendant</code> our element, and <code class="literal">@modifier</code> is our modifier. When compiled, our CSS would look like this:</p><div><pre class="programlisting">.ComponentName {
  color: cyan;
}
 
.ComponentName--modifierName {
  color: purple;
}
 
.ComponentName-descendentName {
  color: darkred;
}
 
.ComponentName.is-stateName {
  color: yellow;
}</pre></div><p>The beauty of using BEM is that it helps to reduce or even avoid CSS specificity issues—although names are longer, we can combine both element and modifier names into one class, instead of having to apply three or more separate classes. Granted, there may be instances where we might <a id="id134" class="indexterm"/>have to apply a second class, but with careful planning we should be able to reduce this to a minimum.</p><p>Right, onwards we go: let's get stuck in to coding! Over the next few pages, we will take a look at implementing BEM styling in a simple demo, and see how we can use PostCSS to compile our code.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Creating simple message boxes</h2></div></div></div><p>For our <a id="id135" class="indexterm"/>BEM demo, we're going to work through the CSS rules required to show some simple message boxes on screen, such as for displaying confirmation that a task has completed, or a warning when something isn't right.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>The original version of this demo, by Rene Spronk, is available from <a class="ulink" href="http://www.cssportal.com/blog/css-notification-boxes/">http://www.cssportal.com/blog/css-notification-boxes/</a>.</p></div></div><p>It's a simple demo, but shows off the principles behind BEM CSS perfectly—go ahead and extract a copy of the <code class="literal">Tutorial8</code> folder, then run <code class="literal">index.html</code> to get a feel for what we will be producing. This version uses standard CSS; we will use this as a basis for converting to using BEM.</p><p>Let's make a start:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll begin by extracting a copy of the <code class="literal">Tutorial9</code> folder from the code download that accompanies this book—drop this into our project area.</li><li class="listitem">Next, in a new file, add the following CSS statements starting at line 1, and leaving a one-line gap between each—they should be fairly self-explanatory, but we will go through each block in turn.</li><li class="listitem">We kick off with the core styles for each dialog—this is a basis style for each dialog box:<div><pre class="programlisting">.dlgBox {
  border-radius: 0.625rem;
  padding: 0.625rem 0.625rem 0.625rem 2.375rem;
  margin: 0.625rem;
  width: 14.5rem
}</pre></div></li><li class="listitem">Next up comes a simple style for each <code class="literal">&lt;span&gt;</code> element—this turns the lead-in caption for each dialog to uppercase and sets it in bold text:<div><pre class="programlisting">span { font-weight: bold;text-transform: uppercase; }</pre></div></li><li class="listitem">We now need to add our block element—it's the opening line that forms the basis for our styling:<div><pre class="programlisting">@component content {</pre></div></li><li class="listitem">Next up <a id="id136" class="indexterm"/>comes the Element part of our style rule. These rules need to be added as nested (that is, indented) rules immediately underneath—using the PostCSS plugin, we add it in as a <code class="literal">@descendent</code> of our <code class="literal">@component</code>:<div><pre class="programlisting">   @descendent alert {
     font-family: Tahoma, Geneva, Arial, sans-serif;
     font-size: 0.6875rem;
     color: #555;
     border-radius: 0.625rem; 
   }</pre></div></li><li class="listitem">Up next comes the first of our status messages—we kick off with styling the Error message first; the main rule adds an error icon and styles the border. The <code class="literal">:hover</code> pseudo-element reduces the opacity when we hover over the box:<div><pre class="programlisting">   @modifier error {
     background: #ffecec url("../img/error.png") no-repeat 0.625rem 50%;
     border: 0.0625rem solid #f5aca6; 
   }

      @modifier error:hover { opacity: 0.8; }</pre></div></li><li class="listitem">This is swiftly followed by styling for the Success message:<div><pre class="programlisting">   @modifier success {
     background: #e9ffd9 url("../img/success.png") no-repeat 0.625rem 50%;
     border: 0.0625rem solid #a6ca8a; 
   }

   @modifier success:hover { opacity: 0.8; }</pre></div></li><li class="listitem">We can't forget the obligatory Warning message, so here's the style rule for that status:<div><pre class="programlisting">   @modifier warning {
     background: #fff8c4 url("../img/warning.png") no-repeat 0.625rem 50%;
     border: 0.0625rem solid #f2c779; 
      }

      @modifier warning:hover { opacity: 0.8; }</pre></div></li><li class="listitem">Last but <a id="id137" class="indexterm"/>by no means least, here's the final one, which is Notice; it includes the closing bracket for the BEM nesting:<div><pre class="programlisting">      @modifier notice {
        background: #e3f7fc url("../img/info.png") no-repeat 0.625rem 50%;
        border: 0.0625rem solid #8ed9f6; 
      }

   @modifier notice:hover { opacity: 0.8; }
}</pre></div></li><li class="listitem">Save the file as <code class="literal">style.scss</code> into the <code class="literal">src</code> folder of our top-level project area (and not into the <code class="literal">Tutorial8</code> folder!).</li></ol></div><p>Our simple demo isn't going to set the world alight in terms of styling. If we were to preview it now, the results will of course not look great; let's fix that by setting up the compilation and linting tasks within PostCSS.</p><div><div><h3 class="title"><a id="note21"/>Note</h3><p>If you are a SASS user, then you can see a version of this code suitable for that processor on GitHub—the code is available at: <a class="ulink" href="https://gist.github.com/alibby251/45eab822a6a619467279">https://gist.github.com/alibby251/45eab822a6a619467279</a>. Note how similar the results are when you compare the compiled version with the version we'll get in the next exercise!</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Compiling and linting our code</h2></div></div></div><p>Our code is in place, but <a id="id138" class="indexterm"/>the boxes won't look particularly <a id="id139" class="indexterm"/>appetizing—most of the styles are still written using PostCSS <code class="literal">@-rules</code>. We can fix that by compiling the code, so let's dive in and take a look at installing support for BEM.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Installing BEM support</h2></div></div></div><p>Setting up <a id="id140" class="indexterm"/>BEM support in PostCSS is a cinch—we can make use of two plugins to compile and lint our code. The plugins we need for this task are <code class="literal">postcss-bem</code> (available from <a class="ulink" href="https://github.com/ileri/postcss-bem">https://github.com/ileri/postcss-bem</a>), and <code class="literal">postcss-bem-linter</code> (available from <a class="ulink" href="https://github.com/postcss/postcss-bem-linter">https://github.com/postcss/postcss-bem-linter</a>). Both can be installed using the same process through Node.js.</p><p>Hopefully the process will be familiar by now, so without further ado, let's make a start:</p><div><ol class="orderedlist arabic"><li class="listitem">We'll begin by firing up a Node.js command prompt, and navigating to our working folder.</li><li class="listitem">At the command prompt, enter this command then press <em>Enter</em>:<div><pre class="programlisting"><strong>npm install --save-dev postcss-bem</strong>
</pre></div></li><li class="listitem">Node.js will install each of the elements required; if all is well, we should see this result, to indicate a successful installation:<div><img src="img/BO5194_03_08.jpg" alt="Installing BEM support"/></div></li><li class="listitem">Repeat the <a id="id141" class="indexterm"/>same process for <code class="literal">postcss-bem-linter</code>, using this command:<div><pre class="programlisting"><strong>npm install --save-dev postcss-bem-linter</strong>
</pre></div><div><img src="img/BO5194_03_09.jpg" alt="Installing BEM support"/></div></li><li class="listitem">Keep the command prompt session open, but minimized. We're going to make use of it again in a moment!</li></ol></div><p>Now that the plugin is installed, we can go ahead and add support to our gulp task file, and begin to parse our code:</p><div><ol class="orderedlist arabic"><li class="listitem">First, go ahead and remove the existing <code class="literal">gulpfile.js</code> file at the root of our project area.</li><li class="listitem">In a new file, add the following lines and save it as <code class="literal">gulpfile.js</code>, at the root of our project area. We start with setting a number of variables that call each of the plugins:<div><pre class="programlisting">var gulp = require('gulp');
var postcss = require('gulp-postcss');
var bem = require('postcss-bem');
var bemLinter = require('postcss-bem-linter');
var reporter = require('postcss-reporter');</pre></div></li><li class="listitem">The first <a id="id142" class="indexterm"/>task in the file checks the code for consistency with BEM standards, and displays any errors on-screen:<div><pre class="programlisting">gulp.task('lint', function() {
  return gulp.src('dest/*.css')
    .pipe(postcss([
      bemLinter({ preset: 'bem' }),
      reporter({ clearMessages: true })
    ]))
    .pipe(gulp.dest('dest/'));
});</pre></div></li><li class="listitem">The second task in the file compiles the BEM code to valid CSS:<div><pre class="programlisting">gulp.task('bem', function() {
  return gulp.src("src/*.css")
    .pipe(postcss([bem({
      style: 'bem',
      separators: { descendent: '__' }
    })]))
    .pipe(gulp.dest('dest/'));
});</pre></div></li><li class="listitem">This task is the default that is called when we run gulp from the command line; it calls each of the tasks in turn:<div><pre class="programlisting">gulp.task('default', ['bem', 'lint']);</pre></div></li><li class="listitem">We finish the <code class="literal">gulpfile.js</code> with a watch facility, to kick in and compile our code when any changes are made to it:<div><pre class="programlisting">var watcher = gulp.watch('src/*.css', ['default']);
watcher.on('change', function(event) {
  console.log('File ' + event.path + ' was ' + event.type + ', running tasks...');
});</pre></div></li><li class="listitem">We're going to replace the <code class="literal">package.json</code> file too—add these lines to a new file, and save it to the root of the project area. These simply tell gulp which versions of our plugins to use when compiling the code:<div><pre class="programlisting">{
  "name": "postcss",
  "version": "1.0.0",
  "description": "Configuration file for PostCSS",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"
  },
  "author": "Alex Libby",
  "license": "ISC",
  "devDependencies": {
    "gulp": "^3.9.0",
    "gulp-postcss": "^6.0.0",
    "postcss-bem-linter": "^2.0.0",
    "postcss-reporter": "^1.3.0"
  }
}</pre></div></li><li class="listitem">From the <a id="id143" class="indexterm"/>code download that accompanies this book, go ahead and extract a copy of <code class="literal">style.css</code> from the <code class="literal">css – completed version</code> folder under <code class="literal">Tutorial9</code>—save this to the <code class="literal">src</code> folder under our project area.</li><li class="listitem">Revert back to the Node.js command prompt session we had before, then at the prompt, enter this command and press <em>Enter</em>:<div><pre class="programlisting"><strong>gulp</strong>
</pre></div></li><li class="listitem">If all is well, the code will be checked, and the results displayed on screen. You may see errors appear, such as those shown in this screenshot. If they do, they can be ignored for now (we will explore this in more detail later):<div><img src="img/BO5194_03_10.jpg" alt="Installing BEM support"/></div></li><li class="listitem">Go ahead and copy the contents of the <code class="literal">dest</code> folder into the <code class="literal">css</code> folder underneath <code class="literal">Tutorial9</code>—if all is well, we should see something akin to this screenshot when previewing the results in a browser:<div><img src="img/BO5194_03_11.jpg" alt="Installing BEM support"/></div></li></ol></div><p>Our simple demo shows some useful message boxes that we can use as a basis for something more complex; it illustrates perfectly how we can use BEM to style our code, while keeping <a id="id144" class="indexterm"/>issues around CSS specificity at bay. We've covered a few useful techniques throughout this exercise, so let's take a moment to explore them in more detail.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Exploring our changes in more detail</h1></div></div></div><p>It is worth <a id="id145" class="indexterm"/>taking time to really get familiar with BEM styling principles. This is one of those areas where not spending time can easily dissuade you from using this technique; the principles are easy to understand but can take time to implement! Let's take a look at our code in more detail.</p><p>The key principle around BEM, when using the PostCSS plugin, is that of nesting—in this instance, we create our core component content, which results in an empty style rule at the top of our style sheet. Indented to the next level is our <code class="literal">@descendant</code>—this indicates that our message boxes are being styled as alerts. We then use a number of <code class="literal">@modifiers</code> to style each type of alert, such as success, warning, error, or notice (that is, information). This includes a separate style rule to cover each instance of the hover pseudo-element used in our code.</p><p>What does this mean for us? It means we have to not just consider each element (for instance, a message box) as a single entity to which we simply apply lots of classes; instead, we should consider the constituent parts of each element and apply a single class to each. Hold on, does that not mean we still have three classes in use (as we might have here)?</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>To learn more about BEM naming conventions, take a look at the useful article posted at <a class="ulink" href="https://en.bem.info/tools/bem/bem-naming/">https://en.bem.info/tools/bem/bem-naming/</a>.</p></div></div><p>Well, the answer is yes, and no: the trick here is that PostCSS will combine each nested style into valid <a id="id146" class="indexterm"/>CSS; for example, this extract (adapted from our demo):</p><div><pre class="programlisting">@component content {
  @descendent alert {
    font-family: Tahoma, Geneva, Arial, sans-serif;
    font-size: 0.6875rem;
    color: #555;
    border-radius: 0.625rem; 

    @modifier error {
      background: #ffecec url("../img/error.png") no-repeat 0.625rem 50%;
      border: 0.0625rem solid #f5aca6; 
    }
  }
}</pre></div><p>When compiled, this will appear as this CSS:</p><div><pre class="programlisting">.content {}
.content__alert {
    font-family: Tahoma, Geneva, Arial, sans-serif;
    font-size: 0.6875rem;
    color: #555;
    border-radius: 0.625rem;
}
.content__alert_error {
    background: #ffecec url("../img/error.png") no-repeat 0.625rem 50%;
    border: 0.0625rem solid #f5aca6;
}</pre></div><p>The sharp-eyed among you will have spotted that we still have errors being generated when our code is compiled:</p><div><img src="img/BO5194_03_12.jpg" alt="Exploring our changes in more detail"/></div><p>It's always disconcerting to see errors, but there are valid reasons for them. We can safely ignore the two <a id="id147" class="indexterm"/>deprecation warnings (these should be fixed in a future version), but the two errors are of more concern.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Fixing our errors</h2></div></div></div><p>The two errors are <a id="id148" class="indexterm"/>being caused by <code class="literal">postcss-bem-linter</code>, which is not recognizing the two styles as valid BEM notation. This raises a question: can we alter our code to remove the issues?</p><p>To answer this, we would need to weigh up how much code is affected against the time and effort required to alter it. In our demo, there is very little code affected; to resolve it, we would need to alter the <code class="literal">.dlgBox</code> and <code class="literal">span</code> styles to equivalent BEM naming.</p><p>Is this worth the effort? In a small demo such as ours, it is likely that the answer is no, for a larger demo, we would look to alter these two styles. Instead, we can add a simple directive at line 48, thus:</p><div><img src="img/BO5194_03_13.jpg" alt="Fixing our errors"/></div><p>When the code is recompiled, the errors are removed:</p><div><img src="img/BO5194_03_14.jpg" alt="Fixing our errors"/></div><p>Purists may say this is cheating. It's true, our code is still <em>technically</em> not all BEM. In defense though, it's <a id="id149" class="indexterm"/>up to each developer to make that decision; there may be elements that have to remain as standard CSS, which we can't convert. In this case, it may be sensible to import these styles using the PostCSS import plugin—we will explore using this more in <a class="link" href="ch10.html" title="Chapter 10. Building a Custom Processor">Chapter 10</a>, <em>Building a Custom Preprocessor</em>.</p><p>It's worth noting that the <code class="literal">postcss-bem-linter plugin</code> will not display the results of any errors by itself—for this, we need to use a plugin such as <code class="literal">postcss-reporter</code> (available at <a class="ulink" href="https://github.com/postcss/postcss-reporter">https://github.com/postcss/postcss-reporter</a>, for command line), or postcss-browser-reporter (from <a class="ulink" href="https://github.com/postcss/postcss-browser-reporter">https://github.com/postcss/postcss-browser-reporter</a>, displays content in the browser window). Both have a number of options that are worth investigating to help fine-tune what is displayed when the code is processed through PostCSS.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Summary</h1></div></div></div><p>Over the years, developers have had to frequently write code that duplicates all or part of a selector—a perfect example is styling lists or navigation items. It's a real pain to have to write so much extra code; instead we can use nesting principles to help remove some of this code. We've covered a number of techniques around nesting in PostCSS throughout this chapter, so let's take a moment to review what we've learned.</p><p>We kicked off with an introduction to nesting, to help bring us up to speed, before launching into using the <code class="literal">postcss-nesting</code> plugin to create nested styles within PostCSS. We then moved on to creating our nesting demo. We began with preparing a plain vanilla CSS version, before taking a look at converting to existing processors such as SASS.</p><p>Moving on, we then took a look at converting our code using the <code class="literal">postcss-nesting</code> plugin, before exploring some of the pitfalls that are associated with nesting, and some of the tips and tricks we can use to reduce CSS specificity, one of the key issues associated with nesting.</p><p>We then rounded out the chapter with a look at BEM, and how it can be used in PostCSS. We covered some of the basic principles of this methodology, before applying it to a simple example. We also learned why it won't always work for every instance; for those where it is suitable, we took a brief look at how we can set PostCSS to automatically lint our BEM code.</p><p>Phew, a real whistle stop tour there! Hang on to your hats though, as it won't stop: in our next chapter, we're going to take a look at writing media queries, and how PostCSS can help with compiling them into valid CSS.</p></div></body></html>