<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer035">
<h1 class="chapter-number" id="_idParaDest-28"><a id="_idTextAnchor036"/>2</h1>
<h1 id="_idParaDest-29"><a id="_idTextAnchor037"/>Defining and Using Sequelize Models </h1>
<p>For our <em class="italic">Avalon Airlines</em> project that we introduced in the previous chapter, we will need to instruct our application on how we want to define our database’s schematics. A database can have various roles and applications but only a single purpose, and that purpose is to organize our data (storage is the filesystem’s job). Before we can begin defining our models within the Node.js application, we need to think about the entities of our business logic and models from a project’s perspective (and each project will have different requirements). Most projects will structure their schema in a way that categorizes <em class="italic">organizations</em> (for example, customers, employees, vendors, and companies) and <em class="italic">things</em> such as products, planes, and receipts from transactions.</p>
<p> <strong class="bold">Object-relational mapping</strong> (<strong class="bold">ORM</strong>) helps us ensure that the database is organized from the <a id="_idIndexMarker101"/>data and team’s perspective. Sequelize will help us manage the nomenclature for our project (for example, whether to define tables using a <strong class="source-inline">snake_case</strong> or with a <strong class="source-inline">PascalCase</strong> pattern). Relations—or associations—between models will be automatically created and managed by Sequelize. Business logic workflows can also be established so that you do not have to remember workflows such as <em class="italic">removing the customer’s boarding pass if they canceled their trip</em>. That part would be handled in one organized place versus invoking <strong class="source-inline">RemoveBoardingPass(...)</strong> in every code section that cancels a trip (regardless of whether the method was called from the customer, an employee, and so on). This chapter will teach you how to define and synchronize your models with a database and how to apply the data to a Node.js runtime application using Sequelize. This will be the initial foundation on how to operate Sequelize.</p>
<p>This chapter will introduce you to the following concepts:</p>
<ul>
<li>Defining models for a database</li>
<li>Exploring the various Sequelize data types and when to use them</li>
<li>Migrating schematic changes and data from Sequelize to the database</li>
<li>Manipulating and querying data using Sequelize</li>
<li>Advanced Sequelize options for defining models</li>
</ul>
<h1 id="_idParaDest-30"><a id="_idTextAnchor038"/>Technical requirements</h1>
<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch2">https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch2</a></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor039"/>Defining models for a database</h1>
<p>In this section, we will go over a brief overview of our project’s requirements and establish <a id="_idIndexMarker102"/>which kinds of models we need to define. After that, we will run a script generator command from the Sequelize <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) tool and <a id="_idIndexMarker103"/>inspect the basic structure of a model’s definition. </p>
<p>For <em class="italic">Avalon Airlines</em>, we will begin modeling with the following <em class="italic">organizations</em> and <em class="italic">things</em>:</p>
<ul>
<li>Airplanes</li>
<li>Customers</li>
<li>Flight schedules</li>
<li>Boarding tickets</li>
</ul>
<p>Each model will have its own table within the database. We will eventually associate these models or tables with columns, indices, validation, and relations to other models. For now, we will define, select (or query), insert, update, and delete data from these tables using Sequelize within our Node.js application. If you are working on a pre-existing project that already has a database, the <em class="italic">Manipulating and querying data using Sequelize</em> section will pertain to you more than to someone starting on a project from a clean slate. </p>
<p>We will first generate our models with the minimum requirements for columns using the Sequelize CLI tool. Then, we will go over the code that was generated by the CLI so that you are more familiar with how to define Sequelize models without depending on the CLI. Generate the previously mentioned models with the following commands within the project’s root directory:</p>
<p class="source-code">sequelize model:generate --name Airplane --attributes planeModel:string,totalSeats:integer</p>
<p class="source-code">sequelize model:generate --name Customer --attributes name:string,email:string</p>
<p class="source-code">sequelize model:generate --name FlightSchedule --attributes originAirport:string,destinationAirport:string,departureTime:date</p>
<p class="source-code">sequelize model:generate --name BoardingTicket --attributes seat:string</p>
<p>You may <a id="_idIndexMarker104"/>have noticed we used a singular noun for our models’ names. Sequelize will automatically pluralize the associated table and models for us. You can disable this behavior via Sequelize configuration settings, which will be discussed in detail further in this chapter. For our <strong class="source-inline">BoardingTickets</strong> model, we will generate associations of a customer and flight schedules in the next chapter, but for now, we can build the bare minimum for the table.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Sequelize comes with some useful utility functions available to the developer. The framework <a id="_idIndexMarker105"/>uses a library called <strong class="bold">Inflection</strong>, which comes with a set of string manipulation functions. Sequelize exposes underscore, singularize, and pluralize functions directly from <strong class="source-inline">Sequelize</strong>.</p>
<p>Opening the <strong class="source-inline">models/flightschedule.js</strong> file, we should see the following generated code:</p>
<pre class="source-code">
'use strict';
const {
  Model
} = require('@sequelize/core');
module.exports = (sequelize, DataTypes) =&gt; {
  class FlightSchedule extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method
       automatically.
     */
    static associate(models) {
      // define association here
    }
  };
  FlightSchedule.init({
    originAirport: DataTypes.STRING,
    destinationAirport: DataTypes.STRING,
    departureTime: DataTypes.DATE
  }, {
    sequelize,
    modelName: 'FlightSchedule',
  });
  return FlightSchedule;
};</pre>
<p>The <strong class="source-inline">'use strict';</strong> line in <a id="_idIndexMarker106"/>the preceding code snippet will tell our Node.js runtime to execute the JavaScript file (<strong class="source-inline">models/flightschedule.js</strong>) with a <a id="_idIndexMarker107"/>set of rules to help alleviate <strong class="bold">sloppy mode</strong>. <strong class="bold">Strict mode</strong> will prohibit <a id="_idIndexMarker108"/>the developer from assigning values to undeclared variables, using reserved keywords as defined by <strong class="bold">ECMAScript 2015</strong> (<strong class="bold">ES6</strong>), and <a id="_idIndexMarker109"/>so on. This mode is completely optional for the contents of this book; however, if you wish to learn more, Mozilla offers a helpful <a id="_idIndexMarker110"/>guide on the differences between strict and sloppy mode here: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode</a>.</p>
<p>The next set of instructions is to import the <strong class="source-inline">Model</strong> class from Sequelize, which we will use to initialize the model in the next few commands. The <strong class="source-inline">module.exports</strong> line that follows is a pattern that the Sequelize model loader (the <strong class="source-inline">models/index.js</strong> file) can interpret <a id="_idIndexMarker111"/>and how to invoke the file. The first argument provides an instance of Sequelize to us with all of the parameters and configuration settings that we established from the <strong class="source-inline">models/index.js</strong> file. The second parameter, <strong class="source-inline">DataTypes</strong>, provides a more ergonomic way of declaring the various data types for our columns (for example, instead of having to type out <strong class="source-inline">sequelize.DataTypes.STRING</strong>, we can omit the <strong class="source-inline">sequelize.</strong> instance prefix and just use <strong class="source-inline">DataTypes.STRING</strong>).</p>
<p>Next, we define our <strong class="source-inline">FlightSchedule</strong> class and extend Sequelize’s <strong class="source-inline">Model</strong> class. Here, we can define our associations, hooks/events, table information, and so on. The CLI will generate a <a id="_idIndexMarker112"/>static function for us called <strong class="bold">associations</strong>. For now, we can leave this function as is; we will modify it later throughout the book. </p>
<p>The last instruction within this file takes our <strong class="source-inline">FlightSchedule</strong> class and invokes the <strong class="source-inline">init()</strong> function, which will set up internal rules and instructions to help Sequelize navigate the model’s definition. This is also where Sequelize learns how to synchronize the model with the database, as shown in the following screenshot. If you were to set Sequelize’s <a id="_idIndexMarker113"/>option to <strong class="source-inline">sync: true</strong>, there would be additional <strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong>) commands executed such as <strong class="source-inline">DROP TABLE IF EXISTS</strong> for when we want to test our application on a clean slate every runtime. Having the sync option set to <strong class="source-inline">true</strong> is useful for unit tests and early prototype development. It is <em class="italic">not</em> recommended to set this option to <strong class="source-inline">true</strong> within a production environment:</p>
<div>
<div class="IMG---Figure" id="_idContainer031">
<img alt="Figure 2.1 – Sequelize’s automatic synchronization " height="369" src="image/Figure_2.1_B17841.jpg" width="935"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Sequelize’s automatic synchronization</p>
<p class="callout-heading">Note</p>
<p class="callout">Running our Node.js application and letting Sequelize synchronize our database is fine for the initial implementation phase, but we will go over the methodology of using Sequelize’s CLI and migrations to perform the necessary SQL commands to synchronize the database. Migrations offer incremental changes/updates as opposed to the Sequelize synchronize option, which is more of a generic solution. </p>
<p>The first <a id="_idIndexMarker114"/>parameter of the <strong class="source-inline">init()</strong> function is where we define our model’s attributes (or columns). The pattern for this is typically an object with the keys as column names and the value for each key is either a DataType, a literal string value, or an object containing advanced options for each column. From this example, we are shown three columns (<strong class="source-inline">originAirport</strong>, <strong class="source-inline">destinationAirport</strong>, and <strong class="source-inline">departureTime</strong>) with <strong class="source-inline">string</strong>, <strong class="source-inline">string</strong>, and <strong class="source-inline">date</strong> data types respectively. </p>
<p>The second parameter lets us define instance type settings for the model explicitly. This is where we can define a different table name, choose whether to pluralize our tables, disable meta columns (such as <strong class="source-inline">createdAt</strong> and <strong class="source-inline">updatedAt</strong>), and so on. We will go into details about these options later in this chapter.</p>
<p>If you prefer to not use classes in your project, there is another way to define our models. The following code snippet provides an example of using Sequelize’s <strong class="source-inline">define()</strong> function:</p>
<pre class="source-code">
module.exports = (sequelize, DataTypes) =&gt; {
    return sequelize.define('FlightSchedule', {
        originAirport: DataTypes.STRING,
        destinationAirport: DataTypes.STRING,
        departureTime: DataTypes.DATE
    }, {
        sequelize,
    });
};</pre>
<p>The parameters remain relatively the same as <strong class="source-inline">init()</strong> except that the first parameter is now the model’s name. Either way is acceptable and one does not provide advantages over the <a id="_idIndexMarker115"/>other from Sequelize’s point of view. This book will use the former example throughout its code base (the <strong class="source-inline">Model</strong> class), but for advanced configuration settings and adding associations, this book will illustrate both styles as there are some fundamental differences, ergonomically speaking. For programmers who favor using TypeScript over JavaScript, the <strong class="source-inline">Model</strong> class method may provide a more native experience to you.</p>
<p>Now that we have an understanding of how models are defined in Sequelize, we can go over which built-in attribute data types Sequelize has to offer, along with a brief explanation to help guide your future model designs. </p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor040"/>Exploring the various Sequelize data types and when to use them</h1>
<p>As <a id="_idIndexMarker116"/>explained earlier, Sequelize offers us various data types <a id="_idIndexMarker117"/>to help map our model’s attributes to their respective <strong class="bold">database management system</strong> (<strong class="bold">DBMS</strong>) column types. Next is a list of what Sequelize has to offer, along with a brief explanation.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor041"/>STRING</h2>
<p>The <strong class="source-inline">STRING</strong> data type <a id="_idIndexMarker118"/>refers to a <strong class="bold">Variable Character Field</strong> (<strong class="bold">VARCHAR</strong>) column <a id="_idIndexMarker119"/>type, which <a id="_idIndexMarker120"/>is a non-fixed character column. The maximum storage for this column type varies depending on the DBMS. <strong class="source-inline">VARCHAR</strong> fields usually contain meta information to help optimize the DBMS’ query planner. MySQL explicitly adds another byte to the column’s prefix header if the size of the string is greater than 255 bytes. A query <a id="_idIndexMarker121"/>planner could use this information to help alleviate pressure from memory, or the <strong class="bold">central processing unit</strong> (<strong class="bold">CPU</strong>), when retrieving/collecting/analyzing the data. To call <strong class="source-inline">VARCHAR</strong> with a fixed paging length, you would define the column as <strong class="source-inline">DataTypes.STRING(100)</strong> instead of <strong class="source-inline">DataTypes.STRING</strong>. </p>
<p>Within a <strong class="source-inline">VARCHAR</strong> column type, the DBMS will not store the value as a fixed length (no padding is required). If you need data to be retrieved in the exact same way it was stored, you could use the <strong class="source-inline">VARCHAR BINARY</strong> column type. This can be achieved by declaring the column’s data type as <strong class="source-inline">DataTypes.STRING.BINARY</strong>. </p>
<p>Despite having the word “binary” in the data type’s name, for storing movies, pictures, and so on, it is often recommended to use the <strong class="source-inline">BLOB</strong> type over <strong class="source-inline">VARCHAR BINARY</strong>. The binary part of <strong class="source-inline">VARCHAR BINARY</strong> performs comparisons over the binary representation of that <a id="_idIndexMarker122"/>column versus a <strong class="bold">character set</strong> (<strong class="bold">charset</strong>).</p>
<p>For instance, suppose <a id="_idIndexMarker123"/>we had the following rows <a id="_idIndexMarker124"/>in a database: <strong class="source-inline">A</strong>, <strong class="source-inline">a</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">b</strong>. The <strong class="source-inline">VARCHAR</strong> column type would have an internal map to tell the database that “A” and “a” will be listed prior to “B” and “b”. In a <strong class="source-inline">VARCHAR BINARY</strong> column, the sum binary representation of <strong class="source-inline">A</strong>, <strong class="source-inline">a</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">b</strong> would be <strong class="source-inline">0</strong>, <strong class="source-inline">2</strong>, <strong class="source-inline">1</strong>, <strong class="source-inline">3</strong>, which would sort into the following: <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, <strong class="source-inline">a</strong>, <strong class="source-inline">b</strong>. There is no internal map/charset for <strong class="source-inline">VARCHAR BINARY</strong> columns, so the database would not be able to tell that “A” and “a” are actually the same letter. </p>
<p>For the most part, we could use <strong class="source-inline">VARCHAR BINARY</strong> and <strong class="source-inline">BLOB</strong> interchangeably in MySQL versions above 5.0.2. There are some small subtle differences, as indicated here:</p>
<ul>
<li>An index prefix length must be specified for <strong class="source-inline">BLOB</strong> indexes</li>
<li><strong class="source-inline">BLOB</strong> column types cannot have default values</li>
</ul>
<h2 id="_idParaDest-34"><a id="_idTextAnchor042"/>CHAR</h2>
<p>The <strong class="source-inline">CHAR</strong> data type <a id="_idIndexMarker125"/>is similar to the <strong class="source-inline">STRING</strong> data type, except that it <a id="_idIndexMarker126"/>references the <strong class="source-inline">CHAR</strong> column type. Traditionally, a DBMS will cap the length of a <strong class="source-inline">CHAR</strong> column to 255 characters. A <strong class="source-inline">VARCHAR</strong> type will allow you to go over the specified paging size without an error or an exception. A <strong class="source-inline">CHAR</strong> column could be used as a last-resort effort for validating your data and ensuring it does not exceed the specified length (for example, <strong class="source-inline">CHAR(20)</strong> would cap the data to 20 characters defined by the table’s collation). <strong class="source-inline">CHAR</strong> column types are padded <a id="_idIndexMarker127"/>to their fixed length, which could help <a id="_idIndexMarker128"/>optimize the DBMS—or even your application—presuming that the pre-determined length is appropriate for the scenario’s paging size.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor043"/>TEXT/TINYTEXT/MEDIUMTEXT/LONGTEXT</h2>
<p>Database <a id="_idIndexMarker129"/>designers <a id="_idIndexMarker130"/>understand <a id="_idIndexMarker131"/>that sometimes, our <a id="_idIndexMarker132"/>text data requires <a id="_idIndexMarker133"/>a considerable amount of space or needs <a id="_idIndexMarker134"/>to be associated with rows larger than 65,535 bytes (a MySQL <strong class="source-inline">VARCHAR</strong> limitation). In this case, we would use a <strong class="source-inline">TEXT</strong> column <a id="_idIndexMarker135"/>type. Every DBMS has its nuances <a id="_idIndexMarker136"/>and limitations; since this book uses MySQL, we will briefly go over MySQL’s <strong class="source-inline">TEXT</strong> limitations, as follows: </p>
<ul>
<li><strong class="source-inline">TINYTEXT</strong>: 255 bytes </li>
<li><strong class="source-inline">TEXT</strong>: 64 <strong class="bold">kilobytes</strong> (<strong class="bold">KB</strong>) </li>
<li><strong class="source-inline">MEDIUMTEXT</strong>: 16 <strong class="bold">megabytes</strong> (<strong class="bold">MB</strong>)</li>
<li><strong class="source-inline">LONGTEXT</strong>: 4 <strong class="bold">gigabytes</strong> (<strong class="bold">GB</strong>)</li>
</ul>
<p><strong class="source-inline">DataTypes.TEXT</strong> will default to the <strong class="source-inline">TEXT</strong> column type, and if you wanted to declare your column type as <strong class="source-inline">TINYTEXT</strong>, <strong class="source-inline">MEDIUMTEXT</strong>, or <strong class="source-inline">LONGTEXT</strong>, you would use <strong class="source-inline">DataTypes.TEXT('TINY')</strong>, <strong class="source-inline">DataTypes.TEXT('MEDIUM')</strong>, or <strong class="source-inline">DataTypes.TEXT('LONG')</strong>, respectively. Unlike the <strong class="source-inline">VARCHAR</strong> type, there is no <strong class="source-inline">BINARY</strong> option for <strong class="source-inline">TEXT</strong> column types. For storing serialized binary types, you would use <strong class="source-inline">VARCHAR BINARY</strong> or <strong class="source-inline">BLOB</strong> instead. </p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor044"/>CITEXT</h2>
<p><strong class="bold">CITEXT</strong> stands for <strong class="bold">Case-Insensitive Text</strong>, which <a id="_idIndexMarker137"/>is a column <a id="_idIndexMarker138"/>that preserves the data’s casing <a id="_idIndexMarker139"/>except for comparison operations. This option is available for Postgres and SQLite databases only. </p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor045"/>NUMBER</h2>
<p>Not to <a id="_idIndexMarker140"/>be confused with Postgres’ <strong class="source-inline">NUMERIC</strong> type, the <strong class="source-inline">NUMBER</strong> data type is an abstraction for more than an explicit type, depending <a id="_idIndexMarker141"/>on its configuration settings. This data type should <em class="italic">not</em> be used directly unless you are extending/adding your own numeric data type. This abstract data type could help organize your code if you use the same precision and scale values throughout your database, or if your online store sells a product in different denominations and currencies.</p>
<p>The following code snippet provides an example of how you would extend your own numeric data type:</p>
<pre class="source-code">
<strong class="bold">// INT(4)</strong>
var unsignedInteger = DataTypes.NUMBER({
    length: 4,
    zerofill: false,
    unsigned: true,
});
<strong class="bold">// FLOAT(5,4)</strong>
var specificFloat = DataTypes.NUMBER({
    length: 5,
    zerofill: false,
    unsigned: false,
    decimals: 4
});
<strong class="bold">// DECIMAL(6,4)</strong>
var specificPrecision = DataTypes.NUMBER({
    zerofill: false,
    unsigned: false,
    precision: 6,
    scale: 4
});</pre>
<h2 id="_idParaDest-38"><a id="_idTextAnchor046"/>INTEGER/TINYINT/SMALLINT/MEDIUMINT/BIGINT</h2>
<p>With <strong class="source-inline">DataTypes.INTEGER</strong>, <strong class="source-inline">DataTypes.SMALLINT</strong>, and so on, we can associate our <a id="_idIndexMarker142"/>attributes with the respective column <a id="_idIndexMarker143"/>types. You can find references for minimum <a id="_idIndexMarker144"/>and maximum values for each <a id="_idIndexMarker145"/>integer type with MySQL here: <a href="https://dev.mysql.com/doc/refman/5.7/en/integer-types.xhtml">https://dev.mysql.com/doc/refman/5.7/en/integer-types.xhtml</a>. To <a id="_idIndexMarker146"/>declare your model’s attribute as an unsigned value, we can attach the <strong class="source-inline">UNSIGNED</strong> option <a id="_idIndexMarker147"/>to our data type, like so:</p>
<pre class="source-code">
DataTypes.INTEGER(21).UNSIGNED</pre>
<p>If <a id="_idIndexMarker148"/>we wanted <a id="_idIndexMarker149"/>to have our attribute unsigned <a id="_idIndexMarker150"/>and zero-filled, we <a id="_idIndexMarker151"/>can chain <a id="_idIndexMarker152"/>the data-type options, as follows:</p>
<pre class="source-code">
DataTypes.INTEGER(21).UNSIGNED.ZEROFILL</pre>
<p class="callout-heading">Note</p>
<p class="callout">Depending on which DBMS you use, the <strong class="source-inline">ZEROFILL</strong> option may not be available to you. If you are using a Postgres database, then the order of assigning those attributes is important (<strong class="source-inline">UNSIGNED</strong> must be declared before <strong class="source-inline">ZEROFILL</strong>). In MySQL, the <strong class="source-inline">ZEROFILL</strong> option will also imply <strong class="source-inline">UNSIGNED</strong> automatically. The <strong class="source-inline">ZEROFILL</strong> attribute will only affect the data from an aesthetics perspective (when you select data) and will not modify your data in storage.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor047"/>FLOAT/REAL</h2>
<p>Traditionally, a DBMS will differentiate between <strong class="source-inline">FLOAT</strong> and <strong class="source-inline">REAL</strong> column types by their <a id="_idIndexMarker153"/>bit precisions. <strong class="source-inline">FLOAT</strong> columns are usually stored with 32-bit precision, and <strong class="source-inline">REAL</strong> column <a id="_idIndexMarker154"/>types are stored with 64-bit precision. <strong class="bold">Microsoft SQL Server</strong> (<strong class="bold">MSSQL</strong>) is <a id="_idIndexMarker155"/>the inverse of this, where <strong class="source-inline">REAL</strong> column types are 64-bit and <strong class="source-inline">FLOAT</strong> columns are 32-bit. To make <a id="_idIndexMarker156"/>things even more confusing, MySQL will treat <strong class="source-inline">REAL</strong> as the <a id="_idIndexMarker157"/>same as a <strong class="source-inline">DOUBLE</strong> (also known as <strong class="source-inline">DOUBLE PRECISION</strong> and <strong class="source-inline">DECIMAL</strong>) column.</p>
<p>Internally, Sequelize <a id="_idIndexMarker158"/>handles <strong class="source-inline">FLOAT</strong>, <strong class="source-inline">REAL</strong>, and <strong class="source-inline">DOUBLE</strong> in the <a id="_idIndexMarker159"/>same way. There is a small float validation performed for the <strong class="source-inline">FLOAT</strong> type explicitly, but otherwise, Sequelize will translate the column type directly to the DBMS. Just as with the integer data types, <strong class="source-inline">UNSIGNED</strong> and <strong class="source-inline">ZEROFILL</strong> can be defined on these attributes as well, as follows:</p>
<pre class="source-code">
DataTypes.FLOAT.UNSIGNED.ZEROFILL</pre>
<h2 id="_idParaDest-40"><a id="_idTextAnchor048"/>DECIMAL/DOUBLE</h2>
<p>The <strong class="source-inline">DECIMAL</strong> or <strong class="source-inline">DOUBLE</strong> data <a id="_idIndexMarker160"/>type allows <a id="_idIndexMarker161"/>us to define a precise length and scale for our columns using the traditional format of <strong class="source-inline">DECIMAL(P, S</strong>) where <strong class="source-inline">P</strong> &gt; <strong class="source-inline">S</strong>. The <strong class="source-inline">P</strong> variable <a id="_idIndexMarker162"/>is the number’s precision and the <strong class="source-inline">S</strong> variable is the number’s <a id="_idIndexMarker163"/>scale. The precision determines the maximal length of the whole number part, and the scale defines the maximal length of the decimal part. For example, <strong class="source-inline">DataTypes.DECIMAL(6, 4</strong>) will give us a decimal column with a precision of 6 and a scale of 4. An example value for this column could be <strong class="source-inline">38.3411</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may use <strong class="source-inline">DataTypes.NUMERIC</strong> as an alias for <strong class="source-inline">DataTypes.DECIMAL</strong>.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor049"/>BOOLEAN</h2>
<p>There are <a id="_idIndexMarker164"/>many ways <a id="_idIndexMarker165"/>to express a <strong class="bold">Boolean</strong>. Some applications prefer <a id="_idIndexMarker166"/>to use numerical values (or as a single bit) of 0 for <strong class="source-inline">false</strong> and 1 for <strong class="source-inline">true</strong>. Sometimes, the Boolean value will be stored as a string such as <strong class="source-inline">true</strong>, <strong class="source-inline">false</strong>, <strong class="source-inline">t</strong>, or <strong class="source-inline">f</strong>. Sequelize will automatically handle numerical—or bit—values, as well as the “<strong class="source-inline">true</strong>” or “<strong class="source-inline">false</strong>” string expressions as appropriate Boolean values for Node.js. If the value is marked as “<strong class="source-inline">t</strong>” or “<strong class="source-inline">f</strong>”, then Sequelize will pass the raw value along to the programmer to handle (as a way to avoid being over presumptuous—this behavior may change in the future). A Boolean column can be defined with just <strong class="source-inline">DataTypes.BOOLEAN</strong>. There are no arguments or inputs to process for this data type.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor050"/>DATE/DATEONLY/TIME</h2>
<p>The <strong class="source-inline">DATE</strong> data <a id="_idIndexMarker167"/>type references the <strong class="source-inline">DATETIME</strong> column <a id="_idIndexMarker168"/>types for MySQL, MariaDB, and <a id="_idIndexMarker169"/>SQLite. For Postgres, the <strong class="source-inline">DATE</strong> data type <a id="_idIndexMarker170"/>will be translated as <strong class="source-inline">TIMESTAMP WITH TIME ZONE</strong>. </p>
<p>In MySQL, you <a id="_idIndexMarker171"/>can define fractional seconds for <strong class="source-inline">DATETIME</strong> columns <a id="_idIndexMarker172"/>by up to six digits, like so:</p>
<pre class="source-code">
DataTypes.DATE(6)</pre>
<p>If you wish to keep just the date or time, you may use <strong class="source-inline">DataTypes.DATEONLY</strong> or <strong class="source-inline">DataTypes.TIME</strong>, respectively.</p>
<p class="callout-heading">Quick note on Postgres without time zones</p>
<p class="callout">If you are using Postgres with a column type of <strong class="source-inline">TIMESTAMP WITHOUT TIME ZONE</strong>, and you know the data’s time differentiates that from the server that is running the application, it is recommended to set the time zone’s offset. This can be achieved via the <strong class="source-inline">pg</strong> Node.js library, as illustrated here:</p>
<p class="callout"><strong class="source-inline">var types = require('pg').types</strong></p>
<p class="callout"><strong class="source-inline">function setTimestampWithoutTimezoneOffset(val) {</strong></p>
<p class="callout"><strong class="source-inline">    // '+0000' being the UTC offset, change this to the desired time zone</strong></p>
<p class="callout"><strong class="source-inline">    return val === null ? null : new Date(stringValue + '+0000');</strong></p>
<p class="callout"><strong class="source-inline">}</strong></p>
<p class="callout"><strong class="source-inline">types.setTypeParser(types.builtins.TIMESTAMP, setTimestampWithoutTimezoneOffset);</strong></p>
<p class="callout">For <a id="_idIndexMarker173"/>more <a id="_idIndexMarker174"/>information <a id="_idIndexMarker175"/>on setting <a id="_idIndexMarker176"/>types <a id="_idIndexMarker177"/>for Postgres within Node.js, refer <a id="_idIndexMarker178"/>to the following link: <a href="https://github.com/brianc/node-pg-types">https://github.com/brianc/node-pg-types</a></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor051"/>NOW</h2>
<p><strong class="source-inline">DataTypes.NOW</strong> is a special <a id="_idIndexMarker179"/>type within Sequelize. It is not to be used <a id="_idIndexMarker180"/>as the column’s type but as the attribute’s value and is traditionally set as the attribute’s <strong class="source-inline">defaultValue</strong> option. If we wanted a <strong class="source-inline">Receipt</strong> model that kept track of when a transaction was made, it would look similar to this:</p>
<pre class="source-code">
Receipt.init({
    total: DataTypes.DECIMAL(10,2),
    tax: DataTypes.DECIMAL(10,2),
    dateOfPurchase: {
        type: DataTypes.DATE,
        defaultValue: DataTypes.NOW
    }
}, {
    sequelize,
    modelName: 'Receipt'
});</pre>
<p>Whenever <a id="_idIndexMarker181"/>we insert a <strong class="source-inline">Receipt</strong> record, Sequelize will automatically <a id="_idIndexMarker182"/>convert the <strong class="source-inline">dateOfPurchase</strong> attribute’s value to the DBMS’ <strong class="source-inline">NOW()</strong> function from the attribute’s <strong class="source-inline">defaultValue</strong> option using Sequelize’s <strong class="source-inline">DataTypes.NOW</strong> data type. If we have defined a value for the attribute initially, then Sequelize will use that value instead.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor052"/>HSTORE</h2>
<p><strong class="source-inline">HSTORE</strong> is for <a id="_idIndexMarker183"/>Postgres only. This data type is used for mapped key-value types but is often <a id="_idIndexMarker184"/>replaced by <strong class="source-inline">JSON</strong> or <strong class="bold">JSON Binary</strong> (<strong class="bold">JSONB</strong>). If your project requires the use of <strong class="source-inline">HSTORE</strong>, there is a caveat to keep <a id="_idIndexMarker185"/>in mind, which is to install the <strong class="source-inline">pg-hstore</strong> Node.js library. The full installation command would look like this:</p>
<p class="source-code">npm install --save sequelize pg pg-hstore</p>
<p>For selecting data, in Sequelize, your <strong class="source-inline">where</strong> clause would be an object instead of an integer, string, and so on. An example would look like this:</p>
<pre class="source-code">
MyModel.find({
  where: {
    myHstoreColumn: {
      someFieldKey: 'value',
    }
  }
});</pre>
<h2 id="_idParaDest-45"><a id="_idTextAnchor053"/>JSON</h2>
<p>The <strong class="source-inline">JSON</strong> data type <a id="_idIndexMarker186"/>is available for SQLite, MariaDB, MySQL, and Postgres. When defining an attribute with the <strong class="source-inline">JSON</strong> type, you can query <a id="_idIndexMarker187"/>information similar to how the <strong class="source-inline">HSTORE</strong> type is queried, with the exception of having the ability to deeply nest your search clause. Let us say we had the following <strong class="source-inline">JSON</strong> data type stored in a column:</p>
<pre class="source-code">
{
    "someKey": {
        "deeply": {
            "nested": true
        }
    }
}</pre>
<p>We would search for the nested value like so:</p>
<pre class="source-code">
MyModel.find({
    where: {
        myJsonColumn: {
            someKey: { deeply: { nested: true } }
        }
    }
});</pre>
<p>Please <a id="_idIndexMarker188"/>note that MySQL and MariaDB introduced support for <strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) fields in MySQL 5.7.8 and MariaDB 10.2.7 respectively. For former versions, you can define models with situations where the <strong class="source-inline">DataTypes.JSON</strong> attribute type will not be compatible with your database. To resolve this issue, you can define models with getters/setters that will store and retrieve the JSON document, like so:</p>
<pre class="source-code">
sequelize.define('MyModel', {
    myJsonColumn: {
        type: DataTypes.TEXT,
        get: function () {
            return JSON.parse(this.getDataValue('value'));
        },
        set: function (val) {
            this.setDataValue('value',JSON.stringify(val));
        }
    }
});</pre>
<p class="callout-heading">Note</p>
<p class="callout">For <a id="_idIndexMarker189"/>users of MSSQL 2016 and above, please refer to <a href="https://sequelize.org/master/manual/other-data-types.xhtml#mssql">https://sequelize.org/master/manual/other-data-types.xhtml#mssql</a> as a workaround for handling JSON column types with this DBMS.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor054"/>JSONB</h2>
<p>The <strong class="source-inline">JSONB</strong> data type <a id="_idIndexMarker190"/>is reserved for Postgres only. If you are using a JSON <a id="_idIndexMarker191"/>column for storage, it is recommended to use the <strong class="source-inline">JSON</strong> column type, and if you are using comparison operators on the column, it is recommended to use the <strong class="source-inline">JSONB</strong> column type.</p>
<p>Other than the previously mentioned way of querying JSON data, you can also query JSONB data types with the following formats:</p>
<pre class="source-code">
<strong class="bold">// String matching</strong>
MyModel.find({
  where: {
    "someKey.deeply.nested": {
      [Op.eq]: true
    }
  }
});
<strong class="bold">// Using the Op.contains operator</strong>
MyModel.find({
  where: {
    someKey: {
      [Op.contains]: {
        deeply: {
          nested: true
        }
      }
    }
  }
});</pre>
<h2 id="_idParaDest-47"><a id="_idTextAnchor055"/>BLOB</h2>
<p>Several <a id="_idIndexMarker192"/>databases, including MySQL, offer a range <a id="_idIndexMarker193"/>of <strong class="bold">binary large object</strong> (<strong class="bold">BLOB</strong>) types. Regardless <a id="_idIndexMarker194"/>of the input for the <strong class="source-inline">BLOB</strong> attribute type, Postgres will always be converted into a <strong class="source-inline">bytea</strong> (byte array) column type. This data type is useful for storing anything binary-related, such as images, documents, or serialized data. You can see an example of it in use here:</p>
<pre class="source-code">
DataTypes.BLOB // BLOB
DataTypes.BLOB('tiny') // TINYBLOB
DataTypes.BLOB('medium') // MEDIUMBLOB
DataTypes.BLOB('long') // LONGBLOB</pre>
<p>Here is <a id="_idIndexMarker195"/>a table of different <strong class="source-inline">BLOB</strong> types with their <a id="_idIndexMarker196"/>byte prefix length and their maximum storage length for MySQL:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>BLOB Type</p>
</td>
<td class="No-Table-Style">
<p>Byte Prefix Length</p>
</td>
<td class="No-Table-Style">
<p>Maximum Storage (in bytes)</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>TINYBLOB</p>
</td>
<td class="No-Table-Style">
<p>1 byte</p>
</td>
<td class="No-Table-Style">
<p>2^8 - 1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>BLOB</p>
</td>
<td class="No-Table-Style">
<p>2 bytes</p>
</td>
<td class="No-Table-Style">
<p>2^16 - 1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>MEDIUMBLOB</p>
</td>
<td class="No-Table-Style">
<p>3 bytes</p>
</td>
<td class="No-Table-Style">
<p>2^24-1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>LONGBLOB</p>
</td>
<td class="No-Table-Style">
<p>4 bytes</p>
</td>
<td class="No-Table-Style">
<p>2^32 - 1</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">RANGE</p>
<p><strong class="source-inline">RANGE</strong> data types <a id="_idIndexMarker197"/>are reserved for Postgres only. Supported range <a id="_idIndexMarker198"/>types are <strong class="source-inline">INTEGER</strong>, <strong class="source-inline">BIGINT</strong>, <strong class="source-inline">DATE</strong>, <strong class="source-inline">DATEONLY</strong>, and <strong class="source-inline">DECIMAL</strong>. You may define an attribute with the range type like so:</p>
<pre class="source-code">
var MyModel = sequelize.define('MyModel', {
    myRangeColumn: DataTypes.RANGE(DataTypes.INTEGER)
});</pre>
<p>There are a couple of ways to create ranges for our models, as illustrated here:</p>
<pre class="source-code">
// inclusive boundaries are the default for Sequelize
   var inclusiveRange = [10, 20];
MyModel.create({ myRangeColumn: inclusiveRange });
// inclusion may be toggled with a parameter
   var range = [
    { value: 10, inclusive: false },
    { value: 20, inclusive: true }
];
MyModel.create({ myRangeColumn: range });</pre>
<p>When <a id="_idIndexMarker199"/>querying a range column, the data for that attribute will always <a id="_idIndexMarker200"/>return in object notation with the <strong class="source-inline">value</strong> and <strong class="source-inline">inclusive</strong> keys.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor056"/>UUID/UUIDV1/UUIDV4</h2>
<p>A <strong class="bold">universally unique identifier</strong> (<strong class="bold">UUID</strong>) is <a id="_idIndexMarker201"/>a 128-bit <a id="_idIndexMarker202"/>label with some sort of constraints <a id="_idIndexMarker203"/>and stipulations for uniqueness and <a id="_idIndexMarker204"/>near to no chance of a collision with other <a id="_idIndexMarker205"/>values. The <strong class="source-inline">UUIDV1</strong>/<strong class="source-inline">UUIDV4</strong> data types work in conjunction <a id="_idIndexMarker206"/>with the <strong class="source-inline">UUID</strong> attribute type. We can declare a model <a id="_idIndexMarker207"/>that has <a id="_idIndexMarker208"/>a default <strong class="source-inline">UUIDV4</strong> value <a id="_idIndexMarker209"/>as its <strong class="bold">primary key</strong> (<strong class="bold">PK</strong>) like so:</p>
<pre class="source-code">
sequelize.define('MyModel', {
    id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        allowNull: false,
        primaryKey: true
    }
});</pre>
<h2 id="_idParaDest-49"><a id="_idTextAnchor057"/>VIRTUAL</h2>
<p>The <strong class="source-inline">VIRTUAL</strong> attribute <a id="_idIndexMarker210"/>type is a special type that will hydrate the <a id="_idIndexMarker211"/>data within Sequelize but will not populate the data into the database. The <strong class="source-inline">VIRTUAL</strong> field could be used for organizing code, validations, and extending Sequelize to any protocol or framework that requires <a id="_idIndexMarker212"/>nested typing (for example, GraphQL, <strong class="bold">Protocol Buffers</strong> (<strong class="bold">Protobuf</strong>), and so on), which is covered in <a href="B17841_09.xhtml#_idTextAnchor177"><em class="italic">Chapter 9</em></a>, <em class="italic">Using and Creating Adapters</em>.</p>
<p>We can define a <strong class="source-inline">VIRTUAL</strong> attribute like so:</p>
<pre class="source-code">
sequelize.define('MyModel', {
    envelope: DataTypes.STRING,
    message: {
        type: DataTypes.VIRTUAL,
        set: function(val) {
            // the following line is optional
            // but required if you wish to use the
               validation associated with the attribute
            this.setDataValue('message', val);
            this.setDataValue('envelope', 
                               encryptTheMessage(val));
        },
        validate: {
            noDadJokes: function(val) {
                if (val === "knock knock") {
                    throw new Error("Who is there? Not this 
                                     message")
                }
            }
        }
    }
});</pre>
<p>For <a id="_idIndexMarker213"/>retrieving <strong class="source-inline">VIRTUAL</strong> attributes, we would <a id="_idIndexMarker214"/>need to define a data type as a parameter for the <strong class="source-inline">DataTypes.VIRTUAL</strong> invocation. If we want to pass through other attributes within our <strong class="source-inline">VIRTUAL</strong> attribute, we would define a list as the second parameter. An example is shown here:</p>
<pre class="source-code">
sequelize.define('MyModel', {
    envelope: DataTypes.STRING,
    message: {
        type: DataTypes.VIRTUAL(DataTypes.STRING, ['en
        velope']),
        get: function() {
            return decryptTheMessage(this.get('envelope'));
        },
        set: function(val) {
            this.setDataValue('envelope', 
                               encryptTheMessage(val));
        }
    }
});</pre>
<h2 id="_idParaDest-50"><a id="_idTextAnchor058"/>ENUM</h2>
<p>Sequelize <a id="_idIndexMarker215"/>has a <strong class="source-inline">DataTypes.ENUM</strong> attribute type for enumerated <a id="_idIndexMarker216"/>columns. At the moment, only Postgres has this feature enabled. A solution for other database engines would be to define a custom validation rule for your model that performs some sort of inclusion operator. Custom <a id="_idIndexMarker217"/>validations for our models will be discussed in the next chapter. There <a id="_idIndexMarker218"/>are three different ways of defining enumerated attributes, as illustrated here:</p>
<pre class="source-code">
// Defining enums with function arguments
DataTypes.ENUM('a', 'b')
// Defining enums with an array argument
DataTypes.ENUM(['a', 'b'])
// Defining enums with an object argument
DataTypes.ENUM({
    values: ['a', 'b']
})</pre>
<h2 id="_idParaDest-51"><a id="_idTextAnchor059"/>ARRAY</h2>
<p><strong class="source-inline">ARRAY</strong> attribute <a id="_idIndexMarker219"/>types are supported for Postgres <a id="_idIndexMarker220"/>only at the moment. This type requires a parameter of an applicable data type. You can see an example here:</p>
<pre class="source-code">
DataTypes.ARRAY(DataTypes.STRING) // text[]
DataTypes.ARRAY(DataTypes.DECIMAL) // double precision[]</pre>
<h2 id="_idParaDest-52"><a id="_idTextAnchor060"/>GEOMETRY</h2>
<p>Sequelize <a id="_idIndexMarker221"/>can handle geometric data for MariaDB, MySQL, and <a id="_idIndexMarker222"/>Postgres (as long as the PostGIS extension <a id="_idIndexMarker223"/>is enabled). The <strong class="bold">GeoJSON</strong> specification (<a href="https://tools.ietf.org/html/rfc7946">https://tools.ietf.org/html/rfc7946</a>) can be useful for querying geometric data for an airline business. For example, we can mark the coordinates of an airport and the current location of an airplane to determine the estimated time of arrival without manually memorizing <a id="_idIndexMarker224"/>the Haversine algorithm (a formula to determine the <a id="_idIndexMarker225"/>distance between two points on a sphere). Reference examples can be found in the following code snippet:</p>
<pre class="source-code">
var MyModel = sequelize.define('MyModel', {
    point: DataTypes.GEOMETRY('POINT'),
    polygon: DataTypes.GEOMETRY('POLYGON')
});
var point = {
    type: 'Point',
    coordinates: [44.386815, -82.755759]
}
var polygon = { type: 'Polygon', coordinates: [
    [
        [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
        [100.0, 1.0], [100.0, 0.0]
    ]
]};
await MyModel.create({ point, polygon });</pre>
<p>In the preceding snippet, we first define our model with two attributes (<strong class="source-inline">point</strong> and <strong class="source-inline">polygon</strong>) with the <a id="_idIndexMarker226"/>respective geometry data types (for a complete list, you may reference the <strong class="bold">Request for Comments</strong> (<strong class="bold">RFC</strong>) manual previously mentioned). Then, we create our geometric objects with a set of defined values (a point will accept two coordinates, and a polygon can accept N coordinates). The last line will create an entry with the defined values for the corresponding attribute.</p>
<p class="callout-heading">Note</p>
<p class="callout">GeoJSON is <a id="_idIndexMarker227"/>handled differently depending on whether we are using the Postgres or MariaDB/MySQL dialect. The Postgres dialect will call the <strong class="source-inline">ST_GeomFromGeoJSON</strong> function for interpretation of GeoJSON, and MariaDB/MySQL will use the <strong class="source-inline">GeomFromText</strong> function. The following reference goes into detail on spatial columns with MySQL: <a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-types.xhtml">https://dev.mysql.com/doc/refman/5.7/en/spatial-types.xhtml</a>.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor061"/>GEOGRAPHY</h2>
<p>For MariaDB/MySQL, the <strong class="source-inline">GEOGRAPHY</strong> attribute type will work the same as the <strong class="source-inline">GEOMETRY</strong> type, but <a id="_idIndexMarker228"/>for Postgres, Sequelize will utilize PostGIS’ geography <a id="_idIndexMarker229"/>data type. The <strong class="source-inline">GEOGRAPHY</strong> attribute type follows the same GeoJSON syntax as the <strong class="source-inline">GEOMETRY</strong> type.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you are looking for a complete set of utility functions and querying complex relationships between several coordinates, then the <strong class="source-inline">GEOMETRY</strong> type is recommended over the <strong class="source-inline">GEOGRAPHY</strong> type. If you need to use geodetic measurements instead of Cartesian measurements, or if you have simpler relationships over large areas, then the <strong class="source-inline">GEOGRAPHY</strong> type would be more applicable to you. </p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor062"/>CIDR/INET/MACADDR</h2>
<p>These <a id="_idIndexMarker230"/>three <a id="_idIndexMarker231"/>attribute <a id="_idIndexMarker232"/>types are for Postgres only. All <a id="_idIndexMarker233"/>of these <a id="_idIndexMarker234"/>types perform some type of <a id="_idIndexMarker235"/>internal validation respective to the type. These types do not have an input parameter. The following are brief explanations, with references, for each of these data types:</p>
<ul>
<li><strong class="source-inline">CIDR</strong>—This stands for <strong class="bold">Classless Inter-Domain Routing</strong> and <a id="_idIndexMarker236"/>is used for <a id="_idIndexMarker237"/>allocating <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) addresses and route tables (<a href="https://datatracker.ietf.org/doc/html/rfc4632">https://datatracker.ietf.org/doc/html/rfc4632</a>)</li>
<li><strong class="source-inline">INET</strong>—Common ways of identifying over the net (<a href="https://datatracker.ietf.org/doc/html/rfc6991">https://datatracker.ietf.org/doc/html/rfc6991</a>)</li>
<li><strong class="source-inline">MACADDR</strong>—<strong class="bold">Unique identifiers</strong> (<strong class="bold">UIDs</strong>) for <a id="_idIndexMarker238"/>network interfaces (<a href="https://www.rfc-editor.org/rfc/rfc7042.xhtml">https://www.rfc-editor.org/rfc/rfc7042.xhtml</a>)</li>
</ul>
<h2 id="_idParaDest-55"><a id="_idTextAnchor063"/>TSVECTOR</h2>
<p>The <strong class="source-inline">TSVECTOR</strong> data type <a id="_idIndexMarker239"/>is used for searching through text columns with <a id="_idIndexMarker240"/>advanced operators available in Postgres’ <strong class="source-inline">to_tsquery()</strong> function. These operators include wildcard matching, negate matching, and Boolean search. This attribute type is for Postgres only and will only accept string variables for values. When querying a <strong class="source-inline">TSVECTOR</strong> attribute, Sequelize will not interpret the attribute type with its associated functions implicitly (for example, <strong class="source-inline">to_tsvector</strong>). Let’s suppose we have the following model definition:</p>
<pre class="source-code">
var MyModel = sequelize.define('MyModel', {
    col: DataTypes.TSVECTOR
});
MyModel.create({
    col: 'The quick brown fox jumps over the lazy dog'
});</pre>
<p>Then, we want to query a value on the <strong class="source-inline">col</strong> field, like so:</p>
<pre class="source-code">
MyModel.find({
    where: { col: 'fox' }
});</pre>
<p>The generated SQL would look similar to this:</p>
<pre class="source-code">
SELECT * FROM MyModel WHERE col = 'fox';</pre>
<p>Sequelize will interpret this query with an equals operator for the <strong class="source-inline">where</strong> clause. In order to take advantage of the <strong class="source-inline">TSVECTOR</strong> column type, we would have to be explicit with our intentions, like so:</p>
<pre class="source-code">
MyModel.find({
    where: {
        col: {
            [Op.match]: sequelize.fn('to_tsvector', 'fox')
        }
    }
});</pre>
<p>This will <a id="_idIndexMarker241"/>convert the <strong class="source-inline">where</strong> clause’s operator from equal to matching (<strong class="source-inline">@@</strong>). The <strong class="source-inline">sequelize.fn</strong> method allows you to explicitly invoke a function from <a id="_idIndexMarker242"/>your DBMS. The query generated by this procedure would look like this:</p>
<pre class="source-code">
SELECT * FROM MyModel WHERE col @@ to_tsvector('fox');</pre>
<p>After learning how to define our model and which data types are available to us in Sequelize, we can now begin migrating our definitions to an actual database. Sequelize offers a migration subcommand within its command-line tool, to make this easy for us. </p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor064"/>Migrating schematic changes and data from Sequelize to the database</h1>
<p>We have <a id="_idIndexMarker243"/>defined our database’s <a id="_idIndexMarker244"/>schema with <a id="_idIndexMarker245"/>the generated files from the command-line tool, and we are now ready to migrate those definitions to our DBMS. Using Sequelize’s migrations can help teams of developers maintain the same schema structure across multiple machines. Migrations can provide a historical reference as to how your database has changed over time, which can also help us undo certain changes and revert our database’s schema to a specific time.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor065"/>Migrating schematic changes</h2>
<p>The Sequelize CLI provides a convenient way of propagating updates toward a database. All of our <a id="_idIndexMarker246"/>schematic changes will be located within the <strong class="source-inline">migrations</strong> directory, and all of our data seeds will be located within the <strong class="source-inline">seeders</strong> directory. This chapter will cover only the initialization of the database’s structure. In subsequent chapters, there will be examples of adding and removing columns (or indices) using the migration tool.</p>
<p>In the <em class="italic">Defining models for a database</em> section, we used the Sequelize CLI to generate our models, which should have created several files in the <strong class="source-inline">migrations</strong> directory. Each file is prefixed with <a id="_idIndexMarker247"/>a timestamp, a <strong class="bold">call to action</strong> (<strong class="bold">CTA</strong>) (for example, <strong class="source-inline">create</strong>), and the model’s name. An example for one of the files (<strong class="source-inline">20210914153156-create-airplane.js</strong>) would look like this:</p>
<pre class="source-code">
'use strict';
module.exports = {
  up: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.createTable('Airplanes', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      planeModel: {
        type: Sequelize.STRING
      },
      totalSeats: {
        type: Sequelize.INTEGER
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },
  down: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.dropTable('Airplanes');
  }
};</pre>
<p>Sequelize will <a id="_idIndexMarker248"/>use the scope of the <strong class="source-inline">up(…)</strong> method when we invoke the <strong class="source-inline">migrations</strong> subcommand. The <strong class="source-inline">down(…)</strong> method is reserved for when we decide <a id="_idIndexMarker249"/>to undo, or revert, a migration. The <strong class="bold">query interface</strong> is a database-agnostic adapter that executes generic SQL commands that are available to all supported database engines. We will go into detail about the query interface in a later chapter.</p>
<p>You may have noticed that Sequelize has added several columns to our model’s definition. With the default settings, Sequelize will generate three additional columns, as follows:</p>
<ul>
<li><strong class="source-inline">id</strong>—A PK as an integer value with <strong class="source-inline">autoIncrement</strong> set to <strong class="source-inline">true</strong>. The <strong class="source-inline">autoIncrement</strong> flag will create a sequence value (some databases, such as MySQL, will call sequences <em class="italic">auto-increment</em> columns).</li>
<li><strong class="source-inline">createdAt</strong>—This field will generate a timestamp upon the row’s creation. Since this is a Sequelize-recognized column, the default value for this column does not require us to explicitly state <strong class="source-inline">DataTypes.NOW</strong> or any equivalent value. Sequelize will hydrate the row’s value automatically when using applicable methods such as <strong class="source-inline">create()</strong>.</li>
<li><strong class="source-inline">updatedAt</strong>—Similar to the <strong class="source-inline">createdAt</strong> field, except this value will update automatically from Sequelize every time the row is updated.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">We can prevent Sequelize from creating these attributes automatically through configuration settings. These settings will be explained in detail later in this chapter.</p>
<p>In the <a id="_idIndexMarker250"/>root directory of our project, run the following command to initialize migrations:</p>
<p class="source-code">sequelize db:migrate</p>
<p>This command will perform several more instructions than iterating through the <strong class="source-inline">migrations</strong> directory. Sequelize will first look for a table called <strong class="source-inline">SequelizeMeta</strong> that holds meta information on which files have already been processed through the <strong class="source-inline">migrations</strong> subcommand. After the table has been found or created, Sequelize will iterate through the <strong class="source-inline">migrations</strong> table in sequential order of the file’s name (timestamps are a convenient way of maintaining this order) and skip any files found within the <strong class="source-inline">SequelizeMeta</strong> table. </p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">sequelize-cli</strong> <strong class="source-inline">db:migrate</strong> and <strong class="source-inline">db:seed</strong> commands will use the <strong class="source-inline">NODE_ENV</strong> environmental variable to determine where to migrate/initialize data to. As an alternative, you can state which database to connect to with the <strong class="source-inline">--url</strong> option, like so: <strong class="source-inline">sequelize db:migrate --url 'mysql://user:password@host.com/database'</strong>.</p>
<p>If we made a mistake on a model’s definition, after migration, we always have the option to revert our changes, like so:</p>
<p class="source-code">sequelize db:migrate:undo</p>
<p>This will revert the last migration performed by Sequelize. If we want to undo all of our changes, there is another subcommand, shown here:</p>
<p class="source-code">sequelize db:migrate:undo:all</p>
<p>If we want to revert all of our migrations up until a certain point (this is why prefixing your filenames with a timestamp is important for congruity), we can run the following command:</p>
<p class="source-code">sequelize db:migrate:undo:all --to XXXXXXXXXXXXXX-airlines.js</p>
<p>After <a id="_idIndexMarker251"/>the migration is completed, we should run the following commands:</p>
<p class="source-code">$ mysql -uroot airline</p>
<p class="source-code">mysql&gt; show tables;</p>
<p>The tables shown in the following screenshot should be displayed: </p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 2.2 – Display of the project’s tables " height="505" src="image/Figure_2.2_B17841.jpg" width="1102"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Display of the project’s tables</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor066"/>Initializing seed data</h2>
<p>Now that <a id="_idIndexMarker252"/>we have our schema in place, we can start populating our database with actual data by generating seeder files within the <strong class="source-inline">seeders</strong> directory. Seed data is conventionally used for initial configuration data, static information, and so on. Good thing too—our business partner just notified us that they have purchased five airplanes to help get us started. We can create seed data for these airplanes, like so:</p>
<p class="source-code">sequelize seed:generate --name initial-airplanes</p>
<p>This will generate a file in our project’s <strong class="source-inline">seeders</strong> directory that contains the bare minimum for migrating seed data into the database. Similar to our migration files, there are only two methods exposed to the CLI: <strong class="source-inline">up(…)</strong> and <strong class="source-inline">down(…)</strong>.</p>
<p>We will <a id="_idIndexMarker253"/>replace the file’s contents with the following code:</p>
<pre class="source-code">
'use strict';
module.exports = {
  up: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.bulkInsert('Airplanes', [{
      planeModel: 'Airbus A220-100',
      totalSeats: 110,
      createdAt: new Date(),
      updatedAt: new Date()
    }, {
      planeModel: 'Airbus A220-300',
      totalSeats: 110,
      createdAt: new Date(),
      updatedAt: new Date()
    }, {
      planeModel: 'Airbus A 318',
      totalSeats: 115,
      createdAt: new Date(),
      updatedAt: new Date()
    }, {
      planeModel: 'Boeing 707-100',
      totalSeats: 100,
      createdAt: new Date(),
      updatedAt: new Date()
    }, {
      planeModel: 'Boeing 737-100',
      totalSeats: 85,
      createdAt: new Date(),
      updatedAt: new Date()
    }], {});
  },
  down: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.bulkDelete('Airplanes', null, {});
  }
};</pre>
<p class="callout-heading">Note</p>
<p class="callout">Unlike <a id="_idIndexMarker254"/>Sequelize’s <strong class="source-inline">create()</strong> function, the query interface’s <strong class="source-inline">bulkInsert()</strong> method will not hydrate the <strong class="source-inline">createdAt</strong> or <strong class="source-inline">updatedAt</strong> columns automatically. If you omit these columns from the seed file, the database will return an error since the columns do not have a default value.</p>
<p>Now, we can process our seed data via the following command:</p>
<p class="source-code">sequelize db:seed:all</p>
<p>We can confirm the changes by entering the following SQL command into our database: </p>
<p class="source-code">SELECT * FROM airplanes;</p>
<p>We then get the following results: </p>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 2.3 – Querying a list of airplanes " height="291" src="image/Figure_2.3_B17841.jpg" width="790"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Querying a list of airplanes</p>
<p>Reverting <a id="_idIndexMarker255"/>seed data is similar to the <strong class="source-inline">migrations</strong> subcommand, as we can see here:</p>
<p class="source-code">sequelize db:seed:undo</p>
<p class="source-code">sequelize db:seed:undo:all</p>
<p class="source-code">sequelize db:seed:undo --seed &lt;the name of your seed file&gt;</p>
<p class="callout-heading">Tip</p>
<p class="callout">Sequelize uses another project internally for migrations called Umzug. A full reference, and more examples on how to tune your migration cycle, can be found at the project’s GitHub repository: <a href="https://github.com/sequelize/umzug">https://github.com/sequelize/umzug</a>.</p>
<p>Once we are done inserting seed data into a database, we can now query or manipulate that data using Sequelize. The following section will provide a very brief introduction for incorporating Sequelize for an Express application following more of a reference style for Sequelize. This will help give you an idea of how we will apply Sequelize in subsequent chapters for our airline project, and enough technical knowledge to help you become comfortable with making your own adjustments.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor067"/>Manipulating and querying data using Sequelize</h1>
<p>After <a id="_idIndexMarker256"/>initializing our database’s structure and data, we <a id="_idIndexMarker257"/>should be able to view, modify, and remove <a id="_idIndexMarker258"/>the airplanes from our dashboard. For now, we <a id="_idIndexMarker259"/>will create very naive and simple implementations for our administrative tasks, but since we are the only technical employee at <em class="italic">Avalon Airlines</em>, this will not be a problem. As we continue creating the project, we will modify our application to become more robust and function with safety measures in mind.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor068"/>Reading data</h2>
<p>Replace <a id="_idIndexMarker260"/>the <strong class="source-inline">app.get('/', …)</strong> block with the following code (in <strong class="source-inline">index.js</strong>):</p>
<pre class="source-code">
app.get('/', async function (req, res) {
    const airplanes = await models.Airplane.findAll();
    res.send("&lt;pre&gt;" + JSON.stringify(airplanes, undefined, 
              4) + "&lt;/pre&gt;");
});</pre>
<p>After that, save the file and run our application with the following command:</p>
<p class="source-code">npm run start</p>
<p>Now, we can visit our website at <strong class="source-inline">http://localhost:3000</strong> and should see results similar to those shown here: </p>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 2.4 – Listing our airplanes  " height="609" src="image/Figure_2.4_B17841.jpg" width="371"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Listing our airplanes </p>
<p>Now, we will <a id="_idIndexMarker261"/>create another route that will return the results to us for a <a id="_idIndexMarker262"/>specific airplane. If the airplane cannot be found, then we should send a <em class="italic">Not Found</em> <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>) response <a id="_idIndexMarker263"/>code (which is <strong class="source-inline">404</strong>). Add the following route below the root <strong class="bold">Uniform Resource Locator</strong> (<strong class="bold">URL</strong>) route (the <strong class="source-inline">app.get('/', …)</strong> block):</p>
<pre class="source-code">
app.get('/airplanes/:id', async function (req, res) {
    var airplane = await models.Airplane.findByPk
                   (req.params.id);
    if (!airplane) {
        return res.sendStatus(404);
    }
    res.send("&lt;pre&gt;" + JSON.stringify(airplane, undefined, 
              4) + "&lt;/pre&gt;");
});</pre>
<p>The <strong class="source-inline">findByPk</strong> method will try to find a record from the model’s PK attribute (by default, this will be Sequelize’s generated <strong class="source-inline">id</strong> column). When a record is found (for example, <a href="http://localhost:3000/airplanes/1">http://localhost:3000/airplanes/1</a>), the application will return the record to us, but if we changed the <strong class="source-inline">id</strong> parameter from <strong class="source-inline">1</strong> to <strong class="source-inline">10</strong> (<strong class="source-inline">http://localhost:3000/airplanes/10</strong>), we should receive a <em class="italic">Not Found</em> response. </p>
<p>Here is a <a id="_idIndexMarker264"/>list with a brief explanation of Sequelize functions relating to retrieving data:</p>
<ul>
<li><strong class="source-inline">findAll</strong>—Use this <a id="_idIndexMarker265"/>when you want to use the <strong class="source-inline">where</strong> clause in your query and retrieve more than one row.</li>
<li><strong class="source-inline">findOne</strong>—Similar <a id="_idIndexMarker266"/>to the <strong class="source-inline">findAll</strong> function, except that this function will return a single row.</li>
<li><strong class="source-inline">findByPk</strong>—A function <a id="_idIndexMarker267"/>that returns a single row using the model’s defined PK.</li>
<li><strong class="source-inline">findOrCreate</strong>—This function will return a single instance of the row that was either <a id="_idIndexMarker268"/>found or instantiated from the database. Sequelize will compose the attributes defined within the <strong class="source-inline">where</strong> and <strong class="source-inline">defaults</strong> key.</li>
</ul>
<h2 id="_idParaDest-61"><a id="_idTextAnchor069"/>Complex querying</h2>
<p>Sometimes, you <a id="_idIndexMarker269"/>will need more than just a simple <strong class="source-inline">where</strong> clause with an <strong class="source-inline">AND</strong> operator. Sequelize has several operators built in to help write queries with a more complex <strong class="source-inline">where</strong> clause. A full list of these operators is shown here:</p>
<ul>
<li><strong class="source-inline">and</strong>/<strong class="source-inline">or</strong>—Logical <strong class="source-inline">AND</strong> and logical <strong class="source-inline">OR</strong>. These values contain an array of <strong class="source-inline">where</strong> clause objects.</li>
<li><strong class="source-inline">eq</strong>/<strong class="source-inline">ne</strong>—Equal (<strong class="source-inline">=</strong>) or Not Equal (<strong class="source-inline">!=</strong>).</li>
<li><strong class="source-inline">gte</strong>/<strong class="source-inline">gt</strong>—Greater-Than-or-Equal (<strong class="source-inline">&gt;=</strong>) and Greater-Than (<strong class="source-inline">&gt;</strong>).</li>
<li><strong class="source-inline">lte</strong>/<strong class="source-inline">lt</strong>—Lesser-Than-or-Equal (<strong class="source-inline">&lt;=</strong>) and Lesser-Than (<strong class="source-inline">&lt;</strong>).</li>
<li><strong class="source-inline">is</strong>/<strong class="source-inline">not</strong>—<strong class="source-inline">IS NULL</strong> and <strong class="source-inline">IS NOT TRUE</strong>, respectively.</li>
<li><strong class="source-inline">in</strong>/<strong class="source-inline">notIn</strong>—<strong class="source-inline">IN</strong> and <strong class="source-inline">NOT IN</strong> operators of any array with values.</li>
<li><strong class="source-inline">any</strong>/<strong class="source-inline">all</strong>/<strong class="source-inline">values</strong>—<strong class="source-inline">ANY</strong> (Postgres only), <strong class="source-inline">ALL</strong>, and <strong class="source-inline">VALUES</strong> operators respectively.</li>
<li><strong class="source-inline">col</strong>—Converts column string values into <strong class="bold">identifiers</strong> (<strong class="bold">IDs</strong>) specified by the database/dialect.</li>
<li><strong class="source-inline">placeholder</strong>—Internal operator used by Sequelize.</li>
<li><strong class="source-inline">join</strong>—Used internally by Sequelize.</li>
<li><strong class="source-inline">match</strong>—Match operator <a id="_idIndexMarker270"/>used for text searching (Postgres only).</li>
<li><strong class="source-inline">like</strong>/<strong class="source-inline">notLike</strong>—<strong class="source-inline">LIKE</strong> and <strong class="source-inline">NOT LIKE</strong>, respectively.</li>
<li><strong class="source-inline">iLike</strong>/<strong class="source-inline">notILike</strong>—Case-insensitive version of <strong class="source-inline">LIKE</strong> and <strong class="source-inline">NOT LIKE</strong> (Postgres only).</li>
<li><strong class="source-inline">startsWith</strong>/<strong class="source-inline">endsWith</strong>—Shorthand for the <strong class="source-inline">LIKE '%...'</strong> and <strong class="source-inline">LIKE '...%'</strong> expressions.</li>
<li><strong class="source-inline">substring</strong>—Shorthand expression for <strong class="source-inline">LIKE '%...%'</strong>.</li>
<li><strong class="source-inline">regexp</strong>/<strong class="source-inline">notRegexp</strong>—<strong class="source-inline">REGEXP</strong> and <strong class="source-inline">NOT REGEXP</strong> for MySQL and Postgres only.</li>
<li><strong class="source-inline">between</strong>/<strong class="source-inline">notBetween</strong>—<strong class="source-inline">BETWEEN x AND y</strong> and <strong class="source-inline">NOT BETWEEN x AND y</strong>.</li>
<li><strong class="source-inline">overlap</strong>—Postgres-only range operator for overlap (<strong class="source-inline">&amp;&amp;</strong>).</li>
<li><strong class="source-inline">contains</strong>/<strong class="source-inline">contained</strong>—Postgres-only range operator for <strong class="source-inline">@&gt;</strong> and <strong class="source-inline">&lt;@</strong>, respectively.</li>
<li><strong class="source-inline">Adjacent</strong>—Postgres-only range operator for adjacent querying (<strong class="source-inline">-|-</strong>).</li>
<li><strong class="source-inline">strictLeft</strong>/<strong class="source-inline">strictRight</strong>—Strict operators for Postgres ranges (<strong class="source-inline">&lt;&lt;</strong> and <strong class="source-inline">&gt;&gt;</strong>).</li>
<li><strong class="source-inline">noExtendRight</strong>/<strong class="source-inline">noExtendLeft</strong>—No extension range operators for Postgres (<strong class="source-inline">&amp;&lt; </strong>and <strong class="source-inline">&amp;&gt;</strong>).</li>
</ul>
<p>Querying <a id="_idIndexMarker271"/>a complex <strong class="source-inline">where</strong> clause may look something like this:</p>
<pre class="source-code">
const { Op } = require("sequelize");
MyModel.findAll({
    where: {
        [Op.or]: [
            { status: 'active' },
            sequelize.where(sequelize.fn('lower', se
            quelize.col('name')), {
                [Op.eq]: 'bob'
            },
            {
                [Op.and]: {
                    age: {
                        [Op.gte]: 40
                    },
                    name: {
                        [Op.like]: 'mary%'
                    }
                }
            }
        }]
    }
});</pre>
<p>This <a id="_idIndexMarker272"/>will then produce the following query:</p>
<pre class="source-code">
SELECT
    ...
FROM "MyModel"
WHERE (
    status = 'active'
    OR
    lower(name) = 'bob'
    OR (
        age &gt;= 40
        AND
        name LIKE 'mary%'
    )
)</pre>
<h2 id="_idParaDest-62"><a id="_idTextAnchor070"/>Deleting data</h2>
<p>For deleting <a id="_idIndexMarker273"/>an instance (a single record), we can call a <strong class="source-inline">destroy()</strong> function, like so:</p>
<pre class="source-code">
var record = MyModel.findOne({ where: { /* ... */ } });
await record.destroy();</pre>
<p class="callout-heading">Note</p>
<p class="callout">If there is no attribute marked as a PK within your model’s definition, then Sequelize may not delete the correct record. The instance’s <strong class="source-inline">destroy()</strong> method would be called with a <strong class="source-inline">where</strong> clause that tried to match all of the instance’s attributes. This could lead to unintentional deletions.</p>
<p>To delete <a id="_idIndexMarker274"/>multiple rows at once, execute the following code:</p>
<pre class="source-code">
MyModel.destroy({ where: { name: 'Bob' }});</pre>
<p>You can remove all of a table’s data by passing a configuration option to the <strong class="source-inline">destroy()</strong> method, like so:</p>
<pre class="source-code">
await MyModel.destroy({ truncate: true });
// or
await MyModel.truncate();</pre>
<h2 id="_idParaDest-63"><a id="_idTextAnchor071"/>Updating and saving data</h2>
<p>Sequelize <a id="_idIndexMarker275"/>offers a few ways of updating attributes/data, depending <a id="_idIndexMarker276"/>on where you are updating from. If you wish to update multiple rows, we could use the model’s <strong class="source-inline">update()</strong> function, like so:</p>
<pre class="source-code">
await MyModel.update({ name: "John" }, {
  where: { name: null }
});</pre>
<p>This query will update all of the records’ names to <strong class="source-inline">John</strong>, where the current value is <strong class="source-inline">NULL</strong>. For updating a specific instance, we would change the attribute’s value and then call the <strong class="source-inline">save()</strong> function, as follows:</p>
<pre class="source-code">
var record = MyModel.findOne();
record.name = "John";
await record.save();</pre>
<p>If you are in the middle of changing a record’s attributes and your workflow requires you to reset the record’s data back to the original values (without touching the database), you may do so with the <strong class="source-inline">reload()</strong> method, as follows:</p>
<pre class="source-code">
var record = MyModel.findOne({ where: { name: 'John' } });
record.name = "Bob";
record.reload();
// the record.name attribute's value is now back to John</pre>
<h2 id="_idParaDest-64"><a id="_idTextAnchor072"/>Creating data</h2>
<p>To create <a id="_idIndexMarker277"/>a single row, the code for Sequelize would look similar to this:</p>
<pre class="source-code">
await MyModel.create({ firstName: 'Bob' }, { ... });</pre>
<p>The second parameter accepts the following options for <strong class="source-inline">create()</strong>: </p>
<ul>
<li><strong class="source-inline">raw</strong>—If this <a id="_idIndexMarker278"/>Boolean value is set to <strong class="source-inline">true</strong>, then Sequelize <a id="_idIndexMarker279"/>will ignore the <strong class="bold">virtual setter attributes</strong> within the model’s definition. This is useful when you want to skip transforming the data through setter functions and wish to use the raw values that are provided from the query directly instead.</li>
<li><strong class="source-inline">isNewRecord</strong>—A Boolean <a id="_idIndexMarker280"/>value that can enable (if set to <strong class="source-inline">true</strong>) Sequelize’s behavior for applying default values, updating a timestamp column, and so on. The default value for this method is <strong class="source-inline">true</strong>.</li>
<li><strong class="source-inline">include</strong>—An array <a id="_idIndexMarker281"/>containing include options for Sequelize. This book will provide examples and further details in a later chapter.</li>
<li><strong class="source-inline">fields</strong>—An array <a id="_idIndexMarker282"/>of strings containing column names that will filter which attributes will be updated, validated, and saved.</li>
<li><strong class="source-inline">silent</strong>—If this <a id="_idIndexMarker283"/>value is set to <strong class="source-inline">true</strong>, then Sequelize will not update the <strong class="source-inline">updatedAt</strong> timestamp column.</li>
<li><strong class="source-inline">validate</strong>—A Boolean <a id="_idIndexMarker284"/>value to toggle whether or not to execute validations.</li>
<li><strong class="source-inline">hooks</strong>—A Boolean <a id="_idIndexMarker285"/>value that enables/disables running before/after <strong class="source-inline">create</strong>, <strong class="source-inline">update</strong>, and <strong class="source-inline">validate</strong> life cycle events.</li>
<li><strong class="source-inline">logging</strong>—A function <a id="_idIndexMarker286"/>that will pass down the query’s statement.</li>
<li><strong class="source-inline">benchmark</strong>—Logs <a id="_idIndexMarker287"/>execution query time (in milliseconds) and will be passed as the second parameter for the <strong class="source-inline">logging</strong> function.</li>
<li><strong class="source-inline">transaction</strong>—You <a id="_idIndexMarker288"/>may pass a transaction Sequelize instance for this option.</li>
<li><strong class="source-inline">searchPath</strong>—Postgres-only <a id="_idIndexMarker289"/>option for defining which <strong class="source-inline">search_path</strong> to use when querying.</li>
<li><strong class="source-inline">returning</strong>—Postgres-only <a id="_idIndexMarker290"/>option for selecting which fields to return when creating a new record. A Boolean <strong class="source-inline">true</strong> value will return all of the fields, but an array of strings will filter which columns to return.</li>
</ul>
<p>Bulk-inserting <a id="_idIndexMarker291"/>data is very similar to creating a single row with Sequelize. The following code snippet illustrates an example of this:</p>
<pre class="source-code">
await MyModel.bulkCreate([
    { firstName: 'Bob' },
    { firstName: 'William' }
], {...});</pre>
<p>The first parameter is an array of values, and the second parameter is for configuration options. These options are identical to the <strong class="source-inline">create()</strong> method: <strong class="source-inline">fields</strong>, <strong class="source-inline">validate</strong>, <strong class="source-inline">hooks</strong>, <strong class="source-inline">transaction</strong>, <strong class="source-inline">logging</strong>, <strong class="source-inline">benchmark</strong>, <strong class="source-inline">returning</strong>, and <strong class="source-inline">searchPath</strong>. In addition, the <strong class="source-inline">bulkCreate()</strong> method also offers us the following options:</p>
<ul>
<li><strong class="source-inline">individualHooks</strong>—Executed <a id="_idIndexMarker292"/>before/after create life cycle events for each record individually. This does not affect bulk before/after life cycle events.</li>
<li><strong class="source-inline">ignoreDuplicates</strong>—Ignores duplicated rows by any constrained key defined <a id="_idIndexMarker293"/>on the table. This feature is not supported on MSSQL or Postgres versions below 9.5.</li>
<li><strong class="source-inline">k</strong>—An array <a id="_idIndexMarker294"/>of fields to update if there is a duplicated key entry (for MySQL/MariaDB, SQLite 3.24.0+, and Postgres 9.5+ only).</li>
</ul>
<h2 id="_idParaDest-65"><a id="_idTextAnchor073"/>Ordering and grouping</h2>
<p>When <a id="_idIndexMarker295"/>sifting through your data, you can order (or group) your columns like so:</p>
<pre class="source-code">
MyModel.findAll({
    where: { name: 'Bob' },
    order: [
        ['name', 'DESC']
    ]
});</pre>
<p>For grouping, depending <a id="_idIndexMarker296"/>on which database you are using, you may have different results from other database engines (such as requiring you to select only aggregated functions and grouped columns). Consult your database’s documentation for the specific nuances and rules that are required for grouping. Here is an example of a simple <strong class="source-inline">GROUP BY</strong> statement:</p>
<pre class="source-code">
MyModel.findAll({ group: 'name' });</pre>
<p class="callout-heading">Caution</p>
<p class="callout">Sequelize will treat the group’s input as a literal value. If you are grouping by user-generated <a id="_idIndexMarker297"/>content, it is highly recommended to escape your value to avoid SQL injections (<a href="https://en.wikipedia.org/wiki/SQL_injection">https://en.wikipedia.org/wiki/SQL_injection</a>). You may escape values using the <strong class="source-inline">sequelize.escape('...');</strong> method.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor074"/>Limits and pagination</h2>
<p>We can <a id="_idIndexMarker298"/>simply use the <strong class="source-inline">offset</strong> and <strong class="source-inline">limit</strong> key values for our <a id="_idIndexMarker299"/>finder methods, like so:</p>
<pre class="source-code">
MyModel.findAll({ offset: 5, limit: 10 });</pre>
<p>This will select from the <strong class="source-inline">MyModel</strong> table with a limit of 10 and an offset of 5.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline">limit</strong> property will tell the database to only retrieve that number of rows (in MSSQL, this would be <strong class="source-inline">SELECT TOP N</strong> or <strong class="source-inline">FETCH NEXT N ROWS</strong>). The <strong class="source-inline">offset</strong> property will skip N rows before retrieving the results. For MSSQL 2008 (and earlier) users, Sequelize will offer offset support by nesting queries to simulate offset behavior for compatibility and completeness.</p>
<p>Now that we have finished referencing Sequelize’s methodologies for querying and manipulating data, we can now go over the more advanced options when defining a model. These options can change the way Sequelize will transform data internally, filter queried data, and adjust naming conventions, allowing you to better adapt Sequelize’s behavior to your company/project’s requirements. </p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor075"/>Advanced Sequelize options for defining models</h1>
<p>When <a id="_idIndexMarker300"/>defining a model, within Sequelize, the last input parameter for the <strong class="source-inline">init()</strong> and <strong class="source-inline">define()</strong> methods offers us a way to fine-tune our project’s requirements and Sequelize’s behavior. These parameter options are useful for situations such as when we need to construct Sequelize in a pre-existing environment that does not adhere to Sequelize’s naming conventions (for example, a column named <strong class="source-inline">PersonIsMIA</strong> as opposed to Sequelize’s <strong class="source-inline">"PersonIsMia"</strong> convention).</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor076"/>sequelize</h2>
<p>A copy (or new) instance of Sequelize to associate with the model. Sequelize will return an error <a id="_idIndexMarker301"/>if this field is not provided (except when using the <strong class="source-inline">sequelize.define</strong> method). Useful for querying across data centers or even databases.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor077"/>modelName</h2>
<p>Explicitly <a id="_idIndexMarker302"/>defines the model’s name with a string. This would be the first parameter in Sequelize’s <strong class="source-inline">define()</strong> method. If you are using ES6 class definitions, the default for this value would be the class name.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor078"/>defaultScope/scopes</h2>
<p>An object <a id="_idIndexMarker303"/>for values that will set the <a id="_idIndexMarker304"/>model’s default scope and set applicable scopes for the model, respectively. Scopes can be useful for code organization or enforcing a basic access control list as a default behavior. We will go into detail about scoping in a later chapter.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor079"/>omitNull</h2>
<p>Setting <a id="_idIndexMarker305"/>this Boolean value to <strong class="source-inline">true</strong> will tell Sequelize to omit any columns that have a <strong class="source-inline">null</strong> value when saving a record.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor080"/>timestamps</h2>
<p>This option <a id="_idIndexMarker306"/>allows us to control Sequelize’s behavior for adding <strong class="source-inline">createdAt</strong> and <strong class="source-inline">updatedAt</strong> timestamp columns for the model. The default value for this setting is <strong class="source-inline">true</strong> (Sequelize will create timestamp columns).</p>
<p class="callout-heading">Note</p>
<p class="callout">You can always override the default settings for the <strong class="source-inline">createdAt</strong> and <strong class="source-inline">updatedAt</strong> attributes by defining them explicitly within your model. Sequelize will know to use those attributes for timestamp-related columns.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor081"/>paranoid</h2>
<p>This <a id="_idIndexMarker307"/>Boolean option, when set to <strong class="source-inline">true</strong>, will prevent Sequelize from deleting the data (by default) and adds a <strong class="source-inline">deletedAt</strong> timestamp column. The <strong class="source-inline">timestamps</strong> option must be set to <strong class="source-inline">true</strong> in order to make <strong class="source-inline">paranoid</strong> applicable. The default value for <strong class="source-inline">paranoid</strong> is <strong class="source-inline">false</strong>.</p>
<p>The following query will perform a “soft deletion”:</p>
<pre class="source-code">
await Post.destroy({
  where: {
    id: 1
  }
});</pre>
<p>This query will update the <strong class="source-inline">Post</strong> record of ID 1 and update the <strong class="source-inline">deletedAt</strong> column. If we wanted to remove the record from the database (instead of updating it), we would use the <strong class="source-inline">force</strong> parameter, as illustrated in the following code snippet:</p>
<pre class="source-code">
await Post.destroy({
  where: {
    id: 1
  },
  force: true
});</pre>
<p>This would perform a <strong class="source-inline">delete</strong> query versus an <strong class="source-inline">update</strong> query on the database.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor082"/>createdAt/updatedAt/deletedAt</h2>
<p>This <a id="_idIndexMarker308"/>option will rename the <strong class="source-inline">createdAt</strong>, <strong class="source-inline">updatedAt</strong>, and <strong class="source-inline">deletedAt</strong> attributes, respectively. If you provide camel-cased <a id="_idIndexMarker309"/>values and the underscored option <a id="_idIndexMarker310"/>is set to <strong class="source-inline">true</strong>, Sequelize will automatically convert the column’s casing. Setting the value as <strong class="source-inline">false</strong> instead of a string will tell Sequelize to disable its default behavior for that respective column.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor083"/>underscored</h2>
<p>By default, Sequelize <a id="_idIndexMarker311"/>will create columns using camel case (for example, <strong class="source-inline">updatedAt</strong>, <strong class="source-inline">firstName</strong>, and so on). If you prefer underscores or snake case (for example, <strong class="source-inline">updated_at</strong>, <strong class="source-inline">first_name</strong>, and so on), then you would set this value to <strong class="source-inline">true</strong>.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor084"/>freezeTableName</h2>
<p>As <a id="_idIndexMarker312"/>previously mentioned, Sequelize will pluralize table names derived from the model’s name by default. Setting this value to <strong class="source-inline">true</strong> would prevent Sequelize from transforming the table’s name.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor085"/>tableName</h2>
<p>Explicitly <a id="_idIndexMarker313"/>defines the table name for Sequelize to use when creating SQL queries. A typical use case for this option is when you are integrating Sequelize into a pre-existing database/schema or when the pluralization is incorrectly set.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor086"/>name</h2>
<p>An object <a id="_idIndexMarker314"/>with two available options to define singular and plural names to use when associating this model with others. A clearer explanation, and an example, will be provided when we go over model associations and relations in a later chapter, but you can see an overview of the two options here:</p>
<ul>
<li><strong class="source-inline">singular</strong>—The name to use when referencing a single instance from a model (defaults to <strong class="source-inline">Sequelize.Utils.singularize(modelName)</strong>)</li>
<li><strong class="source-inline">pluralize</strong>—The name to use when referencing multiple instances of a model (defaults to <strong class="source-inline">Sequelize.Utils.pluralize(modelName)</strong>)</li>
</ul>
<h2 id="_idParaDest-79"><a id="_idTextAnchor087"/>schema</h2>
<p>Defines <a id="_idIndexMarker315"/>the model’s schema (this would be referenced as <strong class="source-inline">search_path</strong> in Postgres). Not all databases support schemas, and some will refer to schemas as databases entirely.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor088"/>engine</h2>
<p>Applicable <a id="_idIndexMarker316"/>to MySQL only, this is where you can define your table’s engine type (typically <strong class="source-inline">InnoDB</strong> or <strong class="source-inline">MyISAM</strong>). The default is <strong class="source-inline">InnoDB</strong>.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor089"/>charset</h2>
<p>Specifies the <a id="_idIndexMarker317"/>table’s charset. Useful for when your table’s contents can be deterministically defined to a set of characters that could help reduce database size (if you do not need universal encodings and only Latin characters, then you would use a Latin-derived charset).</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor090"/>collation</h2>
<p>Specifies <a id="_idIndexMarker318"/>the table’s collation (sorting and ordering rules for the characters).</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor091"/>comment</h2>
<p>Adds a <a id="_idIndexMarker319"/>comment to the table (if applicable to the DBMS).</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor092"/>initialAutoIncrement</h2>
<p>Sets <a id="_idIndexMarker320"/>the initial <strong class="source-inline">AUTO_INCREMENT</strong> value for applicable dialects (MySQL and MariaDB).</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor093"/>hooks</h2>
<p>An object <a id="_idIndexMarker321"/>with keys mapped to hooks (or life cycle events). The values may be a function or an array of functions. We will go into details about hooks in a later chapter.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor094"/>validate</h2>
<p>An object <a id="_idIndexMarker322"/>to define model validations. We will go into detail about validations in the next chapter.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor095"/>indexes</h2>
<p>An array <a id="_idIndexMarker323"/>of objects that define table indices’ definitions. These indices are created when calling <strong class="source-inline">sync()</strong> or using the migration tool. Each object has the following options:</p>
<ul>
<li><strong class="source-inline">name</strong>—The name of the index (Sequelize will default to the model’s name and applicable fields joined by an underscore).</li>
<li><strong class="source-inline">type</strong>—A string value for defining the index’s type (only for MySQL/MariaDB). Typically, this is where you would define <strong class="source-inline">FULLTEXT</strong> or <strong class="source-inline">SPATIAL</strong> indices (<strong class="source-inline">UNIQUE</strong> as well, but there is a dialect-agnostic option for creating unique indices).</li>
<li><strong class="source-inline">unique</strong>—Setting this value to true would create a unique index.</li>
<li><strong class="source-inline">using</strong>—The <strong class="source-inline">USING</strong> clause value for the index’s SQL statement. A few examples would be <strong class="source-inline">BTREE</strong> (typically, a DBMS will use this index type as the default), <strong class="source-inline">HASH</strong> (MySQL/MariaDB/Postgres only), and <strong class="source-inline">GIST</strong>/<strong class="source-inline">GIN</strong> (Postgres only).</li>
<li><strong class="source-inline">operator</strong>—Defines an operator to use for this index (primarily used for Postgres but can be used in other dialects).</li>
<li><strong class="source-inline">concurrently</strong>—Setting this to <strong class="source-inline">true</strong> offers a way of creating indices without writing locks (Postgres only).</li>
<li><strong class="source-inline">fields</strong>—An array of index fields to define for the model. Refer to the <em class="italic">Index fields</em> section, next.</li>
</ul>
<h3>Index fields</h3>
<p>Each <a id="_idIndexMarker324"/>index definition’s fields value can be one of the following:</p>
<ul>
<li>A string indicating the name of the index</li>
<li>Sequelize literal object functions (for example, <strong class="source-inline">sequelize.fn()</strong>)</li>
<li>An object with the following keys:<ul><li><strong class="source-inline">attribute</strong>—A string value for the column to index</li><li><strong class="source-inline">length</strong>—Defines the length for a prefix index (if applicable to your DBMS)</li><li><strong class="source-inline">order</strong>—Determines whether the sorting should be ascending or descending</li><li><strong class="source-inline">collate</strong>—Defines the collation for the column</li></ul></li>
</ul>
<p>A quick example is provided here to illustrate how to use some of these advanced options when defining a Sequelize model:</p>
<pre class="source-code">
class User extends Model { }
User.init({
    name: DataTypes.STRING,
}, {
    sequelize,
    modelName: 'User',
    omitNull: true,
    // renames deletedAt to removedAt
    deletedAt: 'removedAt',
    // start with ID 1000
    initialAutoIncrement: 1000,
    validate: {
        isNotBob() {
            if (this.name === 'bob') {
                throw new Error("Bob is not allowed to be a 
                                 user.");
            }
        }
    },
    indexes: [
        { unique: true, fields: ['name'] }
    ],
});</pre>
<h1 id="_idParaDest-88"><a id="_idTextAnchor096"/>Summary</h1>
<p>In this chapter, we went through a detailed overview of the various parameters and configuration settings for defining models with Sequelize. We also learned how to use the Sequelize CLI to automatically generate models’ definition (and data) files and how to migrate those definitions to a database. This chapter has also covered the various attribute types provided by Sequelize, as well as the methodologies for querying or updating data from Sequelize to the database.</p>
<p>In the next chapter, we will go over model validations, establishing foreign relationships, and how to constrain your data to meet your project’s requirements.</p>
</div>
</div>

<div id="sbo-rt-content"><div>
<div id="_idContainer036">
</div>
</div>
<div class="Content" id="_idContainer037">
<h1 id="_idParaDest-89"><a id="_idTextAnchor097"/>Part 2 – Validating, Customizing, and Associating Your Data</h1>
<p>In this part, you will take a deeper look into Sequelize’s model attributes and add validations, custom column types, and related associated models. You will explore hooks, JSON, and Blob types, along with transactions.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B17841_03.xhtml#_idTextAnchor098"><em class="italic">Chapter 3</em></a>, <em class="italic">Validating Models</em></li>
<li><a href="B17841_04.xhtml#_idTextAnchor111"><em class="italic">Chapter 4</em></a>, <em class="italic">Associating Models</em></li>
<li><a href="B17841_05.xhtml#_idTextAnchor134"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Hooks and Lifecycle Events to Your Models</em></li>
<li><a href="B17841_06.xhtml#_idTextAnchor147"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Transactions with Sequelize</em></li>
<li><a href="B17841_07.xhtml#_idTextAnchor159"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling Customized, JSON, and Blob Data Types</em></li>
</ul>
</div>
</div></body></html>