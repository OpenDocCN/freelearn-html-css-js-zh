<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-28"><a id="_idTextAnchor036"/>2</h1>
<h1 id="_idParaDest-29"><a id="_idTextAnchor037"/>Defining and Using Sequelize Models </h1>
<p>For our <em class="italic">Avalon Airlines</em> project that we introduced in the previous chapter, we will need to instruct our application on how we want to define our database’s schematics. A database can have various roles and applications but only a single purpose, and that purpose is to organize our data (storage is the filesystem’s job). Before we can begin defining our models within the Node.js application, we need to think about the entities of our business logic and models from a project’s perspective (and each project will have different requirements). Most projects will structure their schema in a way that categorizes <em class="italic">organizations</em> (for example, customers, employees, vendors, and companies) and <em class="italic">things</em> such as products, planes, and receipts from transactions.</p>
<p> <code>snake_case</code> or with a <code>PascalCase</code> pattern). Relations—or associations—between models will be automatically created and managed by Sequelize. Business logic workflows can also be established so that you do not have to remember workflows such as <em class="italic">removing the customer’s boarding pass if they canceled their trip</em>. That part would be handled in one organized place versus invoking <code>RemoveBoardingPass(...)</code> in every code section that cancels a trip (regardless of whether the method was called from the customer, an employee, and so on). This chapter will teach you how to define and synchronize your models with a database and how to apply the data to a Node.js runtime application using Sequelize. This will be the initial foundation on how to operate Sequelize.</p>
<p>This chapter will introduce you to the following concepts:</p>
<ul>
<li>Defining models for a database</li>
<li>Exploring the various Sequelize data types and when to use them</li>
<li>Migrating schematic changes and data from Sequelize to the database</li>
<li>Manipulating and querying data using Sequelize</li>
<li>Advanced Sequelize options for defining models</li>
</ul>
<h1 id="_idParaDest-30"><a id="_idTextAnchor038"/>Technical requirements</h1>
<p>You can find the code files present in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch2">https://github.com/PacktPublishing/Supercharging-Node.js-Applications-with-Sequelize/tree/main/ch2</a></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor039"/>Defining models for a database</h1>
<p>In this section, we will go over a brief overview of our project’s requirements and establish <a id="_idIndexMarker102"/>which kinds of models we need to define. After that, we will run a script generator command from the Sequelize <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) tool and <a id="_idIndexMarker103"/>inspect the basic structure of a model’s definition. </p>
<p>For <em class="italic">Avalon Airlines</em>, we will begin modeling with the following <em class="italic">organizations</em> and <em class="italic">things</em>:</p>
<ul>
<li>Airplanes</li>
<li>Customers</li>
<li>Flight schedules</li>
<li>Boarding tickets</li>
</ul>
<p>Each model will have its own table within the database. We will eventually associate these models or tables with columns, indices, validation, and relations to other models. For now, we will define, select (or query), insert, update, and delete data from these tables using Sequelize within our Node.js application. If you are working on a pre-existing project that already has a database, the <em class="italic">Manipulating and querying data using Sequelize</em> section will pertain to you more than to someone starting on a project from a clean slate. </p>
<p>We will first generate our models with the minimum requirements for columns using the Sequelize CLI tool. Then, we will go over the code that was generated by the CLI so that you are more familiar with how to define Sequelize models without depending on the CLI. Generate the previously mentioned models with the following commands within the project’s root directory:</p>
<pre>sequelize model:generate --name Airplane --attributes planeModel:string,totalSeats:integer
sequelize model:generate --name Customer --attributes name:string,email:string
sequelize model:generate --name FlightSchedule --attributes originAirport:string,destinationAirport:string,departureTime:date
sequelize model:generate --name BoardingTicket --attributes seat:string</pre>
<p>You may <a id="_idIndexMarker104"/>have noticed we used a singular noun for our models’ names. Sequelize will automatically pluralize the associated table and models for us. You can disable this behavior via Sequelize configuration settings, which will be discussed in detail further in this chapter. For our <code>BoardingTickets</code> model, we will generate associations of a customer and flight schedules in the next chapter, but for now, we can build the bare minimum for the table.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Sequelize comes with some useful utility functions available to the developer. The framework <a id="_idIndexMarker105"/>uses a library called <code>Sequelize</code>.</p>
<p>Opening the <code>models/flightschedule.js</code> file, we should see the following generated code:</p>
<pre class="source-code">
'use strict';
const {
  Model
} = require('@sequelize/core');
module.exports = (sequelize, DataTypes) =&gt; {
  class FlightSchedule extends Model {
    /**
     * Helper method for defining associations.
     * This method is not a part of Sequelize lifecycle.
     * The `models/index` file will call this method
       automatically.
     */
    static associate(models) {
      // define association here
    }
  };
  FlightSchedule.init({
    originAirport: DataTypes.STRING,
    destinationAirport: DataTypes.STRING,
    departureTime: DataTypes.DATE
  }, {
    sequelize,
    modelName: 'FlightSchedule',
  });
  return FlightSchedule;
};</pre>
<p>The <code>'use strict';</code> line in <a id="_idIndexMarker106"/>the preceding code snippet will tell our Node.js runtime to execute the JavaScript file (<code>models/flightschedule.js</code>) with a <a id="_idIndexMarker107"/>set of rules to help alleviate <strong class="bold">sloppy mode</strong>. <strong class="bold">Strict mode</strong> will prohibit <a id="_idIndexMarker108"/>the developer from assigning values to undeclared variables, using reserved keywords as defined by <strong class="bold">ECMAScript 2015</strong> (<strong class="bold">ES6</strong>), and <a id="_idIndexMarker109"/>so on. This mode is completely optional for the contents of this book; however, if you wish to learn more, Mozilla offers a helpful <a id="_idIndexMarker110"/>guide on the differences between strict and sloppy mode here: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode/Transitioning_to_strict_mode</a>.</p>
<p>The next set of instructions is to import the <code>Model</code> class from Sequelize, which we will use to initialize the model in the next few commands. The <code>module.exports</code> line that follows is a pattern that the Sequelize model loader (the <code>models/index.js</code> file) can interpret <a id="_idIndexMarker111"/>and how to invoke the file. The first argument provides an instance of Sequelize to us with all of the parameters and configuration settings that we established from the <code>models/index.js</code> file. The second parameter, <code>DataTypes</code>, provides a more ergonomic way of declaring the various data types for our columns (for example, instead of having to type out <code>sequelize.DataTypes.STRING</code>, we can omit the <code>sequelize.</code> instance prefix and just use <code>DataTypes.STRING</code>).</p>
<p>Next, we define our <code>FlightSchedule</code> class and extend Sequelize’s <code>Model</code> class. Here, we can define our associations, hooks/events, table information, and so on. The CLI will generate a <a id="_idIndexMarker112"/>static function for us called <strong class="bold">associations</strong>. For now, we can leave this function as is; we will modify it later throughout the book. </p>
<p>The last instruction within this file takes our <code>FlightSchedule</code> class and invokes the <code>init()</code> function, which will set up internal rules and instructions to help Sequelize navigate the model’s definition. This is also where Sequelize learns how to synchronize the model with the database, as shown in the following screenshot. If you were to set Sequelize’s <a id="_idIndexMarker113"/>option to <code>sync: true</code>, there would be additional <code>DROP TABLE IF EXISTS</code> for when we want to test our application on a clean slate every runtime. Having the sync option set to <code>true</code> is useful for unit tests and early prototype development. It is <em class="italic">not</em> recommended to set this option to <code>true</code> within a production environment:</p>
<div><div><img alt="Figure 2.1 – Sequelize’s automatic synchronization " height="369" src="img/Figure_2.1_B17841.jpg" width="935"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Sequelize’s automatic synchronization</p>
<p class="callout-heading">Note</p>
<p class="callout">Running our Node.js application and letting Sequelize synchronize our database is fine for the initial implementation phase, but we will go over the methodology of using Sequelize’s CLI and migrations to perform the necessary SQL commands to synchronize the database. Migrations offer incremental changes/updates as opposed to the Sequelize synchronize option, which is more of a generic solution. </p>
<p>The first <a id="_idIndexMarker114"/>parameter of the <code>init()</code> function is where we define our model’s attributes (or columns). The pattern for this is typically an object with the keys as column names and the value for each key is either a DataType, a literal string value, or an object containing advanced options for each column. From this example, we are shown three columns (<code>originAirport</code>, <code>destinationAirport</code>, and <code>departureTime</code>) with <code>string</code>, <code>string</code>, and <code>date</code> data types respectively. </p>
<p>The second parameter lets us define instance type settings for the model explicitly. This is where we can define a different table name, choose whether to pluralize our tables, disable meta columns (such as <code>createdAt</code> and <code>updatedAt</code>), and so on. We will go into details about these options later in this chapter.</p>
<p>If you prefer to not use classes in your project, there is another way to define our models. The following code snippet provides an example of using Sequelize’s <code>define()</code> function:</p>
<pre class="source-code">
module.exports = (sequelize, DataTypes) =&gt; {
    return sequelize.define('FlightSchedule', {
        originAirport: DataTypes.STRING,
        destinationAirport: DataTypes.STRING,
        departureTime: DataTypes.DATE
    }, {
        sequelize,
    });
};</pre>
<p>The parameters remain relatively the same as <code>init()</code> except that the first parameter is now the model’s name. Either way is acceptable and one does not provide advantages over the <a id="_idIndexMarker115"/>other from Sequelize’s point of view. This book will use the former example throughout its code base (the <code>Model</code> class), but for advanced configuration settings and adding associations, this book will illustrate both styles as there are some fundamental differences, ergonomically speaking. For programmers who favor using TypeScript over JavaScript, the <code>Model</code> class method may provide a more native experience to you.</p>
<p>Now that we have an understanding of how models are defined in Sequelize, we can go over which built-in attribute data types Sequelize has to offer, along with a brief explanation to help guide your future model designs. </p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor040"/>Exploring the various Sequelize data types and when to use them</h1>
<p>As <a id="_idIndexMarker116"/>explained earlier, Sequelize offers us various data types <a id="_idIndexMarker117"/>to help map our model’s attributes to their respective <strong class="bold">database management system</strong> (<strong class="bold">DBMS</strong>) column types. Next is a list of what Sequelize has to offer, along with a brief explanation.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor041"/>STRING</h2>
<p>The <code>STRING</code> data type <a id="_idIndexMarker118"/>refers to a <code>VARCHAR</code> fields usually contain meta information to help optimize the DBMS’ query planner. MySQL explicitly adds another byte to the column’s prefix header if the size of the string is greater than 255 bytes. A query <a id="_idIndexMarker121"/>planner could use this information to help alleviate pressure from memory, or the <code>VARCHAR</code> with a fixed paging length, you would define the column as <code>DataTypes.STRING(100)</code> instead of <code>DataTypes.STRING</code>. </p>
<p>Within a <code>VARCHAR</code> column type, the DBMS will not store the value as a fixed length (no padding is required). If you need data to be retrieved in the exact same way it was stored, you could use the <code>VARCHAR BINARY</code> column type. This can be achieved by declaring the column’s data type as <code>DataTypes.STRING.BINARY</code>. </p>
<p>Despite having the word “binary” in the data type’s name, for storing movies, pictures, and so on, it is often recommended to use the <code>BLOB</code> type over <code>VARCHAR BINARY</code>. The binary part of <code>VARCHAR BINARY</code> performs comparisons over the binary representation of that <a id="_idIndexMarker122"/>column versus a <strong class="bold">character set</strong> (<strong class="bold">charset</strong>).</p>
<p>For instance, suppose <a id="_idIndexMarker123"/>we had the following rows <a id="_idIndexMarker124"/>in a database: <code>A</code>, <code>a</code>, <code>B</code>, and <code>b</code>. The <code>VARCHAR</code> column type would have an internal map to tell the database that “A” and “a” will be listed prior to “B” and “b”. In a <code>VARCHAR BINARY</code> column, the sum binary representation of <code>A</code>, <code>a</code>, <code>B</code>, and <code>b</code> would be <code>0</code>, <code>2</code>, <code>1</code>, <code>3</code>, which would sort into the following: <code>A</code>, <code>B</code>, <code>a</code>, <code>b</code>. There is no internal map/charset for <code>VARCHAR BINARY</code> columns, so the database would not be able to tell that “A” and “a” are actually the same letter. </p>
<p>For the most part, we could use <code>VARCHAR BINARY</code> and <code>BLOB</code> interchangeably in MySQL versions above 5.0.2. There are some small subtle differences, as indicated here:</p>
<ul>
<li>An index prefix length must be specified for <code>BLOB</code> indexes</li>
<li><code>BLOB</code> column types cannot have default values</li>
</ul>
<h2 id="_idParaDest-34"><a id="_idTextAnchor042"/>CHAR</h2>
<p>The <code>CHAR</code> data type <a id="_idIndexMarker125"/>is similar to the <code>STRING</code> data type, except that it <a id="_idIndexMarker126"/>references the <code>CHAR</code> column type. Traditionally, a DBMS will cap the length of a <code>CHAR</code> column to 255 characters. A <code>VARCHAR</code> type will allow you to go over the specified paging size without an error or an exception. A <code>CHAR</code> column could be used as a last-resort effort for validating your data and ensuring it does not exceed the specified length (for example, <code>CHAR(20)</code> would cap the data to 20 characters defined by the table’s collation). <code>CHAR</code> column types are padded <a id="_idIndexMarker127"/>to their fixed length, which could help <a id="_idIndexMarker128"/>optimize the DBMS—or even your application—presuming that the pre-determined length is appropriate for the scenario’s paging size.</p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor043"/>TEXT/TINYTEXT/MEDIUMTEXT/LONGTEXT</h2>
<p>Database <a id="_idIndexMarker129"/>designers <a id="_idIndexMarker130"/>understand <a id="_idIndexMarker131"/>that sometimes, our <a id="_idIndexMarker132"/>text data requires <a id="_idIndexMarker133"/>a considerable amount of space or needs <a id="_idIndexMarker134"/>to be associated with rows larger than 65,535 bytes (a MySQL <code>VARCHAR</code> limitation). In this case, we would use a <code>TEXT</code> column <a id="_idIndexMarker135"/>type. Every DBMS has its nuances <a id="_idIndexMarker136"/>and limitations; since this book uses MySQL, we will briefly go over MySQL’s <code>TEXT</code> limitations, as follows: </p>
<ul>
<li><code>TINYTEXT</code>: 255 bytes </li>
<li><code>TEXT</code>: 64 <strong class="bold">kilobytes</strong> (<strong class="bold">KB</strong>) </li>
<li><code>MEDIUMTEXT</code>: 16 <strong class="bold">megabytes</strong> (<strong class="bold">MB</strong>)</li>
<li><code>LONGTEXT</code>: 4 <strong class="bold">gigabytes</strong> (<strong class="bold">GB</strong>)</li>
</ul>
<p><code>DataTypes.TEXT</code> will default to the <code>TEXT</code> column type, and if you wanted to declare your column type as <code>TINYTEXT</code>, <code>MEDIUMTEXT</code>, or <code>LONGTEXT</code>, you would use <code>DataTypes.TEXT('TINY')</code>, <code>DataTypes.TEXT('MEDIUM')</code>, or <code>DataTypes.TEXT('LONG')</code>, respectively. Unlike the <code>VARCHAR</code> type, there is no <code>BINARY</code> option for <code>TEXT</code> column types. For storing serialized binary types, you would use <code>VARCHAR BINARY</code> or <code>BLOB</code> instead. </p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor044"/>CITEXT</h2>
<p><strong class="bold">CITEXT</strong> stands for <strong class="bold">Case-Insensitive Text</strong>, which <a id="_idIndexMarker137"/>is a column <a id="_idIndexMarker138"/>that preserves the data’s casing <a id="_idIndexMarker139"/>except for comparison operations. This option is available for Postgres and SQLite databases only. </p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor045"/>NUMBER</h2>
<p>Not to <a id="_idIndexMarker140"/>be confused with Postgres’ <code>NUMERIC</code> type, the <code>NUMBER</code> data type is an abstraction for more than an explicit type, depending <a id="_idIndexMarker141"/>on its configuration settings. This data type should <em class="italic">not</em> be used directly unless you are extending/adding your own numeric data type. This abstract data type could help organize your code if you use the same precision and scale values throughout your database, or if your online store sells a product in different denominations and currencies.</p>
<p>The following code snippet provides an example of how you would extend your own numeric data type:</p>
<pre class="source-code">
<strong class="bold">// INT(4)</strong>
var unsignedInteger = DataTypes.NUMBER({
    length: 4,
    zerofill: false,
    unsigned: true,
});
<strong class="bold">// FLOAT(5,4)</strong>
var specificFloat = DataTypes.NUMBER({
    length: 5,
    zerofill: false,
    unsigned: false,
    decimals: 4
});
<strong class="bold">// DECIMAL(6,4)</strong>
var specificPrecision = DataTypes.NUMBER({
    zerofill: false,
    unsigned: false,
    precision: 6,
    scale: 4
});</pre>
<h2 id="_idParaDest-38"><a id="_idTextAnchor046"/>INTEGER/TINYINT/SMALLINT/MEDIUMINT/BIGINT</h2>
<p>With <code>DataTypes.INTEGER</code>, <code>DataTypes.SMALLINT</code>, and so on, we can associate our <a id="_idIndexMarker142"/>attributes with the respective column <a id="_idIndexMarker143"/>types. You can find references for minimum <a id="_idIndexMarker144"/>and maximum values for each <a id="_idIndexMarker145"/>integer type with MySQL here: <a href="https://dev.mysql.com/doc/refman/5.7/en/integer-types.xhtml">https://dev.mysql.com/doc/refman/5.7/en/integer-types.xhtml</a>. To <a id="_idIndexMarker146"/>declare your model’s attribute as an unsigned value, we can attach the <code>UNSIGNED</code> option <a id="_idIndexMarker147"/>to our data type, like so:</p>
<pre class="source-code">
DataTypes.INTEGER(21).UNSIGNED</pre>
<p>If <a id="_idIndexMarker148"/>we wanted <a id="_idIndexMarker149"/>to have our attribute unsigned <a id="_idIndexMarker150"/>and zero-filled, we <a id="_idIndexMarker151"/>can chain <a id="_idIndexMarker152"/>the data-type options, as follows:</p>
<pre class="source-code">
DataTypes.INTEGER(21).UNSIGNED.ZEROFILL</pre>
<p class="callout-heading">Note</p>
<p class="callout">Depending on which DBMS you use, the <code>ZEROFILL</code> option may not be available to you. If you are using a Postgres database, then the order of assigning those attributes is important (<code>UNSIGNED</code> must be declared before <code>ZEROFILL</code>). In MySQL, the <code>ZEROFILL</code> option will also imply <code>UNSIGNED</code> automatically. The <code>ZEROFILL</code> attribute will only affect the data from an aesthetics perspective (when you select data) and will not modify your data in storage.</p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor047"/>FLOAT/REAL</h2>
<p>Traditionally, a DBMS will differentiate between <code>FLOAT</code> and <code>REAL</code> column types by their <a id="_idIndexMarker153"/>bit precisions. <code>FLOAT</code> columns are usually stored with 32-bit precision, and <code>REAL</code> column <a id="_idIndexMarker154"/>types are stored with 64-bit precision. <code>REAL</code> column types are 64-bit and <code>FLOAT</code> columns are 32-bit. To make <a id="_idIndexMarker156"/>things even more confusing, MySQL will treat <code>REAL</code> as the <a id="_idIndexMarker157"/>same as a <code>DOUBLE</code> (also known as <code>DOUBLE PRECISION</code> and <code>DECIMAL</code>) column.</p>
<p>Internally, Sequelize <a id="_idIndexMarker158"/>handles <code>FLOAT</code>, <code>REAL</code>, and <code>DOUBLE</code> in the <a id="_idIndexMarker159"/>same way. There is a small float validation performed for the <code>FLOAT</code> type explicitly, but otherwise, Sequelize will translate the column type directly to the DBMS. Just as with the integer data types, <code>UNSIGNED</code> and <code>ZEROFILL</code> can be defined on these attributes as well, as follows:</p>
<pre class="source-code">
DataTypes.FLOAT.UNSIGNED.ZEROFILL</pre>
<h2 id="_idParaDest-40"><a id="_idTextAnchor048"/>DECIMAL/DOUBLE</h2>
<p>The <code>DECIMAL</code> or <code>DOUBLE</code> data <a id="_idIndexMarker160"/>type allows <a id="_idIndexMarker161"/>us to define a precise length and scale for our columns using the traditional format of <code>DECIMAL(P, S</code>) where <code>P</code> &gt; <code>S</code>. The <code>P</code> variable <a id="_idIndexMarker162"/>is the number’s precision and the <code>S</code> variable is the number’s <a id="_idIndexMarker163"/>scale. The precision determines the maximal length of the whole number part, and the scale defines the maximal length of the decimal part. For example, <code>DataTypes.DECIMAL(6, 4</code>) will give us a decimal column with a precision of 6 and a scale of 4. An example value for this column could be <code>38.3411</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You may use <code>DataTypes.NUMERIC</code> as an alias for <code>DataTypes.DECIMAL</code>.</p>
<h2 id="_idParaDest-41"><a id="_idTextAnchor049"/>BOOLEAN</h2>
<p>There are <a id="_idIndexMarker164"/>many ways <a id="_idIndexMarker165"/>to express a <code>false</code> and 1 for <code>true</code>. Sometimes, the Boolean value will be stored as a string such as <code>true</code>, <code>false</code>, <code>t</code>, or <code>f</code>. Sequelize will automatically handle numerical—or bit—values, as well as the “<code>true</code>” or “<code>false</code>” string expressions as appropriate Boolean values for Node.js. If the value is marked as “<code>t</code>” or “<code>f</code>”, then Sequelize will pass the raw value along to the programmer to handle (as a way to avoid being over presumptuous—this behavior may change in the future). A Boolean column can be defined with just <code>DataTypes.BOOLEAN</code>. There are no arguments or inputs to process for this data type.</p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor050"/>DATE/DATEONLY/TIME</h2>
<p>The <code>DATE</code> data <a id="_idIndexMarker167"/>type references the <code>DATETIME</code> column <a id="_idIndexMarker168"/>types for MySQL, MariaDB, and <a id="_idIndexMarker169"/>SQLite. For Postgres, the <code>DATE</code> data type <a id="_idIndexMarker170"/>will be translated as <code>TIMESTAMP WITH TIME ZONE</code>. </p>
<p>In MySQL, you <a id="_idIndexMarker171"/>can define fractional seconds for <code>DATETIME</code> columns <a id="_idIndexMarker172"/>by up to six digits, like so:</p>
<pre class="source-code">
DataTypes.DATE(6)</pre>
<p>If you wish to keep just the date or time, you may use <code>DataTypes.DATEONLY</code> or <code>DataTypes.TIME</code>, respectively.</p>
<p class="callout-heading">Quick note on Postgres without time zones</p>
<p class="callout">If you are using Postgres with a column type of <code>TIMESTAMP WITHOUT TIME ZONE</code>, and you know the data’s time differentiates that from the server that is running the application, it is recommended to set the time zone’s offset. This can be achieved via the <code>pg</code> Node.js library, as illustrated here:</p>
<p class="callout"><code>var types = require('pg').types</code></p>
<p class="callout"><code>function setTimestampWithoutTimezoneOffset(val) {</code></p>
<p class="callout"><code>    // '+0000' being the UTC offset, change this to the desired time zone</code></p>
<p class="callout"><code>    return val === null ? null : new Date(stringValue + '+0000');</code></p>
<p class="callout"><code>}</code></p>
<p class="callout"><code>types.setTypeParser(types.builtins.TIMESTAMP, setTimestampWithoutTimezoneOffset);</code></p>
<p class="callout">For <a id="_idIndexMarker173"/>more <a id="_idIndexMarker174"/>information <a id="_idIndexMarker175"/>on setting <a id="_idIndexMarker176"/>types <a id="_idIndexMarker177"/>for Postgres within Node.js, refer <a id="_idIndexMarker178"/>to the following link: <a href="https://github.com/brianc/node-pg-types">https://github.com/brianc/node-pg-types</a></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor051"/>NOW</h2>
<p><code>DataTypes.NOW</code> is a special <a id="_idIndexMarker179"/>type within Sequelize. It is not to be used <a id="_idIndexMarker180"/>as the column’s type but as the attribute’s value and is traditionally set as the attribute’s <code>defaultValue</code> option. If we wanted a <code>Receipt</code> model that kept track of when a transaction was made, it would look similar to this:</p>
<pre class="source-code">
Receipt.init({
    total: DataTypes.DECIMAL(10,2),
    tax: DataTypes.DECIMAL(10,2),
    dateOfPurchase: {
        type: DataTypes.DATE,
        defaultValue: DataTypes.NOW
    }
}, {
    sequelize,
    modelName: 'Receipt'
});</pre>
<p>Whenever <a id="_idIndexMarker181"/>we insert a <code>Receipt</code> record, Sequelize will automatically <a id="_idIndexMarker182"/>convert the <code>dateOfPurchase</code> attribute’s value to the DBMS’ <code>NOW()</code> function from the attribute’s <code>defaultValue</code> option using Sequelize’s <code>DataTypes.NOW</code> data type. If we have defined a value for the attribute initially, then Sequelize will use that value instead.</p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor052"/>HSTORE</h2>
<p><code>HSTORE</code> is for <a id="_idIndexMarker183"/>Postgres only. This data type is used for mapped key-value types but is often <a id="_idIndexMarker184"/>replaced by <code>JSON</code> or <code>HSTORE</code>, there is a caveat to keep <a id="_idIndexMarker185"/>in mind, which is to install the <code>pg-hstore</code> Node.js library. The full installation command would look like this:</p>
<pre>npm install --save sequelize pg pg-hstore</pre>
<p>For selecting data, in Sequelize, your <code>where</code> clause would be an object instead of an integer, string, and so on. An example would look like this:</p>
<pre class="source-code">
MyModel.find({
  where: {
    myHstoreColumn: {
      someFieldKey: 'value',
    }
  }
});</pre>
<h2 id="_idParaDest-45"><a id="_idTextAnchor053"/>JSON</h2>
<p>The <code>JSON</code> data type <a id="_idIndexMarker186"/>is available for SQLite, MariaDB, MySQL, and Postgres. When defining an attribute with the <code>JSON</code> type, you can query <a id="_idIndexMarker187"/>information similar to how the <code>HSTORE</code> type is queried, with the exception of having the ability to deeply nest your search clause. Let us say we had the following <code>JSON</code> data type stored in a column:</p>
<pre class="source-code">
{
    "someKey": {
        "deeply": {
            "nested": true
        }
    }
}</pre>
<p>We would search for the nested value like so:</p>
<pre class="source-code">
MyModel.find({
    where: {
        myJsonColumn: {
            someKey: { deeply: { nested: true } }
        }
    }
});</pre>
<p>Please <a id="_idIndexMarker188"/>note that MySQL and MariaDB introduced support for <code>DataTypes.JSON</code> attribute type will not be compatible with your database. To resolve this issue, you can define models with getters/setters that will store and retrieve the JSON document, like so:</p>
<pre class="source-code">
sequelize.define('MyModel', {
    myJsonColumn: {
        type: DataTypes.TEXT,
        get: function () {
            return JSON.parse(this.getDataValue('value'));
        },
        set: function (val) {
            this.setDataValue('value',JSON.stringify(val));
        }
    }
});</pre>
<p class="callout-heading">Note</p>
<p class="callout">For <a id="_idIndexMarker189"/>users of MSSQL 2016 and above, please refer to <a href="https://sequelize.org/master/manual/other-data-types.xhtml#mssql">https://sequelize.org/master/manual/other-data-types.xhtml#mssql</a> as a workaround for handling JSON column types with this DBMS.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor054"/>JSONB</h2>
<p>The <code>JSONB</code> data type <a id="_idIndexMarker190"/>is reserved for Postgres only. If you are using a JSON <a id="_idIndexMarker191"/>column for storage, it is recommended to use the <code>JSON</code> column type, and if you are using comparison operators on the column, it is recommended to use the <code>JSONB</code> column type.</p>
<p>Other than the previously mentioned way of querying JSON data, you can also query JSONB data types with the following formats:</p>
<pre class="source-code">
<strong class="bold">// String matching</strong>
MyModel.find({
  where: {
    "someKey.deeply.nested": {
      [Op.eq]: true
    }
  }
});
<strong class="bold">// Using the Op.contains operator</strong>
MyModel.find({
  where: {
    someKey: {
      [Op.contains]: {
        deeply: {
          nested: true
        }
      }
    }
  }
});</pre>
<h2 id="_idParaDest-47"><a id="_idTextAnchor055"/>BLOB</h2>
<p>Several <a id="_idIndexMarker192"/>databases, including MySQL, offer a range <a id="_idIndexMarker193"/>of <code>BLOB</code> attribute type, Postgres will always be converted into a <code>bytea</code> (byte array) column type. This data type is useful for storing anything binary-related, such as images, documents, or serialized data. You can see an example of it in use here:</p>
<pre class="source-code">
DataTypes.BLOB // BLOB
DataTypes.BLOB('tiny') // TINYBLOB
DataTypes.BLOB('medium') // MEDIUMBLOB
DataTypes.BLOB('long') // LONGBLOB</pre>
<p>Here is <a id="_idIndexMarker195"/>a table of different <code>BLOB</code> types with their <a id="_idIndexMarker196"/>byte prefix length and their maximum storage length for MySQL:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>BLOB Type</p>
</td>
<td class="No-Table-Style">
<p>Byte Prefix Length</p>
</td>
<td class="No-Table-Style">
<p>Maximum Storage (in bytes)</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>TINYBLOB</p>
</td>
<td class="No-Table-Style">
<p>1 byte</p>
</td>
<td class="No-Table-Style">
<p>2^8 - 1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>BLOB</p>
</td>
<td class="No-Table-Style">
<p>2 bytes</p>
</td>
<td class="No-Table-Style">
<p>2^16 - 1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>MEDIUMBLOB</p>
</td>
<td class="No-Table-Style">
<p>3 bytes</p>
</td>
<td class="No-Table-Style">
<p>2^24-1</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>LONGBLOB</p>
</td>
<td class="No-Table-Style">
<p>4 bytes</p>
</td>
<td class="No-Table-Style">
<p>2^32 - 1</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Figure">RANGE</p>
<p><code>RANGE</code> data types <a id="_idIndexMarker197"/>are reserved for Postgres only. Supported range <a id="_idIndexMarker198"/>types are <code>INTEGER</code>, <code>BIGINT</code>, <code>DATE</code>, <code>DATEONLY</code>, and <code>DECIMAL</code>. You may define an attribute with the range type like so:</p>
<pre class="source-code">
var MyModel = sequelize.define('MyModel', {
    myRangeColumn: DataTypes.RANGE(DataTypes.INTEGER)
});</pre>
<p>There are a couple of ways to create ranges for our models, as illustrated here:</p>
<pre class="source-code">
// inclusive boundaries are the default for Sequelize
   var inclusiveRange = [10, 20];
MyModel.create({ myRangeColumn: inclusiveRange });
// inclusion may be toggled with a parameter
   var range = [
    { value: 10, inclusive: false },
    { value: 20, inclusive: true }
];
MyModel.create({ myRangeColumn: range });</pre>
<p>When <a id="_idIndexMarker199"/>querying a range column, the data for that attribute will always <a id="_idIndexMarker200"/>return in object notation with the <code>value</code> and <code>inclusive</code> keys.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor056"/>UUID/UUIDV1/UUIDV4</h2>
<p>A <code>UUIDV1</code>/<code>UUIDV4</code> data types work in conjunction <a id="_idIndexMarker206"/>with the <code>UUID</code> attribute type. We can declare a model <a id="_idIndexMarker207"/>that has <a id="_idIndexMarker208"/>a default <code>UUIDV4</code> value <a id="_idIndexMarker209"/>as its <strong class="bold">primary key</strong> (<strong class="bold">PK</strong>) like so:</p>
<pre class="source-code">
sequelize.define('MyModel', {
    id: {
        type: DataTypes.UUID,
        defaultValue: DataTypes.UUIDV4,
        allowNull: false,
        primaryKey: true
    }
});</pre>
<h2 id="_idParaDest-49"><a id="_idTextAnchor057"/>VIRTUAL</h2>
<p>The <code>VIRTUAL</code> attribute <a id="_idIndexMarker210"/>type is a special type that will hydrate the <a id="_idIndexMarker211"/>data within Sequelize but will not populate the data into the database. The <code>VIRTUAL</code> field could be used for organizing code, validations, and extending Sequelize to any protocol or framework that requires <a id="_idIndexMarker212"/>nested typing (for example, GraphQL, <strong class="bold">Protocol Buffers</strong> (<strong class="bold">Protobuf</strong>), and so on), which is covered in <a href="B17841_09.xhtml#_idTextAnchor177"><em class="italic">Chapter 9</em></a>, <em class="italic">Using and Creating Adapters</em>.</p>
<p>We can define a <code>VIRTUAL</code> attribute like so:</p>
<pre class="source-code">
sequelize.define('MyModel', {
    envelope: DataTypes.STRING,
    message: {
        type: DataTypes.VIRTUAL,
        set: function(val) {
            // the following line is optional
            // but required if you wish to use the
               validation associated with the attribute
            this.setDataValue('message', val);
            this.setDataValue('envelope', 
                               encryptTheMessage(val));
        },
        validate: {
            noDadJokes: function(val) {
                if (val === "knock knock") {
                    throw new Error("Who is there? Not this 
                                     message")
                }
            }
        }
    }
});</pre>
<p>For <a id="_idIndexMarker213"/>retrieving <code>VIRTUAL</code> attributes, we would <a id="_idIndexMarker214"/>need to define a data type as a parameter for the <code>DataTypes.VIRTUAL</code> invocation. If we want to pass through other attributes within our <code>VIRTUAL</code> attribute, we would define a list as the second parameter. An example is shown here:</p>
<pre class="source-code">
sequelize.define('MyModel', {
    envelope: DataTypes.STRING,
    message: {
        type: DataTypes.VIRTUAL(DataTypes.STRING, ['en
        velope']),
        get: function() {
            return decryptTheMessage(this.get('envelope'));
        },
        set: function(val) {
            this.setDataValue('envelope', 
                               encryptTheMessage(val));
        }
    }
});</pre>
<h2 id="_idParaDest-50"><a id="_idTextAnchor058"/>ENUM</h2>
<p>Sequelize <a id="_idIndexMarker215"/>has a <code>DataTypes.ENUM</code> attribute type for enumerated <a id="_idIndexMarker216"/>columns. At the moment, only Postgres has this feature enabled. A solution for other database engines would be to define a custom validation rule for your model that performs some sort of inclusion operator. Custom <a id="_idIndexMarker217"/>validations for our models will be discussed in the next chapter. There <a id="_idIndexMarker218"/>are three different ways of defining enumerated attributes, as illustrated here:</p>
<pre class="source-code">
// Defining enums with function arguments
DataTypes.ENUM('a', 'b')
// Defining enums with an array argument
DataTypes.ENUM(['a', 'b'])
// Defining enums with an object argument
DataTypes.ENUM({
    values: ['a', 'b']
})</pre>
<h2 id="_idParaDest-51"><a id="_idTextAnchor059"/>ARRAY</h2>
<p><code>ARRAY</code> attribute <a id="_idIndexMarker219"/>types are supported for Postgres <a id="_idIndexMarker220"/>only at the moment. This type requires a parameter of an applicable data type. You can see an example here:</p>
<pre class="source-code">
DataTypes.ARRAY(DataTypes.STRING) // text[]
DataTypes.ARRAY(DataTypes.DECIMAL) // double precision[]</pre>
<h2 id="_idParaDest-52"><a id="_idTextAnchor060"/>GEOMETRY</h2>
<p>Sequelize <a id="_idIndexMarker221"/>can handle geometric data for MariaDB, MySQL, and <a id="_idIndexMarker222"/>Postgres (as long as the PostGIS extension <a id="_idIndexMarker223"/>is enabled). The <strong class="bold">GeoJSON</strong> specification (<a href="https://tools.ietf.org/html/rfc7946">https://tools.ietf.org/html/rfc7946</a>) can be useful for querying geometric data for an airline business. For example, we can mark the coordinates of an airport and the current location of an airplane to determine the estimated time of arrival without manually memorizing <a id="_idIndexMarker224"/>the Haversine algorithm (a formula to determine the <a id="_idIndexMarker225"/>distance between two points on a sphere). Reference examples can be found in the following code snippet:</p>
<pre class="source-code">
var MyModel = sequelize.define('MyModel', {
    point: DataTypes.GEOMETRY('POINT'),
    polygon: DataTypes.GEOMETRY('POLYGON')
});
var point = {
    type: 'Point',
    coordinates: [44.386815, -82.755759]
}
var polygon = { type: 'Polygon', coordinates: [
    [
        [100.0, 0.0], [101.0, 0.0], [101.0, 1.0],
        [100.0, 1.0], [100.0, 0.0]
    ]
]};
await MyModel.create({ point, polygon });</pre>
<p>In the preceding snippet, we first define our model with two attributes (<code>point</code> and <code>polygon</code>) with the <a id="_idIndexMarker226"/>respective geometry data types (for a complete list, you may reference the <strong class="bold">Request for Comments</strong> (<strong class="bold">RFC</strong>) manual previously mentioned). Then, we create our geometric objects with a set of defined values (a point will accept two coordinates, and a polygon can accept N coordinates). The last line will create an entry with the defined values for the corresponding attribute.</p>
<p class="callout-heading">Note</p>
<p class="callout">GeoJSON is <a id="_idIndexMarker227"/>handled differently depending on whether we are using the Postgres or MariaDB/MySQL dialect. The Postgres dialect will call the <code>ST_GeomFromGeoJSON</code> function for interpretation of GeoJSON, and MariaDB/MySQL will use the <code>GeomFromText</code> function. The following reference goes into detail on spatial columns with MySQL: <a href="https://dev.mysql.com/doc/refman/5.7/en/spatial-types.xhtml">https://dev.mysql.com/doc/refman/5.7/en/spatial-types.xhtml</a>.</p>
<h2 id="_idParaDest-53"><a id="_idTextAnchor061"/>GEOGRAPHY</h2>
<p>For MariaDB/MySQL, the <code>GEOGRAPHY</code> attribute type will work the same as the <code>GEOMETRY</code> type, but <a id="_idIndexMarker228"/>for Postgres, Sequelize will utilize PostGIS’ geography <a id="_idIndexMarker229"/>data type. The <code>GEOGRAPHY</code> attribute type follows the same GeoJSON syntax as the <code>GEOMETRY</code> type.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you are looking for a complete set of utility functions and querying complex relationships between several coordinates, then the <code>GEOMETRY</code> type is recommended over the <code>GEOGRAPHY</code> type. If you need to use geodetic measurements instead of Cartesian measurements, or if you have simpler relationships over large areas, then the <code>GEOGRAPHY</code> type would be more applicable to you. </p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor062"/>CIDR/INET/MACADDR</h2>
<p>These <a id="_idIndexMarker230"/>three <a id="_idIndexMarker231"/>attribute <a id="_idIndexMarker232"/>types are for Postgres only. All <a id="_idIndexMarker233"/>of these <a id="_idIndexMarker234"/>types perform some type of <a id="_idIndexMarker235"/>internal validation respective to the type. These types do not have an input parameter. The following are brief explanations, with references, for each of these data types:</p>
<ul>
<li><code>CIDR</code>—This stands for <strong class="bold">Classless Inter-Domain Routing</strong> and <a id="_idIndexMarker236"/>is used for <a id="_idIndexMarker237"/>allocating <strong class="bold">Internet Protocol</strong> (<strong class="bold">IP</strong>) addresses and route tables (<a href="https://datatracker.ietf.org/doc/html/rfc4632">https://datatracker.ietf.org/doc/html/rfc4632</a>)</li>
<li><code>INET</code>—Common ways of identifying over the net (<a href="https://datatracker.ietf.org/doc/html/rfc6991">https://datatracker.ietf.org/doc/html/rfc6991</a>)</li>
<li><code>MACADDR</code>—<strong class="bold">Unique identifiers</strong> (<strong class="bold">UIDs</strong>) for <a id="_idIndexMarker238"/>network interfaces (<a href="https://www.rfc-editor.org/rfc/rfc7042.xhtml">https://www.rfc-editor.org/rfc/rfc7042.xhtml</a>)</li>
</ul>
<h2 id="_idParaDest-55"><a id="_idTextAnchor063"/>TSVECTOR</h2>
<p>The <code>TSVECTOR</code> data type <a id="_idIndexMarker239"/>is used for searching through text columns with <a id="_idIndexMarker240"/>advanced operators available in Postgres’ <code>to_tsquery()</code> function. These operators include wildcard matching, negate matching, and Boolean search. This attribute type is for Postgres only and will only accept string variables for values. When querying a <code>TSVECTOR</code> attribute, Sequelize will not interpret the attribute type with its associated functions implicitly (for example, <code>to_tsvector</code>). Let’s suppose we have the following model definition:</p>
<pre class="source-code">
var MyModel = sequelize.define('MyModel', {
    col: DataTypes.TSVECTOR
});
MyModel.create({
    col: 'The quick brown fox jumps over the lazy dog'
});</pre>
<p>Then, we want to query a value on the <code>col</code> field, like so:</p>
<pre class="source-code">
MyModel.find({
    where: { col: 'fox' }
});</pre>
<p>The generated SQL would look similar to this:</p>
<pre class="source-code">
SELECT * FROM MyModel WHERE col = 'fox';</pre>
<p>Sequelize will interpret this query with an equals operator for the <code>where</code> clause. In order to take advantage of the <code>TSVECTOR</code> column type, we would have to be explicit with our intentions, like so:</p>
<pre class="source-code">
MyModel.find({
    where: {
        col: {
            [Op.match]: sequelize.fn('to_tsvector', 'fox')
        }
    }
});</pre>
<p>This will <a id="_idIndexMarker241"/>convert the <code>where</code> clause’s operator from equal to matching (<code>@@</code>). The <code>sequelize.fn</code> method allows you to explicitly invoke a function from <a id="_idIndexMarker242"/>your DBMS. The query generated by this procedure would look like this:</p>
<pre class="source-code">
SELECT * FROM MyModel WHERE col @@ to_tsvector('fox');</pre>
<p>After learning how to define our model and which data types are available to us in Sequelize, we can now begin migrating our definitions to an actual database. Sequelize offers a migration subcommand within its command-line tool, to make this easy for us. </p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor064"/>Migrating schematic changes and data from Sequelize to the database</h1>
<p>We have <a id="_idIndexMarker243"/>defined our database’s <a id="_idIndexMarker244"/>schema with <a id="_idIndexMarker245"/>the generated files from the command-line tool, and we are now ready to migrate those definitions to our DBMS. Using Sequelize’s migrations can help teams of developers maintain the same schema structure across multiple machines. Migrations can provide a historical reference as to how your database has changed over time, which can also help us undo certain changes and revert our database’s schema to a specific time.</p>
<h2 id="_idParaDest-57"><a id="_idTextAnchor065"/>Migrating schematic changes</h2>
<p>The Sequelize CLI provides a convenient way of propagating updates toward a database. All of our <a id="_idIndexMarker246"/>schematic changes will be located within the <code>migrations</code> directory, and all of our data seeds will be located within the <code>seeders</code> directory. This chapter will cover only the initialization of the database’s structure. In subsequent chapters, there will be examples of adding and removing columns (or indices) using the migration tool.</p>
<p>In the <em class="italic">Defining models for a database</em> section, we used the Sequelize CLI to generate our models, which should have created several files in the <code>migrations</code> directory. Each file is prefixed with <a id="_idIndexMarker247"/>a timestamp, a <code>create</code>), and the model’s name. An example for one of the files (<code>20210914153156-create-airplane.js</code>) would look like this:</p>
<pre class="source-code">
'use strict';
module.exports = {
  up: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.createTable('Airplanes', {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER
      },
      planeModel: {
        type: Sequelize.STRING
      },
      totalSeats: {
        type: Sequelize.INTEGER
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE
      }
    });
  },
  down: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.dropTable('Airplanes');
  }
};</pre>
<p>Sequelize will <a id="_idIndexMarker248"/>use the scope of the <code>up(…)</code> method when we invoke the <code>migrations</code> subcommand. The <code>down(…)</code> method is reserved for when we decide <a id="_idIndexMarker249"/>to undo, or revert, a migration. The <strong class="bold">query interface</strong> is a database-agnostic adapter that executes generic SQL commands that are available to all supported database engines. We will go into detail about the query interface in a later chapter.</p>
<p>You may have noticed that Sequelize has added several columns to our model’s definition. With the default settings, Sequelize will generate three additional columns, as follows:</p>
<ul>
<li><code>id</code>—A PK as an integer value with <code>autoIncrement</code> set to <code>true</code>. The <code>autoIncrement</code> flag will create a sequence value (some databases, such as MySQL, will call sequences <em class="italic">auto-increment</em> columns).</li>
<li><code>createdAt</code>—This field will generate a timestamp upon the row’s creation. Since this is a Sequelize-recognized column, the default value for this column does not require us to explicitly state <code>DataTypes.NOW</code> or any equivalent value. Sequelize will hydrate the row’s value automatically when using applicable methods such as <code>create()</code>.</li>
<li><code>updatedAt</code>—Similar to the <code>createdAt</code> field, except this value will update automatically from Sequelize every time the row is updated.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">We can prevent Sequelize from creating these attributes automatically through configuration settings. These settings will be explained in detail later in this chapter.</p>
<p>In the <a id="_idIndexMarker250"/>root directory of our project, run the following command to initialize migrations:</p>
<pre>sequelize db:migrate</pre>
<p>This command will perform several more instructions than iterating through the <code>migrations</code> directory. Sequelize will first look for a table called <code>SequelizeMeta</code> that holds meta information on which files have already been processed through the <code>migrations</code> subcommand. After the table has been found or created, Sequelize will iterate through the <code>migrations</code> table in sequential order of the file’s name (timestamps are a convenient way of maintaining this order) and skip any files found within the <code>SequelizeMeta</code> table. </p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>sequelize-cli</code> <code>db:migrate</code> and <code>db:seed</code> commands will use the <code>NODE_ENV</code> environmental variable to determine where to migrate/initialize data to. As an alternative, you can state which database to connect to with the <code>--url</code> option, like so: <code>sequelize db:migrate --url 'mysql://user:password@host.com/database'</code>.</p>
<p>If we made a mistake on a model’s definition, after migration, we always have the option to revert our changes, like so:</p>
<pre>sequelize db:migrate:undo</pre>
<p>This will revert the last migration performed by Sequelize. If we want to undo all of our changes, there is another subcommand, shown here:</p>
<pre>sequelize db:migrate:undo:all</pre>
<p>If we want to revert all of our migrations up until a certain point (this is why prefixing your filenames with a timestamp is important for congruity), we can run the following command:</p>
<pre>sequelize db:migrate:undo:all --to XXXXXXXXXXXXXX-airlines.js</pre>
<p>After <a id="_idIndexMarker251"/>the migration is completed, we should run the following commands:</p>
<pre>$ mysql -uroot airline
mysql&gt; show tables;</pre>
<p>The tables shown in the following screenshot should be displayed: </p>
<div><div><img alt="Figure 2.2 – Display of the project’s tables " height="505" src="img/Figure_2.2_B17841.jpg" width="1102"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Display of the project’s tables</p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor066"/>Initializing seed data</h2>
<p>Now that <a id="_idIndexMarker252"/>we have our schema in place, we can start populating our database with actual data by generating seeder files within the <code>seeders</code> directory. Seed data is conventionally used for initial configuration data, static information, and so on. Good thing too—our business partner just notified us that they have purchased five airplanes to help get us started. We can create seed data for these airplanes, like so:</p>
<pre>sequelize seed:generate --name initial-airplanes</pre>
<p>This will generate a file in our project’s <code>seeders</code> directory that contains the bare minimum for migrating seed data into the database. Similar to our migration files, there are only two methods exposed to the CLI: <code>up(…)</code> and <code>down(…)</code>.</p>
<p>We will <a id="_idIndexMarker253"/>replace the file’s contents with the following code:</p>
<pre class="source-code">
'use strict';
module.exports = {
  up: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.bulkInsert('Airplanes', [{
      planeModel: 'Airbus A220-100',
      totalSeats: 110,
      createdAt: new Date(),
      updatedAt: new Date()
    }, {
      planeModel: 'Airbus A220-300',
      totalSeats: 110,
      createdAt: new Date(),
      updatedAt: new Date()
    }, {
      planeModel: 'Airbus A 318',
      totalSeats: 115,
      createdAt: new Date(),
      updatedAt: new Date()
    }, {
      planeModel: 'Boeing 707-100',
      totalSeats: 100,
      createdAt: new Date(),
      updatedAt: new Date()
    }, {
      planeModel: 'Boeing 737-100',
      totalSeats: 85,
      createdAt: new Date(),
      updatedAt: new Date()
    }], {});
  },
  down: async (queryInterface, Sequelize) =&gt; {
    await queryInterface.bulkDelete('Airplanes', null, {});
  }
};</pre>
<p class="callout-heading">Note</p>
<p class="callout">Unlike <a id="_idIndexMarker254"/>Sequelize’s <code>create()</code> function, the query interface’s <code>bulkInsert()</code> method will not hydrate the <code>createdAt</code> or <code>updatedAt</code> columns automatically. If you omit these columns from the seed file, the database will return an error since the columns do not have a default value.</p>
<p>Now, we can process our seed data via the following command:</p>
<pre>sequelize db:seed:all</pre>
<p>We can confirm the changes by entering the following SQL command into our database: </p>
<pre>SELECT * FROM airplanes;</pre>
<p>We then get the following results: </p>
<div><div><img alt="Figure 2.3 – Querying a list of airplanes " height="291" src="img/Figure_2.3_B17841.jpg" width="790"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Querying a list of airplanes</p>
<p>Reverting <a id="_idIndexMarker255"/>seed data is similar to the <code>migrations</code> subcommand, as we can see here:</p>
<pre>sequelize db:seed:undo
sequelize db:seed:undo:all
sequelize db:seed:undo --seed &lt;the name of your seed file&gt;</pre>
<p class="callout-heading">Tip</p>
<p class="callout">Sequelize uses another project internally for migrations called Umzug. A full reference, and more examples on how to tune your migration cycle, can be found at the project’s GitHub repository: <a href="https://github.com/sequelize/umzug">https://github.com/sequelize/umzug</a>.</p>
<p>Once we are done inserting seed data into a database, we can now query or manipulate that data using Sequelize. The following section will provide a very brief introduction for incorporating Sequelize for an Express application following more of a reference style for Sequelize. This will help give you an idea of how we will apply Sequelize in subsequent chapters for our airline project, and enough technical knowledge to help you become comfortable with making your own adjustments.</p>
<h1 id="_idParaDest-59"><a id="_idTextAnchor067"/>Manipulating and querying data using Sequelize</h1>
<p>After <a id="_idIndexMarker256"/>initializing our database’s structure and data, we <a id="_idIndexMarker257"/>should be able to view, modify, and remove <a id="_idIndexMarker258"/>the airplanes from our dashboard. For now, we <a id="_idIndexMarker259"/>will create very naive and simple implementations for our administrative tasks, but since we are the only technical employee at <em class="italic">Avalon Airlines</em>, this will not be a problem. As we continue creating the project, we will modify our application to become more robust and function with safety measures in mind.</p>
<h2 id="_idParaDest-60"><a id="_idTextAnchor068"/>Reading data</h2>
<p>Replace <a id="_idIndexMarker260"/>the <code>app.get('/', …)</code> block with the following code (in <code>index.js</code>):</p>
<pre class="source-code">
app.get('/', async function (req, res) {
    const airplanes = await models.Airplane.findAll();
    res.send("&lt;pre&gt;" + JSON.stringify(airplanes, undefined, 
              4) + "&lt;/pre&gt;");
});</pre>
<p>After that, save the file and run our application with the following command:</p>
<pre>npm run start</pre>
<p>Now, we can visit our website at <code>http://localhost:3000</code> and should see results similar to those shown here: </p>
<div><div><img alt="Figure 2.4 – Listing our airplanes  " height="609" src="img/Figure_2.4_B17841.jpg" width="371"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Listing our airplanes </p>
<p>Now, we will <a id="_idIndexMarker261"/>create another route that will return the results to us for a <a id="_idIndexMarker262"/>specific airplane. If the airplane cannot be found, then we should send a <em class="italic">Not Found</em> <code>404</code>). Add the following route below the root <code>app.get('/', …)</code> block):</p>
<pre class="source-code">
app.get('/airplanes/:id', async function (req, res) {
    var airplane = await models.Airplane.findByPk
                   (req.params.id);
    if (!airplane) {
        return res.sendStatus(404);
    }
    res.send("&lt;pre&gt;" + JSON.stringify(airplane, undefined, 
              4) + "&lt;/pre&gt;");
});</pre>
<p>The <code>findByPk</code> method will try to find a record from the model’s PK attribute (by default, this will be Sequelize’s generated <code>id</code> column). When a record is found (for example, <a href="http://localhost:3000/airplanes/1">http://localhost:3000/airplanes/1</a>), the application will return the record to us, but if we changed the <code>id</code> parameter from <code>1</code> to <code>10</code> (<code>http://localhost:3000/airplanes/10</code>), we should receive a <em class="italic">Not Found</em> response. </p>
<p>Here is a <a id="_idIndexMarker264"/>list with a brief explanation of Sequelize functions relating to retrieving data:</p>
<ul>
<li><code>findAll</code>—Use this <a id="_idIndexMarker265"/>when you want to use the <code>where</code> clause in your query and retrieve more than one row.</li>
<li><code>findOne</code>—Similar <a id="_idIndexMarker266"/>to the <code>findAll</code> function, except that this function will return a single row.</li>
<li><code>findByPk</code>—A function <a id="_idIndexMarker267"/>that returns a single row using the model’s defined PK.</li>
<li><code>findOrCreate</code>—This function will return a single instance of the row that was either <a id="_idIndexMarker268"/>found or instantiated from the database. Sequelize will compose the attributes defined within the <code>where</code> and <code>defaults</code> key.</li>
</ul>
<h2 id="_idParaDest-61"><a id="_idTextAnchor069"/>Complex querying</h2>
<p>Sometimes, you <a id="_idIndexMarker269"/>will need more than just a simple <code>where</code> clause with an <code>AND</code> operator. Sequelize has several operators built in to help write queries with a more complex <code>where</code> clause. A full list of these operators is shown here:</p>
<ul>
<li><code>and</code>/<code>or</code>—Logical <code>AND</code> and logical <code>OR</code>. These values contain an array of <code>where</code> clause objects.</li>
<li><code>eq</code>/<code>ne</code>—Equal (<code>=</code>) or Not Equal (<code>!=</code>).</li>
<li><code>gte</code>/<code>gt</code>—Greater-Than-or-Equal (<code>&gt;=</code>) and Greater-Than (<code>&gt;</code>).</li>
<li><code>lte</code>/<code>lt</code>—Lesser-Than-or-Equal (<code>&lt;=</code>) and Lesser-Than (<code>&lt;</code>).</li>
<li><code>is</code>/<code>not</code>—<code>IS NULL</code> and <code>IS NOT TRUE</code>, respectively.</li>
<li><code>in</code>/<code>notIn</code>—<code>IN</code> and <code>NOT IN</code> operators of any array with values.</li>
<li><code>any</code>/<code>all</code>/<code>values</code>—<code>ANY</code> (Postgres only), <code>ALL</code>, and <code>VALUES</code> operators respectively.</li>
<li><code>col</code>—Converts column string values into <strong class="bold">identifiers</strong> (<strong class="bold">IDs</strong>) specified by the database/dialect.</li>
<li><code>placeholder</code>—Internal operator used by Sequelize.</li>
<li><code>join</code>—Used internally by Sequelize.</li>
<li><code>match</code>—Match operator <a id="_idIndexMarker270"/>used for text searching (Postgres only).</li>
<li><code>like</code>/<code>notLike</code>—<code>LIKE</code> and <code>NOT LIKE</code>, respectively.</li>
<li><code>iLike</code>/<code>notILike</code>—Case-insensitive version of <code>LIKE</code> and <code>NOT LIKE</code> (Postgres only).</li>
<li><code>startsWith</code>/<code>endsWith</code>—Shorthand for the <code>LIKE '%...'</code> and <code>LIKE '...%'</code> expressions.</li>
<li><code>substring</code>—Shorthand expression for <code>LIKE '%...%'</code>.</li>
<li><code>regexp</code>/<code>notRegexp</code>—<code>REGEXP</code> and <code>NOT REGEXP</code> for MySQL and Postgres only.</li>
<li><code>between</code>/<code>notBetween</code>—<code>BETWEEN x AND y</code> and <code>NOT BETWEEN x AND y</code>.</li>
<li><code>overlap</code>—Postgres-only range operator for overlap (<code>&amp;&amp;</code>).</li>
<li><code>contains</code>/<code>contained</code>—Postgres-only range operator for <code>@&gt;</code> and <code>&lt;@</code>, respectively.</li>
<li><code>Adjacent</code>—Postgres-only range operator for adjacent querying (<code>-|-</code>).</li>
<li><code>strictLeft</code>/<code>strictRight</code>—Strict operators for Postgres ranges (<code>&lt;&lt;</code> and <code>&gt;&gt;</code>).</li>
<li><code>noExtendRight</code>/<code>noExtendLeft</code>—No extension range operators for Postgres (<code>&amp;&lt; </code>and <code>&amp;&gt;</code>).</li>
</ul>
<p>Querying <a id="_idIndexMarker271"/>a complex <code>where</code> clause may look something like this:</p>
<pre class="source-code">
const { Op } = require("sequelize");
MyModel.findAll({
    where: {
        [Op.or]: [
            { status: 'active' },
            sequelize.where(sequelize.fn('lower', se
            quelize.col('name')), {
                [Op.eq]: 'bob'
            },
            {
                [Op.and]: {
                    age: {
                        [Op.gte]: 40
                    },
                    name: {
                        [Op.like]: 'mary%'
                    }
                }
            }
        }]
    }
});</pre>
<p>This <a id="_idIndexMarker272"/>will then produce the following query:</p>
<pre class="source-code">
SELECT
    ...
FROM "MyModel"
WHERE (
    status = 'active'
    OR
    lower(name) = 'bob'
    OR (
        age &gt;= 40
        AND
        name LIKE 'mary%'
    )
)</pre>
<h2 id="_idParaDest-62"><a id="_idTextAnchor070"/>Deleting data</h2>
<p>For deleting <a id="_idIndexMarker273"/>an instance (a single record), we can call a <code>destroy()</code> function, like so:</p>
<pre class="source-code">
var record = MyModel.findOne({ where: { /* ... */ } });
await record.destroy();</pre>
<p class="callout-heading">Note</p>
<p class="callout">If there is no attribute marked as a PK within your model’s definition, then Sequelize may not delete the correct record. The instance’s <code>destroy()</code> method would be called with a <code>where</code> clause that tried to match all of the instance’s attributes. This could lead to unintentional deletions.</p>
<p>To delete <a id="_idIndexMarker274"/>multiple rows at once, execute the following code:</p>
<pre class="source-code">
MyModel.destroy({ where: { name: 'Bob' }});</pre>
<p>You can remove all of a table’s data by passing a configuration option to the <code>destroy()</code> method, like so:</p>
<pre class="source-code">
await MyModel.destroy({ truncate: true });
// or
await MyModel.truncate();</pre>
<h2 id="_idParaDest-63"><a id="_idTextAnchor071"/>Updating and saving data</h2>
<p>Sequelize <a id="_idIndexMarker275"/>offers a few ways of updating attributes/data, depending <a id="_idIndexMarker276"/>on where you are updating from. If you wish to update multiple rows, we could use the model’s <code>update()</code> function, like so:</p>
<pre class="source-code">
await MyModel.update({ name: "John" }, {
  where: { name: null }
});</pre>
<p>This query will update all of the records’ names to <code>John</code>, where the current value is <code>NULL</code>. For updating a specific instance, we would change the attribute’s value and then call the <code>save()</code> function, as follows:</p>
<pre class="source-code">
var record = MyModel.findOne();
record.name = "John";
await record.save();</pre>
<p>If you are in the middle of changing a record’s attributes and your workflow requires you to reset the record’s data back to the original values (without touching the database), you may do so with the <code>reload()</code> method, as follows:</p>
<pre class="source-code">
var record = MyModel.findOne({ where: { name: 'John' } });
record.name = "Bob";
record.reload();
// the record.name attribute's value is now back to John</pre>
<h2 id="_idParaDest-64"><a id="_idTextAnchor072"/>Creating data</h2>
<p>To create <a id="_idIndexMarker277"/>a single row, the code for Sequelize would look similar to this:</p>
<pre class="source-code">
await MyModel.create({ firstName: 'Bob' }, { ... });</pre>
<p>The second parameter accepts the following options for <code>create()</code>: </p>
<ul>
<li><code>raw</code>—If this <a id="_idIndexMarker278"/>Boolean value is set to <code>true</code>, then Sequelize <a id="_idIndexMarker279"/>will ignore the <strong class="bold">virtual setter attributes</strong> within the model’s definition. This is useful when you want to skip transforming the data through setter functions and wish to use the raw values that are provided from the query directly instead.</li>
<li><code>isNewRecord</code>—A Boolean <a id="_idIndexMarker280"/>value that can enable (if set to <code>true</code>) Sequelize’s behavior for applying default values, updating a timestamp column, and so on. The default value for this method is <code>true</code>.</li>
<li><code>include</code>—An array <a id="_idIndexMarker281"/>containing include options for Sequelize. This book will provide examples and further details in a later chapter.</li>
<li><code>fields</code>—An array <a id="_idIndexMarker282"/>of strings containing column names that will filter which attributes will be updated, validated, and saved.</li>
<li><code>silent</code>—If this <a id="_idIndexMarker283"/>value is set to <code>true</code>, then Sequelize will not update the <code>updatedAt</code> timestamp column.</li>
<li><code>validate</code>—A Boolean <a id="_idIndexMarker284"/>value to toggle whether or not to execute validations.</li>
<li><code>hooks</code>—A Boolean <a id="_idIndexMarker285"/>value that enables/disables running before/after <code>create</code>, <code>update</code>, and <code>validate</code> life cycle events.</li>
<li><code>logging</code>—A function <a id="_idIndexMarker286"/>that will pass down the query’s statement.</li>
<li><code>benchmark</code>—Logs <a id="_idIndexMarker287"/>execution query time (in milliseconds) and will be passed as the second parameter for the <code>logging</code> function.</li>
<li><code>transaction</code>—You <a id="_idIndexMarker288"/>may pass a transaction Sequelize instance for this option.</li>
<li><code>searchPath</code>—Postgres-only <a id="_idIndexMarker289"/>option for defining which <code>search_path</code> to use when querying.</li>
<li><code>returning</code>—Postgres-only <a id="_idIndexMarker290"/>option for selecting which fields to return when creating a new record. A Boolean <code>true</code> value will return all of the fields, but an array of strings will filter which columns to return.</li>
</ul>
<p>Bulk-inserting <a id="_idIndexMarker291"/>data is very similar to creating a single row with Sequelize. The following code snippet illustrates an example of this:</p>
<pre class="source-code">
await MyModel.bulkCreate([
    { firstName: 'Bob' },
    { firstName: 'William' }
], {...});</pre>
<p>The first parameter is an array of values, and the second parameter is for configuration options. These options are identical to the <code>create()</code> method: <code>fields</code>, <code>validate</code>, <code>hooks</code>, <code>transaction</code>, <code>logging</code>, <code>benchmark</code>, <code>returning</code>, and <code>searchPath</code>. In addition, the <code>bulkCreate()</code> method also offers us the following options:</p>
<ul>
<li><code>individualHooks</code>—Executed <a id="_idIndexMarker292"/>before/after create life cycle events for each record individually. This does not affect bulk before/after life cycle events.</li>
<li><code>ignoreDuplicates</code>—Ignores duplicated rows by any constrained key defined <a id="_idIndexMarker293"/>on the table. This feature is not supported on MSSQL or Postgres versions below 9.5.</li>
<li><code>k</code>—An array <a id="_idIndexMarker294"/>of fields to update if there is a duplicated key entry (for MySQL/MariaDB, SQLite 3.24.0+, and Postgres 9.5+ only).</li>
</ul>
<h2 id="_idParaDest-65"><a id="_idTextAnchor073"/>Ordering and grouping</h2>
<p>When <a id="_idIndexMarker295"/>sifting through your data, you can order (or group) your columns like so:</p>
<pre class="source-code">
MyModel.findAll({
    where: { name: 'Bob' },
    order: [
        ['name', 'DESC']
    ]
});</pre>
<p>For grouping, depending <a id="_idIndexMarker296"/>on which database you are using, you may have different results from other database engines (such as requiring you to select only aggregated functions and grouped columns). Consult your database’s documentation for the specific nuances and rules that are required for grouping. Here is an example of a simple <code>GROUP BY</code> statement:</p>
<pre class="source-code">
MyModel.findAll({ group: 'name' });</pre>
<p class="callout-heading">Caution</p>
<p class="callout">Sequelize will treat the group’s input as a literal value. If you are grouping by user-generated <a id="_idIndexMarker297"/>content, it is highly recommended to escape your value to avoid SQL injections (<a href="https://en.wikipedia.org/wiki/SQL_injection">https://en.wikipedia.org/wiki/SQL_injection</a>). You may escape values using the <code>sequelize.escape('...');</code> method.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor074"/>Limits and pagination</h2>
<p>We can <a id="_idIndexMarker298"/>simply use the <code>offset</code> and <code>limit</code> key values for our <a id="_idIndexMarker299"/>finder methods, like so:</p>
<pre class="source-code">
MyModel.findAll({ offset: 5, limit: 10 });</pre>
<p>This will select from the <code>MyModel</code> table with a limit of 10 and an offset of 5.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>limit</code> property will tell the database to only retrieve that number of rows (in MSSQL, this would be <code>SELECT TOP N</code> or <code>FETCH NEXT N ROWS</code>). The <code>offset</code> property will skip N rows before retrieving the results. For MSSQL 2008 (and earlier) users, Sequelize will offer offset support by nesting queries to simulate offset behavior for compatibility and completeness.</p>
<p>Now that we have finished referencing Sequelize’s methodologies for querying and manipulating data, we can now go over the more advanced options when defining a model. These options can change the way Sequelize will transform data internally, filter queried data, and adjust naming conventions, allowing you to better adapt Sequelize’s behavior to your company/project’s requirements. </p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor075"/>Advanced Sequelize options for defining models</h1>
<p>When <a id="_idIndexMarker300"/>defining a model, within Sequelize, the last input parameter for the <code>init()</code> and <code>define()</code> methods offers us a way to fine-tune our project’s requirements and Sequelize’s behavior. These parameter options are useful for situations such as when we need to construct Sequelize in a pre-existing environment that does not adhere to Sequelize’s naming conventions (for example, a column named <code>PersonIsMIA</code> as opposed to Sequelize’s <code>"PersonIsMia"</code> convention).</p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor076"/>sequelize</h2>
<p>A copy (or new) instance of Sequelize to associate with the model. Sequelize will return an error <a id="_idIndexMarker301"/>if this field is not provided (except when using the <code>sequelize.define</code> method). Useful for querying across data centers or even databases.</p>
<h2 id="_idParaDest-69"><a id="_idTextAnchor077"/>modelName</h2>
<p>Explicitly <a id="_idIndexMarker302"/>defines the model’s name with a string. This would be the first parameter in Sequelize’s <code>define()</code> method. If you are using ES6 class definitions, the default for this value would be the class name.</p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor078"/>defaultScope/scopes</h2>
<p>An object <a id="_idIndexMarker303"/>for values that will set the <a id="_idIndexMarker304"/>model’s default scope and set applicable scopes for the model, respectively. Scopes can be useful for code organization or enforcing a basic access control list as a default behavior. We will go into detail about scoping in a later chapter.</p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor079"/>omitNull</h2>
<p>Setting <a id="_idIndexMarker305"/>this Boolean value to <code>true</code> will tell Sequelize to omit any columns that have a <code>null</code> value when saving a record.</p>
<h2 id="_idParaDest-72"><a id="_idTextAnchor080"/>timestamps</h2>
<p>This option <a id="_idIndexMarker306"/>allows us to control Sequelize’s behavior for adding <code>createdAt</code> and <code>updatedAt</code> timestamp columns for the model. The default value for this setting is <code>true</code> (Sequelize will create timestamp columns).</p>
<p class="callout-heading">Note</p>
<p class="callout">You can always override the default settings for the <code>createdAt</code> and <code>updatedAt</code> attributes by defining them explicitly within your model. Sequelize will know to use those attributes for timestamp-related columns.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor081"/>paranoid</h2>
<p>This <a id="_idIndexMarker307"/>Boolean option, when set to <code>true</code>, will prevent Sequelize from deleting the data (by default) and adds a <code>deletedAt</code> timestamp column. The <code>timestamps</code> option must be set to <code>true</code> in order to make <code>paranoid</code> applicable. The default value for <code>paranoid</code> is <code>false</code>.</p>
<p>The following query will perform a “soft deletion”:</p>
<pre class="source-code">
await Post.destroy({
  where: {
    id: 1
  }
});</pre>
<p>This query will update the <code>Post</code> record of ID 1 and update the <code>deletedAt</code> column. If we wanted to remove the record from the database (instead of updating it), we would use the <code>force</code> parameter, as illustrated in the following code snippet:</p>
<pre class="source-code">
await Post.destroy({
  where: {
    id: 1
  },
  force: true
});</pre>
<p>This would perform a <code>delete</code> query versus an <code>update</code> query on the database.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor082"/>createdAt/updatedAt/deletedAt</h2>
<p>This <a id="_idIndexMarker308"/>option will rename the <code>createdAt</code>, <code>updatedAt</code>, and <code>deletedAt</code> attributes, respectively. If you provide camel-cased <a id="_idIndexMarker309"/>values and the underscored option <a id="_idIndexMarker310"/>is set to <code>true</code>, Sequelize will automatically convert the column’s casing. Setting the value as <code>false</code> instead of a string will tell Sequelize to disable its default behavior for that respective column.</p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor083"/>underscored</h2>
<p>By default, Sequelize <a id="_idIndexMarker311"/>will create columns using camel case (for example, <code>updatedAt</code>, <code>firstName</code>, and so on). If you prefer underscores or snake case (for example, <code>updated_at</code>, <code>first_name</code>, and so on), then you would set this value to <code>true</code>.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor084"/>freezeTableName</h2>
<p>As <a id="_idIndexMarker312"/>previously mentioned, Sequelize will pluralize table names derived from the model’s name by default. Setting this value to <code>true</code> would prevent Sequelize from transforming the table’s name.</p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor085"/>tableName</h2>
<p>Explicitly <a id="_idIndexMarker313"/>defines the table name for Sequelize to use when creating SQL queries. A typical use case for this option is when you are integrating Sequelize into a pre-existing database/schema or when the pluralization is incorrectly set.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor086"/>name</h2>
<p>An object <a id="_idIndexMarker314"/>with two available options to define singular and plural names to use when associating this model with others. A clearer explanation, and an example, will be provided when we go over model associations and relations in a later chapter, but you can see an overview of the two options here:</p>
<ul>
<li><code>singular</code>—The name to use when referencing a single instance from a model (defaults to <code>Sequelize.Utils.singularize(modelName)</code>)</li>
<li><code>pluralize</code>—The name to use when referencing multiple instances of a model (defaults to <code>Sequelize.Utils.pluralize(modelName)</code>)</li>
</ul>
<h2 id="_idParaDest-79"><a id="_idTextAnchor087"/>schema</h2>
<p>Defines <a id="_idIndexMarker315"/>the model’s schema (this would be referenced as <code>search_path</code> in Postgres). Not all databases support schemas, and some will refer to schemas as databases entirely.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor088"/>engine</h2>
<p>Applicable <a id="_idIndexMarker316"/>to MySQL only, this is where you can define your table’s engine type (typically <code>InnoDB</code> or <code>MyISAM</code>). The default is <code>InnoDB</code>.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor089"/>charset</h2>
<p>Specifies the <a id="_idIndexMarker317"/>table’s charset. Useful for when your table’s contents can be deterministically defined to a set of characters that could help reduce database size (if you do not need universal encodings and only Latin characters, then you would use a Latin-derived charset).</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor090"/>collation</h2>
<p>Specifies <a id="_idIndexMarker318"/>the table’s collation (sorting and ordering rules for the characters).</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor091"/>comment</h2>
<p>Adds a <a id="_idIndexMarker319"/>comment to the table (if applicable to the DBMS).</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor092"/>initialAutoIncrement</h2>
<p>Sets <a id="_idIndexMarker320"/>the initial <code>AUTO_INCREMENT</code> value for applicable dialects (MySQL and MariaDB).</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor093"/>hooks</h2>
<p>An object <a id="_idIndexMarker321"/>with keys mapped to hooks (or life cycle events). The values may be a function or an array of functions. We will go into details about hooks in a later chapter.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor094"/>validate</h2>
<p>An object <a id="_idIndexMarker322"/>to define model validations. We will go into detail about validations in the next chapter.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor095"/>indexes</h2>
<p>An array <a id="_idIndexMarker323"/>of objects that define table indices’ definitions. These indices are created when calling <code>sync()</code> or using the migration tool. Each object has the following options:</p>
<ul>
<li><code>name</code>—The name of the index (Sequelize will default to the model’s name and applicable fields joined by an underscore).</li>
<li><code>type</code>—A string value for defining the index’s type (only for MySQL/MariaDB). Typically, this is where you would define <code>FULLTEXT</code> or <code>SPATIAL</code> indices (<code>UNIQUE</code> as well, but there is a dialect-agnostic option for creating unique indices).</li>
<li><code>unique</code>—Setting this value to true would create a unique index.</li>
<li><code>using</code>—The <code>USING</code> clause value for the index’s SQL statement. A few examples would be <code>BTREE</code> (typically, a DBMS will use this index type as the default), <code>HASH</code> (MySQL/MariaDB/Postgres only), and <code>GIST</code>/<code>GIN</code> (Postgres only).</li>
<li><code>operator</code>—Defines an operator to use for this index (primarily used for Postgres but can be used in other dialects).</li>
<li><code>concurrently</code>—Setting this to <code>true</code> offers a way of creating indices without writing locks (Postgres only).</li>
<li><code>fields</code>—An array of index fields to define for the model. Refer to the <em class="italic">Index fields</em> section, next.</li>
</ul>
<h3>Index fields</h3>
<p>Each <a id="_idIndexMarker324"/>index definition’s fields value can be one of the following:</p>
<ul>
<li>A string indicating the name of the index</li>
<li>Sequelize literal object functions (for example, <code>sequelize.fn()</code>)</li>
<li>An object with the following keys:<ul><li><code>attribute</code>—A string value for the column to index</li><li><code>length</code>—Defines the length for a prefix index (if applicable to your DBMS)</li><li><code>order</code>—Determines whether the sorting should be ascending or descending</li><li><code>collate</code>—Defines the collation for the column</li></ul></li>
</ul>
<p>A quick example is provided here to illustrate how to use some of these advanced options when defining a Sequelize model:</p>
<pre class="source-code">
class User extends Model { }
User.init({
    name: DataTypes.STRING,
}, {
    sequelize,
    modelName: 'User',
    omitNull: true,
    // renames deletedAt to removedAt
    deletedAt: 'removedAt',
    // start with ID 1000
    initialAutoIncrement: 1000,
    validate: {
        isNotBob() {
            if (this.name === 'bob') {
                throw new Error("Bob is not allowed to be a 
                                 user.");
            }
        }
    },
    indexes: [
        { unique: true, fields: ['name'] }
    ],
});</pre>
<h1 id="_idParaDest-88"><a id="_idTextAnchor096"/>Summary</h1>
<p>In this chapter, we went through a detailed overview of the various parameters and configuration settings for defining models with Sequelize. We also learned how to use the Sequelize CLI to automatically generate models’ definition (and data) files and how to migrate those definitions to a database. This chapter has also covered the various attribute types provided by Sequelize, as well as the methodologies for querying or updating data from Sequelize to the database.</p>
<p>In the next chapter, we will go over model validations, establishing foreign relationships, and how to constrain your data to meet your project’s requirements.</p>
</div>
</div>

<div><div><div></div>
</div>
<div><h1 id="_idParaDest-89"><a id="_idTextAnchor097"/>Part 2 – Validating, Customizing, and Associating Your Data</h1>
<p>In this part, you will take a deeper look into Sequelize’s model attributes and add validations, custom column types, and related associated models. You will explore hooks, JSON, and Blob types, along with transactions.</p>
<p>This part comprises the following chapters:</p>
<ul>
<li><a href="B17841_03.xhtml#_idTextAnchor098"><em class="italic">Chapter 3</em></a>, <em class="italic">Validating Models</em></li>
<li><a href="B17841_04.xhtml#_idTextAnchor111"><em class="italic">Chapter 4</em></a>, <em class="italic">Associating Models</em></li>
<li><a href="B17841_05.xhtml#_idTextAnchor134"><em class="italic">Chapter 5</em></a>, <em class="italic">Adding Hooks and Lifecycle Events to Your Models</em></li>
<li><a href="B17841_06.xhtml#_idTextAnchor147"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Transactions with Sequelize</em></li>
<li><a href="B17841_07.xhtml#_idTextAnchor159"><em class="italic">Chapter 7</em></a>, <em class="italic">Handling Customized, JSON, and Blob Data Types</em></li>
</ul>
</div>
</div></body></html>