- en: Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered colors, multiple lights, and important concepts
    about depth and alpha testing for various blending techniques. So far, we've added
    details to our scene with geometry, vertex colors, and lighting; but often, that
    won't be enough to achieve the results we're looking for. Wouldn't it be great
    if we could "paint" additional details onto our scene without needing additional
    geometry? We can! This requires us to use a technique called texture mapping.
    In this chapter, we'll examine how we can use textures to make our scene more
    detailed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to create a texture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use a texture when rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about filter and wrapping modes and how they affect the texture's use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn how to use multi-texturing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about cube mapping.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What Is Texture Mapping?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Texture mapping is simply a method for adding detail to a geometry being rendered
    by displaying an image on the surface. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b50e4c7c-20ba-4e9e-8864-10fc993fab91.png)'
  prefs: []
  type: TYPE_IMG
- en: Using only the techniques we've learned so far, this relatively simple scene
    would be very difficult to build. The WebGL logo alone would have to be carefully
    constructed out of many triangle primitives. Although this is a possible approach,
    the additional geometry construction would be impractical for a marginally complex
    scene.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, texture mapping makes such requirements incredibly simple. All
    that's required is an image in an appropriate file format, an additional vertex
    attribute on the mesh, and a few additions to our shader code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Uploading a Texture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike traditional native OpenGL applications, browsers load textures "upside
    down". As a result, many WebGL applications set textures to be loaded with the
    `Y` coordinate flipped. This is done with a single call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Inverted Textures
  prefs: []
  type: TYPE_NORMAL
- en: Textures can either be manually flipped or flipped via WebGL. We will programmatically
    flip them with WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process of creating a texture is similar to creating a vertex or an index
    buffer. We start by creating the texture object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Textures, like buffers, must be bound before we can manipulate them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter indicates the type of texture we're binding, or the texture
    target. For now, we'll focus on 2D textures, indicated with `gl.TEXTURE_2D`. More
    targets will be introduced later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we''ve bound the texture, we can provide it with image data. The simplest
    way to do that is to pass a DOM image into the `texImage2D` function, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the previous snippet, we selected an image element from our page with the
    ID of `texture-image` as the source texture. This is **uploading** the texture,
    since the image will be stored in the GPU's memory for fast access during rendering.
    The source can be in any image format that can be displayed on a web page, such
    as JPEG, PNG, GIF, and BMP files.
  prefs: []
  type: TYPE_NORMAL
- en: The image source for the texture is passed in as the last parameter of the `texImage2D`
    call. When `texImage2D` is called with an image, WebGL will automatically determine
    the dimensions of the provided texture. The remainder of the parameters instruct
    WebGL about the type of information the image contains and how to store it. Most
    of the time, the only values you need to worry about changing are the third and
    fourth parameters, which can also be `gl.RGB`, to indicate that your texture has
    no alpha (transparency) channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the image, we also need to instruct WebGL on how to filter the
    texture when rendering. We''ll get into what filtering means and what the different
    filtering modes do in a bit. In the meantime, let''s use the simplest one to get
    us started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as with buffers, it''s good practice to unbind a texture when you are
    finished using it. You can do so by binding `null` as the active texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, in many cases, you won''t want to have all of the textures for your
    scene embedded in your web page, so it''s often more convenient to create the
    element in JavaScript and load it without adding it to the document. Putting all
    of this together gives us a simple function that will load any image URL that
    we provide as a texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Asynchronous Loading
  prefs: []
  type: TYPE_NORMAL
- en: There is a slight gotcha when loading images this way. The image loading is
    **asynchronous**, which means that your program won't stop and wait for the image
    to finish loading before continuing execution. So what happens if you try to use
    a texture before it's been populated with image data? Your scene will still render,
    but any texture values you sample will be black.
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, creating textures follows the same pattern as using buffers. For
    every texture we create, we want to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new texture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind it to make it the current texture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pass the texture contents, typically from an image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the filter mode or other texture parameters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unbind the texture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we reach a point where we no longer need a texture, we can remove it and
    free up the associated memory by using `deleteTexture`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After this, the texture is no longer valid. Any attempt to use it will react
    as though `null` has been passed.
  prefs: []
  type: TYPE_NORMAL
- en: Using Texture Coordinates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we apply our texture to our surface, we need to figure out which part
    of the texture maps onto which part of the surface. We do this through another
    vertex attribute known as **texture coordinates**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Texture coordinates are two-element float vectors that describe a location
    on the texture that coincides with that vertex. You may think that it would be
    most natural to have this vector be an actual pixel location on the image; instead,
    WebGL forces all of the texture coordinates into a `0` to `1` range, where `(0,
    0)` represents the top left-hand side corner of the texture and `(1, 1)` represents
    the bottom right-hand side corner, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6b0f89d4-52ad-43fe-9ae8-d40bf5cbd3f0.png)'
  prefs: []
  type: TYPE_IMG
- en: This means that, in order to map a vertex to the center of any texture, you
    would give it a texture coordinate of `(0.5, 0.5)`. This coordinate system holds
    true even for rectangular textures.
  prefs: []
  type: TYPE_NORMAL
- en: This may seem strange at first; after all, it's easier to determine the pixel
    coordinates of a particular point than the percentage of an image's height and
    width of the point's location. That said, there is a benefit to the coordinate
    system that WebGL uses.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we could build a WebGL application comprised of high resolution
    textures. Then, at some later point, we will receive feedback that the textures
    are taking too long to load or the application is causing devices to render slowly.
    As a result, we may decide to offer a lower resolution texture option for these
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: If your texture coordinates were defined in terms of pixels, you would now have
    to modify every mesh used by your application to ensure that the texture coordinates
    match up to the new, smaller textures correctly. However, when using WebGL's normalized
    `0` to `1` coordinate range, the smaller textures can use the exact same coordinates
    as the larger ones and still display correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Figuring out texture coordinates for your mesh is often a tricky part of creating
    3D resources, especially with complex meshes.
  prefs: []
  type: TYPE_NORMAL
- en: Polygon Mesh
  prefs: []
  type: TYPE_NORMAL
- en: A polygon **mesh** is a collection of vertices, edges, and faces that defines
    the shape of a polyhedral object in 3D computer graphics and solid modeling.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, most 3D modeling tools come with excellent utilities for laying
    out textures and generating texture coordinates—this process is called **unwrapping**.
  prefs: []
  type: TYPE_NORMAL
- en: Texture Coordinates
  prefs: []
  type: TYPE_NORMAL
- en: Just as vertex position components are commonly represented with `(x, y, z)`,
    texture coordinates also have a common symbolic representation. Unfortunately,
    it's not consistent across all 3D software applications. OpenGL and WebGL refer
    to these coordinates as `s` and `t` for the `x` and `y` components, respectively.
    However, DirectX and many popular modeling packages refer to them as `u` and `v`.
    As a result, you'll often see people referring to texture coordinates as "UVs"
    and unwrapping as "UV Mapping."
  prefs: []
  type: TYPE_NORMAL
- en: To be consistent with WebGL's usage, we will use `st` for the remainder of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Using Textures in a Shader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Texture coordinates are exposed to the shader code in the same way that they
    are with any other vertex attribute. We''ll want to include a two-element vector
    attribute in our vertex shader that will map to our texture coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we will also want to add a new uniform to the fragment shader
    that uses a type we haven''t seen before: `sampler2D`. The `sampler2D` uniform
    is what allows us to access the texture data in the shader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the past, when we''ve used uniforms, we set them to the value that we want
    them to be in the shader, such as a light color. **Samplers** work a bit differently.
    The following code shows how to associate a texture with a specific sampler uniform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: So, what's going on here? First off, we are changing the active texture index
    with `gl.activeTexture`. WebGL supports the use of multiple textures at once (which
    we'll talk about later in this chapter), so it's good practice to specify which
    texture index we're working with, even though it won't change for the duration
    of this program. Next, we bind the texture we wish to use, which associates it
    with the currently active texture, `TEXTURE0`. Finally, we tell the sampler uniform
    which texture it should be associated with given the texture unit provided via
    `gl.uniform1i`. Here, we give it `0` to indicate that the sampler should use `TEXTURE0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to use our texture in the fragment shader! The simplest way
    to use a texture is to return its value as the fragment color, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`texture` takes in the sampler uniform we wish to query and the coordinates
    to lookup, and returns the color of the texture image at those coordinates as
    `vec4`. If the image has no alpha channel, `vec4` will still be returned with
    the alpha component always set to `1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Texturing the Cube'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example where we add a texture map to a cube:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch07_01_textured-cube.html` file in your editor. If you open it in
    a browser, you should see a scene that looks like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1e1e7440-0416-4246-a033-d81b9693dcfe.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s load the texture image. At the top of the script block, add a new variable
    to hold the texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the `configure` function, add the following code, which creates
    the texture object, loads an image, and sets the image as the texture data. In
    this case, we''ll use a PNG image with the WebGL logo as our texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` function after the `vertexColors` binding block, add the following
    code to bind the texture to the shader sampler uniform:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to add the texture-specific code to the shader. In the vertex shader,
    add the following attribute and varying to the variable declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of the vertex shader''s `main` function, make sure to copy the texture
    coordinate attribute into the varying so that the fragment shader can access it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The fragment shader also needs two new variable declarations—the sampler uniform
    and the varying from the vertex shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We must also remember to add `aVertexTextureCoords` to the `attributes` list
    and `uSampler` to the `uniforms` list in the `configure` function so that the
    new variables can be accessed from our JavaScript binding code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To access the texture color, we call `texture` with the sampler and the texture
    coordinates. Since we want the textured surface to retain the lighting, we''ll
    multiply the lighting color and the texture color together, giving us the following
    line to calculate the fragment color:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the file now in browser and you should see a scene like this one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90ee294d-de73-4d47-a9a7-55e606ec2b75.png)'
  prefs: []
  type: TYPE_IMG
- en: If you're having trouble with a particular step and would like a reference,
    the completed code is available in `ch07_02_textured-cube-final.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We've just loaded a texture from a file, uploaded it to the GPU, rendered it
    on the cube geometry, and blended it with the lighting information that was already
    being calculated.
  prefs: []
  type: TYPE_NORMAL
- en: The remaining examples in this chapter will omit the calculation of lighting
    for simplicity and clarity, but lighting could be applied to all of them if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Try a Different Texture'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Try one of your own images to see if you can get it to display as the texture.
    What happens if you provide a rectangular image rather than a square one?
  prefs: []
  type: TYPE_NORMAL
- en: Texture Filter Modes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen how textures can be used to sample image data in a fragment
    shader, but we've only used them in a limited context. Some interesting issues
    arise when you start to investigate textures more closely.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you were to zoom in on the cube from the previous demo, you
    would see that the texture begins to alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c17e305b-65e0-4d6d-b7e3-fb60575854cb.png)'
  prefs: []
  type: TYPE_IMG
- en: As we zoom in, we can see that jagged edges develop around the WebGL logo. Similar
    problems become apparent when the texture is very small on the screen. Isolated
    to a single object, such artifacts are easy to overlook, but they can become very
    distracting in complex scenes. Why do we see these artifacts in the first place?
  prefs: []
  type: TYPE_NORMAL
- en: 'From the previous chapter, you should remember how vertex colors are interpolated
    so that the fragment shader is provided with a smooth gradient of color. Texture
    coordinates are interpolated in the exact same way, with the resulting coordinates
    being provided to the fragment shader and used to sample color values from the
    texture. In a perfect situation, the texture would display at a `1:1` ratio on
    screen, meaning each pixel of the texture (known as **texels**) would take up
    exactly one pixel on screen. In this scenario, there would be no artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8311bff0-9b3e-40c9-8739-bc71b889e018.png)'
  prefs: []
  type: TYPE_IMG
- en: Pixel Versus TexelSometimes, the pixels in a texture are called **texels**.
    Pixel is short for Picture Element. Texel is short for Texture Element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reality of 3D applications, however, is that textures are almost never
    displayed at their native resolution. We refer to these scenarios as **magnification**
    and **minification**, depending on whether the texture has a lower or higher resolution
    than the screen space it occupies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/366bbeed-d14a-42df-86cf-27667bf130bb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When a texture is magnified or minified, there can be some ambiguity about
    what color the texture sampler should return. For example, consider the following
    diagram of sample points against a slightly magnified texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a672fc80-bf56-4470-a439-6bf6d8ef388a.png)'
  prefs: []
  type: TYPE_IMG
- en: It's pretty obvious what color you would want the top left-hand side or middle
    sample points to return, but what about those texels in the middle? What color
    should they return? The answer is determined by your filter mode. Texture filtering
    allows us to control how textures are sampled and achieve the look we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting a texture''s filter mode is very straightforward, and we already saw
    an example of how it works when we talked about creating textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As with most WebGL calls, `texParameteri` operates on the currently bound texture,
    and must be set for every texture you create. This also means that different textures
    can have different filters, which can be useful when trying to achieve specific
    effects.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are setting both the magnification filter (`TEXTURE_MAG_FILTER`)
    and the minification filter (`TEXTURE_MIN_FILTER`) to `NEAREST`. There are several
    modes that can be passed for the third parameter, and the best way to understand
    the visual impact they have on a scene is to see the various filter modes in action.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a demonstration of the filters in your browser while we discuss
    different parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Trying Different Filter Modes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of seeing different filter modes in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch07_03_texture-filters.html` file using your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/73bca57f-91a9-4594-8999-dfcb0ea4ff29.png)'
  prefs: []
  type: TYPE_IMG
- en: The controls include a slider to adjust the distance of the box from the viewer,
    while the buttons modify the magnification and minification filters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment with different modes to observe the effect they have on the texture.
    Magnification filters take effect when the cube's textures are being rendered
    larger than their source image size; minification filters when it is further away.
    Be sure to rotate the cube as well to observe what the texture looks like when
    viewed at an angle with each mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to create and load textures into our 3D scene. We also covered
    various techniques for mapping textures onto objects, along with an interactive
    example to demonstrate these capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each of the filter modes in depth and discuss how they work.
  prefs: []
  type: TYPE_NORMAL
- en: NEAREST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Textures using the `NEAREST` filter always return the color of the texel whose
    center is nearest to the sample point. Using this mode, textures will look blocky
    and pixilated when viewed up close, which can be useful for creating "retro" graphics.
    `NEAREST` can be used for both the `MIN` and `MAG` filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d78ee73-5df7-4bb9-bfc5-be418fd971f1.png)'
  prefs: []
  type: TYPE_IMG
- en: LINEAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `LINEAR` filter returns the weighted average of the four pixels whose centers
    are nearest to the sample point. This provides a smooth blending of texel colors
    when looking at textures close up—it''s generally the more desirable effect. This
    does mean that the graphics hardware has to read four times as many pixels per
    fragment there is, so naturally, it''s slower than `NEAREST`, but modern graphics
    hardware is so fast that this is almost never an issue. `LINEAR` can be used for
    both the `MIN` and `MAG` filters. This filtering mode is also known as **bilinear
    filtering**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70f249f-fa09-400f-985c-8b146c6b0a04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Returning to the close-up example image we showed earlier in this chapter,
    had we used `LINEAR` filtering, it would have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/89d602f9-f910-460a-bf2b-6534964c419d.png)'
  prefs: []
  type: TYPE_IMG
- en: Mipmapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we can discuss the remaining filter modes that are only applicable to
    `TEXTURE_MIN_FILTER`, we need to introduce a new concept: **mipmapping**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A problem arises when sampling minified textures. In cases where we use `LINEAR`
    filtering and the sample points are so far apart, we can completely miss some
    details of the texture. As the view shifts, the texture fragments that we miss
    change, which results in a shimmering effect. You can see this in action by setting
    the `MIN` filter in the demo to `NEAREST` or `LINEAR`, zooming out, and rotating
    the cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8233e1c-b064-4437-885a-e2e089fa7200.png)'
  prefs: []
  type: TYPE_IMG
- en: To avoid this, graphics cards can utilize a **mipmap chain**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mipmaps are scaled-down copies of a texture, with each copy being exactly half
    the size of the previous one. If you were to show a texture and all of its mipmaps
    in a row, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/79e5c391-6b74-4fac-a30b-3c0c86d16d85.png)'
  prefs: []
  type: TYPE_IMG
- en: The advantage is that when rendering, the graphics hardware can choose the copy
    of the texture that most closely matches the size of the texture on screen and
    samples from it instead. This reduces the number of skipped texels and the jittery
    artifacts that accompany them. However, mipmapping is only used if you use the
    appropriate texture filters.
  prefs: []
  type: TYPE_NORMAL
- en: NEAREST_MIPMAP_NEAREST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This filter will select the mipmap that most closely matches the size of the
    texture on screen and samples from it using the `NEAREST` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: LINEAR_MIPMAP_NEAREST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This filter selects the mipmap that most closely matches the size of the texture
    on screen and samples from it using the `LINEAR` algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: NEAREST_MIPMAP_LINEAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This filter selects two mipmaps that most closely match the size of the texture
    on screen and samples from both of them by using the `NEAREST` algorithm. The
    color returned is a weighted average of those two samples.
  prefs: []
  type: TYPE_NORMAL
- en: LINEAR_MIPMAP_LINEAR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This filter selects two mipmaps that most closely match the size of the texture
    on screen and samples from both of them using the `LINEAR` algorithm. The color
    returned is a weighted average of those two samples. This mode is also known as
    **trilinear filtering**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/be2654c4-556f-41c8-9e62-6942d710fdb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Of the `*_MIPMAP_*` filter modes, `NEAREST_MIPMAP_NEAREST` is the fastest and
    lowest quality while `LINEAR_MIPMAP_LINEAR` will provide the best quality but
    the lowest performance. The other two modes sit somewhere in between on the quality/speed
    scale. In most cases, the performance trade-off will be small enough that it's
    common to use `LINEAR_MIPMAP_LINEAR`.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Mipmaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'WebGL doesn''t automatically create mipmaps for every texture; so, if we want
    to use one of the `*_MIPMAP_*` filter modes, we have to create the mipmaps for
    the texture first. Fortunately, all this takes is a single function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`generateMipmap` must be called after the texture has been populated with `texImage2D`
    and will automatically create a full mipmap chain for the image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you want to provide the mipmaps manually, you can always
    specify that you are providing a mipmap level rather than the source texture when
    calling `texImage2D` by passing a number other than `0` as the second parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're manually creating the first mipmap level, which is half the height
    and width of the normal texture. The second level would be a quarter of the dimensions
    of the normal texture, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for some advanced effects or when using compressed textures
    that cannot be used with `generateMipmap`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are familiar with WebGL 1, you'll remember its limit that textures with
    dimensions that were not a power of two (**not** `1`, `2`, `4`, `8`, `16`, `32`,
    `64`, `128`, `256`, `512`, and so on) could not use mips and could not repeat.
    In WebGL 2, these restrictions are gone.
  prefs: []
  type: TYPE_NORMAL
- en: Non Power of Two (NPOT)
  prefs: []
  type: TYPE_NORMAL
- en: In order to use mipmaps with a texture in WebGL 1, mipmaps need to satisfy some
    dimension restrictions. Namely, the texture width and height must both be **Powers
    of Two** (**POT**). That is, the width and height can be `pow(2, n)` pixels, where
    `n` is any integer. Examples are `16px`, `32px`, `64px`, `128px`, `256px`, `512px`,
    `1024px`, and so on. Also, note that the width and height do not have to be the
    same as long as both are powers of two. For example, a `512x128` texture can still
    be mipmapped. NPOT textures can still be used with WebGL 1, but are restricted
    to only using `NEAREST` and `LINEAR` filters.
  prefs: []
  type: TYPE_NORMAL
- en: Why, then, is power restricted for two textures? Recall that the mipmap chain
    is made up of textures whose sizes are half the previous level. When the dimensions
    are powers of two, this will always produce integer numbers, which means that
    the number of pixels never needs to be rounded off, and hence produces clean and
    fast scaling algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: For all of the texture code samples after this point, we'll be using a simple
    texture class that cleanly wraps up the texture's download, creation, and setup.
    Any textures created with the class will automatically have mipmaps generated
    for them and be set to use `LINEAR` for the magnification filter and `LINEAR_MIPMAP_LINEAR`
    for the minification filter.
  prefs: []
  type: TYPE_NORMAL
- en: Texture Wrapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we used `texParameteri` to set the filter mode for
    textures but, as you might expect from the generic function name, that's not all
    it can do. Another texture behavior that we can manipulate is the **texture wrapping**
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: Texture wrapping describes the behavior of the sampler when the texture coordinates
    fall outside the range of `0` and `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The wrapping mode can be set independently for both the `S` and `T` coordinates,
    so changing the wrapping mode typically takes two calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're setting both the `S` and `T` wrapping modes for the currently bound
    texture to `CLAMP_TO_EDGE`, the effects of which we will see in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: As with texture filters, it's easiest to demonstrate the effects of the different
    wrapping modes via an example and then discuss the results. Please open your browser
    again for another demonstration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Trying Different Wrap Modes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of seeing different wrap modes in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch07_04_texture-wrapping.html` file using your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22809f44-7d56-4dda-97bd-144a8d886e3c.png)'
  prefs: []
  type: TYPE_IMG
- en: The cube shown in the preceding screenshot has texture coordinates that range
    from `-1` to `2`, which forces the texture wrapping mode to be used for everything
    but the center tile of the texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment with the controls to see the effect that different wrap modes have
    on the texture.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We experimented with various approaches to texture interpolation and mipmapping
    techniques, along with interactive examples demonstrating these capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's investigate each of the wrap modes and discuss how they function.
  prefs: []
  type: TYPE_NORMAL
- en: CLAMP_TO_EDGE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This wrap mode rounds any texture coordinates greater than `1` down to `1`;
    any coordinates lower than `0` are rounded up to `0`, "clamping" the values to
    the `0`-`1` range. Visually, this has the effect of repeating the texture''s border
    pixels indefinitely once the coordinates go out of the `0`-`1` range. Note that
    this is the only wrapping mode that''s compatible with **NPOT** textures:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7cdc7623-4392-4973-8f88-252489ad40a6.png)'
  prefs: []
  type: TYPE_IMG
- en: REPEAT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the default wrap mode, and the one that you''ll probably use most often.
    In mathematical terms, this wrap mode simply ignores the integer part of the texture
    coordinate. This creates the visual effect of the texture repeating as you move
    outside of the `0`-`1` range. This is a useful effect for displaying surfaces
    that have a natural repeating pattern to them, such as a tile floor or brick wall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1339edfd-2dde-4f8d-a0a1-61d27f982e5d.png)'
  prefs: []
  type: TYPE_IMG
- en: MIRRORED_REPEAT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The algorithm for this mode is a little more complicated. If the coordinate''s
    integer portion is even, the texture coordinates will be the same as they were
    with `REPEAT`. If the integer portion of the coordinate is odd, the resulting
    coordinate is `1` minus the fractional portion of the coordinate. This results
    in a texture that "flip-flops" as it repeats, with every other repetition being
    a mirror image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12cd5797-553d-4893-9d29-e4d8e8c4cdab.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we mentioned earlier, these modes can be mixed and matched. For example,
    consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This would produce the following effect on the texture from the sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3dbeeb7-9e96-431c-8f4b-194618d69cbc.png)'
  prefs: []
  type: TYPE_IMG
- en: Samplers Versus Textures
  prefs: []
  type: TYPE_NORMAL
- en: Wondering why the shader uniforms are called *samplers* instead of *textures*?
    A texture is just the image data stored on the GPU, while a sampler contains all
    of the information about how to look up texture information, including filter
    and wrap modes.
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've done all of our rendering by using a single texture. However,
    there are times when we may want to have multiple textures contribute to a fragment
    to create more complex effects. In such cases, we can use WebGL's ability to access
    multiple textures in a single draw call, commonly referred to as **multi-texturing**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We briefly covered multi-texturing earlier, so let''s go back and look at it
    again. When talking about exposing a texture to a shader as a sampler uniform,
    we used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The first line, `gl.activeTexture`, is the key to utilizing multi-texturing.
    We use it to tell the WebGL state machine which texture we're going to use in
    subsequent texture functions. In this case, we passed `gl.TEXTURE0`, which means
    that any following texture calls (such as `gl.bindTexture`) will alter the state
    of the first texture unit. If we want to attach a different texture to the second
    texture unit, we would use `gl.TEXTURE1` instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different devices will support different numbers of texture units, but WebGL
    specifies that compatible hardware must always support at least two texture units.
    We can find out how many texture units the current device supports with the following
    function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'WebGL provides explicit enumerations for `gl.TEXTURE0` through `gl.TEXTURE31`.
    It may be more convenient to specify the texture unit programmatically or find
    a need to refer to a texture unit above `31`. In such situations, you can always
    substitute `gl.TEXTURE0 + i` for `gl.TEXTUREi`, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Accessing multiple textures in a shader is as simple as declaring multiple
    samplers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When setting up your draw call, tell the shader which texture is associated
    with which sampler by providing the texture unit to `gl.uniform1i`. The code to
    bind two textures to the samplers above would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We now have two textures available for our fragment shader, but what do we want
    to do with them?
  prefs: []
  type: TYPE_NORMAL
- en: As an example, we're going to implement a simple multi-texture effect that layers
    another texture on top of a simple textured cube to simulate static lighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Using Multi-Texturing'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of multi-texturing in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch07_05_multi-texture.html` file with your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the script block, add another texture variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the `configure` function, add the code to load the second
    texture. We''re using a class to make this process easier, so the new code is
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The texture we''re using is a white radial gradient that simulates a spot light:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0af51617-be91-4d55-9a8d-9875e6e8df98.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `render` function, directly below the code that binds the first texture,
    add the following to expose the new texture to the shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add the new sampler uniform to the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Don't forget to add the corresponding string to the uniforms list in the `configure`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We add the code to sample the new texture value and blend it with the first
    texture. Since we want the second texture to simulate a light, we multiply the
    two values together as we did with the per-vertex lighting in the first texture
    example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're re-using the same texture coordinate for both textures. This
    is more convenient but, if needed, a second texture coordinate attribute could
    be provided or we could calculate a new texture coordinate from the vertex position
    or some other criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see a scene that looks like this when you open the file in your
    browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/3b30f924-5ce4-4574-92d2-46115915aa43.png)'
  prefs: []
  type: TYPE_IMG
- en: You can see the completed example in `ch07_06_multi-texture-final.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We've added a second texture to the `render` call and blended it with the first
    to create a new effect, which, in this case, simulates a simple static spotlight.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to realize that the colors sampled from a texture are treated
    like any other color in the shader—that is, as a generic 4-dimensional vector.
    As a result, we can combine textures just as we would combine vertex and light
    colors, or any other color manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Moving Beyond Multiply'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Multiplication is one of the most common ways to blend colors in a shader,
    but there''s really no limit to how you can combine color values. Try experimenting
    with different algorithms in the fragment shader to see what effect it has on
    the output. What happens when you add values instead of multiply? What if you
    use the red channel from one texture and the blue and green from the other? Try
    out the following algorithm and see what the result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/af682a41-586b-4863-b5de-f190665f37ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Have a Go: Using Multi-Dimensional Textures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed, the challenges in maintaining multiple textures resembles
    the same challenges we faced in [Chapter 6](65e942d0-5402-4006-9b64-6811ade8f46c.xhtml),
    *Colors, Depth Testing, and Alpha Blending,* in managing multiple lights. That
    being said, does WebGL provide a similar feature as uniform arrays for managing
    multiple textures? Yes, of course! We can leverage two different solutions that
    WebGL 2 provides for managing multi-dimensional textures: **3D textures** and
    **texture arrays**.'
  prefs: []
  type: TYPE_NORMAL
- en: Although, we will discuss these features in [Chapter 11](9a56a1ad-908b-4201-b95c-0c811b1bd011.xhtml),
    *WebGL 2 Highlights,* it may be useful to think about how these features can be
    useful in reducing complexity, improving code maintainability, and increasing
    the number of textures that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Cube Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier in this chapter, we mentioned 2D textures and cube maps for creating
    complex effects using images. We covered textures, but exactly what are cube maps
    and how do we use them?
  prefs: []
  type: TYPE_NORMAL
- en: A **cube map** is, very much like it sounds, a cube of textures. Six individual
    textures are created, each assigned to a different face of the cube. The graphics
    hardware can sample them as a single entity, by using a 3D texture coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The faces of the cube are identified by the axis they face and whether they
    are on the positive or negative side of that axis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5762d179-58de-4c54-b10f-b50f1d66f965.png)'
  prefs: []
  type: TYPE_IMG
- en: 'So far, we have manipulated a texture by specifying a texture target of `TEXTURE_2D`.
    Cube mapping introduces a few new texture targets that indicate we are working
    with cube maps. These targets also indicate which face of the cube map we''re
    manipulating:'
  prefs: []
  type: TYPE_NORMAL
- en: '`TEXTURE_CUBE_MAP`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXTURE_CUBE_MAP_POSITIVE_X`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXTURE_CUBE_MAP_NEGATIVE_X`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXTURE_CUBE_MAP_POSITIVE_Y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXTURE_CUBE_MAP_NEGATIVE_Y`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXTURE_CUBE_MAP_POSITIVE_Z`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TEXTURE_CUBE_MAP_NEGATIVE_Z`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These targets are collectively known as the `gl.TEXTURE_CUBE_MAP_*` targets.
    Which one you need to use depends on the function you're calling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cube maps are created like a normal texture, but binding and property manipulation
    happen with the `TEXTURE_CUBE_MAP` target, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When uploading the image data for the texture, you need to specify the side
    that you are manipulating, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Exposing the cube map texture to the shader is done in the same way as a normal
    texture, just with the cube map target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the uniform type within the shader is specific to cube maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When sampling from the cube map, you also use a cube map-specific function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The 3D coordinates you provide are normalized by the graphics hardware into
    a unit vector, which specifies a direction from the center of the "cube." A ray
    is traced along that vector, and where it intersects the cube face is where the
    texture is sampled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e0f5c69-128a-49a8-ad7a-ae4b8ad6bb7b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Time for Action: Trying out Cube Maps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of seeing cube maps in action:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch07_07_cubemap.html` file in your browser. Once again, this contains
    a simple textured cube example on top of which we'll build the cube map example.
    We want to use the cube map to create a reflective-looking surface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creating the cube map is a bit more complicated than the textures we''ve loaded
    in the past, so this time, we''ll use a function to simplify the asynchronous
    loading of individual cube faces. It''s called `loadCubemapFace` and has already
    been to the file. Inside of the `configure` function, at the bottom, add the following
    code, which creates and loads the cube map faces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `render` function, add the code to bind the cube map to the appropriate
    sampler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning to the shader now, we want to add a new varying to the vertex shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll be using the vertex normals instead of a dedicated texture coordinate
    to do the cube map sampling, which will give us the mirror effect we''re looking
    for. Unfortunately, the actual normals of each face on the cube point straight
    out. If we were to use them, we would only get a single color per face from the
    cube map. In this case, we can "cheat" and use the vertex position as the normal
    instead (for most models, using the normals would be appropriate):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to define the following varying inside of the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to add the new sampler uniform inside of the fragment shader.
    Be sure to also include this in the `uniforms` list inside of the `configure`
    function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And then, in the fragment shader''s `main` function, add the code to actually
    sample the cube map and blend it with the base texture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We should now be able to reload the file in a browser and see the scene shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac07b294-5ebb-4afe-b292-d4266523ad4c.png)'
  prefs: []
  type: TYPE_IMG
- en: The completed example is available in `ch07_08_cubemap-final.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: As you rotate the cube, you'll notice that the scene displayed on the cube map
    does not rotate along, creating a "mirror" effect on the cube faces. This is due
    to multiplication of the normals by the Normal matrix when assigning the `vVertexNormal`
    varying, which puts the normals in world space.
  prefs: []
  type: TYPE_NORMAL
- en: Using cube maps for reflective surfaces is a common technique, but it's not
    the only use for cube maps. Other common uses include skyboxes and advanced lighting
    models.
  prefs: []
  type: TYPE_NORMAL
- en: 'SkyboxA skybox is a method that''s used for creating backgrounds to make computer
    and video game levels look bigger than they really are. When a skybox is used,
    the level is enclosed in a cuboid. The sky, distant mountains, distant buildings,
    and other unreachable objects are projected onto the cube''s faces (using a technique
    called cube mapping), hence creating the illusion of distant, three-dimensional
    surroundings. A skydome employs the same concept but uses either a sphere or a
    hemisphere instead of a cube. For more information, check out the following URL:
    [https://en.wikipedia.org/wiki/Skybox_(video_games)](https://en.wikipedia.org/wiki/Skybox_(video_games)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Shiny Logo'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we've created a reflective "mirrored" cube. But what if we
    only wanted the logo to be reflective? How could we constrain the cube map to
    only be displayed within the red portion of the texture?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s summarize what we''ve learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to use textures to add a new level of detail to our scenes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create and manage texture objects and use HTML images as textures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered texture coordinates and the ability to mipmap for various rendering
    techniques.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We examined the various filter modes and how they affect the texture's appearance
    and usage, as well as the available texture wrapping modes and how they alter
    the way texture coordinates are interpreted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to use multiple textures in a single draw call, and how to combine
    them in a shader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to create and render cube maps and saw how they can be used to
    simulate reflective surfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will look at selecting and interacting with objects
    in our WebGL scene by using a clever technique known as picking.
  prefs: []
  type: TYPE_NORMAL
