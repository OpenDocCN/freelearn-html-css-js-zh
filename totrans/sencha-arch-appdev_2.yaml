- en: Chapter 2. Creating an Ext JS App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 创建 Ext JS 应用
- en: 'In this chapter, we will take our first steps with Sencha Architect by implementing
    a sample application with Ext JS, always highlighting the Sencha Architect features.
    We will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过实现一个使用 Ext JS 的示例应用程序来迈出 Sencha Architect 的第一步，始终突出 Sencha Architect
    的功能。我们将涵盖以下内容：
- en: Creating an Ext JS project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Ext JS 项目
- en: Creating models, stores, views, and controllers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模型、存储、视图和控制器
- en: Executing the project for the first time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首次执行项目
- en: Implementing the Ext JS app
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Ext JS应用
- en: 'Before we start implementing our Ext JS application, let''s take a look at
    what we will have at the end of the chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实现我们的 Ext JS 应用程序之前，让我们看看本章结束时我们将有什么：
- en: '![Implementing the Ext JS app](img/9819OS_02_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![实现 Ext JS 应用](img/9819OS_02_01.jpg)'
- en: It is a simple grid that lists books, which we will retrieve from a database.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个简单的网格，列出书籍，我们将从数据库中检索这些书籍。
- en: Creating the project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建项目
- en: 'First, to create a new Ext JS project, refer to the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要创建一个新的 Ext JS 项目，请参考以下截图：
- en: '![Creating the project](img/9819OS_02_02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/9819OS_02_02.jpg)'
- en: 'Right after the project is created, we will see the landing screen with the
    toolbar, canvas, project inspector, config panel, and toolbox. We will save our
    project right away. To do so, click on **Save** on the toolbox or press *Ctrl*
    + *S* (*cmd* + *S* on Mac OS). The **Save Project** screen will be displayed:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 项目创建后，我们将看到带有工具栏、画布、项目检查器、配置面板和工具箱的登录屏幕。我们将立即保存项目。为此，请点击工具箱中的 **保存** 或按 *Ctrl*
    + *S* (*cmd* + *S* 在 Mac OS 上)。将显示 **保存项目** 屏幕：
- en: '![Creating the project](img/9819OS_02_03.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![创建项目](img/9819OS_02_03.jpg)'
- en: We will save the project as `extBooks` inside the `sencha-architect` directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将项目保存为 `extBooks`，位于 `sencha-architect` 目录下。
- en: 'Now that the project is saved, we can start implementing it. We will follow
    the following development workflow: we will implement first the model then the
    store, view, and controller, and then repeat until our project is finished.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目已保存，我们可以开始实现了。我们将遵循以下开发工作流程：首先实现模型，然后是存储、视图和控制器，然后重复此过程，直到项目完成。
- en: A quick word about MVC
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单谈谈 MVC
- en: '**Model-View-Controller** (**MVC**) is a software architecture pattern, which
    separates the representation of the information from the user''s interaction with
    it. The model represents the application data, the view represents the output
    of the representation of the data (a form, grid, chart), and the controller mediates
    the input, converting it to commands for the model or view.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器** (**MVC**) 是一种软件架构模式，它将信息的表示与用户的交互分离。模型表示应用程序数据，视图表示数据的表示输出（表单、网格、图表），控制器调解输入，将其转换为模型或视图的命令。'
- en: Ext JS and Sencha Touch use a **Model-View-Controller-Store** (**MVCS**) pattern.
    The model is a representation of the data we want to manipulate in our application
    (a representation of a table from the database). The view contains all the components
    and screens we create to manage the information of a model. As Ext JS is event
    driven, all the views fire events when the user interacts with them, and the controller
    will capture these events and will do something, redirecting the command to the
    model (or store) or the view. The store in Ext JS is very similar to the **Data
    Access Object** (**DAO**) pattern used on the server side.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Ext JS 和 Sencha Touch 使用 **模型-视图-控制器-存储** (**MVCS**) 模式。模型是我们想要在应用程序中操作的数据的表示（数据库中表的表示）。视图包含我们创建的所有组件和屏幕，用于管理模型的信息。由于
    Ext JS 是事件驱动的，所有视图在用户与之交互时都会触发事件，控制器将捕获这些事件并执行某些操作，将命令重定向到模型（或存储）或视图。Ext JS 中的存储与在服务器端使用的
    **数据访问对象** (**DAO**) 模式非常相似。
- en: 'For a quick example, let''s say we have **WidgetA**, which is a grid panel
    that displays all the records from the table A. **ModelA** represents this table.
    The **StoreA** table is responsible for retrieving the information (collection
    of **ModelA** from the server). When the user clicks on a record from **WidgetA**,
    a window will be opened (called **WidgetB**) that displays information from the
    table B (represented by **ModelB**). And of course, the **StoreB** will be responsible
    for retrieving the collection of **ModelB** from server. In this case, we will
    have **ControllerA** to capture the click event from **WidgetA** and do all the
    required logic to display **WidgetB** and load all the **ModelB** information.
    If we try to put this in a quick reference diagram, it would look something like
    the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速举例，假设我们有一个**WidgetA**，它是一个显示表A中所有记录的网格面板。**ModelA**代表这个表。**StoreA**表负责检索信息（从服务器获取的**ModelA**集合）。当用户点击**WidgetA**中的记录时，将打开一个窗口（称为**WidgetB**），显示表B的信息（由**ModelB**表示）。当然，**StoreB**将负责从服务器检索**ModelB**集合。在这种情况下，我们将有**ControllerA**来捕获**WidgetA**的点击事件，并执行所有必要的逻辑以显示**WidgetB**并加载所有**ModelB**信息。如果我们尝试将其放入快速参考图中，它将看起来像以下截图：
- en: '![A quick word about MVC](img/9819OS_02_28.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![关于MVC的简要说明](img/9819OS_02_28.jpg)'
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about MVC and Sencha applications, go to [http://docs.sencha.com/extjs/4.2.1/#!/guide/application_architecture](http://docs.sencha.com/extjs/4.2.1/#!/guide/application_architecture).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有关MVC和Sencha应用程序的更多信息，请访问[http://docs.sencha.com/extjs/4.2.1/#!/guide/application_architecture](http://docs.sencha.com/extjs/4.2.1/#!/guide/application_architecture)。
- en: Configuring the app
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序
- en: 'The first step is to set up the application we are going to develop throughout
    this chapter. Before we start, on the project inspector, select the **Application**
    option (*Step 1 in the following screenshot*) and then go to the config panel;
    locate the **name** property and set its value to `Packt` (*Step 2*). This is
    the namespace of our application, meaning that all the classes will be named `Packt.`
    `+` `package` `+` `className`. Many programming languages use namespacing to avoid
    collisions with other objects or variables in the global namespace. If we open
    the code editor, the code we will see is the same as on *Step 3*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是设置我们将在本章中开发的整个应用程序。在我们开始之前，在项目检查器中，选择**应用程序**选项（以下截图中的*步骤1*），然后转到配置面板；找到**名称**属性并将其值设置为`Packt`（*步骤2*）。这是我们的应用程序命名空间，意味着所有类都将命名为`Packt.`
    `+` `package` `+` `className`。许多编程语言使用命名空间来避免与全局命名空间中的其他对象或变量发生冲突。如果我们打开代码编辑器，我们将看到的代码与*步骤3*相同：
- en: '![Configuring the app](img/9819OS_02_04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![配置应用程序](img/9819OS_02_04.jpg)'
- en: All these configurations will be applied on the `app.js` file, since the **Application**
    option represents the `app.js` file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些配置都将应用于`app.js`文件，因为**应用程序**选项代表`app.js`文件。
- en: Creating the model
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'Following our development workflow, we will start with the model. On the top
    of the project inspector, click on the **+** icon and select **Model** (*Step
    1*):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们的开发工作流程，我们将从模型开始。在项目检查器的顶部，点击**+**图标，并选择**模型**（*步骤1*）：
- en: '![Creating the model](img/9819OS_02_05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![创建模型](img/9819OS_02_05.jpg)'
- en: 'Once the model is created, select it, go to the config panel, and set the class
    name (**userClassName**) to **Book** (*Step 2*). Then, still on the config panel,
    locate the **Fields** option, click on its **+** icon, and add the first field,
    which we will name `id`. Continue adding the following fields: **id**, **name**,
    **author**, **language**, **paperback**, **releaseDate**, **isbn**,and **isbn13**,
    as shown in the following screenshot (*Step 4*):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了模型，选择它，转到配置面板，并将类名（**userClassName**）设置为**Book**（*步骤2*）。然后，仍然在配置面板中，找到**字段**选项，点击其**+**图标，并添加第一个字段，我们将命名为`id`。继续添加以下字段：**id**、**name**、**author**、**language**、**paperback**、**releaseDate**、**isbn**和**isbn13**，如图所示（*步骤4*）：
- en: '![Creating the model](img/9819OS_02_06.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![创建模型](img/9819OS_02_06.jpg)'
- en: If we go back to the project inspector, the book model should look like *Step
    5*. If we look at the canvas, nothing will be displayed on the design mode, but
    if we take a look at the code editor, the `Packt.model.Book` class will be defined.
    If we try to edit its code, it will not be possible, because we have a simple
    model with no functions or methods inside it (created by ourselves).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到项目检查器，书籍模型应该看起来像*步骤 5*。如果我们查看画布，设计模式下将不会显示任何内容，但如果我们查看代码编辑器，`Packt.model.Book`类将被定义。如果我们尝试编辑其代码，将无法进行，因为我们有一个简单的模型，其中没有函数或方法（由我们自己创建）。
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `Book.js` inside
    the `app/model` directory.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目并查看Sencha Architect迄今为止创建的文件，我们会看到它已经在`app/model`目录中创建了一个名为`Book.js`的文件。
- en: Creating the store
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建存储
- en: 'The next step is to create a store. Our data is going to come from the server
    (Java, Ruby, PHP, .NET, and so on), and we will use Ajax to load it. So, we need
    to create a store that will use an Ajax Proxy to read information that is coming
    from the server in a **JavaScript Object Notation** (**JSON**) format. So, we
    need to go back to the project inspector, click on the **+** icon again, and select
    **Store** and **Json Store**, as shown in the following screenshot:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个存储。我们的数据将来自服务器（Java、Ruby、PHP、.NET等），我们将使用Ajax来加载它。因此，我们需要创建一个使用Ajax代理来读取以**JavaScript对象表示法**（**JSON**）格式从服务器发送的信息的存储。因此，我们需要回到项目检查器，再次点击**+**图标，选择**Store**和**Json
    Store**，如下面的截图所示：
- en: '![Creating the store](img/9819OS_02_07.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![创建存储](img/9819OS_02_07.jpg)'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about Ajax Proxy and Json Store, go to [http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.data.proxy.Ajax](http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.data.proxy.Ajax).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Ajax代理和Json Store的更多信息，请访问[http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.data.proxy.Ajax](http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.data.proxy.Ajax)。
- en: 'Right after we create the store, we will see a red exclamation mark icon (*Step
    1*). If we click on it (*Step 1*), we will see an error message saying that we
    need to associate a model to this store or create at least one field on the store
    (*Step 2*). As we already have a model, click on the store (**MyJsonStore**) on
    the project inspector, go to the config panel, search for `model`, and then you
    can choose from the list the **Book** model (which is already created) (*Step
    3*). In this case, we have only created the **Book** model:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建存储后，我们会看到一个红色的感叹号图标（*步骤 1*）。如果我们点击它（*步骤 1*），我们会看到一个错误消息，说明我们需要为此存储关联一个模型或至少在存储上创建一个字段（*步骤
    2*）。因为我们已经有一个模型，所以点击项目检查器中的存储（**MyJsonStore**），进入配置面板，搜索`model`，然后可以从列表中选择**Book**模型（该模型已经创建）（*步骤
    3*）。在这种情况下，我们只创建了**Book**模型：
- en: '![Creating the store](img/9819OS_02_08.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![创建存储](img/9819OS_02_08.jpg)'
- en: 'Next, we need to give a name to our store. We will call it `Books` (following
    the Sencha MVC convention, the store name should be the plural of the model name).
    Sencha Architect also automatically creates the **storeId** field for the store.
    Let''s also change it to **books** (as we can see in the following screenshot).
    Also, search for the `pageSize` property and set it to `5` (we will use a paging
    toolbar later):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为我们的存储命名。我们将称之为`Books`（遵循Sencha MVC约定，存储名称应该是模型名称的复数形式）。Sencha Architect还会自动为存储创建**storeId**字段。让我们也将它改为**books**（如下面的截图所示）。还要搜索`pageSize`属性，并将其设置为`5`（我们稍后将使用分页工具栏）：
- en: '![Creating the store](img/9819OS_02_09.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![创建存储](img/9819OS_02_09.jpg)'
- en: Then next step is to select the proxy (**MyAjaxProxy**) under the **Books**
    store in the project inspector and locate the **url** configuration and set its
    value to `http://localhost/sencha-architect/extBooks/php/list.php`. We are going
    to create the server code for this example inside the `php` folder. You can get
    the server-side code within the source code distributed with this book.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是选择项目检查器中**Books**存储下的代理（**MyAjaxProxy**），定位到**url**配置，并将其值设置为`http://localhost/sencha-architect/extBooks/php/list.php`。我们将在这个示例中创建`php`文件夹中的服务器代码。您可以从本书附带源代码中获取服务器端代码。
- en: '![Creating the store](img/9819OS_02_10.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![创建存储](img/9819OS_02_10.jpg)'
- en: 'And finally, we need to set some configurations for the reader. To do so, please
    select the **MyJsonReader** store, locate the **root** property, and set its value
    to **data**:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要为读者设置一些配置。为此，请选择**MyJsonReader**存储，定位到**root**属性，并将其值设置为**data**：
- en: '![Creating the store](img/9819OS_02_11.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![创建存储](img/9819OS_02_11.jpg)'
- en: When we load the information from the server, we expect to receive a JSON object
    that will have a property named **data**, which will wrap the collection of book
    objects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从服务器加载信息时，我们期望收到一个名为**data**的属性，它将包含书籍对象的集合。
- en: 'The last step to test—if everything is okay—is to load the store. To do it,
    select the **Books** store, right-click on it, and select **Load Data**; then,
    a new window will be displayed with the data loaded from the server. If you want
    to see the information that was loaded, you can also click on the eye icon as
    shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最后一步——如果一切正常的话——是加载存储。要这样做，请选择**Books**存储，右键单击它，然后选择**加载数据**；然后，将显示一个新窗口，其中包含从服务器加载的数据。如果您想查看加载的信息，也可以点击如下截图所示的眼睛图标：
- en: '![Creating the store](img/9819OS_02_12.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![创建存储](img/9819OS_02_12.jpg)'
- en: We set the proxy URL as `http://localhost/sencha-architect/extBooks/php/list.php`
    (the complete path) so we can perform this test. Usually, we simply need to set
    the relative URL; in our case, it is `php/list.php`. The complete URL is only
    for testing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代理URL设置为`http://localhost/sencha-architect/extBooks/php/list.php`（完整路径），以便我们可以进行此测试。通常，我们只需要设置相对URL；在我们的情况下，它是`php/list.php`。完整的URL仅用于测试。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the `list.php` file inside the `extbooks` project available for
    download at [https://github.com/loiane/sencha-architect-app-development](https://github.com/loiane/sencha-architect-app-development).
    Before executing the project, please execute the `dbscript.sql` file and change
    the user and password inside the `db.php` file to connect to your database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/loiane/sencha-architect-app-development](https://github.com/loiane/sencha-architect-app-development)下载的`extbooks`项目中找到`list.php`文件。在执行项目之前，请执行`dbscript.sql`文件，并将`db.php`文件中的用户名和密码更改为连接到您的数据库。
- en: A mistake most developers make is to have the server code deployed on a server
    and the Sencha Architect project deployed in a different location. We always need
    to remember that we are using an Ajax Proxy, meaning that the calls need to be
    made from the same URL (server) as the project is deployed. If you would like
    to use a different domain/server, you can use the JSONP proxy or enable **Cross-Origin
    Resource Sharing** (**CORS**) in the server side.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者犯的一个错误是将服务器代码部署在服务器上，而将Sencha Architect项目部署在不同的位置。我们始终需要记住，我们正在使用Ajax代理，这意味着调用需要从与项目部署相同的URL（服务器）进行。如果您想使用不同的域名/服务器，可以使用JSONP代理或在服务器端启用**跨源资源共享**（**CORS**）。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about CORS, please go to [http://enable-cors.org/](http://enable-cors.org/).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于CORS的信息，请访问[http://enable-cors.org/](http://enable-cors.org/)。
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `Books.js` inside
    the `app/store` directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目并查看Sencha Architect迄今为止创建的文件后，我们将看到它已在`app/store`目录中创建了一个名为`Books.js`的文件。
- en: Creating the books grid
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建书籍网格
- en: 'In the next step, we will create our first view, which is the books grid. There
    are two ways of creating a view. You can choose the one you like the most. The
    first one requires selecting the **Views** package on the project inspector, going
    to the toolbox, locating the **Grid Panel** component, and then double-clicking
    on it. A new **Grid Panel** view called `MyGridPanel` will be created under the
    **Views** package:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将创建我们的第一个视图，即书籍网格。创建视图有两种方式。您可以选择您最喜欢的一种。第一种方法需要选择项目检查器上的**视图**包，转到工具箱，找到**网格面板**组件，然后双击它。将在**视图**包下创建一个名为`MyGridPanel`的新**网格面板**视图：
- en: '![Creating the books grid](img/9819OS_02_13.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![创建书籍网格](img/9819OS_02_13.jpg)'
- en: You can use this approach for anything. If you want to add a toolbar to the
    grid, select the grid from the project inspector then go to the toolbar and double-click
    on the component you would like to add as an item of the grid (or any other view,
    store, model, or controller from the project inspector).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用这种方法做任何事情。如果您想在网格中添加工具栏，请从项目检查器中选择网格，然后转到工具栏并双击您想将其作为网格（或任何其他视图、存储、模型或控制器）项目添加的组件。
- en: 'The second way of doing it is to select the component from the toolbox and
    drag-and-drop it inside the **Views** package (or it can be a view, store, model,
    or controller as well):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是从工具箱中选择组件并将其拖放到**视图**包内（或者它也可以是一个视图、存储、模型或控制器）：
- en: '![Creating the books grid](img/9819OS_02_14.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![创建书籍网格](img/9819OS_02_14.jpg)'
- en: 'Once we have the `MyGridPanel` component under the **Views** package, we need
    to set some configurations. Select the `MyGridPanel` view, go to the config panel,
    uncheck the **initialView** property, set **userAlias** as **booksgrid** (alias
    convention is all in lowercase),and set **userClassName** as **BooksGrid** (which
    is the name of the class) as shown by *Step 1*. Then, locate the **store** property
    and select the **Books** store (*Step 2*):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在**视图**包下有了`MyGridPanel`组件，我们需要设置一些配置。选择`MyGridPanel`视图，进入配置面板，取消勾选**initialView**属性，将**userAlias**设置为**booksgrid**（别名约定全部小写），并将**userClassName**设置为**BooksGrid**（这是类的名称），如*步骤1*所示。然后，定位**store**属性并选择**Books**存储（*步骤2*）：
- en: '![Creating the books grid](img/9819OS_02_15.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![创建书籍网格](img/9819OS_02_15.jpg)'
- en: 'Now that our class is named **BooksGrid** in **Views**, select it, right-click
    on it, and select **Auto columns** (*Step 3*). This will generate all the columns
    based on the fields of the model that is associated with the store we set for
    the **BooksGrid** class (*Step 4*). However: we can only generate the autocolumns
    once we have the store set on the grid.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的类在**视图**中命名为**BooksGrid**，选择它，右键单击它，并选择**自动列**（*步骤3*）。这将根据与**BooksGrid**类关联的存储的模型字段生成所有列（*步骤4*）。然而：我们只能在设置了网格上的存储后生成自动列。
- en: 'Next, we can go to the **Design** tab on the canvas and change a few things,
    such as the grid title, column titles, and column width. To modify the title of
    the grid or a column, simply double-click on it as follows (or you can do it by
    using the config panel):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以转到画布上的**设计**选项卡，更改一些内容，例如网格标题、列标题和列宽。要修改网格或列的标题，只需双击它，如下所示（或者您也可以通过使用配置面板来完成）：
- en: '![Creating the books grid](img/9819OS_02_16.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![创建书籍网格](img/9819OS_02_16.jpg)'
- en: These features can save us some time, because we do not need to go to the config
    panel to configure them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能可以为我们节省一些时间，因为我们不需要进入配置面板来配置它们。
- en: Our last step is to add a paging toolbar to the books grid. Select the **BooksGrid**
    class on the project inspector, go to the toolbox, locate the paging toolbar,
    and double- click on it. The paging toolbar will be added to the **BooksGrid**
    class (or you can drag it from the toolbox and drop it on the **BooksGrid** class).
    As the store is already set on the grid, it will be set automatically to the paging
    toolbar as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一步是将分页工具栏添加到书籍网格中。在项目检查器中选择**BooksGrid**类，进入工具箱，找到分页工具栏，并双击它。分页工具栏将被添加到**BooksGrid**类中（或者您可以从工具箱中拖动它并将其放在**BooksGrid**类上）。由于存储已经设置在网格上，它也将自动设置到分页工具栏上。
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `BooksGrid.js` inside
    the `app/view` directory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目并查看Sencha Architect迄今为止创建的文件，我们会看到它已经在`app/view`目录中创建了一个名为`BooksGrid.js`的文件。
- en: Creating the viewport
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建视口
- en: 'Our next step is to create a viewport. To do so, select the **Views** package
    (*Step 1*), and on the toolbox, locate the **Viewport** component and double-click
    on it (*Step 2*). Select the **MyViewport** view from the **Views** package on
    the project inspector, go to the config panel, and set some properties: mark **initialView**
    and set **userClassName** as **Main** (*Step 3*). Finally, go to the **Design**
    tab and click on the blank area. A blue border should be displayed. Select the
    flyout config button and select **fit** as **Layout** as demonstrated in the following
    screenshot (*Step 4*):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一步是创建一个视口。为此，选择**视图**包（*步骤1*），在工具箱中找到**Viewport**组件并双击它（*步骤2*）。从项目检查器中选择**视图**包中的**MyViewport**视图，进入配置面板，并设置一些属性：勾选**initialView**并将**userClassName**设置为**Main**（*步骤3*）。最后，转到**设计**选项卡并点击空白区域。应该会显示一个蓝色边框。选择飞出配置按钮并选择**fit**作为**布局**，如以下截图所示（*步骤4*）：
- en: '![Creating the viewport](img/9819OS_02_17.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![创建视口](img/9819OS_02_17.jpg)'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about viewports, please go to [http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.container](http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.container).
    To learn more about the Fit Layout, please go to [http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.layout.container.Fit](http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.layout.container.Fit).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于视口的信息，请访问[http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.container](http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.container)。要了解更多关于Fit布局的信息，请访问[http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.layout.container.Fit](http://docs.sencha.com/extjs/4.2.1/#!/api/Ext.layout.container.Fit)。
- en: 'We cannot forget to always have **initialView** on the project. One of the
    **View** classes must have the highlighted icon as shown in the next screenshot,
    otherwise we will get a blank screen when we execute the project:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能忘记始终在项目中保留 **initialView**。**视图** 类中必须有一个如图所示的高亮图标，否则当我们执行项目时将得到一个空白屏幕：
- en: '![Creating the viewport](img/9819OS_02_18.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![创建视口](img/9819OS_02_18.jpg)'
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `Main.js` inside
    the `app/view` directory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们保存项目并查看 Sencha Architect 到目前为止创建的文件，我们会看到它已经在 `app/view` 目录中创建了一个名为 `Main.js`
    的文件。
- en: Linking the grid to the viewport
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将网格链接到视口
- en: 'Our next goal is to make the `booksgrid` class an item of the viewport we created.
    So, let''s go ahead and make it happen. The first step is to select the `booksgrid`
    class, then drag-and-drop it on the `Main` class:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个目标是使 `booksgrid` 类成为我们创建的视口的项。所以，让我们继续前进并实现它。第一步是选择 `booksgrid` 类，然后将其拖放到
    `Main` 类上：
- en: '![Linking the grid to the viewport](img/9819OS_02_19.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![链接网格到视口](img/9819OS_02_19.jpg)'
- en: A window will be displayed with a **Copy** **Component** question. We will choose
    **Link**; this way, our `booksgrid` class will continue a class and we can reuse
    its code. If we choose **Copy**, Sencha Architect will copy all the **BooksGrid**
    code into the `Main` class as an item. And if we choose **Move**, Sencha Architect
    will delete the `booksgrid` class and put all its code inside the `Main` class
    as an item.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示一个带有 **复制** **组件** 问题的窗口。我们将选择 **链接**；这样，我们的 `booksgrid` 类将继续作为一个类，我们可以重用其代码。如果我们选择
    **复制**，Sencha Architect 将将所有 **BooksGrid** 代码复制到 `Main` 类作为一个项。如果我们选择 **移动**，Sencha
    Architect 将删除 `booksgrid` 类并将所有代码放入 `Main` 类作为一个项。
- en: 'As a result, we will see a blue line connecting the `booksgrid` class to the
    `Main` class. If we verify the `Main` class source code on the code editor, we
    will notice that the `booksgrid` class is declared as an item of the viewport
    by using its **xtype** (the `userAlias` property on the config panel):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，我们将看到一个蓝色线条连接 `booksgrid` 类和 `Main` 类。如果我们验证代码编辑器上的 `Main` 类源代码，我们会注意到 `booksgrid`
    类是通过使用其 **xtype**（配置面板上的 `userAlias` 属性）被声明为视口的项：
- en: '![Linking the grid to the viewport](img/9819OS_02_20.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![链接网格到视口](img/9819OS_02_20.jpg)'
- en: Linking components is a great way of reusing components on Sencha Architect.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Sencha Architect 中链接组件是一种很好的重用组件的方法。
- en: The output so far
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到目前为止的输出
- en: 'It is time to execute our project for the first time. On the toolbar, click
    on the **Preview** icon. Your default browser will open a page like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候执行我们的项目了。在工具栏上，点击 **预览** 图标。您的默认浏览器将打开一个类似这样的页面：
- en: '![The output so far](img/9819OS_02_21.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![到目前为止的输出](img/9819OS_02_21.jpg)'
- en: 'This is because Sencha Architect thinks the `app.html` page, which is the page
    that contains all the code from our application (Sencha Architect creates the
    `app.html` file instead of `index.html`), is deployed on the `root` folder of
    the webserver, which is not true. In our case, the application is located at the
    `htdocs/sencha-architect/extBooks` directory (`htdocs` is the public folder of
    Xampp). So, we need to set the correct location on the project''s settings. On
    the toolbar, click on the **Settings** icon. A new window will be displayed; click
    on the **Project** tab and put the full path to the project''s directory as shown
    in the following screenshot (**URL prefix**):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Sencha Architect 认为包含我们应用程序（Sencha Architect 创建 `app.html` 文件而不是 `index.html`）所有代码的
    `app.html` 页面部署在 web 服务器的 `root` 文件夹上，这并不正确。在我们的情况下，应用程序位于 `htdocs/sencha-architect/extBooks`
    目录（`htdocs` 是 Xampp 的公共文件夹）。因此，我们需要在项目设置中设置正确的位置。在工具栏上，点击 **设置** 图标。将显示一个新窗口；点击
    **项目** 选项卡，并将项目目录的完整路径放入以下截图所示（**URL 前缀**）：
- en: '![The output so far](img/9819OS_02_22.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![到目前为止的输出](img/9819OS_02_22.jpg)'
- en: 'Now, if we try to execute the project again, it will open the correct URL with
    the grid we just created:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次尝试执行项目，它将打开我们刚刚创建的网格的正确 URL：
- en: '![The output so far](img/9819OS_02_23.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![到目前为止的输出](img/9819OS_02_23.jpg)'
- en: But wait a second, the grid is empty, and on the test we performed with the
    store, the server is returning some data. We need to create a controller to load
    the store when the grid is rendered; this way, we will have some information displayed
    inside the grid.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，网格是空的，在我们进行的测试中，服务器返回了一些数据。我们需要创建一个控制器，当网格渲染时加载存储；这样，我们将在网格内显示一些信息。
- en: Creating the controller
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建控制器
- en: 'So, to create the controller, let''s go back to the top of the project inspector
    and click on the **+** icon once again and select the **Controller** option (*Step
    1*). Then, with the controller selected, go to the config panel and change its
    **userClassname** to **Book** (*Step 2*):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建控制器，让我们回到项目检查器的顶部并再次点击**+**图标，然后选择**Controller**选项（*步骤1*）。然后，在选择了控制器后，转到配置面板并将它的**userClassname**更改为**Book**（*步骤2*）：
- en: '![Creating the controller](img/9819OS_02_24.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/9819OS_02_24.jpg)'
- en: 'Still on the config panel, locate the **models**, **stores**, and **views**
    properties (*Step 3*). With these properties, we will declare the **models**,
    **stores**, and **views** that this controller will care about. Once you select
    a model, store, or view, Sencha Architect will display the following window with
    a question. Click on **Remove**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在配置面板中，找到**models**、**stores**和**views**属性（*步骤3*）。有了这些属性，我们将声明控制器将关心的**models**、**stores**和**views**。一旦您选择了一个模型、存储或视图，Sencha
    Architect将显示以下带有问题的窗口。点击**移除**：
- en: '![Creating the controller](img/9819OS_02_25.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/9819OS_02_25.jpg)'
- en: This is because on the application (`app.js`), as we create models, stores,
    and views, they will be declared on the **models**, **views**, and **stores**
    properties of the application. With this step, we are transferring the responsibility
    to the controller, and there is no need to keep their declaration on the `app.js`
    file and also on the controller (which is what will happen if we click on the
    **Keep** button).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在应用程序（`app.js`）中，当我们创建模型、存储和视图时，它们将被声明在应用程序的**models**、**views**和**stores**属性中。通过这一步，我们将责任转移到控制器，并且不需要在`app.js`文件和控制器（如果我们点击**保留**按钮会发生的情况）中保留它们的声明。
- en: 'The next step is to add **Controller** **Action** to the **Book** controller.
    To do so, select the **Book** controller on the project inspector, go to the toolbox,
    locate **Controler** **Action**, and double-click on it (or drag-and-drop, as
    you wish) as demonstrated by *Step 1*. Once **Controller** **Action** is listed
    under the **Book** controller, select it (*Step 2*), go to the config panel, and
    choose **BooksGrid** as **targetType**; then on **EventBinding**, select the name
    of the event we want to listen to, which is **render**. If you would like, you
    can change the **controlQuery** to be more specific and the name of **BasicFunction**
    (**fn**) as well (*Step 3*):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将**控制器****操作**添加到**书籍**控制器中。为此，在项目检查器中选择**书籍**控制器，转到工具箱，找到**控制器****操作**，并双击它（或按需拖放），如*步骤1*所示。一旦**控制器****操作**在**书籍**控制器下列出，选择它（*步骤2*），转到配置面板，并将**targetType**选择为**BooksGrid**；然后在**EventBinding**中，选择我们想要监听的事件名称，即**render**。如果您愿意，可以将**controlQuery**改为更具体，并将**BasicFunction**（**fn**）的名称也更改（*步骤3*）：
- en: '![Creating the controller](img/9819OS_02_26.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![创建控制器](img/9819OS_02_26.jpg)'
- en: After these steps, the code editor will open the **onGridpanelRender** function
    editor, so we can add the code we desire (we need to enter the code as shown in
    *Step 4*). In this case, the render event passes the grid reference (**component**)
    as a parameter and also some options (**eOpts**). So, we need to get the grid
    reference (**component**), call the `getStore` method to get the store reference,
    and then the `load` method so the store can load the information from the server
    (*Step 4*).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤之后，代码编辑器将打开**onGridpanelRender**函数编辑器，因此我们可以添加我们想要的代码（我们需要输入*步骤4*中显示的代码）。在这种情况下，渲染事件将网格引用（**component**）作为参数传递，还传递了一些选项（**eOpts**）。因此，我们需要获取网格引用（**component**），调用`getStore`方法以获取存储引用，然后调用`load`方法，以便存储可以从服务器加载数据（*步骤4*）。
- en: Notice that we worked on the model, store, views and in the controller. Sencha
    Architect has generated all the code so far for us. Only now, on a controller
    action, do we have to use the code editor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在模型、存储、视图和控制器上进行了工作。到目前为止，Sencha Architect已经为我们生成了所有代码。现在，只有在控制器操作中，我们才必须使用代码编辑器。
- en: Once we save the project and take a look at the files that Sencha Architect
    has created so far, we will see that it created a file named `Book.js` inside
    the `app/controller` directory.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 保存项目并查看Sencha Architect迄今为止创建的文件后，我们将看到它已经在`app/controller`目录中创建了一个名为`Book.js`的文件。
- en: We can click on the preview icon again on the toolbar and now we will see the
    final version of our project.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在工具栏上再次点击预览图标，现在我们将看到我们项目的最终版本。
- en: The final project structure
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终的项目结构
- en: 'As we have now finished implementing our first Ext JS project with Sencha Architect,
    let''s take a look at the code generated for us:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经使用 Sencha Architect 完成了第一个 Ext JS 项目的实现，让我们来看看为我们生成的代码：
- en: '![The final project structure](img/9819OS_02_27.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![最终项目结构](img/9819OS_02_27.jpg)'
- en: Notice that Sencha Architect created all the files for us (with the exception
    of the server-side code `php` folder).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 Sencha Architect 为我们创建了所有文件（除了服务器端代码的 `php` 文件夹）。
- en: It is very important to bring to our attention that we cannot modify the files
    on a code editor. In case we do modify any files and try to open them on Sencha
    Architect again, all changes will be lost because Sencha Architect will override
    them. So, in case you decide you want to change any file on a code editor, it
    is important to know that you will not be able to use Sencha Architect again (and
    if you do, you will lose the modifications).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要引起我们的注意，我们不能在代码编辑器上修改文件。如果我们修改了任何文件并尝试再次在 Sencha Architect 上打开它们，所有更改都将丢失，因为
    Sencha Architect 将覆盖它们。所以，如果你决定想在代码编辑器上更改任何文件，重要的是要知道你将无法再次使用 Sencha Architect（如果你这样做，你将丢失这些修改）。
- en: Summary
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to implement our first Ext JS project using
    Sencha Architect. We learned how to create a new Ext JS project and set up the
    `app.js` file using the application. We learned how to create models, stores,
    views, and controller, and how to reuse a component by linking it to another component.
    We have also learned how to test a store to see if the information is being loaded
    from the server correctly and how to configure the project settings to execute
    it for the first time.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Sencha Architect 实现我们的第一个 Ext JS 项目。我们学习了如何创建一个新的 Ext JS 项目，并使用应用程序设置
    `app.js` 文件。我们还学习了如何创建模型、存储、视图和控制器，以及如何通过将其链接到另一个组件来重用组件。我们还学习了如何测试存储以查看信息是否正确从服务器加载，以及如何配置项目设置以执行第一次运行。
- en: In the next chapter, we will create our first Sencha Touch application with
    Sencha Architect.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用 Sencha Architect 创建我们的第一个 Sencha Touch 应用程序。
