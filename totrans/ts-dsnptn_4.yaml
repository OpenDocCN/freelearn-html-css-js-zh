- en: 'Chapter 6. Behavioral Design Patterns: Continuous'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章. 行为设计模式：持续
- en: 'In the previous chapter, we''ve already talked about some of the behavioral
    design patterns. We''ll be continuing with more patterns in this category in this
    chapter, including: Strategy Pattern, State Pattern, Template Method Pattern,
    Observer Pattern, and Visitor Pattern.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们已经讨论了一些行为设计模式。在本章中，我们将继续讨论这一类别中的更多模式，包括：策略模式、状态模式、模板方法模式、观察者模式和访问者模式。
- en: 'Many of these patterns share the same idea: unify the shape and vary the details.
    Here is a quick overview:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些模式都共享同一个理念：统一形状，变化细节。以下是一个简要概述：
- en: '**Strategy Pattern** and **Template Pattern**: Defines the same outline of
    algorithms'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略模式** 和 **模板模式**: 定义了相同的算法轮廓'
- en: '**State Pattern**: Provides different behavior for objects in different states
    with the same interface'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态模式**: 为具有相同接口的不同状态的对象提供不同的行为'
- en: '**Observer Pattern**: Provides a unified process of handling subject changes
    and notifying observers'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者模式**: 提供处理主题变化和通知观察者的统一过程'
- en: '**Visitor Pattern**: Does similar jobs as Strategy Pattern sometimes, but avoids
    an over complex interface that might be required for Strategy Pattern to handle
    objects in many different types'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问者模式**: 有时与策略模式做相似的工作，但避免了策略模式处理许多不同类型对象可能需要的过于复杂的接口'
- en: Patterns that will be discussed in this chapter could be applied in different
    scopes just as many patterns in other categories.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将要讨论的这些模式可以在不同的范围内应用，就像其他类别中的许多模式一样。
- en: Strategy Pattern
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: It's common that a program has similar outlines for processing different targets
    with different detailed algorithms. Strategy Pattern encapsulates those algorithms
    and makes them interchangeable within the shared outline.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 程序通常会有类似的轮廓来处理不同的目标，使用不同的详细算法。策略模式封装了这些算法，并在共享轮廓中使它们可互换。
- en: 'Consider conflicting merging processes of data synchronization, which we talked
    about in [Chapter 2](ch02.html "Chapter 2. The Challenge of Increasing Complexity"),
    *The Challenge of Increasing Complexity*. Before refactoring, the code was like
    this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑数据同步中冲突的合并过程，这是我们之前在[第二章](ch02.html "第二章. 增加复杂性的挑战")中讨论的，即《增加复杂性的挑战》。在重构之前，代码是这样的：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But later we found out that we could actually extract the same outlines from
    different phases of the synchronization process, and encapsulate them as different
    strategies. After refactoring, the outline of the code became as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但后来我们发现，我们可以从同步过程的不同阶段提取相同的轮廓，并将它们封装为不同的策略。重构后，代码的轮廓如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We get a lot of ways to compose and organize those strategy objects or classes
    sometimes in JavaScript. A possible structure for Strategy Pattern could be:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在JavaScript中，我们有很多种方式来组合和组织这些策略对象或类。策略模式的可能结构可以是：
- en: '![Strategy Pattern](img/image_06_001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![策略模式](img/image_06_001.jpg)'
- en: In this structure, the client is responsible for fetching specific strategies
    from the table and applying operations of the current phase.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个结构中，客户端负责从表中获取特定的策略并应用当前阶段的操作。
- en: 'Another structure is using contextual objects and letting them control their
    own strategies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种结构是使用上下文对象，并让它们控制自己的策略：
- en: '![Strategy Pattern](img/image_06_002.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![策略模式](img/image_06_002.jpg)'
- en: Thus the client needs only to link a specific context with the corresponding
    strategy.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，客户端只需要将特定的上下文与相应的策略相连接。
- en: Participants
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'We''ve mentioned two possible structures for Strategy Pattern, so let''s discuss
    the participants separately. For the first structure, the participants include
    the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了策略模式的两种可能结构，因此让我们分别讨论参与者。对于第一种结构，参与者包括以下内容：
- en: '**Strategy**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**'
- en: Defines the interface of strategy objects or classes.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义策略对象或类的接口。
- en: '**Concrete strategy**: `ConcreteStrategyA` and `ConcreteStrategyB`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体策略**: `ConcreteStrategyA` 和 `ConcreteStrategyB`'
- en: Implements concrete strategy operations defined by the `Strategy` interface.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现`Strategy`接口定义的具体策略操作。
- en: '**Strategy manager**: `Strategies`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略管理器**: `策略`'
- en: 'Defines a data structure to manage strategy objects. In the example, it''s
    just a simple hash table that uses data type names as keys and strategy objects
    as values. It could be more complex on demand: for example, with matching patterns
    or conditions.'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义一个数据结构来管理策略对象。在示例中，它只是一个简单的哈希表，使用数据类型名称作为键，策略对象作为值。根据需求，它可能更复杂：例如，使用匹配模式或条件。
- en: '**Target**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**'
- en: The target to apply algorithms defined in strategy objects.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用策略对象中定义的算法的目标。
- en: '**Client**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**'
- en: Makes targets and strategies cooperate.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使目标和策略合作。
- en: 'The participants of the second structure include the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个结构的参与者包括以下内容：
- en: '**Strategy** and **concrete strategy**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**策略**和**具体策略**'
- en: The same as in the preceding section.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与上一节相同。
- en: '**Context**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**'
- en: Defines a reference to the strategy object applied. Provides related methods
    or property getters for clients to operate.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义应用策略对象的引用。为客户端提供相关的方法或属性获取器以进行操作。
- en: '**Client**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**'
- en: Manages context objects.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 管理上下文对象。
- en: Pattern scope
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Strategy Pattern is usually applied to scopes with small or medium sizes. It
    provides a way to encapsulate algorithms and makes those algorithms easier to
    manage under the same outline. Strategy Pattern can also be the core of an entire
    solution sometimes, and a good example is the synchronization implementation we've
    been playing with. In this case, Strategy Pattern builds the bridge of plugins
    and makes the system extendable. But most of the time, the fundamental work done
    by Strategy Pattern is decoupling concrete strategies, contexts, or targets.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式通常应用于小或中型的范围。它提供了一种封装算法的方法，使得在相同的轮廓下管理这些算法变得更加容易。有时，策略模式也可以是整个解决方案的核心，一个很好的例子是我们一直在使用的同步实现。在这种情况下，策略模式构建了插件之间的桥梁，使得系统可扩展。但大多数时候，策略模式的基本工作是将具体的策略、上下文或目标解耦。
- en: Implementation
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现方式
- en: The implementation starts with defining the interfaces of objects we'll be playing
    with. We have two target types in string literal type `'a'` and `'b'`. Targets
    of type `'a'`  have a `result` property with type `string`, while targets of type
    `'b'` have a `value` property with type `number`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实现开始于定义我们将要使用的对象的接口。我们有两种目标类型，字符串字面量类型`'a'`和`'b'`。类型`'a'`的目标有一个类型为`string`的`result`属性，而类型`'b'`的目标有一个类型为`number`的`value`属性。
- en: 'The interfaces we''ll have look, are like:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将拥有的接口看起来是这样的：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we''ll define the concrete strategy objects without a constructor:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将定义没有构造函数的具体策略对象：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To make it easier for a client to fetch those strategies, we''ll put them into
    a hash table:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让客户端更容易获取这些策略，我们将它们放入哈希表中：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And now we can make them work with targets in different types:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以让它们与不同类型的目标一起工作：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Consequences
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Strategy Pattern makes the foreseeable addition of algorithms for contexts or
    targets under new categories easier. It also makes the outline of a process even
    cleaner by hiding trivial branches of behaviors selection.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式使得在新的类别下为上下文或目标添加算法变得更容易可预见。它还通过隐藏行为选择中的琐碎分支，使流程的轮廓更加清晰。
- en: However, the abstraction of algorithms defined by the `Strategy` interface may
    keep growing while we are trying to add more strategies and satisfy their requirements
    of parameters. This could be a problem for a Strategy Pattern with clients that
    are managing targets and strategies. But for the other structures which the references
    of strategy objects are stored by contexts themselves, we can manage to trade-off
    the interchangeability. This would result in Visitor Pattern, which we are going
    to talk about later in this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Strategy`接口定义的算法的抽象可能会在尝试添加更多策略并满足它们的参数要求时不断增长。这对于管理目标和策略的客户端来说可能是一个问题。但对于其他结构，其中策略对象的引用是由上下文本身存储的，我们可以设法权衡可互换性。这会导致我们将在本章后面讨论的访问者模式。
- en: And as we've mentioned before, Strategy Pattern can also provide notable extensibility
    if an extendable strategy manager is available or the client of contexts is designed
    to.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，如果有一个可扩展的策略管理器可用，或者上下文的客户端被设计为可扩展的，策略模式也可以提供显著的扩展性。
- en: State Pattern
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式
- en: 'It''s possible for some objects to behave completely differently when they
    are in different states. Let''s think about an easy example first. Consider rendering
    and interacting with a custom button in two states: enabled and disabled. When
    the button is enabled, it lights up and changes its style to active on a mouse
    hover, and of course, it handles clicks; when disabled, it dims and no longer
    cares about mouse events.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象处于不同状态时，它们的行为可能完全不同。让我们先考虑一个简单的例子。考虑在两种状态下渲染和与自定义按钮交互：启用和禁用。当按钮处于启用状态时，它会亮起并改变鼠标悬停时的样式为活动状态，当然，它也处理点击事件；当禁用时，它会变暗并且不再关心鼠标事件。
- en: 'We may think of an abstraction with two operations: `render` (with a parameter
    that indicates whether the mouse is hovering) and `click`; along with two states:
    *enabled* and *disabled*. We can even divide deeper and have state *active*, but
    that won''t be necessary in our case.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个具有两个操作的抽象：`render`（带有表示鼠标是否悬停的参数）和`click`；以及两个状态：*启用*和*禁用*。我们甚至可以进一步细分，拥有*活动*状态，但在我们的情况下这并不必要。
- en: '![State Pattern](img/image_06_003.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![状态模式](img/image_06_003.jpg)'
- en: And now we can have `StateEnabled` with both `render` and `click` methods implemented,
    while having `StateDisabled` with only `render` method implemented because it
    does not care about the `hover` parameter. In this example, we are expecting every
    method of the states being callable. So we can have the abstract class `State`
    with empty `render` and `click` methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以实现具有`render`和`click`方法的`StateEnabled`，同时实现只有`render`方法的`StateDisabled`，因为它不关心`hover`参数。在这个例子中，我们期望每个状态的方法都是可调用的。因此，我们可以有一个抽象类`State`，其中包含空的`render`和`click`方法。
- en: Participants
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of State Pattern include the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式的参与者包括以下内容：
- en: '**State**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**'
- en: Defines the interface of state objects that are being switched to internally.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了正在内部切换的状态对象的接口。
- en: '**Concrete state**: `StateEnabled` and `StateDisabled`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体状态**：`StateEnabled`和`StateDisabled`'
- en: Implements the `State` interface with behavior corresponding to a specific state
    of the context. May have an optional reference back to its context.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现与上下文特定状态相对应的行为的`State`接口。可能有一个可选的对其上下文的引用。
- en: '**Context**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**'
- en: Manages references to different states, and makes operations defined on the
    active one.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 管理对不同状态的引用，并执行在活动状态上定义的操作。
- en: Pattern scope
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: 'State Pattern usually applies to the code of scopes with the size of a feature.
    It does not specify whom to transfer the state of context: it could be either
    the context itself, the state methods, or code that controls context.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式通常适用于具有功能规模的代码范围。它不指定谁要转移上下文的状态：这可能既可以是上下文本身，也可以是状态方法，或者控制上下文的代码。
- en: Implementation
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Start with the `State` interface (it could also be an abstract class if there
    are operations or logic to share):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从`State`接口开始（如果存在要共享的操作或逻辑，它也可以是一个抽象类）：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With the `State` interface defined, we can move to `Context` and sketch its
    outline:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`State`接口后，我们可以转向`Context`并勾勒其轮廓：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we are going to have the two states, `StateEnabled` and `StateDisabled`
    implemented. First, let''s address `StateEnabled`, it cares about `hover` status
    and handles `click` event:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将实现两个状态，`StateEnabled`和`StateDisabled`。首先，让我们处理`StateEnabled`，它关心`hover`状态并处理`click`事件：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, for `StateDisabled` it just ignores `hover` parameter and does nothing
    when `click` event emits:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于`StateDisabled`，它只是忽略`hover`参数，当`click`事件发生时什么也不做：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we have classes of states *enabled* and *disabled* ready. As the instances
    of those classes are associated with the context, we need to initialize every
    state when a new `Context` is initiated:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了*启用*和*禁用*的状态类。由于这些类的实例与上下文相关联，因此每当一个新的`Context`被初始化时，我们需要初始化每个状态：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is possible to use flyweights by passing context in when invoking every operation
    on the active state as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用活动状态的每个操作时传递上下文，也可以使用轻量级对象。
- en: 'Now let''s finish the `Context` by listening to and forwarding proper events:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过监听和转发适当的事件来完成`Context`：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Consequences
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: State Pattern reduces conditional branches in potentially multiple methods of
    context objects. As a trade-off, extra state objects are introduced, though it
    usually won't be a big problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式减少了上下文对象可能多个方法中的条件分支。作为权衡，引入了额外的状态对象，尽管这通常不会是一个大问题。
- en: The context object in State Pattern usually delegates operations and forwards
    them to the current state object. Thus operations defined by a concrete state
    may have access to the context itself. This makes reusing state objects possible
    with flyweights.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 状态模式中的上下文对象通常将操作委托给当前状态对象并转发它们。因此，具体状态定义的操作可能可以访问上下文本身。这使得使用轻量级对象重用状态对象成为可能。
- en: Template Method Pattern
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法模式
- en: When we are talking about subclassing or inheriting, the building is usually
    built from the bottom up. Subclasses inherit the basis and then provide more.
    However, it could be useful to reverse the structure sometimes as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论子类化或继承时，建筑通常是自下而上建造的。子类继承基础并提供更多功能。然而，有时反转结构也可能很有用。
- en: Consider Strategy Pattern which defines the outline of a process and has interchangeable
    algorithms as strategies. If we apply this structure under the hierarchy of classes,
    we will have Template Method Pattern.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑策略模式，它定义了过程的轮廓，并具有可互换的算法作为策略。如果我们在这个类层次结构下应用这种结构，我们将得到模板方法模式。
- en: 'A template method is an abstract method (optionally with default implementation)
    and acts as a placeholder under the outline of a larger process. Subclasses override
    or implement related methods to modify or complete the behaviors. Imaging the
    skeleton of a `TextReader`, we are expecting its subclasses to handle text files
    from different storage media, detect different encodings and read all the text.
    We may consider a structure like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法是一个抽象方法（可选带有默认实现），在更大过程轮廓下充当占位符。子类覆盖或实现相关方法以修改或完成行为。想象一下 `TextReader` 的骨架，我们期望其子类能够处理来自不同存储介质的文本文件，检测不同的编码并读取所有文本。我们可能考虑以下结构：
- en: '![Template Method Pattern](img/image_06_004.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法模式](img/image_06_004.jpg)'
- en: 'The `TextReader` in this example has a method `readAllText` that reads all
    text from a resource by two steps: reading all bytes from the resource (`readAllBytes`),
    and then decoding those bytes with certain encoding (`decodeBytes`).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`TextReader` 有一个名为 `readAllText` 的方法，通过两个步骤读取资源中的所有文本：从资源中读取所有字节（`readAllBytes`），然后使用特定的编码对这些字节进行解码（`decodeBytes`）。
- en: The structure also suggests the possibility of sharing implementations among
    concrete classes that implement template methods. We may create an abstract class
    `AsciiTextReader` that extends `TextReader` and implements method `decodeBytes`.
    And build concrete classes `FileAsciiTextReader` and `HttpAsciiTextReader` that
    extend `AsciiTextReader` and implement method `readAllBytes` to handle resources
    on different storage media.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结构还暗示了在实现模板方法的具体类之间共享实现的可能性。我们可能创建一个扩展 `TextReader` 并实现 `decodeBytes` 方法的抽象类
    `AsciiTextReader`。然后构建扩展 `AsciiTextReader` 并实现 `readAllBytes` 方法的具体类 `FileAsciiTextReader`
    和 `HttpAsciiTextReader`，以处理不同存储介质上的资源。
- en: Participants
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Template Method Pattern include the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式的参与者包括以下内容：
- en: '**Abstract class**: `TextReader`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象类**: `TextReader`'
- en: Defines the signatures of template methods, as well as the outline of algorithms
    that weave everything together.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义模板方法的签名，以及将一切编织在一起的算法的轮廓。
- en: '**Concrete classes**: `AsciiTextReader`, `FileAsciiTextReader` and `HttpAsciiTextReader`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体类**: `AsciiTextReader`, `FileAsciiTextReader` 和 `HttpAsciiTextReader`'
- en: Implements template methods defined in abstract classes. Typical concrete classes
    are `FileAsciiTextReader` and `HttpAsciiTextReader` in this example. However,
    compared to being abstract, *defining the outline of algorithms* weighs more in
    the categorization.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现抽象类中定义的模板方法。在这个例子中，典型的具体类是 `FileAsciiTextReader` 和 `HttpAsciiTextReader`。然而，与定义算法轮廓相比，*定义算法轮廓*在分类中更为重要。
- en: Pattern scope
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Template Method Pattern is usually applied in a relatively small scope. It provides
    an extendable way to implement features and avoid redundancy from the upper structure
    of a series of algorithms.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式通常应用于相对较小的范围。它提供了一种可扩展的方式来实现功能，并避免一系列算法的上层结构中的冗余。
- en: Implementation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'There are two levels of the inheriting hierarchy: the `AsciiTextReader` will
    subclass `TextReader` as another abstract class. It implements method `decodeBytes`
    but leaves `readAllBytes` to its subclasses. Starting with the `TextReader`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 继承层次结构有两个级别：`AsciiTextReader` 将作为另一个抽象类子类化 `TextReader`。它实现了 `decodeBytes` 方法，但将
    `readAllBytes` 留给其子类。从 `TextReader` 开始：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We are using Promises with `async` and `await` which are coming to ECMAScript
    next. Please refer to the following links for more information:[https://github.com/Microsoft/TypeScript/issues/1664](https://github.com/Microsoft/TypeScript/issues/1664)
    [https://tc39.github.io/ecmascript-asyncawait/](https://tc39.github.io/ecmascript-asyncawait/)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`async`和`await`与Promise一起，这些功能将在ECMAScript中到来。请参阅以下链接以获取更多信息：[https://github.com/Microsoft/TypeScript/issues/1664](https://github.com/Microsoft/TypeScript/issues/1664)
    [https://tc39.github.io/ecmascript-asyncawait/](https://tc39.github.io/ecmascript-asyncawait/)
- en: 'And now let''s subclass `TextReader` as `AsciiTextReader` which still remains
    abstract:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`TextReader`子类化为`AsciiTextReader`，它仍然保持抽象：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For `FileAsciiTextReader`, we''ll need to import filesystem (`fs`) module of
    Node.js to perform file reading:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`FileAsciiTextReader`，我们需要导入Node.js的文件系统（`fs`）模块来执行文件读取：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For `HttpAsciiTextReader`, we are going to use a popular package `request`
    to send HTTP requests:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`HttpAsciiTextReader`，我们将使用流行的`request`包来发送HTTP请求：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Both concrete reader implementations pass resolver functions to the Promise
    constructor for converting asynchronous Node.js style callbacks to Promises. For
    more information, read more about the Promise constructor : [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 两个具体的读取实现都将解析函数传递给Promise构造函数，以将异步Node.js风格回调转换为Promise。有关更多信息，请阅读有关Promise构造函数的更多内容：[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)。
- en: Consequences
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Compared to Strategy Pattern, Template Method Pattern provides convenience for
    building objects with the same outline of algorithms outside of the existing system.
    This makes Template Method Pattern a useful way to build tooling classes instead
    of fixed processes built-in.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与策略模式相比，模板方法模式为在现有系统之外构建具有相同算法轮廓的对象提供了便利。这使得模板方法模式成为构建工具类而不是内置固定过程的有用方式。
- en: But Template Method Pattern has less runtime flexibility as it does not have
    a *manager*. It also relies on the client who's using those objects to do the
    work. And as the implementation of Template Method Pattern relies on subclassing,
    it could easily result in hierarchies that have a similar code on different branches.
    Though this could be optimized by using techniques like *mixin*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但模板方法模式由于没有`*manager*`，运行时灵活性较低。它还依赖于使用这些对象的客户端来完成工作。并且由于模板方法模式的实现依赖于子类化，它很容易导致在不同分支上有类似代码的层次结构。尽管可以通过使用像*mixin*这样的技术来优化。
- en: Observer Pattern
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Observer Pattern is an important Pattern backed by an important idea in software
    engineering. And it is usually a key part of MVC architecture and its variants
    as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是一个重要的模式，它背后有一个在软件工程中非常重要的想法。它通常是MVC架构及其变体的关键部分。
- en: If you have ever written an application with a rich user interface without a
    framework like Angular or a solution with React, you might probably have struggled
    with changing class names and other properties of UI elements. More specifically,
    the code that controls those properties of the same group of elements lies every
    branch related to the elements in related event listeners, just to keep the elements
    being correctly updated.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经编写过没有Angular或React等框架的丰富用户界面应用程序，或者编写过解决方案，你可能会在更改UI元素的类名和其他属性时遇到困难。更具体地说，控制同一组元素属性的相关代码位于与相关事件监听器相关的每个分支中，只是为了确保元素被正确更新。
- en: Consider a "Do" button of which the `disabled` property should be determined
    by the status of a `WebSocket` connection to a server and whether the currently
    active item is done. Every time the status of either the connection or the active
    item gets updated, we'll need to update the button correspondingly. The most "handy"
    way could be two somewhat identical groups of code being put in two event listeners.
    But in this way, the amount of similar code would just keep growing as more relevant
    objects get involved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个“执行”按钮，其`disabled`属性应由连接到服务器的`WebSocket`连接的状态以及当前活动项是否完成来决定。每当连接或活动项的状态更新时，我们都需要相应地更新按钮。最“方便”的方法可能是将两个有些相似的代码组放入两个事件监听器中。但这样，随着更多相关对象的参与，相似代码的数量会不断增加。
- en: The problem in this "Do" button example is that, the behavior of code that's
    controlling the button is driven by primitive events. The heavy load of managing
    the connections and behaviors among different events is directly taken by the
    developer who's writing that code. And unfortunately, the complexity in this case,
    grows exponentially, which means it could easily exceed our brain capacity. Writing
    code this way might result in more bugs and make maintaining much likely to introduce
    new bugs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个“执行”按钮的例子中，问题在于，控制按钮的代码的行为是由原始事件驱动的。管理不同事件之间的连接和行为的大量工作直接由编写该代码的开发者承担。不幸的是，在这种情况下，复杂性呈指数增长，这意味着它可能很容易超过我们的脑容量。以这种方式编写代码可能会导致更多错误，并使维护更容易引入新的错误。
- en: 'But the beautiful thing is, we can find the factors that multiply and output
    the desired result, and the reference for dividing those factors are groups of
    related states. Still speaking of the "Do" button example, what the button cares
    about is: connection status and the active item status (assuming they are booleans
    `connected` and `loaded`). We can have the code written as two parts: one part
    that changes those states, and another part that updates the button:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但美妙的是，我们可以找到乘积因子并输出所需的结果，而那些因子的参考是相关状态的一组。仍然以“执行”按钮的例子来说，按钮所关心的是：连接状态和活动项状态（假设它们是布尔值`connected`和`loaded`）。我们可以将代码分为两部分：一部分改变这些状态，另一部分更新按钮：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding sample code already has the embryo of Observer Pattern: the subjects
    (states `connected` and `loaded`) and the observer (`updateButton` function),
    though we still need to call `updateButton` manually every time any related state
    changes. An improved structure could look like the following figure:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例代码已经包含了观察者模式的胚胎：主体（状态`connected`和`loaded`）和观察者（`updateButton`函数），尽管我们仍然需要在任何相关状态改变时手动调用`updateButton`。改进的结构可能看起来像以下图示：
- en: '![Observer Pattern](img/image_06_005.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![观察者模式](img/image_06_005.jpg)'
- en: But just like the example we've been talking about, observers in many situations
    care about more than one state. It could be less satisfying to have subjects attach
    observers separately.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但就像我们一直在讨论的例子一样，在许多情况下，观察者关心不止一个状态。单独将观察者附加到主体上可能不太令人满意。
- en: A solution to this could be multi-state subjects, to achieve that, we can form
    a composite subject that contains sub-subjects. If a subject receives a `notify`
    call, it wakes up its observers and at the same time notifies its parent. Thus
    the observer can attach one composite subject for notifications of changes that
    happen to multiple states.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法可以是多状态观察对象，为了实现这一点，我们可以形成一个包含子观察对象的复合观察对象。如果一个观察对象收到`notify`调用，它会唤醒其观察者，并同时通知其父对象。因此，观察者可以为多个状态的变化通知附加一个复合观察对象。
- en: 'However, the process of creating the composite itself could still be annoying.
    In dynamic programming languages like JavaScript, we may have a state manager
    that contains specific states handling notifications and attaching observers directly
    with implicit creations of subjects:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创建复合对象本身的过程仍然可能令人烦恼。在动态编程语言如JavaScript中，我们可能有一个包含特定状态处理通知和直接通过隐式创建观察对象的状态管理器：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In many MV* frameworks, the states to be observed are analyzed automatically
    from related expressions by built-in parsers or similar mechanisms.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多MV*框架中，要观察的状态是通过内置解析器或类似机制从相关表达式自动分析的。
- en: 'And now the structure gets even simpler:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在结构变得更简单了：
- en: '![Observer Pattern](img/image_06_006.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![观察者模式](img/image_06_006.jpg)'
- en: Participants
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'We''ve talked about the basic structure of Observer Pattern with subjects and
    observers, and a variant with implicit subjects. The participants of the basic
    structure include the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了观察者模式的基本结构，包括主体和观察者，以及具有隐式主体的变体。基本结构的参与者包括以下内容：
- en: '**Subject**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体**'
- en: Subject to be observed. Defines methods to `attach` or `notify` observers. A
    subject could also be a composite that contains sub-subjects, which allows multiple
    states to be observed with the same interface.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 观察对象。定义了`attach`或`notify`观察者的方法。观察对象也可以是一个包含子观察对象的复合对象，这允许使用相同的接口观察多个状态。
- en: '**Concrete subject**: `ConnectedSubject` and `LoadedSubject`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体观察对象**：`ConnectedSubject`和`LoadedSubject`'
- en: Contains state related to the subject, and implements methods or properties
    to get and set their state.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含与主体相关的状态，并实现获取和设置其状态的方法或属性。
- en: '**Observer**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**观察者**'
- en: Defines the interface of an object that reacts when an observation notifies.
    In JavaScript, it could also be an interface (or signature) of a function.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了一个对象接口，当观察者通知时，该对象会做出反应。在JavaScript中，它也可以是一个函数的接口（或签名）。
- en: '**Concrete observer**: `DoButtonObserver`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体观察者**：`DoButtonObserver`'
- en: Defines the action that reacts to the notifications of subjects being observed.
    Could be a callback function that matches the signature defined.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义了对观察的主题通知做出反应的动作。可以是一个与定义的签名匹配的回调函数。
- en: 'In the variant version, the participants include the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在变体版本中，参与者包括以下内容：
- en: '**State manager**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态管理器**'
- en: Manages a complex, possibly multi-level state object containing multiple states.
    Defines the interface to attach observers with subjects, and notifies those observers
    when a subject changes.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 管理一个复杂、可能的多级状态对象，包含多个状态。定义了将观察者附加到主题的接口，并在主题发生变化时通知这些观察者。
- en: '**Concrete subject**'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体主题**'
- en: Keys to specific states. For example, string `"connected"` may represent state
    `stateManager.connected`, while string `"foo.bar"` may represent state `stateManager.foo.bar`.
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特定状态的关键。例如，字符串`"connected"`可能代表状态`stateManager.connected`，而字符串`"foo.bar"`可能代表状态`stateManager.foo.bar`。
- en: '*Observer* and *concrete observer* are basically the same as described in the
    former structure. But observers are now notified by the state manager instead
    of subject objects.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*观察者*和*具体观察者*基本上与前面结构中描述的相同。但现在观察者是由状态管理器而不是主题对象来通知的。'
- en: Pattern scope
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Observer Pattern is a pattern that may easily structure half of the project.
    In MV* architectures, Observer Pattern can decouple the view from business logic.
    The concept of view can be applied to other scenarios related to displaying information
    as well.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式是一种可以轻松构建项目一半的模式。在MV*架构中，观察者模式可以将视图与业务逻辑解耦。视图的概念也可以应用于其他与显示信息相关的场景。
- en: Implementation
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: Both of the structures we've mentioned should not be hard to implement, though
    more details should be put into consideration for production code. We'll go with
    the second implementation that has a central state manager.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的这两种结构都不难实现，但在生产代码中应该考虑更多细节。我们将采用具有中央状态管理器的第二种实现。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To simplify the implementation, we will use `get` and `set` methods to access
    specific states by their keys. But many frameworks available might handle those
    through getters and setters, or other mechanisms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化实现，我们将使用`get`和`set`方法通过键访问特定的状态。但许多可用的框架可能通过getter和setter或其他机制来处理这些。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn about how frameworks like Angular handle states changing, please read
    their documentation or source code if necessary.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解像Angular这样的框架如何处理状态变化，请阅读它们的文档或源代码（如有必要）。
- en: 'We are going to have `StateManager` inherit `EventEmitter`, so we don''t need
    to care much about issues like multiple listeners. But as we are accepting multiple
    state keys as subjects, an overload to method `on` will be added. Thus the outline
    of `StateManager` would be as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让`StateManager`继承`EventEmitter`，这样我们就不必过多关注像多个监听器这样的问题。但因为我们接受多个状态键作为主题，所以将为`on`方法添加一个重载。因此，`StateManager`的轮廓将如下所示：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You might have noticed that method `on` has the return type `this`, which may
    keep referring to the type of current instance. Type `this` is very helpful for
    chaining methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到方法`on`的返回类型是`this`，这可能意味着会持续引用当前实例的类型。类型`this`对于链式调用方法非常有帮助。
- en: 'The keys will be `"foo"` and `"foo.bar"`, we need to split a key as separate
    identifiers for accessing the value from the `state` object. Let''s have a private
    `_get` method that takes an array of `identifiers` as input:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 键将是`"foo"`和`"foo.bar"`，我们需要将键分割成单独的标识符，以便从`state`对象中访问值。让我们有一个私有方法`_get`，它接受一个`identifiers`数组作为输入：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we can implement method `get` upon `_get`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在`_get`上实现方法`get`：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For method `set`, we can get the parent object of the last identifier of property
    to be set, so things work like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于方法`set`，我们可以获取要设置的属性最后一个标识符的父对象，这样就可以像这样工作：
- en: '[PRE21]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'But there''s one more thing, we need to notify observers that are observing
    a certain subject:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有一件事，我们需要通知正在观察特定主题的观察者：
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we''re done with the notifying part, let''s add an overload for method
    `on` to support multiple keys:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成通知部分后，让我们为`on`方法添加一个重载以支持多个键：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Problem solved. Now we have a state manager that will work for simple scenarios.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 问题解决。现在我们有一个适用于简单场景的状态管理器。
- en: Consequences
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Observer Pattern decouples subjects with observers. While an observer may be
    observing multiple states in subjects at the same time, it usually does not care
    about which state triggers the notification. As a result, the observer may make
    *unnecessary* updates that actually do nothing to - for example - the view.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式解耦了主题和观察者。虽然观察者可能同时观察主题的多个状态，但它通常不关心哪个状态触发了通知。因此，观察者可能会进行不必要的更新，实际上对视图没有任何作用。
- en: However, the impact on performance could be negligible most of the time, not
    even need to mention the benefits it brings.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对性能的影响在大多数情况下可能是微不足道的，甚至不需要提及它带来的好处。
- en: By splitting view and logic apart, Observer Pattern may reduce possible branches
    significantly. This will help eliminate bugs caused at the coupling part between
    view and logic. Thus, by properly applying Observer Pattern, the project will
    be made much more robust and easier to maintain.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将视图和逻辑分开，观察者模式可以显著减少可能的分支。这将有助于消除视图和逻辑耦合部分产生的错误。因此，通过正确应用观察者模式，项目将变得更加健壮且易于维护。
- en: 'However, there are some details we still need care about:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些细节我们需要注意：
- en: The observer that updates the state could cause circular invocation.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新状态的观察者可能导致循环调用。
- en: For more complex data structures like collections, it might be expensive to
    re-render everything. Observers in this scenario may need more information about
    the change to only perform necessary updates. View implementations like React
    do this in another way; they introduce a concept called **Virtual DOM**. By updating
    and diffing the virtual DOM before re-rendering the actual DOM (which could usually
    be the bottleneck of performance), it provides a relatively general solution for
    different data structures.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于像集合这样的更复杂的数据结构，重新渲染所有内容可能会很昂贵。在这种情况下，观察者可能需要更多关于变化的信息，以便只执行必要的更新。像React这样的视图实现以另一种方式做这件事；它们引入了一个称为**虚拟DOM**的概念。通过在重新渲染实际的DOM（这通常可能是性能瓶颈）之前更新和比较虚拟DOM，它为不同的数据结构提供了一个相对通用的解决方案。
- en: Visitor Pattern
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问者模式
- en: Visitor Pattern provides a uniformed interface for *visiting* different data
    or objects while allowing detailed operations in concrete visitors to vary. Visitor
    Pattern is usually used with composites, and it is widely used for walking through
    data structures like **abstract syntax tree** (**AST**). But to make it easier
    for those who are not familiar with compiler stuff, we will provide a simpler
    example.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式提供了一个统一的接口来**访问**不同的数据或对象，同时允许具体访问者中的详细操作有所不同。访问者模式通常与组合一起使用，并且它被广泛用于遍历数据结构，如**抽象语法树**（**AST**）。但为了使那些不熟悉编译器内容的人更容易理解，我们将提供一个更简单的例子。
- en: 'Consider a DOM-like tree containing multiple elements to render:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个包含多个要渲染元素的类似DOM的树：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The rendering result in HTML would look like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中的渲染结果将如下所示：
- en: '![Visitor Pattern](img/image_06_007.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![访问者模式](img/image_06_007.jpg)'
- en: 'While in Markdown, it would look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Markdown中看起来是这样的：
- en: '![Visitor Pattern](img/image_06_008.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![访问者模式](img/image_06_008.jpg)'
- en: 'Visitor Pattern allows operations in the same category to be coded in the same
    place. We''ll have concrete visitors, `HTMLVisitor` and `MarkdownVisitor` that
    take the responsibilities of transforming different nodes by visiting them respectively
    and recursively. The nodes being visited have a method `accept` for accepting
    a visitor to perform the transformation. An overall structure of Visitor Pattern
    could be split into two parts, the first part is the visitor abstraction and its
    concrete subclasses:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式允许同一类操作在相同的地方进行编码。我们将有具体的访问者，`HTMLVisitor`和`MarkdownVisitor`，它们分别通过遍历和递归地转换不同的节点来承担转换不同节点的责任。被访问的节点有一个`accept`方法，用于接受访问者以执行转换。访问者模式的整体结构可以分为两部分，第一部分是访问者抽象及其具体子类：
- en: '![Visitor Pattern](img/image_06_009.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![访问者模式](img/image_06_009.jpg)'
- en: 'The second part is the abstraction and concrete subclasses of nodes to be visited:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是待访问节点的抽象及其具体子类：
- en: '![Visitor Pattern](img/image_06_010.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![访问者模式](img/image_06_010.jpg)'
- en: Participants
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'The participants of Visitor Pattern include the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式的参与者包括以下内容：
- en: '**Visitor**: `NodeVisitor`'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问者**: `NodeVisitor`'
- en: Defines the interface of operations corresponding to each element class. In
    languages with static types and method overloading, the method names can be unified.
    But as it takes extra runtime checking in JavaScript, we'll use different method
    names to distinguish them. The operation methods are usually named after `visit`,
    but here we use `append` as its more related to the context.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义与每个元素类对应的操作接口。在具有静态类型和方法重载的语言中，方法名可以统一。但在 JavaScript 中，它需要额外的运行时检查，因此我们将使用不同的方法名来区分它们。操作方法通常以
    `visit` 命名，但在这里我们使用 `append`，因为它与上下文更相关。
- en: '**Concrete visitor**: `HTMLVisitor` and `MarkdownVisitor`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体访问者**：`HTMLVisitor` 和 `MarkdownVisitor`'
- en: Implements every operation of the concrete visitor, and handles internal states
    if any.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现具体访问者的每个操作，并处理任何内部状态。
- en: '**Element**: `Node`'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素**：`Node`'
- en: Defines the interface of the element accepting the visitor instance. The method
    is usually named `accept`, though here we are using `appendTo` for a better matching
    with the context. Elements could themselves be composites and pass visitors on
    with their child elements.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定义接受访问者实例的元素接口。方法通常命名为 `accept`，尽管在这里我们使用 `appendTo` 以更好地匹配上下文。元素本身可以是复合的，并通过其子元素传递访问者。
- en: '**Concrete element**: `Text`, `BoldText`, `UnorderedList` and `ListItem`'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**具体元素**：`Text`、`BoldText`、`UnorderedList` 和 `ListItem`'
- en: Implements `accept` method and calls the method from the visitor instance corresponding
    to the element instance itself.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现 `accept` 方法，并从与元素实例对应的访问者实例调用该方法。
- en: '**Client**:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端**：'
- en: Enumerates elements and applies visitors to them.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 列出元素并对其应用访问者。
- en: Pattern scope
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式范围
- en: Visitor Pattern can form a large feature inside a system. For some programs
    under certain categories, it may also form the core architecture. For example,
    *Babel* uses Visitor Pattern for AST transforming and a plugin for Babel is actually
    a visitor that can visit and transform elements it cares about.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者模式可以在系统中形成一个大型功能。对于某些分类的程序，它也可能形成核心架构。例如，*Babel* 使用访问者模式进行 AST 转换，而 Babel
    的插件实际上是一个可以访问和转换它关心的元素的访问者。
- en: Implementation
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'We are going to implement `HTMLVisitor` and `MarkdownVisitor` which may transform
    nodes to text, as we''ve talked about. Start with the upper abstraction:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现 `HTMLVisitor` 和 `MarkdownVisitor`，它们可以将节点转换为文本，正如我们之前讨论的那样。从上层抽象开始：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Continue with concrete nodes that do similar things, `Text` and `BoldText`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用执行类似操作的具体系列节点，`Text` 和 `BoldText`：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And list stuff:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后列出内容：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we have the elements of a structure to be visited, we''ll begin to implement
    concrete visitors. Those visitors will have an `output` property for the transformed
    string. `HTMLVisitor` goes first:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了要访问的结构元素，我们将开始实现具体的访问者。这些访问者将有一个 `output` 属性用于转换后的字符串。`HTMLVisitor` 首先开始：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Pay attention to the loop inside `appendUnorderedList`, it handles visiting
    of its own list items.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `appendUnorderedList` 中的循环，它处理其自己的列表项的访问。
- en: 'A similar structure applies to `MarkdownVisitor`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的结构也适用于 `MarkdownVisitor`：
- en: '[PRE29]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now the infrastructures are ready, let''s create the tree-like structure we''ve
    been imagining since the beginning:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基础设施已经就绪，让我们创建从开始就想象中的树状结构：
- en: '[PRE30]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And finally, build the outputs with visitors:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用访问者构建输出：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Consequences
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后果
- en: Both Strategy Pattern and Visitor Pattern could be applied to scenarios of processing
    objects. But Strategy Pattern relies on clients to handle all related arguments
    and contexts, this makes it hard to come out with an exquisite abstraction if
    the expected behaviors of different objects differ a lot. Visitor Pattern solves
    this problem by decoupling visit actions and operations to be performed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式和访问者模式都可以应用于处理对象的场景。但策略模式依赖于客户端处理所有相关参数和上下文，如果不同对象的预期行为差异很大，这会使抽象变得难以精致。访问者模式通过解耦访问动作和要执行的操作来解决这个问题。
- en: By passing different visitors, Visitor Pattern can apply different operations
    to objects without changing other code although it usually means adding new elements
    and would result in adding related operations to an abstract visitor and all of
    its concrete subclasses.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递不同的访问者，访问者模式可以对对象应用不同的操作，而无需更改其他代码，尽管这通常意味着添加新元素，并会导致向抽象访问者和所有其具体子类添加相关操作。
- en: Visitors like the `NodeVisitor` in the previous example may store state itself
    (in that example, we stored the output of transformed nodes) and more advanced
    operations can be applied based on the state accumulated. For example, it's possible
    to determine what has been appended to the output, and thus we can apply different
    behaviors with the node currently being visited.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 像前一个示例中的 `NodeVisitor` 这样的访问者可能自身存储状态（在那个例子中，我们存储了转换后节点的输出）并且可以根据累积的状态应用更高级的操作。例如，可以确定已经添加到输出中的内容，因此我们可以根据当前正在访问的节点应用不同的行为。
- en: However, to complete certain operations, extra public methods may need to be
    exposed from the elements.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了完成某些操作，可能需要从元素中暴露额外的公共方法。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've talked about other behavior design patterns as complements
    to the former chapter, including Strategy, State, Template Method, Observer and
    Visitor Pattern.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经讨论了其他行为设计模式，作为前一章的补充，包括策略（Strategy）、状态（State）、模板方法（Template Method）、观察者（Observer）和访问者（Visitor）模式。
- en: Strategy Pattern is so common and useful that it may appear in a project several
    times, with different forms. And you might not know you were using Observer Pattern
    with implementation in a daily framework.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式非常常见且有用，它可能在一个项目中出现多次，形式各异。你可能不知道你每天都在一个日常框架中使用观察者模式。
- en: After walking through those patterns, you might find there are many ideas in
    common behind each pattern. It is worth thinking what's behind them and even letting
    the outline go in your mind.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了那些模式之后，你可能会发现每个模式背后都有许多共同的想法。值得思考这些想法背后的东西，甚至让这些想法在你的脑海中形成轮廓。
- en: In the next chapter, we'll continue with some handy patterns related to JavaScript
    and TypeScript, and important scenarios of those languages.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续介绍一些与 JavaScript 和 TypeScript 相关的实用模式，以及这些语言的重要场景。
