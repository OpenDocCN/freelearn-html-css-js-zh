- en: 'Chapter 6. Behavioral Design Patterns: Continuous'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we''ve already talked about some of the behavioral
    design patterns. We''ll be continuing with more patterns in this category in this
    chapter, including: Strategy Pattern, State Pattern, Template Method Pattern,
    Observer Pattern, and Visitor Pattern.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many of these patterns share the same idea: unify the shape and vary the details.
    Here is a quick overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy Pattern** and **Template Pattern**: Defines the same outline of
    algorithms'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**State Pattern**: Provides different behavior for objects in different states
    with the same interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Observer Pattern**: Provides a unified process of handling subject changes
    and notifying observers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visitor Pattern**: Does similar jobs as Strategy Pattern sometimes, but avoids
    an over complex interface that might be required for Strategy Pattern to handle
    objects in many different types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns that will be discussed in this chapter could be applied in different
    scopes just as many patterns in other categories.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's common that a program has similar outlines for processing different targets
    with different detailed algorithms. Strategy Pattern encapsulates those algorithms
    and makes them interchangeable within the shared outline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider conflicting merging processes of data synchronization, which we talked
    about in [Chapter 2](ch02.html "Chapter 2. The Challenge of Increasing Complexity"),
    *The Challenge of Increasing Complexity*. Before refactoring, the code was like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'But later we found out that we could actually extract the same outlines from
    different phases of the synchronization process, and encapsulate them as different
    strategies. After refactoring, the outline of the code became as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a lot of ways to compose and organize those strategy objects or classes
    sometimes in JavaScript. A possible structure for Strategy Pattern could be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy Pattern](img/image_06_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this structure, the client is responsible for fetching specific strategies
    from the table and applying operations of the current phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another structure is using contextual objects and letting them control their
    own strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Strategy Pattern](img/image_06_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Thus the client needs only to link a specific context with the corresponding
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve mentioned two possible structures for Strategy Pattern, so let''s discuss
    the participants separately. For the first structure, the participants include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of strategy objects or classes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete strategy**: `ConcreteStrategyA` and `ConcreteStrategyB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements concrete strategy operations defined by the `Strategy` interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Strategy manager**: `Strategies`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defines a data structure to manage strategy objects. In the example, it''s
    just a simple hash table that uses data type names as keys and strategy objects
    as values. It could be more complex on demand: for example, with matching patterns
    or conditions.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Target**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target to apply algorithms defined in strategy objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Makes targets and strategies cooperate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The participants of the second structure include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy** and **concrete strategy**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same as in the preceding section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Context**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines a reference to the strategy object applied. Provides related methods
    or property getters for clients to operate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages context objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strategy Pattern is usually applied to scopes with small or medium sizes. It
    provides a way to encapsulate algorithms and makes those algorithms easier to
    manage under the same outline. Strategy Pattern can also be the core of an entire
    solution sometimes, and a good example is the synchronization implementation we've
    been playing with. In this case, Strategy Pattern builds the bridge of plugins
    and makes the system extendable. But most of the time, the fundamental work done
    by Strategy Pattern is decoupling concrete strategies, contexts, or targets.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation starts with defining the interfaces of objects we'll be playing
    with. We have two target types in string literal type `'a'` and `'b'`. Targets
    of type `'a'`  have a `result` property with type `string`, while targets of type
    `'b'` have a `value` property with type `number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The interfaces we''ll have look, are like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we''ll define the concrete strategy objects without a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it easier for a client to fetch those strategies, we''ll put them into
    a hash table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And now we can make them work with targets in different types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Strategy Pattern makes the foreseeable addition of algorithms for contexts or
    targets under new categories easier. It also makes the outline of a process even
    cleaner by hiding trivial branches of behaviors selection.
  prefs: []
  type: TYPE_NORMAL
- en: However, the abstraction of algorithms defined by the `Strategy` interface may
    keep growing while we are trying to add more strategies and satisfy their requirements
    of parameters. This could be a problem for a Strategy Pattern with clients that
    are managing targets and strategies. But for the other structures which the references
    of strategy objects are stored by contexts themselves, we can manage to trade-off
    the interchangeability. This would result in Visitor Pattern, which we are going
    to talk about later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: And as we've mentioned before, Strategy Pattern can also provide notable extensibility
    if an extendable strategy manager is available or the client of contexts is designed
    to.
  prefs: []
  type: TYPE_NORMAL
- en: State Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s possible for some objects to behave completely differently when they
    are in different states. Let''s think about an easy example first. Consider rendering
    and interacting with a custom button in two states: enabled and disabled. When
    the button is enabled, it lights up and changes its style to active on a mouse
    hover, and of course, it handles clicks; when disabled, it dims and no longer
    cares about mouse events.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may think of an abstraction with two operations: `render` (with a parameter
    that indicates whether the mouse is hovering) and `click`; along with two states:
    *enabled* and *disabled*. We can even divide deeper and have state *active*, but
    that won''t be necessary in our case.'
  prefs: []
  type: TYPE_NORMAL
- en: '![State Pattern](img/image_06_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And now we can have `StateEnabled` with both `render` and `click` methods implemented,
    while having `StateDisabled` with only `render` method implemented because it
    does not care about the `hover` parameter. In this example, we are expecting every
    method of the states being callable. So we can have the abstract class `State`
    with empty `render` and `click` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of State Pattern include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of state objects that are being switched to internally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete state**: `StateEnabled` and `StateDisabled`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements the `State` interface with behavior corresponding to a specific state
    of the context. May have an optional reference back to its context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Context**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages references to different states, and makes operations defined on the
    active one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'State Pattern usually applies to the code of scopes with the size of a feature.
    It does not specify whom to transfer the state of context: it could be either
    the context itself, the state methods, or code that controls context.'
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start with the `State` interface (it could also be an abstract class if there
    are operations or logic to share):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `State` interface defined, we can move to `Context` and sketch its
    outline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to have the two states, `StateEnabled` and `StateDisabled`
    implemented. First, let''s address `StateEnabled`, it cares about `hover` status
    and handles `click` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, for `StateDisabled` it just ignores `hover` parameter and does nothing
    when `click` event emits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have classes of states *enabled* and *disabled* ready. As the instances
    of those classes are associated with the context, we need to initialize every
    state when a new `Context` is initiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to use flyweights by passing context in when invoking every operation
    on the active state as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s finish the `Context` by listening to and forwarding proper events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State Pattern reduces conditional branches in potentially multiple methods of
    context objects. As a trade-off, extra state objects are introduced, though it
    usually won't be a big problem.
  prefs: []
  type: TYPE_NORMAL
- en: The context object in State Pattern usually delegates operations and forwards
    them to the current state object. Thus operations defined by a concrete state
    may have access to the context itself. This makes reusing state objects possible
    with flyweights.
  prefs: []
  type: TYPE_NORMAL
- en: Template Method Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we are talking about subclassing or inheriting, the building is usually
    built from the bottom up. Subclasses inherit the basis and then provide more.
    However, it could be useful to reverse the structure sometimes as well.
  prefs: []
  type: TYPE_NORMAL
- en: Consider Strategy Pattern which defines the outline of a process and has interchangeable
    algorithms as strategies. If we apply this structure under the hierarchy of classes,
    we will have Template Method Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'A template method is an abstract method (optionally with default implementation)
    and acts as a placeholder under the outline of a larger process. Subclasses override
    or implement related methods to modify or complete the behaviors. Imaging the
    skeleton of a `TextReader`, we are expecting its subclasses to handle text files
    from different storage media, detect different encodings and read all the text.
    We may consider a structure like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Template Method Pattern](img/image_06_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `TextReader` in this example has a method `readAllText` that reads all
    text from a resource by two steps: reading all bytes from the resource (`readAllBytes`),
    and then decoding those bytes with certain encoding (`decodeBytes`).'
  prefs: []
  type: TYPE_NORMAL
- en: The structure also suggests the possibility of sharing implementations among
    concrete classes that implement template methods. We may create an abstract class
    `AsciiTextReader` that extends `TextReader` and implements method `decodeBytes`.
    And build concrete classes `FileAsciiTextReader` and `HttpAsciiTextReader` that
    extend `AsciiTextReader` and implement method `readAllBytes` to handle resources
    on different storage media.
  prefs: []
  type: TYPE_NORMAL
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Template Method Pattern include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Abstract class**: `TextReader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the signatures of template methods, as well as the outline of algorithms
    that weave everything together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete classes**: `AsciiTextReader`, `FileAsciiTextReader` and `HttpAsciiTextReader`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements template methods defined in abstract classes. Typical concrete classes
    are `FileAsciiTextReader` and `HttpAsciiTextReader` in this example. However,
    compared to being abstract, *defining the outline of algorithms* weighs more in
    the categorization.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template Method Pattern is usually applied in a relatively small scope. It provides
    an extendable way to implement features and avoid redundancy from the upper structure
    of a series of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two levels of the inheriting hierarchy: the `AsciiTextReader` will
    subclass `TextReader` as another abstract class. It implements method `decodeBytes`
    but leaves `readAllBytes` to its subclasses. Starting with the `TextReader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are using Promises with `async` and `await` which are coming to ECMAScript
    next. Please refer to the following links for more information:[https://github.com/Microsoft/TypeScript/issues/1664](https://github.com/Microsoft/TypeScript/issues/1664)
    [https://tc39.github.io/ecmascript-asyncawait/](https://tc39.github.io/ecmascript-asyncawait/)
  prefs: []
  type: TYPE_NORMAL
- en: 'And now let''s subclass `TextReader` as `AsciiTextReader` which still remains
    abstract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'For `FileAsciiTextReader`, we''ll need to import filesystem (`fs`) module of
    Node.js to perform file reading:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'For `HttpAsciiTextReader`, we are going to use a popular package `request`
    to send HTTP requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both concrete reader implementations pass resolver functions to the Promise
    constructor for converting asynchronous Node.js style callbacks to Promises. For
    more information, read more about the Promise constructor : [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).'
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to Strategy Pattern, Template Method Pattern provides convenience for
    building objects with the same outline of algorithms outside of the existing system.
    This makes Template Method Pattern a useful way to build tooling classes instead
    of fixed processes built-in.
  prefs: []
  type: TYPE_NORMAL
- en: But Template Method Pattern has less runtime flexibility as it does not have
    a *manager*. It also relies on the client who's using those objects to do the
    work. And as the implementation of Template Method Pattern relies on subclassing,
    it could easily result in hierarchies that have a similar code on different branches.
    Though this could be optimized by using techniques like *mixin*.
  prefs: []
  type: TYPE_NORMAL
- en: Observer Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Observer Pattern is an important Pattern backed by an important idea in software
    engineering. And it is usually a key part of MVC architecture and its variants
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you have ever written an application with a rich user interface without a
    framework like Angular or a solution with React, you might probably have struggled
    with changing class names and other properties of UI elements. More specifically,
    the code that controls those properties of the same group of elements lies every
    branch related to the elements in related event listeners, just to keep the elements
    being correctly updated.
  prefs: []
  type: TYPE_NORMAL
- en: Consider a "Do" button of which the `disabled` property should be determined
    by the status of a `WebSocket` connection to a server and whether the currently
    active item is done. Every time the status of either the connection or the active
    item gets updated, we'll need to update the button correspondingly. The most "handy"
    way could be two somewhat identical groups of code being put in two event listeners.
    But in this way, the amount of similar code would just keep growing as more relevant
    objects get involved.
  prefs: []
  type: TYPE_NORMAL
- en: The problem in this "Do" button example is that, the behavior of code that's
    controlling the button is driven by primitive events. The heavy load of managing
    the connections and behaviors among different events is directly taken by the
    developer who's writing that code. And unfortunately, the complexity in this case,
    grows exponentially, which means it could easily exceed our brain capacity. Writing
    code this way might result in more bugs and make maintaining much likely to introduce
    new bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'But the beautiful thing is, we can find the factors that multiply and output
    the desired result, and the reference for dividing those factors are groups of
    related states. Still speaking of the "Do" button example, what the button cares
    about is: connection status and the active item status (assuming they are booleans
    `connected` and `loaded`). We can have the code written as two parts: one part
    that changes those states, and another part that updates the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding sample code already has the embryo of Observer Pattern: the subjects
    (states `connected` and `loaded`) and the observer (`updateButton` function),
    though we still need to call `updateButton` manually every time any related state
    changes. An improved structure could look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observer Pattern](img/image_06_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But just like the example we've been talking about, observers in many situations
    care about more than one state. It could be less satisfying to have subjects attach
    observers separately.
  prefs: []
  type: TYPE_NORMAL
- en: A solution to this could be multi-state subjects, to achieve that, we can form
    a composite subject that contains sub-subjects. If a subject receives a `notify`
    call, it wakes up its observers and at the same time notifies its parent. Thus
    the observer can attach one composite subject for notifications of changes that
    happen to multiple states.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the process of creating the composite itself could still be annoying.
    In dynamic programming languages like JavaScript, we may have a state manager
    that contains specific states handling notifications and attaching observers directly
    with implicit creations of subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In many MV* frameworks, the states to be observed are analyzed automatically
    from related expressions by built-in parsers or similar mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now the structure gets even simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Observer Pattern](img/image_06_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve talked about the basic structure of Observer Pattern with subjects and
    observers, and a variant with implicit subjects. The participants of the basic
    structure include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subject**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subject to be observed. Defines methods to `attach` or `notify` observers. A
    subject could also be a composite that contains sub-subjects, which allows multiple
    states to be observed with the same interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete subject**: `ConnectedSubject` and `LoadedSubject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contains state related to the subject, and implements methods or properties
    to get and set their state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Observer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of an object that reacts when an observation notifies.
    In JavaScript, it could also be an interface (or signature) of a function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete observer**: `DoButtonObserver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the action that reacts to the notifications of subjects being observed.
    Could be a callback function that matches the signature defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the variant version, the participants include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State manager**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manages a complex, possibly multi-level state object containing multiple states.
    Defines the interface to attach observers with subjects, and notifies those observers
    when a subject changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete subject**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys to specific states. For example, string `"connected"` may represent state
    `stateManager.connected`, while string `"foo.bar"` may represent state `stateManager.foo.bar`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Observer* and *concrete observer* are basically the same as described in the
    former structure. But observers are now notified by the state manager instead
    of subject objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Observer Pattern is a pattern that may easily structure half of the project.
    In MV* architectures, Observer Pattern can decouple the view from business logic.
    The concept of view can be applied to other scenarios related to displaying information
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both of the structures we've mentioned should not be hard to implement, though
    more details should be put into consideration for production code. We'll go with
    the second implementation that has a central state manager.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To simplify the implementation, we will use `get` and `set` methods to access
    specific states by their keys. But many frameworks available might handle those
    through getters and setters, or other mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn about how frameworks like Angular handle states changing, please read
    their documentation or source code if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to have `StateManager` inherit `EventEmitter`, so we don''t need
    to care much about issues like multiple listeners. But as we are accepting multiple
    state keys as subjects, an overload to method `on` will be added. Thus the outline
    of `StateManager` would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might have noticed that method `on` has the return type `this`, which may
    keep referring to the type of current instance. Type `this` is very helpful for
    chaining methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys will be `"foo"` and `"foo.bar"`, we need to split a key as separate
    identifiers for accessing the value from the `state` object. Let''s have a private
    `_get` method that takes an array of `identifiers` as input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can implement method `get` upon `_get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For method `set`, we can get the parent object of the last identifier of property
    to be set, so things work like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'But there''s one more thing, we need to notify observers that are observing
    a certain subject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When we''re done with the notifying part, let''s add an overload for method
    `on` to support multiple keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Problem solved. Now we have a state manager that will work for simple scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Observer Pattern decouples subjects with observers. While an observer may be
    observing multiple states in subjects at the same time, it usually does not care
    about which state triggers the notification. As a result, the observer may make
    *unnecessary* updates that actually do nothing to - for example - the view.
  prefs: []
  type: TYPE_NORMAL
- en: However, the impact on performance could be negligible most of the time, not
    even need to mention the benefits it brings.
  prefs: []
  type: TYPE_NORMAL
- en: By splitting view and logic apart, Observer Pattern may reduce possible branches
    significantly. This will help eliminate bugs caused at the coupling part between
    view and logic. Thus, by properly applying Observer Pattern, the project will
    be made much more robust and easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some details we still need care about:'
  prefs: []
  type: TYPE_NORMAL
- en: The observer that updates the state could cause circular invocation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For more complex data structures like collections, it might be expensive to
    re-render everything. Observers in this scenario may need more information about
    the change to only perform necessary updates. View implementations like React
    do this in another way; they introduce a concept called **Virtual DOM**. By updating
    and diffing the virtual DOM before re-rendering the actual DOM (which could usually
    be the bottleneck of performance), it provides a relatively general solution for
    different data structures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Visitor Pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visitor Pattern provides a uniformed interface for *visiting* different data
    or objects while allowing detailed operations in concrete visitors to vary. Visitor
    Pattern is usually used with composites, and it is widely used for walking through
    data structures like **abstract syntax tree** (**AST**). But to make it easier
    for those who are not familiar with compiler stuff, we will provide a simpler
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a DOM-like tree containing multiple elements to render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendering result in HTML would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visitor Pattern](img/image_06_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While in Markdown, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visitor Pattern](img/image_06_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Visitor Pattern allows operations in the same category to be coded in the same
    place. We''ll have concrete visitors, `HTMLVisitor` and `MarkdownVisitor` that
    take the responsibilities of transforming different nodes by visiting them respectively
    and recursively. The nodes being visited have a method `accept` for accepting
    a visitor to perform the transformation. An overall structure of Visitor Pattern
    could be split into two parts, the first part is the visitor abstraction and its
    concrete subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visitor Pattern](img/image_06_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second part is the abstraction and concrete subclasses of nodes to be visited:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Visitor Pattern](img/image_06_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The participants of Visitor Pattern include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visitor**: `NodeVisitor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of operations corresponding to each element class. In
    languages with static types and method overloading, the method names can be unified.
    But as it takes extra runtime checking in JavaScript, we'll use different method
    names to distinguish them. The operation methods are usually named after `visit`,
    but here we use `append` as its more related to the context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete visitor**: `HTMLVisitor` and `MarkdownVisitor`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements every operation of the concrete visitor, and handles internal states
    if any.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Element**: `Node`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the interface of the element accepting the visitor instance. The method
    is usually named `accept`, though here we are using `appendTo` for a better matching
    with the context. Elements could themselves be composites and pass visitors on
    with their child elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Concrete element**: `Text`, `BoldText`, `UnorderedList` and `ListItem`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implements `accept` method and calls the method from the visitor instance corresponding
    to the element instance itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Client**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enumerates elements and applies visitors to them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Pattern scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visitor Pattern can form a large feature inside a system. For some programs
    under certain categories, it may also form the core architecture. For example,
    *Babel* uses Visitor Pattern for AST transforming and a plugin for Babel is actually
    a visitor that can visit and transform elements it cares about.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to implement `HTMLVisitor` and `MarkdownVisitor` which may transform
    nodes to text, as we''ve talked about. Start with the upper abstraction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue with concrete nodes that do similar things, `Text` and `BoldText`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And list stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have the elements of a structure to be visited, we''ll begin to implement
    concrete visitors. Those visitors will have an `output` property for the transformed
    string. `HTMLVisitor` goes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Pay attention to the loop inside `appendUnorderedList`, it handles visiting
    of its own list items.
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar structure applies to `MarkdownVisitor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the infrastructures are ready, let''s create the tree-like structure we''ve
    been imagining since the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, build the outputs with visitors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Consequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both Strategy Pattern and Visitor Pattern could be applied to scenarios of processing
    objects. But Strategy Pattern relies on clients to handle all related arguments
    and contexts, this makes it hard to come out with an exquisite abstraction if
    the expected behaviors of different objects differ a lot. Visitor Pattern solves
    this problem by decoupling visit actions and operations to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: By passing different visitors, Visitor Pattern can apply different operations
    to objects without changing other code although it usually means adding new elements
    and would result in adding related operations to an abstract visitor and all of
    its concrete subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: Visitors like the `NodeVisitor` in the previous example may store state itself
    (in that example, we stored the output of transformed nodes) and more advanced
    operations can be applied based on the state accumulated. For example, it's possible
    to determine what has been appended to the output, and thus we can apply different
    behaviors with the node currently being visited.
  prefs: []
  type: TYPE_NORMAL
- en: However, to complete certain operations, extra public methods may need to be
    exposed from the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've talked about other behavior design patterns as complements
    to the former chapter, including Strategy, State, Template Method, Observer and
    Visitor Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Strategy Pattern is so common and useful that it may appear in a project several
    times, with different forms. And you might not know you were using Observer Pattern
    with implementation in a daily framework.
  prefs: []
  type: TYPE_NORMAL
- en: After walking through those patterns, you might find there are many ideas in
    common behind each pattern. It is worth thinking what's behind them and even letting
    the outline go in your mind.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll continue with some handy patterns related to JavaScript
    and TypeScript, and important scenarios of those languages.
  prefs: []
  type: TYPE_NORMAL
