<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Creating a Backbone.js Application Test Plan</h1></div></div></div><p>Now that we have a basic test infrastructure, we'll turn our attention toward integrating a Backbone.js application and mapping out a test development strategy. In this chapter, we will create a test plan by working through the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reviewing some fundamental concepts of Backbone.js development</li><li class="listitem" style="list-style-type: disc">Selecting a Backbone.js application to test</li><li class="listitem" style="list-style-type: disc">Examining relevant testing concepts and approaches to guide test plan creation and execution</li><li class="listitem" style="list-style-type: disc">Evaluating parts of the Backbone.js application to test in complete or partial isolation</li><li class="listitem" style="list-style-type: disc">Identifying tests that exercise multiple interacting parts of the Backbone.js application</li><li class="listitem" style="list-style-type: disc">Integrating the Backbone.js application into our test infrastructure, and authoring and running a few introductory application tests</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>A Backbone.js refresher</h1></div></div></div><p>Although this book assumes a comfortable level of familiarity with Backbone.js, Underscore.js, and jQuery, we will briefly touch upon the basics of Backbone.js application development.</p><p>Backbone.js provides abstractions and useful functionality for architecting and developing JavaScript web applications. Backbone.js <a id="id63" class="indexterm"/>brings order to the chaotic interactions between program and display logic, DOM events, and backend communication. This is achieved via what could loosely be considered a <strong>Model-View-Controller</strong> (<strong>MVC</strong>)<a id="id64" class="indexterm"/> paradigm that separates application code into the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Data modeling and retrieval</li><li class="listitem" style="list-style-type: disc">Display rendering and user interactivity</li><li class="listitem" style="list-style-type: disc">Brokering data and display logic to appropriately bind and manipulate data models and user interfaces</li></ul></div><div><div><h3 class="title"><a id="note09"/>Note</h3><p>Backbone.js does not completely follow a traditional MVC approach, causing some observers to call it an <strong>MV*</strong> framework. An MV* application has a model and a view but has something other than a controller connecting the model and the view. For a much more detailed discussion on MVC and the various MV* approaches, see <em>Developing Backbone.js Applications</em> by <em>Addy Osmani</em>, and the article, <em>Journey Through The JavaScript MVC Jungle</em> (<a class="ulink" href="http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/">http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/</a>).</p></div></div><p>To this end, Backbone.js provides a set of <a id="id65" class="indexterm"/>core library components:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Events</strong>: The<a id="id66" class="indexterm"/> <code class="literal">Backbone.Events</code> module<a id="id67" class="indexterm"/> gives JavaScript objects the ability to emit and respond to<a id="id68" class="indexterm"/> events, including built-in Backbone.js class events as well as custom application events.</li><li class="listitem" style="list-style-type: disc"><strong>Models</strong>: The<a id="id69" class="indexterm"/> <code class="literal">Backbone.Model</code> class<a id="id70" class="indexterm"/> provides a data wrapper that can synchronize with a backend, <a id="id71" class="indexterm"/>validate data changes, and emit events to other parts of a Backbone.js application. A model is the fundamental unit of data in a Backbone.js application.</li><li class="listitem" style="list-style-type: disc"><strong>Collections</strong>: The <code class="literal">Backbone.Collection</code> class wraps a<a id="id72" class="indexterm"/> set of models in an ordered list. Collections <a id="id73" class="indexterm"/>provide events, backend synchronization, and many helper<a id="id74" class="indexterm"/> methods for manipulating and mutating the set of underlying models.</li><li class="listitem" style="list-style-type: disc"><strong>Templates</strong>: Backbone.js leaves <a id="id75" class="indexterm"/>the<a id="id76" class="indexterm"/> choice of the template library up to the developer (we will use Underscore.js templates for this book). Other popular template alternatives include Handlebars (<a class="ulink" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>), Mustache (<a class="ulink" href="https://github.com/janl/mustache.js/">https://github.com/janl/mustache.js/</a>), and EJS (<a class="ulink" href="http://embeddedjs.com/">http://embeddedjs.com/</a>).</li><li class="listitem" style="list-style-type: disc"><strong>Views</strong>: A<a id="id77" class="indexterm"/> <code class="literal">Backbone.View</code> object is<a id="id78" class="indexterm"/> the glue that binds models, collections, and templates together with the browser environment and DOM. Backbone.js is deliberately agnostic as to what<a id="id79" class="indexterm"/> a view must do, but a typical view references a collection or a model, couples data to the user interface via a template, and mediates user interaction and backend server events. To clarify potentially confusing terminologies, <code class="literal">Backbone.View</code> is much more analogous to a traditional MVC controller, and a Backbone.js template acts like an MVC view.</li><li class="listitem" style="list-style-type: disc"><strong>Routers</strong>: Backbone.js programs are<a id="id80" class="indexterm"/> commonly developed as single-page applications in which the entire HTML page source <a id="id81" class="indexterm"/>and JavaScript libraries are downloaded in a single page load. <code class="literal">Backbone.Router</code> <a id="id82" class="indexterm"/>maintains the internal state of the application and manages the browser history. Routers provide client-side routing via URL hash fragments (<code class="literal">#app-page</code>) to allow different views to be linked to, bookmarked, and navigated like traditional web pages.</li></ul></div><p>In the chapters that follow, we will test these components separately and together, so it is important to ensure a solid grasp of the fundamentals. The <a id="id83" class="indexterm"/>core documentation at <a class="ulink" href="http://backbonejs.org">http://backbonejs.org</a> is a good starting point for the concepts, API, and pointers and tips on application development. For a deeper dive into Backbone.js topics, there are many great online and print resources, including:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Developing Backbone.js Applications</em> by <em>Addy Osmani</em>, which is a Creative-Commons-licensed book <a id="id84" class="indexterm"/>developed with the help of the open source community on GitHub. This book discusses the theory, architecture, and fundamentals of creating Backbone.js applications (<a class="ulink" href="https://github.com/addyosmani/backbone-fundamentals">https://github.com/addyosmani/backbone-fundamentals</a>).</li><li class="listitem" style="list-style-type: disc"><em>Derick Bailey's Blog</em>, which is a blog that is frequently updated with many Backbone.js posts and has been written by the creator of <code class="literal">Backbone.Marionette</code> (<a class="ulink" href="http://lostechies.com/derickbailey/category/backbone/">http://lostechies.com/derickbailey/category/backbone/</a>).</li><li class="listitem" style="list-style-type: disc">The official <a id="id85" class="indexterm"/>Backbone.js wiki page that aggregates blog posts, tutorials, and working examples (<a class="ulink" href="https://github.com/documentcloud/backbone/wiki/Tutorials%2C-blog-posts-and-example-sites">https://github.com/documentcloud/backbone/wiki/Tutorials%2C-blog-posts-and-example-sites</a>).</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Selecting a Backbone.js application to test</h1></div></div></div><p>Devising and implementing <a id="id86" class="indexterm"/>a test plan is fundamentally a practical<a id="id87" class="indexterm"/> exercise, and we can better achieve our goal of overall application reliability by applying test lessons and techniques to a real application—whether it is one that has just been started or an existing application in need of better test coverage.</p><p>If you already have a Backbone.js application in development, you can most likely skip to the next section of this chapter. One potential issue we want to identify is the complexity of the existing application, especially one with minimal or no existing tests. Complicated dependencies, non-modular design, and highly coupled application components may require extensive mocking and stubbing to even permit a base level of test framework integration. Ultimately, the test infrastructure written around a legacy application will likely be quite different from the one written around a modular, decoupled application such as Notes. Accordingly, you may wish to use our reference application as a learning tool instead.</p><p>We provide a small reference Backbone.js application to use along with this book, simply named Notes. Notes is an online note manager that allows a user to create, view, and edit notes using the Markdown (<a class="ulink" href="http://daringfireball.net/projects/markdown/">http://daringfireball.net/projects/markdown/</a>) language. You can try out an online demo of the application at <a class="ulink" href="http://backbone-testing.com/notes/app/">http://backbone-testing.com/notes/app/</a>.</p><p>The full source code of Notes is available as part of the examples repository (see the <em>Preface</em> for the download instructions). We actually provide two versions of the Notes application that share most of the same underlying code. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Local Application</strong>: The <code class="literal">notes/</code> directory<a id="id88" class="indexterm"/> in the examples repository contains an application backed by HTML5 localStorage (<a class="ulink" href="https://developer.mozilla.org/en-US/docs/DOM/Storage#localStorage">https://developer.mozilla.org/en-US/docs/DOM/Storage#localStorage</a>) for persistent, client-side storage in a web browser. The application can be run without a network connection from a URL based on <code class="literal">file://</code>, and will be used for most of the examples in this book.</li><li class="listitem" style="list-style-type: disc"><strong>Server Application</strong>: The <code class="literal">notes-rest/</code> directory<a id="id89" class="indexterm"/> in the examples repository contains an application backed by a MongoDB database and served by a Node.js web server (available at <code class="literal">notes-rest/server.js</code>). The examples repository contains further instructions on installing and running the backend server.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Getting acquainted with the Notes application</h2></div></div></div><p>The <a id="id90" class="indexterm"/>Notes application initially presents a user with a list of existing note titles with buttons for editing/deleting individual notes. The page also provides a <strong>Write a new note</strong> input form for creating notes and a simple search box for a user to filter displayed notes by title.</p><div><img src="img/5248OS_02_01.jpg" alt="Getting acquainted with the Notes application"/><div><p>Notes list</p></div></div><p>Clicking on a note title, such as <strong>Things to do in Washington, DC.</strong>, activates the single note view and displays the note with rendered HTML (headings, bulleted lists, and so on):</p><div><img src="img/5248OS_02_02.jpg" alt="Getting acquainted with the Notes application"/><div><p>Single note view</p></div></div><p>The single <a id="id91" class="indexterm"/>note editor provides form inputs for title and Markdown text data. Any changes to the title or text are immediately saved to the backing datastore and made available for viewing:</p><div><img src="img/5248OS_02_03.jpg" alt="Getting acquainted with the Notes application"/><div><p>A single-note-editing form</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>The anatomy of the Notes application</h2></div></div></div><p>The<a id="id92" class="indexterm"/> JavaScript <code class="literal">script</code> tags in the <code class="literal">notes/app/index.html</code> web page illustrate the program files and the overall structure of the application:</p><div><pre class="programlisting">&lt;!-- JavaScript Core Libraries --&gt;
&lt;script src="img/underscore.js"&gt;&lt;/script&gt;
&lt;script src="img/jquery.js"&gt;&lt;/script&gt;
&lt;script src="img/backbone.js"&gt;&lt;/script&gt;
&lt;script src="img/backbone.localStorage.js"&gt;&lt;/script&gt;
&lt;script src="img/bootstrap.js"&gt;&lt;/script&gt;
&lt;script src="img/showdown.js"&gt;&lt;/script&gt;

&lt;!-- JavaScript Application Libraries --&gt;
&lt;script src="img/namespace.js"&gt;&lt;/script&gt;
&lt;script src="img/config.js"&gt;&lt;/script&gt;
&lt;script src="img/note.js"&gt;&lt;/script&gt;
&lt;script src="img/notes.js"&gt;&lt;/script&gt;
&lt;script src="img/templates.js"&gt;&lt;/script&gt;
&lt;script src="img/note-nav.js"&gt;&lt;/script&gt;
&lt;script src="img/note-view.js"&gt;&lt;/script&gt;
&lt;script src="img/note.js"&gt;&lt;/script&gt;
&lt;script src="img/notes-item.js"&gt;&lt;/script&gt;
&lt;script src="img/notes-filter.js"&gt;&lt;/script&gt;
&lt;script src="img/notes.js"&gt;&lt;/script&gt;
&lt;script src="img/router.js"&gt;&lt;/script&gt;

&lt;!-- Bootstrap and start application. --&gt;
&lt;script src="img/app.js"&gt;&lt;/script&gt;</pre></div><p>Don't worry if the long list of JavaScript libraries and application files looks foreboding. We will introduce each application piece as we test it. The examples in this book stand on their own without the need to look at the full source code of the Notes application. At the same time, downloading, running, and testing the Notes application is a useful exercise, particularly as you advance to the later chapters of this book and want to see the entire test collection put together in a single package.</p><p>Working our <a id="id93" class="indexterm"/>way through the JavaScript libraries, we start with the familiar core of Backbone.js (v1.0.0), Underscore.js (v1.4.4), and jQuery (v2.0.2). The additional vendor libraries in <code class="literal">notes/app/js/lib/</code> include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Backbone.localStorage</strong>: This<a id="id94" class="indexterm"/> allows us to save model data into the <code class="literal">localStorage</code> database for the <code class="literal">notes/app/</code> example application—<a class="ulink" href="https://github.com/jeromegn/Backbone.localStorage">https://github.com/jeromegn/Backbone.localStorage</a></li><li class="listitem" style="list-style-type: disc"><strong>Bootstrap</strong>: This is a popular<a id="id95" class="indexterm"/> user interface layout and components library—<a class="ulink" href="http://twitter.github.io/bootstrap/">http://twitter.github.io/bootstrap/</a></li><li class="listitem" style="list-style-type: disc"><strong>Showdown</strong>: This converts<a id="id96" class="indexterm"/> Markdown text (for example, <code class="literal">## Heading</code>) to formatted HTML (for example, <code class="literal">&lt;h2&gt;Heading&lt;/h2&gt;</code>)—<a class="ulink" href="https://github.com/coreyti/showdown">https://github.com/coreyti/showdown</a></li></ul></div><p>In terms of application structure and event flow, the key components of Notes can loosely be presented in a hierarchical fashion as follows:</p><div><pre class="programlisting">app
  App.Routers.Router
    App.Views.Notes
      App.Views.NotesFilter
      App.Views.NotesItem
      App.Collections.Notes
      App.Templates

    App.Views.Note
      App.Views.NoteNav
      App.Views.NoteView
      App.Models.Note
      App.Templates</pre></div><p>The application <code class="literal">app</code> bootstraps various application parts and starts up the router <code class="literal">App.Routers.Router</code>. The router routes hash fragments to either the list view <code class="literal">App.Views.Notes</code> or the single note view <code class="literal">App.Views.Note</code>. Both of these views use Underscore.js template strings from <code class="literal">App.Templates</code>. The list view <code class="literal">App.Views.Notes</code> contains two additional view objects for filtering and displaying list items, and a collection of notes. The <code class="literal">App.Views.Note</code> single note view contains two views objects for menu bar navigation actions and rendering Markup, and a note model.</p><p>Diving into the application files, the <code class="literal">notes/app/js/app/</code> directory decomposes into module groups, starting with some helper utilities:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">namespace.js</code>: This sets up a global namespace for our application classes (<code class="literal">App</code>) and instance (<code class="literal">app</code>)</li><li class="listitem" style="list-style-type: disc"><code class="literal">config.js</code>: This sets up configuration variables for the application instance, which we will be overriding in some of our tests</li></ul></div><p>The application has a single model and collection that abstract the note data:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">App.Models.Note</code> (<code class="literal">models/note.js</code>): This is a model class that represents a note</li><li class="listitem" style="list-style-type: disc"><code class="literal">App.Collections.Notes</code> (<code class="literal">collections/notes.js</code>): This is a collection that wraps <code class="literal">App.Models.Note</code> model instances, representing a list of notes</li></ul></div><p>All view templates are maintained in one file:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">App.Templates</code> (<code class="literal">templates/templates.js</code>): This is an object literal that contains the Underscore.js template strings for rendering HTML sections for various views</li></ul></div><p>The single note page has three view objects—a parent view (<code class="literal">App.Views.Note</code>) containing a child view (<code class="literal">App.Views.NoteView</code>) that renders a note, and a helper view (<code class="literal">App.Views.NoteNav</code>) for interacting with the navigation bar.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">App.Views.NoteNav</code> (<code class="literal">views/note-nav.js</code>): This is a helper view that controls the note navigation bar options <strong>View</strong>, <strong>Edit</strong>, and <strong>Delete</strong> and listens for / triggers events for interaction with other views.</li><li class="listitem" style="list-style-type: disc"><code class="literal">App.Views.NoteView</code> (<code class="literal">views/note-view.js</code>): This is a child view that renders note Markdown data as HTML.</li><li class="listitem" style="list-style-type: disc"><code class="literal">App.Views.Note</code> (<code class="literal">views/note.js</code>): This is a parent view that represents a single <code class="literal">App.Models.Note</code> model for viewing, editing, and deleting. It contains the <code class="literal">App.Views.NoteView</code> child view and the <code class="literal">App.Views.NoteNav</code> helper view.</li></ul></div><p>The list of notes on the home page has a similar assortment of views.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">App.Views.NotesFilter</code> (<code class="literal">views/notes-filter.js</code>): This is a helper view for managing the filter form input and for hiding/showing notes based on the filter query</li><li class="listitem" style="list-style-type: disc"><code class="literal">App.Views.NotesItem</code> (<code class="literal">views/notes-item.js</code>): This is a child view that renders a single note list entry on the home page</li><li class="listitem" style="list-style-type: disc"><code class="literal">App.Views.Notes</code> (<code class="literal">views/notes.js</code>): This is a parent view containing an <code class="literal">App.Collections.Notes</code> collection, an <code class="literal">App.Views.NotesFilter</code> view, and multiple <code class="literal">App.Views.NotesItem</code> view instances, allowing a user to peruse available notes by title and click on action buttons to invoke specific note actions (for example, edit or delete)</li></ul></div><p>Finally, we <a id="id97" class="indexterm"/>have the router and the application instance:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">App.Routers.Router</code> (<code class="literal">routers/router.js</code>): This is the application router, which mediates routes for the home and single note pages.</li><li class="listitem" style="list-style-type: disc"><code class="literal">app.js</code>: This is the Backbone.js application instance, which instantiates the <code class="literal">App.Views.Notes</code> and <code class="literal">App.Routers.Router</code> instances and starts routing history. The application instance is functionally similar to the <code class="literal">main</code> function entry point in languages such as C and Java.</li></ul></div><p>These components serve as the basis for the test examples throughout this book. At the same time, the specific code, classes, and objects of the Notes application are not special or unique as a testing target—any Backbone.js application with a standard assortment of models, views, templates, and routers should suffice.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>Numerous other sample Backbone.js applications are available as learning tools for testing and development practices, many of which are documented on the Backbone.js example sites wiki page. One particularly well-liked project is TodoMVC<a id="id98" class="indexterm"/> (<a class="ulink" href="http://todomvc.com/">http://todomvc.com/</a>) that provides a simple task manager using Backbone.js. TodoMVC further provides examples of the same application using other JavaScript frameworks, including AngularJS, Knockout.js, Meteor, and Derby, making it a great way to try out popular frontend frameworks outside the world of Backbone.js.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Test paradigms and methods</h1></div></div></div><p>There are numerous competing<a id="id99" class="indexterm"/> and complementary theories regarding software testing and <a id="id100" class="indexterm"/>development methodologies. Reading up on the world of test methods provides an excellent background for any developer looking to improve the ways in which they construct, implement, and manage tests. For brevity's sake, we will only introduce two paradigms in this book that are particularly useful for Backbone.js testing—Test-Driven Development (TDD)<a id="id101" class="indexterm"/> and <a id="id102" class="indexterm"/>Behavior-Driven Development (BDD).</p><p>Test-Driven Development is a process wherein tests are written first and <em>then</em> the actual code is written. The benefits of this approach include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Making tests a first-class priority in the development process</li><li class="listitem" style="list-style-type: disc">Encouraging code to be written in small modular units</li><li class="listitem" style="list-style-type: disc">Preventing the knowledge of code implementation details from unduly influencing the tests</li></ul></div><p>TDD and general software testing principles are covered in many resources; a recommended reference on the subject is <em>Growing Object-Oriented Software, Guided by Tests</em> by <em>Steve Freeman and Nat Pryce</em> (<a class="ulink" href="http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627">http://www.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627</a>).</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>For the purpose of readability, we usually present the code first and the tests second. However, this is not necessarily the order in which the code and tests would be developed. Notwithstanding our examples, we strongly encourage that you incorporate TDD practices into your software development process.</p></div></div><p>Behavior-Driven Development is a refinement to TDD. It was developed by <em>Dan North</em> (<a class="ulink" href="http://dannorth.net/introducing-bdd/">http://dannorth.net/introducing-bdd/</a>), and centers around specifying and describing tests in terms of the desired <em>behavior</em> of the application. In other words, BDD tests focus on what the <em>application</em> should be doing and not what the <em>test code</em> is testing, causing developers to ideally think less about internal test details and more about the application as a whole. To learn more about the principles and applications of BDD, a great starting point is the <a class="ulink" href="http://behaviour-driven.org/">http://behaviour-driven.org/</a> website.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>
<strong>BDD and TDD as library configuration options</strong>
</p><p>The BDD and TDD paradigms are so prevalent in the testing vernacular that many test libraries have adopted the terms BDD or TDD to designate APIs and configurations. For example, in <a class="link" href="ch03.html" title="Chapter 3. Test Assertions, Specs, and Suites">Chapter 3</a>, <em>Test Assertions, Specs, and Suites</em>, we'll explore the Mocha <code class="literal">bdd</code> and <code class="literal">tdd</code> API interfaces. To avoid any confusion, it is best to view test library modes as just configuration options that may or may not have a strict relationship to the paradigms we have just discussed.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Testing concepts, approaches, and planning</h1></div></div></div><p>Before jumping into the testing waters, it makes sense to have a plan of <em>what</em> we should test and <em>why</em>. The term <strong>test plan</strong>
<a id="id103" class="indexterm"/> is heavily overloaded with many potential interpretations as processes, literature, and practices have been prevalent and continuously evolving for decades. It is not surprising that modern test plans can range from casual, mostly ad-hoc practices to formal, 100-page documents requiring executive sign offs at various stages.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>For a more detailed discussion on the test plan practices applied to modern JavaScript applications, see the <em>JavaScript Testing Beginner's Guide</em> by <em>Yuxian Eugene Liang</em> (<a class="ulink" href="http://www.packtpub.com/javascript-testing-beginners-guide/book">http://www.packtpub.com/javascript-testing-beginners-guide/book</a>).</p></div></div><p>As Backbone.js applications are typically created in iterative development cycles, often without a lot of extra formality, we will take a fairly practical approach and create a test plan that simply identifies testing categories and applies them to the application under test. While an actual planning document or wiki is a best practice, it is not absolutely necessary. The overriding point is being able to identify what tests are appropriate for a given piece of code or feature during development.</p><p>We will focus on a few of the many overlapping concepts within the auspices of a test plan:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Unit tests</strong>: Unit tests <a id="id104" class="indexterm"/>isolate parts of the application (individual functions, classes, and modules) to exercise. Some interpretations of a frontend unit test further require that the test executes quickly and without any I/O (network, disk, and so on).</li><li class="listitem" style="list-style-type: disc"><strong>Partial integration tests</strong>: Integration tests <a id="id105" class="indexterm"/>typically involve testing the <em>entire</em> application stack—frontend, web server, backend datastore, and everything in between. We will not go that far in this book but will instead write frontend tests that combine multiple application parts (for example, collections and views) and verify that they are interacting correctly.</li></ul></div><p>Unit tests take a narrow view and are often used by a developer to set forth a set of required behaviors for the small piece of code they are presently working on. Then, the code is developed to match up with the unit test assertions. Partial integration tests take a higher-level view, piecing together the application and checking that the individual components add up to a functional whole. In an exemplary Backbone.js application, a unit test might create a single model and test-only model methods. In contrast, a partial integration test might create a view with several subviews and a collection and verify that collection data changes modify the subview display.</p><p>Other concepts that we will not explicitly cover in this book, but that are worth becoming familiar with and integrating into the overall development and testing process, include:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Full integration tests</strong>: Full integration tests<a id="id106" class="indexterm"/> incorporate the entire application (often seeded with known test data), exercise behavior as a user would through the frontend, and verify that the application responses propagate all the way from the backend to the user interface. For a Backbone.js application, this would entail pointing a browser window to the application's HTML page and running the application like a real user would.</li><li class="listitem" style="list-style-type: disc"><strong>Regression tests</strong>: Regression tests <a id="id107" class="indexterm"/>isolate and expose reported bugs in an application. The tests are written <em>first</em> to verify that the bug is reproduced, after which the source code is fixed. The tests continue to be run as part of the overall test suite to ensure that the bug does not reappear.</li><li class="listitem" style="list-style-type: disc"><strong>Usability tests</strong>: Usability <a id="id108" class="indexterm"/>testing encompasses many different forms and focuses on getting feedback that exposes portions of the application that need user interface or user experience improvements.</li><li class="listitem" style="list-style-type: disc"><strong>Performance/load tests</strong>: Performance tests <a id="id109" class="indexterm"/>verify that the application maintains minimum response times for given use cases. Load testing checks that the application can still meet performance goals when different parts of the program are stressed.</li><li class="listitem" style="list-style-type: disc"><strong>Acceptance tests</strong>: Acceptance tests <a id="id110" class="indexterm"/>form the criteria by which a customer can verify that the application meets its requirements. A suite of acceptance tests can include any of the categories of tests mentioned previously.</li></ul></div><p>Now that we have had a brief introduction of these various testing concepts, we will develop an informal test plan for our Backbone.js application. We will examine the various parts of our Backbone.js application and identify what needs to be tested, what type of tests we should apply, and the behavior that we need to verify in the application. For the parts of an application that are still in development or in the early design phases, we'll go through the same exercises, just with a focus on the behaviors we expect the application to exhibit once it has been developed.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Testing individual Backbone.js components</h1></div></div></div><p>Backbone.js applications are <a id="id111" class="indexterm"/>quite amenable to testing separation. Backbone.js <a id="id112" class="indexterm"/>provides a small number of core components that mostly avoid interdependencies. Our goal in this section is to identify the different parts of a Backbone.js application that can be unit tested in isolation and start thinking about the features of each one that we should test. Many components can simply be instantiated alone while others will need some extra mocking or patching help in our tests.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Models</h2></div></div></div><p>Backbone.js models most <a id="id113" class="indexterm"/>often are independent entities that can be<a id="id114" class="indexterm"/> instantiated with a simple <code class="literal">new MyModel({foo: 123})</code> invocation. Accordingly, we can create standalone model objects in our tests without references to any other objects. Our model tests should include the assertions that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Objects can be instantiated with supplied and/or default values</li><li class="listitem" style="list-style-type: disc">Data can be synchronized with a backing datastore (for example, <code class="literal">localStorage</code> or a REST server)</li><li class="listitem" style="list-style-type: disc">Custom and built-in events fire and/or are consumed on appropriate state changes</li><li class="listitem" style="list-style-type: disc">Validation logic accurately distinguishes the correctness of attribute data</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Collections</h2></div></div></div><p>Collections customarily<a id="id115" class="indexterm"/> have a single dependency on a<a id="id116" class="indexterm"/> model, declared like <code class="literal">model: MyModel</code> in the class definition. We can either directly instantiate collections in our tests or mock the <code class="literal">model</code> property for further test isolation. A typical set of collection specs should verify that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Collection objects can be created with or without an array of model objects</li><li class="listitem" style="list-style-type: disc">Model objects can be added and removed from a collection</li><li class="listitem" style="list-style-type: disc">Events are triggered on container and model changes</li><li class="listitem" style="list-style-type: disc">Data is appropriately synchronized with the backend</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Templates</h2></div></div></div><p>Although <a id="id117" class="indexterm"/>templates <a id="id118" class="indexterm"/>are not an actual Backbone.js component, there are several conventional template development techniques for Backbone.js integration that we'll observe. Templates generally do not have any dependencies and can readily be used alone in test code.</p><p>The specifics of template tests largely depend on the engine used (for example, Underscore.js or Handlebars). A reasonable test starting point would confirm that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Template objects render the appropriate HTML output with the provided data</li><li class="listitem" style="list-style-type: disc">Complex data structures such as arrays and objects are correctly interpolated in the template output</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Views</h2></div></div></div><p>Views <a id="id119" class="indexterm"/>frequently have the most dependencies of any Backbone.js <a id="id120" class="indexterm"/>component. Views can contain combinations of model, collection, template, router, and child/helper view references. Accordingly, we will have to mock or patch dependencies to isolate views and/or provide partial dependencies in our tests.</p><p>For all application views, we will want to verify that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Views can render the target HTML, binding model data to a template string</li><li class="listitem" style="list-style-type: disc">View objects provided with an <code class="literal">el</code> property get added to the DOM on creation</li><li class="listitem" style="list-style-type: disc">View methods correctly bind to DOM and Backbone.js events, and respond appropriately</li><li class="listitem" style="list-style-type: disc">Objects contained by a view (for example, subviews and models) are properly disposed on the view removal</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Routers</h2></div></div></div><p>Routers commonly<a id="id121" class="indexterm"/> contain several top-level views and <a id="id122" class="indexterm"/>may have collection or model references. For unit-testing purposes, we will usually mock out dependencies to easily test the routing behavior without regard to the rest of the application. Our router tests will need to assert that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">URL routes are accurately matched to appropriate views or other actions</li><li class="listitem" style="list-style-type: disc">A router maintains the browser history correctly after navigation events</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Utilities</h2></div></div></div><p>Utilities<a id="id123" class="indexterm"/> include any helper code that is not actually a<a id="id124" class="indexterm"/> core Backbone.js class or object. As utilities are ad-hoc creations and have no real constraints, they can usually be unit tested easily, provided they are developed along with, and in consideration with, their supporting tests.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Testing application interactions and events</h1></div></div></div><p>A Backbone.js application is <a id="id125" class="indexterm"/>used as a cohesive whole by end users, and wherever possible, we should have the test infrastructure verify overall application functionality and behaviors that cut across single Backbone.js components.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Partial integrations</h2></div></div></div><p>While unit tests are a staple of<a id="id126" class="indexterm"/> modern software development, we must metaphorically move from unit-testing trees to the forest of partial integration tests to ensure that at least some pieces of the application work together harmoniously and reliably. In practice, this just means varying the degree to which we mock or remove component dependencies in the tests we discussed previously.</p><p>Integration tests can interact with application parts in many ways, including:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">By creating a parent view with a collection and subviews, invoking DOM events, and checking appropriate changes are made to both the collection data and subview displays</li><li class="listitem" style="list-style-type: disc">By filling in and submitting the form input in a Backbone.js view</li><li class="listitem" style="list-style-type: disc">By directly adding models to a collection and triggering events in listening views</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Events</h2></div></div></div><p>All Backbone.js classes <a id="id127" class="indexterm"/>extend the <code class="literal">Backbone.Events</code> base class and typically emit and consume events as a first-order means of communication. We will want to test that our application components trigger correctly and react to various expected events during the application's execution. We will often leverage tools, such as spies, stubs, and mocks, to exercise the event logic we want to test while not actually affecting other application states.</p><p>We will also need to carefully craft our test code to properly set up and tear down the test environment so that we can make reasonable assumptions about the starting event listener state in each test. For example, if multiple tests add custom listeners to a shared object without cleaning up, other tests could spuriously fail due to listener callback interaction.</p><p>The event behaviors that we will want to test across all our Backbone.js components include whether:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Objects respond to custom/built-in events</li><li class="listitem" style="list-style-type: disc">Objects emit events correctly</li><li class="listitem" style="list-style-type: disc">Event listeners are properly cleaned up on disposal events, such as object or view removal</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Dipping our toes in the application testing waters</h1></div></div></div><p>Now that we can identify the aspects of the Backbone.js components that we want to test, let's begin planning <a id="id128" class="indexterm"/>and writing tests for the namespace utility and the Backbone.js model. For each component, we will examine application use cases and expected behaviors and then write tests to verify our expectations.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Namespace</h2></div></div></div><p>The starting<a id="id129" class="indexterm"/> point for the Notes application is a namespace utility that provides two global variables to organize our application classes (<code class="literal">App</code>) and instance (<code class="literal">app</code>). In the <code class="literal">notes/app/js/app/namespace.js</code> example application file, we'll create the two namespace object literals with class/application properties:</p><div><pre class="programlisting">// Class names.
var App = App   || {};
App.Config      || (App.Config = {});
App.Models      || (App.Models = {});
App.Collections || (App.Collections = {});
App.Routers     || (App.Routers = {});
App.Views       || (App.Views = {});
App.Templates   || (App.Templates = {});

// Application instance.
var app = app || {};</pre></div><p>The behavior that we want to test of these helper objects is if they contain the correct properties that other application components will rely upon. Accordingly, the <code class="literal">chapters/02/test/js/spec/namespace.spec.js</code> test file just needs a few specs to cover these objects. The first spec <code class="literal">provides the 'App' object</code> asserts that <code class="literal">App</code> is a JavaScript object with properties for all of the different grouping names (<code class="literal">Models</code>, <code class="literal">Views</code>, and so on) that we have attached:</p><div><pre class="programlisting">describe('Namespace', function () {
  it("provides the 'App' object", function () {
    // Expect exists and is an object.
    expect(App).to.be.an("object");

    // Expect all namespace properties are present.
    expect(App).to.include.keys(
      "Config", "Collections", "Models",
      "Routers", "Templates", "Views"
    );
  });</pre></div><p>The second spec <code class="literal">provides the 'app' object</code> just checks that the global <code class="literal">app</code> variable exists as an object:</p><div><pre class="programlisting">  it("provides the 'app' object", function () {
    expect(app).to.be.an("object");
  });
});</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Note model</h2></div></div></div><p>Moving on to <a id="id130" class="indexterm"/>the actual Backbone.js classes, we will start with the model <code class="literal">notes/app/js/app/models/note.js</code> file that provides the data backing a single note in the Notes application:</p><div><pre class="programlisting">App.Models.Note = Backbone.Model.extend({
  defaults: function () {
    return {
      title: "",
      text: "*Edit your note!*",
      createdAt: new Date()
    };
  }
});</pre></div><p>The model has three fields: <code class="literal">title</code>, <code class="literal">text</code>, and <code class="literal">createdAt</code>. As our example Notes application uses <code class="literal">localStorage</code> configured in the collection class, we do not have to provide backend synchronization declarations (for example, a <code class="literal">urlRoot</code> property or a <code class="literal">url</code> function) to persist model data. Because our model essentially comprises a single <code class="literal">defaults</code> declaration, the behavior that we need to test is simply that the default and modified attributes work as expected.</p><p>Our test file for the model, <code class="literal">chapters/02/test/js/spec/models/note.spec.js</code>, has two specs. The first spec creates an <code class="literal">App.Models.Note</code> object with default values and uses <code class="literal">get()</code>to verify each attribute:</p><div><pre class="programlisting">describe("App.Models.Note", function () {
  it("has default values", function () {
    // Create empty note model.
    var model = new App.Models.Note();

    expect(model).to.be.ok;
    expect(model.get("title")).to.equal("");
    expect(model.get("text")).to.equal("*Edit your note!*");
    expect(model.get("createdAt")).to.be.a("Date");
  });</pre></div><p>The second spec <code class="literal">sets passed attributes</code> tests a model created with the supplied values for <code class="literal">title</code> and <code class="literal">text</code>:</p><div><pre class="programlisting">  it("sets passed attributes", function () {
    var model = new App.Models.Note({
      title: "Grocery List",
      text: "* Milk\n* Eggs\n*Coffee"
    });

    expect(model.get("title")).to.equal("Grocery List");
    expect(model.get("text")).to.equal("* Milk\n* Eggs\n*Coffee");
  });
});</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Running the application tests</h1></div></div></div><p>With our Backbone.js<a id="id131" class="indexterm"/> application files and the preliminary application tests ready, we need to integrate everything into the test driver we created in <a class="link" href="ch01.html" title="Chapter 1. Setting Up a Test Infrastructure">Chapter 1</a>, <em>Setting Up a Test Infrastructure</em>. We will continue with the existing application directory structure by adding specs to <code class="literal">chapters/02/test/js/spec</code> and copying the application libraries from <code class="literal">notes/app/js/app</code> to <code class="literal">chapters/02/app/js/app</code>.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>The Notes application resides in the <code class="literal">notes/app</code> directory, which is the base location we will use to discuss the application components. At the same time, the chapter code examples are aimed to be independent. Therefore, we maintain our layout rules that the application code goes in <code class="literal">chapters/NUMBER/app</code> and the tests go in <code class="literal">chapters/NUMBER/test</code>.</p><p>Accordingly, the downloadable examples link files such as <code class="literal">chapters/02/app/js/app/namespace.js</code> to <code class="literal">notes/app/js/app/namespace.js</code>. Thus, throughout this book, we will talk about a file such as <code class="literal">namespace.js</code> interchangeably using either of the full paths as a prefix.</p></div></div><p>In the <code class="literal">chapters/02/test/test.html</code> test driver page, we'll add <code class="literal">script</code> tags referencing our libraries, application files, and tests:</p><div><pre class="programlisting">&lt;!-- JavaScript Test Libraries. --&gt;
&lt;script src="img/mocha.js"&gt;&lt;/script&gt;
&lt;script src="img/chai.js"&gt;&lt;/script&gt;
&lt;script src="img/sinon.js"&gt;&lt;/script&gt;

&lt;!-- JavaScript Core Libraries --&gt;
<strong>&lt;script src="img/underscore.js"&gt;&lt;/script&gt;</strong>
<strong>&lt;script src="img/jquery.js"&gt;&lt;/script&gt;</strong>
<strong>&lt;script src="img/backbone.js"&gt;&lt;/script&gt;</strong>
<strong>&lt;script src="img/backbone.localStorage.js"&gt;&lt;/script&gt;</strong>
<strong>&lt;script src="img/bootstrap.js"&gt;&lt;/script&gt;</strong>
<strong>&lt;script src="img/showdown.js"&gt;&lt;/script&gt;</strong>

&lt;!-- JavaScript Application Libraries --&gt;
<strong>&lt;script src="img/namespace.js"&gt;&lt;/script&gt;</strong>
<strong>&lt;script src="img/note.js"&gt;&lt;/script&gt;</strong>

&lt;!-- Set up Mocha and Chai --&gt;
&lt;script&gt;
  var expect = chai.expect;
  mocha.setup("bdd");

  window.onload = function () {
    mocha.run();
  };
&lt;/script&gt;

&lt;!-- Include our specs. --&gt;
<strong>&lt;script src="img/namespace.spec.js"&gt;&lt;/script&gt;</strong>
<strong>&lt;script src="img/note.spec.js"&gt;&lt;/script&gt;</strong>
</pre></div><p>The highlighted tag<a id="id132" class="indexterm"/> lines in the previous file illustrate that we have now added the core vendor libraries (Underscore.js, Backbone.js, and so on), the application libraries, and our two spec files. Opening <code class="literal">chapters/02/test/test.html</code> gives us our test report:</p><div><img src="img/5248OS_02_04.jpg" alt="Running the application tests"/><div><p>Test report</p></div></div><p>With our finished<a id="id133" class="indexterm"/> test report, we have now exercised and tested specific Backbone.js components and hooked everything into the overall test infrastructure.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Summary</h1></div></div></div><p>In this chapter, we reviewed the basics of Backbone.js applications and introduced the Notes application as a helpful, if optional, companion to the test examples in this book. We then reviewed some relevant high-level testing concepts and dived into the specifics of what we will want to test in a Backbone.js application—in separated application pieces and as integrated parts of a whole. Finally, we wrote our first application unit tests and extended the test infrastructure from <a class="link" href="ch01.html" title="Chapter 1. Setting Up a Test Infrastructure">Chapter 1</a>, <em>Setting Up a Test Infrastructure</em>, to execute our test reporter.</p><p>You should now be able to take an existing or in-development Backbone.js application, analyze its components, and create an abstract test infrastructure outline that will later be filled in with actual tests and suites.</p><p>In the next chapter, we will learn about Chai assertions, basic Mocha test constructs (specs and suites), test setup/teardown/configuration, and how to deterministically verify behavior in an asynchronous application environment. We will also broadly increase our test coverage as we write many more tests for our Backbone.js application in the course of learning testing technologies.</p></div></body></html>