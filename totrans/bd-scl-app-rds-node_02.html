<html><head></head><body>


<h1 class="chap2"><a id="page73" class="calibre6"/><a href="toc.xhtml#c03" class="calibre6">C<small class="calibre8">HAPTER</small> 3</a></h1>
<h1 class="subchap"><a href="toc.xhtml#c03" class="calibre6">Overview of Express.js</a></h1>

<h1 class="sec" id="s76"><a href="toc.xhtml#s76a" class="calibre6">Introduction</a></h1>
<p class="nonindent">Express.js is a highly recognized and frequently utilized open-source framework of Node.js that facilitates the creation of web applications and REST APIs. It is a robust and adaptable framework that is favored by developers seeking to construct efficient and expandable web applications.</p>
<p class="nonindent">It is a very popular framework due to its simplicity, flexibility, and scalability. Its popularity can be observed by looking at the average downloads per week. According to the npm registry, the Express.js package has been downloaded on average over 27 million times per week.</p>
<h1 class="sec" id="s77"><a href="toc.xhtml#s77a" class="calibre6">Structure</a></h1>
<p class="nonindent">In this chapter, we will discuss the following topics:</p>
<ul class="bull">
<li class="calibre9">Defining Express.js</li>
<li class="calibre9">Advantages and Limitations of Express.js</li>
<li class="calibre9">Express.js Installation and Creating a Basic Application</li>
<li class="calibre9">Core Features of Express.js</li>
<li class="calibre9">Security and Performance Best Practices</li>
</ul>
<h1 class="sec" id="s78"><a href="toc.xhtml#s78a" class="calibre6">Defining Express.js</a></h1>
<p class="nonindent">In software development, a <strong class="calibre3">framework</strong> is a pre-written code that provides a set of generic functionality, tools, and guidelines for building applications. It is essentially a structured and standardized way of organizing and developing software, which helps to reduce development time and effort by providing pre-existing components and patterns that can be reused across multiple projects.</p>
<p class="nonindent">Express.js is one of the most popular open source, fast, and flexible frameworks of Node.js. It follows the “<em class="calibre4">unopinionated</em>” approach, which means that it does not enforce <a id="page74"/>any specific architecture or patterns and allows developers to build their applications using their preferred tools and techniques. It provides a set of tools and features for building web applications and APIs using Node.js, including handling HTTP requests and responses, routing, middleware, templating engines, static file serving, and more. It has a large and active community of developers contributing to its development and maintenance.</p>
<p class="nonindent">Express.js is also known for its performance and scalability, with a lightweight and efficient core that allows it to handle high-traffic loads. Overall, Express.js is a powerful framework of Node.js that has all the required features to develop secure and scalable web applications.</p>
<h1 class="sec" id="s79"><a href="toc.xhtml#s79a" class="calibre6">Advantages of Express.js</a></h1>
<p class="nonindent">Express.js has several advantages over other web application frameworks, including:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Minimalist</strong>
<p class="nonindent">Express.js has a straightforward design that helps to reduce the learning curve for developers who are new to the framework, enabling them to get up and running with their projects more quickly and easily.</p></li>
<li class="calibre9"><strong class="calibre3">Flexible</strong>
<p class="nonindent">Express.js is a highly customizable and flexible framework. One such example of its flexibility is the middleware system, which allows developers to add custom logic to incoming requests or outgoing responses.</p></li>
<li class="calibre9"><strong class="calibre3">Scalable</strong>
<p class="nonindent">Express.js provides built-in support for asynchronous programming using JavaScript promises and <code class="calibre7"><strong class="calibre3">async</strong></code>/<code class="calibre7"><strong class="calibre3">await</strong></code> syntax, which enables developers to write scalable code that can handle a large number of concurrent requests. It is well-suited for building large, complex applications that can handle high levels of traffic and data.</p></li>
<li class="calibre9"><strong class="calibre3">Compatibility with Node.js</strong>
<p class="nonindent">Express.js is built specifically to work with Node.js, which means that it is highly compatible with Node.js and its related libraries. Express.js is designed to leverage the features and capabilities of Node.js, such as its event-driven architecture and non-blocking I/O model. It is also able to seamlessly integrate with other Node.js libraries and tools.</p></li>
<li class="calibre9"><strong class="calibre3">Collaborative community</strong>
<p class="nonindent">It has a very large and active community which is a key advantage of it. It ensures that the framework is constantly evolving and improving. Moreover, <a id="page75"/>it provides valuable support for developers, making it easier for them to troubleshoot issues and learn from the experience of others.</p></li>
</ul>
<p class="nonindent">Express.js not only offers the aforementioned benefits, but also provides numerous additional advantages.</p>
<h1 class="sec" id="s80"><a href="toc.xhtml#s80a" class="calibre6">Limitations of Express.js</a></h1>
<p class="nonindent">Like every coin has two sides, Express.js also has its limitations as follows:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Incompatible with client-side application</strong>
<p class="nonindent">Express.js is primarily focused on server-side web development, so it is not used for building complex client-side applications. However, it can be used in conjunction with other tools and frameworks to build full-stack applications.</p></li>
<li class="calibre9"><strong class="calibre3">Lack of built-in features</strong>
<p class="nonindent">Express.js is a minimalist framework, which means that it does not come with all the built-in features and tools that some other frameworks provide. Developers may need to install and configure additional modules or libraries to add certain functionalities to their applications.</p></li>
<li class="calibre9"><strong class="calibre3">Inconsistency</strong>
<p class="nonindent">Since Express.js is a minimalist framework, it does not enforce any standard way to structure an application or organize its code. As a result, developers are free to design their structures, which can pose a challenge for new developers trying to contribute to any existing project.</p></li>
</ul>
<p class="nonindent">Express.js has fewer limitations compared to other frameworks and offers more benefits, making it an easily approachable framework for developers.</p>
<h1 class="sec" id="s81"><a href="toc.xhtml#s81a" class="calibre6">Express.js Installation and Creating a Basic Application</a></h1>
<p class="nonindent">To install Express.js, prior make sure you have Node.js installed on your machine, then you can perform the following steps:</p>
<ol class="num">
<li class="calibre9">Create a new project directory and navigate into it using the command prompt or terminal.
<p class="code"><code class="calibre7"> $ mkdir my-express-app</code></p>
<p class="code1"><code class="calibre7"> $ cd my-express-app</code></p>
<p class="nonindent"> Initialize a new Node.js project. This will create a <code class="calibre7"><strong class="calibre3">package</strong></code><strong class="calibre3">.</strong><code class="calibre7"><strong class="calibre3">json</strong></code> file in your project directory.</p>
<p class="code1"><code class="calibre7"> $ npm init</code></p></li>
<li class="calibre9"><a id="page76"/>Install <code class="calibre7"><strong class="calibre3">Express.js</strong></code> and typescript dependency with run the following command:
<p class="code"><code class="calibre7"> $ npm install express typescript --save</code></p>
<p class="nonindent"> The<code class="calibre7"> --save</code> option will automatically update your <code class="calibre7"><strong class="calibre3">package.json</strong></code> file with the installed package and its version.</p></li>
<li class="calibre9">Install development dependency as dev dependency for typescript with express.js 
<p class="code"><code class="calibre7"> $ npm install @types/express @types/node --save-dev</code></p></li>
<li class="calibre9">Create a new file called <code class="calibre7"><strong class="calibre3">app.ts</strong></code> in the root directory of your project, and add the following code:
<p class="code"><code class="calibre7">import * as express from 'express';</code></p>
<p class="code1"><code class="calibre7">import { Request, Response } from 'express';</code></p>
<p class="code1"><code class="calibre7">const app: express.Application = express();</code></p>
<p class="code"><code class="calibre7">app.get('/', (req: Request, res: Response) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.send('Hello World!');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">app.listen(3000, () =&gt; {</code></p>
<p class="code2"><code class="calibre7">console.log('Server listening on port 3000');</code></p>
<p class="code1"><code class="calibre7">});</code></p></li>
<li class="calibre9">Compile the TypeScript code into JavaScript using the <code class="calibre7"><strong class="calibre3">tsc</strong></code> command:
<p class="code"><code class="calibre7"> $ tsc app.ts</code></p></li>
<li class="calibre9">Run the server with the <code class="calibre7"><strong class="calibre3">node</strong></code> command:
<p class="code"><code class="calibre7"> $ node app.js</code></p>
<figure class="img">
<img alt="" src="img/3.1.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_1"><strong class="calibre3">Figure 3.1:</strong> Compile and Run Express Application</p></li>
</ol>
<p class="nonindent">Now you should be able to visit <code class="calibre7"><strong class="calibre3">http://localhost:3000</strong></code> in your web browser and see the message <code class="calibre7">"<strong class="calibre3">Hello World!</strong>"</code> displayed on the page:</p>
<a id="page77"/>
<figure class="img">
<img alt="" src="img/3.2.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_2"><strong class="calibre3">Figure 3.2:</strong> Launch Express Application</p>
<h1 class="sec" id="s82"><a href="toc.xhtml#s82a" class="calibre6">Core Features of Express.js</a></h1>
<p class="nonindent">Express.js is equipped with several fundamental features, some of which are as follows:</p>
<h1 class="sec" id="s83"><a href="toc.xhtml#s83a" class="calibre6">REST APIs</a></h1>
<p class="nonindent">A RESTful API is a web-based API that follows the principles of Representational State Transfer (REST) architectural style. It is a way of designing web services that are lightweight, maintainable, and scalable. RESTful APIs use HTTP methods to interact with resources that are identified by URIs.</p>
<p class="nonindent">There are certain principles which should be followed while building REST APIs. These principles are a set of guidelines for designing an application.</p>
<h1 class="sec1" id="s84"><a href="toc.xhtml#s84a" class="calibre6">REST Principles</a></h1>
<p class="nonindent">There are a total of six guiding principles. In general, not all of these are mandatory to be followed to build applications; however, using these principles ensures better performance, efficiency, and scalability. These principles are:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Client-Server Architecture</strong> 
<p class="nonindent">The system should be divided into client and server. The client should communicate to the server over the network. Server-side and Client-side responsibilities must be independent and to be implemented by respective sides. This allows the evolution of both client and server independently.</p></li>
<li class="calibre9"><strong class="calibre3">Stateless Design</strong>
<p class="nonindent">Whenever a client needs any data from the server it sends a request to the backend server. This principle says that each request from client to server must contain all of the information that server would need to understand the request. Server must not store the state of the session about the client.</p></li>
<li class="calibre9"><strong class="calibre3">Cacheable</strong>
<p class="nonindent">Sometimes, there are responses which do not change too frequently. <a id="page78"/>Such responses can be cached to improve performance. Responses should be defined as cacheable so that client can also know if it can reuse the same data or should request again.</p></li>
<li class="calibre9"><strong class="calibre3">Uniform Interface</strong>
<p class="nonindent">The uniform interface simplifies the architecture by making it more modular, and allows easier development and deployment. There are four constraints which define a uniform interface :</p>
<ul class="bull1">
<li class="calibre9"><strong class="calibre3">Resource Identification</strong>: Resources can be identified through request URIs. For example, /projects clearly says that we are requesting the list of projects. A URI /projects/23 says that we are requesting a project using unique id 23.</li>
<li class="calibre9"><strong class="calibre3">Resource Manipulation through Representations</strong>: A resource is a conceptual entity identified by URI and the representation is the form of the resource when it is transferred over the network. The representation can be as JSON, XML, HTML, and so on. By sending or receiving these representations, clients manipulate resources. 
<p class="nonindent">A project can be represented (in JSON format) as</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"name":"Mobile App",</code></p>
<p class="code2"><code class="calibre7">"description":"This project is to manage development of Mobile App"</code></p>
<p class="code1"><code class="calibre7">}</code></p></li>
<li class="calibre9"><strong class="calibre3">Self-descriptive Messages</strong>: The messages being transferred between server and client should include enough information to describe how to process the message. This helps in decoupling of the client and server. Let us consider a request: 
<p class="code"><code class="calibre7">GET /projects/23 HTTP/1.1</code></p>
<p class="code1"><code class="calibre7">Host: example.com</code></p>
<p class="code1"><code class="calibre7">Accept: application/json</code></p>
<p class="nonindent">The above can be a request from client to server. This clearly shows that we are making a GET request over HTTP for host example.com and it desires the response in JSON format using the Accept header. Let us see a sample response to this:</p>
<p class="code"><code class="calibre7">HTTP/1.1 200 OK</code></p>
<p class="code1"><code class="calibre7">Content-Type: application/json</code></p>
<p class="code1"><code class="calibre7">Content-Length: 122</code></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"id": 23,</code></p>
<p class="code2"><code class="calibre7">"name":"Mobile App",</code></p>
<p class="code2"><code class="calibre7">"description":"This project is to manage development of Mobile App"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page79"/>The preceding response shows that the status of the request was <code class="calibre7"><strong class="calibre3">200 OK</strong></code>, the returned data is in JSON format and the body contains the requested project.</p></li>
<li class="calibre9"><strong class="calibre3">Hypermedia as the Engine of Application State (HATEOAS)</strong>: The principle says that the client should interact with a RESTful application entirely through the hypermedia provided dynamically by the application servers. The client would have only the initial URI of the application. The hyperlinks needed further should be inside the response. This allows the dynamic discovery of actions and helps to decouple the client from the server. Each communication here would have self-descriptive messages.</li></ul></li>
<li class="calibre9"><strong class="calibre3">Layered Architecture</strong>
<p class="nonindent">This principle insists that the application architecture should be divided into hierarchical layers. Each layer performs specific tasks. Let us consider a simple web application. The layers in it can be:</p>
<ul class="bull1">
<li class="calibre9"><strong class="calibre3">Client Layer</strong>: User interacts with this layer, for example, web app or mobile app.</li>
<li class="calibre9"><strong class="calibre3">API Gateway Layer</strong>: Entry point, every request goes through this layer.</li>
<li class="calibre9"><strong class="calibre3">Application Layer</strong>: Handles the business logic of processing the user requests.</li>
<li class="calibre9"><strong class="calibre3">Service Layer</strong>: Contains helper services such as notification service, and so on.</li>
<li class="calibre9"><strong class="calibre3">Data Access Layer</strong>: Contains logic needed to fetch, store or update data.</li>
<li class="calibre9"><strong class="calibre3">Database Layer</strong>: The layer which communicates with the database to fetch or store data.</li></ul>
<p class="nonindent">These layers should give an idea about the principle. This is an example and the layers can vary depending on the system being developed.</p></li>
<li class="calibre9"><strong class="calibre3">Code on Demand</strong> 
<p class="nonindent">This is an optional principle. This allows the client to extend the client functionality by providing the code in response. In this case, the client makes <a id="page80"/>a request and server responses with a code which is usually a script which can be run at the client side. This principle allows flexibility and on-the-fly customization of the client application. However, we must be careful and should consider the security aspects.</p></li>
</ul>
<p class="nonindent">While it is true that REST principles enhance the scalability, performance, and maintainability of the APIs, not each principle is mandatory in all contexts. The last principle — Code on Demand is optional. However, to achieve the full benefits of the REST architecture, it is recommended that these principles should be followed as closely as possible.</p>
<h1 class="sec" id="s85"><a href="toc.xhtml#s85a" class="calibre6">Building REST API</a></h1>
<p class="nonindent">Express.js is well-suited for building RESTful APIs, with support for HTTP. It allows developers to easily handle HTTP requests and responses. There are different types of HTTP methods such as <code class="calibre7"><strong class="calibre3">GET</strong></code>, <code class="calibre7"><strong class="calibre3">POST</strong></code>, <code class="calibre7"><strong class="calibre3">PUT</strong></code>, <code class="calibre7"><strong class="calibre3">DELETE</strong></code>, <code class="calibre7"><strong class="calibre3">PATCH</strong></code>, <code class="calibre7"><strong class="calibre3">HEAD</strong></code>.</p>
<p class="nonindent">Let us build a rest api to get a list of users using the GET Method of HTTP.</p>
<p class="nonindent">We have already created a basic-typescript-project in the previous chapter, so let us take that as a starting point and install <code class="calibre7"><strong class="calibre3">express</strong></code> in that project.</p>
<p class="code"><code class="calibre7">$ npm install express --save</code></p>
<p class="nonindent">In a REST API <code class="calibre7"><strong class="calibre3">body-parser</strong></code> is a very useful npm package that is used as Node.js parsing middleware. It extracts the body portion of the incoming request and parses it based on the <code class="calibre7"><strong class="calibre3">Content-Type</strong></code> request header. The parsed body data is then made available through the <code class="calibre7"><strong class="calibre3">req.body</strong></code> property. Let us install it using the npm package manager:</p>
<p class="code"><code class="calibre7">$ npm install body-parser --save</code></p>
<p class="nonindent">Additionally, let us install the TypeScript definitions for Express and <code class="calibre7"><strong class="calibre3">body-parser</strong></code> as dev dependencies:</p>
<p class="code"><code class="calibre7">$ npm install -D @types/express @types/body-parser</code></p>
<p class="nonindent">Now, let us update the <code class="calibre7"><strong class="calibre3">main.ts</strong></code> file in the root directory of the project with the following code:</p>
<p class="code"><code class="calibre7">import express from 'express';</code></p>
<p class="code1"><code class="calibre7">import * as bodyParser from 'body-parser';</code></p>
<p class="code1"><code class="calibre7">import { users } from "./users/user";</code></p>
<p class="code1"><code class="calibre7">import { Application } from 'express';</code></p>
<p class="code"><code class="calibre7">const app: Application = express();</code></p>
<p class="code"><code class="calibre7"><a id="page81"/>app.use(bodyParser.json());</code></p>
<p class="code"><code class="calibre7">app.get('/api/users', (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.json(users);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">app.listen(3000, () =&gt; {</code></p>
<p class="code2"><code class="calibre7">console.log('Server listening on port 3000');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">Next, create a <code class="calibre7"><strong class="calibre3">user.ts</strong></code> file in the user directory inside the <code class="calibre7"><strong class="calibre3">lib</strong></code> directory and put the following code:</p>
<p class="code"><code class="calibre7">interface User {</code></p>
<p class="code2"><code class="calibre7">id: number;</code></p>
<p class="code2"><code class="calibre7">name: string;</code></p>
<p class="code2"><code class="calibre7">email: string;</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">export const users: User[] = [</code></p>
<p class="code2"><code class="calibre7">{ id: 1, name: 'John', email: 'john@example.com' },</code></p>
<p class="code2"><code class="calibre7">{ id: 2, name: 'Jane', email: 'jane@example.com' },</code></p>
<p class="code1"><code class="calibre7">];</code></p>
<p class="nonindent">To run the server, we need to compile the TypeScript code with <code class="calibre7"><strong class="calibre3">tsc</strong></code> and start the server with node:</p>
<p class="code"><code class="calibre7">$ tsc</code></p>
<p class="code1"><code class="calibre7">$ node dist/main.js</code></p>
<p class="nonindent">Now we can test the API using a tool like Postman/curl or directly open the browser with url <code class="calibre7">http://localhost:3000/api/users</code>, it gives the following JSON output:</p>
<p class="code"><code class="calibre7">[{"id":1,"name":"John","email":"john@example.com"},{"id":2,"name":"Jane","email":"jane@example.com"}]</code></p>
<figure class="img">
<img alt="" src="img/3.3.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_3"><strong class="calibre3">Figure 3.3:</strong> Get API Users</p>
<p class="nonindent"><a id="page82"/>In the preceding example, we created an API endpoint<code class="calibre7"> /api/users</code> which returned us the users list. We also used <code class="calibre7"><strong class="calibre3">body-parser</strong></code> middleware. We will learn about middlewares later in this chapter.</p>
<h1 class="sec1" id="s86"><a href="toc.xhtml#s86a" class="calibre6">Routing</a></h1>
<p class="nonindent">Express.js provides a simple and flexible routing system that allows developers to define URL routes for handling incoming HTTP requests. Routing in Express.js refers to the mechanism of defining and handling endpoints (URL paths) for web applications and APIs.</p>
<p class="nonindent">It is a crucial aspect of any web framework, as it helps to determine how the application responds to client requests. In Express.js, routing is accomplished using the <code class="calibre7"><strong class="calibre3">express.Router()</strong></code> class, which creates modular, mountable route handlers. The router consists of route method, route path, and callback handler.</p>
<p class="code"><code class="calibre7">app.METHOD(PATH, HANDLER)</code></p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">app</strong></code> : It is an instance of express.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">METHOD</strong></code> : It is an HTTP request method, in lowercase.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">PATH</strong></code> : It is a path on the server.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">HANDLER</strong></code> : It is the function executed when the route is matched.</p>
<h1 class="sec1" id="s87"><a href="toc.xhtml#s87a" class="calibre6">Route Methods</a></h1>
<p class="nonindent">There are most commonly used methods are as follows:</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">GET</strong></code> : It is used for retrieving data.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">POST</strong></code> : It is used for creating or adding new data.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">PUT</strong></code> : It is used to update an existing data.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">DELETE</strong></code> : It is used to delete data.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">PATCH</strong></code> : It is used to partially update an existing data.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">OPTIONS</strong></code> : It is used to retrieve information about available options for data.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">HEAD</strong></code> : It is similar to the<code class="calibre7"> GET</code> method but only retrieves the response headers without the response body.</p>
<p class="nonindent">You can also use <code class="calibre7"><strong class="calibre3">app.all()</strong></code> to handle all HTTP methods.</p>
<p class="code"><code class="calibre7">app.all('/', (req, res, next) =&gt; {</code></p>
<p class="code2"><code class="calibre7">console.log('all method…')</code></p>
<p class="code2"><code class="calibre7">next() // pass control to the next handler</code></p>
<p class="code1"><code class="calibre7">})</code></p>
<h1 class="sec1" id="s88"><a id="page83" class="calibre6"/><a href="toc.xhtml#s88a" class="calibre6">Route Paths</a></h1>
<p class="nonindent">A path can be string, string pattern, or a regular expression.</p>
<p class="nonindent">This route path will match requests to <code class="calibre7"><strong class="calibre3">/users</strong></code> specific string.</p>
<p class="code"><code class="calibre7">app.get('/users, (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.send('users')</code></p>
<p class="code1"><code class="calibre7">})</code></p>
<p class="nonindent">This route path will be matched with string patterns such as <code class="calibre7"><strong class="calibre3">abcd</strong></code>, <code class="calibre7"><strong class="calibre3">abbcd</strong></code>, <code class="calibre7"><strong class="calibre3">abbbcd</strong></code>, and so on.</p>
<p class="code"><code class="calibre7">app.get('/ab+cd', (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.send('ab+cd')</code></p>
<p class="code1"><code class="calibre7">})</code></p>
<p class="nonindent">This route path will match blueberries and strawberries, raspberries, but not <code class="calibre7"><strong class="calibre3">blueberriesfruit</strong></code>, <code class="calibre7"><strong class="calibre3">strawberriesfruit</strong></code>, and so on.</p>
<p class="code"><code class="calibre7">app.get(/.*berries$/, (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.send('/.*berries$/')</code></p>
<p class="code1"><code class="calibre7">})</code></p>
<p class="nonindent">These are different ways of defining route paths.</p>
<h1 class="sec1" id="s89"><a href="toc.xhtml#s89a" class="calibre6">Route Parameters</a></h1>
<p class="nonindent">Express.js treats certain characters differently in string-based paths compared to their regular expression counterparts.</p>
<p class="nonindent">For example, ?, +, *, and () are all subsets of their regular expression counterparts. On the other hand, the hyphen (-) and the dot (.) are interpreted literally when used in string-based paths.</p>
<p class="nonindent">Consider the following example:</p>
<p class="code"><code class="calibre7"><a id="page84"/>app.get('/projects/:projectCode', function(req, res) {</code></p>
<p class="code2"><code class="calibre7">var projectCode = req.params.projectCode;</code></p>
<p class="code2"><code class="calibre7">// Do something with the project code</code></p>
<p class="code2"><code class="calibre7">res.send('project code: ' + projectCode);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">app.get('/users/:user-email', function(req, res) {</code></p>
<p class="code2"><code class="calibre7">var userEmail = req.params['user-email'];</code></p>
<p class="code2"><code class="calibre7">// Do something with the user email</code></p>
<p class="code2"><code class="calibre7">res.send('User email: ' + userEmail);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">app.get('/files/:file_name.pdf', function(req, res) {</code></p>
<p class="code2"><code class="calibre7">var fileName = req.params['file_name'];</code></p>
<p class="code2"><code class="calibre7">// Do something with the file name</code></p>
<p class="code2"><code class="calibre7">res.send('File name: ' + fileName);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">In this example, there are three routes with hyphens and dots in their parameters. The first route <code class="calibre7"><strong class="calibre3">/projects/:projectCode</strong></code> accepts a project code parameter, which can contain hyphens. The second route <code class="calibre7"><strong class="calibre3">/users/:user-email</strong></code> accepts a user email parameter, which can contain hyphens. The third route <code class="calibre7"><strong class="calibre3">/files/:file_name.pdf</strong></code> accepts a file name parameter, which can contain hyphens and ends with .pdf.</p>
<h1 class="sec1" id="s90"><a href="toc.xhtml#s90a" class="calibre6">Route Handlers</a></h1>
<p class="nonindent">When a route is matched in Express.js, it can have one or more handler functions associated with it, which are executed. Route handlers are responsible for processing requests, accessing data, and returning responses to the client.</p>
<p class="nonindent">Let us take the following example:</p>
<p class="code"><code class="calibre7">app.get('/api/users', (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.json(users);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">In this example, the route handler function is <code class="calibre7"><strong class="calibre3">(req, res) =&gt; {…}</strong></code>, which is executed when a <code class="calibre7"><strong class="calibre3">GET</strong></code> request is received with a URL path that matches the pattern <code class="calibre7"><strong class="calibre3">/api/users</strong></code>. The <code class="calibre7"><strong class="calibre3">req</strong></code> parameter contains information about the incoming request, such as the request headers and parameters, while the <code class="calibre7"><strong class="calibre3">res</strong></code> parameter is used to send a response back to the client.</p>
<h1 class="sec1" id="s91"><a href="toc.xhtml#s91a" class="calibre6">Middleware</a></h1>
<p class="nonindent">Express.js supports middleware functions that can modify incoming requests or outgoing responses as per the required custom logic. Middleware in Express.js refers to a series of functions that are executed in a specific order when a client sends a request to a server. These functions have access to the request and response objects <a id="page85"/>and can modify them as needed. Middleware functions can be used for a variety of purposes such as logging, authentication, error handling, and more.</p>
<p class="nonindent">In Express.js, middleware functions can be added to the application or specific routes using the `<code class="calibre7"><strong class="calibre3">use()</strong></code>` method.</p>
<p class="nonindent">Previously we already used body-parser as middleware while building rest api. This middleware is for each route as passed in <code class="calibre7"><strong class="calibre3">app.use()</strong></code>, for example.</p>
<p class="code"><code class="calibre7">app.use(bodyParser.json());</code></p>
<p class="nonindent">There is another <strong class="calibre3">example of middleware in which you do not wish to use it</strong>  for each route such as user validation on a specific route. They are executed in the order in which they are added and can be chained together using the <code class="calibre7"><strong class="calibre3">next()</strong></code> function to pass control to the next middleware function in the stack.</p>
<p class="code"><code class="calibre7">// Validation middleware</code></p>
<p class="code1"><code class="calibre7">const validate = (req, res, next) =&gt; {</code></p>
<p class="code2"><code class="calibre7">const { name } = req.body;</code></p>
<p class="code2a"><code class="calibre7">if (!name) {</code></p>
<p class="code3"><code class="calibre7">return res.status(400).send('Name is required');</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">next();</code></p>
<p class="code1"><code class="calibre7">};</code></p>
<p class="code"><code class="calibre7">// Route</code></p>
<p class="code1"><code class="calibre7">app.post('/users', validate, (req, res) =&gt; {</code></p>
<p class="code2a"><code class="calibre7">const { name } = req.body;</code></p>
<p class="code2"><code class="calibre7">res.send(`Hello, ${name}!`);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">In this example, the validate middleware function is defined to check if the name parameter is present in the body string. If it is not present, the middleware sends a 400 Bad Request response with an error message. If the name parameter is present, the middleware calls the <code class="calibre7"><strong class="calibre3">next()</strong></code> function to pass control to the next middleware or route handler.</p>
<p class="nonindent">The validate middleware is then used in the `<code class="calibre7"><strong class="calibre3">/user</strong></code>` route handler as the second argument to ensure that the name parameter is present before generating a user’s response.</p>
<a id="page86"/>
<figure class="img">
<img alt="" src="img/3.4.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_4"><strong class="calibre3">Figure 3.4:</strong> Post API User Bad Request</p>
<p class="nonindent"><em class="calibre4"><a href="#fig3_5">Figure 3.5</a></em> shows the result <code class="calibre7">"<strong class="calibre3">Hello, Yamini!</strong>"</code>:</p>
<figure class="img">
<img alt="" src="img/3.5.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_5"><strong class="calibre3">Figure 3.5:</strong> Post API User Valid Input Name</p>
<h1 class="sec" id="s92"><a href="toc.xhtml#s92a" class="calibre6">Error Handling</a></h1>
<p class="nonindent">Error handling is an important aspect of building robust applications. The framework provides a few ways to handle errors:</p>
<h1 class="sec1" id="s93"><a href="toc.xhtml#s93a" class="calibre6">Built-in Error Handling</a></h1>
<p class="nonindent">Express.js provides a built-in error-handling middleware function that can be used to handle errors in the application. This middleware function can be used to catch any unhandled errors that occur during the execution of the application.</p>
<p class="nonindent"><a id="page87"/>In Express.js, another way to handle errors is by utilizing middleware functions with error-first callbacks or functions. Here is an example demonstrating how it can be implemented:</p>
<p class="code"><code class="calibre7">import express, { Request, Response, NextFunction } from 'express';</code></p>
<p class="code"><code class="calibre7">const app = express();</code></p>
<p class="code"><code class="calibre7">app.get('/', (req: Request, res: Response) =&gt; {</code></p>
<p class="code2"><code class="calibre7">throw new Error('Oops! Something went wrong.');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">app.use((err: Error, req: Request, res: Response, next: NextFunction) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.status(500).send('Something went wrong!');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">app.listen(3000, () =&gt; {</code></p>
<p class="code2"><code class="calibre7">console.log('Server listening on port 3000!');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">In this example, we have defined an Express app with a single route that throws an error. We then use the built-in error handling middleware function <code class="calibre7"><strong class="calibre3">app.use</strong></code> to catch the error and send a <code class="calibre7"><strong class="calibre3">500</strong></code> status code with a message to the client.</p>
<p class="nonindent">The error-handling middleware function takes four arguments: err, req, res, and next. The first argument (<code class="calibre7"><strong class="calibre3">err</strong></code>) is the error that was thrown, the second argument (<code class="calibre7"><strong class="calibre3">req</strong></code>) is the request object, the third argument (<code class="calibre7"><strong class="calibre3">res</strong></code>) is the response object, and the fourth argument (<code class="calibre7"><strong class="calibre3">next</strong></code>) is a function that is used to pass control to the next middleware function in the stack.</p>
<p class="nonindent">If an error is thrown within any middleware or route handler function, Express.js will automatically call the error handling middleware function with the thrown error object as the first argument.</p>
<a id="page88"/>
<figure class="img">
<img alt="" src="img/3.6.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_6"><strong class="calibre3">Figure 3.6:</strong> Error Handling</p>
<h1 class="sec1" id="s94"><a href="toc.xhtml#s94a" class="calibre6">Custom Error Handling</a></h1>
<p class="nonindent">Developers can also create their own custom error-handling middleware to handle specific types of errors. This middleware function can be added to the middleware stack and used to catch errors that are specific to the application.</p>
<p class="nonindent">Let us update the <code class="calibre7"><strong class="calibre3">main.ts</strong></code> file with the following code:</p>
<p class="code"><code class="calibre7">import express, { Application, Request, Response, NextFunction } from 'express';</code></p>
<p class="code1"><code class="calibre7">import { HttpException, NotFoundException } from './utils/errorHandler';</code></p>
<p class="code1"><code class="calibre7">import * as bodyParser from 'body-parser';</code></p>
<p class="code1"><code class="calibre7">import { users, Users } from "./users/user";</code></p>
<p class="code"><code class="calibre7">const app: Application = express();</code></p>
<p class="code"><code class="calibre7">app.use(bodyParser.json());</code></p>
<p class="code"><code class="calibre7">app.get('/api/users', (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.json(users);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">app.get('/users/:id', (req, res, next) =&gt; {</code></p>
<p class="code2"><code class="calibre7">const userId = req.params.id;</code></p>
<p class="code2"><code class="calibre7">const user = new Users();</code></p>
<p class="code2"><code class="calibre7"><a id="page89"/>const isUserExist = user.getUserById(userId);</code></p>
<p class="code2a"><code class="calibre7">if (!isUserExist) {</code></p>
<p class="code3"><code class="calibre7">return next(new NotFoundException(`User with ID ${userId} not found`));</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2a"><code class="calibre7">res.status(200).json(user);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">app.use((err: HttpException, req: Request, res: Response, next: NextFunction) =&gt; {</code></p>
<p class="code2"><code class="calibre7">const status = err.status || 500;</code></p>
<p class="code2"><code class="calibre7">const message = err.message || 'Internal server error';</code></p>
<p class="code2a"><code class="calibre7">res.status(status).json({ error: message });</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">app.listen(3000, () =&gt; {</code></p>
<p class="code2"><code class="calibre7">console.log('Server listening on port 3000!');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">Create <code class="calibre7">utils</code> folder and create <code class="calibre7"><strong class="calibre3">errorHandler.ts</strong></code> file into that directory the paste the following code:</p>
<p class="code"><code class="calibre7">export class HttpException extends Error {</code></p>
<p class="code3"><code class="calibre7">status: number;</code></p>
<p class="code3"><code class="calibre7">message: string;</code></p>
<p class="code3a"><code class="calibre7">constructor(status: number, message: string) {</code></p>
<p class="code4"><code class="calibre7">super(message);</code></p>
<p class="code4"><code class="calibre7">this.status = status;</code></p>
<p class="code4"><code class="calibre7">this.message = message;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">export class NotFoundException extends HttpException {</code></p>
<p class="code3"><code class="calibre7">constructor(message: string = 'Not Found') {</code></p>
<p class="code4"><code class="calibre7">super(404, message);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page90"/>Now update the <code class="calibre7"><strong class="calibre3">user.ts</strong></code> file in users directory with the following code:</p>
<p class="code"><code class="calibre7">interface User {</code></p>
<p class="code3"><code class="calibre7">id: number;</code></p>
<p class="code3"><code class="calibre7">name: string;</code></p>
<p class="code3"><code class="calibre7">email: string;</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">export const users: User[] = [</code></p>
<p class="code3"><code class="calibre7">{ id: 1, name: 'John', email: 'john@example.com' },</code></p>
<p class="code3"><code class="calibre7">{ id: 2, name: 'Jane', email: 'jane@example.com' },</code></p>
<p class="code1"><code class="calibre7">];</code></p>
<p class="code1"><code class="calibre7">export class Users {</code></p>
<p class="code3"><code class="calibre7">public getUserById(userId) {</code></p>
<p class="code4"><code class="calibre7">if (users.find(i =&gt; i.id == userId)) {</code></p>
<p class="code5"><code class="calibre7">return true;</code></p>
<p class="code4"><code class="calibre7">} else {</code></p>
<p class="code5"><code class="calibre7">return false;</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In this example, there is a custom <code class="calibre7"><strong class="calibre3">HttpException</strong></code> class that extends the Error class and adds a status property. There is also a <code class="calibre7"><strong class="calibre3">NotFoundException</strong></code> class that extends the <code class="calibre7"><strong class="calibre3">HttpException</strong></code> class and sets the status to 404 by default.</p>
<p class="nonindent">In the route handler for <code class="calibre7"><strong class="calibre3">/users/:id</strong></code>, if the requested user is not found, a <code class="calibre7"><strong class="calibre3">NotFoundException</strong></code> is thrown and passed to the next function, which triggers the custom error handling middleware.</p>
<a id="page91"/>
<figure class="img">
<img alt="" src="img/3.7.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_7"><strong class="calibre3">Figure 3.7:</strong> User Not Found Exception</p>
<p class="nonindent">The custom error handling middleware checks if the error is an instance of <code class="calibre7"><strong class="calibre3">HttpException</strong></code> and uses the status and message properties to send a JSON response with the appropriate HTTP status code. If the error is not an instance of <code class="calibre7"><strong class="calibre3">HttpException</strong></code>, it sends a generic 500 error response.</p>
<figure class="img">
<img alt="" src="img/3.8.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_8"><strong class="calibre3">Figure 3.8:</strong> Sample code in VsCode Editor</p>
<h1 class="sec1" id="s95"><a href="toc.xhtml#s95a" class="calibre6">Async Error Handling</a></h1>
<p class="nonindent">In Express.js, asynchronous errors can be handled using try-catch blocks or by returning a rejected Promise.</p>
<p class="nonindent"><a id="page92"/>Add the following code in <code class="calibre7"><strong class="calibre3">main.ts</strong></code> file:</p>
<p class="code"><code class="calibre7">// Async function that throws an error</code></p>
<p class="code1"><code class="calibre7">async function asyncFunction(): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">throw new Error('Async error');</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">// Async route handler that calls the async function</code></p>
<p class="code1"><code class="calibre7">app.get('/async-error', async (req: Request, res: Response, next: NextFunction) =&gt; {</code></p>
<p class="code2"><code class="calibre7">try {</code></p>
<p class="code3"><code class="calibre7">await asyncFunction();</code></p>
<p class="code3"><code class="calibre7">res.send('Success');</code></p>
<p class="code2"><code class="calibre7">} catch (error) {</code></p>
<p class="code3"><code class="calibre7">next(error);</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">// Error handling middleware</code></p>
<p class="code1"><code class="calibre7">app.use((err: Error, req: Request, res: Response, next: NextFunction) =&gt; {</code></p>
<p class="code2"><code class="calibre7">console.error(err.message);</code></p>
<p class="code2"><code class="calibre7">res.status(500).send('Something broke!');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">Now compile and run the code with <code class="calibre7"><strong class="calibre3">$ tsc</strong></code> and then <code class="calibre7"><strong class="calibre3">$ node dist/main.js</strong></code>. After that open browser with <code class="calibre7"><strong class="calibre3">http://localhost:3000/async-error</strong></code>it displays as Something broke!</p>
<p class="nonindent">In this example, we have an async function called <code class="calibre7"><strong class="calibre3">asyncFunction</strong></code> that throws an error. We have a route handler that calls this function and catches any errors that occur using a try-catch block. If an error occurs, the next function is called with the error parameter to pass the error to the error-handling middleware.</p>
<p class="nonindent">The error-handling middleware function takes four parameters: <code class="calibre7">err</code>, <code class="calibre7">req</code>, <code class="calibre7">res</code>, and <code class="calibre7">next</code>. If an error occurs in any middleware or route handler before this function, it will be passed to this middleware function. The middleware function logs the error to the console and sends a <code class="calibre7"><strong class="calibre3">500 Internal Server Error</strong></code> response to the client.</p>
<p class="nonindent">Note that the <code class="calibre7"><strong class="calibre3">async</strong></code> keyword is used before the route handler function to indicate that it is an asynchronous function. Also, the <code class="calibre7"><strong class="calibre3">await</strong></code> keyword is used before the call to the <code class="calibre7"><strong class="calibre3">asyncFunction</strong></code> to wait for the function to complete before proceeding to the next line of code.</p>
<a id="page93"/>
<figure class="img">
<img alt="" src="img/3.9.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_9"><strong class="calibre3">Figure 3.9:</strong> Async Error API</p>
<p class="nonindent"><em class="calibre4"><a href="#fig3_10">Figure 3.10</a></em> shows the terminal output:</p>
<figure class="img">
<img alt="" src="img/3.10.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_10"><strong class="calibre3">Figure 3.10:</strong> Async Error Terminal Output</p>
<p class="nonindent">It is important to handle errors properly in an Express.js application to ensure that the application is robust and reliable.</p>
<h1 class="sec1" id="s96"><a href="toc.xhtml#s96a" class="calibre6">Static File Serving</a></h1>
<p class="nonindent">In Express.js, we can serve static files, such as images, CSS, JavaScript files, and more, using the <code class="calibre7"><strong class="calibre3">express.static()</strong></code> middleware function, for example.</p>
<p class="code"><code class="calibre7">app.use(express.static('public'));</code></p>
<p class="nonindent">In the preceding example, we are serving static files from the public directory. The <code class="calibre7"><strong class="calibre3">express.static()</strong></code> middleware function takes one argument, which is the name of the directory that contains the static files.</p>
<p class="nonindent">Once the middleware is set up, you can access your static files by specifying their URL relative to the public directory. For example, if you have a file called <code class="calibre7"><strong class="calibre3">profilePic.png</strong></code> in the <code class="calibre7"><strong class="calibre3">public/images</strong></code> directory, you can access it at <code class="calibre7"><strong class="calibre3">http://localhost:3000/images/profilePic.png</strong></code></p>
<a id="page94"/>
<figure class="img">
<img alt="" src="img/3.11.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_11"><strong class="calibre3">Figure 3.11:</strong> Static Serving Image File</p>
<h1 class="sec" id="s97"><a href="toc.xhtml#s97a" class="calibre6">Templating Engines</a></h1>
<p class="nonindent">In Express.js, templating engines are used to generate HTML markup and dynamically render views. Templating engines allow you to create templates with placeholders for dynamic data that can be replaced with real data when the template is rendered.</p>
<p class="nonindent">Some of the popular templating engines supported by Express.js include:</p>
<ul class="bull">
<li class="calibre9">EJS (Embedded JavaScript)</li>
<li class="calibre9">Pug (formerly Jade)</li>
<li class="calibre9">Handlebars</li>
<li class="calibre9">Mustache</li>
</ul>
<p class="nonindent">To use a templating engine in an Express.js application, you need to install the engine using npm and set it as the default view engine in the app configuration. Then you can create views using the syntax and features of the chosen templating engine.</p>
<p class="nonindent">Open the terminal and install dependency for <code class="calibre7"><strong class="calibre3">ejs</strong></code> with the following command:</p>
<p class="code"><code class="calibre7">$ npm install ejs --save</code></p>
<p class="nonindent">Once <code class="calibre7"><strong class="calibre3">ejs</strong></code> is installed, we can try the following example code:</p>
<p class="code"><code class="calibre7">app.set('view engine', 'ejs');</code></p>
<p class="code1"><code class="calibre7">app.set('views', path.join(__dirname, 'views'));</code></p>
<p class="code1"><code class="calibre7"><a id="page95"/>app.get('/ejs', (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">const data = {</code></p>
<p class="code3"><code class="calibre7"> title: 'My App',</code></p>
<p class="code3"><code class="calibre7"> message: 'Hello, I am from EJS !!'</code></p>
<p class="code2"><code class="calibre7">};</code></p>
<p class="code2"><code class="calibre7">res.render('index', data);</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">Create <code class="calibre7"><strong class="calibre3">index.ejs</strong></code> file and paste html code.</p>
<p class="code"><code class="calibre7">&lt;!DOCTYPE html&gt;</code></p>
<p class="code1"><code class="calibre7">&lt;html&gt;</code></p>
<p class="code2"><code class="calibre7">&lt;head&gt;</code></p>
<p class="code3"><code class="calibre7">&lt;title&gt;&lt;%= title %&gt;&lt;/title&gt;</code></p>
<p class="code2"><code class="calibre7">&lt;/head&gt;</code></p>
<p class="code2"><code class="calibre7">&lt;body&gt;</code></p>
<p class="code3"><code class="calibre7">&lt;h1&gt;&lt;%= message %&gt;&lt;/h1&gt;</code></p>
<p class="code2"><code class="calibre7">&lt;/body&gt;</code></p>
<p class="code1"><code class="calibre7">&lt;/html&gt;</code></p>
<p class="nonindent">In this example, we use the<code class="calibre7"> <strong class="calibre3">&lt;%= %&gt;</strong></code> syntax to output the <code class="calibre7">"<strong class="calibre3">title</strong>"</code> and <code class="calibre7">"<strong class="calibre3">message</strong>"</code> variables that were passed to the view in the route handler. When the view is rendered, these variables will be replaced with their respective values.</p>
<p class="nonindent">The TypeScript compiler handles the task of generating JavaScript files and transferring them to the <code class="calibre7"><strong class="calibre3">dist</strong></code> folder. However, it does not handle the copying of other necessary project files like EJS view templates. To address this, you can create a build script responsible for copying all additional files to the <code class="calibre7"><strong class="calibre3">dist</strong></code> folder.</p>
<p class="nonindent">To automatically copy files from the views folder to the <code class="calibre7"><strong class="calibre3">dist</strong></code> folder after compiling your TypeScript code, you can use a build tool like <code class="calibre7"><strong class="calibre3">copyfiles</strong></code> or copy.</p>
<p class="nonindent">First, install the <code class="calibre7"><strong class="calibre3">copyfiles</strong></code> package as a dev dependency with the following command executed in the terminal:</p>
<p class="code"><code class="calibre7">$npm install --save-dev copyfiles</code></p>
<p class="nonindent">Now update the scripts in <code class="calibre7"><strong class="calibre3">package.json</strong></code> with the following code:</p>
<p class="code2a"><code class="calibre7">"scripts": {</code></p>
<p class="code3"><code class="calibre7">"build": "tsc &amp;&amp; npm run copy-views",</code></p>
<p class="code3"><code class="calibre7">"copy-views": "cpy 'views/*' dist/views/ --recursive"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page96"/>Then execute script from the terminal with the following code:</p>
<p class="code"><code class="calibre7">$ npm run build</code></p>
<figure class="img">
<img alt="" src="img/3.12.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_12"><strong class="calibre3">Figure 3.12:</strong> Build Application</p>
<p class="nonindent">After running the application, you can open your web browser and navigate to <code class="calibre7"><strong class="calibre3">http://localhost:3000/ejs</strong></code>. This will display the HTML output in the browser, as shown in the following image.</p>
<figure class="img">
<img alt="" src="img/3.13.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig3_13"><strong class="calibre3">Figure 3.13:</strong> Browser EJS Template</p>
<h1 class="sec" id="s98"><a href="toc.xhtml#s98a" class="calibre6">Security and Performance Best Practices</a></h1>
<p class="nonindent">There are several security best practices to follow when developing applications with Express.js:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Use secure HTTP protocols</strong>: Always use HTTPS instead of HTTP to ensure secure communication between client and server.</li>
<li class="calibre9"><strong class="calibre3">Use the latest version</strong>: Keep your Express.js version up to date, and apply security patches as soon as they become available.</li>
<li class="calibre9"><strong class="calibre3">Avoid using deprecated or vulnerable packages</strong>: Use only up-to-date, well-maintained packages and avoid deprecated or vulnerable ones.</li>
<li class="calibre9"><strong class="calibre3">Validate user input</strong>: Always validate user input to prevent injection attacks, cross-site scripting (XSS) attacks, and other malicious activities.</li>
<li class="calibre9"><strong class="calibre3">Use a Content Security Policy (CSP)</strong>: Implement a Content Security Policy (CSP) to protect against XSS attacks by limiting the resources that a page can load.
<p class="nonindent"><strong class="calibre3"><a id="page97"/>Example:</strong></p>
<p class="code1"><code class="calibre7">app.use((req, res, next) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.setHeader(</code></p>
<p class="code3"><code class="calibre7">'Content-Security-Policy',</code></p>
<p class="code3"><code class="calibre7">"default-src 'self'; script-src 'self'</code> <code class="calibre7">'unsafe-inline'; img-src 'self' data:; font-src 'self' data:;"</code></p>
<p class="code2"><code class="calibre7">);</code></p>
<p class="code2"><code class="calibre7">next();</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">The CSP header is then set in a middleware function that is added to the Express app. The CSP policy in this example allows scripts to be loaded from the same domain (‘<code class="calibre7"><code><strong class="calibre3">unsafe-inline</code></code>’). Images and fonts are allowed from the same domain as well as from the data: protocol.</p></li>
<li class="calibre9"><strong class="calibre3">Implement rate limiting</strong>: Implement rate limiting to prevent brute force attacks and other types of attacks that involve repeated requests.
<p class="nonindent"><strong class="calibre3">Example:</strong></p>
<p class="nonindent">First, install the <code class="calibre7"><strong class="calibre3">express-rate-limit</strong></code> package using npm:</p>
<p class="code"><code class="calibre7">$ npm install express-rate-limit</code></p>
<p class="nonindent">Then, require the package and create a new rate limiter object with the desired options:</p>
<p class="code"><code class="calibre7">const rateLimit = require("express-rate-limit");</code></p>
<p class="code"><code class="calibre7">const limiter = rateLimit({</code></p>
<p class="code2"><code class="calibre7">windowMs: 15 * 60 * 1000, // 15 minutes</code></p>
<p class="code2"><code class="calibre7">max: 100 // limit each IP to 100 requests per windowMs</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">In this example, we are creating a rate limiter that limits each IP address to 100 requests every 15 minutes.</p>
<p class="nonindent">Finally, apply the rate limiter middleware to the desired routes:</p>
<p class="code"><code class="calibre7">app.use(limiter);</code></p>
<p class="code"><code class="calibre7">app.get("/", (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.send("Hello World!");</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent"><a id="page98"/>Now, each incoming request to the root route (<code class="calibre7">"</code>/<code class="calibre7">"</code>) will be checked against the rate limiter. If the IP address has exceeded the maximum number of requests within the specified time window, the middleware will return a 429 <code class="calibre7">"<strong class="calibre3">Too Many Requests</strong>"</code> error.</p></li>
<li class="calibre9"><strong class="calibre3">Use helmet</strong>: Use the helmet middleware to add additional security headers to HTTP responses, such as the X-XSS-Protection, X-Content-Type-Options, and X-Frame-Options headers.
<p class="nonindent"><strong class="calibre3">Example:</strong></p>
<p class="code"><code class="calibre7">import helmet from "helmet";</code></p>
<p class="code"><code class="calibre7">// Use Helmet middleware</code></p>
<p class="code1"><code class="calibre7">app.use(helmet());</code></p>
<p class="code"><code class="calibre7">// Add routes to the app</code></p>
<p class="code1"><code class="calibre7">app.get("/", (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.send("Hello, world!");</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">In this example, the helmet middleware is imported from the helmet package and used in the application using <code class="calibre7"><strong class="calibre3">app.use(helmet())</strong></code>. This will automatically add security headers to HTTP responses, such as setting the X-Content-Type-Options header to <code class="calibre7"><strong class="calibre3">nosniff</strong></code> to prevent browsers from interpreting response content as a different MIME type.</p>
<p class="nonindent">Note that this is just a basic example, and additional configuration may be necessary depending on the specific security needs of your application.</p></li>
<li class="calibre9"><strong class="calibre3">Use secure cookies</strong>: When using cookies, set the secure and <code class="calibre7"><strong class="calibre3">httpOnly</strong></code> flags to prevent cross-site scripting (XSS) and cross-site request forgery (CSRF) attacks.
<p class="nonindent"><strong class="calibre3">Example:</strong></p>
<p class="code"><code class="calibre7">import cookieParser from 'cookie-parser';</code></p>
<p class="code1"><code class="calibre7">app.use(cookieParser('secret'));</code></p>
<p class="code1"><code class="calibre7">app.get('/set-cookie', (req, res) =&gt; {</code></p>
<p class="code2"><code class="calibre7">res.cookie('myCookie', 'someValue', {</code></p>
<p class="code3"><code class="calibre7">httpOnly: true,</code></p>
<p class="code3"><code class="calibre7">sameSite: 'strict',</code></p>
<p class="code3"><code class="calibre7">secure: true</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">res.send('Cookie set successfully!');</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent"><a id="page99"/>In this example, the cookie-parser middleware is used to parse cookies in incoming requests. The secret argument is used to sign and encrypt the cookies.</p>
<p class="nonindent">The<code class="calibre7"> <strong class="calibre3">/set-cookie</strong></code> route sets a new cookie with the <code class="calibre7"><strong class="calibre3">res.cookie()</strong></code> method. The httpOnly option prevents the cookie from being accessed by JavaScript code, making it more difficult for an attacker to steal the cookie using a cross-site scripting (XSS) attack. The sameSite option limits the scope of the cookie to the same site that set it, reducing the risk of cross-site request forgery (CSRF) attacks. The secure option ensures that the cookie is only sent over HTTPS, protecting it from interception by network attackers.</p>
<p class="nonindent">By following these best practices for secure cookie handling, you can significantly improve the security of your Express.js application.</p></li>
<li class="calibre9"><strong class="calibre3">Implement a secure deployment process</strong>: Implement a secure deployment process that includes secure configurations, code review, and testing to prevent security vulnerabilities from being introduced into production.</li>
<li class="calibre9"><strong class="calibre3">Use a linter and security scanner</strong>: Use a linter and security scanner to detect and fix potential security issues in your code. The best example is <code class="calibre7"><strong class="calibre3">EsLint</strong></code>.</li>
</ul>
<p class="nonindent">By following these security best practices, you can help ensure that your Express.js applications are secure and protected against common security threats.</p>
<p class="nonindent">There are some performance best practices to follow when developing applications with Express.js:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Avoid the use of synchronous functions</strong>: It is recommended to use asynchronous code because synchronous code in production slows down the application, so try to avoid unnecessary synchronous functions and use <code class="calibre7"><strong class="calibre3">async</strong></code>/<code class="calibre7"><strong class="calibre3">await</strong></code> with promises.</li>
<li class="calibre9"><strong class="calibre3">Exception handling</strong>: Use always try catch to handle the exception at the code level so it does not break the application on run time.</li>
<li class="calibre9"><strong class="calibre3">Reduce middleware usage</strong>: Use only the required middleware and avoid excessive usage. Middleware can be resource-intensive and may slow down the application.</li>
<li class="calibre9"><strong class="calibre3">Caching</strong>: Implement caching for frequently requested data such as static files or API responses. By caching this data, you can reduce the number of requests that the server has to process and significantly improve the response times of your application.</li>
<li class="calibre9"><strong class="calibre3"><a id="page100"/>Use cluster</strong>: Use Node.js Cluster mode to utilize all available CPU cores and distribute the load evenly across all cores which improves the performance of the application.</li>
<li class="calibre9"><strong class="calibre3">Auto restart application</strong>: Make sure that if anytime application crashes then it automatically restarts so use a process manager or packages such as PM2 or Forever for that.</li>
</ul>
<p class="nonindent">By following these recommended practices, you can enhance the performance of your Express.js application, resulting in a faster and more efficient user experience.</p>
<h1 class="sec" id="s99"><a href="toc.xhtml#s99a" class="calibre6">Conclusion</a></h1>
<p class="nonindent">In this chapter, we learned about Express.js, a popular and powerful web application framework for Node.js. We learned about its offerings, upsides, and limitations. While it has a few limitations, the benefits of Express.js, such as its active community, extensive documentation, and support for REST API development, make it an excellent choice for web development projects.</p>
<p class="nonindent">In the next chapter, we will start building a project management system application. We will take this as a big exercise to learn the concepts of TypeScript and Express.Js.</p>
<h1 class="sec" id="s100"><a href="toc.xhtml#s100a" class="calibre6">Multiple Choice Questions</a></h1>
<ol class="num">
<li class="calibre9">What is Express.js primarily used for?
<ol class="alfa">
<li class="calibre9">Database management</li>
<li class="calibre9">Front-end development</li>
<li class="calibre9">Building web applications and APIs</li>
<li class="calibre9">Machine learning</li></ol></li>
<li class="calibre9">What advantages and drawbacks are associated with the Express.js framework?
<ol class="alfa">
<li class="calibre9">Advantages encompass its lightweight and minimalist design, while drawbacks involve the absence of built-in features for complex applications.</li>
<li class="calibre9">Advantages comprise a wide range of built-in features for complex applications, while drawbacks pertain to suboptimal performance.</li>
<li class="calibre9">Advantages include automated scaling for high-traffic applications, while drawbacks involve a challenging learning curve.</li>
<li class="calibre9">Advantages entail effortless integration with databases, while drawbacks concern the absence of routing support.</li></ol></li>
<li class="calibre9"><a id="page101"/>What is the purpose of the Express.js Router object?
<ol class="alfa">
<li class="calibre9">To define routes for multiple applications</li>
<li class="calibre9">To create middleware functions</li>
<li class="calibre9">To handle errors in the application</li>
<li class="calibre9">To define routes for a specific part of the application</li></ol></li>
<li class="calibre9">What role does middleware play in an Express.js application?
<ol class="alfa">
<li class="calibre9">To host static files</li>
<li class="calibre9">To establish routes</li>
<li class="calibre9">To manage incoming requests and responses</li>
<li class="calibre9">To facilitate authentication</li></ol></li>
<li class="calibre9">How can you handle routing parameters in Express.js?
<ol class="alfa">
<li class="calibre9">Using the <code class="calibre7">req.routeParams</code> object</li>
<li class="calibre9">By defining separate route handlers for each parameter</li>
<li class="calibre9">Accessing them directly from the URL</li>
<li class="calibre9">Using the <code class="calibre7">req.params</code> object</li></ol></li>
<li class="calibre9">What does the <code class="calibre7">next()</code> function do in Express.js middleware?
<ol class="alfa">
<li class="calibre9">Ends the request-response cycle</li>
<li class="calibre9">Passes control to the next middleware function</li>
<li class="calibre9">Sends a response to the client</li>
<li class="calibre9">Logs information to the console</li></ol></li>
<li class="calibre9">How can you handle errors in an Express.js application using middleware?
<ol class="alfa">
<li class="calibre9">Use the <code class="calibre7">catchError</code> middleware function</li>
<li class="calibre9">Wrap the code in <code class="calibre7">try-catch</code> blocks</li>
<li class="calibre9">Use the error event on the app object</li>
<li class="calibre9">Define an error-handling middleware with four parameters</li></ol></li>
<li class="calibre9">Which of the following Express.js middleware is commonly used for parsing JSON requests?
<ol class="alfa">
<li class="calibre9"><code class="calibre7">express-static</code></li>
<li class="calibre9"><code class="calibre7">body-parser</code></li>
<li class="calibre9"><code class="calibre7"><a id="page102"/>cookie-parser</code></li>
<li class="calibre9"><code class="calibre7">express-session</code></li></ol></li>
<li class="calibre9">What is the primary purpose of the <code class="calibre7">"cookie-parser"</code> middleware in an Express.js application?
<ol class="alfa">
<li class="calibre9">To generate random cookies for user sessions.</li>
<li class="calibre9">To parse and handle incoming HTTP requests.</li>
<li class="calibre9">To parse cookies attached to incoming HTTP requests.</li>
<li class="calibre9">To set secure HTTP headers for cookie handling.</li></ol></li>
<li class="calibre9">Which middleware is used for handling Cross-Origin Resource Sharing (CORS) in Express.js applications?
<ol class="alfa">
<li class="calibre9"><code class="calibre7">express-cors</code></li>
<li class="calibre9"><code class="calibre7">cors-express</code></li>
<li class="calibre9"><code class="calibre7">cross-origin</code></li>
<li class="calibre9"><code class="calibre7">cors</code></li></ol></li>
</ol>
<h1 class="sec1" id="s101"><a href="toc.xhtml#s101a" class="calibre6">Answers</a></h1>
<ol class="num">
<li class="calibre9">c</li>
<li class="calibre9">a</li>
<li class="calibre9">d</li>
<li class="calibre9">c</li>
<li class="calibre9">d</li>
<li class="calibre9">b</li>
<li class="calibre9">d</li>
<li class="calibre9">b</li>
<li class="calibre9">c</li>
<li class="calibre9">d</li>
</ol>
<h1 class="sec" id="s102"><a href="toc.xhtml#s102a" class="calibre6">Further Readings</a></h1>
<p class="nonindent"><a href="https://expressjs.com">https://expressjs.com</a></p>
<p class="nonindent"><a href="https://blog.dreamfactory.com/rest-apis-an-overview-of-basic-principles/">https://blog.dreamfactory.com/rest-apis-an-overview-of-basic-principles/</a></p>
<p class="nonindent"><a href="https://restfulapi.net/">https://restfulapi.net/</a></p>

</body></html>