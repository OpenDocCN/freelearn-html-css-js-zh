<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Storage APIs in JavaScript</h1>
                </header>
            
            <article>
                
<p class="mce-root">Imagine you're on Facebook and have logged in to your account. You see your news feed; everything looks normal. Next, you click on a post, and you're made to log in again. That's strange. You continue and log in one more time, and the post opens. You click on a link in a comment, and you're made to log in yet again. What is happening?</p>
<p>That's what would happen if we lived in a world without storage APIs on the frontend.</p>
<p>In this chapter, we'll take a look at the following topics:</p>
<ul>
<li>How the internet works because of cookies</li>
<li>Different forms of data storage areas available in JavaScript</li>
<li>Methods associated with <kbd>localStorage</kbd> and <kbd>sessionStorage</kbd> objects</li>
<li>An introduction to <kbd>indexedDB</kbd></li>
<li>How to use <kbd>indexedDB</kbd> to perform basic adding, deleting, and reading operations</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">HyperText Transfer Protocol (HTTP)</h1>
                </header>
            
            <article>
                
<p>HTTP is a stateless protocol. A stateless protocol means that there is no state being stored on the server, which, in turn, means that the server forgets everything once it has sent a response to the client. Consider the following situation:</p>
<p>You've typed <kbd>http://example.com</kbd> in your browser. When your request hits the server, the server is aware of your IP address, your requested page, and any other headers associated with your HTTP request. It fetches the content from the filesystem or database, sends the response to you, and then forgets about it.</p>
<p>Upon every new HTTP request, the client and server interact as if they're meeting for the first time. So, doesn't that mean our earlier Facebook example is true in the real world as well?</p>
<p>Essentially, that is the case. All websites use <strong>cookies</strong> for authentication purposes, which is a way to fake the statefulness of a protocol. Remove cookies from every request and you will be able to see the raw, stateless HTTP protocol in front of you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What is a TLS/SSL handshake?</h1>
                </header>
            
            <article>
                
<p>Let's take a minute to understand what the <span><strong>Transport Layer Security</strong> (</span><strong>TLS</strong>)/<span><strong>Secure Sockets Layer </strong>(</span><strong>SSL</strong>) is before actually diving into what the heck a handshake is. </p>
<p>First of all, we should note that TLS is just an upgraded, and more modern, version of SSL. So, what's SSL?</p>
<p>SSL is a standard within security protocols for setting up an encrypted and secure tunnel between your computer and the remote server. It prevents somebody who is eavesdropping on your internet connection, say your <strong>Internet Service Provider</strong> (<strong>ISP</strong>), from stealing data that is transferred over the network.</p>
<p>On every major site these days, you will see a green lock to the left of the URL inside the browser. That is a symbol of security, and it means that your browser is using TLS/SSL encryption to communicate with the server.</p>
<p>Now, what is a handshake? Just like the literal meaning, a handshake is where your browser and server exchange the cryptographic keys they'll use in each communication to encrypt or decrypt the messages sent by one another.</p>
<p>Why are we discussing TLS/SSL? It is because TLS/SSL handshakes are expensive on performance. They are not really expensive when there is just one handshake, but they start to become a problem if we introduce the concept of statelessness. This means that your browser and server forget that they already know each other's cryptographic keys with every request. This means that your browser and server need to perform a TLS handshake with every request, which will make everything quite slow. To avoid this, the TLS/SSL protocol is actually a stateful protocol.</p>
<p>The reason why HTTP is so scalable is that it is stateless. Stateful protocols such as TLS and SSL are heavy to implement logically. If you want to know more about how TLS/SSL works, read here: https://security.stackexchange.com/a/20833/44281</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mimicking an HTTP state</h1>
                </header>
            
            <article>
                
<p><span>Using a cookie is a way to store a small amount of data related to a user visiting your site</span>. You'll learn more about cookies in the next section. Whatever you store in cookies on a particular website is attached to every HTTP request to that site. So, basically, your HTTP protocol transfers a string of cookies on every request that allows the server to store some sort of information related to each client connected to it.</p>
<p>When we add custom headers to our <kbd>XMLHttpRequest</kbd> (remember T<em>he</em> <em>Fetch API customizations</em> section from the preceding chapter?), it makes it easy to fake our own state on the HTTP protocol. An authorization header is one more header that is sent by the browser on every request if it is set.</p>
<p>Let's now actually take a look at these storage areas, such as cookies, <kbd>localStorage</kbd>, <kbd>sessionStorage</kbd>, and <kbd>indexedDB</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Storing data with cookies</h1>
                </header>
            
            <article>
                
<p>Cookies are little strings, which, once set for a domain and path, are sent over and over to the server for every request. This is perfect for authentication, but not so good if you're using them to store some data that you need only once or that you need to access only on the frontend, such as a player's score in a game whose results you are not storing on the server.</p>
<p>People usually use cookies to store heavy data to make it available on some other path on the domain. This is a bad practice because you're transferring that data to the server all the time, and, if that data is heavy, it'll make your communication slow.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting cookies</h1>
                </header>
            
            <article>
                
<p>Let's take a look at how to access and set cookies using JavaScript:</p>
<p class="mce-root">Information found within a cookie is in the <kbd>key=value;</kbd><span> format. Let us create some cookies in the browser using the code snippet below:</span></p>
<pre>document.cookie = "myFirstCookie=good;"<br/>document.cookie = "mySecondCookie=great;"<br/>console.log(document.cookie);</pre>
<p><strong>Warning: Strange behavior ahead!</strong></p>
<p>What do you expect to be logged here? The answer is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="64" src="assets/dfc57c9d-6d9e-4bae-9703-6c6ae5c42f4c.png" width="301"/></div>
<p>Why, and why wasn't the <kbd>document.cookie</kbd> object overwritten? All will be explained in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The document.cookie is a strange object</h1>
                </header>
            
            <article>
                
<p>As you saw earlier, <kbd>document.cookie</kbd> shows a special behavior. Instead of replacing all cookies, it updates the variable to the new cookie. This behavior is implemented by a document that is actually called a <strong>host object</strong> instead of a native object. Host objects have the power to do anything, as they don't need to follow the semantics for regular objects.</p>
<p>Host objects are actually the objects provided in a particular environment--in our case, the browser. When JavaScript runs on the server (Node.js), you do not have access to a document or window. That means they're host objects--that is, dependent on hosts and implemented by hosts (browsers).</p>
<p>In this case, <kbd>document.cookie</kbd> overrides the assignment operator to actually append the value to the variable instead of modifying it.</p>
<div class="packt_infobox"><span>More</span> technical information about <kbd>[[PutValue]]</kbd> from the specs can be found at <a href="http://es5.github.io/#x8.7.2">http://es5.github.io/#x8.7.2</a>. </div>
<p>The question is now how do we remove the cookies we set? We'll take a look in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting cookies</h1>
                </header>
            
            <article>
                
<p>To delete a cookie, you return to the cookie and then specify an expiry date for it. After which, the browser will delete the cookie and no longer send it to the server on every request.</p>
<p>Here's how to implement that in code:</p>
<pre>document.cookie = "myFirstCookie=good;"<br/>document.cookie = "mySecondCookie=great;"<br/>console.log(document.cookie);<br/>document.cookie = "mySecondCookie=; expires=Thu, 01 Jan 1970 00:00:00 GMT";<br/>console.log(document.cookie);</pre>
<p><kbd>1 January 1970 00:00:00</kbd> is as far back in time as we can go, as JavaScript follows Unix's timestamp. The output for the preceding code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="98" src="assets/f8928628-f65c-4d1e-9174-3a5a98dd70a0.png" width="480"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a cookie value</h1>
                </header>
            
            <article>
                
<p>JavaScript doesn't provide any convenient way out of the box to actually get a cookie value. All we have is just a bunch of random cookies together in a string, which is accessible by <kbd>document.cookie</kbd>. We will need to do some work, as shown in the following snippet:</p>
<pre>document.cookie = "awesomecookie=yes;";<br/>document.cookie = "ilovecookies=sure;";<br/>document.cookie = "great=yes";<br/><br/>function getCookie(name) {<br/>    const cookies = document.cookie.split(';');<br/>    for(let i=0;i &lt; cookies.length;i++) {<br/>        if(cookies[i].trim().indexOf(name) === 0) {<br/>            return cookies[i].split('=')[1];<br/>        }<br/>    }<br/>    return null;<br/>}<br/><br/>console.log(getCookie("ilovecookies"));<br/>console.log(getCookie("doesnotexist"));</pre>
<p>The output will be, therefore, as follows:</p>
<pre><strong>sure</strong><br/><strong>null</strong></pre>
<p>As you can see in the highlighted part of the image below, when we reload the page, the set cookies are sent to the server at every request:</p>
<div class="CDPAlignCenter CDPAlign"><img height="197" src="assets/f837637f-0e47-4107-9058-0015e37a2284.png" width="402"/></div>
<p>These will later become accessible by the server, depending on the backend language you're using.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with localStorage</h1>
                </header>
            
            <article>
                
<p>The <kbd>localStorage</kbd> object is available in all major browsers. It was introduced in HTML5. Local storage allows you to store data persistently on a user's computer. Unless your script or user explicitly want to clear the data, the data will remain.</p>
<p>Local storage follows the same origin policy. We will discuss origin policy in detail in the next chapter, but, for now, just understand that the same origin policies can restrict different websites and their access to a particular website's local storage. </p>
<p>In addition, keep in mind that key-value pairs in local storage can only be string values. To store objects, you'll have to <kbd>JSON.stringify</kbd> them first.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a local storage entry</h1>
                </header>
            
            <article>
                
<p>We can add entries to local storage in a more intuitive and convenient way than cookies. Here's what the syntax looks like using <kbd>localStorage.setItem(key, value)</kbd>:</p>
<pre>localStorage.setItem('myKey', 'awesome value');<br/>console.log('entry added');</pre>
<div class="packt_infobox">The <kbd>localStorage</kbd> is a synchronous API. It'll block the thread execution until completed.</div>
<p>Let's now quickly, and roughly, determine how much time on average <kbd>localStorage.setItem</kbd> takes, as follows:</p>
<pre>const now = performance.now();<br/><br/>for(let i=0;i&lt;1000;i++) {<br/>    localStorage.setItem(`myKey${i}`, `myValue${i}`);<br/>}<br/><br/>const then = performance.now();<br/>console.log('Done')<br/>console.log(`Time taken: ${(then - now)/1000} milliseconds per operation`);</pre>
<p>The result, as you can see, is not that bad:</p>
<div class="CDPAlignCenter CDPAlign"><img height="48" src="assets/28972abb-1380-4ba0-b5ec-5293ac906dec.png" width="472"/></div>
<p>So, it roughly takes around <kbd>0.02</kbd> milliseconds for one operation. That's good going for a regular application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a stored item</h1>
                </header>
            
            <article>
                
<p>A stored item inside a session storage object can be accessed using the<span> </span><kbd>localStorage.getItem</kbd><span>, </span><span> </span><kbd>localStorage.key</kbd><span>, </span>or<span> </span><kbd>localStorage['key']</kbd><span> </span>methods. We'll take a look at this in more detail a little later, in the <kbd>localStorage.getItem('key')</kbd> versus <kbd>localStorage.key</kbd><span> section,</span> where we'll see which method is the best and why not to use other methods; now, though, let's stick with the <kbd>localStorage.getItem</kbd> method.</p>
<p>It's easy to get stored items from local storage, as shown in the following snippet:</p>
<pre>const item = localStorage.getItem('myKey');<br/>console.log(item); // my awesome value</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing a stored item</h1>
                </header>
            
            <article>
                
<p>You can remove a single item from the <kbd>localStorage</kbd> object. For this, you will need to have the key of the key-value pair you want to remove. This could be anything you no longer need.</p>
<p>Accessing it further in your code will result in<span> </span><kbd>null</kbd>, as follows:</p>
<pre>localStorage.removeItem('myKey');<br/>console.log(localStorage.getItem('myKey')); // null</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clearing all the items</h1>
                </header>
            
            <article>
                
<p><span>Sometimes, you might find while experimenting that you've put a lot of useless key-value pairs inside your storage. You can clear them all at once with the </span><kbd>clear</kbd><span> method in local storage. You can do that with the following command:</span></p>
<pre>localStorage.clear();<br/>console.log(localStorage); // blank object {}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">localStorage.getItem('key') versus localStorage.key versus localStorage['key']</h1>
                </header>
            
            <article>
                
<p><span>A</span>ll three, <kbd>localStorage.getItem('key')</kbd>, <kbd>localStorage.key</kbd>, and <kbd>localStorage['key']</kbd> methods, do the same thing. However, it is advisable to use the provided methods for the following reasons:</p>
<ul>
<li><kbd>localStorage.getItem('key-does-not-exist')</kbd> returns <kbd>null</kbd>, whereas <kbd>localStorage['key-does-not-exist']</kbd> will return <kbd>undefined</kbd>. In JavaScript, <kbd>null</kbd> is not equal to <kbd>undefined</kbd>. <span> For example, s</span>uppose that you want to set a key that is actually the property of an object as well, or as a function name, such as <kbd>getItem</kbd> and <kbd>setItem</kbd>. In this case, you're better off with the <kbd>getItem</kbd> approach, as follows:
<pre>localStorage.setItem('getItem', 'whohoo we are not overwriting getItem'); // #1<br/>localStorage.getItem('getItem'); // whohoo we are not overwriting getItem<br/><br/>localStorage.getItem = 'oh no I'm screwed'; // #2 <br/>localStorage.getItem('getItem'); // Error! getItem is not a function.</pre></li>
<li>If you accidentally used the notation <kbd>#2</kbd> instead of <kbd>#1</kbd> to store a number, <kbd>localStorage</kbd> will  overwrite the <kbd>getItem</kbd> function, and you will no longer be able to access it, as shown in the following snippet:<br/>
<pre>localStorage.setItem('length', 100); // Stores "1" as string in localStorage<br/>localStorage.length = 100; // Ignored by localStorage</pre></li>
</ul>
<p style="padding-left: 60px">The takeaway here is to use the <kbd>getItem</kbd>, <kbd>setItem</kbd>, and other methods on <kbd>localStorage</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with SessionStorage</h1>
                </header>
            
            <article>
                
<p>Session storage is just like local storage, with the exception that session storage is not persistent. That means whenever you close even the tab that sets the session storage, your data will be lost.</p>
<p>A case where session storage could be useful could be when you have an Ajax-based website that loads everything dynamically. You want to create a state-like object, which you can use to store the state of the interface so that, when a user returns to a page they have already visited, you can easily restore the state of that page.</p>
<p>Let's now quickly go over all the methods of session storage.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a session storage entry</h1>
                </header>
            
            <article>
                
<p>To create a key-value pair inside the <kbd>sessionStorage</kbd> object, you can use the <kbd>setItem</kbd> method, similar to the <kbd>localStorage</kbd> object. Just like <kbd>localStorage</kbd>, <kbd>sessionStorage</kbd> is also a synchronous API, so you can be sure that you'll immediately have access to whatever values you're storing.</p>
<p>Adding an item to session storage is just like working with local storage, as shown in the following snippet:</p>
<pre>sessionStorage.setItem('my key', 'awesome value');<br/>console.log('Added to session storage');</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting a stored item</h1>
                </header>
            
            <article>
                
<p>A stored item inside the <kbd>sessionStorage</kbd> object can be accessed using the <kbd>sessionStorage.getItem</kbd>,  <kbd>sessionStorage.key</kbd>, or <kbd>sessionStorage['key']</kbd> methods. However, as with <kbd>localStorage</kbd>,  it is advisable to make use of <kbd>getItem</kbd> to safely get the right storage value instead of a property of the <kbd>sessionStorage</kbd> object. </p>
<p>The following snippet demonstrates how to get a stored item from session storage:</p>
<pre>const item = sessionStorage.getItem('myKey');<br/>console.log(item); // my awesome value</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing a stored item</h1>
                </header>
            
            <article>
                
<p>You can remove a single item from the <kbd>sessionStorage</kbd> object. For this, you will need to have the key of the key-value pair you want to remove. This could be anything you no longer need.</p>
<p>Accessing it further in your code will result in <kbd>null</kbd>, as shown in the following snippet:</p>
<pre>sessionStorage.removeItem('myKey');<br/>console.log(sessionStorage.getItem('myKey')); // null</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clearing all items</h1>
                </header>
            
            <article>
                
<p>Sometimes, you might find while experimenting that you've put a lot of useless key-value pairs inside your storage. You can clear them all at once with the <kbd>clear</kbd> method in session storage, as shown in the following snippet:</p>
<pre>sessionStorage.clear();<br/>console.log(sessionStorage); // blank object {}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling storage changes across multiple tabs</h1>
                </header>
            
            <article>
                
<p>Storage, when changed, emits certain events that can be captured by other opened tabs. You can set event listeners for them to listen and perform any appropriate modifications.</p>
<p>For example, let's say that you added something to <kbd>localStorage</kbd> in one tab of your website. A user has also opened another tab of your website. If you want to reflect the changes of <kbd>localStorage</kbd> in that tab, you can listen to the storage event and update the contents accordingly.</p>
<p>Note that the update event will be fired on every other tab except the one that made the change:</p>
<pre class="brush: js line-numbers language-js">window.addEventListener('storage', e =&gt; { <br/>  console.log(e);<br/>});<br/>localStorage.setItem('myKey', 'myValue'); // note that this line was run in another tab</pre>
<p>The preceding code produces the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9a1d606d-b132-464b-95cf-a355a338d1db.png"/></div>
<p>You can note that it contains a lot of useful information about the storage event.</p>
<div class="packt_infobox">The web workers (discussed in Chapter 11) do not have access to local storage or session storage.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Cookies versus local storage</h1>
                </header>
            
            <article>
                
<p>By now, you may have observed that cookies and local storage serve almost completely different purposes. The only thing they have in common is that they store data. The following is a brief comparison of cookies and local storage:</p>
<table>
<tbody>
<tr>
<td><strong>Cookies</strong></td>
<td><strong>Local</strong> <strong>storage</strong></td>
</tr>
<tr>
<td>Cookies are transferred to a server on every request automatically by the browser</td>
<td>To transfer local storage data to a server, you need to manually send an Ajax request or send it through hidden form fields</td>
</tr>
<tr>
<td>If data needs to be accessed and read both by the client and server, use cookies</td>
<td>If the data needs to be accessed and read only by the client, use local storage</td>
</tr>
<tr>
<td>Cookies can have an expiration date, after which they are automatically deleted</td>
<td>Local storage provides no such expiration date feature; it can only be cleared by JavaScript</td>
</tr>
<tr>
<td>The maximum size of a cookie is 4 KB</td>
<td>The maximum size of local storage depends on the browser and platform, but it is usually around 5 MB per domain</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The indexedDB - storing large data</h1>
                </header>
            
            <article>
                
<p>The <kbd>indexedDB</kbd> is a relatively new and low-level API compared to the other storage mediums we've already discussed. It is used to store large amounts of data compared to local storage. However, the drawback of this is that it is difficult to be used and set up.</p>
<p>What you can do with local storage in a few lines may take a lot of lines and callbacks in <kbd>indexedDB</kbd>. Therefore, be careful when using it. If you're using it in your application, we recommend that you use popular wrappers instead of directly writing the endpoints, as that will make things easier.</p>
<p>The <kbd>indexedDB</kbd> is so vast that it would be fair to say it deserves a whole chapter on its own. We can't cover each and every aspect in this chapter, but we'll try to convey the key information required.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Opening an indexedDB database</h1>
                </header>
            
            <article>
                
<p>The <kbd>indexedDB</kbd> object is available on the <kbd>window</kbd> object. You will need to actually open a database in order to store data in <kbd>indexedDB</kbd>, shown as follows:</p>
<pre>const open = window.indexedDB.open("myDB", 1);</pre>
<p>You have to first request to open the database from <kbd>indexedDB</kbd>. The first parameter here is the name of your database. If it doesn't exist, it'll be created automatically.</p>
<p>The second parameter is the version number of the database. What that means is that you can assign a version number to every database schema, which is useful in the following example.</p>
<p><span>Consider that you shipped your application that is using</span> <kbd>indexedDB</kbd><span>. Now,</span> <kbd>indexedDB</kbd> <span>consists of a database schema, which lays down certain rules on how the data should look in the database, its data types, and so on. However, you soon realize that you need to update your database design. Now, you can ship your production code with  </span><kbd>indexedDB.open</kbd><span>, but with a higher version. This further enables you to know within your code that your older database schema may be incompatible with the new one.</span></p>
<p>If the database already existed and you opened it with a higher version number (say 2, in our case), then it'll fire the <span><kbd>upgradeneeded</kbd> event, which you can handle in the code.</span></p>
<div class="packt_tip packt_infobox">Version numbers only supports integers. Any floating number passed will be rounded off to the closest lower integer. For example, passing 2.3 as a version number is the same as passing 2.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Handling the upgradeneeded event</h1>
                </header>
            
            <article>
                
<p>As discussed previously, we can now handle the <kbd>upgradeneeded</kbd> event. As we have just created the database for the first time, the following <kbd>upgradeneeded</kbd> event will be fired:</p>
<pre>const open = window.indexedDB.open("types", 1);<br/><br/>// Let us create a schema for the database<br/>open.onupgradeneeded = () =&gt; {<br/>    const dbHandler = open.result;<br/>    const storeHandler = dbHandler.createObjectStore("frontend");<br/>};</pre>
<p>Okay, in the preceding code, we got the <kbd>IDBDatabase</kbd> object handler, which we call  <kbd>dbHandler</kbd>, by calling <kbd>open.result</kbd>.</p>
<p>Then, we created something called an object store in <kbd>indexedDB</kbd>. Object stores are like tables in <kbd>indexedDB</kbd>, where the data is stored in the form of key-value pairs. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding data to object stores</h1>
                </header>
            
            <article>
                
<p><span>We can use  </span><kbd>storeHandler</kbd><span> to actually put data inside a table with the following code:</span></p>
<pre>const open = window.indexedDB.open("types", 1);<br/><br/>open.onupgradeneeded = () =&gt; {<br/>    const dbHandler = open.result;<br/>    const storeHandler = dbHandler.createObjectStore("frontend");<br/>    storeHandler.add({<br/>        latestVersion: 5,<br/>        cool: "yes",<br/>        easy2use: "yes"<br/>    }, "HTML5");<br/>};</pre>
<p>Let's take a moment to understand what just happened. By calling <kbd>storeHandler.add()</kbd>, we were able to add data to our <kbd>frontend</kbd> table inside our <kbd>types</kbd> database (version 1). The first argument--that is, our passed object--is the value, which can be an object in <kbd>indexedDB</kbd>. Values can only be strings in <kbd>localStorage</kbd>. The second argument--that is, <kbd>HTML5</kbd>--is the name of our key.</p>
<p>The result should look like the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="234" src="assets/c64b446b-e55c-44a9-a186-b3c01f784f75.png" width="504"/></div>
<p>In the preceding screenshot, you should be able to see the <kbd>indexedDB</kbd>, <kbd>types</kbd> database, and then a table called <kbd>frontend</kbd> that stores the key as <kbd>HTML5</kbd> and the value as our supplied object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Reading data from object stores</h1>
                </header>
            
            <article>
                
<p>Whenever a connection is established, the <kbd>onsuccess</kbd> event is fired. Only read-write operations in the <kbd>onupgradeneeded</kbd> work because it won't be fired if the version number of the database is not increased.</p>
<p>As a matter of fact, we recommend changing the database schema from the <kbd>onupgradeneeded</kbd> event. When you're in <kbd>onsuccess</kbd>, perform <span>only </span>the CRUD operations (which are Create, Update, <span>Retrieve, </span>and Delete).</p>
<p>We can do our operations inside the <kbd>success</kbd> event with the following code:</p>
<pre>const open = window.indexedDB.open("types", 1); // same database as above<br/>open.onsuccess = () =&gt; {<br/>    const dbHandler = open.result;<br/>    const transaction = dbHandler.transaction(['frontend'], 'readonly');<br/>    const storeHandler = transaction.objectStore('frontend');<br/>    const req = storeHandler.get("HTML5");<br/>    req.onsuccess = e =&gt; {<br/>        console.log(e.target.result);<br/>    }<br/>};</pre>
<p>The output of the program is as follows:</p>
<pre><strong>{latestVersion: 5, cool: "yes", easy2use: "yes"}</strong></pre>
<p>The result is exactly the same as the data we stored earlier, but what are the transactions? They are as follows:</p>
<ul>
<li>The <kbd>indexedDB</kbd> uses transactions to perform reading and writing over the database</li>
<li>We first open a transaction to our database <kbd>frontend</kbd> in the <kbd>readonly</kbd> mode; the other mode is the <kbd>readwrite</kbd> mode, which is used when you want to write to the database as well</li>
<li>From that transaction, we then get <kbd>storeHandler</kbd>, which is the same as the store handler we had in an earlier section when we created the store</li>
<li>Now, we make use of the <kbd>get</kbd> method to get the value associated with the key we stored</li>
<li>We then wait for <kbd>req</kbd> to call the <kbd>success</kbd> event, on which we console log the target result value, which is nothing but our stored object</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deleting data from object stores</h1>
                </header>
            
            <article>
                
<p>Similar to writing and reading, we can also delete data from the object store, as well, as follows:</p>
<pre>const open = window.indexedDB.open("types", 1); // same database as above<br/>open.onsuccess = () =&gt; {<br/>    const dbHandler = open.result;<br/>    const transaction = dbHandler.transaction(['frontend'], 'readwrite');<br/>    const storeHandler = transaction.objectStore('frontend');<br/>    storeHandler.delete("HTML5");<br/>};</pre>
<p>The only thing we did here was using the <kbd>delete</kbd> method. Note that we have to give the <kbd>readwrite</kbd> access to the transaction in order to delete the record.</p>
<div class="packt_infobox">It's recommended that you go through MDN documents to get a deeper insight on how to make <kbd>indexedDB</kbd> work in big projects; you can find them at <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB">https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Great! That's one more concept we've now equipped ourselves with. In this chapter, you learned how to store data on the client side effectively, and how cookies are sent automatically to the server by browsers. In the next two chapters, we will dive deep into web workers and shared memory, which can create some very powerful stuff when combined together. Let's go!</p>


            </article>

            
        </section>
    </body></html>