<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Applying Advanced Service Worker Cache Strategies</h1>
                
            
            <article>
                
<p class="calibre2">It's time to take our progressive web app capabilities up a notch. So far, you have learned how to add to the home screen experience, core service worker concepts, and how to make your site secure. In this chapter, we will dive into advanced service worker concepts and a brand new progressive web app, PWA tickets.</p>
<p class="calibre2">The following topics will be covered in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">What is PWA tickets?</li>
<li class="calibre11">How to run a local, mock API server</li>
<li class="calibre11">PWA application architecture</li>
<li class="calibre11">Importing utility libraries to a service worker</li>
<li class="calibre11">A service worker response manager</li>
<li class="calibre11">Advanced caching strategies and techniques</li>
<li class="calibre11">Caching invalidation techniques</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is PWA tickets?</h1>
                
            
            <article>
                
<p class="calibre2">The PWA tickets application is an example hosted service application designed to resemble an online ticket purchasing solution. While there are many aspects of this application I could have focused on, this book focuses on the consumer app.</p>
<p class="calibre2">The following screenshot is the PWA ticket home page, which displays a list of cards for upcoming events that the customer can purchase tickets for. Card refers to the UI metaphor that is used to style the block representing items in a list:</p>
<div class="cdpaligncenter"><img src="../images/00091.jpeg" class="calibre105"/></div>
<p class="calibre2">A real ticket service application would be a suite of apps including an administrative application and an app for ushers to validate tickets. For this book, I will focus on the consumer client experience.</p>
<p class="calibre2">The consumer version of the application features user login, profile management, access to a list of future events, the ability to buy tickets, and the user's ticket purchase history.</p>
<p class="calibre2">The application itself consists of a live API and static web pages, but the real area of focus for this chapter is some of the advanced service worker concepts.</p>
<p class="calibre2">The service worker evaluates each <kbd class="calibre12">fetch</kbd> request and processes it differently. The service worker pre-caches critical assets, but also defines custom rules for different routes.</p>
<p class="calibre2">Another new advanced concept is the idea of cache invalidation. This is where you define a rule that applies to cached responses and determines if a network request should be made and the cache invalidated. This is an important concept to understand because it gives you full control over your applications, caching rules and allows you to manage how much is stored in the cache.</p>
<p class="calibre2">The PWA tickets application will demonstrate some new concepts and tactics, which will help you create professional progressive web apps, such as the following:</p>
<ul class="calibre10">
<li class="calibre11">Service worker templating</li>
<li class="calibre11">Cache invalidation</li>
<li class="calibre11">Triggering different cache strategies based on a requested URL</li>
<li class="calibre11">Using <kbd class="calibre12">importScripts</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reviewing the PWA ticket application</h1>
                
            
            <article>
                
<p class="calibre2">Let's take look at the different sections that our application will consist of. There are eight main page areas of the application:</p>
<ul class="calibre10">
<li class="calibre11">Home</li>
<li class="calibre11">User Profile</li>
<li class="calibre11">Events</li>
<li class="calibre11">Tickets</li>
<li class="calibre11">Cart</li>
<li class="calibre11">Contact</li>
<li class="calibre11">Configure</li>
<li class="calibre11">Login</li>
</ul>
<p class="calibre2">Tickets and events both consist of two pages: one for a list and another for an item detail. The application also features our first pages, which make POST requests to an API rather than just a GET request. This introduces a new <kbd class="calibre12">fetch</kbd> method that our service worker must handle correctly</p>
<p class="calibre2">The homepage lists 10 future events, followed by a list of user purchased tickets. Each item utilizes a card, which is styled using the bootstrap card classes. Each ticket card also has a button to show the item's details.</p>
<p class="calibre2">The user profile page list the user's contact information and some of their most recently purchased tickets. It also features a button to update the user profile. This will toggle the view from read-only to edit mode.</p>
<p class="calibre2">The application's navigation consists of <span class="calibre5">Events</span>, <span class="calibre5">Tickets</span>, <span class="calibre5">Profile</span>, <span class="calibre5">Logout</span>, and a <span class="calibre5">Search</span> field:</p>
<div class="cdpaligncenter"><img src="../images/00092.jpeg" class="calibre106"/></div>
<p class="calibre2">A user can enter a search term and whatever page they are on will automatically update to show any matching events without making a round trip to load a new page. It does this by making an AJAX call and rendering the results in the browser and service worker.</p>
<p class="calibre2">The application's API is not representative of a production quality search feature, but serves our purpose. It will match any event that contains the phrase entered in the search box.</p>
<p class="calibre2">The events page will list all future events that are available in the system. Again, each event is a card with a button to view the event's details. The event's details page shows a little more information and includes a list of tickets that are available to purchase:</p>
<div class="cdpaligncenter"><img src="../images/00093.jpeg" class="calibre107"/></div>
<p class="calibre2">A true ticket service app would offer a more sophisticated way to find tickets, but I wanted to keep this simple for demonstration purposes.</p>
<p class="calibre2">When a user buys a ticket, they must confirm the purchase and then it is added to their profile</p>
<p class="calibre2">Selecting the <span class="calibre5">tickets</span> link in the <span class="calibre5">Now</span> bar takes the user to a list of their purchased tickets. From here, they can view the details of any ticket, which includes a QR code. The QR code is meant to simulate what modern E-ticket solutions use for ushers and gate agents to scan when you enter a venue or when you need to find your seat:</p>
<div class="cdpaligncenter"><img src="../images/00094.jpeg" class="calibre108"/></div>
<p class="calibre2">This is where the usher's app would come into play. They could use their phone to scan the QR code to confirm the ticket and allow the customer into the venue.</p>
<p class="calibre2">There is also a contact page where a user could submit a message to the system administrators. It is mostly used to demonstrate how to handle post messages using fetch and the service worker.</p>
<p class="calibre2">Finally, the entire application requires a user to be authenticated. Each page does a quick verification if the user is logged in, and if not, loads the login page:</p>
<div class="cdpaligncenter"><img src="../images/00095.jpeg" class="calibre109"/></div>
<p class="calibre2">The user logs in by entering a username and password. The credentials are sent to the API for verification. The API returns the user's profile, which simulates an authentication token. The authentication token is persisted and <kbd class="calibre12">IndexedDB</kbd> (using <kbd class="calibre12">localForage</kbd>), and verified before each page load.</p>
<p class="calibre2">The user does not yet have a profile they can select. They can use the create new profile link and add themselves to the system.</p>
<p class="calibre2">The following function is the application's API call to log a user into the application:</p>
<pre class="calibre17">   login: function (credentials) { 
          return fetch(api + 
               "users/?userName=" + 
                credentials.username + 
                "password=" + credentials.password) 
                .then(function (response) { 
 
                if (response.ok) { 
                      return response.json() 
                      .then(function (token) { 
                       if (token.length &gt; 0) { 
                              return saveAuthToken(token[0]); 
                             } 
                           });</pre>
<p class="calibre2"/>
<p class="calibre2"/>
<pre class="calibre17">                     } else { 
                     throw "user tickets fetch failed"; 
                    } 
                 }); 
        } </pre>
<p class="calibre2">Notice that the username and password are passed to the API using the <kbd class="calibre12">queryString</kbd>. I would not do this normally, but I needed a way to work with json-server and it did not seem to offer a way to match without a custom function using a POST.</p>
<p class="calibre2">You would not want to do this in production because it exposes credentials. When posting the credentials as part of the request body, they are shielded behind HTTPS.</p>
<p class="calibre2">The PWA ticket application includes a minimal feature set, which I feel will help demonstrate the concepts covered in the last three chapters. This introduction to how the application works does not quite cover everything. I invite you to clone the source code (<a href="https://github.com/docluv/pwa-ticket" target="_blank" class="calibre9">https://github.com/docluv/pwa-ticket</a>) and run it locally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the JSON server for an API</h1>
                
            
            <article>
                
<p class="calibre2">When you build modern applications, the frontend almost always communicates with an API to interact with a date source. The API is the gateway to the backend application and can be consumed by any client application, such as a Progressive Web App.</p>
<p class="calibre2">Developing against an API can be rather tricky when you don't want to develop the entire API first. In the podcast application, we simply loaded a pre-rendered JSON to simulate an API. The podcast application only made a GET request and did not do any post requests or attempts to update the underlying data model.</p>
<p class="calibre2">The PWA ticket application does make post requests and attempts to update the underlying data model, but rather than building out an entire infrastructure for this, I found a nice solution: json-server (<a href="https://github.com/typicode/json-server" target="_blank" class="calibre9">https://github.com/typicode/json-server</a>). This is a node module that works much like the http-server we used for the previous applications.</p>
<p class="calibre2">The real advantage of json-server is its built-in ability to create a fully functioning API based on a JSON data model. You must install the module like any other node module: by using <kbd class="calibre12">npm install</kbd> and including a reference to it in your <kbd class="calibre12">packages.json</kbd> file.</p>
<p class="calibre2">Before you execute the server, you must create a data source. This is just another JSON file. Rather than manually creating the data and the data model, I chose to write a script that uses the faker module (<a href="https://github.com/marak/Faker.js/" target="_blank" class="calibre9">https://github.com/marak/Faker.js/</a>). This can also be installed using the standard NPM tasks.</p>
<p class="calibre2">faker is a pretty cool node module that allows you to dynamically generate massive amounts of fake data for you to build your application around. This is one of the more troubling aspects of front and web development in my opinion, because you need large amounts of data to validate your application logic. However, that takes a long time to create. Faker eliminates this problem.</p>
<p class="calibre2">Combining json-server and faker together allows you to create a very complex and deep API and data source. You can emulate just about every aspect of your potential API and backend with these two modules.</p>
<p class="calibre2">As I created the PWA ticket application, I modified the data model numerous times trying to get things just right. Rather than hand coding all of the data, I was able to write a script to rebuild the database from scratch.</p>
<p class="calibre2">The project source repository includes a top-level folder called <kbd class="calibre12">utils</kbd>. In this folder, there are a couple of scripts: one to generate fake data and another to render the pages. The fake data script utilizes a combination of faker and some fixed data sources.</p>
<p class="calibre2">Faker has the capability to generate data of all kinds, including images. However, I found the images that it generates and uses to be a slow, random image generation service. Rather than rely on those images, I chose to fix a small set of 8 venue images and 8 headshot images. The 16 images are stored under the website's <kbd class="calibre12">img</kbd> folder.</p>
<p class="calibre2">You will also notice a method to generate QR codes. This is also done with a pair of node modules: one to generate a QR code image and another to save that image to disk.</p>
<p class="calibre2">A QR code is generated for each ticket and represents the ticket's unique identifier. Each barcode image that is generated is saved to the website in the barcodes folder. Each barcode image is a <kbd class="calibre12">.gif</kbd> file and has the extension appended to its name.</p>
<p class="calibre2">While these node modules are critical to running the PWA ticket application, they are not directly related to service workers and progressive web apps. I do want to take a little time to explain how they work so that you can use the source code locally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Making a database and the API</h1>
                
            
            <article>
                
<p class="calibre2">The JSON server allows you to host a local REST API by supporting basic CRUD operations without writing any code. The node module works by reading a source file with a complete JSON object. The PWA ticket app relies on a JSON data structure, which is outlined here:</p>
<pre class="calibre17">{ 
    tickets: [], 
    users: [], 
    futureEvents: [], 
    pastEvents: [], 
    contact: [] 
} </pre>
<p class="calibre2">You can configure the data source to include methods to return data based on supplied parameters. I chose not to do this in order to keep things simple. Hence, this explains the use of both the <kbd class="calibre12">futureEvents</kbd> and <kbd class="calibre12">pastEvents</kbd> arrays instead of creating these lists on demand.</p>
<p class="calibre2">To execute <kbd class="calibre12">json-server</kbd>, run the command-line utility with the <kbd class="calibre12">--watch</kbd> switch. The watch switch causes <kbd class="calibre12">json-server</kbd> to update when the source data file updates:</p>
<pre class="calibre17"><strong class="calibre1">json-server --watch db.json</strong> </pre>
<p class="calibre2">The PWA ticket source code has the <kbd class="calibre12">db.json</kbd> data source file in the root folder. The server creates RESTful end points that map to the names of the top-level objects. It also doubles as a static file server. You just need to watch out for overlapping paths between the objects in the data file and pages.</p>
<p class="calibre2">I ran into a scenario where I duplicated routes in the same site using <kbd class="calibre12">json-server</kbd> while creating this demonstration application. This forced me to run two instances of the web server: one for the API and one for the website.</p>
<p class="calibre2">For localhost-based servers, you can specify different port numbers to run multiple local servers. You can define the port number by adding the <kbd class="calibre12">-port</kbd> switch to the command-line interface:</p>
<pre class="calibre17"><strong class="calibre1">json-server --watch db.json -port 15501</strong> </pre>
<p class="calibre2">I ran into some frustration trying to launch a static web server-only instance, so I chose to launch the API using <kbd class="calibre12">json-server</kbd> and the static website using <kbd class="calibre12">http-server</kbd>.</p>
<p class="calibre2">You can run both local web servers from a command line, one console instance each, since they are running a server:</p>
<pre class="calibre17"><strong class="calibre1">&gt;npm run api-server 
&gt;npm run web-server</strong> </pre>
<p class="calibre2">Another advantage of running the API server on a different port is that it helps emulate cross-domain access, or CORS.</p>
<div class="packt_infobox">CORS stands for <strong class="calibre110">cross origin resource sharing</strong> and was created to allow browsers to more securely request resources on external domains. It relies on the browser using extra headers to manage access to the external resource, typically via AJAX.</div>
<div class="packt_infobox">CORS-specific headers are added by the server to tell the browser which domains are allowed to access the resource.</div>
<p class="calibre2">To retrieve the data, you can load a URI that corresponds to the API server and the name of the object:</p>
<pre class="calibre17">http://localhost:15501/users/</pre>
<p class="calibre2">This example URL returns an array of user objects:</p>
<pre class="calibre17">[ 
  { 
    "id": "891ad435-41f3-4b83-929b-18d8870a53a4", 
    "firstName": "Catharine", 
    "lastName": "Cormier", 
    "mugshot": "avtar-2.jpg", 
    "userName": "Clay.Parker", 
    "password": "93gQtXaB0Tc3JM5", 
    "streetAddress": "401 Kassulke Square", 
    "city": "Cronintown", 
    "state": "Vermont", 
    "zipCode": "09904-5827", 
    "email": "Bradly_Fahey56@gmail.com", 
    "phoneNumber": "400.748.9656 x0600", 
    "tickets": [...] 
  }, {...} 
] </pre>
<p class="calibre2">There are more advanced features available with json-server, but this should be enough for you to understand how to run the site locally.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using faker</h1>
                
            
            <article>
                
<p class="calibre2">Before you can host the API using json-server, you need the source data file. This is where the faker module is helpful. Creating enough data for a realistic test environment has always been one of my top challenges. Today, it seems like there are libraries or tools like faker available for most platforms.</p>
<p class="calibre2">Since I use Node.js for the majority of my projects, faker stands out as a powerful tool. It just requires a script to generate the data. This script is in the <kbd class="calibre12">/utils</kbd> folder, <kbd class="calibre12">generate-fake-data.js</kbd>:</p>
<div class="cdpaligncenter"><img src="../images/00096.jpeg" class="calibre111"/></div>
<p class="calibre2">This script helped me not only generate the file data set, but also allowed me to continually modify the source data as the overall model evolved.</p>
<p class="calibre2">This script generates a random number of users, events, and tickets, and maps them randomly together to create a complete database.</p>
<p class="calibre2">I won't go into all of the details of possible data types available from <kbd class="calibre12">faker</kbd>. This is how the script generates a new user:</p>
<pre class="calibre17">    let user = { 
        "id": faker.random.uuid(), 
        "firstName": faker.name.firstName(), 
        "lastName": faker.name.lastName(), 
        "mugshot": mugshots[mugshot], 
        "userName": faker.internet.userName(), 
        "password": faker.internet.password(), 
        "streetAddress": faker.address.streetAddress(), 
        "city": faker.address.city(), 
        "state": faker.address.state(), 
        "zipCode": faker.address.zipCode(), 
        "email": faker.internet.email(), 
        "phoneNumber": faker.phone.phoneNumber() 
    } </pre>
<p class="calibre2">The <kbd class="calibre12">faker</kbd> object has different top-level data types with various methods to generate properly formatted, random data.</p>
<p class="calibre2">The data values generated by faker are in the correct or expected format. I love some of the text values it generates. I encourage you to read through some of them because they create some rather humorous values and combinations! For example, <em class="calibre13">Generic Plastic Cheese</em>.</p>
<p class="calibre2">The script is self-contained and will create a fresh database each time it runs. Plus, when you launch json-server using the <kbd class="calibre12">-watch</kbd> switch, the API will automatically update for the new data.</p>
<p class="calibre2">The next aspect of the database remains: QR codes!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Generating QR codes</h1>
                
            
            <article>
                
<p class="calibre2">Modern ticketing solutions are more about barcodes and QR codes than the physical ticket. To create a life-like ticket application, I needed to create custom QR codes for each ticket. Again, a pair of node modules made this very straightforward: <kbd class="calibre12">qr-encode</kbd> (<a href="http://cryptocoinjs.com/modules/misc/qr-encode/" target="_blank" class="calibre9">http://cryptocoinjs.com/modules/misc/qr-encode/</a>) and <kbd class="calibre12">ba64</kbd><strong class="calibre4"> </strong>(<a href="https://www.npmjs.com/package/ba64" target="_blank" class="calibre9">https://www.npmjs.com/package/ba64</a>).</p>
<p class="calibre2">qr-encode converts strings into one of a variety of QR code options. The following code shows you how to use the <kbd class="calibre12">qr</kbd> method to generate <kbd class="calibre12">dataURI</kbd>:</p>
<pre class="calibre17">    let dataURI = qr(id, { 
        type: 6, 
        size: 6, 
        level: 'Q' 
    }); </pre>
<p class="calibre2">The <kbd class="calibre12">qr</kbd> method returns a <kbd class="calibre12">base64</kbd> encoded data buffer. You still need to convert this into a physical file. This is where <kbd class="calibre12">ba64</kbd> helps. It converts the <kbd class="calibre12">base64</kbd> encoded buffer into a file:</p>
<pre class="calibre17">ba64.writeImageSync(qrCodePath + "/" + id, dataURI); </pre>
<p class="calibre2">The <kbd class="calibre12">qrCodePath</kbd> points the local path to the <kbd class="calibre12">public/qrcodes</kbd> folder. The script will delete the existing QR image file and create the new QR codes as each ticket is generate:</p>
<div class="cdpaligncenter"><img src="../images/00097.jpeg" class="calibre112"/></div>
<p class="calibre2">The QR code encodes the ticket's unique identifier, which is a GUID generated by faker. This ensures that each ticket can be identified by scanning the QR code.</p>
<p class="calibre2">Now that the data is generated, and we have a way to serve both the API and website, we just need one more thing: the website.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Rendering the website</h1>
                
            
            <article>
                
<p class="calibre2">The 2048 and Podstr apps were based on static websites. While the Podstr app used some dynamically rendered pages, most of it was pre-rendered. It also had a script to create the HTML pages, but this was not as integral to the demonstration as the PWA ticket application.</p>
<p class="calibre2">The PWA ticket application has a script to render the core pages by combining an app shell and the individual pages markup for the actual page. This is handy because it allows you to update the app shell and the pages independently as well as customize the rendering script for different environments.</p>
<p class="calibre2">For example, before deploying to production, you will want to bundle and minify some style sheets and scripts. As you will see in the next chapter, you will also want to reduce the assets, such as styles using tooling.</p>
<p class="calibre2">The source markup files are in the site's HTML folders, <kbd class="calibre12">/public/html</kbd> and <kbd class="calibre12">/public/html/pages</kbd>, respectively. The rendering script loops over these files and loads a corresponding data file defining page-specific configuration data:</p>
<pre class="calibre17">{ 
    "name": "events", 
    "slug": "events", 
    "scripts": ["js/app/pages/events.js"], 
    "css": [] 
} </pre>
<p class="calibre2">The PWA ticket application has some simple configuration objects. The properties are used to define components in each page, like the route or folder to save the final rendered file to. These properties are used in the rendering pipeline to produce the final page based on a common template.</p>
<p class="calibre2">The script is run from the command line:</p>
<pre class="calibre17"><strong class="calibre1">&gt;node render-public</strong> </pre>
<p class="calibre2">The console will log each page as it is rendered.</p>
<p class="calibre2">The PWA ticket application is more advanced than the Podstr app because most of the pages are rendered on the client, not as a full static website. The reason the ticket application relies on client-side rendering is due to each page being tied to the user's profile and ticket purchase.</p>
<p class="calibre2">This chapter will explore these scenarios and how the service worker can enhance the overall experience.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The PWA ticket rendering architecture and logic</h1>
                
            
            <article>
                
<p class="calibre2">We introduced the concept of an app shell earlier in this book. As a quick recap, this is where the application uses a common markup file to manage the common <kbd class="calibre12">HEAD</kbd> and layout features. This shell is then combined with individual pages to compose each page.</p>
<p class="calibre2">The concept has a mass adoption due to the recent rise of single page applications. Progressive web apps can benefit from this concept, but do not need to rely on rendering the markup in the UI thread.</p>
<p class="calibre2">Instead, the markup can be rendered in the service worker. The technique is similar: it uses <kbd class="calibre12">Mustache</kbd>, a JavaScript template library, to merge the data into the markup template. The rendered page markup is returned to the client. I will review the code for this later in this chapter.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">This technique is the practical application of the final caching strategy, <em class="calibre13">Service Worker Templating</em>, which was discussed in the <a target="_blank" href="part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 7</a>, <em class="calibre13">Service Worker Caching Patterns</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The PWA ticket JavaScript architecture</h1>
                
            
            <article>
                
<p class="calibre2">Similar to the Podstr application, the PWA ticket app utilizes a combination of third-party libraries and application-specific JavaScript.</p>
<p class="calibre2">The following screenshot shows how the JavaScript files are organized in the source code:</p>
<div class="cdpaligncenter"><img src="../images/00098.jpeg" class="calibre113"/></div>
<p class="calibre2">The custom service worker logic or workflow utilizes different libraries to render content on the client. The two third-party libraries are <kbd class="calibre12">localForage</kbd> for <kbd class="calibre12">IndexedDB</kbd> interactions and <kbd class="calibre12">Mustache</kbd> to render markup.</p>
<p class="calibre2"><kbd class="calibre12">localForage</kbd> (<a href="https://localforage.github.io/localForage/" target="_blank" class="calibre9">https://localforage.github.io/localForage/</a>) is another <kbd class="calibre12">IndexedDB</kbd> wrapper. It provides a simple interface that mimics <kbd class="calibre12">localStorage</kbd>. The main difference is that <kbd class="calibre12">localForage</kbd> supports promises, making it asynchronous.</p>
<p class="calibre2">There are three <kbd class="calibre12">polyfils</kbd>, and these are <kbd class="calibre12">Object.assign</kbd>, <kbd class="calibre12">Promise</kbd>, and <kbd class="calibre12">Fetch</kbd>.</p>
<p class="calibre2">Each page uses a few application-specific libraries: <kbd class="calibre12">api</kbd> and <kbd class="calibre12">push-mgr</kbd>, and common application modules. Each page has a page-specific script to drive the user experience.</p>
<p class="calibre2">The application module handles the common UI components, which are hamburger menu toggle, logout, search, and authentication validation. It also registers the service worker and manages the push notifications at a high level.</p>
<p class="calibre2">Because the common user interface is simple, I combined these components in single script to keep things simpler to manage. Notice that there is no reference to jQuery or more complex frameworks to drive the UI. The entire app script is roughly 200 lines of nicely spaced code. Individual page scripts are much shorter, so there is not a lot of application-specific code.</p>
<p class="calibre2">The <kbd class="calibre12">api.js</kbd> file is a module that contains methods to interact with the application's API. Because the application is small, I placed all the methods in a single module. For a more complex application, you would want to refactor to separate modules to make the code easier to maintain:</p>
<pre class="calibre17">var pwaTicketAPI = (function () { 
 
    var api = "http://localhost:15501/", 
        authToken = "auth-token"; 
 
    function saveAuthToken(token) { 
 
        return localforage.setItem(authToken, token) 
            .then(function () { 
                return token; 
            }); 
     }</pre>
<pre class="calibre17">    return { 
      //API wrapper methods go here 
    }; 
 
})(); </pre>
<p class="calibre2">This method creates a global variable, <kbd class="calibre12">pwaTicketAPI</kbd>, which can be accessed by individual page controller modules to interact with the API.</p>
<p class="calibre2">Each method wraps a fetch call to an API endpoint:</p>
<pre class="calibre17">getUser: function (userId) { 
 
    return fetch(api + "users/" + userId) 
        .then(function (response) { 
 
            if (response.ok) { <br class="title-page-name"/>               return response.json();  
            } else { 
 
                throw "user tickets fetch failed"; 
            } 
        }); 
}, </pre>
<p class="calibre2">Most of the API methods make GET requests, but a few make POST requests to update or create new records:</p>
<pre class="calibre17">updateUser: function (user) { 
 
    return fetch({ 
        "method": "POST", 
        "Content-Type": "application/json", 
        "body": JSON.stringify(user), 
        "url": api + "users/" 
    }); 
}, </pre>
<p class="calibre2">Each page controller uses an <strong class="calibre4">Immediately Invoked Function Expression</strong> (<strong class="calibre4">IIFE</strong>) to isolate the page logic from the global scope:</p>
<pre class="calibre17">(function () { 
 
//no need to render if service workers are supported 
//unless the service worker is not in control of the page yet. 
//test if the loader element exists. If so then fetch the data to //render 
if (_d.qs(".loader")) { <br class="title-page-name"/>        pwaTicketAPI.loadTemplate("templates/event.html") 
       .then(function (template) { 
 
         if (template) {                        <br class="title-page-name"/>           pwaTicketAPI.getEvent(pwaTickets.getParameterByName("id")) 
            .then(function (event) { 
 
         var target = _d.qs(".content-target"); 
 
         target.innerHTML = Mustache.render(template, event); 
           }); 
            } 
            }) 
            .catch(function (err) { 
               console.log(err); 
         }); 
    } 
})(); </pre>
<p class="calibre2">Each of the pages follows a common pattern of retrieving data from the API and rendering markup to build the page. Most pages have a placeholder with a spinning disc. This is replaced when the markup is rendered:</p>
<pre class="calibre17">&lt;div class="loader"&gt;&lt;/div&gt; </pre>
<p class="calibre2">The main app-shell has a main element with the <kbd class="calibre12">content-target</kbd> class. This class name is used as a reference to select the element and set the inner HTML with the dynamically rendered text:</p>
<pre class="calibre17">    &lt;main class="page-content content-target"&gt; 
        &lt;%template%&gt; 
    &lt;/main&gt; </pre>
<p class="calibre2">You should have noticed how I used <kbd class="calibre12">_d.qs()</kbd> to select the target element. This is a simple utility object that I created to eliminate the need to write <kbd class="calibre12">document.querySelector()</kbd> and the related selector methods. I don't know about you, but I get tired of typing that out everywhere and it's sort of long for the simplicity of jQuery's selector syntax:</p>
<pre class="calibre17">var _d = { 
    qs: function (s) { 
        return document.querySelector(s); 
    }, 
    qsa: function (s) { 
        return document.querySelectorAll(s); 
    }, 
    gei: function (s) { 
        return document.getElementById(s); 
    }, 
    gen: function (s) { 
        return document.getElementsByName(s); 
    } 
}; </pre>
<p class="calibre2">This utility provides a simple shorthand to select elements, but without the overhead of jQuery.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The PWA ticket service worker architecture</h1>
                
            
            <article>
                
<p class="calibre2">The 2048 and Podstr apps have relied on a single script. The PWA ticket app uses more complex techniques like importing libraries to drive the logic.</p>
<p class="calibre2">Service workers can load external scripts using the <kbd class="calibre12">importScripts</kbd> method. This function is available in the global scope and accepts an array of URLs. These are additional scripts and work much like the node.js <kbd class="calibre12">require</kbd> system:</p>
<pre class="calibre17">self.importScripts("js/libs/localforage.min.js", 
    "js/app/libs/api.js",  
    "sw/response-mgr.js",  
    "sw/push-mgr.js", 
    "sw/invalidation-mgr.js",  
    "sw/date-mgr.js" 
); </pre>
<p class="calibre2">The first two scripts are also used in the client code. <kbd class="calibre12">localForage</kbd> is an <kbd class="calibre12">IndexedDB</kbd> wrapper and the API script manages access to the API and authentication token. The <kbd class="calibre12">Mustache</kbd> library file is imported in the <kbd class="calibre12">ResponseManager</kbd> module and I will cover how it is used later.</p>
<p class="calibre2">The remaining scripts are common service worker libraries to help with caching strategies, such as cache invalidation and push management. Each service worker library contains a JavaScript class with methods to manage an aspect of the cache strategy and life cycle.</p>
<p class="calibre2">Importing scripts is a great way to refactor your service worker logic into smaller units that can be reused and easier to maintain. I have reviewed several service workers that were over 10,000 lines of code. Any time you have a large code file, you tend to introduce unwanted maintenance issues.</p>
<p class="calibre2">The first problem large code files create is navigating the code. Even with modern development environments and nice keyboard shortcuts, it is very easy to get lost in the code. If you have ever wasted time looking for functions and coordinating variables, you know what this is like.</p>
<p class="calibre2">Another common problem is managing team access to the code. When you have two or more developers with their hands in a single file, this introduces too many opportunities for code merges. Code merging is one of my least favorite developer activities, especially when someone else wrote the other version.</p>
<p class="calibre2">The last problem I see when large files are created is no code reuse. When you refactor your code into smaller modules, not only are they focused on a single responsibility, the classes, modules, and so on, can be reused in other areas of the application or across different applications.</p>
<p class="calibre2">This is why I like importing scripts in service workers. The 2048 service worker was very simple and did not warrant this tactic. The Podstr app could use the <kbd class="calibre12">importScripts</kbd> capabilities, but I chose to save this till now. For a true production version of Podstr, I would have to refactor the code to import different scripts.</p>
<p class="calibre2">One drawback of importing scripts to your service worker is regarding updating the scripts. They are not updated when the service worker is updated. Unfortunately, I am still not clear on when these files will update from the server. I have read references saying that the imported scripts should following normal browser cache or cache-control invalidation, and others claimed that this is not working as expected.</p>
<p class="calibre2">There are some open discussions about this problem in the specification chats, but at this point, I think a true solution has not been adopted.</p>
<p class="calibre2">Either way, during development, this issue can be very frustrating. You need to update these files frequently as you update the code. The best way I have found to force these files to update is to manually unregister the service worker.</p>
<p class="calibre2">After unregistering the service worker, reloading the page registers the service worker again and it will execute the <kbd class="calibre12">importScripts</kbd> method.</p>
<p class="calibre2">There is one <em class="calibre13">bug</em> with this technique that I am currently seeing in the Chrome developer tools, and this is that each unregistered service worker leaves its footprint in the tools:</p>
<div class="cdpaligncenter"><img src="../images/00099.gif" class="calibre114"/></div>
<p class="calibre2">You can close the tools to reset the service worker panel. If you can tolerate scrolling down to the current, active service worker, you can avoid this step. I think this is just an issue with the developer tools UI not properly refreshing when a service worker is unregistered manually.</p>
<p class="calibre2"><kbd class="calibre12">importScripts</kbd> can also be used in any script that is imported by the service worker. In fact, the service worker's global scope is available to these scripts. Any variable declared in the service worker's global scope is available in the scripts. This also refers to any objects exported from the other imported scripts.</p>
<p class="calibre2">The node request system is similar to the <kbd class="calibre12">importScript</kbd> method. They both load external scripts to create methods and objects you can use in your script, which in this case is the service worker.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The ResponseManager</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">ResponseManager</kbd> contains common logic that correlates to some of the caching strategies covered in <a target="_blank" href="part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 7</a>, <em class="calibre13">Service Worker Caching Patterns</em>. The <kbd class="calibre12">ResponseManager</kbd> class contains a condensed set of cache strategies and the corresponding methods for five caching strategies:</p>
<ul class="calibre10">
<li class="calibre11">Cache only</li>
<li class="calibre11">Network only</li>
<li class="calibre11">Cache falling back to network</li>
<li class="calibre11">Cache falling back to network and caching response</li>
<li class="calibre11">Cache falling back to network, render result, and cache</li>
</ul>
<p class="calibre2">This is the <kbd class="calibre12">ResponseManager</kbd> class definition with method signatures:</p>
<pre class="calibre17"> 
class ResponseManager { 
   fetchText(url) {...} 
   fetchJSON(url) {...} 
   fetchAndRenderResponseCache(options) {...} 
   cacheFallingBackToNetwork(request, cacheName) {...} 
   cacheFallingBackToNetworkCache(request, cacheName) {...} 
   cacheOnly(request, cacheName) {...} 
   networkOnly(request) {...} 
 
} </pre>
<p class="calibre2">The <kbd class="calibre12">cacheOnly</kbd> and <kbd class="calibre12">networkOnly</kbd> method do exactly what their name implies, returning a response either from just the cache or just the network:</p>
<pre class="calibre17">cacheOnly(request, cacheName) { 
    return caches.match(request); 
} 
<br class="title-page-name"/> 
networkOnly(request) { 
    return fetch(request); 
}</pre>
<p class="calibre2"><kbd class="calibre12">cacheFallingBackToNetwork</kbd> checks if a response has been cached and if not, makes a network request to fetch the response. The response is not cached.</p>
<p class="calibre2"><kbd class="calibre12">cacheFallingBackToNetworkCache</kbd> repeats that logic, but caches the network response.</p>
<p class="calibre2">There are two additional helper methods, which are <kbd class="calibre12">fetchText</kbd> and <kbd class="calibre12">fetchJson</kbd>. These two methods specifically help the render result strategy to retrieve HTML templates and fetch JSON from the API.</p>
<p class="calibre2"><kbd class="calibre12">fetchText</kbd> is used to retrieve HTML files. <kbd class="calibre12">fetchJSON</kbd> makes an API call to get data. The <kbd class="calibre12">fetchAndRenderCache</kbd> method utilizes a supplied option parameter to execute the API call.</p>
<p class="calibre2">I covered the core concepts around these caching strategies in previous chapters. However, I do want to review the <kbd class="calibre12">fetchAndRenderCache</kbd> strategy because it was not covered in detail.</p>
<p class="calibre2">The goal of this strategy is to dynamically render a response in the service worker and cache the rendered result for the next request. This works great in applications like the PWA ticket app, which are highly dynamic.</p>
<p class="calibre2">While you could pre-render all the HTML pages on the server for any app, it may not be as efficient or cost-effective as rendering on demand. In the past, we have relied on run-time rendering systems such as ASP.NET, PHP, and so on, on the server and large single page app frameworks on the client.</p>
<p class="calibre2">It does not matter how you render the markup; the process is always the same. You merge data with a markup template. The engine you are using utilizes some sort of merge field syntax and replaces those fields with the matching values in the source data.</p>
<p class="calibre2">I prefer to use <kbd class="calibre12">Mustache</kbd> (<a href="http://mustache.github.io/" target="_blank" class="calibre9">http://mustache.github.io/</a>) because the syntax is relatively simple:</p>
<pre class="calibre17">&lt;div class="card ticket-card" id="{{id}}"&gt; 
    &lt;div class="card-header"&gt; 
        &lt;h5 class="card-title"&gt;{{event.title}}&lt;/h5&gt; 
    &lt;/div&gt; 
    &lt;div class="row"&gt; 
        &lt;div class="col-md-6 text-center"&gt; 
            &lt;img class="card-img-top ticket-barcode" <br class="title-page-name"/>           src="qrcodes/{{barcode}}"  <br class="title-page-name"/>             alt="{{id}}" /&gt; 
        &lt;/div&gt; 
        &lt;div class="col-md-6"&gt; 
            &lt;div class="card-body"&gt; 
                &lt;p class="card-text"&gt;{{event.venue}}&lt;/p&gt; 
                &lt;p class="card-text"&gt;{{event.date}} - {{event.city}} <br class="title-page-name"/>                {{event.state}}&lt;/p&gt; 
                &lt;p class="card-text"&gt;{{id}}&lt;/p&gt; 
            &lt;/div&gt; 
            &lt;ul class="list-group list-group-flush"&gt; 
                &lt;li class="list-group-item"&gt;Section {{section}}&lt;/li&gt; 
                &lt;li class="list-group-item"&gt;Row {{row}}&lt;/li&gt; 
                &lt;li class="list-group-item"&gt;Seat {{seat}}&lt;/li&gt; 
            &lt;/ul&gt; 
        &lt;/div&gt; 
    &lt;/div&gt; 
&lt;/div&gt; </pre>
<p class="calibre2"><kbd class="calibre12">Mustache</kbd> gets its name from the use of two curly braces to denote the merge field. The render method will merge a JSON object's properties with the matching field name. It can do single records or create a repeated list using the same template. It also supports basic <kbd class="calibre12">if...else</kbd> logic and a few other features.</p>
<p class="calibre2">The PWA ticket application uses <kbd class="calibre12">Mustache</kbd> templates for most pages, both for single records and lists. The application templates are stored in the <kbd class="calibre12">/templates</kbd> folder:</p>
<div class="cdpaligncenter"><img src="../images/00100.jpeg" class="calibre115"/></div>
<p class="calibre2">The JavaScript <kbd class="calibre12">Mustache</kbd> library can be used on the client or as a node module. I use it on both the server and client in many applications. It's great because you can make a single template and use it anywhere in the application and not worry about the rendering library being different.</p>
<p class="calibre2">If you are following any of the mainstream JavaScript frameworks, they all have mature server-side rendering components. I think this is an important trend because these frameworks have caused a lot of performance issues and made many sites impossible to index in search engines.</p>
<p class="calibre2">The rise of these server-side components should give these frameworks a longer lifespan and help them to produce better quality user experiences by moving their heavy logic to the server. This is also good since so many developers have invested many hours learning their proprietary syntaxes.</p>
<p class="calibre2">The <kbd class="calibre12">fetchAndRenderResponseCache</kbd> method executes service worker level run-time rendering. It accepts an options parameter that contains different properties which are required to drive the strategy.</p>
<p class="calibre2">I highly recommend pairing this method with a call to cache to see if the response is available. The <kbd class="calibre12">ResponseManager</kbd> has a <kbd class="calibre12">cacheOnly</kbd> method you can utilize:</p>
<pre class="calibre17">responseManager.cacheOnly(request, runtimeCache) 
  .then(response =&gt; { 
   return response ||  
             responseManager.fetchAndRenderResponseCache({...}); 
}); </pre>
<p class="calibre2">The method uses a JavaScript object as its only parameter. It should have the following properties:</p>
<pre class="calibre17">{ 
    request: //the request that triggered the fetch 
    pageURL: "url to core page html", 
    template: "url to the data template", 
    api: //a method to execute that makes the API call, 
    cacheName: "cache name to save the rendered response" 
} </pre>
<p class="calibre2">These values are used to drive the logic and make it flexible enough to be reused by different pages and components in any application:</p>
<pre class="calibre17">fetchAndRenderResponseCache(options) { 
    return fetchText(options.pageURL) 
        .then(pageHTML =&gt; { 
            return fetchText(options.template) 
                .then(template =&gt; { 
                    return pageHTML.replace(/&lt;%template%&gt;/g, template); 
                }); 
        }) </pre>
<p class="calibre2">The first step in the sequence is to retrieve the page's HTML. This is done by passing the <kbd class="calibre12">pageURL</kbd> value to the <kbd class="calibre12">fetchText</kbd> method. This should resolve the page's core HTML.</p>
<p class="calibre2">Next, the template is fetched using the same method. This time, the resolved template HTML is injected in the <kbd class="calibre12">pageHTML</kbd>. It does this be replacing a custom token, <kbd class="calibre12">/&lt;%template%&gt;/g</kbd>, in the HTML page. Again, this is to make the page template more flexible. You could prerender the entire page with the template included.</p>
<p class="calibre2">I do this because I want the application to be able to fallback to using classic client-side rendering if service workers are not supported.</p>
<p class="calibre2">At this point, you should have the page's full HTML, short of rendering with the data. The following step retrieves the data from the API using the supplied method. This method should return a promise, which means you can just return the fetch you use to call the API:</p>
<pre class="calibre17">        .then(pageTemplate =&gt; { 
            return options.api() 
                .then(data =&gt; { 
                    return Mustache.render(pageTemplate, data); 
                }); </pre>
<p class="calibre2">The API method should resolve the response to JSON. The data is then rendered with the <kbd class="calibre12">pageTemplate</kbd> using the <kbd class="calibre12">Mustache.render</kbd> method. This creates the final HTML we want!</p>
<p class="calibre2">Now for some cool magic. The logic creates a new <kbd class="calibre12">Response</kbd> object and clones it. The clone is saved to the named cache and the new response is returned so that it can be rendered for the user:</p>
<pre class="calibre17"> 
        }).then(html =&gt; { 
 
            //make custom response 
            let response = new Response(html, { 
                    headers: { 
                        'content-type': 'text/html' 
                    } 
                }), 
                copy = response.clone(); 
 
            caches.open(options.cacheName) 
                .then(cache =&gt; { 
                    cache.put(options.request, copy); 
                }); 
 
            return response; 
 
        }); 
} </pre>
<p class="calibre2">This may seem like a lot of work, but it can be done pretty quickly assuming that the call to the API is fast. I do recommend pre-caching the page and the data template markup ahead of time. The pre-cache is a good place to do this.</p>
<p class="calibre2">You might also consider caching these responses in a special template cache so that you can apply appropriate invalidation rules to ensure that they do not become too stale.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the request method to determine the caching strategy</h1>
                
            
            <article>
                
<p class="calibre2">One of the magical aspects of HTTP is its use of different properties to trigger actions. The HTTP method provides a descriptive way to trigger a response. There are a variety of possible HTTP methods, with PUT, GET, POST, and DELETE being the most common methods.</p>
<p class="calibre2">Those methods correspond to <strong class="calibre4">create</strong>, <strong class="calibre4">retrieve</strong>, <strong class="calibre4">update</strong>, and <strong class="calibre4">delete</strong> (<strong class="calibre4">CRUD</strong>) actions. Cache is a powerful tool to make your application respond faster, but not all responses should be cached. The HTTP method can be a primary signal to trigger an appropriate caching strategy.</p>
<p class="calibre2">The first two applications, 2048 and Podstr, use only GET requests. The PWA ticket application utilizes POST methods, which should not be cached. When a user registers, <em class="calibre13">buys</em> a ticket, updates their profile, or submits a contact request, a POST request is made to the API.</p>
<p class="calibre2">The API response is typically used to determine success or some sort of failure state. These responses should not be cached. If they were, your request might not be sent to the server:</p>
<pre class="calibre17">if (!responseManager.isResponseNotFound(response)  
    request.method.toUpperCase() === "GET"  
    request.url.indexOf("chrome-extension") === -1  
    responseManager.isResponseCacheable(response)) { 
 
    //cache response here 
} </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Matching routes with caching strategies</h1>
                
            
            <article>
                
<p class="calibre2">Utilizing different caching strategies involves some way of triggering specific strategies for different response types or routes. The more complex your application is, the more potential routes and media types you may need to manage.</p>
<p class="calibre2">This can be done by defining an array of rules driven by URL routes. I recommend using regular expressions to match routes, especially when the route has a common base with a large variety options. A good example would be an e-commerce site's product details page. This could be a URL to a pre-rendered page or might involve a <kbd class="calibre12">QueryString</kbd> value.</p>
<p class="calibre2">For the PWA tickets application, I am demonstrating how to define a dynamic route for event details using a regular expression and another for the QR code images.</p>
<p class="calibre2">A QR code request triggers the cache falling back to the network and then cache the response pattern. An event request triggers the service worker rendering strategy. This involves an extra property with values to drive the strategy:</p>
<pre class="calibre17">routeRules = [ 
{ 
    "url": /event?/, 
    "strategy": "fetchAndRenderResponseCache", 
    "options": {...}, 
    "cacheName": eventsCacheName 
},  
{ 
    "url": /qrcodes?/, 
    "strategy": "cacheFallingBackToNetworkCache", 
    "cacheName": qrCodesCacheName 
}  
]; </pre>
<p class="calibre2">Instead of having a complex fetch event handler, you should refactor the logic to a separate method. Pass the event object to your handler:</p>
<pre class="calibre17">self.addEventListener("fetch", event =&gt; { 
    event.respondWith( 
        handleResponse(event) 
    ); 
});</pre>
<p class="calibre2">The magic happens by testing the requested URL against the array of rules. This is done by testing the URL against each one of the rules <kbd class="calibre12">url</kbd> values. This testing is done using JavaScript's regular expression <kbd class="calibre12">test()</kbd> method:</p>
<pre class="calibre17">function testRequestRule(url, rules) { 
 
    for (let i = 0; i &lt; rules.length - 1; i++) { 
 
        if (rules[i].route.test(url)) { 
            return rules[i]; 
        } 
    } 
} </pre>
<p class="calibre2">This method returns the matching rule object. If no matching rule has been defined, you can coalesce the rule value to an empty object:</p>
<pre class="calibre17">function handleResponse(event) { 
 
    let cacheName = getCacheName(event.request.url); 
    let rule = testRequestRule(event.request.url, routeRules); 
 
    rule = rule || {}; 
 
    switch(rule.strategy){ 
       // 
    } 
} </pre>
<p class="calibre2">After identifying a matching rule, the strategy can be executed using a JavaScript switch statement. The <kbd class="calibre12">responseManager</kbd> has the logic for each strategy. Make sure you pass the <kbd class="calibre12">request</kbd> object and the target <kbd class="calibre12">cacheName</kbd>:</p>
<pre class="calibre17">    case "cacheFallingBackToNetwork": 
 
        return responseManager.cacheFallingBackToNetworkCache(event.request, <br class="title-page-name"/>        cacheName); 
 
        break; </pre>
<p class="calibre2">I like to make the cache falling back to the network caching the response my default strategy. By stacking this strategy in the case expression, the code only needs to be included once:</p>
<pre class="calibre17">    case "cacheFallingBackToNetworkCache": 
    default: 
         return   <br class="title-page-name"/>        responseManager.cacheFallingBackToNetworkCache(event.request, <br class="title-page-name"/>        cacheName) 
            .then(response =&gt; { 
 
                invalidationManager.cacheCleanUp(cacheName); 
                return response; 
 
            }); 
 
        break; </pre>
<p class="calibre2">This approach relies on configuring routes and their corresponding caching strategy. This is similar to the WorkBox approach. I will explore Workbox, a node module to help you scaffold complex service workers, in the next chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Cache invalidation strategies</h1>
                
            
            <article>
                
<p class="calibre2">Just like there are caching strategies, there are cache invalidation strategies you can employ to keep your cache from getting out of control. The PWA tickets application uses a maximum items strategy to control how many responses are cached, but there are other strategies you can use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Unique hash names and long time-to-live values</h1>
                
            
            <article>
                
<p class="calibre2">A popular technique to make updating assets easier with long time to live values is using hash values in the file name. This is because a hash which is generated based on the file's contents means that the algorithm generates a relatively unique value.</p>
<p class="calibre2">The unique name creates a new URL for the asset and assigns a new Cache-Control value to the asset. This works well with style sheets, scripts and images, and other static resources.</p>
<p class="calibre2">MD5 hash values are the most common way to create these unique values. Node.js has a built-in <kbd class="calibre12">crypto</kbd> module with MD5 hash capabilities:</p>
<pre class="calibre17">function getHash(data) { 
    var md5 = crypto.createHash('md5'); 
    md5.update(data); 
 
    return md5.digest('hex'); 
} </pre>
<p class="calibre2">The data parameter is the contents of the file. For a style sheet or script, it is the data is the text in the file. The digest is a unique value you can use to name the file:</p>
<div class="cdpaligncenter"><img src="../images/00101.gif" class="calibre116"/></div>
<p class="calibre2">This technique works great, but requires a somewhat complicated build process to update file names in all the referencing files. I don't encourage this technique for a local development environment, but for production, this is a very powerful cache busting technique. Just keep in mind that you need to update references in all HTML files and potentially in your service worker or other files that may reference these unique file names.</p>
<p class="calibre2">I think this might be a bit complex for many sites, especially without a formal system underlying the site that supports this technique. It's best if the hash technique is transparent to the developer and more or less automatic.</p>
<p class="calibre2">Unfortunately, this is not common today. There are other techniques you can utilize that provide more granular control and possibly more control over how much data you cache. The following techniques can be used in your service worker to manage how long responses are cached.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Maximum items in a cache</h1>
                
            
            <article>
                
<p class="calibre2">A simpler cache invalidation strategy is limiting the number of items persisted. I call this <strong class="calibre4">Maximum Item Invalidation</strong>.</p>
<p class="calibre2">This requires service worker logic to check how many items are saved in a specifically named cache. If the cache has saved the maximum number of responses, at least one response is removed before adding a new item.</p>
<p class="calibre2">This strategy requires multiple named caches, which correlate to different types of responses. Each named cache can have a different item limit assigned to manage the different types of responses. You can also assign a difference cache invalidation strategy, which will be discussed shortly.</p>
<p class="calibre2">The ticket application has named caches for events, which are dynamically rendered as they are requested. I arbitrarily chose a limit of 20 events to make it easier to demonstrate the strategy. It also has a QR code named cache with a limit of five responses, again, somewhat arbitrary.</p>
<p class="calibre2">You will need to choose an appropriate value for your application and types of responses. Remember, your storage quota is a combination all the different storage mediums and varies by device and capacities.</p>
<p class="calibre2">I typically use more liberal values for text responses and smaller values for binary files like images. Until you know how your site is used by your customers, you may need to adjust this value.</p>
<p class="calibre2">If you managed a site like Amazon.com, you would have access to data that tells you how many products a user visits in an average session. So, maybe you make sure you can cache that many product pages and associated images. I would probably cache most of their watch list products and everything in their shopping cart.</p>
<p class="calibre2">Every site and application is different, and within those sites there are unique page and data types that need a varied cache limit:</p>
<pre class="calibre17">    maxItems(options) { 
 
        self.caches.open(options.cacheName) 
            .then((cache) =&gt; { 
 
                cache.keys().then((keys) =&gt; { 
 
                    if (keys.length &gt; options.strategyOptions.max) { 
 
                        let purge = keys.length - <br class="title-page-name"/>                        options.strategyOptions.max; 
 
                        for (let i = 0; i &lt; purge; i++) { 
                            cache.delete(keys[i]); 
                        } 
 
                    } 
 
                }); 
            }); 
    } </pre>
<p class="calibre2">Just like there is not a magic number of total items you should cap a named cache capacity, not all caches should be limited by a maximum number of items. You should also consider limiting based on time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Purging stale responses using time to live</h1>
                
            
            <article>
                
<p class="calibre2">The next cache invalidation strategy is based on how long a response can be cached. If you don't have access to the Cache-Control header, it may be challenging to determine how long to cache the response.</p>
<p class="calibre2">The good news is that the Cache-Control header is not the only way to determine a response's cache lifespan. When responses are added to a named cache, a <kbd class="calibre12">"date"</kbd> value is added. You can use the cached date value to apply a timeout rule to the cached responses:</p>
<pre class="calibre17">let responseDate = new Date(response.headers.get("date")), 
  currentDate = Date.now(); 
 
if(!DateManager.compareDates(currentDate,  
  DateManager.addSecondsToDate(responseDate, 300))) { 
    cache.add(request); 
}else{ 
    cache.delete(request); 
} </pre>
<p class="calibre2">When a cached response becomes stale, you can delete it. The next time the asset is requested, the default caching strategy triggers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Executing ResponseManager</h1>
                
            
            <article>
                
<p class="calibre2">Instead of writing a complex routine to fetch and cache a response directly in the service worker's <kbd class="calibre12">fetch</kbd> event handler, you can use the <kbd class="calibre12">ResponseManager</kbd>. Because the caching strategy logic is contained within the module, you can pass the request and <kbd class="calibre12">cacheName</kbd> to have it execute:</p>
<pre class="calibre17">self.addEventListener("fetch", event =&gt; { 
 
    let cacheName = getCacheName(event.request.url); 
 
    event.respondWith( 
 
        responseManager.cacheFallingBackToNetworkCache(event.request, <br class="title-page-name"/>        cacheName) 
        .then(response =&gt; { 
     
          invalidationManager.cacheCleanUp(cacheName); 
     
          return response;     
        })     
    ); 
}); </pre>
<p class="calibre2">In this example, the response is returned as a result of the promise chain. It also executes the cache's <kbd class="calibre12">InvalidatationManager.cacheCleanUp</kbd> method to make sure that the cache does not contain too many items or stale items.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The Invalidation Manager</h1>
                
            
            <article>
                
<p class="calibre2">The Invalidation Manager is a special module that handles implementing the maximum items and time to live invalidation strategies. The script is imported to the service worker using the <kbd class="calibre12">importScripts</kbd> method:</p>
<pre class="calibre17">invalidationManager = new InvalidationManager([{ 
        "cacheName": preCache, 
        "invalidationStrategy": "ttl", 
        "strategyOptions": { 
          "ttl": 604800 //1 week }<br class="title-page-name"/>         },<br class="title-page-name"/>        { "cacheName": qrCodesCacheName,<br class="title-page-name"/>          "invalidationStrategy": "maxItems",<br class="title-page-name"/>          "strategyOptions": { "max": 10 }<br class="title-page-name"/>        }]);</pre>
<p class="calibre2">This module has a method called <kbd class="calibre12">cacheCleanup</kbd>, which loops over the set of invalidation rules that are supplied in the constructor, as shown earlier. As it loops through the rules, it executes each strategy against a named cache. The invalidation rules are defined when the class is instantiated by passing an array of rules.</p>
<p class="calibre2">The class can process two invalidation strategies, which are <kbd class="calibre12">maxItems</kbd> and <kbd class="calibre12">ttl</kbd> (time to live). Each item in the rules array is an object defining the named cache, the strategy to apply to the cache, and the options for the strategy.</p>
<p class="calibre2">The <kbd class="calibre12">ttl</kbd> <kbd class="calibre12">strategyOptions</kbd> is the maximum time frame a cached item can remain cached. In the preceding example, the <kbd class="calibre12">preCached</kbd> items can remain for a week before they will be purged. Once they are purged, a network request is made, which updates the asset.</p>
<p class="calibre2">The <kbd class="calibre12">maxItems</kbd> <kbd class="calibre12">strategyOptions</kbd> has a <kbd class="calibre12">max</kbd> property, which defines the maximum number of cached items a named cache can persist. In this example, I chose an arbitrarily low number of 10 items to help demonstrate the principle.</p>
<p class="calibre2">The <kbd class="calibre12">strategyOptions</kbd> property is an object, even though right now there are only single properties for each strategy. By using an object, it allows additional properties to be added later and for potential future strategies to have different property options:</p>
<pre class="calibre17">cacheCleanUp() { 
     let invMgr = this; 
     invMgr.invalidationRules.forEach((value) =&gt; { 
         switch (value.invalidationStrategy) { 
             case "ttl": 
                 invMgr.updateStaleEntries(value); 
                 break; 

            case "maxItems": 
                 invMgr.maxItems(value); 
                break; 
             default: 
                 break; 
        } 
    }); 
} </pre>
<p class="calibre2">The <kbd class="calibre12">cacheCleanUp</kbd> method can be invoked at any time. It is always executed when a new <kbd class="calibre12">InvalidationManger</kbd> is created, or when your service worker first wakes up.</p>
<p class="calibre2">This may not be good enough for your application. You could periodically execute this method based on a timer or after items are cached.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">maxItems strategy</h1>
                
            
            <article>
                
<p class="calibre2">The <kbd class="calibre12">maxItems</kbd> strategy limits how many items can be stored in a named cache. It works by opening the named cache, and then retrieving an array of requests using the keys method.</p>
<p class="calibre2">The routine then compares the number of stored items (<kbd class="calibre12">keys.length</kbd>) to the maximum number of items allowed in this cache. If there are more items than the quota, the number of items exceeding the quota is calculated.</p>
<p class="calibre2">A <kbd class="calibre12">for</kbd> loop is then executed to delete the first item from the cache and repeats until the number of items to purge have been deleted:</p>
<pre class="calibre17">maxItems(options) { 
 
    self.caches.open(options.cacheName) 
        .then(cache =&gt; { 
 
            cache.keys().then(keys =&gt; { 
 
                if (keys.length &gt; options.strategyOptions.max) { 
 
                    let purge = keys.length - <br class="title-page-name"/>                    options.strategyOptions.max; 
 
                    for (let i = 0; i &lt; purge; i++) { 
                        cache.delete(keys[i]); 
                    } 
 
                } 
 
            }); 
        }); 
} </pre>
<p class="calibre2">You may be wondering why you could not use the Array <kbd class="calibre12">pop</kbd> or <kbd class="calibre12">slice</kbd> methods to remove the cache items. This is because caches do not provide an array interface, and thus there are no native array methods.</p>
<p class="calibre2">Instead, you must create a loop or custom routine to individually delete cached items.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The time-to-live invalidation strategy</h1>
                
            
            <article>
                
<p class="calibre2">Like the <kbd class="calibre12">maxItems</kbd> strategy, the <kbd class="calibre12">updateStaleEntries</kbd> strategy opens a reference to the named cache and gets a list of the cached requests. This time, individual requests must be retrieved from the cache.</p>
<p class="calibre2">This requires calling the cache's match method by passing a request object (key). This will return the stored response with a <kbd class="calibre12">date</kbd> header. This is added when the item is added to the cache and can be used to determine if the response is stale:</p>
<pre class="calibre17">updateStaleEntries(rule) { 
 
    self.caches.open(rule.cacheName) 
        .then(cache =&gt; { 
 
            cache.keys().then(keys =&gt; { 
 
                keys.forEach((request, index, array) =&gt; { 
 
                    cache.match(request).then(response =&gt; { 
 
                        let date = new <br class="title-page-name"/>                        Date(response.headers.get("date")), 
                            current = new Date(Date.now()); 
 
                        if (!DateManager.compareDates(current, 
                                DateManager.addSecondsToDate(date,  
                                    rule.strategyOptions.ttl))) { 
 
                            cache.delete(request); 
 
                        } 
                    }); 
                }); 
            }); 
        }); 
} </pre>
<p class="calibre2">After retrieving the cached date, the <kbd class="calibre12">DateManager</kbd> can be used to test if the response is stale or past its expiration time. If the item has expired, it is deleted from the cache.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using a real-time asset manifest</h1>
                
            
            <article>
                
<p class="calibre2">A more complex technique I have used to manage service worker caches is the manifest file. This technique involves maintaining a file with a JSON object with caching rules:</p>
<pre class="calibre17">[{ 
    "url": "/", 
    "strategy": "precache-dependency", 
    "ttl": 604800 
}, { 
    "url": "/privacy", 
    "strategy": "genericFallback", 
    "fallback": "fallback/", 
    "ttl": 604800 
}, { 
    "url": "/product/*", 
    "strategy": "cacheFirst", 
    "ttl": 1800 
}, 
... 
] </pre>
<p class="calibre2">To leverage this technique, you would process the dynamic requests by testing their URL against the supplied routes. This can be done using a regular expression.</p>
<p class="calibre2">This process is very similar to the way the routes and caching strategies were defined and triggered earlier. The request URL is tested against a regular expression to identify the caching strategy to use:</p>
<pre class="calibre17">processDynamicRequest(request) { 
 
    var routeTest = new RegExp(this.routes), 
        result = routeTest.exec(request.url); 
 
    if (result) { 
 
        var match = result.shift(), 
            index = result.indexOf(match); 
 
        //return request handler. Should be a promise. 
        return strategyManager[this.strategies[index - 1]](request); 
 
    } else { 
 
        //default to pass-through 
        return fetch(request); 
 
    } 
} </pre>
<p class="calibre2">The manifest file is dynamically loaded when the service worker is first instantiated. The way I manage when the manifest is updated is by persisting a series of values in <kbd class="calibre12">indexedDB</kbd>:</p>
<pre class="calibre17">    canUpdateCacheManifest() { 
 
        let cm = this, 
            now = new Date(); 
 
        //retrieve persisted list of precached URLs 
        return cm.idbkv.get(this.CACHE_UPDATE_TTL_KEY).then(ret =&gt; { 
 
            if (!ret) { 
                return true; 
            } 
 
            return cm.dateMgr.compareDates(ret, Date.now()); 
 
        }); 
 
    } </pre>
<p class="calibre2">The reason I chose to control the manifest file's time to live manually is to avoid potential issues with the browser cache. It is important that you set the manifest's cache headers to not allow the resource to be cached by the browser or proxy servers.</p>
<p class="calibre2">I set the default time to live to 24 hours, just like the built-in service worker's time to live. This keeps the service worker from loading the manifest too often, but not so long that it could get out of sync from the server.</p>
<p class="calibre2">The ticket app does not use this technique, but I did include an example manifest file and some of the additional support modules you might need. I reserve this technique for more complex applications, and it does require some investment to maintain. Specifically, you would need a utility to keep the manifest file updated that I feel is outside the scope of this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">How much should you cache?</h1>
                
            
            <article>
                
<p class="calibre2">I mentioned earlier that you need to determine how your application's data should be cached. The type of data and how it will be used should be used as guidelines as to how it is managed in your service worker.</p>
<p class="calibre2">I want you to also consider your user. Not everyone has access to an unlimited high-speed connection or a large disk. Many smartphones still come with just 8 GB of storage, which after the operating system and all the photos and videos consumers record, there is not much room left.</p>
<p class="calibre2">Just because you could cache your entire application, including images and data, does not mean you should. Nicholas Hoizey (<a href="https://nicolas-hoizey.com/2017/01/how-much-data-should-my-service-worker-put-upfront-in-the-offline-cache.html" class="calibre9">https://nicolas-hoizey.com/2017/01/how-much-data-should-my-service-worker-put-upfront-in-the-offline-cache.html</a>) demonstrates that that tactic could have a negative impact on your application.</p>
<p class="calibre2">You might want to consider adding an experience where the user can configure your application to control how resources are persisted. Just like we saw with push notification management, you might want to add the ability for the user to determine how many events or tickets (in the example application) are cached and how long ticket QR codes are available:</p>
<div class="cdpaligncenter"><img src="../images/00102.jpeg" class="calibre117"/></div>
<p class="calibre2">You can still use the helper modules covered in this chapter. The caching and invalidation strategies wont change, just the settings they use to execute the actions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">This has been a very long chapter with some advanced concepts being covered. You learned how to trigger different caching strategies based on the request URL, modularizing the service worker logic, and employing cache invalidation strategies. Plus, you got to play with a new progressive web app!</p>
<p class="calibre2">There was a lot of valuable information and source code covered in this chapter, but these examples should only serve as a base reference for your applications. Not only should you be a good steward of the storage your application is allocated, but you should be mindful of your users' data plans.</p>
<p class="calibre2">In the next chapter, we'll continue to review how to use service workers and caching to make applications perform better. You will also see how to use available tools to evaluate and diagnose performance issues so that you can make a better application.</p>


            </article>

            
        </section>
    </body></html>