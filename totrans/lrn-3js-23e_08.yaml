- en: Chapter 8. Creating and Loading Advanced Meshes and Geometries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at a couple of different ways that you can create
    advanced and complex geometries and meshes. In [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*, and [Chapter 6](ch06.html
    "Chapter 6. Advanced Geometries and Binary Operations"), *Advanced Geometries
    and Binary Operations* ,we showed you how to create a few advanced geometries
    using the built-in objects from Three.js. In this chapter, we''ll use the following
    two approaches to create advanced geometries and meshes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Grouping and merging**: The first approach we explain uses built-in functionality
    from Three.js to group and merge existing geometries. This creates new meshes
    and geometries from existing objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Loading from external**: In this section, we''ll explain how you can load
    meshes and geometries from external sources. For instance, we''ll show you how
    you can use Blender to export meshes in a format Three.js supports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We start with the *group and merge* approach. With this approach, we use the
    standard Three.js grouping and the `THREE.Geometry.merge()` function to create
    new objects.
  prefs: []
  type: TYPE_NORMAL
- en: Geometry grouping and merging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we''ll look at two basic features of Three.js: grouping objects
    together and merging multiple meshes into a single mesh. We''ll start with grouping
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: Grouping objects together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some of the previous chapters, you already saw this when working with multiple
    materials. When you create a mesh from a geometry using multiple materials, Three.js
    creates a group. Multiple copies of your geometry are added to this group, each
    with their own specific material. This group is returned, so it looks like a mesh
    that uses multiple materials. In truth, however, it is a group that contains a
    number of meshes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating groups is very easy. Every mesh you create can contain child elements,
    which can be added using the add function. The effect of adding a child object
    to a group is that you can move, scale, rotate, and translate the parent object,
    and all the child objects will also be affected. Let''s look at an example (`01-grouping.html`).
    The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping objects together](img/2215OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you can use the menu to move the sphere and the cube around.
    If you check the **rotate** option, you''ll see these two meshes rotating around
    their center. This isn''t anything new and is not very exciting. However, these
    two objects haven''t been added to the scene directly, but have been added as
    a group. The following code encapsulates this discussion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, you can see that we create `THREE.Object3D`. This is the
    base class of `THREE.Mesh` and `THREE.Scene`, but by itself, it doesn't contain
    anything or cause anything to be rendered. Note that in the latest version of
    Three.js, a new object called `THREE.Group` was introduced to support grouping.
    This object is exactly the same as a `THREE.Object3D` object, and you can replace
    `new THREE.Object3D()` in the previous code with `new THREE.Group()` for the same
    effect. In this example, we use the `add` function to add the `sphere` and `cube`
    to this object, and then we add it to the `scene`. If you look at the example,
    you can still move the cube and sphere around and scale and rotate these two objects.
    You can also do these things on the group they are in. If you look at the group
    menu, you'll see position and scale options. You can use these to scale and move
    the entire group around. The scale and position of the objects inside this group
    are relative to the scale and position of the group itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scale and position are very straightforward. One thing to keep in mind, though,
    is that when you rotate a group, it doesn''t rotate the objects inside it separately;
    it rotates the entire group around its own center (in our example, you rotate
    the entire group around the center of the `group` object). In this example, we
    placed an arrow using the `THREE.ArrowHelper` object at the center of the group
    to indicate the rotation point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you check both the **grouping** and **rotate** checkboxes, the group will
    rotate. You''ll see the sphere and cube rotating around the center of the group
    (indicated by the arrow), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Grouping objects together](img/2215OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When using a group, you can still refer to, modify, and position the individual
    geometries. The only thing you need to remember is that all positions, rotations,
    and translations are done relative to the parent object. In the next section,
    we'll look at merging, where you'll combine multiple separate geometries and end
    up with a single `THREE.Geometry` object.
  prefs: []
  type: TYPE_NORMAL
- en: Merging multiple meshes into a single mesh
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In most cases, using groups allows you to easily manipulate and manage a large
    number of meshes. When you''re dealing with a very large number of objects, however,
    performance will become an issue. With groups, you''re still working with individual
    objects that each need to be handled and rendered separately. With `THREE.Geometry.merge()`,
    you can merge geometries together and create a combined one. In the following
    example, you can see how this works and the effect it has on performance. If you
    open the `02-merging.html` example, you see a scene with a set of randomly distributed
    semitransparent cubes. With the slider in the menu, you can set the number of
    cubes you want in the scene and redraw the scene by clicking on the **redraw**
    button. Depending on the hardware you''re running on, you''ll see a performance
    degradation as the number of cubes increases. In our case, as you can see in the
    following screenshot, this happens at around 4,000 objects, where the refresh
    rate drops to around 40 fps instead of the normal 60 fps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging multiple meshes into a single mesh](img/2215OS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there is a certain limit to the number of meshes you can add
    to the scene. Normally, though, you probably wouldn''t need that many meshes,
    but when creating specific games (for example, something like *Minecraft*) or
    advanced visualizations, you might need to manage a large number of individual
    meshes. With `THREE.Geometry.merge()`, you can solve this problem. Before we look
    at the code, let''s run this same example, but this time, with the **combine**
    box checked. With this option flagged, we merge all the cubes into a single `THREE.Geometry`
    and add that one instead, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Merging multiple meshes into a single mesh](img/2215OS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we can easily render 20,000 cubes without any drop in performance.
    To do this, we use the following couple of lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this code snippet, the `addCube()` function returns `THREE.Mesh`. In older
    versions of Three.js, we could use the `THREE.GeometryUtils.merge` function to
    also merge `THREE.Mesh` objects into `THREE.Geometry` objects. With the latest
    version, this functionality has been deprecated in favor of the `THREE.Geometry.merge`
    function. To make sure the merged-in `THREE.Geometry` object is positioned and
    rotated correctly, we not only provide `THREE.Geometry` to the `merge` function,
    but also its transformation matrix. When we add this matrix to the `merge` function,
    the cube we merge in will be positioned correctly.
  prefs: []
  type: TYPE_NORMAL
- en: We do this 20,000 times and are left with a single geometry that we add to the
    scene. If you look at the code, you can probably see a couple of drawbacks of
    this approach. Since you're left with a single geometry, you can't apply a material
    to each individual cube. This, however, can be somewhat solved using `THREE.MeshFaceMaterial`.
    The biggest drawback, however, is that you lose control over the individual cubes.
    If you want to move, rotate, or scale a single cube, you can't (unless you search
    for the correct faces and vertices and position them individually).
  prefs: []
  type: TYPE_NORMAL
- en: With the grouping and merging approach, you can create large and complex geometries
    using the basic geometries provided by Three.js. If you want to create more advanced
    geometries, then using the programmatic approach provided by Three.js isn't always
    the best and easiest option. Three.js, luckily, offers a couple of other options
    to create geometries. In the next section, we'll look at how you can load geometries
    and meshes from external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Loading geometries from external resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js can read a number of 3D file formats and import geometries and meshes
    defined in those files. The following table shows the file formats that are supported
    by Three.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Format | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| JSON | Three.js has its own JSON format you can use to declaratively define
    a geometry or a scene. Even though this isn''t an official format, it''s very
    easy to use and comes in very handy when you want to reuse complex geometries
    or scenes. |'
  prefs: []
  type: TYPE_TB
- en: '| OBJ or MTL | OBJ is a simple 3D format first developed by **Wavefront Technologies**.
    It''s one of the most widely adopted 3D file formats and is used to define the
    geometry of an object. MTL is a companion format to OBJ. In an MTL file, the material
    of the objects in an OBJ file is specified.Three.js also has a custom OBJ exporter,
    called OBJExporter.js, should you want to export your models to OBJ from Three.js.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Collada | Collada is a format for defining *digital assets* in an XML-based
    format. This is also a widely used format that is supported by pretty much all
    3D applications and rendering engines. |'
  prefs: []
  type: TYPE_TB
- en: '| STL | **STL** stands for **STereoLithography** and is widely used for rapid
    prototyping. For instance, models for 3D printers are often defined as STL files.Three.js
    also has a custom STL exporter, called STLExporter.js, should you want to export
    your models to STL from Three.js. |'
  prefs: []
  type: TYPE_TB
- en: '| CTM | CTM is a file format created by **openCTM**. It''s used as a format
    for storing 3D triangle-based meshes in a compact format. |'
  prefs: []
  type: TYPE_TB
- en: '| VTK | VTK is the file format defined by **Visualization Toolkit** and is
    used to specify vertices and faces. There are two formats available: a binary
    one and a text-based ASCII one. Three.js only supports the ASCII-based format.
    |'
  prefs: []
  type: TYPE_TB
- en: '| AWD | AWD is a binary format for 3D scenes and is most often used with the
    [http://away3d.com/](http://away3d.com/) engine. Note that this loader doesn''t
    support compressed AWD files. |'
  prefs: []
  type: TYPE_TB
- en: '| Assimp | Open asset import library (also called **Assimp**) is a standard
    way to import various 3D model formats. With this loader, you can import models
    from a large range of 3D formats that have been converted using **assimp2json**,
    details of which are available at [https://github.com/acgessler/assimp2json](https://github.com/acgessler/assimp2json).
    |'
  prefs: []
  type: TYPE_TB
- en: '| VRML | **VRML** stands for **Virtual Reality Modeling Language**. This is
    a text-based format that allows you to specify 3D objects and worlds. It has been
    superseded by the X3D file format. Three.js doesn''t support loading X3D models,
    but these models can be easily converted to other formats. More information can
    be found at [http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Babylon | Babylon is a 3D JavaScript game library. It stores models in its
    own internal format. More information about this can be found at [http://www.babylonjs.com/](http://www.babylonjs.com/).
    |'
  prefs: []
  type: TYPE_TB
- en: '| PDB | This is a very specialized format, created by **Protein Data Bank**,
    that is used to specify what proteins look like. Three.js can load and visualize
    proteins specified in this format. |'
  prefs: []
  type: TYPE_TB
- en: '| PLY | This format is called the **Polygon** file format. This is most often
    used to store information from 3D scanners. |'
  prefs: []
  type: TYPE_TB
- en: In the next chapter, we'll revisit some of these formats (and look at two additional
    ones, MD2 and glTF) when we look at animations. For now, we start with the first
    one on the list, the internal format of Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading in Three.js JSON format
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use Three.js' JSON format for two different scenarios in Three.js. You
    can use it to save and load a single `THREE.Mesh`, or you can use it to save and
    load a complete scene.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading THREE.Mesh
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate saving and loading, we created a simple example based on `THREE.TorusKnotGeometry`.
    With this example, you can create a torus knot, just like we did in [Chapter 5](ch05.html
    "Chapter 5. Learning to Work with Geometries"), *Learning to Work with Geometries*,
    and using the **save** button from the **Save & Load** menu, you can save the
    current geometry. For this example, we save using the HTML5 local storage API.
    This API allows us to easily store persistent information in the client's browser
    and retrieve it at a later time (even after the browser has been shut down and
    restarted).
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the `03-load-save-json-object.html` example. The following
    screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving and loading THREE.Mesh](img/2215OS_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exporting in JSON from Three.js is very easy and doesn''t require you to include
    any additional libraries. The only thing you need to do to export `THREE.Mesh`
    as JSON is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Before saving it, we first convert the result from the `toJSON` function, a
    JavaScript object, to a string using the `JSON.stringify` function. This results
    in a JSON string that looks like this (most of the vertices and faces are left
    out):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Three.js saves all the information about `THREE.Mesh`. To save
    this information using the HTML5 local storage API, all we have to do is call
    the `localStorage.setItem` function. The first argument is the key value (`json`)
    that we can later use to retrieve the information we passed in as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading `THREE.Mesh` back into Three.js also requires just a couple of lines
    of code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we first get the JSON from local storage using the name we saved it with
    (`json` in this case). For this, we use the `localStorage.getItem` function provided
    by the HTML5 local storage API. Next, we need to convert the string back to a
    JavaScript object (`JSON.parse`) and convert the JSON object back to `THREE.Mesh`.
    Three.js provides a helper object called `THREE.ObjectLoader`, which you can use
    to convert JSON to `THREE.Mesh`. In this example, we used the `parse` method on
    the loader to directly parse a JSON string. The loader also provides a `load`
    function, where you can pass in the URL to a file containing the JSON definition.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, we only saved `THREE.Mesh`. We lose everything else. If
    you want to save the complete scene, including the lights and the cameras, you
    can use `THREE.SceneExporter`.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading a scene
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to save a complete scene, you use the same approach as we saw in
    the previous section for the geometry. `04-load-save-json-scene.html` is a working
    example showing this. The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving and loading a scene](img/2215OS_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you''ve got three options: **exportScene**, **clearScene**,
    and **importScene**. With **exportScene**, the current state of the scene will
    be saved in the browser''s local storage. To test the import functionality, you
    can remove the scene by clicking on the **clearScene** button and load it from
    local storage with the **importScene** button. The code to do all this is very
    simple, but before you can use it, you have to import the required exporter and
    loader from the Three.js distribution (look at the `examples/js/exporters` and
    `examples/js/loaders` directories):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'With these JavaScript imports included in the page, you can export a scene
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is exactly the same as we used in the previous section—only this
    time, we use `THREE.SceneExporter()` to export a complete scene. The resulting
    JSON looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you load this JSON again, Three.js just recreates the objects exactly
    as they were exported. Loading a scene is done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The last argument passed into the loader (`'.'`) defines the relative URL. For
    instance, if you've got materials that use textures (for example, external images),
    those will be retrieved using this relative URL. In this example, where we don't
    use textures, we just pass in the current directory. Just as with `THREE.ObjectLoader`,
    you can also load a JSON file from a URL using the `load` function.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different 3D programs you can use to create complex meshes. A
    popular open source one is Blender ([www.blender.org](http://www.blender.org)).
    Three.js has an exporter for Blender (and for Maya and 3D Studio Max) that directly
    exports to the JSON format of Three.js. In the next section, we'll walk you through
    getting Blender configured to use this exporter and show you how you can export
    a complex model in Blender and show it in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Blender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get started with the configuration, we''ll show the result that we''ll
    be aiming for. In the following screenshot, you can see a simple Blender model
    that we exported with the Three.js plugin and imported in Three.js with `THREE.JSONLoader`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Blender](img/2215OS_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Installing the Three.js exporter in Blender
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get Blender to export Three.js models, we first need to add the Three.js
    exporter to Blender. The following steps are for Mac OS X but are pretty much
    the same on Windows and Linux. You can download Blender from [www.blender.org](http://www.blender.org)
    and follow the platform-specific installation instructions. After installation,
    you can add the Three.js plugin. First, locate the `addons` directory from your
    Blender installation using a terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On my Mac, it''s located here: `./blender.app/Contents/MacOS/2.70/scripts/addons`.
    For Windows, this directory can be found at the following location: `C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.7X\scripts\addons`. And for Linux, you can find this directory
    here: `/home/USERNAME/.config/blender/2.7X/scripts/addons`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to get the Three.js distribution and unpack it locally. In this
    distribution, you can find the following folder: `utils/exporters/blender/2.65/scripts/addons/`.
    In this directory, there is a single subdirectory with the name `io_mesh_threejs`.
    Copy this directory to the `addons` folder of your Blender installation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need to do is start Blender and enable the exporter. In Blender,
    open **Blender User Preferences** (**File** | **User Preferences**). In the window
    that opens, select the **Addons** tab, and in the search box, type `three`. This
    will show the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, the Three.js plugin is found, but it is still disabled. Check
    the small checkbox to the right, and the Three.js exporter will be enabled. As
    a final check to see whether everything is working correctly, open the **File**
    | **Export** menu option, and you''ll see Three.js listed as an export option.
    This is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With the plugin installed, we can load our first model.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and exporting a model from Blender
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example, we've added a simple Blender model named `misc_chair01.blend`
    in the `assets/models` folder, which you can find in the sources for this book.
    In this section, we'll load this model and show the minimal steps it takes to
    export this model to Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to load this model in Blender. Use **File** | **Open** and navigate
    to the folder containing the `misc_chair01.blend` file. Select this file and click
    on **Open**. This will show you a screen that looks somewhat like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading and exporting a model from Blender](img/2215OS_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Exporting this model to the Three.js JSON format is pretty straightforward.
    From the **File** menu, open **Export** | **Three.js**, type in the name of the
    export file, and select **Export Three.js**. This will create a JSON file in a
    format Three.js understands. A part of the contents of this file is shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we aren''t completely done. In the previous screenshot, you can see
    that the chair contains a wooden texture. If you look through the JSON export,
    you can see that the export for the chair also specifies a material, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This material specifies a texture, `misc_chair01_col.jpg`, for the `mapDiffuse`
    property. So, besides exporting the model, we also need to make sure the texture
    file is also available to Three.js. Luckily, we can save this texture directly
    from Blender.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Blender, open the **UV/Image Editor** view. You can select this view from
    the drop-down menu on the left-hand side of the **File** menu option. This will
    replace the top menu with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading and exporting a model from Blender](img/2215OS_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure the texture you want to export is selected, `misc_chair_01_col.jpg`
    in our case (you can select a different one using the small image icon). Next,
    click on the **Image** menu and use the **Save as Image** menu option to save
    the image. Save it in the same folder where you saved the model using the name
    specified in the JSON export file. At this point, we're ready to load the model
    into Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to load this into Three.js at this point looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve already seen `JSONLoader` before, but this time, we use the `load` function
    instead of the `parse` function. In this function, we specify the URL we want
    to load (points to the exported JSON file), a callback that is called when the
    object is loaded, and the location, `../assets/models/`, where the texture can
    be found (relative to the page). This callback takes two parameters: `geometry`
    and `mat`. The `geometry` parameter contains the model, and the `mat` parameter
    contains an array of material objects. We know that there is only one material,
    so when we create `THREE.Mesh`, we directly reference that material. If you open
    the `05-blender-from-json.html` example, you can see the chair we just exported
    from Blender.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Three.js exporter isn't the only way of loading models from Blender
    into Three.js. Three.js understands a number of 3D file formats, and Blender can
    export in a couple of those formats. Using the Three.js format, however, is very
    easy, and if things go wrong, they are often quickly found.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll look at a couple of the formats Three.js supports
    and also show a Blender-based example for the OBJ and MTL file formats.
  prefs: []
  type: TYPE_NORMAL
- en: Importing from 3D file formats
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we listed a number of formats that are supported
    by Three.js. In this section, we'll quickly walk through a couple of examples
    for those formats. Note that for all these formats, an additional JavaScript file
    needs to be included. You can find all these files in the Three.js distribution
    in the `examples/js/loaders` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The OBJ and MTL formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OBJ and MTL are companion formats and often used together. The OBJ file defines
    the geometry, and the MTL file defines the materials that are used. Both OBJ and
    MTL are text-based formats. A part of an OBJ file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The MTL file defines materials like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The OBJ and MTL formats by Three.js are understood well and are also supported
    by Blender. So, as an alternative, you could choose to export models from Blender
    in the OBJ/MTL format instead of the Three.js JSON format. Three.js has two different
    loaders you can use. If you only want to load the geometry, you can use `OBJLoader`.
    We used this loader for our example (`06-load-obj.html`). The following screenshot
    shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The OBJ and MTL formats](img/2215OS_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To import this in Three.js, you have to add the OBJLoader JavaScript file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Import the model like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we use `OBJLoader` to load the model from a URL. Once the model
    is loaded, the callback we provide is called, and we add the model to the scene.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, a good first step is to print out the response from the callback to
    the console to understand how the loaded object is built up. Often with these
    loaders, the geometry or mesh is returned as a hierarchy of groups. Understanding
    this makes it much easier to place and apply the correct material and take any
    other additional steps. Also, look at the position of a couple of vertices to
    determine whether you need to scale the model up or down and where to position
    the camera. In this example, we've also made the calls to `computeFaceNormals`
    and `computeVertexNormals`. This is required to ensure that the material used
    (`THREE.MeshLambertMaterial`) is rendered correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example (`07-load-obj-mtl.html`) uses `OBJMTLLoader` to load a model
    and directly assign a material. The following screenshot shows this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The OBJ and MTL formats](img/2215OS_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we need to add the correct loaders to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can load the model from the OBJ and MTL files like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing to mention before we look at the code is that if you receive
    an OBJ file, an MTL file, and the required texture files, you''ll have to check
    how the MTL file references the textures. These should be referenced relative
    to the MTL file and not as an absolute path. The code itself isn''t that different
    from the one we saw for `THREE.ObjLoader`. We specify the location of the OBJ
    file, the location of the MTL file, and the function to call when the model is
    loaded. The model we''ve used as an example in this case is a complex model. So,
    we set some specific properties in the callback to fix some rendering issues,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The opacity in the source files was set incorrectly, which caused the wings
    to be invisible. So, to fix that, we set the `opacity` and `transparent` properties
    ourselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, Three.js only renders one side of an object. Since we look at the
    wings from two sides, we need to set the `side` property to the `THREE.DoubleSide`
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The wings caused some unwanted artifacts when they needed to be rendered on
    top of each other. We've fixed that by setting the `depthTest` property to `false`.
    This has a slight impact on performance but can often solve some strange rendering
    artifacts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But, as you can see, you can easily load complex models directly into Three.js
    and render them in real time in your browser. You might need to fine-tune some
    material properties though.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a Collada model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Collada models (extension is `.dae`) are another very common format for defining
    scenes and models (and animations, as we'll see in the following chapter). In
    a Collada model, it is not just the geometry that is defined, but also the materials.
    It's even possible to define light sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load Collada models, you have to take pretty much the same steps as for
    the OBJ and MTL models. You start by including the correct loader:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For this example, we''ll load the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading a Collada model](img/2215OS_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Loading a truck model is once again pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The main difference here is the result of the object that is returned to the
    callback. The `result` object has the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we're interested in the objects that are in the `scene` parameter.
    I first printed out the scene to the console to look where the mesh was that I
    was interested in, which was `result.scene.children[0].children[0]`. All that
    was left to do was scale it to a reasonable size and add it to the scene. A final
    note on this specific example—when I loaded this model for the first time, the
    materials didn't render correctly. The reason was that the textures used the `.tga`
    format, which isn't supported in WebGL. To fix this, I had to convert the `.tga`
    files to `.png` and edit the XML of the `.dae` model to point to these `.png`
    files.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, for most complex models, including materials, you often have
    to take some additional steps to get the desired results. By looking closely at
    how the materials are configured (using `console.log()`) or replacing them with
    test materials, problems are often easy to spot.
  prefs: []
  type: TYPE_NORMAL
- en: Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re going to quickly skim over these file formats as they all follow the
    same principles:'
  prefs: []
  type: TYPE_NORMAL
- en: Include `[NameOfFormat]Loader.js` in your web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `[NameOfFormat]Loader.load()` to load a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check what the response format for the callback looks like and render the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have included an example for all these formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Example | Screenshot |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| STL | `08-load-STL.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_16.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| CTM | `09-load-CTM.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_17.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| VTK | `10-load-vtk.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_18.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| AWD | `11-load-awd.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_19.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| Assimp | `12-load-assimp.html` | ![Loading the STL, CTM, VTK, AWD, Assimp,
    VRML, and Babylon models](img/2215OS_08_20.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| VRML | `13-load-vrml.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_21.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| Babylon | The Babylon loader is slightly different from the other loaders
    in this table. With this loader, you don''t load a single `THREE.Mesh` or `THREE.Geometry`
    instance, but with this loader, you load a complete scene, including lights.`14-load-babylon.html`
    | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models](img/2215OS_08_22.jpg)
    |'
  prefs: []
  type: TYPE_TB
- en: If you look at the source code for these examples, you might see that for some
    of them, we need to change some material properties or do some scaling before
    the model is rendered correctly. The reason we need to do this is because of the
    way the model is created in its external application, giving it different dimensions
    and grouping than we normally use in Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: We've almost shown all the supported file formats. In the next two sections,
    we'll take a different approach. First, we'll look at how to render proteins from
    Protein Data Bank (PDB format), and finally we'll use a model defined in the PLY
    format to create a particle system.
  prefs: []
  type: TYPE_NORMAL
- en: Show proteins from Protein Data Bank
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protein Data Bank ([www.rcsb.org](http://www.rcsb.org)) contains detailed information
    about many different molecules and proteins. Besides the explanation of these
    proteins, they also provide a way to download the structure of these molecules
    in the PDB format. Three.js provides a loader for files specified in the PDB format.
    In this section, we'll give an example of how you can parse PDB files and visualize
    them with Three.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we always need to do to load in a new file format is include
    the correct loader in Three.js, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With this loader included, we''re going to create the following 3D model of
    the molecule description provided (see the `15-load-ptb.html` example):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Show proteins from Protein Data Bank](img/2215OS_08_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Loading a PDB file is done in the same manner as the previous formats, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this example, we instantiate `THREE.PDBLoader`, pass in
    the model file we want to load, and provide a callback that is called when the
    model is loaded. For this specific loader, the callback function is called with
    two arguments: `geometry` and `geometryBonds`. The vertices from the `geometry`
    argument supplied contain the positions of the individual atoms, and `geometryBounds`
    is used for the connections between the atoms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each vertex, we create a sphere with the color that is also supplied by
    the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each connection is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: For the connection, we first create a 3D path using the `THREE.SplineCurve3`
    object. This path is used as input for `THREE.Tube` and used to create the connection
    between the atoms. All the connections and atoms are added to a group, and this
    group is added to the scene. There are many models you can download from Protein
    Data Bank.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the structure of a diamond:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Show proteins from Protein Data Bank](img/2215OS_08_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Creating a particle system from a PLY model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working with the PLY format isn''t that much different from the other formats.
    You include the loader, provide a callback, and visualize the model. For this
    last example, however, we''re going to do something different. Instead of rendering
    the model as a mesh, we''ll use the information from this model to create a particle
    system (see the `15-load-ply.html` example). The following screenshot shows this
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a particle system from a PLY model](img/2215OS_08_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The JavaScript code to render the preceding screenshot is actually very simple,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use `THREE.PLYLoader` to load the model. The callback returns
    `geometry`, and we use this geometry as input for `THREE.PointCloud`. The material
    we use is the same as the one we used for the last example in the previous chapter.
    As you can see, with Three.js, it is very easy to combine models from various
    sources and render them in different ways, all with a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using models from external sources isn't that hard to do in Three.js. Especially
    for simple models, you only have to take a few simple steps. When working with
    external models, or creating them using grouping and merging, it is good to keep
    a couple of things in mind. The first thing you need to remember is that when
    you group objects, they still remain available as individual objects. Transformations
    applied to the parent also affect the children, but you can still transform the
    children individually. Besides grouping, you can also merge geometries together.
    With this approach, you lose the individual geometries and get a single new geometry.
    This is especially useful when you're dealing with thousands of geometries you
    need to render and you're running into performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js supports a large number of external formats. When using these format
    loaders, it's a good idea to look through the source code and log out the information
    received in the callback. This will help you to understand the steps you need
    to take to get the correct mesh and set it to the correct position and scale.
    Often, when the model doesn't show correctly, this is caused by its material settings.
    It could be that incompatible texture formats are used, opacity is incorrectly
    defined, or the format contains incorrect links to the texture images. It is usually
    a good idea to use a test material to determine whether the model itself is loaded
    correctly and log the loaded material to the JavaScript console to check for unexpected
    values. It is also possible to export meshes and scenes, but remember that `GeometryExporter`,
    `SceneExporter`, and `SceneLoader` of Three.js are still work in progress.
  prefs: []
  type: TYPE_NORMAL
- en: The models you worked with in this chapter, and in the previous chapters, are
    mostly static models. They aren't animated, don't move around, and don't change
    shape. In the next chapter, you'll learn how you can animate your models to make
    them come to life. Besides animations, the following chapter will also explain
    the various camera controls provided by Three.js. With a camera control, you can
    move, pan, and rotate the camera around your scene.
  prefs: []
  type: TYPE_NORMAL
