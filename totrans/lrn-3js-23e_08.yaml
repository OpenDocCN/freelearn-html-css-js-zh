- en: Chapter 8. Creating and Loading Advanced Meshes and Geometries
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。创建和加载高级网格和几何形状
- en: 'In this chapter, we''ll look at a couple of different ways that you can create
    advanced and complex geometries and meshes. In [Chapter 5](ch05.html "Chapter 5. Learning
    to Work with Geometries"), *Learning to Work with Geometries*, and [Chapter 6](ch06.html
    "Chapter 6. Advanced Geometries and Binary Operations"), *Advanced Geometries
    and Binary Operations* ,we showed you how to create a few advanced geometries
    using the built-in objects from Three.js. In this chapter, we''ll use the following
    two approaches to create advanced geometries and meshes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几种不同的方法，您可以使用这些方法创建高级和复杂的几何形状和网格。在[第5章](ch05.html "第5章。学习与几何形状一起工作")“学习与几何形状一起工作”和[第6章](ch06.html
    "第6章。高级几何形状和二进制操作")“高级几何形状和二进制操作”中，我们向您展示了如何使用Three.js的内置对象创建一些高级几何形状。在本章中，我们将使用以下两种方法来创建高级几何形状和网格：
- en: '**Grouping and merging**: The first approach we explain uses built-in functionality
    from Three.js to group and merge existing geometries. This creates new meshes
    and geometries from existing objects.'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分组和合并**: 我们解释的第一个方法使用Three.js的内置功能来分组和合并现有的几何形状。这从现有对象中创建新的网格和几何形状。'
- en: '**Loading from external**: In this section, we''ll explain how you can load
    meshes and geometries from external sources. For instance, we''ll show you how
    you can use Blender to export meshes in a format Three.js supports.'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从外部加载**: 在本节中，我们将解释如何从外部来源加载网格和几何形状。例如，我们将向您展示如何使用Blender导出Three.js支持的网格格式。'
- en: We start with the *group and merge* approach. With this approach, we use the
    standard Three.js grouping and the `THREE.Geometry.merge()` function to create
    new objects.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍*分组和合并*方法。使用这种方法，我们使用标准的Three.js分组和`THREE.Geometry.merge()`函数来创建新对象。
- en: Geometry grouping and merging
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何形状分组和合并
- en: 'In this section, we''ll look at two basic features of Three.js: grouping objects
    together and merging multiple meshes into a single mesh. We''ll start with grouping
    objects.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Three.js的两个基本功能：将对象分组在一起以及将多个网格合并成一个网格。我们将从分组对象开始。
- en: Grouping objects together
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将对象分组
- en: In some of the previous chapters, you already saw this when working with multiple
    materials. When you create a mesh from a geometry using multiple materials, Three.js
    creates a group. Multiple copies of your geometry are added to this group, each
    with their own specific material. This group is returned, so it looks like a mesh
    that uses multiple materials. In truth, however, it is a group that contains a
    number of meshes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些前面的章节中，您在处理多个材质时已经看到了这一点。当您使用多个材质从几何形状创建网格时，Three.js会创建一个组。您的几何形状的多个副本被添加到这个组中，每个副本都有其特定的材质。这个组被返回，所以它看起来像是一个使用多个材质的网格。然而，实际上，它是一个包含多个网格的组。
- en: 'Creating groups is very easy. Every mesh you create can contain child elements,
    which can be added using the add function. The effect of adding a child object
    to a group is that you can move, scale, rotate, and translate the parent object,
    and all the child objects will also be affected. Let''s look at an example (`01-grouping.html`).
    The following screenshot shows this example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 创建组非常简单。您创建的每个网格都可以包含子元素，这些子元素可以通过add函数添加。将子对象添加到组中的效果是您可以移动、缩放、旋转和平移父对象，所有子对象也会受到影响。让我们看一个例子（`01-grouping.html`）。以下截图显示了此示例：
- en: '![Grouping objects together](img/2215OS_08_01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![将对象分组在一起](img/2215OS_08_01.jpg)'
- en: 'In this example, you can use the menu to move the sphere and the cube around.
    If you check the **rotate** option, you''ll see these two meshes rotating around
    their center. This isn''t anything new and is not very exciting. However, these
    two objects haven''t been added to the scene directly, but have been added as
    a group. The following code encapsulates this discussion:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您可以使用菜单移动球体和立方体。如果您勾选**旋转**选项，您将看到这两个网格围绕它们的中心旋转。这并不是什么新东西，也不是很令人兴奋。然而，这两个对象并没有直接添加到场景中，而是作为组添加的。以下代码封装了这次讨论：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this code snippet, you can see that we create `THREE.Object3D`. This is the
    base class of `THREE.Mesh` and `THREE.Scene`, but by itself, it doesn't contain
    anything or cause anything to be rendered. Note that in the latest version of
    Three.js, a new object called `THREE.Group` was introduced to support grouping.
    This object is exactly the same as a `THREE.Object3D` object, and you can replace
    `new THREE.Object3D()` in the previous code with `new THREE.Group()` for the same
    effect. In this example, we use the `add` function to add the `sphere` and `cube`
    to this object, and then we add it to the `scene`. If you look at the example,
    you can still move the cube and sphere around and scale and rotate these two objects.
    You can also do these things on the group they are in. If you look at the group
    menu, you'll see position and scale options. You can use these to scale and move
    the entire group around. The scale and position of the objects inside this group
    are relative to the scale and position of the group itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，你可以看到我们创建了`THREE.Object3D`。这是`THREE.Mesh`和`THREE.Scene`的基础类，但本身并不包含任何内容或导致任何渲染。请注意，在Three.js的最新版本中，引入了一个名为`THREE.Group`的新对象来支持分组。这个对象与`THREE.Object3D`对象完全相同，你可以在之前的代码中将`new
    THREE.Object3D()`替换为`new THREE.Group()`以获得相同的效果。在这个例子中，我们使用`add`函数将`sphere`和`cube`添加到这个对象中，然后将其添加到`scene`中。如果你查看示例，你仍然可以移动立方体和球体，并缩放和旋转这两个对象。你还可以在它们所在的组上执行这些操作。如果你查看组菜单，你会看到位置和缩放选项。你可以使用这些选项来缩放和移动整个组。这个组内对象的缩放和位置相对于组的缩放和位置。
- en: 'Scale and position are very straightforward. One thing to keep in mind, though,
    is that when you rotate a group, it doesn''t rotate the objects inside it separately;
    it rotates the entire group around its own center (in our example, you rotate
    the entire group around the center of the `group` object). In this example, we
    placed an arrow using the `THREE.ArrowHelper` object at the center of the group
    to indicate the rotation point:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放和位置非常直接。不过，需要注意的是，当你旋转一个组时，它不会分别旋转组内的对象；它会围绕组自己的中心旋转整个组（在我们的例子中，你围绕`group`对象的中心旋转整个组）。在这个例子中，我们使用`THREE.ArrowHelper`对象在组的中心放置了一个箭头，以指示旋转点：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you check both the **grouping** and **rotate** checkboxes, the group will
    rotate. You''ll see the sphere and cube rotating around the center of the group
    (indicated by the arrow), as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你同时勾选**分组**和**旋转**复选框，该组将会旋转。你会看到球体和立方体围绕组的中心（由箭头指示）旋转，如下所示：
- en: '![Grouping objects together](img/2215OS_08_02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![将对象分组在一起](img/2215OS_08_02.jpg)'
- en: When using a group, you can still refer to, modify, and position the individual
    geometries. The only thing you need to remember is that all positions, rotations,
    and translations are done relative to the parent object. In the next section,
    we'll look at merging, where you'll combine multiple separate geometries and end
    up with a single `THREE.Geometry` object.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用一个组时，你仍然可以引用、修改和定位单个几何体。你需要记住的唯一一点是，所有位置、旋转和平移都是相对于父对象进行的。在下一节中，我们将探讨合并，在那里你将结合多个单独的几何体，最终得到一个单一的`THREE.Geometry`对象。
- en: Merging multiple meshes into a single mesh
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将多个网格合并成一个网格
- en: 'In most cases, using groups allows you to easily manipulate and manage a large
    number of meshes. When you''re dealing with a very large number of objects, however,
    performance will become an issue. With groups, you''re still working with individual
    objects that each need to be handled and rendered separately. With `THREE.Geometry.merge()`,
    you can merge geometries together and create a combined one. In the following
    example, you can see how this works and the effect it has on performance. If you
    open the `02-merging.html` example, you see a scene with a set of randomly distributed
    semitransparent cubes. With the slider in the menu, you can set the number of
    cubes you want in the scene and redraw the scene by clicking on the **redraw**
    button. Depending on the hardware you''re running on, you''ll see a performance
    degradation as the number of cubes increases. In our case, as you can see in the
    following screenshot, this happens at around 4,000 objects, where the refresh
    rate drops to around 40 fps instead of the normal 60 fps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用组可以让你轻松地操作和管理大量网格。然而，当你处理一个非常大的对象数量时，性能将成为一个问题。使用组时，你仍然是在处理单个对象，每个对象都需要单独处理和渲染。通过`THREE.Geometry.merge()`，你可以将几何体合并在一起，创建一个组合的几何体。在下面的示例中，您可以了解这是如何工作的以及它对性能的影响。如果您打开`02-merging.html`示例，您会看到一个场景，其中包含一组随机分布的半透明立方体。通过菜单中的滑块，您可以设置场景中想要的立方体数量，并通过点击**重绘**按钮重新绘制场景。根据您所运行的硬件，您会看到随着立方体数量的增加，性能会下降。在我们的案例中，如您在下面的截图中所见，这发生在大约4,000个对象时，刷新率下降到大约40
    fps，而不是正常的60 fps：
- en: '![Merging multiple meshes into a single mesh](img/2215OS_08_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![将多个网格合并成一个网格](img/2215OS_08_03.jpg)'
- en: 'As you can see, there is a certain limit to the number of meshes you can add
    to the scene. Normally, though, you probably wouldn''t need that many meshes,
    but when creating specific games (for example, something like *Minecraft*) or
    advanced visualizations, you might need to manage a large number of individual
    meshes. With `THREE.Geometry.merge()`, you can solve this problem. Before we look
    at the code, let''s run this same example, but this time, with the **combine**
    box checked. With this option flagged, we merge all the cubes into a single `THREE.Geometry`
    and add that one instead, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可以添加到场景中的网格数量有一定的限制。不过，通常情况下，你可能不需要那么多网格，但在创建特定游戏（例如，类似于*我的世界*）或高级可视化时，你可能需要管理大量单独的网格。通过`THREE.Geometry.merge()`，你可以解决这个问题。在我们查看代码之前，让我们运行这个相同的示例，但这次，将**组合**框勾选上。使用这个选项标记后，我们将所有立方体合并成一个单一的`THREE.Geometry`，并添加这个单一的几何体，如下面的截图所示：
- en: '![Merging multiple meshes into a single mesh](img/2215OS_08_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![将多个网格合并成一个网格](img/2215OS_08_04.jpg)'
- en: 'As you can see, we can easily render 20,000 cubes without any drop in performance.
    To do this, we use the following couple of lines of code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们能够轻松渲染20,000个立方体而不会出现性能下降。为此，我们使用了以下几行代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this code snippet, the `addCube()` function returns `THREE.Mesh`. In older
    versions of Three.js, we could use the `THREE.GeometryUtils.merge` function to
    also merge `THREE.Mesh` objects into `THREE.Geometry` objects. With the latest
    version, this functionality has been deprecated in favor of the `THREE.Geometry.merge`
    function. To make sure the merged-in `THREE.Geometry` object is positioned and
    rotated correctly, we not only provide `THREE.Geometry` to the `merge` function,
    but also its transformation matrix. When we add this matrix to the `merge` function,
    the cube we merge in will be positioned correctly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，`addCube()`函数返回`THREE.Mesh`。在Three.js的旧版本中，我们可以使用`THREE.GeometryUtils.merge`函数将`THREE.Mesh`对象合并到`THREE.Geometry`对象中。在最新版本中，这个功能已经被弃用，转而使用`THREE.Geometry.merge`函数。为了确保合并的`THREE.Geometry`对象定位和旋转正确，我们不仅向`merge`函数提供了`THREE.Geometry`，还提供了其变换矩阵。当我们向`merge`函数添加这个矩阵时，合并进来的立方体将被正确定位。
- en: We do this 20,000 times and are left with a single geometry that we add to the
    scene. If you look at the code, you can probably see a couple of drawbacks of
    this approach. Since you're left with a single geometry, you can't apply a material
    to each individual cube. This, however, can be somewhat solved using `THREE.MeshFaceMaterial`.
    The biggest drawback, however, is that you lose control over the individual cubes.
    If you want to move, rotate, or scale a single cube, you can't (unless you search
    for the correct faces and vertices and position them individually).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: With the grouping and merging approach, you can create large and complex geometries
    using the basic geometries provided by Three.js. If you want to create more advanced
    geometries, then using the programmatic approach provided by Three.js isn't always
    the best and easiest option. Three.js, luckily, offers a couple of other options
    to create geometries. In the next section, we'll look at how you can load geometries
    and meshes from external resources.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Loading geometries from external resources
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three.js can read a number of 3D file formats and import geometries and meshes
    defined in those files. The following table shows the file formats that are supported
    by Three.js:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '| Format | Description |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '| JSON | Three.js has its own JSON format you can use to declaratively define
    a geometry or a scene. Even though this isn''t an official format, it''s very
    easy to use and comes in very handy when you want to reuse complex geometries
    or scenes. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| OBJ or MTL | OBJ is a simple 3D format first developed by **Wavefront Technologies**.
    It''s one of the most widely adopted 3D file formats and is used to define the
    geometry of an object. MTL is a companion format to OBJ. In an MTL file, the material
    of the objects in an OBJ file is specified.Three.js also has a custom OBJ exporter,
    called OBJExporter.js, should you want to export your models to OBJ from Three.js.
    |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| Collada | Collada is a format for defining *digital assets* in an XML-based
    format. This is also a widely used format that is supported by pretty much all
    3D applications and rendering engines. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| STL | **STL** stands for **STereoLithography** and is widely used for rapid
    prototyping. For instance, models for 3D printers are often defined as STL files.Three.js
    also has a custom STL exporter, called STLExporter.js, should you want to export
    your models to STL from Three.js. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| CTM | CTM is a file format created by **openCTM**. It''s used as a format
    for storing 3D triangle-based meshes in a compact format. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| VTK | VTK is the file format defined by **Visualization Toolkit** and is
    used to specify vertices and faces. There are two formats available: a binary
    one and a text-based ASCII one. Three.js only supports the ASCII-based format.
    |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| AWD | AWD is a binary format for 3D scenes and is most often used with the
    [http://away3d.com/](http://away3d.com/) engine. Note that this loader doesn''t
    support compressed AWD files. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| Assimp | Open asset import library (also called **Assimp**) is a standard
    way to import various 3D model formats. With this loader, you can import models
    from a large range of 3D formats that have been converted using **assimp2json**,
    details of which are available at [https://github.com/acgessler/assimp2json](https://github.com/acgessler/assimp2json).
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: '| VRML | **VRML** stands for **Virtual Reality Modeling Language**. This is
    a text-based format that allows you to specify 3D objects and worlds. It has been
    superseded by the X3D file format. Three.js doesn''t support loading X3D models,
    but these models can be easily converted to other formats. More information can
    be found at [http://www.x3dom.org/?page_id=532#](http://www.x3dom.org/?page_id=532#).
    |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
- en: '| Babylon | Babylon is a 3D JavaScript game library. It stores models in its
    own internal format. More information about this can be found at [http://www.babylonjs.com/](http://www.babylonjs.com/).
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
- en: '| PDB | This is a very specialized format, created by **Protein Data Bank**,
    that is used to specify what proteins look like. Three.js can load and visualize
    proteins specified in this format. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
- en: '| PLY | This format is called the **Polygon** file format. This is most often
    used to store information from 3D scanners. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
- en: In the next chapter, we'll revisit some of these formats (and look at two additional
    ones, MD2 and glTF) when we look at animations. For now, we start with the first
    one on the list, the internal format of Three.js.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading in Three.js JSON format
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use Three.js' JSON format for two different scenarios in Three.js. You
    can use it to save and load a single `THREE.Mesh`, or you can use it to save and
    load a complete scene.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading THREE.Mesh
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate saving and loading, we created a simple example based on `THREE.TorusKnotGeometry`.
    With this example, you can create a torus knot, just like we did in [Chapter 5](ch05.html
    "Chapter 5. Learning to Work with Geometries"), *Learning to Work with Geometries*,
    and using the **save** button from the **Save & Load** menu, you can save the
    current geometry. For this example, we save using the HTML5 local storage API.
    This API allows us to easily store persistent information in the client's browser
    and retrieve it at a later time (even after the browser has been shut down and
    restarted).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at the `03-load-save-json-object.html` example. The following
    screenshot shows this example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving and loading THREE.Mesh](img/2215OS_08_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Exporting in JSON from Three.js is very easy and doesn''t require you to include
    any additional libraries. The only thing you need to do to export `THREE.Mesh`
    as JSON is the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before saving it, we first convert the result from the `toJSON` function, a
    JavaScript object, to a string using the `JSON.stringify` function. This results
    in a JSON string that looks like this (most of the vertices and faces are left
    out):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, Three.js saves all the information about `THREE.Mesh`. To save
    this information using the HTML5 local storage API, all we have to do is call
    the `localStorage.setItem` function. The first argument is the key value (`json`)
    that we can later use to retrieve the information we passed in as the second argument.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading `THREE.Mesh` back into Three.js also requires just a couple of lines
    of code, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we first get the JSON from local storage using the name we saved it with
    (`json` in this case). For this, we use the `localStorage.getItem` function provided
    by the HTML5 local storage API. Next, we need to convert the string back to a
    JavaScript object (`JSON.parse`) and convert the JSON object back to `THREE.Mesh`.
    Three.js provides a helper object called `THREE.ObjectLoader`, which you can use
    to convert JSON to `THREE.Mesh`. In this example, we used the `parse` method on
    the loader to directly parse a JSON string. The loader also provides a `load`
    function, where you can pass in the URL to a file containing the JSON definition.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: As you can see here, we only saved `THREE.Mesh`. We lose everything else. If
    you want to save the complete scene, including the lights and the cameras, you
    can use `THREE.SceneExporter`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Saving and loading a scene
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to save a complete scene, you use the same approach as we saw in
    the previous section for the geometry. `04-load-save-json-scene.html` is a working
    example showing this. The following screenshot shows this example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving and loading a scene](img/2215OS_08_06.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: 'In this example, you''ve got three options: **exportScene**, **clearScene**,
    and **importScene**. With **exportScene**, the current state of the scene will
    be saved in the browser''s local storage. To test the import functionality, you
    can remove the scene by clicking on the **clearScene** button and load it from
    local storage with the **importScene** button. The code to do all this is very
    simple, but before you can use it, you have to import the required exporter and
    loader from the Three.js distribution (look at the `examples/js/exporters` and
    `examples/js/loaders` directories):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With these JavaScript imports included in the page, you can export a scene
    with the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This approach is exactly the same as we used in the previous section—only this
    time, we use `THREE.SceneExporter()` to export a complete scene. The resulting
    JSON looks like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When you load this JSON again, Three.js just recreates the objects exactly
    as they were exported. Loading a scene is done like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The last argument passed into the loader (`'.'`) defines the relative URL. For
    instance, if you've got materials that use textures (for example, external images),
    those will be retrieved using this relative URL. In this example, where we don't
    use textures, we just pass in the current directory. Just as with `THREE.ObjectLoader`,
    you can also load a JSON file from a URL using the `load` function.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: There are many different 3D programs you can use to create complex meshes. A
    popular open source one is Blender ([www.blender.org](http://www.blender.org)).
    Three.js has an exporter for Blender (and for Maya and 3D Studio Max) that directly
    exports to the JSON format of Three.js. In the next section, we'll walk you through
    getting Blender configured to use this exporter and show you how you can export
    a complex model in Blender and show it in Three.js.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Working with Blender
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get started with the configuration, we''ll show the result that we''ll
    be aiming for. In the following screenshot, you can see a simple Blender model
    that we exported with the Three.js plugin and imported in Three.js with `THREE.JSONLoader`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Blender](img/2215OS_08_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: Installing the Three.js exporter in Blender
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To get Blender to export Three.js models, we first need to add the Three.js
    exporter to Blender. The following steps are for Mac OS X but are pretty much
    the same on Windows and Linux. You can download Blender from [www.blender.org](http://www.blender.org)
    and follow the platform-specific installation instructions. After installation,
    you can add the Three.js plugin. First, locate the `addons` directory from your
    Blender installation using a terminal window:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_08.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'On my Mac, it''s located here: `./blender.app/Contents/MacOS/2.70/scripts/addons`.
    For Windows, this directory can be found at the following location: `C:\Users\USERNAME\AppData\Roaming\Blender
    Foundation\Blender\2.7X\scripts\addons`. And for Linux, you can find this directory
    here: `/home/USERNAME/.config/blender/2.7X/scripts/addons`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you need to get the Three.js distribution and unpack it locally. In this
    distribution, you can find the following folder: `utils/exporters/blender/2.65/scripts/addons/`.
    In this directory, there is a single subdirectory with the name `io_mesh_threejs`.
    Copy this directory to the `addons` folder of your Blender installation.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all we need to do is start Blender and enable the exporter. In Blender,
    open **Blender User Preferences** (**File** | **User Preferences**). In the window
    that opens, select the **Addons** tab, and in the search box, type `three`. This
    will show the following screen:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
- en: 'At this point, the Three.js plugin is found, but it is still disabled. Check
    the small checkbox to the right, and the Three.js exporter will be enabled. As
    a final check to see whether everything is working correctly, open the **File**
    | **Export** menu option, and you''ll see Three.js listed as an export option.
    This is shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the Three.js exporter in Blender](img/2215OS_08_10.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: With the plugin installed, we can load our first model.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Loading and exporting a model from Blender
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an example, we've added a simple Blender model named `misc_chair01.blend`
    in the `assets/models` folder, which you can find in the sources for this book.
    In this section, we'll load this model and show the minimal steps it takes to
    export this model to Three.js.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们在`assets/models`文件夹中添加了一个简单的Blender模型`misc_chair01.blend`，你可以在本书的源代码中找到它。在本节中，我们将加载此模型，并展示将此模型导出到Three.js所需的最小步骤。
- en: 'First, we need to load this model in Blender. Use **File** | **Open** and navigate
    to the folder containing the `misc_chair01.blend` file. Select this file and click
    on **Open**. This will show you a screen that looks somewhat like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在Blender中加载这个模型。使用**文件** | **打开**并导航到包含`misc_chair01.blend`文件的文件夹。选择此文件并点击**打开**。这将显示一个看起来有点像这样的屏幕：
- en: '![Loading and exporting a model from Blender](img/2215OS_08_11.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![从Blender加载和导出模型](img/2215OS_08_11.jpg)'
- en: 'Exporting this model to the Three.js JSON format is pretty straightforward.
    From the **File** menu, open **Export** | **Three.js**, type in the name of the
    export file, and select **Export Three.js**. This will create a JSON file in a
    format Three.js understands. A part of the contents of this file is shown next:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模型导出为Three.js JSON格式相当直接。从**文件**菜单，打开**导出** | **Three.js**，输入导出文件的名称，并选择**导出Three.js**。这将创建一个Three.js可以理解的JSON文件。此文件内容的一部分如下所示：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However, we aren''t completely done. In the previous screenshot, you can see
    that the chair contains a wooden texture. If you look through the JSON export,
    you can see that the export for the chair also specifies a material, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们还没有完全完成。在之前的屏幕截图中，你可以看到椅子包含一个木质纹理。如果你查看JSON导出，你可以看到椅子的导出也指定了一个材质，如下所示：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This material specifies a texture, `misc_chair01_col.jpg`, for the `mapDiffuse`
    property. So, besides exporting the model, we also need to make sure the texture
    file is also available to Three.js. Luckily, we can save this texture directly
    from Blender.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此材质指定了`mapDiffuse`属性的一个纹理，`misc_chair01_col.jpg`。因此，除了导出模型外，我们还需要确保纹理文件也对Three.js可用。幸运的是，我们可以直接从Blender中保存这个纹理。
- en: 'In Blender, open the **UV/Image Editor** view. You can select this view from
    the drop-down menu on the left-hand side of the **File** menu option. This will
    replace the top menu with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Blender中，打开**UV/图像编辑器**视图。你可以从**文件**菜单选项左侧的下拉菜单中选择此视图。这将替换顶部菜单，如下所示：
- en: '![Loading and exporting a model from Blender](img/2215OS_08_12.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![从Blender加载和导出模型](img/2215OS_08_12.jpg)'
- en: Make sure the texture you want to export is selected, `misc_chair_01_col.jpg`
    in our case (you can select a different one using the small image icon). Next,
    click on the **Image** menu and use the **Save as Image** menu option to save
    the image. Save it in the same folder where you saved the model using the name
    specified in the JSON export file. At this point, we're ready to load the model
    into Three.js.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你想要导出的纹理被选中，在我们的例子中是`misc_chair_01_col.jpg`（你可以使用小图像图标选择不同的纹理）。接下来，点击**图像**菜单并使用**另存为图像**菜单选项保存图像。将其保存在与模型相同的文件夹中，使用JSON导出文件中指定的名称。到此为止，我们就可以将模型加载到Three.js中了。
- en: 'The code to load this into Three.js at this point looks like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段将此加载到Three.js中的代码看起来像这样：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We''ve already seen `JSONLoader` before, but this time, we use the `load` function
    instead of the `parse` function. In this function, we specify the URL we want
    to load (points to the exported JSON file), a callback that is called when the
    object is loaded, and the location, `../assets/models/`, where the texture can
    be found (relative to the page). This callback takes two parameters: `geometry`
    and `mat`. The `geometry` parameter contains the model, and the `mat` parameter
    contains an array of material objects. We know that there is only one material,
    so when we create `THREE.Mesh`, we directly reference that material. If you open
    the `05-blender-from-json.html` example, you can see the chair we just exported
    from Blender.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经见过`JSONLoader`，但这次我们使用的是`load`函数而不是`parse`函数。在这个函数中，我们指定了想要加载的URL（指向导出的JSON文件），一个在对象加载时被调用的回调函数，以及纹理可以找到的位置，`../assets/models/`（相对于页面）。这个回调函数接受两个参数：`geometry`和`mat`。`geometry`参数包含模型，而`mat`参数包含一个材质对象数组。我们知道只有一个材质，所以当我们创建`THREE.Mesh`时，我们直接引用那个材质。如果你打开`05-blender-from-json.html`示例，你可以看到我们刚刚从Blender导出的椅子。
- en: Using the Three.js exporter isn't the only way of loading models from Blender
    into Three.js. Three.js understands a number of 3D file formats, and Blender can
    export in a couple of those formats. Using the Three.js format, however, is very
    easy, and if things go wrong, they are often quickly found.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we'll look at a couple of the formats Three.js supports
    and also show a Blender-based example for the OBJ and MTL file formats.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Importing from 3D file formats
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this chapter, we listed a number of formats that are supported
    by Three.js. In this section, we'll quickly walk through a couple of examples
    for those formats. Note that for all these formats, an additional JavaScript file
    needs to be included. You can find all these files in the Three.js distribution
    in the `examples/js/loaders` directory.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The OBJ and MTL formats
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'OBJ and MTL are companion formats and often used together. The OBJ file defines
    the geometry, and the MTL file defines the materials that are used. Both OBJ and
    MTL are text-based formats. A part of an OBJ file looks like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The MTL file defines materials like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The OBJ and MTL formats by Three.js are understood well and are also supported
    by Blender. So, as an alternative, you could choose to export models from Blender
    in the OBJ/MTL format instead of the Three.js JSON format. Three.js has two different
    loaders you can use. If you only want to load the geometry, you can use `OBJLoader`.
    We used this loader for our example (`06-load-obj.html`). The following screenshot
    shows this example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![The OBJ and MTL formats](img/2215OS_08_13.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: 'To import this in Three.js, you have to add the OBJLoader JavaScript file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import the model like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this code, we use `OBJLoader` to load the model from a URL. Once the model
    is loaded, the callback we provide is called, and we add the model to the scene.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Usually, a good first step is to print out the response from the callback to
    the console to understand how the loaded object is built up. Often with these
    loaders, the geometry or mesh is returned as a hierarchy of groups. Understanding
    this makes it much easier to place and apply the correct material and take any
    other additional steps. Also, look at the position of a couple of vertices to
    determine whether you need to scale the model up or down and where to position
    the camera. In this example, we've also made the calls to `computeFaceNormals`
    and `computeVertexNormals`. This is required to ensure that the material used
    (`THREE.MeshLambertMaterial`) is rendered correctly.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The next example (`07-load-obj-mtl.html`) uses `OBJMTLLoader` to load a model
    and directly assign a material. The following screenshot shows this example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![The OBJ and MTL formats](img/2215OS_08_14.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'First, we need to add the correct loaders to the page:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can load the model from the OBJ and MTL files like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The first thing to mention before we look at the code is that if you receive
    an OBJ file, an MTL file, and the required texture files, you''ll have to check
    how the MTL file references the textures. These should be referenced relative
    to the MTL file and not as an absolute path. The code itself isn''t that different
    from the one we saw for `THREE.ObjLoader`. We specify the location of the OBJ
    file, the location of the MTL file, and the function to call when the model is
    loaded. The model we''ve used as an example in this case is a complex model. So,
    we set some specific properties in the callback to fix some rendering issues,
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看代码之前，首先要提到的是，如果您收到一个 OBJ 文件、一个 MTL 文件和所需的纹理文件，您必须检查 MTL 文件如何引用纹理。这些应该相对于
    MTL 文件进行引用，而不是作为绝对路径。代码本身与我们之前看到的 `THREE.ObjLoader` 的代码并没有太大的不同。我们指定了 OBJ 文件的位置、MTL
    文件的位置以及当模型加载时调用的函数。在这个例子中，我们使用的模型是一个复杂的模型。因此，我们在回调中设置了一些特定的属性来修复一些渲染问题，如下所示：
- en: The opacity in the source files was set incorrectly, which caused the wings
    to be invisible. So, to fix that, we set the `opacity` and `transparent` properties
    ourselves.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源文件中的不透明度设置不正确，导致翅膀不可见。因此，为了修复这个问题，我们自行设置了 `opacity` 和 `transparent` 属性。
- en: By default, Three.js only renders one side of an object. Since we look at the
    wings from two sides, we need to set the `side` property to the `THREE.DoubleSide`
    value.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，Three.js 只渲染对象的单侧。由于我们从两个侧面查看翅膀，我们需要将 `side` 属性设置为 `THREE.DoubleSide`
    值。
- en: The wings caused some unwanted artifacts when they needed to be rendered on
    top of each other. We've fixed that by setting the `depthTest` property to `false`.
    This has a slight impact on performance but can often solve some strange rendering
    artifacts.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当翅膀需要叠加渲染时，它们造成了一些不希望出现的伪影。我们通过将 `depthTest` 属性设置为 `false` 来修复了这个问题。这会对性能产生轻微影响，但通常可以解决一些奇怪的渲染伪影。
- en: But, as you can see, you can easily load complex models directly into Three.js
    and render them in real time in your browser. You might need to fine-tune some
    material properties though.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如您所见，您可以将复杂模型直接加载到 Three.js 中，并在浏览器中实时渲染。不过，您可能需要微调一些材质属性。
- en: Loading a Collada model
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载 Collada 模型
- en: Collada models (extension is `.dae`) are another very common format for defining
    scenes and models (and animations, as we'll see in the following chapter). In
    a Collada model, it is not just the geometry that is defined, but also the materials.
    It's even possible to define light sources.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Collada 模型（扩展名为 `.dae`）是定义场景和模型（以及动画，我们将在下一章中看到）的另一种非常常见的格式。在 Collada 模型中，不仅定义了几何形状，还定义了材质。甚至可以定义光源。
- en: 'To load Collada models, you have to take pretty much the same steps as for
    the OBJ and MTL models. You start by including the correct loader:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载 Collada 模型，您必须基本上采取与 OBJ 和 MTL 模型相同的步骤。您首先包括正确的加载器：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For this example, we''ll load the following model:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将加载以下模型：
- en: '![Loading a Collada model](img/2215OS_08_15.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![加载 Collada 模型](img/2215OS_08_15.jpg)'
- en: 'Loading a truck model is once again pretty simple:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 加载卡车模型再次非常简单：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The main difference here is the result of the object that is returned to the
    callback. The `result` object has the following structure:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于回调函数返回的对象的结果。`result` 对象具有以下结构：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this chapter, we're interested in the objects that are in the `scene` parameter.
    I first printed out the scene to the console to look where the mesh was that I
    was interested in, which was `result.scene.children[0].children[0]`. All that
    was left to do was scale it to a reasonable size and add it to the scene. A final
    note on this specific example—when I loaded this model for the first time, the
    materials didn't render correctly. The reason was that the textures used the `.tga`
    format, which isn't supported in WebGL. To fix this, I had to convert the `.tga`
    files to `.png` and edit the XML of the `.dae` model to point to these `.png`
    files.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们对 `scene` 参数中的对象感兴趣。我首先将场景打印到控制台，以查看我感兴趣的网格在哪里，它是 `result.scene.children[0].children[0]`。剩下要做的就是将其缩放到合理的大小并添加到场景中。关于这个特定示例的最后一句话——当我第一次加载这个模型时，材质没有正确渲染。原因是使用的纹理格式是
    `.tga`，WebGL 不支持这种格式。为了修复这个问题，我不得不将 `.tga` 文件转换为 `.png`，并编辑 `.dae` 模型的 XML 以指向这些
    `.png` 文件。
- en: As you can see, for most complex models, including materials, you often have
    to take some additional steps to get the desired results. By looking closely at
    how the materials are configured (using `console.log()`) or replacing them with
    test materials, problems are often easy to spot.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''re going to quickly skim over these file formats as they all follow the
    same principles:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Include `[NameOfFormat]Loader.js` in your web page.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `[NameOfFormat]Loader.load()` to load a URL.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check what the response format for the callback looks like and render the result.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have included an example for all these formats:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Example | Screenshot |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| STL | `08-load-STL.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_16.jpg) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| CTM | `09-load-CTM.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_17.jpg) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| VTK | `10-load-vtk.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_18.jpg) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| AWD | `11-load-awd.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_19.jpg) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| Assimp | `12-load-assimp.html` | ![Loading the STL, CTM, VTK, AWD, Assimp,
    VRML, and Babylon models](img/2215OS_08_20.jpg) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| VRML | `13-load-vrml.html` | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML,
    and Babylon models](img/2215OS_08_21.jpg) |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| Babylon | The Babylon loader is slightly different from the other loaders
    in this table. With this loader, you don''t load a single `THREE.Mesh` or `THREE.Geometry`
    instance, but with this loader, you load a complete scene, including lights.`14-load-babylon.html`
    | ![Loading the STL, CTM, VTK, AWD, Assimp, VRML, and Babylon models](img/2215OS_08_22.jpg)
    |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: If you look at the source code for these examples, you might see that for some
    of them, we need to change some material properties or do some scaling before
    the model is rendered correctly. The reason we need to do this is because of the
    way the model is created in its external application, giving it different dimensions
    and grouping than we normally use in Three.js.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We've almost shown all the supported file formats. In the next two sections,
    we'll take a different approach. First, we'll look at how to render proteins from
    Protein Data Bank (PDB format), and finally we'll use a model defined in the PLY
    format to create a particle system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Show proteins from Protein Data Bank
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Protein Data Bank ([www.rcsb.org](http://www.rcsb.org)) contains detailed information
    about many different molecules and proteins. Besides the explanation of these
    proteins, they also provide a way to download the structure of these molecules
    in the PDB format. Three.js provides a loader for files specified in the PDB format.
    In this section, we'll give an example of how you can parse PDB files and visualize
    them with Three.js.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we always need to do to load in a new file format is include
    the correct loader in Three.js, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 加载新文件格式的第一步，我们总是需要在 Three.js 中包含正确的加载器，如下所示：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'With this loader included, we''re going to create the following 3D model of
    the molecule description provided (see the `15-load-ptb.html` example):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 包含了这个加载器后，我们将创建以下分子描述的 3D 模型（参见 `15-load-ptb.html` 示例）：
- en: '![Show proteins from Protein Data Bank](img/2215OS_08_23.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![显示来自蛋白质数据银行的蛋白质](img/2215OS_08_23.jpg)'
- en: 'Loading a PDB file is done in the same manner as the previous formats, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 加载 PDB 文件的方式与之前的格式相同，如下所示：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see from this example, we instantiate `THREE.PDBLoader`, pass in
    the model file we want to load, and provide a callback that is called when the
    model is loaded. For this specific loader, the callback function is called with
    two arguments: `geometry` and `geometryBonds`. The vertices from the `geometry`
    argument supplied contain the positions of the individual atoms, and `geometryBounds`
    is used for the connections between the atoms.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个示例中可以看出，我们实例化 `THREE.PDBLoader`，传入我们想要加载的模型文件，并提供一个在模型加载时被调用的回调函数。对于这个特定的加载器，回调函数接收两个参数：`geometry`
    和 `geometryBonds`。`geometry` 参数提供的顶点包含单个原子的位置，而 `geometryBounds` 用于原子之间的连接。
- en: 'For each vertex, we create a sphere with the color that is also supplied by
    the model:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个顶点，我们创建一个由模型提供的颜色填充的球体：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Each connection is defined like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接的定义如下：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For the connection, we first create a 3D path using the `THREE.SplineCurve3`
    object. This path is used as input for `THREE.Tube` and used to create the connection
    between the atoms. All the connections and atoms are added to a group, and this
    group is added to the scene. There are many models you can download from Protein
    Data Bank.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 对于连接，我们首先使用 `THREE.SplineCurve3` 对象创建一个 3D 路径。这个路径被用作 `THREE.Tube` 的输入，用于创建原子之间的连接。所有的连接和原子都被添加到一个组中，这个组被添加到场景中。你可以从蛋白质数据银行下载许多模型。
- en: 'The following image shows the structure of a diamond:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了钻石的结构：
- en: '![Show proteins from Protein Data Bank](img/2215OS_08_24.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![显示来自蛋白质数据银行的蛋白质](img/2215OS_08_24.jpg)'
- en: Creating a particle system from a PLY model
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从 PLY 模型创建粒子系统
- en: 'Working with the PLY format isn''t that much different from the other formats.
    You include the loader, provide a callback, and visualize the model. For this
    last example, however, we''re going to do something different. Instead of rendering
    the model as a mesh, we''ll use the information from this model to create a particle
    system (see the `15-load-ply.html` example). The following screenshot shows this
    example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PLY 格式与使用其他格式并没有太大的不同。你包含加载器，提供回调函数，并可视化模型。然而，对于这个最后的例子，我们将做一些不同的事情。我们不会将模型作为网格渲染，而是将使用这个模型的信息来创建一个粒子系统（参见
    `15-load-ply.html` 示例）。以下截图展示了这个示例：
- en: '![Creating a particle system from a PLY model](img/2215OS_08_25.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![从 PLY 模型创建粒子系统](img/2215OS_08_25.jpg)'
- en: 'The JavaScript code to render the preceding screenshot is actually very simple,
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染前面截图的 JavaScript 代码实际上非常简单，如下所示：
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, we use `THREE.PLYLoader` to load the model. The callback returns
    `geometry`, and we use this geometry as input for `THREE.PointCloud`. The material
    we use is the same as the one we used for the last example in the previous chapter.
    As you can see, with Three.js, it is very easy to combine models from various
    sources and render them in different ways, all with a few lines of code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用 `THREE.PLYLoader` 来加载模型。回调函数返回 `geometry`，我们将这个几何体作为 `THREE.PointCloud`
    的输入。我们使用的材质与上一章最后一个示例中使用的相同。如您所见，使用 Three.js，结合来自不同来源的模型并以不同方式渲染它们非常容易，只需几行代码即可。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Using models from external sources isn't that hard to do in Three.js. Especially
    for simple models, you only have to take a few simple steps. When working with
    external models, or creating them using grouping and merging, it is good to keep
    a couple of things in mind. The first thing you need to remember is that when
    you group objects, they still remain available as individual objects. Transformations
    applied to the parent also affect the children, but you can still transform the
    children individually. Besides grouping, you can also merge geometries together.
    With this approach, you lose the individual geometries and get a single new geometry.
    This is especially useful when you're dealing with thousands of geometries you
    need to render and you're running into performance issues.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中使用外部模型并不难。特别是对于简单模型，您只需进行几个简单的步骤。当处理外部模型或使用分组和合并创建它们时，有一些事情需要记住。首先，您需要记住的是，当您分组对象时，它们仍然作为单独的对象可用。应用于父对象的变换也会影响子对象，但您仍然可以单独变换子对象。除了分组之外，您还可以合并几何体。采用这种方法，您会失去单个几何体，并获得一个单一的新几何体。当您需要渲染成千上万的几何体并且遇到性能问题时，这种方法特别有用。
- en: Three.js supports a large number of external formats. When using these format
    loaders, it's a good idea to look through the source code and log out the information
    received in the callback. This will help you to understand the steps you need
    to take to get the correct mesh and set it to the correct position and scale.
    Often, when the model doesn't show correctly, this is caused by its material settings.
    It could be that incompatible texture formats are used, opacity is incorrectly
    defined, or the format contains incorrect links to the texture images. It is usually
    a good idea to use a test material to determine whether the model itself is loaded
    correctly and log the loaded material to the JavaScript console to check for unexpected
    values. It is also possible to export meshes and scenes, but remember that `GeometryExporter`,
    `SceneExporter`, and `SceneLoader` of Three.js are still work in progress.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js支持大量外部格式。当使用这些格式加载器时，查看源代码并记录回调中接收到的信息是个好主意。这将帮助您了解获取正确网格并将其设置为正确位置和比例所需的步骤。通常，当模型显示不正确时，这可能是由于其材质设置引起的。可能是使用了不兼容的纹理格式，不透明度定义不正确，或者格式包含指向纹理图像的错误链接。通常，使用测试材质来确定模型本身是否正确加载，并将加载的材质记录到JavaScript控制台以检查意外值是个好主意。也有可能导出网格和场景，但请记住，Three.js的`GeometryExporter`、`SceneExporter`和`SceneLoader`仍在开发中。
- en: The models you worked with in this chapter, and in the previous chapters, are
    mostly static models. They aren't animated, don't move around, and don't change
    shape. In the next chapter, you'll learn how you can animate your models to make
    them come to life. Besides animations, the following chapter will also explain
    the various camera controls provided by Three.js. With a camera control, you can
    move, pan, and rotate the camera around your scene.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章以及前几章中，您所使用的模型大多是静态模型。它们没有动画效果，不会移动，也不会改变形状。在下一章中，您将学习如何使您的模型动起来，使其栩栩如生。除了动画之外，下一章还将解释Three.js提供的各种相机控制功能。有了相机控制，您可以移动、平移和旋转相机，使其围绕场景旋转。
