- en: Starting Type-Driven Development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this book, we are exploring the techniques and idioms available in type-driven
    development. Some people also refer to type-driven development as type-level programming.
    Static types offer several benefits, including:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Preventing incorrect code from getting a chance to run
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documenting the current codebase
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helping to correctly refactor the codebase by pointing out any parts of code
    you may have missed
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offering richer IDE support, for example, auto-completion
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better performance when the compiler knows types and can optimize code accordingly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type-driven development is the practice of using static types to restrict what
    your code can do. Normally, your programming language gives you enough power to
    represent any computation. With type-driven development, you are essentially trying
    to make it impossible for your code to do undesirable things.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will do some basic critical analysis of a piece of code
    and look at the possible errors it may contain. We'll also introduce ReasonML,
    the language we will use to learn type-driven development and compare it with
    JavaScript. We'll get started with a basic Reason project and then introduce Reason,
    as well as its related communities and ecosystems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The main idea and benefits of type-driven development
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically typed code versus its statically typed ReasonML equivalent
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Reason language, ecosystem, and related projects
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a basic Reason project, which we will use throughout this book
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Try Reason online playground
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing code for hidden errors
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s suppose that you have the following JavaScript:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A lot of things can go wrong with the preceding code; they are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The caller can pass in nulls or undefined values as arguments
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller can pass in unintended types of arguments
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller can manipulate the returned `person` object any way they like, for
    example, they can add or remove properties
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In other words, this code doesn't prevent a number of potential errors. In JavaScript,
    we have linters, such as ESLint ([https://eslint.org/](https://eslint.org/)),
    that check for a lot of possible errors, but you have to remember to find them,
    enable them, and then work around their limitations. A linter can be helpful in
    various other ways, such as by pointing out the recommended best practices in
    a coding style. However, linters in JavaScript are often re-purposed to perform
    static type checking tasks as well; because they offer so much flexibility and
    need to be configured (in fact, people usually upload their preferred sets of
    configuration for different styles of programming), there may be large differences
    in what exactly gets checked across different codebases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Adding types
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With a static type system, we can restrict our `makePerson` function in quite
    a few ways. Here''s an example using ReasonML, the language that we''re using
    in this book to learn type-driven development:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, we define a new data type, `person`, and a function that creates a value
    of the type given the required arguments. We have one more line in the preceding
    code than we do in the JavaScript code, but in exchange, we get the following
    guarantees:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: The caller cannot pass in null or undefined arguments
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller cannot pass in the wrong types of arguments
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller cannot mutate the result value of the function
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice in the previous example that we didn't have to declare the argument or
    types for the `makePerson` function. This is because ReasonML has great type inference
    that automatically understands that `int`, `string`, and `person` must be the
    only possible types allowed for those parts of the function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'ReasonML will compile the previous code into the following JavaScript:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, the preceding code looks almost exactly like the JavaScript
    we wrote earlier—the main difference is that Reason's JavaScript compiler turns
    records (which we'll explore later) into JavaScript arrays to take advantage of
    their speed.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: This is just a glimpse of what static types can do to your codebase. In the
    coming chapters, we'll have a look at many more practical applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: ReasonML
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We're going to explore type-driven development using ReasonML ([https://reasonml.github.io/](https://reasonml.github.io/)).
    Reason is a JavaScript-like syntax and is also a set of tools for OCaml ([https://ocaml.org/](https://ocaml.org/)).
    OCaml is a mature statically typed functional programming language with excellent
    support for object-oriented and modular programming.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: We're going to write Reason code and compile it to JavaScript using the BuckleScript
    compiler ([https://bucklescript.github.io/](https://bucklescript.github.io/)).
    BuckleScript takes input from Reason code and outputs essentially a simple subset
    of ES5 (that is, no ES2015-style classes, no arrow functions, and so on). This
    will allow us to write strongly statically typed code and see what the output
    JavaScript looks like with all the types stripped away.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: BuckleScript, by default, outputs JavaScript files with the extension `.bs.js`
    to distinguish them from your other JS files. You can see this in the example
    output file, `src/Ch01/Ch01_Demo.bs.js`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'The Reason toolkit currently consists of:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: A code formatting and syntax translation tool, `refmt`
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interactive code evaluation environment, `rtop`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A build manager for native-compilation projects (we won't need this one for
    this book), `rebuild`
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tool that provides intellisense abilities to editors, `ocamlmerlin-reason`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools work together to provide a minimal, yet powerful, development experience.
    Together with a good editor (we recommend Visual Studio Code), they cover most
    of your day-to-day development needs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Why ReasonML?
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So why have we chosen ReasonML over something else? For example, TypeScript
    and Flow are popular languages that target JavaScript today (among many others),
    but we chose Reason because:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: It has a powerful and elegant type system, which neatly fits together many type-driven
    development concepts
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its JavaScript compiler (BuckleScript) has incredibly fast compiles, optimization,
    and high-quality dead-code elimination; fast compiles are great to have if you’re
    doing type-driven development, and performant code is great to have in any system
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has a very helpful and enthusiastic community that's very accessible
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gives you access to the mature OCaml community and its aggregated knowledge
    base
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will take advantage of the contrasts between the two languages to understand
    how statically typed Reason code is converted into dynamically typed JavaScript
    code yet still runs safely by design.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with ReasonML
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Reason website has a great quickstart guide as well as tutorials for setting
    up editor support. First, install NodeJS to get the **node package manager** (**npm**).
    Then, run the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now we can do an initial compile with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command builds your entire project and its dependencies recursively.
    It will be almost instantaneous.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: It's worth mentioning that we actually recommend running the preceding shell
    commands (substituting in your actual projects folder, of course), because throughout
    this book, we're going to arrange the code examples in the form of a single project,
    `learning-tydd-reason`, and the code examples that you type into the various given
    file names will fit together to make up that project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: You will almost certainly want to set up editor support in Reason so that you
    can get things like autocompletion and go to definition. The guides available
    on the ReasonML website ([https://reasonml.github.io/docs/en/global-installation.html](https://reasonml.github.io/docs/en/global-installation.html))
    are very helpful for this. Currently, Visual Studio Code ([http://code.visualstudio.com/](http://code.visualstudio.com/))
    is the best-supported editor; you will probably get the best results from using
    that.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: If you are trying to decide on the install method, we would personally recommend
    the OPAM method (**OPAM** is the abbreviation of **OCaml Package Manager**).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Using Try Reason
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Reason provides a fantastic resource for learners: an online Reason-to-JavaScript
    compiler and evaluator. To access it, go to the Reason website and click Try in
    the navigation bar at the top. You can use it to quickly try out different ideas.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run through a quick example using Try Reason to get our bearings. Type
    in the example code from `src/Ch01/Ch01_Demo.re` into the Reason section of the
    Try Reason web app. Now add the following line after that:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now if you examine the output JS, you should see that the following changes
    have been made:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Types have been stripped away
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Records have been transformed into arrays without field names (records are roughly
    like C structs or JavaScript objects)
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every declared value is explicitly exported (made public)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that we have purposely introduced very little actual Reason syntax in this
    chapter. If you are curious to explore the syntax (which is very similar to JavaScript
    at its core), it's best if you explore the excellent Reason website documentation.
    Since the focus of this book is type-driven development, in the upcoming chapters
    we will introduce all the syntax we will need and discuss its impact on our understanding
    of the code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这章中故意引入了非常少的实际 Reason 语法。如果你对探索语法（其核心与 JavaScript 非常相似）感兴趣，最好的方式是探索出色的
    Reason 网站文档。由于本书的重点是类型驱动开发，在接下来的章节中，我们将介绍我们将需要的所有语法，并讨论它对我们理解代码的影响。
- en: Going further
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入学习
- en: The ReasonML community is a helpful, fast-growing one. If you need help with
    anything, don't be afraid to ask. You'll only be a beginner once, and once you're
    comfortable, you'll be able to help other beginners. Check out the community page
    at [https://reasonml.github.io/docs/en/community.html](https://reasonml.github.io/docs/en/community.html)
    and drop by the discord chat as the first point of contact.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ReasonML 社区是一个有帮助的、快速发展的社区。如果你需要任何帮助，不要害怕提问。你只会初学者一次，一旦你感到舒适，你就能帮助其他初学者。请访问社区页面
    [https://reasonml.github.io/docs/en/community.html](https://reasonml.github.io/docs/en/community.html)，并在
    discord 聊天中作为首次接触点。
- en: Summary
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the basic ideas of type-driven development and
    critically analyzed a piece of dynamically-typed code to explore its potential
    error conditions that would be prevented by adding static types. We also introduced
    the ReasonML language and its ecosystem, set up our own Reason project, and got
    a glimpse of how it can compile statically typed code to JavaScript.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了类型驱动开发的初步概念，并批判性地分析了一块动态类型代码，以探索其潜在的错误条件，这些错误条件可以通过添加静态类型来防止。我们还介绍了
    ReasonML 语言及其生态系统，设置了我们的 Reason 项目，并瞥见了它如何将静态类型代码编译成 JavaScript。
- en: The next chapter will be an important one—we'll delve more into types, values,
    and working in Reason. See you there!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将非常重要——我们将更深入地探讨类型、值和在 Reason 中的工作方式。那里见！
