<html><head></head><body>
		<div id="_idContainer116">
			<h1 class="chapter-number" id="_idParaDest-195"><a id="_idTextAnchor196"/>12</h1>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor197"/>Testing Microservices</h1>
			<p>Testing is a critical phase within <a id="_idIndexMarker897"/>the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>) that’s integral to ensuring the software meets the required standards and functions as expected. Testing detects bugs introduced during development. It verifies that the software performs its intended functions correctly and efficiently and ensures the software meets user requirements and specifications. By applying tests, we can reduce the risks associated with software failure <span class="No-Break">or malfunction.</span></p>
			<p>In this chapter, we’ll talk about different strategies for software testing within microservices. By the end, you’ll know how to write unit and integration tests for your microservices both in isolation and integrated with <span class="No-Break">other microservices.</span></p>
			<p>We’re going to cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Understanding testing in a <span class="No-Break">microservice architecture</span></li>
				<li>Understanding and implementing <span class="No-Break">unit tests</span></li>
				<li>Implementing unit tests for the <span class="No-Break">account microservice</span></li>
				<li>Writing unit tests for the <span class="No-Break">transaction microservice</span></li>
				<li>Comparing mocks, stubs, and spies in <span class="No-Break">unit tests</span></li>
				<li>Understanding and implementing <span class="No-Break">integration tests</span></li>
			</ul>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor198"/>Technical requirements</h1>
			<p>To implement our tests, we’ll need <span class="No-Break">the following:</span></p>
			<ul>
				<li>An IDE of your choice (we prefer Visual <span class="No-Break">Studio Code).</span></li>
				<li>This book’s GitHub repository, which can be downloaded from <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript</a>. Open the <strong class="source-inline">Ch12</strong> folder so that you can follow along <span class="No-Break">with ease.</span></li>
			</ul>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor199"/>Understanding testing in a microservice architecture</h1>
			<p>Microservice architecture <a id="_idIndexMarker898"/>divides an application into<a id="_idIndexMarker899"/> smaller, loosely coupled services, each responsible for a specific business function. This approach offers numerous benefits, such as improved scalability and flexibility. However, it also introduces complexity, particularly in terms of testing. Comprehensive testing is crucial to ensure that these independent services function correctly and cohesively. Let’s try to understand the importance of testing in a <span class="No-Break">microservice architecture:</span></p>
			<ul>
				<li>The first reason for using <a id="_idIndexMarker900"/>tests in a microservice architecture is to ensure <strong class="bold">functionality</strong>. Each service performs a distinct function in a microservice architecture and is developed independently. Testing ensures that each service performs its intended function correctly. We mostly use unit and functional testing to achieve <span class="No-Break">this goal:</span><ul><li><strong class="bold">Unit testing</strong> focuses on individual components within a service, verifying that each function works as expected. This helps us catch bugs early in the <span class="No-Break">development process.</span></li><li>On the other hand, <strong class="bold">functional testing</strong> ensures<a id="_idIndexMarker901"/> that the service as a whole meets its functional requirements. This involves testing the service’s endpoints and ensuring that they return the <span class="No-Break">expected results.</span></li></ul></li>
				<li>The second reason for using tests in microservices is to maintain <strong class="bold">interoperability</strong>. Microservices must communicate with each other to function as a cohesive application. Ensuring seamless interoperability between services is critical. To achieve this, we mostly focus on integration and <span class="No-Break">contract testing:</span><ul><li><strong class="bold">Integration testing</strong> focuses on interactions between services, verifying that data exchange and communication protocols are <span class="No-Break">implemented correctly.</span></li><li><strong class="bold">Contract testing</strong> ensures that services adhere to defined APIs or contracts. This is particularly important when different teams develop services independently as it helps maintain consistent <span class="No-Break">communication standards.</span></li></ul></li>
				<li>The third reason is <strong class="bold">performance</strong> assurance. Performance testing ensures that services operate efficiently under various load conditions, which is vital for maintaining a good user<a id="_idIndexMarker902"/> experience. We can achieve this goal using load testing and <span class="No-Break">stress testing:</span><ul><li><strong class="bold">Load testing</strong> evaluates how services handle expected load levels. This helps identify performance bottlenecks and ensures services can handle <span class="No-Break">real-world usage.</span></li><li><strong class="bold">Stress testing</strong> examines how services perform under extreme conditions, such as high traffic or resource shortages. This helps in understanding the service’s breaking point <span class="No-Break">and resilience.</span></li></ul></li>
				<li>Testing is<a id="_idIndexMarker903"/> also<a id="_idIndexMarker904"/> important <a id="_idIndexMarker905"/>for <strong class="bold">security</strong> validation. Security is a critical concern in microservice architecture as each service may handle sensitive data and must be protected against vulnerabilities. We can use security testing and penetration testing to achieve <span class="No-Break">our goal:</span><ul><li><strong class="bold">Security testing</strong> identifies vulnerabilities and ensures that services can protect sensitive data. This includes testing for common security issues such as SQL injection, <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>), and<a id="_idIndexMarker906"/> <span class="No-Break">authentication flaws.</span></li><li><strong class="bold">Penetration testing</strong> simulates attacks to identify potential security gaps. This helps in proactively securing services against <span class="No-Break">real-world threats.</span></li></ul></li>
				<li>Microservices need to be reliable and stable, especially during updates or changes. Testing ensures that services remain <strong class="bold">dependable</strong> over time. We have regression and chaos testing to make sure we have reliable and <span class="No-Break">stable microservices:</span><ul><li><strong class="bold">Regression testing</strong> ensures that new changes or updates don’t introduce new bugs or break existing functionality. This is crucial for maintaining service reliability after <span class="No-Break">each deployment.</span></li><li><strong class="bold">Chaos engineering</strong> involves intentionally introducing failures into the system to test its resilience. This helps us understand how services respond to unexpected issues <a id="_idIndexMarker907"/>and improves <span class="No-Break">overall stability.</span></li></ul></li>
			</ul>
			<p>Having <a id="_idIndexMarker908"/>understood <a id="_idIndexMarker909"/>testing as a whole, let’s move on to <span class="No-Break">unit tests.</span></p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor200"/>Understanding unit tests</h1>
			<p><strong class="bold">Unit testing</strong> is a software<a id="_idIndexMarker910"/> testing technique that matters most when you want to ensure that individual units or components of the software are tested in isolation. The goal of unit testing is to validate that each unit of the software performs <span class="No-Break">as expected.</span></p>
			<p>It’s an important aspect of software development, especially in microservices architectures. Node.js, with its asynchronous and event-driven nature, poses unique challenges and opportunities for unit testing. In this context, unit testing involves testing individual functions, methods, or classes within your Node.js application. Let’s cover the importance of unit testing <span class="No-Break">for microservices:</span></p>
			<ul>
				<li><strong class="bold">It ensures code quality</strong>: Unit testing<a id="_idIndexMarker911"/> helps identify bugs early in the development cycle, ensuring that individual units of code function as intended. This is particularly important in microservices, where services are designed to be small, independent, <span class="No-Break">and modular.</span></li>
				<li><strong class="bold">It facilitates refactoring</strong>: With a comprehensive suite of unit tests, developers can confidently refactor code, knowing that any changes will be verified by the tests. This is crucial for maintaining and improving the code base <span class="No-Break">over time.</span></li>
				<li><strong class="bold">It supports continuous integration/continuous deployment (CI/CD)</strong>: Unit tests are an integral part of CI/CD pipelines. They provide immediate feedback on code changes, enabling quick iterations and <span class="No-Break">stable deployments.</span></li>
				<li><strong class="bold">Better documentation</strong>: Well-written unit tests serve as documentation for the code. They demonstrate how individual units are expected to behave, making it easier for new<a id="_idIndexMarker912"/> developers to understand the <span class="No-Break">code base.</span></li>
			</ul>
			<p>Let’s look at some of the benefits of performing unit testing in <span class="No-Break">Node.js microservices:</span></p>
			<ul>
				<li><strong class="bold">Improved reliability</strong>: Unit tests<a id="_idIndexMarker913"/> ensure that each microservice behaves as expected, reducing the likelihood of runtime errors and improving overall <span class="No-Break">system reliability.</span></li>
				<li><strong class="bold">Faster development cycles</strong>: Automated unit tests speed up the development process by allowing developers to quickly identify and fix issues. This is particularly beneficial in microservices, where services are developed and <span class="No-Break">deployed independently.</span></li>
				<li><strong class="bold">Reduced debugging time</strong>: With unit tests in place, bugs can be detected and isolated quickly, reducing the time spent <span class="No-Break">on debugging.</span></li>
				<li><strong class="bold">Increased confidence in code changes</strong>: Unit tests provide a safety net for developers, giving them the confidence to make changes and add new features without breaking <span class="No-Break">existing functionality.</span></li>
			</ul>
			<p>Unit testing in Node.js microservices enhances reliability, accelerates development by catching issues early, reduces debugging time, and boosts developer confidence in making code changes without breaking functionality. Now, let’s focus on unit testing packages we need to use to write <span class="No-Break">unit tests.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor201"/>Introducing unit testing packages</h2>
			<p>Before writing a line <a id="_idIndexMarker914"/>of code, we need to prepare our environment. To be precise, we need to install the required packages to write <span class="No-Break">unit tests.</span></p>
			<p>Chai, Mocha, and Sinon are popular libraries that are used for testing in Node.js applications, including microservices. Each of these libraries has a specific role and they often work together to provide a comprehensive <span class="No-Break">testing framework.</span></p>
			<h3>Introducing Mocha</h3>
			<p>First, let’s talk<a id="_idIndexMarker915"/> about <strong class="bold">Mocha</strong>. Mocha is a feature-rich JavaScript test<a id="_idIndexMarker916"/> framework that runs on Node.js, making asynchronous testing simple and fun. It provides a testing environment where you can define your tests and <span class="No-Break">run them.</span></p>
			<p>It has the <span class="No-Break">following features:</span></p>
			<ul>
				<li><strong class="bold">Descriptive</strong>: It allows <a id="_idIndexMarker917"/>for descriptive and structured test suites using <strong class="source-inline">describe</strong> and <span class="No-Break"><strong class="source-inline">it</strong></span><span class="No-Break"> </span><span class="No-Break">blocks.</span></li>
				<li><strong class="bold">Allows asynchronous testing</strong>: It supports both synchronous and <span class="No-Break">asynchronous </span><span class="No-Break">tests.</span></li>
				<li><strong class="bold">Variety of hooks</strong>: It provides life cycle hooks (<strong class="source-inline">before</strong>, <strong class="source-inline">after</strong>, <strong class="source-inline">beforeEach</strong>, and <strong class="source-inline">afterEach</strong>) for setting up and tearing down conditions <span class="No-Break">for </span><span class="No-Break">tests.</span></li>
				<li><strong class="bold">Extensible</strong>: It can be extended with various plugins and reporters to customize the <span class="No-Break">testing </span><span class="No-Break">setup.</span></li>
			</ul>
			<p>You can install it using the <strong class="source-inline">npm install --save-dev </strong><span class="No-Break"><strong class="source-inline">mocha</strong></span><span class="No-Break"> command.</span></p>
			<h3>Introducing Chai</h3>
			<p><strong class="bold">Chai</strong> is a <a id="_idIndexMarker918"/>popular<a id="_idIndexMarker919"/> assertion library that’s used with Node.js, often in combination with testing frameworks such as Mocha. It provides a variety of interfaces and styles for writing tests, making it flexible and easy <span class="No-Break">to use.</span></p>
			<p>It supports different assertion styles, two of which we’ll look <span class="No-Break">at here:</span></p>
			<ul>
				<li>The first and maybe the most used style is known as <strong class="bold">behavior-driven development</strong> (<strong class="bold">BDD</strong>). In this <a id="_idIndexMarker920"/>style, we have <strong class="source-inline">expect</strong> and <strong class="source-inline">should</strong> interfaces. They’re used for writing expressive and readable assertions. This style allows for natural language assertions, making tests easier <span class="No-Break">to understand.</span></li>
				<li>The second style is <a id="_idIndexMarker921"/>known as <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>). The <strong class="source-inline">assert</strong> interface is used for writing classical unit test assertions. This style is more traditional and straightforward, which makes it suitable for developers familiar with <span class="No-Break">xUnit frameworks.</span></li>
			</ul>
			<p>We can install it using the <strong class="source-inline">npm install --save-dev </strong><span class="No-Break"><strong class="source-inline">chai</strong></span><span class="No-Break"> command.</span></p>
			<p>While Chai has many <a id="_idIndexMarker922"/>features, let’s understand three of the most relevant ones. The first feature we’ll look at<a id="_idIndexMarker923"/> is its <strong class="bold">plugins</strong>. Chai has a rich ecosystem of plugins that extend its functionality. Popular plugins include <strong class="source-inline">chai-as-promised</strong> for promise assertions and <strong class="source-inline">chai-http</strong> for HTTP assertions. The second key feature is <strong class="bold">extensibility</strong>. Chai <a id="_idIndexMarker924"/>can be extended to create custom assertions using its plugin API. This allows developers to add domain-specific language to their tests On the other hand, Chai has a cool feature known as readable and expressive syntax. Chai’s BDD-style assertions are designed <a id="_idIndexMarker925"/>to be readable and expressive, making tests easier to write and understand. Finally, Chai also <strong class="bold">integrates</strong> seamlessly <a id="_idIndexMarker926"/>with Mocha, providing a powerful combination for writing and <span class="No-Break">running tests.</span></p>
			<h3>Introducing Sinon</h3>
			<p><strong class="bold">Sinon</strong> is another<a id="_idIndexMarker927"/> powerful<a id="_idIndexMarker928"/> library for testing in JavaScript that’s particularly useful for creating spies, stubs, and mocks to control and monitor the behavior of functions. It’s especially valuable in unit testing to isolate the code under test from its dependencies, ensuring that the tests focus on the specific functionality <span class="No-Break">being tested.</span></p>
			<p>Before we learn how to implement unit tests, let’s take a look at some of the key features <span class="No-Break">of Sinon:</span></p>
			<ul>
				<li><strong class="bold">Spies</strong>: Track and <a id="_idIndexMarker929"/>monitor the behavior <span class="No-Break">of functions.</span></li>
				<li><strong class="bold">Stubs</strong>: Replace functions with <span class="No-Break">predefined behaviors.</span></li>
				<li><strong class="bold">Mocks</strong>: Create fake objects with expectations for <span class="No-Break">their behavior.</span></li>
				<li><strong class="bold">Fakes</strong>: Combine the behavior of spies and stubs for simpler <span class="No-Break">use cases.</span></li>
				<li><strong class="bold">Timers</strong>: Control and simulate the passage of time <span class="No-Break">in tests.</span></li>
				<li><strong class="bold">XHR and Fetch</strong>: Simulate <strong class="source-inline">XMLHttpRequest</strong> and the Fetch API to test <span class="No-Break">AJAX requests.</span></li>
			</ul>
			<p>We can install it using the <strong class="source-inline">npm install --save-dev sinon</strong> command. Sinon can mock functions, HTTP<a id="_idIndexMarker930"/> requests, and more, making it ideal for <span class="No-Break">unit testing.</span></p>
			<p class="callout-heading">Other packages in Node.js</p>
			<p class="callout">Along with <strong class="source-inline">Chai</strong>, we have other<a id="_idIndexMarker931"/> popular assertion libraries such as Jest. <strong class="bold">Jest</strong> has its own <a id="_idIndexMarker932"/>assertion library, which is fully integrated and optimized for use <span class="No-Break">with Jest.</span></p>
			<p class="callout">When implementing unit tests, we also need mocking and stubbing libraries. In unit testing, mocks and stubs are used to isolate the unit of code being tested by simulating the behavior of dependencies. This allows you to test the functionality of a specific unit without having to rely on external components, such as databases, network services, or <span class="No-Break">other modules.</span></p>
			<p class="callout">Along with <strong class="source-inline">Sinon</strong>, we use<a id="_idIndexMarker933"/> the <strong class="bold">Testdouble</strong> library. <strong class="source-inline">Testdouble</strong> is a minimal, standalone test double library for JavaScript. You can use the <strong class="source-inline">npm install --save-dev testdouble</strong> command to install it. Testdouble provides tools for creating, using, and verifying test doubles <span class="No-Break">in JavaScript.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>What should we test in unit testing?</h2>
			<p>Before implementing unit<a id="_idIndexMarker934"/> tests in our project, we need to answer one simple question: what should we unit test? Let’s take <span class="No-Break">a look:</span></p>
			<ul>
				<li><strong class="bold">Business logic</strong>: This is the most critical part to test. Business logic includes the rules and operations that dictate how data is transformed, manipulated, and controlled. It ensures the application behaves correctly under <span class="No-Break">various conditions.</span></li>
				<li><strong class="bold">Edge cases</strong>: Test the boundaries and limits of your application. This includes checking how the application handles unexpected, extreme, or <span class="No-Break">invalid inputs.</span></li>
				<li><strong class="bold">Error handling</strong>: Ensure that the application responds correctly to error conditions, such as invalid input or <span class="No-Break">failed operations.</span></li>
				<li><strong class="bold">State transitions</strong>: If the application involves state changes (such as a status update), make sure these transitions occur <span class="No-Break">as expected.</span></li>
				<li><strong class="bold">Return values</strong>: Verify that functions return the correct values for <span class="No-Break">given inputs.</span></li>
				<li><strong class="bold">Dependencies and interactions</strong>: While unit tests should ideally test a unit in isolation, it’s important to mock dependencies and verify interactions between components to ensure they <span class="No-Break">collaborate correctly.</span></li>
			</ul>
			<p>Now that we know what<a id="_idIndexMarker935"/> we should test, it’s time to implement unit testing so that we can see it <span class="No-Break">in practice.</span></p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor203"/>Implementing unit tests for the account microservice</h1>
			<p>A copy of the <a id="_idIndexMarker936"/>source code for <a href="B09148_07.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> can be <a id="_idIndexMarker937"/>found in the <strong class="source-inline">Ch12</strong> folder of this book’s GitHub repository. This chapter will demonstrate how to test different microservices. We’ll start with the <span class="No-Break">account microservice.</span></p>
			<p>Create a new folder at the same level as the <strong class="source-inline">src</strong> folder and name it <strong class="source-inline">tests</strong>. Our main focus here is to test the <strong class="source-inline">src/services/account.js</strong> file. It contains the main logic and the required business rules that are implemented in <span class="No-Break">our application.</span></p>
			<p>Next, create a file called <strong class="source-inline">accountservice.test.mjs</strong> under the <strong class="source-inline">tests</strong> folder. Why the <strong class="source-inline">.mjs</strong> extension? This extension is used in Node.js projects to indicate that a JavaScript file should be treated as<a id="_idIndexMarker938"/> an <strong class="bold">ECMAScript</strong> (<strong class="bold">ES</strong>) module. This distinction is important because JavaScript supports two module systems: <em class="italic">CommonJS</em> and <em class="italic">ES modules</em>. Each has different syntax and behaviors. ES modules use <strong class="source-inline">import</strong> and <strong class="source-inline">export</strong> syntax. By using <strong class="source-inline">.mjs</strong>, Node.js can unambiguously determine that the file should be treated as an ES module, even if it exists alongside <strong class="source-inline">CommonJS</strong> files with a <strong class="source-inline">.js</strong> extension. This avoids confusion and potential conflicts, especially in projects that use both module systems. Using <strong class="source-inline">.mjs</strong> makes it explicit to developers and tools that the file is an ES module, helping them avoid making mistakes <span class="No-Break">and misconfigurations.</span></p>
			<p>Simply put, using the <strong class="source-inline">.mjs</strong> extension in Node.js projects helps separate ES modules from CommonJS modules. This ensures Node.js handles them correctly and keeps your code compatible with modern JavaScript standards. By using <strong class="source-inline">.mjs</strong>, you can simplify your module setup and make your code more future proof as JavaScript continues <span class="No-Break">to evolve.</span></p>
			<p>We plan to implement unit tests for the <strong class="source-inline">account.js</strong> file, which can be found in the <strong class="source-inline">src / </strong><span class="No-Break"><strong class="source-inline">services</strong></span><span class="No-Break"> folder.</span></p>
			<p>We have multiple functions inside this service. First, let’s consider some unit tests for the <strong class="source-inline">getAccountById</strong> function. Here’s the <span class="No-Break">original function:</span></p>
			<pre class="source-code">
function getAccountById(id) {
    return Account.findById(id);
}</pre>			<p>From an<a id="_idIndexMarker939"/> implementation <a id="_idIndexMarker940"/>perspective, we haven’t implemented valid exception handling. We <em class="italic">throw</em> the same exception from the database layer to the API layer directly. It’s generally better to handle exceptions either at the lowest level (database layer) or at the highest level (API layer). <em class="italic">Lower layers</em> should primarily focus on detecting and throwing exceptions when unexpected conditions arise. This maintains a clean separation of concerns and prevents lower layers from exposing implementation details. Some exceptions, such as database connection failures or file read/write errors, might require immediate handling at the lowest level to prevent data corruption or resource leaks. For instance, if a file write operation fails due to a full disk, handling the exception at this level can prevent further issues. If the exception is expected and can be handled within the lower layer without exposing internal details, it’s reasonable to do so. A centralized error-handling mechanism at the highest layer can provide consistent error management across <span class="No-Break">the application.</span></p>
			<p>First, let’s install the required packages. To do so, run the <strong class="source-inline">npm install --save-dev mocha chai sinon</strong> command. After installation, we’ll have the following <strong class="source-inline">devDependencies</strong> section in the <span class="No-Break"><strong class="source-inline">package.json</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
"devDependencies": {
    "chai": "^5.1.1",
    "mocha": "^10.7.0",
    «sinon": "^18.0.0"
  }</pre>			<p>Now, it’s time to import the necessary packages <span class="No-Break">and functionalities:</span></p>
			<pre class="source-code">
import * as chai from 'chai';
import sinon from 'sinon';
const expect = chai.expect;
import * as accountService from '../src/services/account.js';
import account from '../src/models/account.js'
const { errorCodes } = accountService.default;</pre>			<p>What should we test in <a id="_idIndexMarker941"/>our <a id="_idIndexMarker942"/>account service? The first function that needs to be tested is <strong class="source-inline">getAccountById</strong>. We should check whether the function will return the exact account information if the given account exists in our database. Here’s our first <span class="No-Break">test case:</span></p>
			<pre class="source-code">
describe('getAccountById service', () =&gt; {
    let findByIdStub;
    beforeEach(() =&gt; {
        findByIdStub = sinon.stub(account, 'findById');
    });
    afterEach(async () =&gt; {
        await findByIdStub.restore();
    });
    it('should return the account if found by id', async () =&gt; {
        const expectedAccountId = '12345';
        const expectedAccount = { name: 'Test Account', 
          number: '123-456-7890' };
        findByIdStub.withArgs(expectedAccountId)
          .resolves(expectedAccount);
        const account = await accountService
          .getAccountById(expectedAccountId);
        expect(account).to.deep.equal(expectedAccount);
        expect(findByIdStub.calledOnceWith(expectedAccountId))
          .to.be.true;
    });
});</pre>			<p>Well, this code may <a id="_idIndexMarker943"/>seem<a id="_idIndexMarker944"/> a little bit complicated at first glance, but the detailed explanation provided in this section will help you understand it <span class="No-Break">with ease.</span></p>
			<p>In Mocha, the <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> blocks are fundamental structures that are used to write and <span class="No-Break">organize tests.</span></p>
			<p>The <strong class="source-inline">describe</strong> block is used to group related test cases. It helps organize tests into logical sections, making them easier to read and understand. It’s typically used to group tests related to a particular feature or function. The <strong class="source-inline">describe</strong> block has <span class="No-Break">two parameters:</span></p>
			<ul>
				<li><strong class="source-inline">description</strong>: A string that describes the group of tests. This description will appear in the <span class="No-Break">test’s output.</span></li>
				<li><strong class="source-inline">function</strong>: A callback function that contains the test cases (using it blocks) and any <span class="No-Break">setup/teardown logic.</span></li>
			</ul>
			<p>The <strong class="source-inline">it</strong> block is used to define individual test cases. Each <strong class="source-inline">it</strong> block represents a single test that performs a specific assertion or set <span class="No-Break">of assertions.</span></p>
			<p>You can nest <strong class="source-inline">describe</strong> blocks to create a hierarchical structure for your tests, making it easier to organize and understand complex test suites. Here’s an example <span class="No-Break">of this:</span></p>
			<pre class="source-code">
describe('Math operations', function() {
  describe('Addition', function() {
    it('should add two numbers correctly', function() {
      expect(1 + 1).to.equal(2);
    });
  });
  describe('Subtraction', function() {
    it('should subtract two numbers correctly', function()
    {
      expect(2 - 1).to.equal(1);
    });
  });
});</pre>			<p>In practice, you <a id="_idIndexMarker945"/>typically<a id="_idIndexMarker946"/> use <strong class="source-inline">describe</strong> to group tests by the feature or unit of code being tested and <strong class="source-inline">it</strong> to define the specific behaviors you expect from <span class="No-Break">that code.</span></p>
			<p>Let’s get back to our example. Our code snippet describes a unit test for a service function called <strong class="source-inline">getAccountById</strong>. The test uses a mocking library called <strong class="source-inline">Sinon</strong> to simulate the behavior of a function named <strong class="source-inline">findById</strong> within the <span class="No-Break">account module.</span></p>
			<p>In simpler terms, this test checks whether the <strong class="source-inline">getAccountById</strong> service function correctly retrieves an account by its ID using the <strong class="source-inline">findById</strong> function. It ensures that the service returns the expected account data when the ID <span class="No-Break">is found.</span></p>
			<p>Here’s a line-by-line explanation of our first <span class="No-Break">unit test:</span></p>
			<ul>
				<li><em class="italic">Line 1</em> declares <a id="_idIndexMarker947"/>a test suite named <strong class="source-inline">getAccountById service</strong>. The function that’s passed to <strong class="source-inline">describe</strong> will contain the test cases related to <span class="No-Break"><strong class="source-inline">getAccountById service</strong></span><span class="No-Break">.</span></li>
				<li><em class="italic">Line 2</em> declares the <strong class="source-inline">findByIdStub</strong> variable, which will be used later to hold the stub created <span class="No-Break">by Sinon.</span></li>
				<li><em class="italic">Line 3</em> sets up a function to run before each test case within this <span class="No-Break"><strong class="source-inline">describe</strong></span><span class="No-Break"> block.</span></li>
				<li>Inside the <strong class="source-inline">beforeEach</strong> function in <em class="italic">Line 4</em>, <strong class="source-inline">Sinon</strong> creates a stub for the <strong class="source-inline">findById</strong> method of the <strong class="source-inline">account</strong> model. This stub will replace the original <strong class="source-inline">findById</strong> method, allowing us to control its behavior <span class="No-Break">during tests.</span></li>
				<li><em class="italic">Line 7</em> sets up a function to run after each test case within this <span class="No-Break"><strong class="source-inline">describe</strong></span><span class="No-Break"> block.</span></li>
				<li>Inside the <strong class="source-inline">afterEach</strong> function in <em class="italic">Line 8</em>, the <strong class="source-inline">restore</strong> method is called on <strong class="source-inline">findByIdStub</strong>. This restores the original <strong class="source-inline">findById</strong> method of the account model, ensuring that <a id="_idIndexMarker948"/>stubs<a id="_idIndexMarker949"/> don’t affect <span class="No-Break">other tests.</span></li>
				<li><em class="italic">Line 11</em> declares a test case with a description of <strong class="source-inline">should return the account if found by id</strong>. The function that’s passed to it contains the <span class="No-Break">test logic.</span></li>
				<li><em class="italic">Line 12</em> declares a constant, <strong class="source-inline">expectedAccountId</strong>, and assigns it a value of <strong class="source-inline">'12345'</strong>. This is the ID that will be used to search for <span class="No-Break">the account.</span></li>
				<li><em class="italic">Line 13</em> declares a constant, <strong class="source-inline">expectedAccount</strong>, and assigns it a mock account object. This is the account that the stubbed <strong class="source-inline">findById</strong> method <span class="No-Break">will return.</span></li>
				<li><em class="italic">Line 14</em> sets up <strong class="source-inline">findByIdStub</strong> to resolve (return a promise that resolves to) <strong class="source-inline">expectedAccount</strong> when it’s called with <strong class="source-inline">expectedAccountId</strong>. This simulates the behavior of finding an account in <span class="No-Break">the database.</span></li>
				<li><em class="italic">Line 15</em> calls the <strong class="source-inline">getAccountById</strong> service function with <strong class="source-inline">expectedAccountId</strong> and awaits its result. The result is assigned to the <span class="No-Break">account variable.</span></li>
				<li><em class="italic">Line 16</em> asserts that the account that’s returned by the service function is deeply equal to <strong class="source-inline">expectedAccount</strong>. Deep equality checks that all properties of the objects <span class="No-Break">are equal.</span></li>
				<li><em class="italic">Line 17</em> asserts that <strong class="source-inline">findByIdStub</strong> was called exactly once with <strong class="source-inline">expectedAccountId</strong>. This <a id="_idIndexMarker950"/>verifies that the service function attempted to find the account by the <span class="No-Break">correct ID.</span></li>
			</ul>
			<p>Here are the next few <a id="_idIndexMarker951"/>unit<a id="_idIndexMarker952"/> tests inside the same <span class="No-Break"><strong class="source-inline">describe</strong></span><span class="No-Break"> block:</span></p>
			<pre class="source-code">
describe('getAccountById service', () =&gt; {
    .........
    .........
    it('should return null if account not found', async () =&gt; {
        const expectedAccountId = '54321';
        findByIdStub.withArgs(expectedAccountId).resolves(null);
        const account = await accountService
          .getAccountById(expectedAccountId);
        expect(account).to.be.null;
        expect(findByIdStub.calledOnceWith(expectedAccountId))
          .to.be.true;
    });
    it('should rethrow errors from findById', async () =&gt; {
        const expectedAccountId = '98765';
        const expectedError = new Error('Database error');
        findByIdStub.withArgs(expectedAccountId)
          .rejects(expectedError);
        try {
            await accountService.getAccountById(expectedAccountId);
        } catch (error) {
            expect(error).to.equal(expectedError);
            expect(findByIdStub.calledOnceWith(expectedAccountId))
              .to.be.true;
        }  }); });</pre>			<p>In this unit test <a id="_idIndexMarker953"/>suite, two <a id="_idIndexMarker954"/>test cases have been defined for the <span class="No-Break"><strong class="source-inline">getAccountById</strong></span><span class="No-Break"> service:</span></p>
			<ul>
				<li>The first test case, named <strong class="source-inline">should return null if account not found</strong>, sets up a scenario where the account with an ID of <strong class="source-inline">'54321'</strong> doesn’t exist. Here, <strong class="source-inline">findByIdStub</strong> is configured to return <strong class="source-inline">null</strong> when called with this ID. The test then calls <strong class="source-inline">getAccountById</strong> with <strong class="source-inline">'54321'</strong> and expects the result to be <strong class="source-inline">null</strong>. It also verifies that <strong class="source-inline">findByIdStub</strong> was called exactly once <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">'54321'</strong></span><span class="No-Break">.</span></li>
				<li>The second test case, named <strong class="source-inline">should rethrow errors from findById</strong>, tests the behavior when the <strong class="source-inline">findById</strong> method throws an error. Here, <strong class="source-inline">findByIdStub</strong> is set up to throw <strong class="source-inline">Database error</strong> when called with ID <strong class="source-inline">'98765'</strong>. The test calls <strong class="source-inline">getAccountById</strong> and expects the call to throw the same error. This is verified using a try-catch block, where it’s checked that the caught error is equal to the expected error. Additionally, it verifies that <strong class="source-inline">findByIdStub</strong> was called exactly once with <strong class="source-inline">'98765'</strong>. These tests ensure that the <strong class="source-inline">getAccountById</strong> service correctly handles cases where the account isn’t found and when errors occur during database access. Please keep in mind that rethrowing errors should include meaningful handling, such as logging or adding additional context to <span class="No-Break">the error.</span></li>
			</ul>
			<p>Other tests except <strong class="source-inline">updateAccountById</strong> follow approximately the same testing style. In a given service, the most complex implementation exists inside the <strong class="source-inline">updateAccountById</strong> function. Please refer to <a href="B09148_05.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> to learn more about the <strong class="source-inline">Account</strong> microservice and its <span class="No-Break">business cases.</span></p>
			<p>We should cover every<a id="_idIndexMarker955"/> business<a id="_idIndexMarker956"/> rule that’s implemented in our original functionality. Here’s the first condition that we need to cover when updating <span class="No-Break">the account:</span></p>
			<pre class="source-code">
async function updateAccountById(id, { name, number, type, status }) {
    if (!name &amp;&amp; !number &amp;&amp; !type &amp;&amp; !status) {
        return { error: 'provide at least one valid data to be updated', code: NO_VALID_DATA_TO_UPDATE };
    }
  ........
}</pre>			<p>This function ensures that an account update is meaningful by requiring at least one valid piece of information (name, number, type, or status) to be provided. If none are given, it returns an error, to enforce the business rule of avoiding <span class="No-Break">invalid updates.</span></p>
			<p>Here’s the unit <span class="No-Break">test fragment:</span></p>
			<pre class="source-code">
describe('updateAccountById service', () =&gt; {
    let findByIdStub, saveStub;
    beforeEach(() =&gt; {
        findByIdStub = sinon.stub(account, 'findById');
        saveStub = sinon.stub(account.prototype, 'save');
    });
    afterEach(async () =&gt; {
        await findByIdStub.restore();
        await saveStub.restore();
    });
    it('should return error for no data to update', async () =&gt; {
        const id = '12345';
        const updateData = {};
        const result = await accountService.updateAccountById(id, 
          updateData);
        expect(result).to.deep.equal({
            error: 'provide at least one valid data to be updated',
            code: errorCodes.NO_VALID_DATA_TO_UPDATE,
        });
           expect(findByIdStub.calledOnceWith(id)).to.be.false;
        expect(saveStub.calledOnce).to.be.false;
    });
    ......
    ....... });</pre>			<p>The preceding code snippet <a id="_idIndexMarker957"/>describes<a id="_idIndexMarker958"/> a unit test for a service function called <strong class="source-inline">updateAccountById</strong>. This function is responsible for updating an account based on a given ID and update data. The test employs <strong class="source-inline">Sinon</strong> to substitute the behavior of the <strong class="source-inline">findById</strong> and <strong class="source-inline">save</strong> methods within the <span class="No-Break">account module.</span></p>
			<p>Before each test case, <strong class="source-inline">Sinon</strong> stubs are established for both the <strong class="source-inline">findById</strong> and <strong class="source-inline">save</strong> methods to enable controlled test scenarios. After each test, these stubs are restored to their <span class="No-Break">original state.</span></p>
			<p>The specific test case focuses on validating the error handling process when no update data is provided. It constructs an account ID and an empty update object. Subsequently, it invokes the <strong class="source-inline">updateAccountById</strong> service with these parameters and captures the result <span class="No-Break">that’s returned.</span></p>
			<p>The test then asserts that the returned result is an error object containing a specific error message and code, indicating the absence of valid update data. To ensure the correct behavior, it further verifies that neither the <strong class="source-inline">findById</strong> nor the <strong class="source-inline">save</strong> method was called as no account retrieval or update was necessary in <span class="No-Break">this scenario.</span></p>
			<p>Long story short, this unit test guarantees that the <strong class="source-inline">updateAccountById</strong> service correctly handles cases where no update data is supplied, returning an appropriate error response without performing <span class="No-Break">unnecessary operations.</span></p>
			<p>The next piece of<a id="_idIndexMarker959"/> logic <a id="_idIndexMarker960"/>in the <strong class="source-inline">updateAccountById</strong> function is defined <span class="No-Break">like this:</span></p>
			<pre class="source-code">
async function updateAccountById(id, { name, number, type, status }) {
 ......
 if (status &amp;&amp; !(status in availableAccountStatusesForUpdate)) {
        return { error: 'invalid status for account', code: INVALID_STATUS_CODE };   }
  ......
}</pre>			<p>The preceding code snippet indicates that if the status isn’t part of the allowed statuses defined by the business rules, it returns an error message, preventing the update with an invalid or unsupported status. This ensures that only acceptable status changes are made, maintaining business consistency and <span class="No-Break">data integrity.</span></p>
			<p>The following unit test validates error handling for invalid <span class="No-Break">status updates:</span></p>
			<pre class="source-code">
it('should return error for invalid status update', async () =&gt; {
        const id = '12345';
        const updateData = { status: 'invalid_status' };
        const result = await accountService.updateAccountById(id, 
          updateData);
        expect(result).to.deep.equal({
            error: 'invalid status for account',
            code: errorCodes.INVALID_STATUS_CODE,
        });
        expect(findByIdStub.calledOnceWith(id)).to.be.false;
        expect(saveStub.calledOnce).to.be.false;
    });</pre>			<p>The preceding unit test verifies error handling for invalid status updates in the <strong class="source-inline">updateAccountById</strong> service. It simulates an update with an invalid status. The test expects an error object with specific details when the service encounters this invalid input. To isolate the <a id="_idIndexMarker961"/>test, stubs<a id="_idIndexMarker962"/> prevent database interactions. By asserting the correct error, the test ensures the service behaves as expected when faced with <span class="No-Break">incorrect data.</span></p>
			<p>Using the same approach we implemented for the preceding unit tests, we can test all the possible cases for our services. For more complete implementation, check out this book’s GitHub repository and the respective folder for <span class="No-Break">this chapter.</span></p>
			<p>To run unit tests, navigate to the root folder from the command line (for us, this is the <strong class="source-inline">Ch12</strong>/<strong class="source-inline">accountservice</strong> folder) and run the <span class="No-Break">following command:</span></p>
			<pre class="console">
npx mocha .\tests\accountservice.tests.mjs</pre>			<p>Here’s <span class="No-Break">the result:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer113">
					<img alt="Figure 12.1: Results of the test run" src="image/B09148_12_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Results of the test run</p>
			<p>With that, we’ve demonstrated how to write tests for the Express.js project. The same unit testing logic is <a id="_idIndexMarker963"/>the <a id="_idIndexMarker964"/>same for Nest.js applications. You can easily apply the aforementioned ideas to your <span class="No-Break">Nest.js applications.</span></p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor204"/>Writing unit tests for the transaction microservice</h1>
			<p>Now, it’s time to<a id="_idIndexMarker965"/> demonstrate how easily you can <a id="_idIndexMarker966"/>write unit tests for your Nest.js applications. In this book’s GitHub repository, in the <strong class="source-inline">Ch12</strong> folder, we have the same transaction service we implemented in <a href="B09148_07.xhtml#_idTextAnchor121"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>
			<p>Open the <strong class="source-inline">transaction.service.spec.ts</strong> file, which can be found in the <strong class="source-inline">src/test</strong> folder. It contains all the essential tests to help us understand how to write unit tests. If you want to follow along and implement everything from scratch, just create a folder named <strong class="source-inline">test</strong> inside the <span class="No-Break"><strong class="source-inline">src</strong></span><span class="No-Break"> folder.</span></p>
			<p>First things first, we need to install the required packages to implement unit testing for our project. To write unit tests for <strong class="source-inline">transaction.service.js</strong>, we need to install the <strong class="source-inline">@nestjs/</strong><strong class="source-inline">testing</strong> package. Here’s how you can <span class="No-Break">do it:</span></p>
			<pre class="console">
npm install --save-dev jest @nestjs/testing</pre>			<p>Once it’s been installed, create a file called <strong class="source-inline">transaction.service.spec.ts</strong>.  First, we need to import the <span class="No-Break">required references:</span></p>
			<pre class="source-code">
import { Test, TestingModule } from '@nest.js/testing';
import { TransactionService } from '../transaction/transaction.service';
import { PrismaService } from '../prisma/prisma.service';
import { HttpService } from '@nest.js/axios';
import { KafkaService } from '../kafka/kafka.service';
import { CreateTransactionDto } from '../transaction/dto/create-transaction.dto';</pre>			<p>The preceding <a id="_idIndexMarker967"/>code <a id="_idIndexMarker968"/>imports the necessary services for testing: <strong class="source-inline">TransactionService</strong> handles transaction logic, <strong class="source-inline">PrismaService</strong> interacts with the database, <strong class="source-inline">HttpService</strong> handles external HTTP requests, <strong class="source-inline">KafkaService</strong> performs message handling, and <strong class="source-inline">CreateTransactionDto</strong> defines the structure of transaction data. The <strong class="source-inline">Test</strong> and <strong class="source-inline">TestingModule</strong> imports are from the Nest.js testing module and are used to create a testing environment <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">TransactionService</strong></span><span class="No-Break">.</span></p>
			<p>Here’s what a simple unit test <span class="No-Break">looks like:</span></p>
			<pre class="source-code">
describe('TransactionService', () =&gt; {
  let service: TransactionService;
  let prismaService: PrismaService;
  let httpService: HttpService;
  let kafkaService: KafkaService;
  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransactionService,
        {
          provide: PrismaService,
          useValue: {
            transaction: {
              create: jest.fn(),
              findMany: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
            },
          },
        },
        {
          provide: HttpService,
          useValue: {
            axiosRef: {
              get: jest.fn(),
            },
          },
        },
        {
          provide: KafkaService,
          useValue: {
            send: jest.fn(),
          },
        },
      ],
    }).compile();</pre>			<p>We already know about the <strong class="source-inline">describe</strong> block and its role in unit testing. The preceding code snippet establishes a testing environment for <strong class="source-inline">TransactionService</strong>. It begins by importing the necessary modules and services: <strong class="source-inline">TransactionService</strong>, <strong class="source-inline">PrismaService</strong> for database interactions, <strong class="source-inline">HttpService</strong> for external requests, <strong class="source-inline">KafkaService</strong> for message handling, and <strong class="source-inline">CreateTransactionDto</strong> for <span class="No-Break">data transfer.</span></p>
			<p>A <strong class="source-inline">describe</strong> block encapsulates the tests for <strong class="source-inline">TransactionService</strong>. Inside, variables are declared to hold instances of the services. The <strong class="source-inline">beforeEach</strong> block sets up the testing module using <strong class="source-inline">Test.createTestingModule</strong>. It provides mock implementations for <strong class="source-inline">PrismaService</strong>, <strong class="source-inline">HttpService</strong>, and <strong class="source-inline">KafkaService</strong> to isolate <strong class="source-inline">TransactionService</strong> during testing. The <strong class="source-inline">PrismaService</strong> mock includes methods such as <strong class="source-inline">create</strong>, <strong class="source-inline">findMany</strong>, <strong class="source-inline">findUnique</strong>, and <strong class="source-inline">update</strong> to simulate database operations. If you open <strong class="source-inline">transaction.service.ts</strong>, you’ll realize that we use these methods to implement the functionalities of the transaction service. Similarly, the <strong class="source-inline">HttpService</strong> and <strong class="source-inline">KafkaService</strong> mocks mimic their respective functionalities using Jest’s <strong class="source-inline">jest.fn()</strong>. This setup allows for controlled testing of <strong class="source-inline">TransactionService</strong> without the need to rely on actual <span class="No-Break">external dependencies.</span></p>
			<p>Here, <strong class="source-inline">jest.fn()</strong> is a function<a id="_idIndexMarker969"/> provided by Jest, a popular<a id="_idIndexMarker970"/> JavaScript testing framework, to create mock functions. A mock function is essentially a dummy function that can be used to replace real functions during testing. There are a lot of benefits and values to using such types of functionalities in unit testing. Here are the benefits of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">jest.fn()</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="bold">Isolation</strong>: It allows us to<a id="_idIndexMarker971"/> isolate the component or function you’re testing by replacing dependencies with mock functions. This helps us focus on the specific behavior of the code under test without being affected by <span class="No-Break">external factors.</span></li>
				<li><strong class="bold">Verifiability</strong>: We can assert how many times the mock function was called, with what arguments, and what it returned. This helps in verifying the correct behavior of <span class="No-Break">the code.</span></li>
				<li><strong class="bold">Custom implementation</strong>: We can define the behavior of the mock function using mock implementation to control its return value <span class="No-Break">or actions.</span></li>
			</ul>
			<p>By using <strong class="source-inline">jest.fn()</strong>, we can <a id="_idIndexMarker972"/>effectively test different scenarios and edge cases without relying on the actual implementation of the <span class="No-Break">mocked function:</span></p>
			<pre class="source-code">
    service = module.get&lt;TransactionService&gt;(TransactionService);
    prismaService = module.get&lt;PrismaService&gt;(PrismaService);
    httpService = module.get&lt;HttpService&gt;(HttpService);
    kafkaService = module.get&lt;KafkaService&gt;(KafkaService);</pre>			<p>The <strong class="source-inline">module.get</strong> method is used to access the providers that were defined in the <strong class="source-inline">TestingModule</strong> setup. It takes the service class as an argument and returns an instance of that service. By calling <strong class="source-inline">module.get</strong> for each service (<strong class="source-inline">TransactionService</strong>, <strong class="source-inline">PrismaService</strong>, <strong class="source-inline">HttpService</strong>, and <strong class="source-inline">KafkaService</strong>), the<a id="_idIndexMarker973"/> code <a id="_idIndexMarker974"/>obtains references to these services, which can then be used for <span class="No-Break">testing purposes.</span></p>
			<p>These service instances are typically used within the test cases to interact with the system under test and verify <span class="No-Break">its behavior.</span></p>
			<p>First, let’s start with a simple <span class="No-Break">test case:</span></p>
			<pre class="source-code">
 it(‹should be defined', () =&gt; {
    expect(service).toBeDefined();
  });</pre>			<p>This code snippet defines a basic test case to ensure the service instance is <span class="No-Break">injected correctly.</span></p>
			<p>The <strong class="source-inline">it('should be defined', () =&gt; { ... })</strong> block creates a test case with a description of <strong class="source-inline">should be defined</strong> Inside this block, the <strong class="source-inline">expect(service).toBeDefined();</strong> assertion checks whether the <strong class="source-inline">service</strong> variable has a defined value. This is a fundamental test to verify that the dependency injection process has successfully provided an instance of <strong class="source-inline">TransactionService</strong>. If the service is <strong class="source-inline">null</strong> or <strong class="source-inline">undefined</strong>, the test <span class="No-Break">will fail.</span></p>
			<p>Essentially, this test case acts as a sanity check to ensure the testing environment has been set up correctly before we proceed with more complex test scenarios. Now, let’s switch to testing the<a id="_idIndexMarker975"/> transaction <a id="_idIndexMarker976"/><span class="No-Break">creation process:</span></p>
			<pre class="source-code">
describe('create', () =&gt; {
    it('should create a transaction with status CREATED if account status is new or active', async () =&gt; {
      const createTransactionDto: CreateTransactionDto = {
        accountId: '1',
        description: 'Test transaction',
      };
      const accountApiResponse = {
        data: {
          account: {
            id: '1',
            status: 'active',
          },
        },
      };
      jest.spyOn(httpService.axiosRef, 'get').mockResolvedValue(accountApiResponse);
      jest.spyOn(prismaService.transaction, 'create').mockResolvedValue({
        id: 1,
        accountId: '1',
        description: 'Test transaction',
        status: 'CREATED',
        createdAt: new Date(),
        updatedAt: new Date(),
      });
      const result = await service.create(createTransactionDto);
      expect(result).toEqual(expect.objectContaining({
        id: 1,
        accountId: '1',
        description: 'Test transaction',
        status: 'CREATED',
      }));
      expect(httpService.axiosRef.get).toHaveBeenCalledWith('http://localhost:3001/v1/accounts/1');
      expect(prismaService.transaction.create).toHaveBeenCalledWith({
        data: {
          accountId: '1',
          description: 'Test transaction',
          status: 'CREATED',
        }, }); });</pre>			<p>This test case aims <a id="_idIndexMarker977"/>to<a id="_idIndexMarker978"/> verify the <strong class="source-inline">create</strong> method of <strong class="source-inline">TransactionService</strong> under <span class="No-Break">specific conditions.</span></p>
			<p>It starts by defining a test scenario where the account status is either <strong class="source-inline">new</strong> or <strong class="source-inline">active</strong>. A <strong class="source-inline">CreateTransactionDto</strong> object is created with the necessary data. To simulate external dependencies, <strong class="source-inline">httpService</strong> and <strong class="source-inline">prismaService</strong> are mocked <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">jest.spyOn</strong></span><span class="No-Break">.</span></p>
			<p>Here, <strong class="source-inline">jest.spyOn</strong> is a function in Jest that’s used to create a spy on an existing function. Unlike <strong class="source-inline">jest.fn()</strong>, which creates a new mock function, <strong class="source-inline">jest.spyOn</strong> wraps an existing function to track calls and potentially modify <span class="No-Break">its behavior.</span></p>
			<p>We can use <strong class="source-inline">jest.spyOn</strong> to observe how a particular function is used within your code without altering its original implementation. It also records information about function calls, such as arguments, return values, and the number of times it was called. This is useful for verifying the interaction between different parts of <span class="No-Break">our code.</span></p>
			<p>While optional, we can change the behavior of the spied function. This is helpful when we want to control the output of the function for specific test cases. After testing, we can restore the original <span class="No-Break">function’s behavior.</span></p>
			<p>The <strong class="source-inline">httpService.axiosRef.get</strong> method is mocked to return a successful account response with an <strong class="source-inline">active</strong> status. The <strong class="source-inline">prismaService.transaction.create</strong> method is also mocked to return a created transaction with the <span class="No-Break"><strong class="source-inline">CREATE</strong></span><span class="No-Break"> status.</span></p>
			<p>The <strong class="source-inline">service.create</strong> method is then called with the prepared <strong class="source-inline">createTransactionDto</strong> object. The test asserts that the returned result matches the expected transaction data, indicating successful creation. Additionally, it verifies that <strong class="source-inline">httpService.axiosRef.get</strong> was called with the correct URL to fetch account information, and <strong class="source-inline">prismaService.transaction.create</strong> was called with the correct data to persist <span class="No-Break">the transaction.</span></p>
			<p>Essentially, this test <a id="_idIndexMarker979"/>case<a id="_idIndexMarker980"/> ensures that the <strong class="source-inline">create</strong> method interacts with <strong class="source-inline">httpService</strong> correctly to fetch account details, determines the transaction status based on account status, and persists the transaction to the database through <strong class="source-inline">prismaService</strong> with the expected data. By mocking dependencies, the test isolates the <strong class="source-inline">create</strong> method’s logic and verifies its behavior without relying on <span class="No-Break">external systems.</span></p>
			<p>It should now be easy for you to understand the rest of the unit tests that have been implemented inside our <span class="No-Break"><strong class="source-inline">transaction.service.spec.ts</strong></span><span class="No-Break"> file.</span></p>
			<p>When implementing unit tests, you may hear a lot about mocks, stubs, and spies. As our last topic regarding unit tests, let’s explore and understand <span class="No-Break">their responsibilities.</span></p>
			<p>To run all your tests, you simply need to run the <strong class="source-inline">npm test</strong> command (<span class="No-Break"><em class="italic">Figure 12</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></p>
			<p>There may be cases where tests fail to run properly. To resolve this, please refer to this book’s GitHub repository and ensure that the <strong class="source-inline">package-lock.json</strong> file matches the package versions specified in <span class="No-Break">the repository:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer114">
					<img alt="Figure 12.2: Running transaction tests" src="image/B09148_12_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: Running transaction tests</p>
			<p>As mentioned <a id="_idIndexMarker981"/>previously, we <a id="_idIndexMarker982"/>can use various building blocks for testing, such as mocks, stubs, and spies. Let’s try to understand and <span class="No-Break">differentiate them.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor205"/>Comparing mocks, stubs, and spies in unit tests</h1>
			<p>We’ll spend this section comparing mocks, stubs, and spies in unit tests because they’re essential tools for isolating and simulating components’ behaviors during testing. Understanding their differences will help us choose the right approach to test various interactions and functionalities in the <span class="No-Break">system effectively.</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor206"/>Mocks</h2>
			<p>A <strong class="bold">mock</strong> is a <a id="_idIndexMarker983"/>simulated object that replaces a real dependency in a <a id="_idIndexMarker984"/>unit test. It’s designed to mimic the behavior of the <a id="_idIndexMarker985"/>original object but with complete control over its actions. Why? This isolation allows for focused testing of the code under scrutiny without the need to rely on <span class="No-Break">external factors.</span></p>
			<p>We can define exact return values, exceptions, or sequences of actions for mock objects. This enables us to test various scenarios and edge cases. Mocks can record interactions, allowing us to verify that methods were called with correct arguments, in the right order, and with the expected frequency. By replacing real dependencies with mocks, we can create a controlled environment, preventing unexpected side effects and ensuring <span class="No-Break">test reliability.</span></p>
			<p>Let’s go over the benefits of <span class="No-Break">using mocks:</span></p>
			<ul>
				<li><strong class="bold">Improved test focus</strong>: Mocks<a id="_idIndexMarker986"/> help you concentrate on the logic of the code being tested, without being distracted by the intricacies of <span class="No-Break">external components.</span></li>
				<li><strong class="bold">Faster test execution</strong>: Since mocks don’t involve real interactions (such as database calls or network requests), tests run <span class="No-Break">significantly faster</span></li>
				<li><strong class="bold">Increased test coverage</strong>: Mocks allow you to test different scenarios and edge cases that might be difficult or impossible to reproduce in a <span class="No-Break">real environment.</span></li>
				<li><strong class="bold">Enhanced code reliability</strong>: By thoroughly testing code in isolation, you can identify and<a id="_idIndexMarker987"/> fix potential issues early in the <span class="No-Break">development</span><span class="No-Break"><a id="_idIndexMarker988"/></span><span class="No-Break"> process.</span></li>
			</ul>
			<p>Next, we’ll look <span class="No-Break">at stubs.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor207"/>Stubs</h2>
			<p>On the other <a id="_idIndexMarker989"/>hand, a <strong class="bold">stub</strong> is a<a id="_idIndexMarker990"/> simplified implementation of a <a id="_idIndexMarker991"/>component that’s used to replace a real component in a test. It provides canned answers to calls that are made during the test, focusing on the specific behavior needed for the <span class="No-Break">test case.</span></p>
			<p>A stub only contains the essential logic required for the test and returns predetermined values or exceptions. It typically doesn’t verify interactions or expectations. That is great, but when can you <span class="No-Break">use them?</span></p>
			<ul>
				<li>When you need to isolate the unit under test by providing <span class="No-Break">controlled </span><span class="No-Break">responses.</span></li>
				<li>When the behavior of the dependency isn’t critical to the <span class="No-Break">test </span><span class="No-Break">case.</span></li>
				<li>When you want to speed up test execution by avoiding <span class="No-Break">complex </span><span class="No-Break">logic.</span></li>
			</ul>
			<p>While both stubs and mocks are used to replace real components in tests, there’s a key difference. Stubs focus on providing predefined responses and don’t verify interactions, whereas mocks allow for more complex behavior, including expectations and <span class="No-Break">verifying interactions.</span></p>
			<p>In many cases, stubs <a id="_idIndexMarker992"/>can be sufficient for basic testing, but as<a id="_idIndexMarker993"/> test <a id="_idIndexMarker994"/>requirements become more complex, mocks offer greater flexibility <span class="No-Break">and control.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor208"/>Spies</h2>
			<p>A <strong class="bold">spy</strong> is a wrapper <a id="_idIndexMarker995"/>around an existing object or function <a id="_idIndexMarker996"/>that records <a id="_idIndexMarker997"/>information about how it’s used. Unlike stubs and mocks, which replace the original object, spies observe the behavior of the <span class="No-Break">real object.</span></p>
			<p>Here are some of the key characteristics <span class="No-Break">of spies:</span></p>
			<ul>
				<li><strong class="bold">Wrap real object</strong>: Spies <a id="_idIndexMarker998"/>can be created around existing objects <span class="No-Break">or functions.</span></li>
				<li><strong class="bold">Record interactions</strong>: They track method calls, arguments, and <span class="No-Break">return values.</span></li>
				<li><strong class="bold">Verify behavior</strong>: Spies are used to ensure that methods are called correctly and with the <span class="No-Break">expected parameters.</span></li>
			</ul>
			<p>You can use spies in the <span class="No-Break">following instances:</span></p>
			<ul>
				<li>When you want to verify that a specific method is called with <span class="No-Break">certain </span><span class="No-Break">arguments.</span></li>
				<li>When you need to check the sequence of <span class="No-Break">method </span><span class="No-Break">calls.</span></li>
				<li>When you want to observe the side effects of a function without controlling <span class="No-Break">its </span><span class="No-Break">behavior.</span></li>
			</ul>
			<p>While both spies and mocks can verify interactions, there’s a key difference – spies observe the behavior of the real object, whereas mocks replace the real object with a <span class="No-Break">simulated one.</span></p>
			<p>Additionally, stubs provide canned responses without verifying interactions. Mocks replace objects and allow for complex behavior and verification. On the other hand, spies observe the behavior of real objects without <span class="No-Break">modifying them.</span></p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor209"/>Understanding and implementing integration tests</h1>
			<p><strong class="bold">Integration tests</strong> are an <a id="_idIndexMarker999"/>important component of a robust testing strategy and focus on the interactions between different parts of your application. Unlike unit tests, which isolate individual components, integration tests evaluate how these components work together as a <span class="No-Break">cohesive system.</span></p>
			<p>In the context of Express.js, integration tests ensure that routes, controllers, models, and databases interact seamlessly. They verify that data flows correctly between these components and that the application produces the <span class="No-Break">expected outcomes.</span></p>
			<p>Why are integration tests essential? They help prevent integration issues, which can often be complex and time-consuming to debug. By testing the interactions between components, you can catch potential problems early in the development cycle, reducing the risk of unexpected behavior <span class="No-Break">in production.</span></p>
			<p>Integration tests aren’t a replacement for unit tests. Unit tests focus on the correctness of individual functions and modules, while integration tests verify how these components work together. A comprehensive testing strategy should include both unit and <span class="No-Break">integration tests.</span></p>
			<p>By investing time in writing effective integration tests, you can significantly improve the quality and reliability of your Express.js applications. They help prevent integration issues, increase confidence in your code base, and ultimately deliver a better <span class="No-Break">user experience.</span></p>
			<p>Integration testing in Node.js microservices focuses on verifying the interactions between different components or services. It ensures that these components work together seamlessly to deliver the <span class="No-Break">expected outcomes.</span></p>
			<p>Integration tests catch issues early in development, reducing production failures. By writing comprehensive integration tests, you encourage better code design and maintainability. Successful integration tests build confidence in the system’s <span class="No-Break">overall reliability.</span></p>
			<p>Before we move on, let’s understand the key aspects of integration testing <span class="No-Break">in microservices:</span></p>
			<ul>
				<li><strong class="bold">Testing boundaries</strong>: Integration tests primarily focus on the interfaces between microservices. They verify data exchange, contract adherence, and <span class="No-Break">error handling.</span></li>
				<li><strong class="bold">Dependency management</strong>: Effectively managing dependencies is essential. You might use mocking, stubbing, or test doubles to isolate components <span class="No-Break">for testing.</span></li>
				<li><strong class="bold">Data consistency</strong>: Integration tests should validate data integrity across different services. This includes testing data transformations, consistency checks, and <span class="No-Break">error handling.</span></li>
				<li><strong class="bold">Performance considerations</strong>: Integration tests can help identify performance bottlenecks and <span class="No-Break">scalability issues.</span></li>
			</ul>
			<p>Having said this, it’s also<a id="_idIndexMarker1000"/> important to understand exactly when you’d use integration testing. Let’s look at the instances when you would use <span class="No-Break">this here:</span></p>
			<ul>
				<li><strong class="bold">API interactions</strong>: Test how different microservices communicate through APIs, verifying request/response formats, error handling, <span class="No-Break">and </span><span class="No-Break">authentication.</span></li>
				<li><strong class="bold">Database interactions</strong>: Ensure data is stored, retrieved, and updated correctly across <span class="No-Break">multiple </span><span class="No-Break">services.</span></li>
				<li><strong class="bold">Message queues</strong>: Verify message delivery, processing, and error handling in asynchronous <span class="No-Break">communication </span><span class="No-Break">patterns.</span></li>
				<li><strong class="bold">External systems</strong>: Test interactions with external systems such as payment gateways, email services, or <span class="No-Break">third-party </span><span class="No-Break">APIs.</span></li>
			</ul>
			<p>Long story short, integration tests in Node.js microservices verify that different components or services interact correctly, ensuring seamless functionality and preventing complex issues in production. Now, let’s implement integration tests for the <span class="No-Break">transaction microservice.</span></p>
			<p>The purpose of this subsection is to show you how you can implement integration tests for your Node.js services, particularly for Nest.js. The general idea of integration testing applies to all types of applications, regardless of whether you use Express.js or <span class="No-Break">other frameworks.</span></p>
			<p>As always, we need to install the required package to write integration tests for our project. Go to <strong class="source-inline">Ch12/transactionservice</strong> and run the following command to install the <strong class="source-inline">jest</strong> and <span class="No-Break"><strong class="source-inline">supertest</strong></span><span class="No-Break"> packages:</span></p>
			<pre class="console">
npm install --save-dev jest @types/jest supertest @nestjs/testing</pre>			<p>We’ve already talked about the <strong class="source-inline">jest</strong> package. The <strong class="source-inline">supertest</strong> package is a high-level abstraction for testing HTTP servers. It makes it easy to send HTTP requests to your Nest.js application and inspect the responses, simulating real-world <span class="No-Break">client behavior.</span></p>
			<p>Nest.js provides excellent integration with both Jest and Supertest, making it straightforward to set up and run integration tests. You can test various aspects of your Nest.js application, including controllers, services, and database interactions. Integration tests can be included in your CI/CD pipeline so that you can catch issues early in the <span class="No-Break">development</span><span class="No-Break"><a id="_idIndexMarker1001"/></span><span class="No-Break"> process.</span></p>
			<p>Go to the root folder (<strong class="source-inline">Ch12/transactionservice</strong>) and create the <strong class="source-inline">jest.config.js</strong> file with the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
// jest.config.js
module.exports = {
    moduleFileExtensions: [
        'js',
        'json',
        'ts',
    ],
    rootDir: 'src',
    testRegex: '.*\\.spec\\.ts$',
    transform: {
        '^.+\\.(t|j)s$': 'ts-jest',
    },
    collectCoverageFrom: [
        '**/*.(t|j)s',
    ],
    coverageDirectory: '../coverage',
    testEnvironment: 'node',
    globalSetup: './test/global-setup.js',
    globalTeardown: './test/global-teardown.js',
};</pre>			<p>Let’s break down the <span class="No-Break">code here:</span></p>
			<ul>
				<li>The <strong class="source-inline">jest.config.js</strong> file is a configuration file that customizes Jest’s behavior. This particular configuration specifies that Jest should look for TypeScript, JavaScript, and JSON files (<strong class="source-inline">moduleFileExtensions</strong>). It sets the project root directory to <strong class="source-inline">src</strong>, defines test files as those ending with <strong class="source-inline">.spec.ts</strong>, and uses <strong class="source-inline">ts-jest</strong> to process TypeScript files. The configuration also enables code coverage reporting to <strong class="source-inline">../coverage</strong>, sets the test environment to Node.js, and executes <strong class="source-inline">global-setup.js</strong> before all tests and <span class="No-Break"><strong class="source-inline">global-teardown.js</strong></span><span class="No-Break"> after.</span></li>
				<li>Next, we have <strong class="source-inline">globalSetup</strong> and <strong class="source-inline">globalTeardown</strong> in our Jest configuration to execute code before and after the entire test suite <span class="No-Break">runs, respectively.</span></li>
				<li>Then, <strong class="source-inline">globalSetup</strong> runs once before all tests. It’s ideal for setting up resources such as databases, servers, or other external dependencies that are required for <span class="No-Break">the tests.</span></li>
				<li>Finally, <strong class="source-inline">globalTeardown</strong> runs once after all tests have been completed. It’s used to clean up resources that are created in <strong class="source-inline">globalSetup</strong>, such as closing database connections or <span class="No-Break">stopping servers.</span></li>
			</ul>
			<p>In the provided <a id="_idIndexMarker1002"/>configuration, the scripts for these operations are located in the <strong class="source-inline">./test/global-setup.js</strong> and <strong class="source-inline">./test/global-teardown.js</strong> files. However, we don’t have these files yet. So, let’s create them. Go to the <strong class="source-inline">test</strong> folder and create <span class="No-Break">both files.</span></p>
			<p>Here’s our <span class="No-Break"><strong class="source-inline">global-setup</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
const { execSync } = require('child_process');
module.exports = async () =&gt; {
    console.log('Starting Docker Compose...');
    execSync('docker-compose -f docker-compose.tests.yml up 
      --build -d', { stdio: 'inherit' });
    // You might need to add a delay here to give services time to initialize
    await new Promise(resolve =&gt; setTimeout(resolve, 15000)); };</pre>			<p>This global setup script initiates a Docker Compose environment for testing. It starts by logging a message, and then executes the <strong class="source-inline">docker-compose up --build -d</strong> command using the specified <strong class="source-inline">docker-compose.tests.yml</strong> file. Finally, it introduces a fifteen second delay to allow services sufficient time to start before test <span class="No-Break">execution begins.</span></p>
			<p>Here’s the <span class="No-Break"><strong class="source-inline">global-teardown</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
const { execSync } = require('child_process');
module.exports = async () =&gt; {
    console.log(‹Stopping Docker Compose...›);
    execSync('docker-compose -f docker-compose.tests.yml down', 
      { stdio: 'inherit' });
};</pre>			<p>This <strong class="source-inline">global-teardown</strong> script terminates the Docker Compose environment. It logs a message indicating <a id="_idIndexMarker1003"/>the process and then executes the <strong class="source-inline">docker-compose down</strong> command using the specified <strong class="source-inline">docker-compose.tests.yml</strong> file to stop all running containers and <span class="No-Break">remove networks.</span></p>
			<p>We run all dependent services from the Docker file, hence why we have a special file called <strong class="source-inline">docker-compose.tests.yml</strong> under <strong class="source-inline">Ch12/transactionservice</strong>. Check out this book’s GitHub repository for the source code for the <span class="No-Break"><strong class="source-inline">docker-compose.tests.yml</strong></span><span class="No-Break"> file.</span></p>
			<p>This Docker Compose file defines a multi-container environment for a microservices application. It includes services for a PostgreSQL database, <strong class="source-inline">PgAdmin</strong> for database management, MongoDB, Zookeeper, Kafka, and a Kafka UI. The file also defines an account service built from a local <strong class="source-inline">Dockerfile</strong> file, configuring its dependencies on MongoDB and Kafka. Environment variables, ports, volumes, and network configurations are specified for each service. Here, <strong class="source-inline">app-network</strong> is used for internal communication <span class="No-Break">between containers.</span></p>
			<p>When writing integration tests for Nest.js applications, we often create a test configuration file. This configuration file specifies configuration values that are necessary for the test environment, such as database connections, API keys, or other sensitive information. You can set up in-memory or temporary databases for testing purposes to isolate test data and prevent conflicts with production data. It also helps us to configure mocking libraries or frameworks so that we can replace real external services with test doubles, improving test isolation and performance. We mostly define configuration options for testing frameworks or libraries, such as Jest or Supertest, to customize their behavior for integration tests. By centralizing test-specific configurations in a separate file, you enhance code organization, maintainability, and reusability. It also helps to prevent sensitive information from being accidentally committed to the main code base. Check out the <strong class="source-inline">Ch12/transactionservice/test-configuration.ts</strong> file for <span class="No-Break">more content.</span></p>
			<p>Our test configuration file sets up a Nest.js testing module for integration tests. It imports the necessary modules for database connection (<strong class="source-inline">TypeOrm</strong>), microservices (<strong class="source-inline">ClientsModule</strong>), and the target module (<strong class="source-inline">TransactionModule</strong>). It also configures a PostgreSQL database using environment variables or default values and establishes a Kafka client. Finally, the <strong class="source-inline">testConfiguration</strong> function compiles the testing module and returns it for use in <span class="No-Break">integration tests.</span></p>
			<p>If you haven’t<a id="_idIndexMarker1004"/> installed it yet, don’t forget to run the following command to make sure your test configuration will <span class="No-Break">run properly:</span></p>
			<pre class="console">
npm install --save @nestjs/microservices @nestjs/testing @nestjs/typeorm</pre>			<p>Here, <strong class="source-inline">@nestjs/typeorm</strong> is a package that seamlessly integrates <strong class="source-inline">TypeORM</strong>, a popular <strong class="bold">object-relational mapper</strong> (<strong class="bold">ORM</strong>), with <a id="_idIndexMarker1005"/>the Nest.js framework. It provides a convenient way to interact with relational databases such as PostgreSQL, MySQL, SQLite, and others within your <span class="No-Break">Nest.js application.</span></p>
			<p>You must define your database tables as TypeScript classes (<em class="italic">entities</em>). Here, <strong class="source-inline">TypeORM</strong> handles the mapping between your code and the database schema. It supports features such as repositories, migrations, transactions, and more, making database operations efficient <span class="No-Break">and reliable.</span></p>
			<p>Now, it’s time to write our simple integration test for the transaction microservice. The <strong class="source-inline">transaction.controller.spec.ts</strong> file can be found under <strong class="source-inline">Ch12/transactionservice/src/test</strong> and contains the <span class="No-Break">following content:</span></p>
			<pre class="source-code">
import { INestApplication } from '@nest.js/common';
import { testConfiguration } from '../test/test-configuration';
import * as request from 'supertest';
describe('AppController (e2e)', () =&gt; {
  let app: INestApplication;
  beforeAll(async () =&gt; {
    const moduleFixture = await testConfiguration();
    app = moduleFixture.createNestApplication();
    await app.init();
  });
  afterAll(async () =&gt; {
    await app.close();
  });
  it('/transactions (POST) should create a transaction', async () =&gt; {
    const createTransactionDto = {
      accountId: '6658ae5284432e40604018d5', // UUID
      description: 'Test transaction',
    };
    return request(app.getHttpServer())
      .post('/transaction')
      .send(createTransactionDto)
      .expect(400);
  }, 10000); });</pre>			<p>This test imports the necessary modules for testing and HTTP requests. The <strong class="source-inline">beforeAll</strong> hook sets up the test environment by creating a Nest.js application using the <strong class="source-inline">testConfiguration</strong> function, while the <strong class="source-inline">afterAll</strong> hook cleans up by closing the application. The test case focuses on creating a transaction. It constructs a transaction DTO with sample data and sends a <strong class="source-inline">POST</strong> request to the <strong class="source-inline">/transaction</strong> endpoint. The expected response status is <strong class="source-inline">400</strong> (<em class="italic">Bad Request</em>), indicating an error in the request. A timeout of <strong class="source-inline">10000</strong> milliseconds (<strong class="source-inline">10</strong> seconds) is set for the test. This test case verifies the basic functionality of the transaction creation endpoint and provides a foundation for further <span class="No-Break">testing scenarios.</span></p>
			<p>To run your tests, simply execute the <strong class="source-inline">npm run test</strong> command. Make sure Docker is running before<a id="_idIndexMarker1006"/> executing any <span class="No-Break">integration tests:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer115">
					<img alt="Figure 12.3: Docker services" src="image/B09148_12_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: Docker services</p>
			<p>When running integration tests with a Dockerized account microservice, the primary challenge is ensuring a consistent data state for each test. This involves doing <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Data preparation</strong>: Creating necessary accounts or records before <span class="No-Break">each test.</span></li>
				<li><strong class="bold">Data cleanup</strong>: Removing test data after each test to prevent <span class="No-Break">data pollution.</span></li>
				<li><strong class="bold">Database isolation</strong>: Ensuring test data doesn’t interfere with other tests <span class="No-Break">or environments.</span></li>
			</ul>
			<p>To handle these challenges, we can use <span class="No-Break">multiple solutions:</span></p>
			<ul>
				<li><strong class="bold">Database migration scripts</strong>: Use tools such as <strong class="source-inline">typeorm</strong> and <strong class="source-inline">sequelize</strong> to create migration scripts for your <span class="No-Break">account database:</span><ul><li><strong class="bold">Run migrations before tests</strong>: Execute these scripts in your <strong class="source-inline">globalSetup</strong> or <strong class="source-inline">beforeEach</strong> hooks to populate the database with <span class="No-Break">test data.</span></li><li><strong class="bold">Rollb ack migrations after tests</strong>: Execute the reverse migrations in your <strong class="source-inline">globalTeardown</strong> or <strong class="source-inline">afterEach</strong> hooks to clean up <span class="No-Break">the database.</span></li></ul></li>
				<li><strong class="bold">Docker volumes</strong>: Define a Docker volume for your account <span class="No-Break">microservice’s database:</span><ul><li><strong class="bold">Mount the volume</strong>: Mount the volume to the container to persist data between <span class="No-Break">test runs.</span></li><li><strong class="bold">Truncate or delete data</strong>: Before each test, truncate or delete the database’s content to ensure a <span class="No-Break">clean state.</span></li></ul></li>
				<li><strong class="bold">Test containers</strong>: For complex scenarios, use a dedicated container for test data preparation <span class="No-Break">and cleanup:</span><ul><li><strong class="bold">Orchestrate with Docker Compose</strong>: Use Docker Compose to manage the relationship between the test container and the <span class="No-Break">account microservice.</span></li></ul></li>
				<li><strong class="bold">In-memory databases</strong>: For simpler scenarios, use in-memory databases such as SQLite <span class="No-Break">for testing:</span><ul><li><strong class="bold">Benefits</strong>: Faster startup, isolation, and no need for <span class="No-Break">data migration.</span></li></ul></li>
			</ul>
			<p>With that, we’ve<a id="_idIndexMarker1007"/> come to the end of this chapter! Let’s recap what <span class="No-Break">we learned.</span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor210"/>Summary</h1>
			<p>In this chapter, we delved into the critical role of testing in microservice architecture. Building upon our previous exploration of microservice creation, we emphasized the importance of rigorous testing for ensuring code quality and reliability. We introduced the concepts of unit and integration testing, explaining their distinct purposes <span class="No-Break">and benefits.</span></p>
			<p>To solidify our understanding, we implemented unit tests for both the account and transaction microservices. These tests verified the correct behavior of individual code units in isolation. Additionally, we explored the nuances of mocks, stubs, and spies, demonstrating their utility in isolating components <span class="No-Break">during testing.</span></p>
			<p>To assess the interactions between different microservices, we introduced integration testing. By combining unit tests with integration tests, we established a robust testing strategy for <span class="No-Break">our microservices.</span></p>
			<p>In the next chapter, we will dive into the practical implementation of CI/CD pipelines. We will explore how to utilize GitHub Actions to automate workflows and streamline the deployment of our microservices, particularly focusing on deploying to Azure Cloud. You’ll learn how to build a fully automated pipeline that ensures your applications are consistently ready for deployment with minimal <span class="No-Break">manual intervention.</span></p>
		</div>
	</body></html>