<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-195"><a id="_idTextAnchor196"/>12</h1>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor197"/>Testing Microservices</h1>
			<p>Testing is a critical phase within <a id="_idIndexMarker897"/>the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>) that’s integral to ensuring the software meets the required standards and functions as expected. Testing detects bugs introduced during development. It verifies that the software performs its intended functions correctly and efficiently and ensures the software meets user requirements and specifications. By applying tests, we can reduce the risks associated with software failure or malfunction.</p>
			<p>In this chapter, we’ll talk about different strategies for software testing within microservices. By the end, you’ll know how to write unit and integration tests for your microservices both in isolation and integrated with other microservices.</p>
			<p>We’re going to cover the following topics:</p>
			<ul>
				<li>Understanding testing in a microservice architecture</li>
				<li>Understanding and implementing unit tests</li>
				<li>Implementing unit tests for the account microservice</li>
				<li>Writing unit tests for the transaction microservice</li>
				<li>Comparing mocks, stubs, and spies in unit tests</li>
				<li>Understanding and implementing integration tests</li>
			</ul>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor198"/>Technical requirements</h1>
			<p>To implement our tests, we’ll need the following:</p>
			<ul>
				<li>An IDE of your choice (we prefer Visual Studio Code).</li>
				<li>This book’s GitHub repository, which can be downloaded from <a href="https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript">https://github.com/PacktPublishing/Hands-on-Microservices-with-JavaScript</a>. Open the <code>Ch12</code> folder so that you can follow along with ease.</li>
			</ul>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor199"/>Understanding testing in a microservice architecture</h1>
			<p>Microservice architecture <a id="_idIndexMarker898"/>divides an application into<a id="_idIndexMarker899"/> smaller, loosely coupled services, each responsible for a specific business function. This approach offers numerous benefits, such as improved scalability and flexibility. However, it also introduces complexity, particularly in terms of testing. Comprehensive testing is crucial to ensure that these independent services function correctly and cohesively. Let’s try to understand the importance of testing in a microservice architecture:</p>
			<ul>
				<li>The first reason for using <a id="_idIndexMarker900"/>tests in a microservice architecture is to ensure <strong class="bold">functionality</strong>. Each service performs a distinct function in a microservice architecture and is developed independently. Testing ensures that each service performs its intended function correctly. We mostly use unit and functional testing to achieve this goal:<ul><li><strong class="bold">Unit testing</strong> focuses on individual components within a service, verifying that each function works as expected. This helps us catch bugs early in the development process.</li><li>On the other hand, <strong class="bold">functional testing</strong> ensures<a id="_idIndexMarker901"/> that the service as a whole meets its functional requirements. This involves testing the service’s endpoints and ensuring that they return the expected results.</li></ul></li>
				<li>The second reason for using tests in microservices is to maintain <strong class="bold">interoperability</strong>. Microservices must communicate with each other to function as a cohesive application. Ensuring seamless interoperability between services is critical. To achieve this, we mostly focus on integration and contract testing:<ul><li><strong class="bold">Integration testing</strong> focuses on interactions between services, verifying that data exchange and communication protocols are implemented correctly.</li><li><strong class="bold">Contract testing</strong> ensures that services adhere to defined APIs or contracts. This is particularly important when different teams develop services independently as it helps maintain consistent communication standards.</li></ul></li>
				<li>The third reason is <strong class="bold">performance</strong> assurance. Performance testing ensures that services operate efficiently under various load conditions, which is vital for maintaining a good user<a id="_idIndexMarker902"/> experience. We can achieve this goal using load testing and stress testing:<ul><li><strong class="bold">Load testing</strong> evaluates how services handle expected load levels. This helps identify performance bottlenecks and ensures services can handle real-world usage.</li><li><strong class="bold">Stress testing</strong> examines how services perform under extreme conditions, such as high traffic or resource shortages. This helps in understanding the service’s breaking point and resilience.</li></ul></li>
				<li>Testing is<a id="_idIndexMarker903"/> also<a id="_idIndexMarker904"/> important <a id="_idIndexMarker905"/>for <strong class="bold">security</strong> validation. Security is a critical concern in microservice architecture as each service may handle sensitive data and must be protected against vulnerabilities. We can use security testing and penetration testing to achieve our goal:<ul><li><strong class="bold">Security testing</strong> identifies vulnerabilities and ensures that services can protect sensitive data. This includes testing for common security issues such as SQL injection, <strong class="bold">cross-site scripting</strong> (<strong class="bold">XSS</strong>), and<a id="_idIndexMarker906"/> authentication flaws.</li><li><strong class="bold">Penetration testing</strong> simulates attacks to identify potential security gaps. This helps in proactively securing services against real-world threats.</li></ul></li>
				<li>Microservices need to be reliable and stable, especially during updates or changes. Testing ensures that services remain <strong class="bold">dependable</strong> over time. We have regression and chaos testing to make sure we have reliable and stable microservices:<ul><li><strong class="bold">Regression testing</strong> ensures that new changes or updates don’t introduce new bugs or break existing functionality. This is crucial for maintaining service reliability after each deployment.</li><li><strong class="bold">Chaos engineering</strong> involves intentionally introducing failures into the system to test its resilience. This helps us understand how services respond to unexpected issues <a id="_idIndexMarker907"/>and improves overall stability.</li></ul></li>
			</ul>
			<p>Having <a id="_idIndexMarker908"/>understood <a id="_idIndexMarker909"/>testing as a whole, let’s move on to unit tests.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor200"/>Understanding unit tests</h1>
			<p><strong class="bold">Unit testing</strong> is a software<a id="_idIndexMarker910"/> testing technique that matters most when you want to ensure that individual units or components of the software are tested in isolation. The goal of unit testing is to validate that each unit of the software performs as expected.</p>
			<p>It’s an important aspect of software development, especially in microservices architectures. Node.js, with its asynchronous and event-driven nature, poses unique challenges and opportunities for unit testing. In this context, unit testing involves testing individual functions, methods, or classes within your Node.js application. Let’s cover the importance of unit testing for microservices:</p>
			<ul>
				<li><strong class="bold">It ensures code quality</strong>: Unit testing<a id="_idIndexMarker911"/> helps identify bugs early in the development cycle, ensuring that individual units of code function as intended. This is particularly important in microservices, where services are designed to be small, independent, and modular.</li>
				<li><strong class="bold">It facilitates refactoring</strong>: With a comprehensive suite of unit tests, developers can confidently refactor code, knowing that any changes will be verified by the tests. This is crucial for maintaining and improving the code base over time.</li>
				<li><strong class="bold">It supports continuous integration/continuous deployment (CI/CD)</strong>: Unit tests are an integral part of CI/CD pipelines. They provide immediate feedback on code changes, enabling quick iterations and stable deployments.</li>
				<li><strong class="bold">Better documentation</strong>: Well-written unit tests serve as documentation for the code. They demonstrate how individual units are expected to behave, making it easier for new<a id="_idIndexMarker912"/> developers to understand the code base.</li>
			</ul>
			<p>Let’s look at some of the benefits of performing unit testing in Node.js microservices:</p>
			<ul>
				<li><strong class="bold">Improved reliability</strong>: Unit tests<a id="_idIndexMarker913"/> ensure that each microservice behaves as expected, reducing the likelihood of runtime errors and improving overall system reliability.</li>
				<li><strong class="bold">Faster development cycles</strong>: Automated unit tests speed up the development process by allowing developers to quickly identify and fix issues. This is particularly beneficial in microservices, where services are developed and deployed independently.</li>
				<li><strong class="bold">Reduced debugging time</strong>: With unit tests in place, bugs can be detected and isolated quickly, reducing the time spent on debugging.</li>
				<li><strong class="bold">Increased confidence in code changes</strong>: Unit tests provide a safety net for developers, giving them the confidence to make changes and add new features without breaking existing functionality.</li>
			</ul>
			<p>Unit testing in Node.js microservices enhances reliability, accelerates development by catching issues early, reduces debugging time, and boosts developer confidence in making code changes without breaking functionality. Now, let’s focus on unit testing packages we need to use to write unit tests.</p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor201"/>Introducing unit testing packages</h2>
			<p>Before writing a line <a id="_idIndexMarker914"/>of code, we need to prepare our environment. To be precise, we need to install the required packages to write unit tests.</p>
			<p>Chai, Mocha, and Sinon are popular libraries that are used for testing in Node.js applications, including microservices. Each of these libraries has a specific role and they often work together to provide a comprehensive testing framework.</p>
			<h3>Introducing Mocha</h3>
			<p>First, let’s talk<a id="_idIndexMarker915"/> about <strong class="bold">Mocha</strong>. Mocha is a feature-rich JavaScript test<a id="_idIndexMarker916"/> framework that runs on Node.js, making asynchronous testing simple and fun. It provides a testing environment where you can define your tests and run them.</p>
			<p>It has the following features:</p>
			<ul>
				<li><code>describe</code> and <code>it</code> blocks.</li>
				<li><strong class="bold">Allows asynchronous testing</strong>: It supports both synchronous and asynchronous tests.</li>
				<li><code>before</code>, <code>after</code>, <code>beforeEach</code>, and <code>afterEach</code>) for setting up and tearing down conditions for tests.</li>
				<li><strong class="bold">Extensible</strong>: It can be extended with various plugins and reporters to customize the testing setup.</li>
			</ul>
			<p>You can install it using the <code>npm install --save-dev </code><code>mocha</code> command.</p>
			<h3>Introducing Chai</h3>
			<p><strong class="bold">Chai</strong> is a <a id="_idIndexMarker918"/>popular<a id="_idIndexMarker919"/> assertion library that’s used with Node.js, often in combination with testing frameworks such as Mocha. It provides a variety of interfaces and styles for writing tests, making it flexible and easy to use.</p>
			<p>It supports different assertion styles, two of which we’ll look at here:</p>
			<ul>
				<li>The first and maybe the most used style is known as <code>expect</code> and <code>should</code> interfaces. They’re used for writing expressive and readable assertions. This style allows for natural language assertions, making tests easier to understand.</li>
				<li>The second style is <a id="_idIndexMarker921"/>known as <code>assert</code> interface is used for writing classical unit test assertions. This style is more traditional and straightforward, which makes it suitable for developers familiar with xUnit frameworks.</li>
			</ul>
			<p>We can install it using the <code>npm install --save-dev </code><code>chai</code> command.</p>
			<p>While Chai has many <a id="_idIndexMarker922"/>features, let’s understand three of the most relevant ones. The first feature we’ll look at<a id="_idIndexMarker923"/> is its <code>chai-as-promised</code> for promise assertions and <code>chai-http</code> for HTTP assertions. The second key feature is <strong class="bold">extensibility</strong>. Chai <a id="_idIndexMarker924"/>can be extended to create custom assertions using its plugin API. This allows developers to add domain-specific language to their tests On the other hand, Chai has a cool feature known as readable and expressive syntax. Chai’s BDD-style assertions are designed <a id="_idIndexMarker925"/>to be readable and expressive, making tests easier to write and understand. Finally, Chai also <strong class="bold">integrates</strong> seamlessly <a id="_idIndexMarker926"/>with Mocha, providing a powerful combination for writing and running tests.</p>
			<h3>Introducing Sinon</h3>
			<p><strong class="bold">Sinon</strong> is another<a id="_idIndexMarker927"/> powerful<a id="_idIndexMarker928"/> library for testing in JavaScript that’s particularly useful for creating spies, stubs, and mocks to control and monitor the behavior of functions. It’s especially valuable in unit testing to isolate the code under test from its dependencies, ensuring that the tests focus on the specific functionality being tested.</p>
			<p>Before we learn how to implement unit tests, let’s take a look at some of the key features of Sinon:</p>
			<ul>
				<li><strong class="bold">Spies</strong>: Track and <a id="_idIndexMarker929"/>monitor the behavior of functions.</li>
				<li><strong class="bold">Stubs</strong>: Replace functions with predefined behaviors.</li>
				<li><strong class="bold">Mocks</strong>: Create fake objects with expectations for their behavior.</li>
				<li><strong class="bold">Fakes</strong>: Combine the behavior of spies and stubs for simpler use cases.</li>
				<li><strong class="bold">Timers</strong>: Control and simulate the passage of time in tests.</li>
				<li><code>XMLHttpRequest</code> and the Fetch API to test AJAX requests.</li>
			</ul>
			<p>We can install it using the <code>npm install --save-dev sinon</code> command. Sinon can mock functions, HTTP<a id="_idIndexMarker930"/> requests, and more, making it ideal for unit testing.</p>
			<p class="callout-heading">Other packages in Node.js</p>
			<p class="callout">Along with <code>Chai</code>, we have other<a id="_idIndexMarker931"/> popular assertion libraries such as Jest. <strong class="bold">Jest</strong> has its own <a id="_idIndexMarker932"/>assertion library, which is fully integrated and optimized for use with Jest.</p>
			<p class="callout">When implementing unit tests, we also need mocking and stubbing libraries. In unit testing, mocks and stubs are used to isolate the unit of code being tested by simulating the behavior of dependencies. This allows you to test the functionality of a specific unit without having to rely on external components, such as databases, network services, or other modules.</p>
			<p class="callout">Along with <code>Sinon</code>, we use<a id="_idIndexMarker933"/> the <code>Testdouble</code> is a minimal, standalone test double library for JavaScript. You can use the <code>npm install --save-dev testdouble</code> command to install it. Testdouble provides tools for creating, using, and verifying test doubles in JavaScript.</p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>What should we test in unit testing?</h2>
			<p>Before implementing unit<a id="_idIndexMarker934"/> tests in our project, we need to answer one simple question: what should we unit test? Let’s take a look:</p>
			<ul>
				<li><strong class="bold">Business logic</strong>: This is the most critical part to test. Business logic includes the rules and operations that dictate how data is transformed, manipulated, and controlled. It ensures the application behaves correctly under various conditions.</li>
				<li><strong class="bold">Edge cases</strong>: Test the boundaries and limits of your application. This includes checking how the application handles unexpected, extreme, or invalid inputs.</li>
				<li><strong class="bold">Error handling</strong>: Ensure that the application responds correctly to error conditions, such as invalid input or failed operations.</li>
				<li><strong class="bold">State transitions</strong>: If the application involves state changes (such as a status update), make sure these transitions occur as expected.</li>
				<li><strong class="bold">Return values</strong>: Verify that functions return the correct values for given inputs.</li>
				<li><strong class="bold">Dependencies and interactions</strong>: While unit tests should ideally test a unit in isolation, it’s important to mock dependencies and verify interactions between components to ensure they collaborate correctly.</li>
			</ul>
			<p>Now that we know what<a id="_idIndexMarker935"/> we should test, it’s time to implement unit testing so that we can see it in practice.</p>
			<h1 id="_idParaDest-202"><a id="_idTextAnchor203"/>Implementing unit tests for the account microservice</h1>
			<p>A copy of the <a id="_idIndexMarker936"/>source code for <a href="B09148_07.xhtml#_idTextAnchor121"><em class="italic">Chapter 7</em></a> can be <a id="_idIndexMarker937"/>found in the <code>Ch12</code> folder of this book’s GitHub repository. This chapter will demonstrate how to test different microservices. We’ll start with the account microservice.</p>
			<p>Create a new folder at the same level as the <code>src</code> folder and name it <code>tests</code>. Our main focus here is to test the <code>src/services/account.js</code> file. It contains the main logic and the required business rules that are implemented in our application.</p>
			<p>Next, create a file called <code>accountservice.test.mjs</code> under the <code>tests</code> folder. Why the <code>.mjs</code> extension? This extension is used in Node.js projects to indicate that a JavaScript file should be treated as<a id="_idIndexMarker938"/> an <code>import</code> and <code>export</code> syntax. By using <code>.mjs</code>, Node.js can unambiguously determine that the file should be treated as an ES module, even if it exists alongside <code>CommonJS</code> files with a <code>.js</code> extension. This avoids confusion and potential conflicts, especially in projects that use both module systems. Using <code>.mjs</code> makes it explicit to developers and tools that the file is an ES module, helping them avoid making mistakes and misconfigurations.</p>
			<p>Simply put, using the <code>.mjs</code> extension in Node.js projects helps separate ES modules from CommonJS modules. This ensures Node.js handles them correctly and keeps your code compatible with modern JavaScript standards. By using <code>.mjs</code>, you can simplify your module setup and make your code more future proof as JavaScript continues to evolve.</p>
			<p>We plan to implement unit tests for the <code>account.js</code> file, which can be found in the <code>src / </code><code>services</code> folder.</p>
			<p>We have multiple functions inside this service. First, let’s consider some unit tests for the <code>getAccountById</code> function. Here’s the original function:</p>
			<pre class="source-code">
function getAccountById(id) {
    return Account.findById(id);
}</pre>			<p>From an<a id="_idIndexMarker939"/> implementation <a id="_idIndexMarker940"/>perspective, we haven’t implemented valid exception handling. We <em class="italic">throw</em> the same exception from the database layer to the API layer directly. It’s generally better to handle exceptions either at the lowest level (database layer) or at the highest level (API layer). <em class="italic">Lower layers</em> should primarily focus on detecting and throwing exceptions when unexpected conditions arise. This maintains a clean separation of concerns and prevents lower layers from exposing implementation details. Some exceptions, such as database connection failures or file read/write errors, might require immediate handling at the lowest level to prevent data corruption or resource leaks. For instance, if a file write operation fails due to a full disk, handling the exception at this level can prevent further issues. If the exception is expected and can be handled within the lower layer without exposing internal details, it’s reasonable to do so. A centralized error-handling mechanism at the highest layer can provide consistent error management across the application.</p>
			<p>First, let’s install the required packages. To do so, run the <code>npm install --save-dev mocha chai sinon</code> command. After installation, we’ll have the following <code>devDependencies</code> section in the <code>package.json</code> file:</p>
			<pre class="source-code">
"devDependencies": {
    "chai": "^5.1.1",
    "mocha": "^10.7.0",
    «sinon": "^18.0.0"
  }</pre>			<p>Now, it’s time to import the necessary packages and functionalities:</p>
			<pre class="source-code">
import * as chai from 'chai';
import sinon from 'sinon';
const expect = chai.expect;
import * as accountService from '../src/services/account.js';
import account from '../src/models/account.js'
const { errorCodes } = accountService.default;</pre>			<p>What should we test in <a id="_idIndexMarker941"/>our <a id="_idIndexMarker942"/>account service? The first function that needs to be tested is <code>getAccountById</code>. We should check whether the function will return the exact account information if the given account exists in our database. Here’s our first test case:</p>
			<pre class="source-code">
describe('getAccountById service', () =&gt; {
    let findByIdStub;
    beforeEach(() =&gt; {
        findByIdStub = sinon.stub(account, 'findById');
    });
    afterEach(async () =&gt; {
        await findByIdStub.restore();
    });
    it('should return the account if found by id', async () =&gt; {
        const expectedAccountId = '12345';
        const expectedAccount = { name: 'Test Account', 
          number: '123-456-7890' };
        findByIdStub.withArgs(expectedAccountId)
          .resolves(expectedAccount);
        const account = await accountService
          .getAccountById(expectedAccountId);
        expect(account).to.deep.equal(expectedAccount);
        expect(findByIdStub.calledOnceWith(expectedAccountId))
          .to.be.true;
    });
});</pre>			<p>Well, this code may <a id="_idIndexMarker943"/>seem<a id="_idIndexMarker944"/> a little bit complicated at first glance, but the detailed explanation provided in this section will help you understand it with ease.</p>
			<p>In Mocha, the <code>describe</code> and <code>it</code> blocks are fundamental structures that are used to write and organize tests.</p>
			<p>The <code>describe</code> block is used to group related test cases. It helps organize tests into logical sections, making them easier to read and understand. It’s typically used to group tests related to a particular feature or function. The <code>describe</code> block has two parameters:</p>
			<ul>
				<li><code>description</code>: A string that describes the group of tests. This description will appear in the test’s output.</li>
				<li><code>function</code>: A callback function that contains the test cases (using it blocks) and any setup/teardown logic.</li>
			</ul>
			<p>The <code>it</code> block is used to define individual test cases. Each <code>it</code> block represents a single test that performs a specific assertion or set of assertions.</p>
			<p>You can nest <code>describe</code> blocks to create a hierarchical structure for your tests, making it easier to organize and understand complex test suites. Here’s an example of this:</p>
			<pre class="source-code">
describe('Math operations', function() {
  describe('Addition', function() {
    it('should add two numbers correctly', function() {
      expect(1 + 1).to.equal(2);
    });
  });
  describe('Subtraction', function() {
    it('should subtract two numbers correctly', function()
    {
      expect(2 - 1).to.equal(1);
    });
  });
});</pre>			<p>In practice, you <a id="_idIndexMarker945"/>typically<a id="_idIndexMarker946"/> use <code>describe</code> to group tests by the feature or unit of code being tested and <code>it</code> to define the specific behaviors you expect from that code.</p>
			<p>Let’s get back to our example. Our code snippet describes a unit test for a service function called <code>getAccountById</code>. The test uses a mocking library called <code>Sinon</code> to simulate the behavior of a function named <code>findById</code> within the account module.</p>
			<p>In simpler terms, this test checks whether the <code>getAccountById</code> service function correctly retrieves an account by its ID using the <code>findById</code> function. It ensures that the service returns the expected account data when the ID is found.</p>
			<p>Here’s a line-by-line explanation of our first unit test:</p>
			<ul>
				<li><em class="italic">Line 1</em> declares <a id="_idIndexMarker947"/>a test suite named <code>getAccountById service</code>. The function that’s passed to <code>describe</code> will contain the test cases related to <code>getAccountById service</code>.</li>
				<li><em class="italic">Line 2</em> declares the <code>findByIdStub</code> variable, which will be used later to hold the stub created by Sinon.</li>
				<li><em class="italic">Line 3</em> sets up a function to run before each test case within this <code>describe</code> block.</li>
				<li>Inside the <code>beforeEach</code> function in <em class="italic">Line 4</em>, <code>Sinon</code> creates a stub for the <code>findById</code> method of the <code>account</code> model. This stub will replace the original <code>findById</code> method, allowing us to control its behavior during tests.</li>
				<li><em class="italic">Line 7</em> sets up a function to run after each test case within this <code>describe</code> block.</li>
				<li>Inside the <code>afterEach</code> function in <em class="italic">Line 8</em>, the <code>restore</code> method is called on <code>findByIdStub</code>. This restores the original <code>findById</code> method of the account model, ensuring that <a id="_idIndexMarker948"/>stubs<a id="_idIndexMarker949"/> don’t affect other tests.</li>
				<li><em class="italic">Line 11</em> declares a test case with a description of <code>should return the account if found by id</code>. The function that’s passed to it contains the test logic.</li>
				<li><em class="italic">Line 12</em> declares a constant, <code>expectedAccountId</code>, and assigns it a value of <code>'12345'</code>. This is the ID that will be used to search for the account.</li>
				<li><em class="italic">Line 13</em> declares a constant, <code>expectedAccount</code>, and assigns it a mock account object. This is the account that the stubbed <code>findById</code> method will return.</li>
				<li><em class="italic">Line 14</em> sets up <code>findByIdStub</code> to resolve (return a promise that resolves to) <code>expectedAccount</code> when it’s called with <code>expectedAccountId</code>. This simulates the behavior of finding an account in the database.</li>
				<li><em class="italic">Line 15</em> calls the <code>getAccountById</code> service function with <code>expectedAccountId</code> and awaits its result. The result is assigned to the account variable.</li>
				<li><em class="italic">Line 16</em> asserts that the account that’s returned by the service function is deeply equal to <code>expectedAccount</code>. Deep equality checks that all properties of the objects are equal.</li>
				<li><em class="italic">Line 17</em> asserts that <code>findByIdStub</code> was called exactly once with <code>expectedAccountId</code>. This <a id="_idIndexMarker950"/>verifies that the service function attempted to find the account by the correct ID.</li>
			</ul>
			<p>Here are the next few <a id="_idIndexMarker951"/>unit<a id="_idIndexMarker952"/> tests inside the same <code>describe</code> block:</p>
			<pre class="source-code">
describe('getAccountById service', () =&gt; {
    .........
    .........
    it('should return null if account not found', async () =&gt; {
        const expectedAccountId = '54321';
        findByIdStub.withArgs(expectedAccountId).resolves(null);
        const account = await accountService
          .getAccountById(expectedAccountId);
        expect(account).to.be.null;
        expect(findByIdStub.calledOnceWith(expectedAccountId))
          .to.be.true;
    });
    it('should rethrow errors from findById', async () =&gt; {
        const expectedAccountId = '98765';
        const expectedError = new Error('Database error');
        findByIdStub.withArgs(expectedAccountId)
          .rejects(expectedError);
        try {
            await accountService.getAccountById(expectedAccountId);
        } catch (error) {
            expect(error).to.equal(expectedError);
            expect(findByIdStub.calledOnceWith(expectedAccountId))
              .to.be.true;
        }  }); });</pre>			<p>In this unit test <a id="_idIndexMarker953"/>suite, two <a id="_idIndexMarker954"/>test cases have been defined for the <code>getAccountById</code> service:</p>
			<ul>
				<li>The first test case, named <code>should return null if account not found</code>, sets up a scenario where the account with an ID of <code>'54321'</code> doesn’t exist. Here, <code>findByIdStub</code> is configured to return <code>null</code> when called with this ID. The test then calls <code>getAccountById</code> with <code>'54321'</code> and expects the result to be <code>null</code>. It also verifies that <code>findByIdStub</code> was called exactly once with <code>'54321'</code>.</li>
				<li>The second test case, named <code>should rethrow errors from findById</code>, tests the behavior when the <code>findById</code> method throws an error. Here, <code>findByIdStub</code> is set up to throw <code>Database error</code> when called with ID <code>'98765'</code>. The test calls <code>getAccountById</code> and expects the call to throw the same error. This is verified using a try-catch block, where it’s checked that the caught error is equal to the expected error. Additionally, it verifies that <code>findByIdStub</code> was called exactly once with <code>'98765'</code>. These tests ensure that the <code>getAccountById</code> service correctly handles cases where the account isn’t found and when errors occur during database access. Please keep in mind that rethrowing errors should include meaningful handling, such as logging or adding additional context to the error.</li>
			</ul>
			<p>Other tests except <code>updateAccountById</code> follow approximately the same testing style. In a given service, the most complex implementation exists inside the <code>updateAccountById</code> function. Please refer to <a href="B09148_05.xhtml#_idTextAnchor074"><em class="italic">Chapter 5</em></a> to learn more about the <code>Account</code> microservice and its business cases.</p>
			<p>We should cover every<a id="_idIndexMarker955"/> business<a id="_idIndexMarker956"/> rule that’s implemented in our original functionality. Here’s the first condition that we need to cover when updating the account:</p>
			<pre class="source-code">
async function updateAccountById(id, { name, number, type, status }) {
    if (!name &amp;&amp; !number &amp;&amp; !type &amp;&amp; !status) {
        return { error: 'provide at least one valid data to be updated', code: NO_VALID_DATA_TO_UPDATE };
    }
  ........
}</pre>			<p>This function ensures that an account update is meaningful by requiring at least one valid piece of information (name, number, type, or status) to be provided. If none are given, it returns an error, to enforce the business rule of avoiding invalid updates.</p>
			<p>Here’s the unit test fragment:</p>
			<pre class="source-code">
describe('updateAccountById service', () =&gt; {
    let findByIdStub, saveStub;
    beforeEach(() =&gt; {
        findByIdStub = sinon.stub(account, 'findById');
        saveStub = sinon.stub(account.prototype, 'save');
    });
    afterEach(async () =&gt; {
        await findByIdStub.restore();
        await saveStub.restore();
    });
    it('should return error for no data to update', async () =&gt; {
        const id = '12345';
        const updateData = {};
        const result = await accountService.updateAccountById(id, 
          updateData);
        expect(result).to.deep.equal({
            error: 'provide at least one valid data to be updated',
            code: errorCodes.NO_VALID_DATA_TO_UPDATE,
        });
           expect(findByIdStub.calledOnceWith(id)).to.be.false;
        expect(saveStub.calledOnce).to.be.false;
    });
    ......
    ....... });</pre>			<p>The preceding code snippet <a id="_idIndexMarker957"/>describes<a id="_idIndexMarker958"/> a unit test for a service function called <code>updateAccountById</code>. This function is responsible for updating an account based on a given ID and update data. The test employs <code>Sinon</code> to substitute the behavior of the <code>findById</code> and <code>save</code> methods within the account module.</p>
			<p>Before each test case, <code>Sinon</code> stubs are established for both the <code>findById</code> and <code>save</code> methods to enable controlled test scenarios. After each test, these stubs are restored to their original state.</p>
			<p>The specific test case focuses on validating the error handling process when no update data is provided. It constructs an account ID and an empty update object. Subsequently, it invokes the <code>updateAccountById</code> service with these parameters and captures the result that’s returned.</p>
			<p>The test then asserts that the returned result is an error object containing a specific error message and code, indicating the absence of valid update data. To ensure the correct behavior, it further verifies that neither the <code>findById</code> nor the <code>save</code> method was called as no account retrieval or update was necessary in this scenario.</p>
			<p>Long story short, this unit test guarantees that the <code>updateAccountById</code> service correctly handles cases where no update data is supplied, returning an appropriate error response without performing unnecessary operations.</p>
			<p>The next piece of<a id="_idIndexMarker959"/> logic <a id="_idIndexMarker960"/>in the <code>updateAccountById</code> function is defined like this:</p>
			<pre class="source-code">
async function updateAccountById(id, { name, number, type, status }) {
 ......
 if (status &amp;&amp; !(status in availableAccountStatusesForUpdate)) {
        return { error: 'invalid status for account', code: INVALID_STATUS_CODE };   }
  ......
}</pre>			<p>The preceding code snippet indicates that if the status isn’t part of the allowed statuses defined by the business rules, it returns an error message, preventing the update with an invalid or unsupported status. This ensures that only acceptable status changes are made, maintaining business consistency and data integrity.</p>
			<p>The following unit test validates error handling for invalid status updates:</p>
			<pre class="source-code">
it('should return error for invalid status update', async () =&gt; {
        const id = '12345';
        const updateData = { status: 'invalid_status' };
        const result = await accountService.updateAccountById(id, 
          updateData);
        expect(result).to.deep.equal({
            error: 'invalid status for account',
            code: errorCodes.INVALID_STATUS_CODE,
        });
        expect(findByIdStub.calledOnceWith(id)).to.be.false;
        expect(saveStub.calledOnce).to.be.false;
    });</pre>			<p>The preceding unit test verifies error handling for invalid status updates in the <code>updateAccountById</code> service. It simulates an update with an invalid status. The test expects an error object with specific details when the service encounters this invalid input. To isolate the <a id="_idIndexMarker961"/>test, stubs<a id="_idIndexMarker962"/> prevent database interactions. By asserting the correct error, the test ensures the service behaves as expected when faced with incorrect data.</p>
			<p>Using the same approach we implemented for the preceding unit tests, we can test all the possible cases for our services. For more complete implementation, check out this book’s GitHub repository and the respective folder for this chapter.</p>
			<p>To run unit tests, navigate to the root folder from the command line (for us, this is the <code>Ch12</code>/<code>accountservice</code> folder) and run the following command:</p>
			<pre class="console">
npx mocha .\tests\accountservice.tests.mjs</pre>			<p>Here’s the result:</p>
			<div><div><img alt="Figure 12.1: Results of the test run" src="img/B09148_12_1.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Results of the test run</p>
			<p>With that, we’ve demonstrated how to write tests for the Express.js project. The same unit testing logic is <a id="_idIndexMarker963"/>the <a id="_idIndexMarker964"/>same for Nest.js applications. You can easily apply the aforementioned ideas to your Nest.js applications.</p>
			<h1 id="_idParaDest-203"><a id="_idTextAnchor204"/>Writing unit tests for the transaction microservice</h1>
			<p>Now, it’s time to<a id="_idIndexMarker965"/> demonstrate how easily you can <a id="_idIndexMarker966"/>write unit tests for your Nest.js applications. In this book’s GitHub repository, in the <code>Ch12</code> folder, we have the same transaction service we implemented in <a href="B09148_07.xhtml#_idTextAnchor121"><em class="italic">Chapter 7</em></a>.</p>
			<p>Open the <code>transaction.service.spec.ts</code> file, which can be found in the <code>src/test</code> folder. It contains all the essential tests to help us understand how to write unit tests. If you want to follow along and implement everything from scratch, just create a folder named <code>test</code> inside the <code>src</code> folder.</p>
			<p>First things first, we need to install the required packages to implement unit testing for our project. To write unit tests for <code>transaction.service.js</code>, we need to install the <code>@nestjs/</code><code>testing</code> package. Here’s how you can do it:</p>
			<pre class="console">
npm install --save-dev jest @nestjs/testing</pre>			<p>Once it’s been installed, create a file called <code>transaction.service.spec.ts</code>.  First, we need to import the required references:</p>
			<pre class="source-code">
import { Test, TestingModule } from '@nest.js/testing';
import { TransactionService } from '../transaction/transaction.service';
import { PrismaService } from '../prisma/prisma.service';
import { HttpService } from '@nest.js/axios';
import { KafkaService } from '../kafka/kafka.service';
import { CreateTransactionDto } from '../transaction/dto/create-transaction.dto';</pre>			<p>The preceding <a id="_idIndexMarker967"/>code <a id="_idIndexMarker968"/>imports the necessary services for testing: <code>TransactionService</code> handles transaction logic, <code>PrismaService</code> interacts with the database, <code>HttpService</code> handles external HTTP requests, <code>KafkaService</code> performs message handling, and <code>CreateTransactionDto</code> defines the structure of transaction data. The <code>Test</code> and <code>TestingModule</code> imports are from the Nest.js testing module and are used to create a testing environment for <code>TransactionService</code>.</p>
			<p>Here’s what a simple unit test looks like:</p>
			<pre class="source-code">
describe('TransactionService', () =&gt; {
  let service: TransactionService;
  let prismaService: PrismaService;
  let httpService: HttpService;
  let kafkaService: KafkaService;
  beforeEach(async () =&gt; {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        TransactionService,
        {
          provide: PrismaService,
          useValue: {
            transaction: {
              create: jest.fn(),
              findMany: jest.fn(),
              findUnique: jest.fn(),
              update: jest.fn(),
            },
          },
        },
        {
          provide: HttpService,
          useValue: {
            axiosRef: {
              get: jest.fn(),
            },
          },
        },
        {
          provide: KafkaService,
          useValue: {
            send: jest.fn(),
          },
        },
      ],
    }).compile();</pre>			<p>We already know about the <code>describe</code> block and its role in unit testing. The preceding code snippet establishes a testing environment for <code>TransactionService</code>. It begins by importing the necessary modules and services: <code>TransactionService</code>, <code>PrismaService</code> for database interactions, <code>HttpService</code> for external requests, <code>KafkaService</code> for message handling, and <code>CreateTransactionDto</code> for data transfer.</p>
			<p>A <code>describe</code> block encapsulates the tests for <code>TransactionService</code>. Inside, variables are declared to hold instances of the services. The <code>beforeEach</code> block sets up the testing module using <code>Test.createTestingModule</code>. It provides mock implementations for <code>PrismaService</code>, <code>HttpService</code>, and <code>KafkaService</code> to isolate <code>TransactionService</code> during testing. The <code>PrismaService</code> mock includes methods such as <code>create</code>, <code>findMany</code>, <code>findUnique</code>, and <code>update</code> to simulate database operations. If you open <code>transaction.service.ts</code>, you’ll realize that we use these methods to implement the functionalities of the transaction service. Similarly, the <code>HttpService</code> and <code>KafkaService</code> mocks mimic their respective functionalities using Jest’s <code>jest.fn()</code>. This setup allows for controlled testing of <code>TransactionService</code> without the need to rely on actual external dependencies.</p>
			<p>Here, <code>jest.fn()</code> is a function<a id="_idIndexMarker969"/> provided by Jest, a popular<a id="_idIndexMarker970"/> JavaScript testing framework, to create mock functions. A mock function is essentially a dummy function that can be used to replace real functions during testing. There are a lot of benefits and values to using such types of functionalities in unit testing. Here are the benefits of using <code>jest.fn()</code>:</p>
			<ul>
				<li><strong class="bold">Isolation</strong>: It allows us to<a id="_idIndexMarker971"/> isolate the component or function you’re testing by replacing dependencies with mock functions. This helps us focus on the specific behavior of the code under test without being affected by external factors.</li>
				<li><strong class="bold">Verifiability</strong>: We can assert how many times the mock function was called, with what arguments, and what it returned. This helps in verifying the correct behavior of the code.</li>
				<li><strong class="bold">Custom implementation</strong>: We can define the behavior of the mock function using mock implementation to control its return value or actions.</li>
			</ul>
			<p>By using <code>jest.fn()</code>, we can <a id="_idIndexMarker972"/>effectively test different scenarios and edge cases without relying on the actual implementation of the mocked function:</p>
			<pre class="source-code">
    service = module.get&lt;TransactionService&gt;(TransactionService);
    prismaService = module.get&lt;PrismaService&gt;(PrismaService);
    httpService = module.get&lt;HttpService&gt;(HttpService);
    kafkaService = module.get&lt;KafkaService&gt;(KafkaService);</pre>			<p>The <code>module.get</code> method is used to access the providers that were defined in the <code>TestingModule</code> setup. It takes the service class as an argument and returns an instance of that service. By calling <code>module.get</code> for each service (<code>TransactionService</code>, <code>PrismaService</code>, <code>HttpService</code>, and <code>KafkaService</code>), the<a id="_idIndexMarker973"/> code <a id="_idIndexMarker974"/>obtains references to these services, which can then be used for testing purposes.</p>
			<p>These service instances are typically used within the test cases to interact with the system under test and verify its behavior.</p>
			<p>First, let’s start with a simple test case:</p>
			<pre class="source-code">
 it(‹should be defined', () =&gt; {
    expect(service).toBeDefined();
  });</pre>			<p>This code snippet defines a basic test case to ensure the service instance is injected correctly.</p>
			<p>The <code>it('should be defined', () =&gt; { ... })</code> block creates a test case with a description of <code>should be defined</code> Inside this block, the <code>expect(service).toBeDefined();</code> assertion checks whether the <code>service</code> variable has a defined value. This is a fundamental test to verify that the dependency injection process has successfully provided an instance of <code>TransactionService</code>. If the service is <code>null</code> or <code>undefined</code>, the test will fail.</p>
			<p>Essentially, this test case acts as a sanity check to ensure the testing environment has been set up correctly before we proceed with more complex test scenarios. Now, let’s switch to testing the<a id="_idIndexMarker975"/> transaction <a id="_idIndexMarker976"/>creation process:</p>
			<pre class="source-code">
describe('create', () =&gt; {
    it('should create a transaction with status CREATED if account status is new or active', async () =&gt; {
      const createTransactionDto: CreateTransactionDto = {
        accountId: '1',
        description: 'Test transaction',
      };
      const accountApiResponse = {
        data: {
          account: {
            id: '1',
            status: 'active',
          },
        },
      };
      jest.spyOn(httpService.axiosRef, 'get').mockResolvedValue(accountApiResponse);
      jest.spyOn(prismaService.transaction, 'create').mockResolvedValue({
        id: 1,
        accountId: '1',
        description: 'Test transaction',
        status: 'CREATED',
        createdAt: new Date(),
        updatedAt: new Date(),
      });
      const result = await service.create(createTransactionDto);
      expect(result).toEqual(expect.objectContaining({
        id: 1,
        accountId: '1',
        description: 'Test transaction',
        status: 'CREATED',
      }));
      expect(httpService.axiosRef.get).toHaveBeenCalledWith('http://localhost:3001/v1/accounts/1');
      expect(prismaService.transaction.create).toHaveBeenCalledWith({
        data: {
          accountId: '1',
          description: 'Test transaction',
          status: 'CREATED',
        }, }); });</pre>			<p>This test case aims <a id="_idIndexMarker977"/>to<a id="_idIndexMarker978"/> verify the <code>create</code> method of <code>TransactionService</code> under specific conditions.</p>
			<p>It starts by defining a test scenario where the account status is either <code>new</code> or <code>active</code>. A <code>CreateTransactionDto</code> object is created with the necessary data. To simulate external dependencies, <code>httpService</code> and <code>prismaService</code> are mocked using <code>jest.spyOn</code>.</p>
			<p>Here, <code>jest.spyOn</code> is a function in Jest that’s used to create a spy on an existing function. Unlike <code>jest.fn()</code>, which creates a new mock function, <code>jest.spyOn</code> wraps an existing function to track calls and potentially modify its behavior.</p>
			<p>We can use <code>jest.spyOn</code> to observe how a particular function is used within your code without altering its original implementation. It also records information about function calls, such as arguments, return values, and the number of times it was called. This is useful for verifying the interaction between different parts of our code.</p>
			<p>While optional, we can change the behavior of the spied function. This is helpful when we want to control the output of the function for specific test cases. After testing, we can restore the original function’s behavior.</p>
			<p>The <code>httpService.axiosRef.get</code> method is mocked to return a successful account response with an <code>active</code> status. The <code>prismaService.transaction.create</code> method is also mocked to return a created transaction with the <code>CREATE</code> status.</p>
			<p>The <code>service.create</code> method is then called with the prepared <code>createTransactionDto</code> object. The test asserts that the returned result matches the expected transaction data, indicating successful creation. Additionally, it verifies that <code>httpService.axiosRef.get</code> was called with the correct URL to fetch account information, and <code>prismaService.transaction.create</code> was called with the correct data to persist the transaction.</p>
			<p>Essentially, this test <a id="_idIndexMarker979"/>case<a id="_idIndexMarker980"/> ensures that the <code>create</code> method interacts with <code>httpService</code> correctly to fetch account details, determines the transaction status based on account status, and persists the transaction to the database through <code>prismaService</code> with the expected data. By mocking dependencies, the test isolates the <code>create</code> method’s logic and verifies its behavior without relying on external systems.</p>
			<p>It should now be easy for you to understand the rest of the unit tests that have been implemented inside our <code>transaction.service.spec.ts</code> file.</p>
			<p>When implementing unit tests, you may hear a lot about mocks, stubs, and spies. As our last topic regarding unit tests, let’s explore and understand their responsibilities.</p>
			<p>To run all your tests, you simply need to run the <code>npm test</code> command (<em class="italic">Figure 12</em><em class="italic">.2</em>).</p>
			<p>There may be cases where tests fail to run properly. To resolve this, please refer to this book’s GitHub repository and ensure that the <code>package-lock.json</code> file matches the package versions specified in the repository:</p>
			<div><div><img alt="Figure 12.2: Running transaction tests" src="img/B09148_12_2.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: Running transaction tests</p>
			<p>As mentioned <a id="_idIndexMarker981"/>previously, we <a id="_idIndexMarker982"/>can use various building blocks for testing, such as mocks, stubs, and spies. Let’s try to understand and differentiate them.</p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor205"/>Comparing mocks, stubs, and spies in unit tests</h1>
			<p>We’ll spend this section comparing mocks, stubs, and spies in unit tests because they’re essential tools for isolating and simulating components’ behaviors during testing. Understanding their differences will help us choose the right approach to test various interactions and functionalities in the system effectively.</p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor206"/>Mocks</h2>
			<p>A <strong class="bold">mock</strong> is a <a id="_idIndexMarker983"/>simulated object that replaces a real dependency in a <a id="_idIndexMarker984"/>unit test. It’s designed to mimic the behavior of the <a id="_idIndexMarker985"/>original object but with complete control over its actions. Why? This isolation allows for focused testing of the code under scrutiny without the need to rely on external factors.</p>
			<p>We can define exact return values, exceptions, or sequences of actions for mock objects. This enables us to test various scenarios and edge cases. Mocks can record interactions, allowing us to verify that methods were called with correct arguments, in the right order, and with the expected frequency. By replacing real dependencies with mocks, we can create a controlled environment, preventing unexpected side effects and ensuring test reliability.</p>
			<p>Let’s go over the benefits of using mocks:</p>
			<ul>
				<li><strong class="bold">Improved test focus</strong>: Mocks<a id="_idIndexMarker986"/> help you concentrate on the logic of the code being tested, without being distracted by the intricacies of external components.</li>
				<li><strong class="bold">Faster test execution</strong>: Since mocks don’t involve real interactions (such as database calls or network requests), tests run significantly faster</li>
				<li><strong class="bold">Increased test coverage</strong>: Mocks allow you to test different scenarios and edge cases that might be difficult or impossible to reproduce in a real environment.</li>
				<li><strong class="bold">Enhanced code reliability</strong>: By thoroughly testing code in isolation, you can identify and<a id="_idIndexMarker987"/> fix potential issues early in the development<a id="_idIndexMarker988"/> process.</li>
			</ul>
			<p>Next, we’ll look at stubs.</p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor207"/>Stubs</h2>
			<p>On the other <a id="_idIndexMarker989"/>hand, a <strong class="bold">stub</strong> is a<a id="_idIndexMarker990"/> simplified implementation of a <a id="_idIndexMarker991"/>component that’s used to replace a real component in a test. It provides canned answers to calls that are made during the test, focusing on the specific behavior needed for the test case.</p>
			<p>A stub only contains the essential logic required for the test and returns predetermined values or exceptions. It typically doesn’t verify interactions or expectations. That is great, but when can you use them?</p>
			<ul>
				<li>When you need to isolate the unit under test by providing controlled responses.</li>
				<li>When the behavior of the dependency isn’t critical to the test case.</li>
				<li>When you want to speed up test execution by avoiding complex logic.</li>
			</ul>
			<p>While both stubs and mocks are used to replace real components in tests, there’s a key difference. Stubs focus on providing predefined responses and don’t verify interactions, whereas mocks allow for more complex behavior, including expectations and verifying interactions.</p>
			<p>In many cases, stubs <a id="_idIndexMarker992"/>can be sufficient for basic testing, but as<a id="_idIndexMarker993"/> test <a id="_idIndexMarker994"/>requirements become more complex, mocks offer greater flexibility and control.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor208"/>Spies</h2>
			<p>A <strong class="bold">spy</strong> is a wrapper <a id="_idIndexMarker995"/>around an existing object or function <a id="_idIndexMarker996"/>that records <a id="_idIndexMarker997"/>information about how it’s used. Unlike stubs and mocks, which replace the original object, spies observe the behavior of the real object.</p>
			<p>Here are some of the key characteristics of spies:</p>
			<ul>
				<li><strong class="bold">Wrap real object</strong>: Spies <a id="_idIndexMarker998"/>can be created around existing objects or functions.</li>
				<li><strong class="bold">Record interactions</strong>: They track method calls, arguments, and return values.</li>
				<li><strong class="bold">Verify behavior</strong>: Spies are used to ensure that methods are called correctly and with the expected parameters.</li>
			</ul>
			<p>You can use spies in the following instances:</p>
			<ul>
				<li>When you want to verify that a specific method is called with certain arguments.</li>
				<li>When you need to check the sequence of method calls.</li>
				<li>When you want to observe the side effects of a function without controlling its behavior.</li>
			</ul>
			<p>While both spies and mocks can verify interactions, there’s a key difference – spies observe the behavior of the real object, whereas mocks replace the real object with a simulated one.</p>
			<p>Additionally, stubs provide canned responses without verifying interactions. Mocks replace objects and allow for complex behavior and verification. On the other hand, spies observe the behavior of real objects without modifying them.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor209"/>Understanding and implementing integration tests</h1>
			<p><strong class="bold">Integration tests</strong> are an <a id="_idIndexMarker999"/>important component of a robust testing strategy and focus on the interactions between different parts of your application. Unlike unit tests, which isolate individual components, integration tests evaluate how these components work together as a cohesive system.</p>
			<p>In the context of Express.js, integration tests ensure that routes, controllers, models, and databases interact seamlessly. They verify that data flows correctly between these components and that the application produces the expected outcomes.</p>
			<p>Why are integration tests essential? They help prevent integration issues, which can often be complex and time-consuming to debug. By testing the interactions between components, you can catch potential problems early in the development cycle, reducing the risk of unexpected behavior in production.</p>
			<p>Integration tests aren’t a replacement for unit tests. Unit tests focus on the correctness of individual functions and modules, while integration tests verify how these components work together. A comprehensive testing strategy should include both unit and integration tests.</p>
			<p>By investing time in writing effective integration tests, you can significantly improve the quality and reliability of your Express.js applications. They help prevent integration issues, increase confidence in your code base, and ultimately deliver a better user experience.</p>
			<p>Integration testing in Node.js microservices focuses on verifying the interactions between different components or services. It ensures that these components work together seamlessly to deliver the expected outcomes.</p>
			<p>Integration tests catch issues early in development, reducing production failures. By writing comprehensive integration tests, you encourage better code design and maintainability. Successful integration tests build confidence in the system’s overall reliability.</p>
			<p>Before we move on, let’s understand the key aspects of integration testing in microservices:</p>
			<ul>
				<li><strong class="bold">Testing boundaries</strong>: Integration tests primarily focus on the interfaces between microservices. They verify data exchange, contract adherence, and error handling.</li>
				<li><strong class="bold">Dependency management</strong>: Effectively managing dependencies is essential. You might use mocking, stubbing, or test doubles to isolate components for testing.</li>
				<li><strong class="bold">Data consistency</strong>: Integration tests should validate data integrity across different services. This includes testing data transformations, consistency checks, and error handling.</li>
				<li><strong class="bold">Performance considerations</strong>: Integration tests can help identify performance bottlenecks and scalability issues.</li>
			</ul>
			<p>Having said this, it’s also<a id="_idIndexMarker1000"/> important to understand exactly when you’d use integration testing. Let’s look at the instances when you would use this here:</p>
			<ul>
				<li><strong class="bold">API interactions</strong>: Test how different microservices communicate through APIs, verifying request/response formats, error handling, and authentication.</li>
				<li><strong class="bold">Database interactions</strong>: Ensure data is stored, retrieved, and updated correctly across multiple services.</li>
				<li><strong class="bold">Message queues</strong>: Verify message delivery, processing, and error handling in asynchronous communication patterns.</li>
				<li><strong class="bold">External systems</strong>: Test interactions with external systems such as payment gateways, email services, or third-party APIs.</li>
			</ul>
			<p>Long story short, integration tests in Node.js microservices verify that different components or services interact correctly, ensuring seamless functionality and preventing complex issues in production. Now, let’s implement integration tests for the transaction microservice.</p>
			<p>The purpose of this subsection is to show you how you can implement integration tests for your Node.js services, particularly for Nest.js. The general idea of integration testing applies to all types of applications, regardless of whether you use Express.js or other frameworks.</p>
			<p>As always, we need to install the required package to write integration tests for our project. Go to <code>Ch12/transactionservice</code> and run the following command to install the <code>jest</code> and <code>supertest</code> packages:</p>
			<pre class="console">
npm install --save-dev jest @types/jest supertest @nestjs/testing</pre>			<p>We’ve already talked about the <code>jest</code> package. The <code>supertest</code> package is a high-level abstraction for testing HTTP servers. It makes it easy to send HTTP requests to your Nest.js application and inspect the responses, simulating real-world client behavior.</p>
			<p>Nest.js provides excellent integration with both Jest and Supertest, making it straightforward to set up and run integration tests. You can test various aspects of your Nest.js application, including controllers, services, and database interactions. Integration tests can be included in your CI/CD pipeline so that you can catch issues early in the development<a id="_idIndexMarker1001"/> process.</p>
			<p>Go to the root folder (<code>Ch12/transactionservice</code>) and create the <code>jest.config.js</code> file with the following content:</p>
			<pre class="source-code">
// jest.config.js
module.exports = {
    moduleFileExtensions: [
        'js',
        'json',
        'ts',
    ],
    rootDir: 'src',
    testRegex: '.*\\.spec\\.ts$',
    transform: {
        '^.+\\.(t|j)s$': 'ts-jest',
    },
    collectCoverageFrom: [
        '**/*.(t|j)s',
    ],
    coverageDirectory: '../coverage',
    testEnvironment: 'node',
    globalSetup: './test/global-setup.js',
    globalTeardown: './test/global-teardown.js',
};</pre>			<p>Let’s break down the code here:</p>
			<ul>
				<li>The <code>jest.config.js</code> file is a configuration file that customizes Jest’s behavior. This particular configuration specifies that Jest should look for TypeScript, JavaScript, and JSON files (<code>moduleFileExtensions</code>). It sets the project root directory to <code>src</code>, defines test files as those ending with <code>.spec.ts</code>, and uses <code>ts-jest</code> to process TypeScript files. The configuration also enables code coverage reporting to <code>../coverage</code>, sets the test environment to Node.js, and executes <code>global-setup.js</code> before all tests and <code>global-teardown.js</code> after.</li>
				<li>Next, we have <code>globalSetup</code> and <code>globalTeardown</code> in our Jest configuration to execute code before and after the entire test suite runs, respectively.</li>
				<li>Then, <code>globalSetup</code> runs once before all tests. It’s ideal for setting up resources such as databases, servers, or other external dependencies that are required for the tests.</li>
				<li>Finally, <code>globalTeardown</code> runs once after all tests have been completed. It’s used to clean up resources that are created in <code>globalSetup</code>, such as closing database connections or stopping servers.</li>
			</ul>
			<p>In the provided <a id="_idIndexMarker1002"/>configuration, the scripts for these operations are located in the <code>./test/global-setup.js</code> and <code>./test/global-teardown.js</code> files. However, we don’t have these files yet. So, let’s create them. Go to the <code>test</code> folder and create both files.</p>
			<p>Here’s our <code>global-setup</code> file:</p>
			<pre class="source-code">
const { execSync } = require('child_process');
module.exports = async () =&gt; {
    console.log('Starting Docker Compose...');
    execSync('docker-compose -f docker-compose.tests.yml up 
      --build -d', { stdio: 'inherit' });
    // You might need to add a delay here to give services time to initialize
    await new Promise(resolve =&gt; setTimeout(resolve, 15000)); };</pre>			<p>This global setup script initiates a Docker Compose environment for testing. It starts by logging a message, and then executes the <code>docker-compose up --build -d</code> command using the specified <code>docker-compose.tests.yml</code> file. Finally, it introduces a fifteen second delay to allow services sufficient time to start before test execution begins.</p>
			<p>Here’s the <code>global-teardown</code> file:</p>
			<pre class="source-code">
const { execSync } = require('child_process');
module.exports = async () =&gt; {
    console.log(‹Stopping Docker Compose...›);
    execSync('docker-compose -f docker-compose.tests.yml down', 
      { stdio: 'inherit' });
};</pre>			<p>This <code>global-teardown</code> script terminates the Docker Compose environment. It logs a message indicating <a id="_idIndexMarker1003"/>the process and then executes the <code>docker-compose down</code> command using the specified <code>docker-compose.tests.yml</code> file to stop all running containers and remove networks.</p>
			<p>We run all dependent services from the Docker file, hence why we have a special file called <code>docker-compose.tests.yml</code> under <code>Ch12/transactionservice</code>. Check out this book’s GitHub repository for the source code for the <code>docker-compose.tests.yml</code> file.</p>
			<p>This Docker Compose file defines a multi-container environment for a microservices application. It includes services for a PostgreSQL database, <code>PgAdmin</code> for database management, MongoDB, Zookeeper, Kafka, and a Kafka UI. The file also defines an account service built from a local <code>Dockerfile</code> file, configuring its dependencies on MongoDB and Kafka. Environment variables, ports, volumes, and network configurations are specified for each service. Here, <code>app-network</code> is used for internal communication between containers.</p>
			<p>When writing integration tests for Nest.js applications, we often create a test configuration file. This configuration file specifies configuration values that are necessary for the test environment, such as database connections, API keys, or other sensitive information. You can set up in-memory or temporary databases for testing purposes to isolate test data and prevent conflicts with production data. It also helps us to configure mocking libraries or frameworks so that we can replace real external services with test doubles, improving test isolation and performance. We mostly define configuration options for testing frameworks or libraries, such as Jest or Supertest, to customize their behavior for integration tests. By centralizing test-specific configurations in a separate file, you enhance code organization, maintainability, and reusability. It also helps to prevent sensitive information from being accidentally committed to the main code base. Check out the <code>Ch12/transactionservice/test-configuration.ts</code> file for more content.</p>
			<p>Our test configuration file sets up a Nest.js testing module for integration tests. It imports the necessary modules for database connection (<code>TypeOrm</code>), microservices (<code>ClientsModule</code>), and the target module (<code>TransactionModule</code>). It also configures a PostgreSQL database using environment variables or default values and establishes a Kafka client. Finally, the <code>testConfiguration</code> function compiles the testing module and returns it for use in integration tests.</p>
			<p>If you haven’t<a id="_idIndexMarker1004"/> installed it yet, don’t forget to run the following command to make sure your test configuration will run properly:</p>
			<pre class="console">
npm install --save @nestjs/microservices @nestjs/testing @nestjs/typeorm</pre>			<p>Here, <code>@nestjs/typeorm</code> is a package that seamlessly integrates <code>TypeORM</code>, a popular <strong class="bold">object-relational mapper</strong> (<strong class="bold">ORM</strong>), with <a id="_idIndexMarker1005"/>the Nest.js framework. It provides a convenient way to interact with relational databases such as PostgreSQL, MySQL, SQLite, and others within your Nest.js application.</p>
			<p>You must define your database tables as TypeScript classes (<em class="italic">entities</em>). Here, <code>TypeORM</code> handles the mapping between your code and the database schema. It supports features such as repositories, migrations, transactions, and more, making database operations efficient and reliable.</p>
			<p>Now, it’s time to write our simple integration test for the transaction microservice. The <code>transaction.controller.spec.ts</code> file can be found under <code>Ch12/transactionservice/src/test</code> and contains the following content:</p>
			<pre class="source-code">
import { INestApplication } from '@nest.js/common';
import { testConfiguration } from '../test/test-configuration';
import * as request from 'supertest';
describe('AppController (e2e)', () =&gt; {
  let app: INestApplication;
  beforeAll(async () =&gt; {
    const moduleFixture = await testConfiguration();
    app = moduleFixture.createNestApplication();
    await app.init();
  });
  afterAll(async () =&gt; {
    await app.close();
  });
  it('/transactions (POST) should create a transaction', async () =&gt; {
    const createTransactionDto = {
      accountId: '6658ae5284432e40604018d5', // UUID
      description: 'Test transaction',
    };
    return request(app.getHttpServer())
      .post('/transaction')
      .send(createTransactionDto)
      .expect(400);
  }, 10000); });</pre>			<p>This test imports the necessary modules for testing and HTTP requests. The <code>beforeAll</code> hook sets up the test environment by creating a Nest.js application using the <code>testConfiguration</code> function, while the <code>afterAll</code> hook cleans up by closing the application. The test case focuses on creating a transaction. It constructs a transaction DTO with sample data and sends a <code>POST</code> request to the <code>/transaction</code> endpoint. The expected response status is <code>400</code> (<em class="italic">Bad Request</em>), indicating an error in the request. A timeout of <code>10000</code> milliseconds (<code>10</code> seconds) is set for the test. This test case verifies the basic functionality of the transaction creation endpoint and provides a foundation for further testing scenarios.</p>
			<p>To run your tests, simply execute the <code>npm run test</code> command. Make sure Docker is running before<a id="_idIndexMarker1006"/> executing any integration tests:</p>
			<div><div><img alt="Figure 12.3: Docker services" src="img/B09148_12_3.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: Docker services</p>
			<p>When running integration tests with a Dockerized account microservice, the primary challenge is ensuring a consistent data state for each test. This involves doing the following:</p>
			<ul>
				<li><strong class="bold">Data preparation</strong>: Creating necessary accounts or records before each test.</li>
				<li><strong class="bold">Data cleanup</strong>: Removing test data after each test to prevent data pollution.</li>
				<li><strong class="bold">Database isolation</strong>: Ensuring test data doesn’t interfere with other tests or environments.</li>
			</ul>
			<p>To handle these challenges, we can use multiple solutions:</p>
			<ul>
				<li><code>typeorm</code> and <code>sequelize</code> to create migration scripts for your account database:<ul><li><code>globalSetup</code> or <code>beforeEach</code> hooks to populate the database with test data.</li><li><code>globalTeardown</code> or <code>afterEach</code> hooks to clean up the database.</li></ul></li>
				<li><strong class="bold">Docker volumes</strong>: Define a Docker volume for your account microservice’s database:<ul><li><strong class="bold">Mount the volume</strong>: Mount the volume to the container to persist data between test runs.</li><li><strong class="bold">Truncate or delete data</strong>: Before each test, truncate or delete the database’s content to ensure a clean state.</li></ul></li>
				<li><strong class="bold">Test containers</strong>: For complex scenarios, use a dedicated container for test data preparation and cleanup:<ul><li><strong class="bold">Orchestrate with Docker Compose</strong>: Use Docker Compose to manage the relationship between the test container and the account microservice.</li></ul></li>
				<li><strong class="bold">In-memory databases</strong>: For simpler scenarios, use in-memory databases such as SQLite for testing:<ul><li><strong class="bold">Benefits</strong>: Faster startup, isolation, and no need for data migration.</li></ul></li>
			</ul>
			<p>With that, we’ve<a id="_idIndexMarker1007"/> come to the end of this chapter! Let’s recap what we learned.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor210"/>Summary</h1>
			<p>In this chapter, we delved into the critical role of testing in microservice architecture. Building upon our previous exploration of microservice creation, we emphasized the importance of rigorous testing for ensuring code quality and reliability. We introduced the concepts of unit and integration testing, explaining their distinct purposes and benefits.</p>
			<p>To solidify our understanding, we implemented unit tests for both the account and transaction microservices. These tests verified the correct behavior of individual code units in isolation. Additionally, we explored the nuances of mocks, stubs, and spies, demonstrating their utility in isolating components during testing.</p>
			<p>To assess the interactions between different microservices, we introduced integration testing. By combining unit tests with integration tests, we established a robust testing strategy for our microservices.</p>
			<p>In the next chapter, we will dive into the practical implementation of CI/CD pipelines. We will explore how to utilize GitHub Actions to automate workflows and streamline the deployment of our microservices, particularly focusing on deploying to Azure Cloud. You’ll learn how to build a fully automated pipeline that ensures your applications are consistently ready for deployment with minimal manual intervention.</p>
		</div>
	</body></html>