<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer264">
			</div>
		</div>
		<div class="Content" id="_idContainer265">
			<h1 id="_idParaDest-405"><a id="_idTextAnchor449"/>11. Creating Clean and Maintainable Code</h1>
		</div>
		<div class="Content" id="_idContainer288">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to identify and implement basic regular expressions (regex); use best practices to produce clean and maintainable code; utilize code quality tools such as <strong class="source-inline">ESLint</strong>, <strong class="source-inline">JSLint</strong>, and <strong class="source-inline">JSHint</strong> and implement strategies for refactoring code.</p>
			<h1 id="_idParaDest-406"><a id="_idTextAnchor450"/>Introduction</h1>
			<p>In this chapter, you will learn about the techniques that can be used for pattern matching and clean coding, which have many uses, perhaps even to facilitate your testing as well.</p>
			<p><strong class="bold">Regular expressions</strong> (<strong class="bold">regex</strong> for short) are a concise and powerful method to search for and match patterns. They may appear alien and intimidating at first, but once you learn the basics, they will quickly appear less difficult, and so you are likely to recognize their usefulness. Regexes are common in many languages and in tools where text and data are involved. So, it is a worthwhile investment to take the time to learn them. A pattern that's expressed as a regex is usually much shorter than the equivalent code that's required to parse and match the same pattern using conventional techniques. </p>
			<p>Making use of regexes also leads to clean and maintainable coding practices. For programming projects to be successful, it is critical that the code is easily understood by others and that it is orderly, focused, and flexible. This chapter introduces techniques and best practices for coding, starting with choosing the clearest and most understandable names for your variables and methods.</p>
			<h1 id="_idParaDest-407"><a id="_idTextAnchor451"/>What Is a Regex?</h1>
			<p>A <strong class="bold">regex</strong> is a sequence of characters that form a pattern that's used to search. Each character in the pattern either has special meaning (a metacharacter) or is meant to match the character itself (a literal). This is perhaps best understood by the following example.</p>
			<p>As a demonstration of the difference between pattern matching with conventional coding versus regex techniques, consider the following code for matching phone number format patterns in a conventional way. We'll then rewrite the matching logic using a regex for comparison. To keep things simple, we will only look for phone numbers that match the following pattern, which is common for phone numbers, particularly in the United States:</p>
			<p class="source-code">	[2-9]XX-XXX-XXXX</p>
			<p>Here, <strong class="source-inline">X</strong> can be any digit from <strong class="source-inline">0-9</strong>, and the first digit cannot be a zero or one (only <strong class="source-inline">2-9</strong> are permitted). For example, <strong class="source-inline">234-567-8901</strong> is a valid phone number in this format.</p>
			<p>You can use the following code to do the matching using conventional methods:</p>
			<p class="source-code-heading">conventional.html</p>
			<p class="source-code">1 &lt;html&gt;</p>
			<p class="source-code">2 &lt;head&gt;</p>
			<p class="source-code">3   &lt;meta charset="utf-8"/&gt;</p>
			<p class="source-code">4 &lt;/head&gt;</p>
			<p class="source-code">5 &lt;body&gt;</p>
			<p class="source-code">6 Enter a phone number in format XXX-XXX-XXXX:</p>
			<p class="source-code">7 &lt;input type="text" id="phone"&gt;</p>
			<p class="source-code">8 &lt;div id="msg"&gt;&lt;/div&gt;</p>
			<p class="source-code">9 &lt;script&gt;</p>
			<p class="source-code">10 var phone = document.getElementById("phone");</p>
			<p class="source-code">11 phone.addEventListener("input", validatePhoneNumber);</p>
			<p class="source-code">12 function isDigit(character) {</p>
			<p class="source-code">13     return character &gt;= '0' &amp;&amp; character &lt;= '9';</p>
			<p class="source-code">14 }</p>
			<p class="source-code-link">The full code is available at: <a href="https://packt.live/2CFKQtK">https://packt.live/2CFKQtK</a></p>
			<p>The following screenshot show the output of the preceding code when a number is entered in an invalid format:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer266">
					<img alt="Figure 11.1: Sample output when a number is input in an incorrect format&#13;&#10;" src="image/C14377_11_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1: Sample output when a number is input in an incorrect format</p>
			<p>Here's the output when a number is entered in a valid format:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer267">
					<img alt="Figure 11.2: Sample output when a number is input correctly&#13;&#10;" src="image/C14377_11_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2: Sample output when a number is input correctly</p>
			<p>Let's focus on the important parts of the JavaScript code:</p>
			<p class="source-code">var phone = document.getElementById("phone");</p>
			<p class="source-code">phone.addEventListener("input", validatePhoneNumber);</p>
			<p>These lines set up the phone number validation, which is to be done as the user enters a value. It finds the DOM element of the input text and adds an event listener for the <strong class="source-inline">input</strong> event. This event occurs when the value of <strong class="source-inline">&lt;input&gt;</strong> is changed, such as with a keypress or even if a value is pasted in using cut/paste. When triggered, the <strong class="source-inline">validatePhoneNumber()</strong> function is called.</p>
			<p>Note the code that checks whether a character is a digit:</p>
			<p class="source-code">function isDigit(character) {</p>
			<p class="source-code">    return character &gt;= '0' &amp;&amp; character &lt;= '9';</p>
			<p class="source-code">}</p>
			<p>This function has a parameter that must be just one character. What may not be intuitive is that JavaScript allows greater than or less than operators on character types. This allows us to check that the character is any digit in the range between the <strong class="source-inline">0</strong> and <strong class="source-inline">9</strong> characters.</p>
			<p>The following is the code for the <strong class="source-inline">validatePhoneNumber()</strong> method:</p>
			<p class="source-code">    var phoneNum = phone.value.trim();</p>
			<p class="source-code">    // check if phone number matches format [2-9]XX-XXX-XXXX</p>
			<p class="source-code">    var valid =</p>
			<p class="source-code">        phoneNum.length == 12 &amp;&amp;</p>
			<p class="source-code">        phoneNum.charAt(0) != '0' &amp;&amp;</p>
			<p class="source-code">        isDigit(phoneNum.charAt(0)) &amp;&amp;</p>
			<p class="source-code">        isDigit(phoneNum.charAt(1)) &amp;&amp;</p>
			<p class="source-code">        isDigit(phoneNum.charAt(2)) &amp;&amp;</p>
			<p class="source-code">        phoneNum.charAt(3) == '-' &amp;&amp;</p>
			<p>This code does the following:</p>
			<ul>
				<li>Checks the expected length of the phone number to make sure there are no ex<a id="_idTextAnchor452"/>traneous characters, such as additional digits, alphabetic characters, or symbols. Note that since we're calling the <strong class="source-inline">trim()</strong> function when we initially read the phone number value, this check is forgiving of leading and trailing whitespace.</li>
				<li>Checks that the first character is not a <strong class="source-inline">0</strong>.</li>
				<li>Checks that the first three characters are digits (indices <strong class="source-inline">0-2</strong>).<p class="callout-heading">Note </p><p class="callout">Rather than calling the <strong class="source-inline">isDigit()</strong> function multiple times, we could have added parameters to the function so that multiple characters would be checked in one invocation. However, for the purposes of this exercise, we chose to keep the code simpler and easier to understand.</p></li>
				<li>Checks for the <strong class="source-inline">-</strong> character afterward.</li>
			</ul>
			<p>The rest of the validation repeats and is similar for the rest of the characters.</p>
			<p>Finally, the validation message is formed and set in the <strong class="source-inline">&lt;div&gt;</strong>:</p>
			<p class="source-code">    var validMsg = "phone number entered is " +</p>
			<p class="source-code">        (valid ? "valid." : "INVALID!!!");</p>
			<p class="source-code">    document.getElementById("msg").innerHTML = validMsg;</p>
			<p>We will now compare this logic to an equivalent implementation using regexes. We'll describe regexes more methodically and in more depth in the next section, but for now, we'll look at how to code with regex techniques, even though it may not make much sense to you yet. We will code an alternative to the phone number validation function we presented, which uses regexes. So, don't worry if you don't quite understand all the concepts yet, as they will be explained in detail later.</p>
			<p>Consider the preceding code, which is for pattern matching with conventional methods. Let's modify it so that it uses a regex.</p>
			<p>To do this, find the <strong class="source-inline">validatePhoneNumber()</strong> function and the declaration of the <strong class="source-inline">valid</strong> variable. Then, delete the entire expression all the way to the semicolon (<strong class="source-inline">;</strong>) character until the comment above it. Replace the area you deleted with the following:</p>
			<p class="source-code">// check if phone number matches format [2-9]XX-XXX-XXXX</p>
			<p class="source-code">var valid = phoneNum.match(//);</p>
			<p>At this point, you only have a shell of a regex in the area between the two forward slash marks. </p>
			<p>After the first forward slash, add a <strong class="source-inline">^</strong> character (called a caret). Your code should now look like this:</p>
			<p class="source-code">var valid = phoneNum.match(/^/);</p>
			<p>The <strong class="source-inline">^</strong> symbol is an <strong class="bold">anchor </strong>that indicates matching should begin at the start of the string.</p>
			<p>Now, add the characters <strong class="source-inline">[2-9]</strong> so that the code now looks like this:</p>
			<p class="source-code">var valid = phoneNum.match(/^[2-9]/);</p>
			<p>The <strong class="source-inline">[2-9]</strong> characters specify a <strong class="bold">character range</strong> to indicate that it must match a character between <strong class="source-inline">2</strong> and <strong class="source-inline">9</strong>.</p>
			<p>By now, you will be able to see how you are progressively adding more characters with each step. In a similar fashion, add the remaining characters one by one, as shown in the left column of the following table:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer268">
					<img alt="Figure 11.3: Table of characters&#13;&#10;" src="image/C14377_11_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3: Table of characters</p>
			<p>The complete code should now look like this:</p>
			<p class="source-code">    // check if phone number matches format [2-9]XX-XXX-XXXX</p>
			<p class="source-code">    var valid = phoneNum.match(/^[2-9]\d{2}-\d{3}-\d{4}$/);</p>
			<p>Here, you have seen the power of regular expressions and that all of them can be expressed in just one line of code. The different concepts of a regular expressions are shown in the following figure:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer269">
					<img alt="Figure 11.4: Showing different concepts in the regular expression&#13;&#10;" src="image/C14377_11_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4: Showing different concepts in the regular expression</p>
			<h1 id="_idParaDest-408"><a id="_idTextAnchor453"/>Regexes in Detail</h1>
			<p>I<a id="_idTextAnchor454"/>n the upcoming sections, the following sample phrase is used for illustration:</p>
			<p>  "The ships were loaded with all these belongings of the mother"</p>
			<p>This phrase will be used to demonstrate various regex concepts, including literal characters, word boundaries, character classes, and others.</p>
			<h2 id="_idParaDest-409"><a id="_idTextAnchor455"/>Literal Characters</h2>
			<p>The simplest regex is one of more <strong class="bold">literal characters</strong>, such as <strong class="source-inline">the</strong>. This indicates a pattern that is a match if the <strong class="source-inline">t</strong> character is immediately followed by <strong class="source-inline">h</strong> and finally an <strong class="source-inline">e</strong> character. This expression would have four matches in the sample phrase: the initial <strong class="source-inline">the</strong>, the second to last word, <strong class="source-inline">the</strong>, <strong class="source-inline">the</strong> in the word <strong class="source-inline">these</strong>, and the sequence of <strong class="source-inline">the</strong> as part of the word <strong class="source-inline">mother</strong>.</p>
			<h2 id="_idParaDest-410"><a id="_idTextAnchor456"/>Special Characters, Anchors, and Escaping</h2>
			<p>If a regex only had literals, its usefulness would be limited. In most cases, you do not want to only match literals; therefore, regexes have a number of characters that have special meanings. These are also known as metacharacters. Two of these special characters are the <strong class="source-inline">^</strong> and <strong class="source-inline">$</strong> <strong class="bold">anchors</strong> that you saw earlier, which indicate the beginning and end of a string, respectively.</p>
			<p>So, if you change the regex to <strong class="source-inline">^the</strong>, only the initial <strong class="source-inline">the</strong> of the phrase would now be a match since this is the only instance of <strong class="source-inline">the</strong> in the phrase that is at the beginning of the string. Anchors are often important in situations where you need to avoid matching too much that is not intended to be matched.</p>
			<p>The following are the most common characters that have special meaning in regexes:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer270">
					<img alt="Figure 11.5: Special characters&#13;&#10;" src="image/C14377_11_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5: Special characters</p>
			<p class="callout-heading">Note </p>
			<p class="callout">If you need to use any of these characters in your regexes as a literal character, in most cases, the character will need to be escaped. You do that by placing a backslash <strong class="source-inline">\</strong> before the character.</p>
			<p>Here are two examples:</p>
			<ul>
				<li>If you need to match a dollar sign as part of your pattern, you would use <strong class="source-inline">\$</strong>.</li>
				<li>Some less obvious escapes are the backslash character itself (you would just use two consecutive backslashes, for example, <strong class="source-inline">\\</strong>), and a dot, where <strong class="source-inline">\.</strong> is the correct escaping sequence.</li>
			</ul>
			<h2 id="_idParaDest-411"><a id="_idTextAnchor457"/>Word Boundary</h2>
			<p>Another type of anchor is a <strong class="bold">word boundary</strong>, which is denoted by <strong class="source-inline">\b</strong> (a backslash followed by a <strong class="source-inline">b</strong>). A word boundary is defined as either of the following:</p>
			<ul>
				<li>The beginning of a string, followed by a word character</li>
				<li>The character between whitespace and a word character, or after a word character leading to either whitespace or the end of the string</li>
			</ul>
			<p>Note that the word characters are defined as follows.</p>
			<ul>
				<li>If the preceding regex was changed to <strong class="source-inline">\bthe</strong>, there would only be three matches in the sample phrase: the four previous matches, minus <strong class="source-inline">the</strong> in <strong class="source-inline">mother</strong>. (The initial <strong class="source-inline">\b</strong> of the pattern are special characters, and the remainder are literal characters.)</li>
				<li>If the regex was changed to <strong class="source-inline">\bthe\b</strong>, only the two standalone <strong class="source-inline">the</strong> words would be matches, and not the ones in <strong class="source-inline">these</strong> or <strong class="source-inline">mother</strong>. This is one way to specify to search for whole words, but with no other leading or trailing characters in a given word.</li>
			</ul>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor458"/>Shorthand Character Classes and Word Characters</h2>
			<p>There are a number of <strong class="bold">character classes </strong>that are available in a sort of shorthand notation due to how commonly they are used. One is the <strong class="source-inline">\d </strong>sequence, which denotes any digit <strong class="source-inline">[0-9]</strong>.</p>
			<p>Another is the <strong class="bold">word character,</strong> <strong class="source-inline">\w</strong>, which is defined as <strong class="source-inline">[A-Za-z0-9_]</strong>. (Character classes and ranges will be defined in more detail next. For now, this is read as a character in the range of uppercase characters <strong class="source-inline">A-Z</strong>, range of characters <strong class="source-inline">a-z</strong>, range of digits <strong class="source-inline">0-9</strong>, or the underscore <strong class="source-inline">_</strong> character.) Here are some examples:</p>
			<ul>
				<li>If the <strong class="source-inline">the\w</strong> regex were used on the preceding sample phrase, only the sequence of <strong class="source-inline">the</strong> in the words <strong class="source-inline">these</strong> and <strong class="source-inline">mother</strong> would be a match, since the other two <strong class="source-inline">the</strong> words do not have a word character following it.</li>
				<li>If the <strong class="source-inline">\wthe\w</strong> regex were used, only the sequence of <strong class="source-inline">the</strong> in the word <strong class="source-inline">mother</strong> would match, as it is the only place in the string where the sequence <strong class="source-inline">the</strong> is both preceded and followed by a word character. This is one way to specify how to search for characters that are only contained within a word.</li>
				<li>Combining the word boundary and word character shortcuts, if the regex <strong class="source-inline">\bthe\w</strong> were used, only the sequence of <strong class="source-inline">the</strong> in the word <strong class="source-inline">these</strong> would match as it is the only place in the string where the sequence <strong class="source-inline">the</strong> starts on a word boundary and is followed by a word character.</li>
			</ul>
			<p>Another common shorthand character class is <strong class="source-inline">\s</strong>, which is shorthand for whitespace, including space characters, tabs, and newlines.</p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor459"/>Inverse Classes</h2>
			<p>Every shorthand character class has an inverse class as well, denoted by making the letter uppercase:</p>
			<ul>
				<li><strong class="source-inline">\B</strong>: The opposite of a word boundary, such as in the middle of a word</li>
				<li><strong class="source-inline">\D</strong>: Represents any non-digit character</li>
				<li><strong class="source-inline">\W</strong>: Any character that is not included in <strong class="source-inline">[A-Za-z0-9_]</strong></li>
				<li><strong class="source-inline">\S</strong>: Any non-whitespace character</li>
			</ul>
			<p>For example, as the inverse of the first example in the previous section, if the <strong class="source-inline">the\W</strong> regex were used on the preceding sample phrase, only the two <strong class="source-inline">the</strong> characters would match, including the trailing space character. The words <strong class="source-inline">these</strong> and <strong class="source-inline">mother</strong> would be a match, since in both cases there is a word character following <strong class="source-inline">the</strong>.</p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor460"/>Dot Character</h2>
			<p>The dot, <strong class="source-inline">.</strong>, matches any character except newlines. For instance, the <strong class="source-inline">.h.</strong> regex looks for any <strong class="source-inline">h</strong> and matches it with the character before and after it, as long as it is not a newline. The highlighted characters that follow are the result of applying the regex to the earlier sample phrase:</p>
			<p> "The ships were loaded with all these belongings of the mother"</p>
			<p>Take special note of the third match of the last two letters of the word <strong class="source-inline">with</strong>, along with the space character that follows it. It is easy to forget that a dot matches any character, including a space. This can be a common error if you do intend to allow spaces in your pattern.</p>
			<h2 id="_idParaDest-415"><a id="_idTextAnchor461"/>Sets</h2>
			<p>One or more characters or character classes enclosed in square brackets, <strong class="source-inline">[...]</strong>, indicates we should match any of the given characters. This is called a <strong class="bold">set</strong>. Here are two examples:</p>
			<ul>
				<li>The <strong class="source-inline">[AEIOUaeiou]</strong> regex can be used to match vowel characters.</li>
				<li>When combining a set followed by two literal characters, the <strong class="source-inline">[oi]ng</strong> regex would match the <strong class="source-inline">ong</strong> and the <strong class="source-inline">ing</strong> in the word <strong class="source-inline">belongings</strong> (from the sample phrase).</li>
			</ul>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor462"/>Ranges</h2>
			<p>One <strong class="bold">range</strong> you saw earlier was <strong class="source-inline">[2-9]</strong>, which indicated a character between <strong class="source-inline">2</strong> and <strong class="source-inline">9</strong>. Similar to sets, ranges are specified within square brackets, <strong class="source-inline">[...]</strong>, and use a dash character to separate the characters that indicate the range.</p>
			<p>Another range you saw earlier was <strong class="source-inline">[A-Za-z0-9_]</strong>, which specified the word characters. This also shows how multiple ranges and even a character that's not part of a range can be indicated in one expression, as this allows characters from <strong class="source-inline">A-Z</strong>, <strong class="source-inline">a-z</strong>, and <strong class="source-inline">0-9</strong>, as well as the underscore character.</p>
			<h2 id="_idParaDest-417"><a id="_idTextAnchor463"/>Excluding Sets and Ranges</h2>
			<p>The opposite of regular sets and ranges, an excluding range indicates to "match a character except for the following". Excluding sets or ranges is indicated by placing a caret character, <strong class="source-inline">^</strong>, immediately after the first square bracket in the expression.</p>
			<p>For instance, <strong class="source-inline">[^AEIOUaeiou]</strong> would match any character that is NOT a vowel.</p>
			<p>The dash can also be included in the exclusion to indicate a range of characters to be excluded. For example, <strong class="source-inline">[^0-9]</strong> would indicate to match any character that is not a digit (similar to <strong class="source-inline">\d</strong>).</p>
			<h2 id="_idParaDest-418"><a id="_idTextAnchor464"/>Quantifiers</h2>
			<p>A <strong class="bold">quantifier</strong> specifies how many of a given character, character class, or token are required for a match.</p>
			<p>Perhaps the most straightforward is a <strong class="bold">fixed quantifier</strong>, which requires an exact number of occurrences for it to be a match, as you saw at the beginning of this section. This type is specified by placing a number inside a pair of curly braces, such as <strong class="source-inline">{4}</strong>. For example, the <strong class="source-inline">a{4}</strong> regex would require the letter <strong class="source-inline">a</strong> to be repeated four times, and <strong class="source-inline">\d{3}</strong> would require three digits in sequence.</p>
			<p>Its close cousin, the range quantifier, can be specified using a format similar to <strong class="source-inline">{min,max}</strong>. This one would match if anything between the specified minimum and maximum number of occurrences was present. For example, the <strong class="source-inline">a{2,5}</strong> regex would match any of <strong class="source-inline">aa</strong>, <strong class="source-inline">aaa</strong>, <strong class="source-inline">aaaa</strong>, or <strong class="source-inline">aaaaa</strong>.</p>
			<p>A special type of range allows for an unbounded upper limit if the numeral after the comma is omitted. For example, <strong class="source-inline">a{3,}</strong> would match any number of consecutive <strong class="source-inline">a</strong> characters of at least three occurrences.</p>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor465"/>Shorthand Quantifiers</h2>
			<p>There are three quantifiers that are used so often that they have special shortcut characters designated to denote them. They are as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer271">
					<img alt="Figure 11.6: Quantifiers&#13;&#10;" src="image/C14377_11_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6: Quantifiers</p>
			<p>Combining these shorthand qualifiers with the concepts we previously covered (literals, character classes, sets, ranges, and so on), the following are example regexes and what they would match:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer272">
					<img alt="Figure 11.7: Regex and their Matches&#13;&#10;&#13;&#10;" src="image/C14377_11_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7: Regex and their Matches</p>
			<h2 id="_idParaDest-420"><a id="_idTextAnchor466"/>Alternation</h2>
			<p>Let's say you want your pattern to allow either of two (or more) words. You can do this by separating the words with a pipe <strong class="source-inline">|</strong> character, which is equivalent to an <strong class="source-inline">OR</strong> indicating <strong class="source-inline">expression1 OR expression2</strong>. </p>
			<p>In most cases, it is also a good idea to enclose the alternative expressions in parenthesis, for example,<strong class="source-inline">(expression1|expression2)</strong>, to separate them from the rest of the pattern. For example, to scan for either a word, <strong class="source-inline">the</strong>, followed by one or more whitespace characters, which would be either <strong class="source-inline">mother</strong> or <strong class="source-inline">father</strong>, the regex would be as follows:</p>
			<p class="source-code">    the\s+(mother|father)</p>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor467"/>Many More Regex Concepts</h2>
			<p>This chapter covers only a brief overview of basic regex concepts and provides a good background so that you can get started with them. You are encouraged to explore more advanced features using the many available resources. These include the following concepts: </p>
			<ul>
				<li>Greedy versus lazy quantifiers: <a href="https://packt.live/33vxqvQ">https://packt.live/33vxqvQ</a></li>
				<li>Capturing groups: <a href="https://packt.live/34Iq0G0">https://packt.live/34Iq0G0</a></li>
				<li>Backreferences: <a href="https://packt.live/2NqrDCe">https://packt.live/2NqrDCe</a></li>
				<li>Lookahead and lookbehind: <a href="https://packt.live/2NrkMbR">https://packt.live/2NrkMbR</a></li>
				<li>Sticky flag: https://packt.live/32q86Gw</li>
				<li>The internals of how regex engines actually work: <a href="https://packt.live/2oXQUKE">https://packt.live/2oXQUKE</a> </li>
			</ul>
			<h2 id="_idParaDest-422"><a id="_idTextAnchor468"/>Pattern Specification and Flags</h2>
			<p>So far, we have covered the elements that comprise regex patterns, but now, we will cover how these patterns are conveyed in JavaScri<a id="_idTextAnchor469"/>pt code. The most common method is to enclose the pattern in a pair of slash characters, for example, <strong class="source-inline">/pattern/</strong>. Flags can also be added after the second slash, though this is optional.</p>
			<p>Flags can change the behavior of how matching and searching occurs. The most common flags are as follows:</p>
			<ul>
				<li><strong class="source-inline">g</strong>: If specified, all matches are returned (if not specified, only the first match is returned by default).</li>
				<li><strong class="source-inline">i</strong>: Makes the matching case-insensitive; there's no differentiation between uppercase and lowercase letters.</li>
			</ul>
			<p>Others include <strong class="source-inline">m</strong> (multiline search), <strong class="source-inline">s</strong> (dot  <strong class="source-inline">.</strong> matches newline), <strong class="source-inline">u</strong> (Unicode support), and <strong class="source-inline">y</strong> (sticky mode).</p>
			<h2 id="_idParaDest-423"><a id="_idTextAnchor470"/>Finding Matches with String.match()</h2>
			<p>The JavaScript <strong class="source-inline">String</strong> class has a number of built-in methods that accept regex parameters. This section outlines some of them.</p>
			<p>The most common method you would use is <strong class="source-inline">String.match()</strong>. This method behaves differently, and its return value varies depending on whether the <strong class="source-inline">g</strong> flag is included:</p>
			<ul>
				<li>If there is no <strong class="source-inline">g</strong> flag: Searching stops after the first match is found. The result is an array with the match returned as the array element, the additional property <strong class="source-inline">index</strong>, indicating the position where the match was found, and some additional properties. (Note that it has other functionalities if the regex contains groupings, but groups are not covered in this chapter)</li>
				<li>If there is a <strong class="source-inline">g</strong> flag: Searches for all possible matches and returns those found in an array. There are no other properties in the return value.</li>
			</ul>
			<h2 id="_idParaDest-424"><a id="_idTextAnchor471"/>Exercise 11.01: The Effect of the g Flag</h2>
			<p>The following code illustrates the difference regarding whether the <strong class="source-inline">g</strong> flag is present or not. It matches words that begin with the letter <strong class="source-inline">t</strong>. (The <strong class="source-inline">i</strong> flag is also demonstrated to make the match case insensitive.) Let's get started:</p>
			<ol>
				<li>In the Google Chrome browser, go into <strong class="source-inline">Developer Tools</strong> (Menu (the three dots in the upper right of the screen), <strong class="source-inline">More Tools</strong> | <strong class="source-inline">Developer Tools</strong>, or just hit the <strong class="source-inline">F12</strong> key).</li>
				<li>Type the following into the console to set up our test string:<p class="source-code">    const str = "Here's the food for Tommy today";</p><p class="source-code">    let match;</p></li>
				<li><strong class="bold">Case #1</strong>: This is where the <strong class="source-inline">g</strong> flag is not present. Type the following:<p class="source-code">    let match = str.match(/\bt\w+/i);</p><p>In the steps that follow, the lines of the code snippets that begin with <strong class="source-inline">&gt;</strong> indicate what you should type in. The lines that begin with <strong class="source-inline">&lt;-</strong> is the output you are expected to see.</p></li>
				<li>Let's see what was matched. To do that, type the following:<p class="source-code">    &gt; match[0]</p><p class="source-code">   &lt;- "the"</p></li>
				<li>Check at what character index the match was made:<p class="source-code">    &gt; match.index</p><p class="source-code">   &lt;- 7</p></li>
				<li>Since there is no <strong class="source-inline">g</strong>, we are not expecting any further matches. To verify this, use the following code:<p class="source-code">    &gt; match[1]</p><p class="source-code">   &lt;- undefined</p><p>The matches from the first expression will be displayed as follows:</p><div class="IMG---Figure" id="_idContainer273"><img alt="Figure 11.8: Full output of the first match expression&#13;&#10;" src="image/C14377_11_08.jpg"/></div><p class="figure-caption">Figure 11.8: Full output of the first match expression</p></li>
				<li><strong class="bold">Case #2</strong>: This is where the <strong class="source-inline">g</strong> flag is present. Type the following to reassign the match variable to include <strong class="source-inline">g</strong> (and <strong class="source-inline">i</strong>):<p class="source-code">    m<a id="_idTextAnchor472"/>atch = str.match(/\bt\w+/gi);</p></li>
				<li>Type the remaining lines in succession, checking the expected output of each:<p class="source-code">    &gt; match[0]</p><p class="source-code">   &lt;- "the"</p><p class="source-code">    &gt; match[1]</p><p class="source-code">   &lt;- "Tommy"</p><p class="source-code">    &gt; match[2]</p><p class="source-code">   &lt;- "today"</p><p class="source-code">    &gt; match[3]</p><p class="source-code">   &lt;- undefined</p><p>The matches of the expression with a <strong class="source-inline">g</strong> will be displayed as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer274">
					<img alt="Figure 11.9: Full output of the match expression with the g flag&#13;&#10;" src="image/C14377_11_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9: Full output of the match expression with the g flag</p>
			<p>In this exercise, you saw how to use the <strong class="source-inline">g</strong> flag of the <strong class="source-inline">String.match()</strong> method to can obtain multiple matches. Next, you will learn about other methods that involve regexes.</p>
			<h2 id="_idParaDest-425"><a id="_idTextAnchor473"/>Other String Methods for Regexes</h2>
			<p>The following table briefly describes some of the other methods in the String object related to regexes:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer275">
					<img alt="Figure 11.10: String methods&#13;&#10;" src="image/C14377_11_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10: String methods</p>
			<p>There is another useful method to take note of when using regexes in JavaScript. The <strong class="source-inline">test()</strong> method returns a simple <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> that indicates whether a match has been found. You can use it in code such as the following to test whether a string begins with the characters <strong class="source-inline">hello</strong>:</p>
			<p class="source-code">   if (/^hello/.test(str)) {</p>
			<p class="source-code">      </p>
			<p class="source-code">   }</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are other more advanced methods of the String object that are not covered here. JavaScript also has a dedicated built-in RegExp object that supports advanced use cases (the <strong class="source-inline">test()</strong> method actually belongs to RegExp).</p>
			<h2 id="_idParaDest-426"><a id="_idTextAnchor474"/>Exercise 11.02: Modifying Regex to Match a Pattern</h2>
			<p>Recall the regex pattern we presented at the beginning of this chapter, which we used to match phone numbers in the format <strong class="source-inline">XXX-XXX-XXXX</strong>:</p>
			<p class="source-code">    ^[2-9]\d{2}-\d{3}-\d{4}$</p>
			<p>Using what you've learned so far, in this exercise, you will modify the regex to match phone numbers of a slightly different format:</p>
			<p class="source-code">    (XXX) XXX-XXXX</p>
			<p>There are many sites that help you craft and test regexes. We will use <a href="https://regex101.com/">https://regex101.com/</a> to work on our regex. Let's get started:</p>
			<ol>
				<li value="1">First, compare the two formats to see how similar they are. Notice that the new format, <strong class="source-inline">(XXX) XXX-XXXX</strong>, is identical to the original format, <strong class="source-inline">XXX-XXX-XXXX </strong>, for the last seven digits and is only different at the beginning of the pattern. We only need to replace the first four characters of the original pattern (the three digits and a dash, <strong class="source-inline">XXX-</strong>) with the new characters (an open parenthesis, three digits, a close parenthesis, and a space).</li>
				<li>We need to come up with a regex that corresponds to <strong class="source-inline">(XXX)</strong>, including a trailing space character that is not displayed:<p class="source-code">    \([2-9]\d{2}\)</p><p>Let's break this code down:</p><ul><li><strong class="source-inline">\(</strong>: The first character you need to match is a parenthesis. Remember that parentheses are special characters (metacharacters) in a regex, so they need to be escaped with a backslash to indicate that you really intend for the parenthesis character to be matched.</li><li><strong class="source-inline">[2-9]</strong>: A character range to match a character between 2 and 9.</li><li><strong class="source-inline">\d</strong>: This is a character class that specifies to match a digit character.</li><li><strong class="source-inline">{2}</strong>: A fixed quantifier that indicates that the previous digit character (\d) needs to repeat twice for it to be considered a match.</li><li><strong class="source-inline">\)</strong>: The closing parenthesis, also escaped.</li></ul></li>
				<li>By combining this with the rest of the original regex, you get the final regex:<p class="source-code">    ^\([2-9]\d{2}\) \d{3}-\d{4}$</p><p>To test this solution, there are many sites that help you craft and test regexes. You can go to <a href="https://regex101.com/">https://regex101.com/</a> and enter the regex in the input box. Also, enter <strong class="source-inline">(234) 567-8910</strong> in the TEST STRING area, as shown here:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer276">
					<img alt="Figure 11.11: Screenshot of https://regex101.com/&#13;&#10;" src="image/C14377_11_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.11: Screenshot of https://regex101.com/</p>
			<p>As you can see, the MATCH INFORMATION section indicates that our test string is a full match.</p>
			<p>There is quite a bit happening on this screen, and a lot of information that helps you understand and work with regexes. If you look at the REGULAR EXPRESSION input box, you will see that the various elements of the regex have been color-coded to help break it down to its constituent parts. The EXPLANATION area goes even further and provides detailed explanations of each character or token. Since the full text was not visible in the preceding screenshot, here are the explanations that were provided:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer277">
					<img alt="Figure 11.12: The EXPLANATION area&#13;&#10;" src="image/C14377_11_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.12: The EXPLANATION area</p>
			<h2 id="_idParaDest-427"><a id="_idTextAnchor475"/>Adding More Strings to the Regex</h2>
			<p>Besides having a test string that passes matching, it is a good idea to also put in other test strings that are similar but are not expected to pass. The following screenshot shows some other such patterns in the TEST STRING area, but notice that only the first one of those patterns shows a match (as expected):</p>
			<div>
				<div class="IMG---Figure" id="_idContainer278">
					<img alt="Figure 11.13: More test strings that are not expected to match&#13;&#10;" src="image/C14377_11_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.13: More test strings that are not expected to match</p>
			<p>The pattern to match phone numbers in the previous exercise works okay, but it looks for a very specific pattern. The following activity will challenge you into making the regex more flexible so that it accepts multiple phone number formats.</p>
			<p>What if you were asked to come up with one regex that can be used to match either of the <strong class="source-inline">XXX-XXX-XXXX</strong> or <strong class="source-inline">(XXX) XXX-XXXX</strong> patterns?</p>
			<p>The challenge is to come up with just one regex that can match either phone number format. Before presenting a good solution, let's consider an incorrect and naive one that, at first glance, seems like the most obvious approach to take, but is actually flawed and fraught with pitfalls.</p>
			<p>Observe that the second format is mostly similar to the original one, with the exception that the first set of three digits begins and end with parenthesis characters (<strong class="source-inline">(</strong> and <strong class="source-inline">)</strong>) and is followed by a space rather than a dash character. You may begin to think of representing these differences by adding parenthesis to the regular expression and simply making them optional (using the ? quantifier) and placing the dash and space in a set (using <strong class="bold">[] </strong>syntax). Such a regex would look like this (the additions are emphasized):</p>
			<p class="source-code">    <strong class="bold">^\(</strong>?[2-9]\d{2}<strong class="bold">\)?[- ]</strong>\d{3}-\d{4}$</p>
			<p>The problem is that this regex is incomplete and would also allow matches of some incorrect and undesirable formats, such as the following:</p>
			<ul>
				<li><strong class="source-inline">(234 567-8901</strong> (no ending parenthesis)</li>
				<li><strong class="source-inline">234) 567-8901</strong> (no starting parenthesis)</li>
				<li><strong class="source-inline">234 567-8901</strong> (using a space character inappropriately)</li>
				<li><strong class="source-inline">(234)-567-8901</strong> (using a dash inappropriately)</li>
			</ul>
			<p>This can be seen if you enter these test strings into the tool as well:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer279">
					<img alt="Figure 11.14: All the test strings match due to a flawed regex&#13;&#10;" src="image/C14377_11_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.14: All the test strings match due to a flawed regex</p>
			<p>Only the first two test strings should have matched, but they all did (indicated by them all being highlighted in blue). </p>
			<h2 id="_idParaDest-428">Acti<a id="_idTextAnchor476"/>vity 11.01: Expanding Phone Number Matching Patterns to Accept Multiple Formats</h2>
			<p>In the previous exercise, we modified a regex to match phone numbers that have the following format: <strong class="source-inline">(XXX) XXX-XXXX</strong>. In this activity, we will create one regex that can be used to match either of the <strong class="source-inline">XXX-XXX-XXXX</strong> or <strong class="source-inline">(XXX) XXX-XXXX</strong> patterns. Once you have completed this activity, you should have a regex that accepts either of the <strong class="source-inline">(XXX) XXX-XXXX </strong>or<strong class="source-inline"> XXX-XXX-XXXX </strong>number formats.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Indicate that the regex snippets corresponding to each format are alternate expressions of an alternation.</li>
				<li>Combine them with the rest of the original regex in the previous exercise to get the complete regex.</li>
				<li>Now, test the regex with the following numbers: (234) 567-8901; 234-567-8907; 234) 567-8901; (234 567-8901; 234 567-8901; and (234)-567-8901.</li>
			</ol>
			<p>The expected output of this activity should be as follows:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer280">
					<img alt="Figure 11.15: Output to the Activity 11.01&#13;&#10;" src="image/C14377_11_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.15: Output to the Activity 11.01</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to the activity can be found on page 745.</p>
			<h2 id="_idParaDest-429"><a id="_idTextAnchor477"/>Activity 11.02: Expanding Phone Number Matching Patterns to Accept a Particular Format</h2>
			<p>In this activity, we will<strong class="bold"> </strong>expand the pattern from the previous activity to allow a format that's used in many non-US countries that optionally prepends a plus sign, 1-3 digits, and a space (for example, <strong class="source-inline">+XXX </strong>), such as one of the following:</p>
			<p class="source-code">+97 (234) 567-8910</p>
			<p class="source-code">+97 234-567-8910</p>
			<p>Once you've completed this activity, you should have a regex that successfully tests for the <strong class="source-inline">+xxx</strong> format.</p>
			<p><strong class="bold">Steps:</strong></p>
			<ol>
				<li value="1">Construct the regex for the <strong class="source-inline">+XXX</strong> pattern (where between 1-3 digits are acceptable).</li>
				<li>Combine this with the original regex to get the complete regex.</li>
				<li>Modify the regex to allow the use of space or dot characters as digit separators rather than only dashes.</li>
				<li>Test the patterns with the following numbers: </li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer281">
					<img alt="Figure 11.16: Many of the patterns that match the regular expression&#13;&#10;" src="image/C14377_11_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.16: Many of the patterns that match the regular expression</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 747.</p>
			<h2 id="_idParaDest-430"><a id="_idTextAnchor478"/>Useful Regexes</h2>
			<p>The following table presents a number of regexes for different purposes. You should be able to understand them using the concepts we've covered, but in most cases, no further explanation will be given besides for the regex itself:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer282">
					<img alt="Figure 11.17: Regex and their purpose&#13;&#10;" src="image/C14377_11_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.17: Regex and their purpose</p>
			<p>In this topic, you learned about the basics of regular expressions and their usefulness. Just a word of caution, though: while regexes are very powerful, they can also be very tricky to implement, and it can take some practice to get them right.</p>
			<p>Now, for a bit of an admission. While our exercise presented regexes for validating phone numbers, they were for the sake of learning and education about regexes. In a real-world application, you would probably want to consider using a dedicated library for such validation. Several such libraries are available, and the advantages of using such libraries are that they are well thought out, tested, and support a wide variety of options and phone number formats from different countries around the world. One such library is Google's <a href="http://libphonenumber">libphonenumber</a>.</p>
			<p>In the next topic, you'll get into clean coding.</p>
			<h1 id="_idParaDest-431"><a id="_idTextAnchor479"/>Best Practices for Clean Coding</h1>
			<p>Code often has a way of living longer than anyone would think it would. Just look at all the mainframe systems that are still in use today. At times, even experienced developers are baffled by it and have a difficult time understanding code they themselves wrote when looking at the code just a few weeks or months later. It behooves software developers to adopt a mindset of good practices and habits when coding.</p>
			<p>Code is almost never written just once to never be used again. Often, you or someone else will need to work on the code at a later date. If you write clean code, you are helping your future self and co-workers work more efficiently when that time comes. You are also making it easier to maintain the system and fix bugs.</p>
			<p>Many of the ideas and practices in this section are based on the books and blogs of Robert C. Martin, also known as "Uncle Bob," who is a recognized expert in the field of clean coding and has produced popular books, blogs, and training videos. We will only present a brief overview and highlights, but entire books have been written on the subject. You are encouraged to delve deeper into this subject.</p>
			<p>Look at the following code:</p>
			<p class="source-code">    function circ(r) {</p>
			<p class="source-code">      return r * 2 * Math.PI;</p>
			<p class="source-code">    }</p>
			<p>The purpose of this code is to calculate the circumference of a circle, but I'll bet this was not very obvious to you based on how it is written. Perhaps adding some explanatory comments would help, but compare the preceding code to this:</p>
			<p class="source-code">    function circumference(radius) {</p>
			<p class="source-code">        return radius * 2 * Math.PI;</p>
			<p class="source-code">    }</p>
			<p>You would agree that this code was much more understandable and leaves little doubt about what it does, what the parameter is, and what is returned. Renaming the function from <strong class="source-inline">circ</strong> to <strong class="source-inline">circumference</strong> and the parameter from <strong class="source-inline">r</strong> to <strong class="source-inline">radius</strong> is all it took to achieve understanding. This was all done without the need to add any explanatory comments.</p>
			<p>We've improved our code so far by using better naming, but here's another improvement worth making. The usual formula for circumference is <strong class="source-inline">C = πd</strong>, where <strong class="source-inline">d</strong> is the diameter. If you split our calculation into two steps, the code would be clearer. Compare the preceding code to the following:</p>
			<p class="source-code">    function circumference(radius) {</p>
			<p class="source-code">        let diameter = radius * 2;</p>
			<p class="source-code">        return diameter * Math.PI;</p>
			<p class="source-code">    }</p>
			<p>This simple change makes it clearer why the calculation needed to multiply the radius by 2, namely, to calculate the diameter before multiplying it by pi to get the circumference.</p>
			<p>This may not seem like a big improvement, and arguably the extra line of code does not add much value or clarity. You would probably be correct in this simple instance. But consider how coding in such a way could potentially simplify scenarios where more complex calculations or logic is required.</p>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor480"/>Good Naming Practices</h2>
			<p>Use the following guidelines when naming variables, functions, or other objects:</p>
			<ul>
				<li><strong class="bold">Use intention revealing names</strong>: Your names should be clear enough that no comments should be needed to explain them, for example, <strong class="source-inline">timeElapsedInDays</strong>, <strong class="source-inline">daysSinceCreation</strong>, and <strong class="source-inline">ageInDays</strong>. In general, code should be as self-documenting as possible and comments should be kept to a minimum. Comments have a way of becoming outdated as code is refactored and logic is changed over time, and programmers tend to forget to update them.</li>
				<li><strong class="bold">Avoid disinformation</strong>: Don't call your variable <strong class="source-inline">bookList</strong> if it is in fact an array of books. Just calling it <strong class="source-inline">books</strong> is preferred.</li>
				<li><strong class="bold">Make meaningful distinctions</strong>: If you have two different classes with similar names, such as <strong class="source-inline">BookInfo</strong> and <strong class="source-inline">BookData</strong>, you have made the names different without making them mean anything different. Use more specific names that differentiate what the purpose of each class is.</li>
				<li><strong class="bold">Use pronounceable names</strong>: Let's take a bad example:<p class="source-code">   <strong class="source-inline">const yyyymmdstr = moment().format("YYYY/MM/DD");</strong></p><p>Now, let's compare it with a good one:</p><p class="source-code">    <strong class="source-inline">const currentDate = moment().format("YYYY/MM/DD");</strong></p></li>
				<li><strong class="bold">Use constants and searchable names</strong>: You will read code more than you will ever write it. A variable named <strong class="source-inline">SECONDS_IN_DAY</strong> is more meaningful than <strong class="source-inline">86400</strong> and explains what that number represents better. It also makes it easier to locate later when searching over the body of text.</li>
				<li><strong class="bold">Class names</strong>: Classes should have noun or noun phrase names such as <strong class="source-inline">Customer</strong>, <strong class="source-inline">Account</strong>, and <strong class="source-inline">AddressParser</strong>. Avoid words such as <strong class="source-inline">Manager</strong>, <strong class="source-inline">Processor</strong>, <strong class="source-inline">Data</strong>, or <strong class="source-inline">Info</strong>, which are either verbs or too generic.</li>
				<li><strong class="bold">Method names</strong>: Methods should have verb or verb phrase names such as <strong class="source-inline">addFunds</strong>, <strong class="source-inline">deleteUser</strong>, or <strong class="source-inline">save</strong>. Accessors and mutators should be prefixed with <strong class="source-inline">get</strong> or <strong class="source-inline">set</strong>.</li>
				<li><strong class="bold">Pick one word per concept</strong>: It is confusing to have <strong class="source-inline">fetch</strong>, <strong class="source-inline">retrieve</strong>, and <strong class="source-inline">get</strong>, which do the same thing. It's best to pick one word and use it consistently across your code.</li>
				<li><strong class="bold">Don't be cute</strong>: If names are too humorous or specific to one culture, they may not make sense to other people who don't share the same culture or sense of humor. This is like using <strong class="source-inline">eatMyShorts()</strong> to mean <strong class="source-inline">abort()</strong>.</li>
				<li><strong class="bold">Don't add unneeded context</strong>: If your class or object is already named descriptively, there is no need to repeat the name in the variables within. Take a look at the following examples.<p>This is bad:</p><p class="source-code">    const employee = {</p><p class="source-code">        employeeFirstName: "Daniel",</p><p class="source-code">        employeenLastName: "Rosenbaum",</p><p class="source-code">        employeeActive: true</p><p class="source-code">    };</p><p class="source-code">    function fireEmployee(employee) {</p><p class="source-code">        employee.employeeActive = false;</p><p class="source-code">    }</p><p>Whereas this is good:</p><p class="source-code">    const employee = {</p><p class="source-code">        firstName: "John",</p><p class="source-code">        lastName: "Smith",</p><p class="source-code">        active: true</p><p class="source-code">    };</p><p class="source-code">    function fireEmployee(employee) {</p><p class="source-code">        employee.active = false;</p><p class="source-code">    }</p></li>
			</ul>
			<p>Following are the best practices for functions:</p>
			<ul>
				<li><strong class="bold">Functions should only do one thing and be small</strong>: When functions are concise and limited in what they do, they are easier to understand, test, and work with. They would also read cleaner and be refactored easily. Coupled with a good function name, they are self-documenting as well.<p>Here's a bad function:</p><p class="source-code">    function phoneSubscribers(subscribers) {</p><p class="source-code">        subscribers.forEach(subscriber =&gt; {</p><p class="source-code">            const subscriberRecord = database.lookup(subscriber);</p><p class="source-code">            if (subscriberRecord.isActive()) {</p><p class="source-code">                phoneSubscriber(subscriber);</p><p class="source-code">            }</p><p class="source-code">        });</p><p class="source-code">    }</p><p>Here's a good function:</p><p class="source-code">    function phoneActiveSubscribers(<a id="_idTextAnchor481"/>subscribers) {</p><p class="source-code">        clients.filter(isActiveSubscriber).forEach(phone);</p><p class="source-code">    }</p><p class="source-code">    function isActiveSubscriber(subscriber) {</p><p class="source-code">        const subscriberRecord = database.lookup(subscriber);</p><p class="source-code">        return subscriberRecord.isActive();</p><p class="source-code">    }</p></li>
				<li><strong class="bold">Limit the number of function arguments</strong>: Ideally, there should be no more than two or three arguments. This makes testing easier. If there are more arguments, consider that your function is probably trying to tackle too much and should be split into multiple functions.</li>
				<li><strong class="bold">Function names should say what they do</strong>: Here's an example of a bad function name:<p class="source-code">    function addToDate(date, month) {</p><p class="source-code">      // ...</p><p class="source-code">    }</p><p class="source-code">    const date = new Date();</p><p class="source-code">    // It's hard to tell from the function name what is added</p><p class="source-code">    addToDate(date, 1);</p><p>This is a good function name:</p><p class="source-code">    function addMonthToDate(month, date) {</p><p class="source-code">      // ...</p><p class="source-code">    }</p><p class="source-code">    const date = new Date();</p><p class="source-code">    addMonthToDate(1, date);</p></li>
				<li><strong class="bold">Don't use boolean flags as function parameters</strong>: If at some point, a function's behavior will be completely altered due to the value of a flag, it is an indication that it would be better to split it into two separate functions. As a guideline, if the name of the function can no longer reasonably be called <strong class="source-inline">doSomething()</strong> and instead turns into <strong class="source-inline">doSomethingOrSomethingDifferentIfAFlagIsSet()</strong>, it's time to split the function.<p>Take a look at the following code:</p><p class="source-code">    function createFile(name, temp) {</p><p class="source-code">      if (temp) {</p><p class="source-code">        fs.create(`./temp/${name}`);</p><p class="source-code">      } else {</p><p class="source-code">        fs.create(name);</p><p class="source-code">      }</p><p class="source-code">    }</p><p>Rather than using the preceding code, use the following instead:</p><p class="source-code">    function createFile(name) {</p><p class="source-code">      fs.create(name);</p><p class="source-code">    }</p><p class="source-code">    function createTempFile(name) {</p><p class="source-code">      createFile(`./temp/${name}`);</p><p class="source-code">    }</p></li>
				<li><strong class="bold">Write your functions to avoid side effects</strong>: Very briefly, a side effect is if, during the execution of a function, something is modified, or an action is done that does not involve the values the function will return. This may be something such as changing the value of a global variable, writing to a file, or making a service call.<p>Of course, there will be times where such actions are needed, such as to make a service call to obtain data or write results to a file. However, the best practice here is to isolate such logic into dedicated functions but to take care and keep the majority of your functions as pure and side-effect-free as possible.</p><p>As an example, the following function modifies a global variable and therefore has side effects. (This could be code in a game where the player's character is located somewhere on a grid.) The <strong class="source-inline">playerX</strong> and <strong class="source-inline">playerY</strong> variables represent the character's current coordinates:</p><p class="source-code">    let playerX = 45, playerY = 100;</p><p class="source-code">    const moveRight = (numSlots) =&gt; {</p><p class="source-code">      playerX += numSlots;</p><p class="source-code">    }</p><p class="source-code">    moveRight(5);</p><p>It is better to take x as a parameter and reassign the result to a global variable outside the function so that the function remains pure and maintains predictable return values (and makes it easier to test):</p><p class="source-code">    let playerX = 45, playerY=100;</p><p class="source-code">    const moveRight = (playerX, numSlots) =&gt; playerX + numSlots;</p><p class="source-code">    playerX = moveRight(playerX, 5);</p><p class="callout-heading">Note</p><p class="callout">Side effects and pure functions are covered in more detail in <em class="italic">Chapter 14, Understanding Functional Programming</em>, on functional programming. Another important example is to clone objects, arrays, or lists when making modifications, rather than directly doing the modification itself on the input.</p></li>
				<li><strong class="bold">Create functions to capture conditional clauses</strong>: Your code could become cluttered, unfocused, and hard to follow if you have complex conditions. Creating dedicated functions for your conditions and naming them descriptively makes the code self-documenting and easier to follow.<p>An example of a bad function:</p><p class="source-code">if (serviceCall.state === "loading" &amp;&amp; isEmpty(result)) {</p><p class="source-code">    // ...</p><p class="source-code">}</p><p>An example of a good function:</p><p class="source-code">function shouldShowSpinner(serviceCall, result) {</p><p class="source-code">    return serviceCall.state === "loading" &amp;&amp; isEmpty(result);</p><p class="source-code">}</p><p class="source-code">if (shouldShowSpinner(serviceCall, result)) {</p><p class="source-code">    // ...</p><p class="source-code">}</p></li>
			</ul>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor482"/>JavaScript Linters</h2>
			<p>A linter is a tool that analyzes source code to help you debug your code, find potential issues and bugs and check coding styles (which is often subjective). Using a linter in your projects could help you and your team improve the quality of your code and provide consistent styling, which could help smooth out differences of code that different team members write.</p>
			<p>Linters can typically be used in three different ways:</p>
			<ul>
				<li>Typing or pasting your code into the online version of a tool via a browser page. This is the simplest way, but it is not convenient for anything but small spot checks.</li>
				<li>Using a plugin for your IDE or text editor, either to show your errors and warnings as you type or separately.</li>
				<li>Running scans and generating reports as part of your automated build process every time your source code is built, or periodically. (If desired, you can even cause builds to fail if the scan results in errors of sufficient severity.)</li>
			</ul>
			<p>There are several linters available for JavaScript, including the following:</p>
			<ul>
				<li><strong class="bold">ESLint</strong>: This is very configurable and customizable. This perhaps makes it the most complex and hardest linter to just pick up and start using.</li>
				<li><strong class="bold">JSLint</strong>: This is somewhat configurable but highly opinionated on a popular but particular coding style, as described in the tool's documentation.</li>
				<li><strong class="bold">JSHint</strong>: This is somewhere between the other two in terms of customizability.</li>
			</ul>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor483"/>Exercise 11.03: JSLint</h2>
			<p>This exercise will describe <strong class="source-inline">JSLint</strong> in more detail since it is the easiest to set up and start using, uses a good coding style, and is a good fit for many projects. Let's get started:</p>
			<ol>
				<li value="1">Open a web browser such as Google Chrome and go to <a href="http://www.jslint.com">www.jslint.com</a>.</li>
				<li>In the Options section on the lower part of the screen, select <strong class="source-inline">Assume → a browser</strong> (this sets the scan to define certain objects that are usually available in a browser, such as a <strong class="source-inline">document</strong> object):<div class="IMG---Figure" id="_idContainer283"><img alt="Figure 11.18: Online version of JSLint&#13;&#10;" src="image/C14377_11_18.jpg"/></div><p class="figure-caption">Figure 11.18: Online version of JSLint</p></li>
				<li>Paste in the code from <strong class="source-inline">conventional.html</strong> file into the <em class="italic">Source</em> window.</li>
				<li>Press the <em class="italic">JSLint</em> button, which will result in an output that's similar to what's shown in the following screenshot:<div class="IMG---Figure" id="_idContainer284"><img alt="Figure 11.19: Result of the scan&#13;&#10;" src="image/C14377_11_19.jpg"/></div><p class="figure-caption">Figure 11.19: Result of the scan</p></li>
				<li>The scan results have multiple warnings of the following: <strong class="source-inline">Use double quotes, not single quotes</strong>. This is perhaps an example of a subjective preference as it is common in many languages for single characters to use single quotes, not double-quotes. Luckily, this is a configurable option if you select <strong class="source-inline">Tolerate → single quote strings</strong> in the Options section, as shown in the following screenshot. After clicking the <em class="italic">JSLint</em> button once again, this will result in all the warnings being removed:<div class="IMG---Figure" id="_idContainer285"><img alt="Figure 11.20: Tolerate → single quote strings option&#13;&#10;" src="image/C14377_11_20.jpg"/></div><p class="figure-caption">Figure 11.20: Tolerate → single quote strings option</p></li>
				<li>An alternative way of specifying the option to allow single quote strings (and a number of other options) is by means of a special comment syntax that begins with <strong class="source-inline">/*jslint</strong>. Uncheck the <strong class="source-inline">Tolerate → single quote strings</strong> option and add the following to the top of the code:<p class="source-code">    /*jslint</p><p class="source-code">        single</p><p class="source-code">    */</p><p>The warnings will continue to be empty upon clicking the JSLint button.</p></li>
			</ol>
			<p>This exercise explains how your JavaScript code compiles using the <strong class="source-inline">Jslint</strong> tool. It also helps to decrease the debugging time by providing a fixing issues report.</p>
			<h2 id="_idParaDest-435">Act<a id="_idTextAnchor484"/>ivity 11.03: Refactoring to Clean Code</h2>
			<p>Making a habit of using clean coding best practices is an essential skill. We are now ready to put our newly acquired clean coding skills to test.</p>
			<p>Look at the JavaScript code in the <strong class="source-inline">&lt;script&gt;</strong> section of the following file and figure out how you can refactor it to be cleaner and easier to maintain and test.</p>
			<p class="source-code-heading">activity_original_code.html</p>
			<p class="source-code">1 &lt;html&gt;</p>
			<p class="source-code">2 &lt;head&gt;</p>
			<p class="source-code">3 &lt;meta charset="utf-8"/&gt;</p>
			<p class="source-code">4 &lt;/head&gt;</p>
			<p class="source-code">5 &lt;body&gt;</p>
			<p class="source-code">5 &lt;span id="error" style="color: red"&gt;&lt;/span&gt;</p>
			<p class="source-code">6 &lt;table&gt;</p>
			<p class="source-code">7   &lt;tr&gt;</p>
			<p class="source-code">8     &lt;td&gt;# of hours:&lt;/td&gt;</p>
			<p class="source-code">9     &lt;td&gt;&lt;input id="numHours" /&gt;&lt;/td&gt;</p>
			<p class="source-code">10   &lt;/tr&gt;</p>
			<p class="source-code">11   &lt;tr&gt;</p>
			<p class="source-code">12     &lt;td&gt;Pay rate per hour:&lt;/td&gt;</p>
			<p class="source-code">13     &lt;td&gt;&lt;input id="payRate" /&gt;&lt;/td&gt;</p>
			<p class="source-code">14     &lt;td&gt;(in ####.## format)&lt;/td&gt;</p>
			<p class="source-code">15   &lt;/tr&gt;</p>
			<p>In short, this is a simple web page that calculates worker pay based on the number of hours, pay rate per hour, and worker type. There are three types of workers that have different rules regarding how their pay is determined: <strong class="source-inline">Standard</strong>, who gets overtime pay at <strong class="bold">1.5x</strong> after <strong class="bold">40</strong> hours, <strong class="source-inline">No Overtime</strong>, who do not get any overtime, and <strong class="source-inline">Double Overtime</strong> workers, who are paid <strong class="bold">2x</strong> after <strong class="bold">50</strong> hours.</p>
			<p>There are also format checks for the two number fields (implemented with regexes) and a facility to show validation error messages. The following screenshot shows the output with valid inputs (there is only minimal color and styling in this implementation):</p>
			<div>
				<div class="IMG---Figure" id="_idContainer286">
					<img alt="Figure 11.21: Sample output with valid inputs&#13;&#10;" src="image/C14377_11_21.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.21: Sample output with valid inputs</p>
			<p>The following screenshot shows the output with a validation error:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer287">
					<img alt="Figure 11.22: Sample output with a validation error&#13;&#10;" src="image/C14377_11_22.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figu<a id="_idTextAnchor485"/>re 11.22: Sample output with a validation error</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 748.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">To refactor the code, create a function called <strong class="source-inline">processForm()</strong>.</li>
				<li>Create a function called <strong class="source-inline">resetErrorsAndResults()</strong>.</li>
				<li>Create a class to hold form field values and perform validations.</li>
				<li>Next, create a function called <strong class="source-inline">getFormFields()</strong>. This function is limited to getting the values from the form and creating an instance of the <strong class="source-inline">FormFields</strong> class.</li>
				<li>Create the <strong class="source-inline">displayError()</strong> and <strong class="source-inline">displayResult()</strong> functions to display errors and results.</li>
				<li>Finally, create the <strong class="source-inline">calculateStandardWorkerPay()</strong>, <strong class="source-inline">calculateNoOvertimeWorkerPay()</strong>, and <strong class="source-inline">calculateDoubleOvertimeWorkerPay()</strong> functions, which take the same two parameters and have the same return value definition so that they can be called abstractly in <strong class="source-inline">doCalculation()</strong>.</li>
			</ol>
			<h1 id="_idParaDest-436"><a id="_idTextAnchor486"/>Summary</h1>
			<p>In this chapter, you learned about the best practices for clean and maintainable coding. As you saw in this chapter's activity, the refactored code that used clean coding techniques resulted in code that was much longer than before. However, you can see that the code as-is is much cleaner and is easier to understand and test compared to the original.</p>
			<p>It is arguably overkill to refactor to the degree that we presented for our simple application, and many developers feel this way. But the value of this programming style really shows itself more in a complex real-world application, and it is good practice to do work in this way. Developers and tech leads need to decide what standards and clean coding practices make sense for their particular project.</p>
			<p>In the next chapter, you will explore the current trends and cutting-edge features that JavaScript has to offer.</p>
		</div>
		<div>
			<div class="Content" id="_idContainer289">
			</div>
		</div>
	</body></html>