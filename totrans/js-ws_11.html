<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-405"><a id="_idTextAnchor449"/>11. Creating Clean and Maintainable Code</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to identify and implement basic regular expressions (regex); use best practices to produce clean and maintainable code; utilize code quality tools such as <code>ESLint</code>, <code>JSLint</code>, and <code>JSHint</code> and implement strategies for refactoring code.</p>
			<h1 id="_idParaDest-406"><a id="_idTextAnchor450"/>Introduction</h1>
			<p>In this chapter, you will learn about the techniques that can be used for pattern matching and clean coding, which have many uses, perhaps even to facilitate your testing as well.</p>
			<p><strong class="bold">Regular expressions</strong> (<strong class="bold">regex</strong> for short) are a concise and powerful method to search for and match patterns. They may appear alien and intimidating at first, but once you learn the basics, they will quickly appear less difficult, and so you are likely to recognize their usefulness. Regexes are common in many languages and in tools where text and data are involved. So, it is a worthwhile investment to take the time to learn them. A pattern that's expressed as a regex is usually much shorter than the equivalent code that's required to parse and match the same pattern using conventional techniques. </p>
			<p>Making use of regexes also leads to clean and maintainable coding practices. For programming projects to be successful, it is critical that the code is easily understood by others and that it is orderly, focused, and flexible. This chapter introduces techniques and best practices for coding, starting with choosing the clearest and most understandable names for your variables and methods.</p>
			<h1 id="_idParaDest-407"><a id="_idTextAnchor451"/>What Is a Regex?</h1>
			<p>A <strong class="bold">regex</strong> is a sequence of characters that form a pattern that's used to search. Each character in the pattern either has special meaning (a metacharacter) or is meant to match the character itself (a literal). This is perhaps best understood by the following example.</p>
			<p>As a demonstration of the difference between pattern matching with conventional coding versus regex techniques, consider the following code for matching phone number format patterns in a conventional way. We'll then rewrite the matching logic using a regex for comparison. To keep things simple, we will only look for phone numbers that match the following pattern, which is common for phone numbers, particularly in the United States:</p>
			<pre>	[2-9]XX-XXX-XXXX</pre>
			<p>Here, <code>X</code> can be any digit from <code>0-9</code>, and the first digit cannot be a zero or one (only <code>2-9</code> are permitted). For example, <code>234-567-8901</code> is a valid phone number in this format.</p>
			<p>You can use the following code to do the matching using conventional methods:</p>
			<pre>conventional.html
1 &lt;html&gt;
2 &lt;head&gt;
3   &lt;meta charset="utf-8"/&gt;
4 &lt;/head&gt;
5 &lt;body&gt;
6 Enter a phone number in format XXX-XXX-XXXX:
7 &lt;input type="text" id="phone"&gt;
8 &lt;div id="msg"&gt;&lt;/div&gt;
9 &lt;script&gt;
10 var phone = document.getElementById("phone");
11 phone.addEventListener("input", validatePhoneNumber);
12 function isDigit(character) {
13     return character &gt;= '0' &amp;&amp; character &lt;= '9';
14 }
The full code is available at: <a href="https://packt.live/2CFKQtK">https://packt.live/2CFKQtK</a></pre>
			<p>The following screenshot show the output of the preceding code when a number is entered in an invalid format:</p>
			<div><div><img alt="Figure 11.1: Sample output when a number is input in an incorrect format&#13;&#10;" src="img/C14377_11_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1: Sample output when a number is input in an incorrect format</p>
			<p>Here's the output when a number is entered in a valid format:</p>
			<div><div><img alt="Figure 11.2: Sample output when a number is input correctly&#13;&#10;" src="img/C14377_11_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2: Sample output when a number is input correctly</p>
			<p>Let's focus on the important parts of the JavaScript code:</p>
			<pre>var phone = document.getElementById("phone");
phone.addEventListener("input", validatePhoneNumber);</pre>
			<p>These lines set up the phone number validation, which is to be done as the user enters a value. It finds the DOM element of the input text and adds an event listener for the <code>input</code> event. This event occurs when the value of <code>&lt;input&gt;</code> is changed, such as with a keypress or even if a value is pasted in using cut/paste. When triggered, the <code>validatePhoneNumber()</code> function is called.</p>
			<p>Note the code that checks whether a character is a digit:</p>
			<pre>function isDigit(character) {
    return character &gt;= '0' &amp;&amp; character &lt;= '9';
}</pre>
			<p>This function has a parameter that must be just one character. What may not be intuitive is that JavaScript allows greater than or less than operators on character types. This allows us to check that the character is any digit in the range between the <code>0</code> and <code>9</code> characters.</p>
			<p>The following is the code for the <code>validatePhoneNumber()</code> method:</p>
			<pre>    var phoneNum = phone.value.trim();
    // check if phone number matches format [2-9]XX-XXX-XXXX
    var valid =
        phoneNum.length == 12 &amp;&amp;
        phoneNum.charAt(0) != '0' &amp;&amp;
        isDigit(phoneNum.charAt(0)) &amp;&amp;
        isDigit(phoneNum.charAt(1)) &amp;&amp;
        isDigit(phoneNum.charAt(2)) &amp;&amp;
        phoneNum.charAt(3) == '-' &amp;&amp;</pre>
			<p>This code does the following:</p>
			<ul>
				<li>Checks the expected length of the phone number to make sure there are no ex<a id="_idTextAnchor452"/>traneous characters, such as additional digits, alphabetic characters, or symbols. Note that since we're calling the <code>trim()</code> function when we initially read the phone number value, this check is forgiving of leading and trailing whitespace.</li>
				<li>Checks that the first character is not a <code>0</code>.</li>
				<li>Checks that the first three characters are digits (indices <code>0-2</code>).<p class="callout-heading">Note </p><p class="callout">Rather than calling the <code>isDigit()</code> function multiple times, we could have added parameters to the function so that multiple characters would be checked in one invocation. However, for the purposes of this exercise, we chose to keep the code simpler and easier to understand.</p></li>
				<li>Checks for the <code>-</code> character afterward.</li>
			</ul>
			<p>The rest of the validation repeats and is similar for the rest of the characters.</p>
			<p>Finally, the validation message is formed and set in the <code>&lt;div&gt;</code>:</p>
			<pre>    var validMsg = "phone number entered is " +
        (valid ? "valid." : "INVALID!!!");
    document.getElementById("msg").innerHTML = validMsg;</pre>
			<p>We will now compare this logic to an equivalent implementation using regexes. We'll describe regexes more methodically and in more depth in the next section, but for now, we'll look at how to code with regex techniques, even though it may not make much sense to you yet. We will code an alternative to the phone number validation function we presented, which uses regexes. So, don't worry if you don't quite understand all the concepts yet, as they will be explained in detail later.</p>
			<p>Consider the preceding code, which is for pattern matching with conventional methods. Let's modify it so that it uses a regex.</p>
			<p>To do this, find the <code>validatePhoneNumber()</code> function and the declaration of the <code>valid</code> variable. Then, delete the entire expression all the way to the semicolon (<code>;</code>) character until the comment above it. Replace the area you deleted with the following:</p>
			<pre>// check if phone number matches format [2-9]XX-XXX-XXXX
var valid = phoneNum.match(//);</pre>
			<p>At this point, you only have a shell of a regex in the area between the two forward slash marks. </p>
			<p>After the first forward slash, add a <code>^</code> character (called a caret). Your code should now look like this:</p>
			<pre>var valid = phoneNum.match(/^/);</pre>
			<p>The <code>^</code> symbol is an <strong class="bold">anchor </strong>that indicates matching should begin at the start of the string.</p>
			<p>Now, add the characters <code>[2-9]</code> so that the code now looks like this:</p>
			<pre>var valid = phoneNum.match(/^[2-9]/);</pre>
			<p>The <code>[2-9]</code> characters specify a <code>2</code> and <code>9</code>.</p>
			<p>By now, you will be able to see how you are progressively adding more characters with each step. In a similar fashion, add the remaining characters one by one, as shown in the left column of the following table:</p>
			<div><div><img alt="Figure 11.3: Table of characters&#13;&#10;" src="img/C14377_11_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3: Table of characters</p>
			<p>The complete code should now look like this:</p>
			<pre>    // check if phone number matches format [2-9]XX-XXX-XXXX
    var valid = phoneNum.match(/^[2-9]\d{2}-\d{3}-\d{4}$/);</pre>
			<p>Here, you have seen the power of regular expressions and that all of them can be expressed in just one line of code. The different concepts of a regular expressions are shown in the following figure:</p>
			<div><div><img alt="Figure 11.4: Showing different concepts in the regular expression&#13;&#10;" src="img/C14377_11_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4: Showing different concepts in the regular expression</p>
			<h1 id="_idParaDest-408"><a id="_idTextAnchor453"/>Regexes in Detail</h1>
			<p>I<a id="_idTextAnchor454"/>n the upcoming sections, the following sample phrase is used for illustration:</p>
			<p>  "The ships were loaded with all these belongings of the mother"</p>
			<p>This phrase will be used to demonstrate various regex concepts, including literal characters, word boundaries, character classes, and others.</p>
			<h2 id="_idParaDest-409"><a id="_idTextAnchor455"/>Literal Characters</h2>
			<p>The simplest regex is one of more <code>the</code>. This indicates a pattern that is a match if the <code>t</code> character is immediately followed by <code>h</code> and finally an <code>e</code> character. This expression would have four matches in the sample phrase: the initial <code>the</code>, the second to last word, <code>the</code>, <code>the</code> in the word <code>these</code>, and the sequence of <code>the</code> as part of the word <code>mother</code>.</p>
			<h2 id="_idParaDest-410"><a id="_idTextAnchor456"/>Special Characters, Anchors, and Escaping</h2>
			<p>If a regex only had literals, its usefulness would be limited. In most cases, you do not want to only match literals; therefore, regexes have a number of characters that have special meanings. These are also known as metacharacters. Two of these special characters are the <code>^</code> and <code>$</code> <strong class="bold">anchors</strong> that you saw earlier, which indicate the beginning and end of a string, respectively.</p>
			<p>So, if you change the regex to <code>^the</code>, only the initial <code>the</code> of the phrase would now be a match since this is the only instance of <code>the</code> in the phrase that is at the beginning of the string. Anchors are often important in situations where you need to avoid matching too much that is not intended to be matched.</p>
			<p>The following are the most common characters that have special meaning in regexes:</p>
			<div><div><img alt="Figure 11.5: Special characters&#13;&#10;" src="img/C14377_11_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5: Special characters</p>
			<p class="callout-heading">Note </p>
			<p class="callout">If you need to use any of these characters in your regexes as a literal character, in most cases, the character will need to be escaped. You do that by placing a backslash <code>\</code> before the character.</p>
			<p>Here are two examples:</p>
			<ul>
				<li>If you need to match a dollar sign as part of your pattern, you would use <code>\$</code>.</li>
				<li>Some less obvious escapes are the backslash character itself (you would just use two consecutive backslashes, for example, <code>\\</code>), and a dot, where <code>\.</code> is the correct escaping sequence.</li>
			</ul>
			<h2 id="_idParaDest-411"><a id="_idTextAnchor457"/>Word Boundary</h2>
			<p>Another type of anchor is a <code>\b</code> (a backslash followed by a <code>b</code>). A word boundary is defined as either of the following:</p>
			<ul>
				<li>The beginning of a string, followed by a word character</li>
				<li>The character between whitespace and a word character, or after a word character leading to either whitespace or the end of the string</li>
			</ul>
			<p>Note that the word characters are defined as follows.</p>
			<ul>
				<li>If the preceding regex was changed to <code>\bthe</code>, there would only be three matches in the sample phrase: the four previous matches, minus <code>the</code> in <code>mother</code>. (The initial <code>\b</code> of the pattern are special characters, and the remainder are literal characters.)</li>
				<li>If the regex was changed to <code>\bthe\b</code>, only the two standalone <code>the</code> words would be matches, and not the ones in <code>these</code> or <code>mother</code>. This is one way to specify to search for whole words, but with no other leading or trailing characters in a given word.</li>
			</ul>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor458"/>Shorthand Character Classes and Word Characters</h2>
			<p>There are a number of <code>\d </code>sequence, which denotes any digit <code>[0-9]</code>.</p>
			<p>Another is the <code>\w</code>, which is defined as <code>[A-Za-z0-9_]</code>. (Character classes and ranges will be defined in more detail next. For now, this is read as a character in the range of uppercase characters <code>A-Z</code>, range of characters <code>a-z</code>, range of digits <code>0-9</code>, or the underscore <code>_</code> character.) Here are some examples:</p>
			<ul>
				<li>If the <code>the\w</code> regex were used on the preceding sample phrase, only the sequence of <code>the</code> in the words <code>these</code> and <code>mother</code> would be a match, since the other two <code>the</code> words do not have a word character following it.</li>
				<li>If the <code>\wthe\w</code> regex were used, only the sequence of <code>the</code> in the word <code>mother</code> would match, as it is the only place in the string where the sequence <code>the</code> is both preceded and followed by a word character. This is one way to specify how to search for characters that are only contained within a word.</li>
				<li>Combining the word boundary and word character shortcuts, if the regex <code>\bthe\w</code> were used, only the sequence of <code>the</code> in the word <code>these</code> would match as it is the only place in the string where the sequence <code>the</code> starts on a word boundary and is followed by a word character.</li>
			</ul>
			<p>Another common shorthand character class is <code>\s</code>, which is shorthand for whitespace, including space characters, tabs, and newlines.</p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor459"/>Inverse Classes</h2>
			<p>Every shorthand character class has an inverse class as well, denoted by making the letter uppercase:</p>
			<ul>
				<li><code>\B</code>: The opposite of a word boundary, such as in the middle of a word</li>
				<li><code>\D</code>: Represents any non-digit character</li>
				<li><code>\W</code>: Any character that is not included in <code>[A-Za-z0-9_]</code></li>
				<li><code>\S</code>: Any non-whitespace character</li>
			</ul>
			<p>For example, as the inverse of the first example in the previous section, if the <code>the\W</code> regex were used on the preceding sample phrase, only the two <code>the</code> characters would match, including the trailing space character. The words <code>these</code> and <code>mother</code> would be a match, since in both cases there is a word character following <code>the</code>.</p>
			<h2 id="_idParaDest-414"><a id="_idTextAnchor460"/>Dot Character</h2>
			<p>The dot, <code>.</code>, matches any character except newlines. For instance, the <code>.h.</code> regex looks for any <code>h</code> and matches it with the character before and after it, as long as it is not a newline. The highlighted characters that follow are the result of applying the regex to the earlier sample phrase:</p>
			<p> "The ships were loaded with all these belongings of the mother"</p>
			<p>Take special note of the third match of the last two letters of the word <code>with</code>, along with the space character that follows it. It is easy to forget that a dot matches any character, including a space. This can be a common error if you do intend to allow spaces in your pattern.</p>
			<h2 id="_idParaDest-415"><a id="_idTextAnchor461"/>Sets</h2>
			<p>One or more characters or character classes enclosed in square brackets, <code>[...]</code>, indicates we should match any of the given characters. This is called a <strong class="bold">set</strong>. Here are two examples:</p>
			<ul>
				<li>The <code>[AEIOUaeiou]</code> regex can be used to match vowel characters.</li>
				<li>When combining a set followed by two literal characters, the <code>[oi]ng</code> regex would match the <code>ong</code> and the <code>ing</code> in the word <code>belongings</code> (from the sample phrase).</li>
			</ul>
			<h2 id="_idParaDest-416"><a id="_idTextAnchor462"/>Ranges</h2>
			<p>One <code>[2-9]</code>, which indicated a character between <code>2</code> and <code>9</code>. Similar to sets, ranges are specified within square brackets, <code>[...]</code>, and use a dash character to separate the characters that indicate the range.</p>
			<p>Another range you saw earlier was <code>[A-Za-z0-9_]</code>, which specified the word characters. This also shows how multiple ranges and even a character that's not part of a range can be indicated in one expression, as this allows characters from <code>A-Z</code>, <code>a-z</code>, and <code>0-9</code>, as well as the underscore character.</p>
			<h2 id="_idParaDest-417"><a id="_idTextAnchor463"/>Excluding Sets and Ranges</h2>
			<p>The opposite of regular sets and ranges, an excluding range indicates to "match a character except for the following". Excluding sets or ranges is indicated by placing a caret character, <code>^</code>, immediately after the first square bracket in the expression.</p>
			<p>For instance, <code>[^AEIOUaeiou]</code> would match any character that is NOT a vowel.</p>
			<p>The dash can also be included in the exclusion to indicate a range of characters to be excluded. For example, <code>[^0-9]</code> would indicate to match any character that is not a digit (similar to <code>\d</code>).</p>
			<h2 id="_idParaDest-418"><a id="_idTextAnchor464"/>Quantifiers</h2>
			<p>A <strong class="bold">quantifier</strong> specifies how many of a given character, character class, or token are required for a match.</p>
			<p>Perhaps the most straightforward is a <code>{4}</code>. For example, the <code>a{4}</code> regex would require the letter <code>a</code> to be repeated four times, and <code>\d{3}</code> would require three digits in sequence.</p>
			<p>Its close cousin, the range quantifier, can be specified using a format similar to <code>{min,max}</code>. This one would match if anything between the specified minimum and maximum number of occurrences was present. For example, the <code>a{2,5}</code> regex would match any of <code>aa</code>, <code>aaa</code>, <code>aaaa</code>, or <code>aaaaa</code>.</p>
			<p>A special type of range allows for an unbounded upper limit if the numeral after the comma is omitted. For example, <code>a{3,}</code> would match any number of consecutive <code>a</code> characters of at least three occurrences.</p>
			<h2 id="_idParaDest-419"><a id="_idTextAnchor465"/>Shorthand Quantifiers</h2>
			<p>There are three quantifiers that are used so often that they have special shortcut characters designated to denote them. They are as follows:</p>
			<div><div><img alt="Figure 11.6: Quantifiers&#13;&#10;" src="img/C14377_11_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6: Quantifiers</p>
			<p>Combining these shorthand qualifiers with the concepts we previously covered (literals, character classes, sets, ranges, and so on), the following are example regexes and what they would match:</p>
			<div><div><img alt="Figure 11.7: Regex and their Matches&#13;&#10;&#13;&#10;" src="img/C14377_11_07.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.7: Regex and their Matches</p>
			<h2 id="_idParaDest-420"><a id="_idTextAnchor466"/>Alternation</h2>
			<p>Let's say you want your pattern to allow either of two (or more) words. You can do this by separating the words with a pipe <code>|</code> character, which is equivalent to an <code>OR</code> indicating <code>expression1 OR expression2</code>. </p>
			<p>In most cases, it is also a good idea to enclose the alternative expressions in parenthesis, for example,<code>(expression1|expression2)</code>, to separate them from the rest of the pattern. For example, to scan for either a word, <code>the</code>, followed by one or more whitespace characters, which would be either <code>mother</code> or <code>father</code>, the regex would be as follows:</p>
			<pre>    the\s+(mother|father)</pre>
			<h2 id="_idParaDest-421"><a id="_idTextAnchor467"/>Many More Regex Concepts</h2>
			<p>This chapter covers only a brief overview of basic regex concepts and provides a good background so that you can get started with them. You are encouraged to explore more advanced features using the many available resources. These include the following concepts: </p>
			<ul>
				<li>Greedy versus lazy quantifiers: <a href="https://packt.live/33vxqvQ">https://packt.live/33vxqvQ</a></li>
				<li>Capturing groups: <a href="https://packt.live/34Iq0G0">https://packt.live/34Iq0G0</a></li>
				<li>Backreferences: <a href="https://packt.live/2NqrDCe">https://packt.live/2NqrDCe</a></li>
				<li>Lookahead and lookbehind: <a href="https://packt.live/2NrkMbR">https://packt.live/2NrkMbR</a></li>
				<li>Sticky flag: https://packt.live/32q86Gw</li>
				<li>The internals of how regex engines actually work: <a href="https://packt.live/2oXQUKE">https://packt.live/2oXQUKE</a> </li>
			</ul>
			<h2 id="_idParaDest-422"><a id="_idTextAnchor468"/>Pattern Specification and Flags</h2>
			<p>So far, we have covered the elements that comprise regex patterns, but now, we will cover how these patterns are conveyed in JavaScri<a id="_idTextAnchor469"/>pt code. The most common method is to enclose the pattern in a pair of slash characters, for example, <code>/pattern/</code>. Flags can also be added after the second slash, though this is optional.</p>
			<p>Flags can change the behavior of how matching and searching occurs. The most common flags are as follows:</p>
			<ul>
				<li><code>g</code>: If specified, all matches are returned (if not specified, only the first match is returned by default).</li>
				<li><code>i</code>: Makes the matching case-insensitive; there's no differentiation between uppercase and lowercase letters.</li>
			</ul>
			<p>Others include <code>m</code> (multiline search), <code>s</code> (dot  <code>.</code> matches newline), <code>u</code> (Unicode support), and <code>y</code> (sticky mode).</p>
			<h2 id="_idParaDest-423"><a id="_idTextAnchor470"/>Finding Matches with String.match()</h2>
			<p>The JavaScript <code>String</code> class has a number of built-in methods that accept regex parameters. This section outlines some of them.</p>
			<p>The most common method you would use is <code>String.match()</code>. This method behaves differently, and its return value varies depending on whether the <code>g</code> flag is included:</p>
			<ul>
				<li>If there is no <code>g</code> flag: Searching stops after the first match is found. The result is an array with the match returned as the array element, the additional property <code>index</code>, indicating the position where the match was found, and some additional properties. (Note that it has other functionalities if the regex contains groupings, but groups are not covered in this chapter)</li>
				<li>If there is a <code>g</code> flag: Searches for all possible matches and returns those found in an array. There are no other properties in the return value.</li>
			</ul>
			<h2 id="_idParaDest-424"><a id="_idTextAnchor471"/>Exercise 11.01: The Effect of the g Flag</h2>
			<p>The following code illustrates the difference regarding whether the <code>g</code> flag is present or not. It matches words that begin with the letter <code>t</code>. (The <code>i</code> flag is also demonstrated to make the match case insensitive.) Let's get started:</p>
			<ol>
				<li>In the Google Chrome browser, go into <code>Developer Tools</code> (Menu (the three dots in the upper right of the screen), <code>More Tools</code> | <code>Developer Tools</code>, or just hit the <code>F12</code> key).</li>
				<li>Type the following into the console to set up our test string:<pre>    const str = "Here's the food for Tommy today";
    let match;</pre></li>
				<li><code>g</code> flag is not present. Type the following:<pre>    let match = str.match(/\bt\w+/i);</pre><p>In the steps that follow, the lines of the code snippets that begin with <code>&gt;</code> indicate what you should type in. The lines that begin with <code>&lt;-</code> is the output you are expected to see.</p></li>
				<li>Let's see what was matched. To do that, type the following:<pre>    &gt; match[0]
   &lt;- "the"</pre></li>
				<li>Check at what character index the match was made:<pre>    &gt; match.index
   &lt;- 7</pre></li>
				<li>Since there is no <code>g</code>, we are not expecting any further matches. To verify this, use the following code:<pre>    &gt; match[1]
   &lt;- undefined</pre><p>The matches from the first expression will be displayed as follows:</p><div><img alt="Figure 11.8: Full output of the first match expression&#13;&#10;" src="img/C14377_11_08.jpg"/></div><p class="figure-caption">Figure 11.8: Full output of the first match expression</p></li>
				<li><code>g</code> flag is present. Type the following to reassign the match variable to include <code>g</code> (and <code>i</code>):<pre>    m<a id="_idTextAnchor472"/>atch = str.match(/\bt\w+/gi);</pre></li>
				<li>Type the remaining lines in succession, checking the expected output of each:<pre>    &gt; match[0]
   &lt;- "the"
    &gt; match[1]
   &lt;- "Tommy"
    &gt; match[2]
   &lt;- "today"
    &gt; match[3]
   &lt;- undefined</pre><p>The matches of the expression with a <code>g</code> will be displayed as follows:</p></li>
			</ol>
			<div><div><img alt="Figure 11.9: Full output of the match expression with the g flag&#13;&#10;" src="img/C14377_11_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.9: Full output of the match expression with the g flag</p>
			<p>In this exercise, you saw how to use the <code>g</code> flag of the <code>String.match()</code> method to can obtain multiple matches. Next, you will learn about other methods that involve regexes.</p>
			<h2 id="_idParaDest-425"><a id="_idTextAnchor473"/>Other String Methods for Regexes</h2>
			<p>The following table briefly describes some of the other methods in the String object related to regexes:</p>
			<div><div><img alt="Figure 11.10: String methods&#13;&#10;" src="img/C14377_11_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.10: String methods</p>
			<p>There is another useful method to take note of when using regexes in JavaScript. The <code>test()</code> method returns a simple <code>true</code> or <code>false</code> that indicates whether a match has been found. You can use it in code such as the following to test whether a string begins with the characters <code>hello</code>:</p>
			<pre>   if (/^hello/.test(str)) {
      
   }</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">There are other more advanced methods of the String object that are not covered here. JavaScript also has a dedicated built-in RegExp object that supports advanced use cases (the <code>test()</code> method actually belongs to RegExp).</p>
			<h2 id="_idParaDest-426"><a id="_idTextAnchor474"/>Exercise 11.02: Modifying Regex to Match a Pattern</h2>
			<p>Recall the regex pattern we presented at the beginning of this chapter, which we used to match phone numbers in the format <code>XXX-XXX-XXXX</code>:</p>
			<pre>    ^[2-9]\d{2}-\d{3}-\d{4}$</pre>
			<p>Using what you've learned so far, in this exercise, you will modify the regex to match phone numbers of a slightly different format:</p>
			<pre>    (XXX) XXX-XXXX</pre>
			<p>There are many sites that help you craft and test regexes. We will use <a href="https://regex101.com/">https://regex101.com/</a> to work on our regex. Let's get started:</p>
			<ol>
				<li value="1">First, compare the two formats to see how similar they are. Notice that the new format, <code>(XXX) XXX-XXXX</code>, is identical to the original format, <code>XXX-XXX-XXXX </code>, for the last seven digits and is only different at the beginning of the pattern. We only need to replace the first four characters of the original pattern (the three digits and a dash, <code>XXX-</code>) with the new characters (an open parenthesis, three digits, a close parenthesis, and a space).</li>
				<li>We need to come up with a regex that corresponds to <code>(XXX)</code>, including a trailing space character that is not displayed:<pre>    \([2-9]\d{2}\)</pre><p>Let's break this code down:</p><ul><li><code>\(</code>: The first character you need to match is a parenthesis. Remember that parentheses are special characters (metacharacters) in a regex, so they need to be escaped with a backslash to indicate that you really intend for the parenthesis character to be matched.</li><li><code>[2-9]</code>: A character range to match a character between 2 and 9.</li><li><code>\d</code>: This is a character class that specifies to match a digit character.</li><li><code>{2}</code>: A fixed quantifier that indicates that the previous digit character (\d) needs to repeat twice for it to be considered a match.</li><li><code>\)</code>: The closing parenthesis, also escaped.</li></ul></li>
				<li>By combining this with the rest of the original regex, you get the final regex:<pre>    ^\([2-9]\d{2}\) \d{3}-\d{4}$</pre><p>To test this solution, there are many sites that help you craft and test regexes. You can go to <a href="https://regex101.com/">https://regex101.com/</a> and enter the regex in the input box. Also, enter <code>(234) 567-8910</code> in the TEST STRING area, as shown here:</p></li>
			</ol>
			<div><div><img alt="Figure 11.11: Screenshot of https://regex101.com/&#13;&#10;" src="img/C14377_11_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.11: Screenshot of https://regex101.com/</p>
			<p>As you can see, the MATCH INFORMATION section indicates that our test string is a full match.</p>
			<p>There is quite a bit happening on this screen, and a lot of information that helps you understand and work with regexes. If you look at the REGULAR EXPRESSION input box, you will see that the various elements of the regex have been color-coded to help break it down to its constituent parts. The EXPLANATION area goes even further and provides detailed explanations of each character or token. Since the full text was not visible in the preceding screenshot, here are the explanations that were provided:</p>
			<div><div><img alt="Figure 11.12: The EXPLANATION area&#13;&#10;" src="img/C14377_11_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.12: The EXPLANATION area</p>
			<h2 id="_idParaDest-427"><a id="_idTextAnchor475"/>Adding More Strings to the Regex</h2>
			<p>Besides having a test string that passes matching, it is a good idea to also put in other test strings that are similar but are not expected to pass. The following screenshot shows some other such patterns in the TEST STRING area, but notice that only the first one of those patterns shows a match (as expected):</p>
			<div><div><img alt="Figure 11.13: More test strings that are not expected to match&#13;&#10;" src="img/C14377_11_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.13: More test strings that are not expected to match</p>
			<p>The pattern to match phone numbers in the previous exercise works okay, but it looks for a very specific pattern. The following activity will challenge you into making the regex more flexible so that it accepts multiple phone number formats.</p>
			<p>What if you were asked to come up with one regex that can be used to match either of the <code>XXX-XXX-XXXX</code> or <code>(XXX) XXX-XXXX</code> patterns?</p>
			<p>The challenge is to come up with just one regex that can match either phone number format. Before presenting a good solution, let's consider an incorrect and naive one that, at first glance, seems like the most obvious approach to take, but is actually flawed and fraught with pitfalls.</p>
			<p>Observe that the second format is mostly similar to the original one, with the exception that the first set of three digits begins and end with parenthesis characters (<code>(</code> and <code>)</code>) and is followed by a space rather than a dash character. You may begin to think of representing these differences by adding parenthesis to the regular expression and simply making them optional (using the ? quantifier) and placing the dash and space in a set (using <strong class="bold">[] </strong>syntax). Such a regex would look like this (the additions are emphasized):</p>
			<pre>    <strong class="bold">^\(</strong>?[2-9]\d{2}<strong class="bold">\)?[- ]</strong>\d{3}-\d{4}$</pre>
			<p>The problem is that this regex is incomplete and would also allow matches of some incorrect and undesirable formats, such as the following:</p>
			<ul>
				<li><code>(234 567-8901</code> (no ending parenthesis)</li>
				<li><code>234) 567-8901</code> (no starting parenthesis)</li>
				<li><code>234 567-8901</code> (using a space character inappropriately)</li>
				<li><code>(234)-567-8901</code> (using a dash inappropriately)</li>
			</ul>
			<p>This can be seen if you enter these test strings into the tool as well:</p>
			<div><div><img alt="Figure 11.14: All the test strings match due to a flawed regex&#13;&#10;" src="img/C14377_11_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.14: All the test strings match due to a flawed regex</p>
			<p>Only the first two test strings should have matched, but they all did (indicated by them all being highlighted in blue). </p>
			<h2 id="_idParaDest-428">Acti<a id="_idTextAnchor476"/>vity 11.01: Expanding Phone Number Matching Patterns to Accept Multiple Formats</h2>
			<p>In the previous exercise, we modified a regex to match phone numbers that have the following format: <code>(XXX) XXX-XXXX</code>. In this activity, we will create one regex that can be used to match either of the <code>XXX-XXX-XXXX</code> or <code>(XXX) XXX-XXXX</code> patterns. Once you have completed this activity, you should have a regex that accepts either of the <code>(XXX) XXX-XXXX </code>or<code> XXX-XXX-XXXX </code>number formats.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Indicate that the regex snippets corresponding to each format are alternate expressions of an alternation.</li>
				<li>Combine them with the rest of the original regex in the previous exercise to get the complete regex.</li>
				<li>Now, test the regex with the following numbers: (234) 567-8901; 234-567-8907; 234) 567-8901; (234 567-8901; 234 567-8901; and (234)-567-8901.</li>
			</ol>
			<p>The expected output of this activity should be as follows:</p>
			<div><div><img alt="Figure 11.15: Output to the Activity 11.01&#13;&#10;" src="img/C14377_11_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.15: Output to the Activity 11.01</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to the activity can be found on page 745.</p>
			<h2 id="_idParaDest-429"><a id="_idTextAnchor477"/>Activity 11.02: Expanding Phone Number Matching Patterns to Accept a Particular Format</h2>
			<p>In this activity, we will<code>+XXX </code>), such as one of the following:</p>
			<pre>+97 (234) 567-8910
+97 234-567-8910</pre>
			<p>Once you've completed this activity, you should have a regex that successfully tests for the <code>+xxx</code> format.</p>
			<p><strong class="bold">Steps:</strong></p>
			<ol>
				<li value="1">Construct the regex for the <code>+XXX</code> pattern (where between 1-3 digits are acceptable).</li>
				<li>Combine this with the original regex to get the complete regex.</li>
				<li>Modify the regex to allow the use of space or dot characters as digit separators rather than only dashes.</li>
				<li>Test the patterns with the following numbers: </li>
			</ol>
			<div><div><img alt="Figure 11.16: Many of the patterns that match the regular expression&#13;&#10;" src="img/C14377_11_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.16: Many of the patterns that match the regular expression</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 747.</p>
			<h2 id="_idParaDest-430"><a id="_idTextAnchor478"/>Useful Regexes</h2>
			<p>The following table presents a number of regexes for different purposes. You should be able to understand them using the concepts we've covered, but in most cases, no further explanation will be given besides for the regex itself:</p>
			<div><div><img alt="Figure 11.17: Regex and their purpose&#13;&#10;" src="img/C14377_11_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.17: Regex and their purpose</p>
			<p>In this topic, you learned about the basics of regular expressions and their usefulness. Just a word of caution, though: while regexes are very powerful, they can also be very tricky to implement, and it can take some practice to get them right.</p>
			<p>Now, for a bit of an admission. While our exercise presented regexes for validating phone numbers, they were for the sake of learning and education about regexes. In a real-world application, you would probably want to consider using a dedicated library for such validation. Several such libraries are available, and the advantages of using such libraries are that they are well thought out, tested, and support a wide variety of options and phone number formats from different countries around the world. One such library is Google's <a href="http://libphonenumber">libphonenumber</a>.</p>
			<p>In the next topic, you'll get into clean coding.</p>
			<h1 id="_idParaDest-431"><a id="_idTextAnchor479"/>Best Practices for Clean Coding</h1>
			<p>Code often has a way of living longer than anyone would think it would. Just look at all the mainframe systems that are still in use today. At times, even experienced developers are baffled by it and have a difficult time understanding code they themselves wrote when looking at the code just a few weeks or months later. It behooves software developers to adopt a mindset of good practices and habits when coding.</p>
			<p>Code is almost never written just once to never be used again. Often, you or someone else will need to work on the code at a later date. If you write clean code, you are helping your future self and co-workers work more efficiently when that time comes. You are also making it easier to maintain the system and fix bugs.</p>
			<p>Many of the ideas and practices in this section are based on the books and blogs of Robert C. Martin, also known as "Uncle Bob," who is a recognized expert in the field of clean coding and has produced popular books, blogs, and training videos. We will only present a brief overview and highlights, but entire books have been written on the subject. You are encouraged to delve deeper into this subject.</p>
			<p>Look at the following code:</p>
			<pre>    function circ(r) {
      return r * 2 * Math.PI;
    }</pre>
			<p>The purpose of this code is to calculate the circumference of a circle, but I'll bet this was not very obvious to you based on how it is written. Perhaps adding some explanatory comments would help, but compare the preceding code to this:</p>
			<pre>    function circumference(radius) {
        return radius * 2 * Math.PI;
    }</pre>
			<p>You would agree that this code was much more understandable and leaves little doubt about what it does, what the parameter is, and what is returned. Renaming the function from <code>circ</code> to <code>circumference</code> and the parameter from <code>r</code> to <code>radius</code> is all it took to achieve understanding. This was all done without the need to add any explanatory comments.</p>
			<p>We've improved our code so far by using better naming, but here's another improvement worth making. The usual formula for circumference is <code>C = πd</code>, where <code>d</code> is the diameter. If you split our calculation into two steps, the code would be clearer. Compare the preceding code to the following:</p>
			<pre>    function circumference(radius) {
        let diameter = radius * 2;
        return diameter * Math.PI;
    }</pre>
			<p>This simple change makes it clearer why the calculation needed to multiply the radius by 2, namely, to calculate the diameter before multiplying it by pi to get the circumference.</p>
			<p>This may not seem like a big improvement, and arguably the extra line of code does not add much value or clarity. You would probably be correct in this simple instance. But consider how coding in such a way could potentially simplify scenarios where more complex calculations or logic is required.</p>
			<h2 id="_idParaDest-432"><a id="_idTextAnchor480"/>Good Naming Practices</h2>
			<p>Use the following guidelines when naming variables, functions, or other objects:</p>
			<ul>
				<li><code>timeElapsedInDays</code>, <code>daysSinceCreation</code>, and <code>ageInDays</code>. In general, code should be as self-documenting as possible and comments should be kept to a minimum. Comments have a way of becoming outdated as code is refactored and logic is changed over time, and programmers tend to forget to update them.</li>
				<li><code>bookList</code> if it is in fact an array of books. Just calling it <code>books</code> is preferred.</li>
				<li><code>BookInfo</code> and <code>BookData</code>, you have made the names different without making them mean anything different. Use more specific names that differentiate what the purpose of each class is.</li>
				<li><code>const yyyymmdstr = moment().format("YYYY/MM/DD");</code></pre><p>Now, let's compare it with a good one:</p><pre>    <code>const currentDate = moment().format("YYYY/MM/DD");</code></pre></li>
				<li><code>SECONDS_IN_DAY</code> is more meaningful than <code>86400</code> and explains what that number represents better. It also makes it easier to locate later when searching over the body of text.</li>
				<li><code>Customer</code>, <code>Account</code>, and <code>AddressParser</code>. Avoid words such as <code>Manager</code>, <code>Processor</code>, <code>Data</code>, or <code>Info</code>, which are either verbs or too generic.</li>
				<li><code>addFunds</code>, <code>deleteUser</code>, or <code>save</code>. Accessors and mutators should be prefixed with <code>get</code> or <code>set</code>.</li>
				<li><code>fetch</code>, <code>retrieve</code>, and <code>get</code>, which do the same thing. It's best to pick one word and use it consistently across your code.</li>
				<li><code>eatMyShorts()</code> to mean <code>abort()</code>.</li>
				<li><strong class="bold">Don't add unneeded context</strong>: If your class or object is already named descriptively, there is no need to repeat the name in the variables within. Take a look at the following examples.<p>This is bad:</p><pre>    const employee = {
        employeeFirstName: "Daniel",
        employeenLastName: "Rosenbaum",
        employeeActive: true
    };
    function fireEmployee(employee) {
        employee.employeeActive = false;
    }</pre><p>Whereas this is good:</p><pre>    const employee = {
        firstName: "John",
        lastName: "Smith",
        active: true
    };
    function fireEmployee(employee) {
        employee.active = false;
    }</pre></li>
			</ul>
			<p>Following are the best practices for functions:</p>
			<ul>
				<li><strong class="bold">Functions should only do one thing and be small</strong>: When functions are concise and limited in what they do, they are easier to understand, test, and work with. They would also read cleaner and be refactored easily. Coupled with a good function name, they are self-documenting as well.<p>Here's a bad function:</p><pre>    function phoneSubscribers(subscribers) {
        subscribers.forEach(subscriber =&gt; {
            const subscriberRecord = database.lookup(subscriber);
            if (subscriberRecord.isActive()) {
                phoneSubscriber(subscriber);
            }
        });
    }</pre><p>Here's a good function:</p><pre>    function phoneActiveSubscribers(<a id="_idTextAnchor481"/>subscribers) {
        clients.filter(isActiveSubscriber).forEach(phone);
    }
    function isActiveSubscriber(subscriber) {
        const subscriberRecord = database.lookup(subscriber);
        return subscriberRecord.isActive();
    }</pre></li>
				<li><strong class="bold">Limit the number of function arguments</strong>: Ideally, there should be no more than two or three arguments. This makes testing easier. If there are more arguments, consider that your function is probably trying to tackle too much and should be split into multiple functions.</li>
				<li><strong class="bold">Function names should say what they do</strong>: Here's an example of a bad function name:<pre>    function addToDate(date, month) {
      // ...
    }
    const date = new Date();
    // It's hard to tell from the function name what is added
    addToDate(date, 1);</pre><p>This is a good function name:</p><pre>    function addMonthToDate(month, date) {
      // ...
    }
    const date = new Date();
    addMonthToDate(1, date);</pre></li>
				<li><code>doSomething()</code> and instead turns into <code>doSomethingOrSomethingDifferentIfAFlagIsSet()</code>, it's time to split the function.<p>Take a look at the following code:</p><pre>    function createFile(name, temp) {
      if (temp) {
        fs.create(`./temp/${name}`);
      } else {
        fs.create(name);
      }
    }</pre><p>Rather than using the preceding code, use the following instead:</p><pre>    function createFile(name) {
      fs.create(name);
    }
    function createTempFile(name) {
      createFile(`./temp/${name}`);
    }</pre></li>
				<li><code>playerX</code> and <code>playerY</code> variables represent the character's current coordinates:</p><pre>    let playerX = 45, playerY = 100;
    const moveRight = (numSlots) =&gt; {
      playerX += numSlots;
    }
    moveRight(5);</pre><p>It is better to take x as a parameter and reassign the result to a global variable outside the function so that the function remains pure and maintains predictable return values (and makes it easier to test):</p><pre>    let playerX = 45, playerY=100;
    const moveRight = (playerX, numSlots) =&gt; playerX + numSlots;
    playerX = moveRight(playerX, 5);</pre><p class="callout-heading">Note</p><p class="callout">Side effects and pure functions are covered in more detail in <em class="italic">Chapter 14, Understanding Functional Programming</em>, on functional programming. Another important example is to clone objects, arrays, or lists when making modifications, rather than directly doing the modification itself on the input.</p></li>
				<li><strong class="bold">Create functions to capture conditional clauses</strong>: Your code could become cluttered, unfocused, and hard to follow if you have complex conditions. Creating dedicated functions for your conditions and naming them descriptively makes the code self-documenting and easier to follow.<p>An example of a bad function:</p><pre>if (serviceCall.state === "loading" &amp;&amp; isEmpty(result)) {
    // ...
}</pre><p>An example of a good function:</p><pre>function shouldShowSpinner(serviceCall, result) {
    return serviceCall.state === "loading" &amp;&amp; isEmpty(result);
}
if (shouldShowSpinner(serviceCall, result)) {
    // ...
}</pre></li>
			</ul>
			<h2 id="_idParaDest-433"><a id="_idTextAnchor482"/>JavaScript Linters</h2>
			<p>A linter is a tool that analyzes source code to help you debug your code, find potential issues and bugs and check coding styles (which is often subjective). Using a linter in your projects could help you and your team improve the quality of your code and provide consistent styling, which could help smooth out differences of code that different team members write.</p>
			<p>Linters can typically be used in three different ways:</p>
			<ul>
				<li>Typing or pasting your code into the online version of a tool via a browser page. This is the simplest way, but it is not convenient for anything but small spot checks.</li>
				<li>Using a plugin for your IDE or text editor, either to show your errors and warnings as you type or separately.</li>
				<li>Running scans and generating reports as part of your automated build process every time your source code is built, or periodically. (If desired, you can even cause builds to fail if the scan results in errors of sufficient severity.)</li>
			</ul>
			<p>There are several linters available for JavaScript, including the following:</p>
			<ul>
				<li><strong class="bold">ESLint</strong>: This is very configurable and customizable. This perhaps makes it the most complex and hardest linter to just pick up and start using.</li>
				<li><strong class="bold">JSLint</strong>: This is somewhat configurable but highly opinionated on a popular but particular coding style, as described in the tool's documentation.</li>
				<li><strong class="bold">JSHint</strong>: This is somewhere between the other two in terms of customizability.</li>
			</ul>
			<h2 id="_idParaDest-434"><a id="_idTextAnchor483"/>Exercise 11.03: JSLint</h2>
			<p>This exercise will describe <code>JSLint</code> in more detail since it is the easiest to set up and start using, uses a good coding style, and is a good fit for many projects. Let's get started:</p>
			<ol>
				<li value="1">Open a web browser such as Google Chrome and go to <a href="http://www.jslint.com">www.jslint.com</a>.</li>
				<li>In the Options section on the lower part of the screen, select <code>Assume → a browser</code> (this sets the scan to define certain objects that are usually available in a browser, such as a <code>document</code> object):<div><img alt="Figure 11.18: Online version of JSLint&#13;&#10;" src="img/C14377_11_18.jpg"/></div><p class="figure-caption">Figure 11.18: Online version of JSLint</p></li>
				<li>Paste in the code from <code>conventional.html</code> file into the <em class="italic">Source</em> window.</li>
				<li>Press the <em class="italic">JSLint</em> button, which will result in an output that's similar to what's shown in the following screenshot:<div><img alt="Figure 11.19: Result of the scan&#13;&#10;" src="img/C14377_11_19.jpg"/></div><p class="figure-caption">Figure 11.19: Result of the scan</p></li>
				<li>The scan results have multiple warnings of the following: <code>Use double quotes, not single quotes</code>. This is perhaps an example of a subjective preference as it is common in many languages for single characters to use single quotes, not double-quotes. Luckily, this is a configurable option if you select <code>Tolerate → single quote strings</code> in the Options section, as shown in the following screenshot. After clicking the <em class="italic">JSLint</em> button once again, this will result in all the warnings being removed:<div><img alt="Figure 11.20: Tolerate → single quote strings option&#13;&#10;" src="img/C14377_11_20.jpg"/></div><p class="figure-caption">Figure 11.20: Tolerate → single quote strings option</p></li>
				<li>An alternative way of specifying the option to allow single quote strings (and a number of other options) is by means of a special comment syntax that begins with <code>/*jslint</code>. Uncheck the <code>Tolerate → single quote strings</code> option and add the following to the top of the code:<pre>    /*jslint
        single
    */</pre><p>The warnings will continue to be empty upon clicking the JSLint button.</p></li>
			</ol>
			<p>This exercise explains how your JavaScript code compiles using the <code>Jslint</code> tool. It also helps to decrease the debugging time by providing a fixing issues report.</p>
			<h2 id="_idParaDest-435">Act<a id="_idTextAnchor484"/>ivity 11.03: Refactoring to Clean Code</h2>
			<p>Making a habit of using clean coding best practices is an essential skill. We are now ready to put our newly acquired clean coding skills to test.</p>
			<p>Look at the JavaScript code in the <code>&lt;script&gt;</code> section of the following file and figure out how you can refactor it to be cleaner and easier to maintain and test.</p>
			<pre>activity_original_code.html
1 &lt;html&gt;
2 &lt;head&gt;
3 &lt;meta charset="utf-8"/&gt;
4 &lt;/head&gt;
5 &lt;body&gt;
5 &lt;span id="error" style="color: red"&gt;&lt;/span&gt;
6 &lt;table&gt;
7   &lt;tr&gt;
8     &lt;td&gt;# of hours:&lt;/td&gt;
9     &lt;td&gt;&lt;input id="numHours" /&gt;&lt;/td&gt;
10   &lt;/tr&gt;
11   &lt;tr&gt;
12     &lt;td&gt;Pay rate per hour:&lt;/td&gt;
13     &lt;td&gt;&lt;input id="payRate" /&gt;&lt;/td&gt;
14     &lt;td&gt;(in ####.## format)&lt;/td&gt;
15   &lt;/tr&gt;</pre>
			<p>In short, this is a simple web page that calculates worker pay based on the number of hours, pay rate per hour, and worker type. There are three types of workers that have different rules regarding how their pay is determined: <code>Standard</code>, who gets overtime pay at <code>No Overtime</code>, who do not get any overtime, and <code>Double Overtime</code> workers, who are paid <strong class="bold">2x</strong> after <strong class="bold">50</strong> hours.</p>
			<p>There are also format checks for the two number fields (implemented with regexes) and a facility to show validation error messages. The following screenshot shows the output with valid inputs (there is only minimal color and styling in this implementation):</p>
			<div><div><img alt="Figure 11.21: Sample output with valid inputs&#13;&#10;" src="img/C14377_11_21.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.21: Sample output with valid inputs</p>
			<p>The following screenshot shows the output with a validation error:</p>
			<div><div><img alt="Figure 11.22: Sample output with a validation error&#13;&#10;" src="img/C14377_11_22.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figu<a id="_idTextAnchor485"/>re 11.22: Sample output with a validation error</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 748.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">To refactor the code, create a function called <code>processForm()</code>.</li>
				<li>Create a function called <code>resetErrorsAndResults()</code>.</li>
				<li>Create a class to hold form field values and perform validations.</li>
				<li>Next, create a function called <code>getFormFields()</code>. This function is limited to getting the values from the form and creating an instance of the <code>FormFields</code> class.</li>
				<li>Create the <code>displayError()</code> and <code>displayResult()</code> functions to display errors and results.</li>
				<li>Finally, create the <code>calculateStandardWorkerPay()</code>, <code>calculateNoOvertimeWorkerPay()</code>, and <code>calculateDoubleOvertimeWorkerPay()</code> functions, which take the same two parameters and have the same return value definition so that they can be called abstractly in <code>doCalculation()</code>.</li>
			</ol>
			<h1 id="_idParaDest-436"><a id="_idTextAnchor486"/>Summary</h1>
			<p>In this chapter, you learned about the best practices for clean and maintainable coding. As you saw in this chapter's activity, the refactored code that used clean coding techniques resulted in code that was much longer than before. However, you can see that the code as-is is much cleaner and is easier to understand and test compared to the original.</p>
			<p>It is arguably overkill to refactor to the degree that we presented for our simple application, and many developers feel this way. But the value of this programming style really shows itself more in a complex real-world application, and it is good practice to do work in this way. Developers and tech leads need to decide what standards and clean coding practices make sense for their particular project.</p>
			<p>In the next chapter, you will explore the current trends and cutting-edge features that JavaScript has to offer.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>