["```js\nfunction add (a, b) {\n  return a + b\n} \n```", "```js\nfunction addCps (a, b, callback) {\n  callback(a + b)\n} \n```", "```js\nconsole.log('before')\naddCps(1, 2, result => console.log(`Result: ${result}`))\nconsole.log('after') \n```", "```js\nbefore\nResult: 3\nafter \n```", "```js\nfunction additionAsync (a, b, callback) {\n  setTimeout(() => callback(a + b), 100)\n} \n```", "```js\nconsole.log('before')\nadditionAsync(1, 2, result => console.log(`Result: ${result}`))\nconsole.log('after') \n```", "```js\nbefore\nafter\nResult: 3 \n```", "```js\nconst result = [1, 5, 7].map(element => element - 1)\nconsole.log(result) // [0, 4, 6] \n```", "```js\nimport { readFile } from 'fs'\nconst cache = new Map()\nfunction inconsistentRead (filename, cb) {\n  if (cache.has(filename)) {\n    // invoked synchronously\n    cb(cache.get(filename))\n  } else {\n    // asynchronous function\n    readFile(filename, 'utf8', (err, data) => {\n      cache.set(filename, data)\n      cb(data)\n    })\n  }\n} \n```", "```js\nfunction createFileReader (filename) {\n  const listeners = []\n  inconsistentRead(filename, value => {\n    listeners.forEach(listener => listener(value))\n  })\n  return {\n    onDataReady: listener => listeners.push(listener)\n  }\n} \n```", "```js\nconst reader1 = createFileReader('data.txt')\nreader1.onDataReady(data => {\n  console.log(`First call data: ${data}`)\n  // ...sometime later we try to read again from\n  // the same file\n  const reader2 = createFileReader('data.txt')\n  reader2.onDataReady(data => {\n    console.log(`Second call data: ${data}`)\n  })\n}) \n```", "```js\nFirst call data: some data \n```", "```js\nimport { readFileSync } from 'fs'\nconst cache = new Map()\nfunction consistentReadSync (filename) {\n  if (cache.has(filename)) {\n    return cache.get(filename)\n  } else {\n    const data = readFileSync(filename, 'utf8')\n    cache.set(filename, data)\n    return data\n  }\n} \n```", "```js\nimport { readFile } from 'fs'\nconst cache = new Map()\nfunction consistentReadAsync (filename, callback) {\n  if (cache.has(filename)) {\n    // deferred callback invocation\n    process.nextTick(() => callback(cache.get(filename)))\n  } else {\n    // asynchronous function\n    readFile(filename, 'utf8', (err, data) => {\n      cache.set(filename, data)\n      callback(data)\n    })\n  }\n} \n```", "```js\nreadFile(filename, [options], callback) \n```", "```js\nreadFile('foo.txt', 'utf8', (err, data) => {\n  if(err) {\n    handleError(err)\n  } else {\n    processData(data)\n  }\n}) \n```", "```js\nimport { readFile } from 'fs'\nfunction readJSON (filename, callback) {\n  readFile(filename, 'utf8', (err, data) => {\n    let parsed\n    if (err) {\n      // propagate the error and exit the current function\n      return callback(err)\n    }\n    try {\n      // parse the file contents\n      parsed = JSON.parse(data)\n    } catch (err) {\n      // catch parsing errors\n      return callback(err)\n    }\n    // no errors, propagate just the data\n    callback(null, parsed)\n  })\n} \n```", "```js\nfunction readJSONThrows (filename, callback) {\n  readFile(filename, 'utf8', (err, data) => {\n    if (err) {\n      return callback(err)\n    }\n    callback(null, JSON.parse(data))\n  })\n} \n```", "```js\nreadJSONThrows('invalid_json.json', (err) => console.error(err)) \n```", "```js\nSyntaxError: Unexpected token h in JSON at position 1\n    at JSON.parse (<anonymous>)\n    at file:///.../03-callbacks-and-events/08-uncaught-errors/index.js:8:25\n    at FSReqCallback.readFileAfterClose [as oncomplete] (internal/fs/read_file_context.js:61:3) \n```", "```js\ntry {\n  readJSONThrows('invalid_json.json', (err) => console.error(err))\n} catch (err) {\n  console.log('This will NOT catch the JSON parsing exception')\n} \n```", "```js\nprocess.on('uncaughtException', (err) => {\n  console.error(`This will catch at last the JSON parsing exception: ${err.message}`)\n  // Terminates the application with 1 (error) as exit code.\n  // Without the following line, the application would continue\n  process.exit(1)\n}) \n```", "```js\nimport { EventEmitter } from 'events'\nconst emitter = new EventEmitter() \n```", "```js\nimport { EventEmitter } from 'events'\nimport { readFile } from 'fs'\nfunction findRegex (files, regex) {\n  const emitter = new EventEmitter()\n  for (const file of files) {\n    readFile(file, 'utf8', (err, content) => {\n      if (err) {\n        return emitter.emit('error', err)\n      }\n      emitter.emit('fileread', file)\n      const match = content.match(regex)\n      if (match) {\n        match.forEach(elem => emitter.emit('found', file, elem))\n      }\n    })\n  }\n  return emitter\n} \n```", "```js\nfindRegex(\n  ['fileA.txt', 'fileB.json'],\n  /hello \\w+/g\n)\n  .on('fileread', file => console.log(`${file} was read`))\n  .on('found', (file, match) => console.log(`Matched \"${match}\" in ${file}`))\n  .on('error', err => console.error(`Error emitted ${err.message}`)) \n```", "```js\nimport { EventEmitter } from 'events'\nimport { readFile } from 'fs'\nclass FindRegex extends EventEmitter {\n  constructor (regex) {\n    super()\n    this.regex = regex\n    this.files = []\n  }\n  addFile (file) {\n    this.files.push(file)\n    return this\n  }\n  find () {\n    for (const file of this.files) {\n      readFile(file, 'utf8', (err, content) => {\n        if (err) {\n          return this.emit('error', err)\n        }\n        this.emit('fileread', file)\n        const match = content.match(this.regex)\n        if (match) {\n          match.forEach(elem => this.emit('found', file, elem))\n        }\n      })\n    }\n    return this\n  }\n} \n```", "```js\nconst findRegexInstance = new FindRegex(/hello \\w+/)\nfindRegexInstance\n  .addFile('fileA.txt')\n  .addFile('fileB.json')\n  .find()\n  .on('found', (file, match) => console.log(`Matched \"${match}\" in file ${file}`))\n  .on('error', err => console.error(`Error emitted ${err.message}`)) \n```", "```js\nconst thisTakesMemory = 'A big string....'\nconst listener = () => {\n  console.log(thisTakesMemory)\n}\nemitter.on('an_event', listener) \n```", "```js\nemitter.removeListener('an_event', listener) \n```", "```js\nfindRegexInstance\n  .addFile(...)\n  .find()\n  .on('found', ...) \n```", "```js\nfind () {\n  for (const file of this.files) {\n    let content\n    try {\n      content = readFileSync(file, 'utf8')\n    } catch (err) {\n      this.emit('error', err)\n    }\n    this.emit('fileread', file)\n    const match = content.match(this.regex)\n    if (match) {\n      match.forEach(elem => this.emit('found', file, elem))\n    }\n  }\n  return this\n} \n```", "```js\nconst findRegexSyncInstance = new FindRegexSync(/hello \\w+/)\nfindRegexSyncInstance\n  .addFile('fileA.txt')\n  .addFile('fileB.json')\n  // this listener is invoked\n  .on('found', (file, match) => console.log(`[Before] Matched \"${match}\"`))\n  .find()\n  // this listener is never invoked\n  .on('found', (file, match) => console.log(`[After] Matched \"${match}\"`)) \n```", "```js\n[Before] Matched \"hello world\"\n[Before] Matched \"hello NodeJS\" \n```", "```js\nimport { EventEmitter } from 'events'\nfunction helloEvents () {\n  const eventEmitter = new EventEmitter()\n  setTimeout(() => eventEmitter.emit('complete', 'hello world'), 100)\n  return eventEmitter\n}\nfunction helloCallback (cb) {\n  setTimeout(() => cb(null, 'hello world'), 100)\n}\nhelloEvents().on('complete', message => console.log(message))\nhelloCallback((err, message) => console.log(message)) \n```", "```js\nconst eventEmitter = glob(pattern, [options], callback) \n```", "```js\nimport glob from 'glob'\nglob('data/*.txt',\n  (err, files) => {\n    if (err) {\n      return console.error(err)\n    }\n    console.log(`All files found: ${JSON.stringify(files)}`)\n  })\n  .on('match', match => console.log(`Match found: ${match}`)) \n```"]