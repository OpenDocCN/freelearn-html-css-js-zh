<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">HTTP Servers and Clients</h1>
                </header>
            
            <article>
                
<p>Now that you've learned about Node.js modules, it's time to put this knowledge to work by building a simple Node.js web application. In this chapter, we'll keep to a simple application, enabling us to explore three different application frameworks for Node.js. In later chapters, we'll build some more complex applications, but before we can walk, we must learn to crawl.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>EventEmitters</li>
<li>Listening to HTTP events and the HTTP Server object</li>
<li>HTTP request routing</li>
<li>ES2015 template strings</li>
<li>Building a simple web application with no frameworks</li>
<li>The Express application framework</li>
<li>Express middleware functions</li>
<li>How to deal with computationally intensive code</li>
<li>The HTTP Client object</li>
<li>Creating a simple REST service with Express</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sending and receiving events with EventEmitters</h1>
                </header>
            
            <article>
                
<p>EventEmitters are one of the core idioms of Node.js. If Node.js's core idea is an event-driven architecture, emitting events from an object is one of the primary mechanisms of that architecture. An EventEmitter is an object that gives notifications—events—at different points in its life cycle. For example, an HTTP Server object emits events concerning each stage of the startup/shutdown of the Server object, and as HTTP requests are made from HTTP clients.</p>
<p>Many core Node.js modules are EventEmitters, and EventEmitters are an excellent skeleton to implement asynchronous programming. EventEmitters have nothing to do with web application development, but they are so much part of the Node.js woodwork that you may skip over their existence. </p>
<p>In this chapter, we'll work with the HTTPServer and HTTPClient objects. Both are subclasses of the <kbd>EventEmitter</kbd> class, and rely on it to send events for each step of the HTTP protocol. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">JavaScript classes and class inheritance</h1>
                </header>
            
            <article>
                
<p>Before getting started on the <kbd>EventEmitter</kbd> class, we need to take a look at another of the ES2015 features: classes. The JavaScript language has always had objects, and a concept of a class hierarchy, but nothing so formal as in other languages. The ES2015 class object builds on the existing prototype-based inheritance model, but with a syntax looking very much like class definitions in other languages.</p>
<p>For example, consider this class we'll be using later in the book:</p>
<pre>class Note {<br/>    constructor(key, title, body) {<br/>        this._key = key;<br/>        this._title = title;<br/>        this._body = body;<br/>    }<br/>    get key() { return this._key; }<br/>    get title() { return this._title; }<br/>    set title(newTitle) { return this._title = newTitle; }<br/>    get body() { return this._body; }<br/>    set body(newBody) { return this._body = newBody; }<br/>}</pre>
<p>Once you've defined the class, you can export the class definition to other modules:</p>
<pre>module.exports.Note = class Note { .. }   # in CommonJS modules<br/>export class Note { .. }                  # in ES6 modules</pre>
<p>The functions marked with <kbd>get</kbd> or <kbd>set</kbd> keywords are getters and setters, used like so:</p>
<pre>var aNote = new Note("key", "The Rain in Spain", "Falls mainly on the plain");<br/>var key = aNote.key;<br/>var title = aNote.title;<br/>aNote.title = "The Rain in Spain, which made me want to cry with joy";</pre>
<p>New instances of a class are created with <kbd>new</kbd>. You access a getter or setter function as if it is a simple field on the object. Behind the scenes, the getter/setter function is invoked.</p>
<p>The preceding implementation is not the best because the <kbd>_title</kbd> and <kbd>_body</kbd> <span>fields </span>are publicly visible, and there is no data hiding or encapsulation. We'll go over a better implementation later.</p>
<p>One tests whether a given object is of a certain class by using the <kbd>instanceof</kbd> operator:</p>
<pre>if (anotherNote instanceof Note) {<br/>    ... it's a Note, so act on it as a Note<br/>}</pre>
<p>Finally, you declare a subclass using the <kbd>extends</kbd> operator, similar to what's done in other languages:</p>
<pre>class LoveNote extends Note {<br/>    constructor(key, title, body, heart) {<br/>        super(key, title, body);<br/>        this._heart = heart;<br/>    }<br/>    get heart() { return this._heart; }<br/>    set heart(newHeart) { return this._heart = newHeart; }<br/>}</pre>
<p>In other words, the <kbd>LoveNote</kbd> class has all the fields of <kbd>Note</kbd>, plus this new field named <kbd>heart</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The EventEmitter Class</h1>
                </header>
            
            <article>
                
<p>The <kbd>EventEmitter</kbd> object is defined in the events module of Node.js. Directly using the <kbd>EventEmitter</kbd> class means performing <kbd>require('events')</kbd>. In most cases, <span>you'll be using an existing object that uses <kbd>EventEmitter</kbd> internally and</span> you won't require this module. But there are cases where needs dictate implementing an <span><kbd>EventEmitter</kbd> </span>subclass.</p>
<p>Create a file named <kbd>pulser.js</kbd> containing the following code:</p>
<pre>const EventEmitter = require('events');<br/><br/>class Pulser extends EventEmitter {<br/>    start() {<br/>        setInterval(() =&gt; {<br/>            console.log(`${new Date().toISOString()} &gt;&gt;&gt;&gt; pulse`);<br/>            this.emit('pulse');<br/>            console.log(`${new Date().toISOString()} &lt;&lt;&lt;&lt; pulse`);<br/>        }, 1000);<br/>    }<br/>}<br/>module.exports = Pulser;</pre>
<p>This defines a <kbd>Pulser</kbd> class, which inherits from <kbd>EventEmitter</kbd>. In older Node.js releases, this would require using <kbd>util.inherits</kbd>, but the new class object makes subclassing much simpler. </p>
<p>Another thing to examine is how <kbd>this.emit</kbd> in the callback function refers to the Pulser object. Before the ES2015 arrow function, when our callbacks used a regular <kbd>function</kbd>, <kbd>this</kbd> would not have referred to the <kbd>Pulser</kbd> object. Instead, it would have referred to some other object related to the <kbd>setInterval</kbd> function. Because it is an arrow function, the <kbd>this</kbd> inside the arrow function is the same <kbd>this</kbd> as in the outer function.</p>
<p>If you needed to use a <kbd>function</kbd> rather than an arrow function, this trick would work:</p>
<pre>class Pulser extends EventEmitter {<br/>    start() {<br/>        <strong>var self = this;</strong><br/>        setInterval(function() {<br/>            self.emit(...);<br/>        });<br/>    }<br/>}</pre>
<p>What's different is the<span> assignment of</span> <kbd>this</kbd> to <kbd>self</kbd>. The value of <kbd>this</kbd> inside the function is different, but the value of <kbd>self</kbd> remains the same in every enclosed scope. This widely-used trick is less necessary now that we have arrow functions.</p>
<p><span>If you want a simple EventEmitter, but with your own class name, the body of the extended class can be empty:</span></p>
<pre>class HeartBeat extends EventEmitter {}<br/>const beatMaker = new HeartBeat();</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The purpose of the <kbd>Pulser</kbd> class is sending a timed event, once a second, to any listeners. The <kbd>start</kbd> method uses <kbd>setInterval</kbd> to kick off repeated callback execution, scheduled for every second, calling <kbd>emit</kbd> to send the <kbd>pulse</kbd> events to any listeners.</p>
<p>Now, let's see how to use the <kbd>Pulser</kbd> object. Create a new file, called <kbd>pulsed.js</kbd>, containing:</p>
<pre>const Pulser = require('./pulser');<br/><br/>// Instantiate a Pulser object<br/>const pulser = new Pulser();<br/>// Handler function<br/>pulser.on('pulse', () =&gt; {<br/>    console.log(`${new Date().toISOString()} pulse received`);<br/>});<br/>// Start it pulsing<br/>pulser.start(); </pre>
<p>Here, we create a <kbd>Pulser</kbd> object and consume its <kbd>pulse</kbd> events. Calling <kbd>pulser.on('pulse')</kbd> sets up connections for the <kbd>pulse</kbd> events to invoke the callback function. It then calls the <kbd>start</kbd> method to get the process going.</p>
<p>Enter this into a file and name the file <kbd>pulsed.js</kbd>. When you run it, you should see the following output:</p>
<pre><strong>$ node pulsed.js </strong><br/><strong>2017-12-03T06:24:10.272Z &gt;&gt;&gt;&gt; pulse</strong><br/><strong>2017-12-03T06:24:10.275Z pulse received</strong><br/><strong>2017-12-03T06:24:10.276Z &lt;&lt;&lt;&lt; pulse</strong><br/><strong>2017-12-03T06:24:11.279Z &gt;&gt;&gt;&gt; pulse</strong><br/><strong>2017-12-03T06:24:11.279Z pulse received</strong><br/><strong>2017-12-03T06:24:11.279Z &lt;&lt;&lt;&lt; pulse</strong><br/><strong>2017-12-03T06:24:12.281Z &gt;&gt;&gt;&gt; pulse</strong><br/><strong>2017-12-03T06:24:12.281Z pulse received</strong><br/><strong>2017-12-03T06:24:12.282Z &lt;&lt;&lt;&lt; pulse</strong></pre>
<p>That gives you a little practical knowledge of the <kbd>EventEmitter</kbd> class. Let's now look at its operational theory.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The EventEmitter theory</h1>
                </header>
            
            <article>
                
<p>With the <kbd>EventEmitter</kbd> class, your code emits events that other code can receive. It's a way of connecting two separated sections of your program, kind of like how quantum entanglement means two electrons can communicate with each other from any distance. Seems simple enough.</p>
<p>The event name can be anything that makes sense to you, and you can define as many event names as you like. Event names are defined simply by calling <kbd>.emit</kbd> with the event name. There's nothing formal to do and no registry of event names. Simply making a call to <kbd>.emit</kbd> is enough to define an event name.</p>
<div class="packt_infobox"><span>By convention, the event name </span><kbd>error</kbd><span> indicates errors.</span></div>
<p>An object sends events using the <kbd>.emit</kbd> function. Events are sent to any listeners that have registered to receive events from the object. The program registers to receive an event by calling that object's <kbd>.on</kbd> method, giving the event name and an event handler function.</p>
<p>There is no central distribution point for all events. Instead, each instance of an <kbd>EventEmitter</kbd> object manages its own set of listeners and distributes its events to those listeners.</p>
<p>Often, it is required to send data along with an event. To do so, simply add the data as arguments to the <kbd>.emit</kbd> call, as follows:</p>
<pre>this.emit('eventName', data1, data2, ..); </pre>
<p>When the program receives that event, the data appears as arguments to the callback function. Your program would listen to such an event as follows:</p>
<pre>emitter.on('eventName', (data1, data2, ...theArgs) =&gt; { 
  // act on event 
}); </pre>
<p>There is no handshaking between event receivers and the event sender. That is, the event sender simply goes on with its business, and it gets no notifications about any events received, any action taken, or any error that occurred.</p>
<p>In this example, we used another of the ES2015 features, the <kbd>rest</kbd> operator, shown here as <kbd>...theArgs.</kbd> The <em>rest</em> operator catches any number of remaining function parameters into an array. Since <kbd>EventEmitter</kbd> can pass along any number of parameters, and the <kbd>rest</kbd> operator can automatically receive any number of parameters, it's a match made in heaven, or else in the TC-39 committee.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">HTTP server applications</h1>
                </header>
            
            <article>
                
<p>The HTTP server object is the foundation of all Node.js web applications. The object itself is very close to the HTTP protocol, and its use requires knowledge of that protocol. In most cases, you'll be able to use an application framework such as Express that hides the HTTP protocol details, allowing the programmer to focus on business logic.</p>
<p>We already saw a simple HTTP server application in <a href=""><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>Setting up Node.js</em>, which is as follows:</p>
<pre>const http = require('http'); 
http.createServer((req, res) =&gt; { 
  res.writeHead(200, {'Content-Type': 'text/plain'}); 
  res.end('Hello, World!\n'); 
}).listen(8124, '127.0.0.1'); 
console.log('Server running at http://127.0.0.1:8124'); </pre>
<p>The <kbd>http.createServer</kbd> function creates an <kbd>http.Server</kbd> object. Because it is an <kbd>EventEmitter</kbd>, this can be written in another way to make that fact explicit:</p>
<pre>const http = require('http'); 
const server = http.createServer(); 
server.on('request',  (req, res) =&gt; { 
  res.writeHead(200, {'Content-Type': 'text/plain'}); 
  res.end('Hello, World!\n'); 
}); 
server.listen(8124, '127.0.0.1'); 
console.log('Server running at http://127.0.0.1:8124'); </pre>
<p>The <kbd>request</kbd> event takes a function, which receives <kbd>request</kbd> and <kbd>response</kbd> objects. The <kbd>request</kbd> object has data from the web browser, while the <kbd>response</kbd> object is used to gather the data to be sent in the response. The <kbd>listen</kbd> function causes the server to start listening and arranging to dispatch an event for every request arriving from a web browser.</p>
<p class="mce-root"/>
<p>Now, let's look at something more interesting with different actions based on the URL.</p>
<p>Create a new file, named <kbd>server.js</kbd>, containing the following code:</p>
<pre>const http = require('http'); 
const util = require('util'); 
const url  = require('url'); 
const os   = require('os'); 
 
const server = http.createServer(); 
server.on('request', (req, res) =&gt; { 
    var requrl = url.parse(req.url, true); 
    if (requrl.pathname === '/') { 
        res.writeHead(200, {'Content-Type': 'text/html'}); 
        res.end( 
`&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;/head&gt; 
&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt; 
&lt;p&gt;&lt;a href='/osinfo'&gt;OS Info&lt;/a&gt;&lt;/p&gt; 
&lt;/body&gt;&lt;/html&gt;`); 
    } else if (requrl.pathname === "/osinfo") { 
        res.writeHead(200, {'Content-Type': 'text/html'}); 
        res.end( 
`&lt;html&gt;&lt;head&gt;&lt;title&gt;Operating System Info&lt;/title&gt;&lt;/head&gt; 
&lt;body&gt;&lt;h1&gt;Operating System Info&lt;/h1&gt; 
&lt;table&gt; 
&lt;tr&gt;&lt;th&gt;TMP Dir&lt;/th&gt;&lt;td&gt;${os.tmpdir()}&lt;/td&gt;&lt;/tr&gt; 
&lt;tr&gt;&lt;th&gt;Host Name&lt;/th&gt;&lt;td&gt;${os.hostname()}&lt;/td&gt;&lt;/tr&gt; 
&lt;tr&gt;&lt;th&gt;OS Type&lt;/th&gt;&lt;td&gt;${os.type()} ${os.platform()} ${os.arch()} ${os.release()}&lt;/td&gt;&lt;/tr&gt; 
&lt;tr&gt;&lt;th&gt;Uptime&lt;/th&gt;&lt;td&gt;${os.uptime()} ${util.inspect(os.loadavg())}&lt;/td&gt;&lt;/tr&gt; 
&lt;tr&gt;&lt;th&gt;Memory&lt;/th&gt;&lt;td&gt;total: ${os.totalmem()} free: ${os.freemem()}&lt;/td&gt;&lt;/tr&gt; 
&lt;tr&gt;&lt;th&gt;CPU's&lt;/th&gt;&lt;td&gt;&lt;pre&gt;${util.inspect(os.cpus())}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt; 
&lt;tr&gt;&lt;th&gt;Network&lt;/th&gt;&lt;td&gt;&lt;pre&gt;${util.inspect(os.networkInterfaces())}&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt; 
&lt;/table&gt; 
&lt;/body&gt;&lt;/html&gt;`); 
    } else { 
        res.writeHead(404, {'Content-Type': 'text/plain'}); 
        res.end("bad URL "+ req.url); 
    } 
}); 
 
server.listen(8124); 
console.log('listening to http://localhost:8124'); </pre>
<p>To run it, type the following command:</p>
<pre><strong>$ node server.js
listening to http://localhost:8124</strong></pre>
<p>This application is meant to be similar to PHP's <kbd>sysinfo</kbd> function. Node's <kbd>os</kbd> module is consulted to provide information about the server. This example can easily be extended to gather other pieces of data about the server:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/21c31140-b897-4230-b82b-efc3757960f4.png" style="width:46.17em;height:34.67em;" width="770" height="578"/></div>
<p>A central part of any web application is the method of routing requests to request handlers. The <kbd>request</kbd> object has several pieces of data attached to it, two of which are useful for routing requests: the <kbd>request.url</kbd> and <kbd>request.method</kbd> fields.</p>
<p>In <kbd>server.js</kbd>, we consult the <kbd>request.url</kbd> data to determine which page to show, after parsing (using <kbd>url.parse</kbd>) to ease the digestion process. In this case, we can do a simple comparison of the <kbd>pathname</kbd> to determine which handler method to use.</p>
<p>Some web applications care about the HTTP verb (<kbd>GET</kbd>, <kbd>DELETE</kbd>, <kbd>POST</kbd>, and so on) used and must consult the <kbd>request.method</kbd> field of the <kbd>request</kbd> object. For example, <kbd>POST</kbd> is frequently used for <kbd>FORM</kbd> submissions.</p>
<p>The <kbd>pathname</kbd> portion of the request URL is used to dispatch the request to the correct handler. While this routing method, based on simple string comparison, will work for a small application, it'll quickly become unwieldy. Larger applications will use pattern matching to use part of the request URL to select the request handler function and other parts to extract request data out of the URL. We'll see this in action while looking at Express later in the <em>Getting started with Express</em> section.</p>
<p>A search for a URL match in the npm repository turns up several promising packages that could be used to implement request matching and routing. A framework like Express has <span>this capability </span>already baked in and tested.</p>
<p>If the request URL is not recognized, the server sends back an error page using a <kbd>404</kbd> result code. The result code informs the browser about the status of the request, where a <kbd>200</kbd> code means everything is fine, and a <kbd>404</kbd> code means the requested page doesn't exist. There are, of course, many other HTTP response codes, each with their own meaning.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">ES2015 multiline and template strings</h1>
                </header>
            
            <article>
                
<p>The previous example showed two of the new features introduced with ES2015, multiline and template strings. The feature is meant to simplify our life while creating text strings.</p>
<p>The existing string representations use single quotes and double quotes. Template strings are delimited with the backtick character that's also known as the <strong>grave accent</strong>:</p>
<pre><strong>`template string text`</strong> </pre>
<p>Before ES2015, one way to implement a multiline string was this construct:</p>
<pre>["&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;/head&gt;", 
 "&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt;", 
 "&lt;p&gt;&lt;a href='/osinfo'&gt;OS Info&lt;/a&gt;&lt;/p&gt;", 
 "&lt;/body&gt;&lt;/html&gt;"] 
.join('\n') </pre>
<p>Yes, that was the code used in the same example in previous versions of this book. This is what we can do with ES2015:</p>
<pre>`&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello, world!&lt;/title&gt;&lt;/head&gt; 
&lt;body&gt;&lt;h1&gt;Hello, world!&lt;/h1&gt; 
&lt;p&gt;&lt;a href='/osinfo'&gt;OS Info&lt;/a&gt;&lt;/p&gt; 
&lt;/body&gt;&lt;/html&gt;`</pre>
<p>This is more succinct and straightforward. The opening quote is on the first line, the closing quote on the last line, and everything in between is part of our string.</p>
<p>The real purpose of the template strings feature is supporting strings where we can easily substitute values directly into the string. Most other programming languages support this ability, and now JavaScript does too.</p>
<p>Pre-ES2015, a programmer could have written code like this:</p>
<pre>[ ... 
  "&lt;tr&gt;&lt;th&gt;OS Type&lt;/th&gt;&lt;td&gt;{ostype} {osplat} {osarch} {osrelease}&lt;/td&gt;&lt;/tr&gt;" 
  ... ].join('\n') 
.replace("{ostype}", os.type()) 
.replace("{osplat}", os.platform()) 
.replace("{osarch}", os.arch()) 
.replace("{osrelease}", os.release()) </pre>
<p>Again, this is extracted from the same example in previous versions of this book. With template strings, this can be written as follows:</p>
<pre>`...&lt;tr&gt;&lt;th&gt;OS Type&lt;/th&gt;&lt;td&gt;${os.type()} ${os.platform()} ${os.arch()} ${os.release()}&lt;/td&gt;&lt;/tr&gt;...` </pre>
<p>Within a template string, the part within the <kbd>${ .. }</kbd> brackets is interpreted as an expression. It can be a simple mathematical expression, a variable reference, or, as in this case, a function call.</p>
<p>The last thing to mention is a matter of indentation. In normal coding, one indents a long argument list to the same level as the containing function call. But, for these multiline string examples, the text content is flush with column zero. What's up?</p>
<p>This may impede the readability of your code, so it's worth weighing code readability against another issue: excess characters in the HTML output. The blanks we would use to indent the code for readability will become part of the string and will be output in the HTML. By making the code flush with column zero, we don't add excess blanks to the output at the cost of some code readability.</p>
<p>This approach also carries a security risk. Have you verified the data is safe? That it will not form the basis of a security attack? In this case, we're dealing with simple strings and numbers coming from a safe data source.  Therefore this code is as safe as the Node.js runtime. What about user-supplied content, and the risk that a nefarious user might supply insecure content implanting some kind of malware into target computers?</p>
<p>For this and many other reasons, it is often safer to use an external template engine. Applications like Express make it easy to do so.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">HTTP Sniffer – listening to the HTTP conversation</h1>
                </header>
            
            <article>
                
<p>The events emitted by the HTTPServer object can be used for additional purposes beyond the immediate task of delivering a web application. The following code demonstrates a useful module that listens to all the HTTP Server events. It could be a useful debugging tool, which also demonstrates how HTTP server objects operate.</p>
<p>Node.js's HTTP Server object is an <kbd>EventEmitter</kbd> and the HTTP Sniffer simply listens to every server event, printing out information pertinent to each event.</p>
<p><span>What we're about to do is:</span></p>
<ol start="1">
<li>Create a module,<span> </span><kbd>httpsniffer</kbd>, that prints information about HTTP requests.</li>
<li>Add that module to the<span> </span><kbd>server.js</kbd><span> </span>script we just created.</li>
<li>Rerun that server to view a trace of HTTP activity.</li>
</ol>
<p><span>Create a file named</span> <kbd>httpsniffer.js</kbd> <span>containing the following code:</span></p>
<pre>const util = require('util'); 
const url  = require('url'); 
<br/>const timestamp = () =&gt; { return new Date().toISOString(); }<br/><br/>exports.sniffOn = function(server) { 
  server.on('request', (req, res) =&gt; { 
    console.log(`${timestamp()} e_request`); 
    console.log(`${timestamp()} ${reqToString(req)}`); 
  }); 
  server.on('close', errno =&gt; { console.log(`${timestamp()} e_close <br/>  ${errno}`); }); 
  server.on('checkContinue', (req, res) =&gt; { 
    console.log(`${timestamp()} e_checkContinue`); 
    console.log(`${timestamp()} ${reqToString(req)}`); 
    res.writeContinue(); 
  }); 
  server.on('upgrade', (req, socket, head) =&gt; { 
    console.log(`${timestamp()} e_upgrade`); 
    console.log(`${timestamp()} ${reqToString(req)}`);
  }); 
  server.on('clientError', () =&gt; { console.log(`${timestamp()} <br/>  e_clientError`); }); 
}; 
 
const reqToString = exports.reqToString = (req) =&gt; { 
  var ret=`req ${req.method} ${req.httpVersion} ${req.url}` +'\n'; 
  ret += JSON.stringify(url.parse(req.url, true)) +'\n'; 
  var keys = Object.keys(req.headers); 
  for (var i = 0, l = keys.length; i &lt; l; i++) { 
    var key = keys[i]; 
    ret += `${i} ${key}: ${req.headers[key]}` +'\n'; 
  } 
  if (req.trailers) ret += util.inspect(req.trailers) +'\n'; 
  return ret; <br/>}; </pre>
<p>That was a lot of code! But the key to it is the <kbd>sniffOn</kbd> function. When given an HTTP Server object, it uses the <kbd>.on</kbd> function to attach listener functions that print data about each <span>emitted </span>event. It gives a fairly detailed trace of HTTP traffic on an application.</p>
<p>In order to use it, simply insert this code just before the <kbd>listen</kbd> function in <kbd>server.js</kbd>:</p>
<pre><strong>require('./httpsniffer').sniffOn(server);</strong> 
server.listen(8124); 
console.log('listening to http://localhost:8124'); </pre>
<p>With this in place, run the server as we did earlier. You can visit <kbd>http://localhost:8124/</kbd> in your browser and see the following console output:</p>
<pre><strong>$ node server.js 
listening to http://localhost:8124
2017-12-03T19:21:33.162Z request</strong><br/><strong>2017-12-03T19:21:33.162Z request GET 1.1 /</strong><br/><strong>{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":"","query":{},"pathname":"/","path":"/","href":"/"}</strong><br/><strong>0 host: localhost:8124</strong><br/><strong>1 upgrade-insecure-requests: 1</strong><br/><strong>2 accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</strong><br/><strong>3 user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/604.3.5 (KHTML, like Gecko) Version/11.0.1 Safari/604.3.5</strong><br/><strong>4 accept-language: en-us</strong><br/><strong>5 accept-encoding: gzip, deflate</strong><br/><strong>6 connection: keep-alive</strong><br/><strong>{}</strong><br/><br/><strong>2017-12-03T19:21:42.154Z request</strong><br/><strong>2017-12-03T19:21:42.154Z request GET 1.1 /osinfo</strong><br/><strong>{"protocol":null,"slashes":null,"auth":null,"host":null,"port":null,"hostname":null,"hash":null,"search":"","query":{},"pathname":"/osinfo","path":"/osinfo","href":"/osinfo"}</strong><br/><strong>0 host: localhost:8124</strong><br/><strong>1 connection: keep-alive</strong><br/><strong>2 upgrade-insecure-requests: 1</strong><br/><strong>3 accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</strong><br/><strong>4 user-agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/604.3.5 (KHTML, like Gecko) Version/11.0.1 Safari/604.3.5</strong><br/><strong>5 referer: http://localhost:8124/</strong><br/><strong>6 accept-language: en-us</strong><br/><strong>7 accept-encoding: gzip, deflate</strong><br/><strong>{}</strong></pre>
<p>You now have a tool for snooping on HTTPServer events. This simple technique prints a detailed log of event data. The pattern can be used for any <kbd>EventEmitter</kbd> object. You can use this technique as a way to inspect the actual behavior of <kbd>EventEmitter</kbd> objects in your program.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Web application frameworks</h1>
                </header>
            
            <article>
                
<p>The HTTPServer object is very close to the HTTP protocol. While this is powerful in the same way that driving a stick shift car gives you low-level control over the driving experience, typical web application programming is better done at a higher level. Does anybody use assembly language to write web applications? It's better to abstract away the HTTP details and concentrate on your application.</p>
<p>The Node.js developer community has developed quite a few application frameworks to help with different aspects of abstracting away HTTP protocol details. Of them, Express is the most popular, and Koa (<a href="http://koajs.com/">http://koajs.com/</a>) should be considered because it was developed by the same team and has fully integrated support for <kbd>async</kbd> functions.</p>
<p>The ExpressJS Wiki has a list of frameworks <span>built on top of ExpressJS, or </span>tools that work with it. This includes template engines, middleware modules, and more. The ExpressJS Wiki is located at <a href="https://github.com/expressjs/express/wiki">https://github.com/expressjs/express/wiki</a>.</p>
<p>One reason to use a web framework is that they often provide the best practices used in web application development for over 20 years. The usual best practices include the following:</p>
<ul>
<li>Providing a page for bad URLs (the 404 page)</li>
<li>Screening URLs and forms for any injected scripting attacks</li>
<li>Supporting the use of cookies to maintain sessions</li>
<li>Logging requests for both usage tracking and debugging</li>
<li>Authentication</li>
<li>Handling static files, such as images, CSS, JavaScript, or HTML</li>
<li>Providing cache control headers to caching proxies</li>
<li>Limiting things such as page size or execution time</li>
</ul>
<p>Web frameworks help you invest your time in the task without getting lost in the details of implementing HTTP protocol. Abstracting away details is a time-honored way for programmers to be more efficient. This is especially true when using a library or framework providing prepackaged functions that take care of the details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting started with Express</h1>
                </header>
            
            <article>
                
<p>Express is perhaps the most popular Node.js web app framework. It's so popular that it's part of the MEAN Stack acronym. MEAN refers to MongoDB, ExpressJS, AngularJS, and Node.js. Express is described as being Sinatra-like, referring to a popular Ruby application framework, and that it isn't an opinionated framework, meaning the framework authors don't impose their opinions about structuring an application<span>. This means</span> Express <span>is not at all strict about how your code is structured; you just write it the way you think is best.</span></p>
<p>You can visit the home page for Express at <a href="http://expressjs.com/"><span class="URLPACKT">http://expressjs.com/</span></a>.</p>
<p>Shortly, we'll implement a simple application to calculate Fibonacci numbers using Express, and in later chapters, we'll do quite a bit more with Express. We'll also explore how to mitigate the performance problems from computationally intensive code we discussed earlier.</p>
<p>As of writing this book, Express 4.16 is the current version, and Express 5 is in Alpha testing. According to the ExpressJS website, there are very few differences between Express 4 and Express 5.</p>
<p>Let's start by installing the express-generator. While we can just start writing some code, the express-generator provides a blank starting application. We'll take that and modify it.</p>
<p>Install it using the following commands:</p>
<pre><strong>$ mkdir fibonacci
$ cd fibonacci
$ npm install express-generator@4.x </strong> </pre>
<p>This is different from the suggested installation method on the Express website, which was to use the <kbd>-g</kbd> tag for a global install. We're also using an explicit version number to ensure compatibility. As of writing this book, <kbd>express-generator@5.x</kbd> does not exist. When it does exist, one should be able to use the 5.x version with the following instructions.</p>
<p>Earlier, we discussed how many now recommend against installing modules globally. In the Twelve-Factor model, it's strongly recommended to not install global dependencies, and that's what we're doing.</p>
<p>The result is that an <kbd>express</kbd> command is installed in the <kbd>./node_modules/.bin</kbd> directory:</p>
<pre><strong>$ ls node_modules/.bin/
express</strong> </pre>
<p>Run the <kbd>express</kbd> command like so:</p>
<pre><strong>$ ./node_modules/.bin/express --help
    
  Usage: express [options] [dir]
 
  Options:
    
    -h, --help          output usage information
    -V, --version       output the version number
    -e, --ejs           add ejs engine support (defaults to jade)
        --hbs           add handlebars engine support
    -H, --hogan         add hogan.js engine support
    -c, --css &lt;engine&gt;  add stylesheet &lt;engine&gt; support </strong><br/><strong>    (less|stylus|compass|sass) (defaults to plain css)
        --git           add .gitignore
    -f, --force         force on non-empty directory</strong> </pre>
<p>We probably don't want to type <kbd>./node_modules/.bin/express</kbd> every time we run the <kbd>express-generator</kbd> application or, for that matter, any of the other applications that provide command-line utilities. Refer back to the discussion in <a href="">Chapter 3</a>,<em> Node.js Modules</em> about adding that directory to the <kbd>PATH</kbd> variable.</p>
<p>Now that you've installed <kbd>express-generator</kbd> in the <kbd>fibonacci</kbd> directory, use it to set up the blank framework application:</p>
<pre><span><strong>$ ./node_modules/.bin/express --view=hbs --git . </strong><br/><strong>destination is not empty, continue? [y/N] y </strong><br/> <br/><strong>   create : . </strong><br/><strong>   create : ./package.json </strong><br/><strong>   create : ./app.js </strong><br/><strong>   create : ./.gitignore </strong><br/><strong>   create : ./public </strong><br/><strong>   create : ./routes </strong><br/><strong>   create : ./routes/index.js </strong><br/><strong>   create : ./routes/users.js </strong><br/><strong>   create : ./views </strong><br/><strong>   create : ./views/index.hbs </strong><br/><strong>   create : ./views/layout.hbs </strong><br/><strong>   create : ./views/error.hbs </strong><br/><strong>   create : ./bin </strong><br/><strong>   create : ./bin/www </strong><br/><strong>   create : ./public/javascripts </strong><br/><strong>   create : ./public/images </strong><br/><strong>   create : ./public/stylesheets </strong><br/><strong>   create : ./public/stylesheets/style.css </strong><br/> <br/><strong>   install dependencies: </strong><br/><strong>     $ cd . &amp;&amp; npm install </strong><br/> <br/><strong>   run the app: </strong><br/><strong>     $ DEBUG=fibonacci:* npm start </strong><br/> <br/><strong>    $ npm uninstall express-generator </strong><br/><strong>    added 83 packages and removed 5 packages in 4.104s</strong><br/></span></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>This created a bunch of files for us, which we'll walk through in a minute. The <kbd>node_modules</kbd> directory still has the <kbd>express-generator</kbd> module, which is now not useful. We can just leave it there and ignore it, or we can add it to the <kbd>devDependencies</kbd> of the <kbd>package.json</kbd> it generated. Alternatively, we can uninstall it as shown here.</p>
<p>The next thing to do is run the blank application in the way we're told. The command shown, <kbd>npm start</kbd>, relies on a section of the supplied <kbd>package.json</kbd> file:</p>
<pre>"scripts": { 
    "start": "node ./bin/www" 
}, </pre>
<p>The <kbd>npm</kbd> tool supports scripts that are ways to automate various tasks. We'll use this capability throughout the book to do various things. When the Twelve-Factor Application model suggests automating all your administrative tasks, the <kbd>npm</kbd> scripts feature is an excellent mechanism to do so. Most <kbd>npm</kbd> scripts are run with the <kbd>npm run scriptName</kbd> command, but the <kbd>start</kbd> command is explicitly recognized by <kbd>npm</kbd> and can be run as shown previously.</p>
<p>The steps are:</p>
<ol>
<li>Install the dependencies <kbd>npm install</kbd>.</li>
<li>Start the application using <kbd>npm start</kbd>.</li>
<li>Optionally modify<span> </span><kbd>package.json</kbd> to always run with debugging.</li>
</ol>
<p>To install the dependencies, and run the application, type these commands:</p>
<pre class="packt_figure"><strong>$ npm install</strong><br/><strong>$ DEBUG=fibonacci:* npm start</strong><br/><br/><strong>&gt; fibonacci@0.0.0 start /Users/David/chap04/fibonacci</strong><br/><strong>&gt; node ./bin/www</strong><br/><br/><strong> fibonacci:server Listening on port 3000 +0ms</strong></pre>
<p>Setting the <kbd>DEBUG</kbd> variable this way turns on some debugging output, which includes this message about listening on port 3000. Otherwise, we aren't told this information. This syntax is what's used in the Bash shell to run a command with an environment variable.  If you get an error try running just "<kbd>npm start</kbd>" then read the next section.</p>
<p>We can modify the supplied <kbd>npm start</kbd> script to always run the app with debugging enabled. Change the <kbd>scripts</kbd> section to the following:</p>
<pre>"scripts": { 
    "start": "DEBUG=fibonacci:* node ./bin/www" 
},</pre>
<p>Since the output says it is listening on port <kbd>3000</kbd>, we direct our browser to<br/>
<kbd>http://localhost:3000/</kbd> and see the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/95ceee18-cfe6-44b2-9766-c13520701f24.png" style="width:34.92em;height:17.83em;" width="598" height="306"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Setting environment variables in Windows cmd.exe command line</h1>
                </header>
            
            <article>
                
<p>If you're on Windows the previous example may have failed with an error that DEBUG is not a known command.  The problem is that the Windows shell, the <kbd>cmd.exe</kbd> program, does not support the Bash command-line structure.  </p>
<p>Adding <kbd>VARIABLE=value</kbd> at the beginning of a command-line is specific to some shells, like Bash, on Linux and macOS.  It sets that environment variable only for the command-line being executed, and is a very convenient way to temporarily override environment variables for a specific command.  </p>
<p>Clearly a solution is required if your <kbd>package.json</kbd> is to be usable across different operating systems.</p>
<p>The best solution appears to be the <kbd>cross-env</kbd> package in the npm repository, see: <a href="https://www.npmjs.com/package/cross-env">https://www.npmjs.com/package/cross-env</a>  With this package installed, commands in the <kbd>scripts</kbd> section in <kbd>package.json</kbd> can set environment variables just as in Bash on Linux/macOS.  The usage looks like so:</p>
<pre>"scripts": { 
    "start": "cross-env DEBUG=fibonacci:* node ./bin/www" 
}, <br/>"dependencies": {<br/>    ...<br/>    "cross-env": "5.1.x"<br/>}</pre>
<p>Then the command is executed as so:</p>
<pre><strong>C:\Users\david\Documents\chap04\fibonacci&gt;npm install</strong><br/><strong>... output from installing packages</strong><br/><strong>C:\Users\david\Documents\chap04\fibonacci&gt;npm run start</strong><br/><br/><strong>&gt; fibonacci@0.0.0 start C:\Users\david\Documents\chap04\fibonacci</strong><br/><strong>&gt; cross-env DEBUG=fibonacci:* node ./bin/www</strong><br/><br/><strong>fibonacci:server Listening on port 3000 +0ms</strong><br/><strong>GET / 304 90.597 ms - -</strong><br/><strong>GET /stylesheets/style.css 304 14.480 ms - -</strong><br/><strong>GET /fibonacci 200 84.726 ms - 503</strong><br/><strong>GET /stylesheets/style.css 304 4.465 ms - -</strong><br/><strong>GET /fibonacci?fibonum=22 500 1069.049 ms - 327</strong><br/><strong>GET /stylesheets/style.css 304 2.601 ms - -</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Walking through the default Express application</h1>
                </header>
            
            <article>
                
<p>We have a working, blank Express application; let's look at what was generated for us. We're doing this to familiarize ourselves with Express before diving in to start coding our <kbd>Fibonacci</kbd> application.</p>
<p>Because we used the <kbd>--view=hbs</kbd> option, this application is set up to use the <kbd>Handlebars.js</kbd> template engine. Handlebars was built on top of Mustache, and was originally designed for use in the browser; for more information see its homepage at <a href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>. The version shown here has been packaged for use with Express, and is documented at <a href="https://github.com/pillarjs/hbs">https://github.com/pillarjs/hbs</a>. </p>
<p>Generally speaking, a template engine makes it possible to insert data into generated web pages. The ExpressJS Wiki has a list of template engines for Express <a href="https://github.com/expressjs/express/wiki#template-engines">https://github.com/expressjs/express/wiki#template-engines</a>.</p>
<p>The <kbd>views</kbd> directory contains two files, <kbd>error.hbs</kbd> and <kbd>index.hbs</kbd>. The <kbd>hbs</kbd> extension is used for Handlebars files. Another file, <kbd>layout.hbs</kbd>, is the default page layout. Handlebars has several ways to configure layout templates and even partials (snippets of code which can be included anywhere).</p>
<p>The <kbd>routes</kbd> directory contains the initial routing setup, that is, the code to handle specific URLs. We'll modify these later.</p>
<p>The <kbd>public</kbd> directory will contain assets that the application doesn't generate, but are simply sent to the browser. What's initially installed is a CSS file, <kbd>public/stylesheets/style.css</kbd>.</p>
<p>The <kbd>package.json</kbd> file contains our dependencies and other metadata.</p>
<p>The <kbd>bin</kbd> directory contains the <kbd>www</kbd> script that we saw earlier. That's a Node.js script, which initializes the HTTPServer objects, starts it listening on a TCP port, and calls the last file we'll discuss, <kbd>app.js</kbd>. These scripts initialize Express, hook up the routing modules, and do other things.</p>
<p>There's a lot going on in the <kbd>www</kbd> and <kbd>app.js</kbd> scripts, so let's start with the application initialization. Let's first take a look at a couple of lines in <kbd>app.js</kbd>:</p>
<pre>var express = require('express'); 
... 
var app = express(); 
... 
module.exports = app; </pre>
<p>This means that <kbd>app.js</kbd> is a module that exports the object returned by the <kbd>express</kbd> module. It doesn't start the HTTP server object, however.</p>
<p>Now, let's turn to the <kbd>www</kbd> script. The first thing to see is that it starts with this line:</p>
<pre><strong>#!/usr/bin/env node</strong></pre>
<p>This is a Unix/Linux technique to make a command script. It says to run the following as a script using the <kbd>node</kbd> command. In other words, we have Node.js code and we're instructing the operating system to execute that code using the Node.js runtime:</p>
<pre class="p1"><strong><span class="s1">$ ls -l bin/www<br/></span><span class="s1">-rwx------<span class="Apple-converted-space">  </span>1 david<span class="Apple-converted-space">  </span>staff<span class="Apple-converted-space">  </span>1595 Feb<span class="Apple-converted-space">  </span>5<span class="Apple-converted-space">  </span>1970 bin/www</span></strong></pre>
<p>We can also see that the script was made executable by <kbd>express-generator</kbd>. </p>
<p>It calls the <kbd>app.js</kbd> module as follows:</p>
<pre>var app = require('../app'); 
... 
var port = normalizePort(process.env.PORT || '3000'); 
app.set('port', port); 
... 
var server = http.createServer(app); 
... 
server.listen(port); 
server.on('error', onError); 
server.on('listening', onListening); </pre>
<p>We see where port <kbd>3000</kbd> comes from; it's a parameter to the <kbd>normalizePort</kbd> function. We also see that setting the <kbd>PORT</kbd> environment variable will override the default port <kbd>3000</kbd>. And finally, we see that the HTTP Server object is created here, and is told to use the application instance created in <kbd>app.js</kbd>. Try running the following command:</p>
<pre><strong>$ PORT=4242 DEBUG=fibonacci:* npm start</strong></pre>
<p>The application now tells you that it's listening on port <kbd>4242</kbd>, where you can ponder the meaning of life.</p>
<p>The <kbd>app</kbd> object is next passed to <kbd>http.createServer()</kbd>. A look in the Node.js documentation tells us this function takes a <kbd>requestListener</kbd>, which is simply a function that takes the <kbd>request</kbd> and <kbd>response</kbd> objects we've seen previously. Therefore, the <kbd>app</kbd> object is such a function.</p>
<p>Finally, the <kbd>www</kbd> script starts the server listening on the port we specified.</p>
<p>Let's now walk through <kbd>app.js</kbd> in more detail:</p>
<pre>app.set('views', path.join(__dirname, 'views')); 
app.set('view engine', 'hbs');</pre>
<p>This tells Express to look for templates in the <kbd>views</kbd> directory and to use the EJS templating engine.</p>
<p>The <kbd>app.set</kbd> function is used for setting application properties. It'll be useful to browse the API documentation as we go through (<a href="http://expressjs.com/en/4x/api.html"><span class="URLPACKT">http://expressjs.com/en/4x/api.html</span></a>).</p>
<p>Next is a series of <kbd>app.use</kbd> calls:</p>
<pre>app.use(logger('dev')); 
app.use(bodyParser.json()); 
app.use(bodyParser.urlencoded({ extended: false })); 
app.use(cookieParser()); 
app.use(express.static(path.join(__dirname, 'public'))); 
 
app.use('/', routes); 
app.use('/users', users); </pre>
<p>The <kbd>app.use</kbd> function mounts middleware functions. This is an important piece of Express jargon we will discuss shortly. At the moment, let's say that middleware functions are executed during the processing of routes. This means all the features named here are enabled in <kbd>app.js</kbd>:</p>
<ul>
<li>Logging is enabled using the Morgan request logger. Visit <a href="https://www.npmjs.com/package/morgan"><span class="URLPACKT">https://www.npmjs.com/package/morgan</span></a> for its documentation.</li>
<li>The <kbd>body-parser</kbd> module handles parsing HTTP request bodies. Visit <a href="https://www.npmjs.com/package/body-parser"><span class="URLPACKT">https://www.npmjs.com/package/body-parser</span></a> for its documentation.</li>
<li>The <kbd>cookie-parser</kbd> module is used to parse HTTP cookies. Visit <a href="https://www.npmjs.com/package/cookie-parser"><span class="URLPACKT">https://www.npmjs.com/package/cookie-parser</span></a> for its documentation.</li>
<li>A static file web server is configured to serve the asset files in the <kbd>public</kbd> directory.</li>
<li>Two router modules, <kbd>routes</kbd> and <kbd>users</kbd>, to set up which functions handle which URLs.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Express middleware</h1>
                </header>
            
            <article>
                
<p>Let's round out the walkthrough of <kbd>app.js</kbd> by discussing what middleware functions do for our application. We have an example at the end of the script:</p>
<pre>app.use(function(req, res, next) { 
  var err = new Error('Not found'); 
  err.status = 404; 
  next(err); 
}); </pre>
<p class="mce-root">The comment says <em>catch 404 and forward to error handler</em>. As you probably know, an HTTP 404 status means the requested resource was not found. We need to tell the user their request wasn't satisfied, and maybe show them a picture of a flock of birds pulling a whale out of the ocean. This is the first step in doing so. Before getting to the last step of reporting this error, you must learn how middleware works.</p>
<p>We do have a middleware function right in front of us. Refer to its documentation at <a href="http://expressjs.com/en/guide/writing-middleware.html"><span class="URLPACKT">http://expressjs.com/en/guide/writing-middleware.html</span></a>.</p>
<p>Middleware functions take three arguments. The first two, <kbd>request</kbd> and <kbd>response</kbd>, are equivalent to the <kbd>request</kbd> and <kbd>response</kbd> of the Node.js HTTP request object. However, Express expands the objects with additional data and capabilities. The last, <kbd>next</kbd>, is a callback function controlling when the request-response cycle ends, and it can be used to send errors down the middleware pipeline.</p>
<p>The incoming request gets handled by the first middleware function, then the next, then the next, and so on. Each time the request is to be passed down the chain of middleware functions, the <kbd>next</kbd> function is called. If <kbd>next</kbd> is called with an error object, as shown here, an error is being signaled. Otherwise, the control simply passes to the next middleware function in the chain.</p>
<p>What happens if <kbd>next</kbd> is not called? The HTTP request will hang because no response has been given. A middleware function gives a response when it calls functions on the <kbd>response</kbd> object, such as <kbd>res.send</kbd> or <kbd>res.render</kbd>.</p>
<p>For example, consider the inclusion of <kbd>app.js</kbd>:</p>
<pre>app.get('/', function(req, res) { res.send('Hello World!'); }); </pre>
<p>This does not call <kbd>next</kbd>, but instead calls <kbd>res.send</kbd>. This is the correct method of ending the request-response cycle, by sending a response (<kbd>res.send</kbd>) to the request. If neither <kbd>next</kbd> nor <kbd>res.send</kbd> is called, the request never gets a response.</p>
<p>Hence, a middleware function does one of the following four things:</p>
<ul>
<li>Executes its own business logic. The request logger middleware shown earlier is an example.</li>
<li>Modifies the request or response objects. Both the <kbd>body-parser</kbd> and<br/>
<kbd>cookie-parser</kbd> do so, looking for data to add to the <kbd>request</kbd> object.</li>
<li>Calls <kbd>next</kbd> to proceed to the next middleware function or else signals an error.</li>
<li>Sends a response, ending the cycle.</li>
</ul>
<p>The ordering of middleware execution depends on the order they're added to the <kbd>app</kbd> object. The first added is executed first, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Middleware and request paths</h1>
                </header>
            
            <article>
                
<p>We've seen two kinds of middleware functions so far. In one, the first argument is the handler function. In the other, the first argument is a string containing a URL snippet, and the second argument is the handler function.</p>
<p>What's actually going on is <kbd>app.use</kbd> has an optional first argument: the path the middleware is mounted on. The path is a pattern match against the request URL, and the given function is triggered if the URL matches the pattern. There's even a method to supply named parameters in the URL:</p>
<pre>app.use('/user/profile/:id', function(req, res, next) { 
    userProfiles.lookup(req.params.id, (err, profile) =&gt; { 
          if (err) return next(err); 
          // do something with the profile 
          // Such as display it to the user 
          res.send(profile.display()); 
    }); 
}); </pre>
<p>This path specification has a pattern, <kbd>:id</kbd>, and the value will land in <kbd>req.params.id</kbd>. In this example, we're suggesting a user profiles service, and that for this URL we want to display information about the named user.</p>
<p>Another way to use a middleware function is on a specific HTTP request method. With <kbd>app.use</kbd>, any request will be matched, but in truth, <kbd>GET</kbd> requests are supposed to behave differently to <kbd>POST</kbd> requests. You call <kbd>app.METHOD</kbd> where <kbd>METHOD</kbd> matches one of the HTTP request verbs. That is, <kbd>app.get</kbd> matches the <kbd>GET</kbd> method, <kbd>app.post</kbd> matches <kbd>POST</kbd>, and so on.</p>
<p>Finally, we get to the <kbd>router</kbd> object. This is a kind of middleware used explicitly for routing requests based on their URL. Take a look at <kbd>routes/users.js</kbd>:</p>
<pre>var express = require('express'); 
var router = express.Router(); 
router.get('/', function(req, res, next) { 
  res.send('respond with a resource'); 
}); 
module.exports = router; </pre>
<p>We have a module whose <kbd>exports</kbd> object is a router. This router has only one route, but it can have any number of routes you think is appropriate.</p>
<p>Back in <kbd>app.js</kbd>, this is added as follows:</p>
<pre>app.use('/users', users); </pre>
<p>All the functions we discussed for the <kbd>app</kbd> object apply to the <kbd>router</kbd> object. If the request matches, the router is given the request for its own chain of processing functions. An important detail is that the request URL prefix is stripped when the request is passed to the router instance.</p>
<p>You'll notice that the <kbd>router.get</kbd> in <kbd>users.js</kbd> matches <kbd>'/'</kbd> and that this router is mounted on <kbd>'/users'</kbd>. In effect, that <kbd>router.get</kbd> matches <kbd>/users</kbd> as well, but because the prefix was stripped, it specifies <kbd>'/'</kbd> instead. This means a router can be mounted on different path prefixes without having to change the router implementation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Error handling</h1>
                </header>
            
            <article>
                
<p>Now, we can finally get back to the generated <kbd>app.js</kbd>, the <span class="packt_screen">404</span> <span class="packt_screen">Error</span> <span class="packt_screen">page not found</span>, and any other errors the application might want to show to the user.</p>
<p>A middleware function indicates an error by passing a value to the <kbd>next</kbd> function call. Once Express sees an error, it will skip any remaining non-error routing, and it will only pass it to error handlers instead. An error handler function has a different signature than what we saw earlier.</p>
<p>In <kbd>app.js</kbd>, which we're examining, this is our error handler:</p>
<pre>app.use(function(err, req, res, next) { 
  res.status(err.status || 500); 
  res.render('error', { 
    message: err.message, 
    error: {} 
  }); 
}); </pre>
<p>Error handler functions take four parameters, with <kbd>err</kbd> added to the familiar <kbd>req</kbd>, <kbd>res</kbd>, and <kbd>next</kbd>. For this handler, we use <kbd>res.status</kbd> to set the HTTP response status code, and we use <kbd>res.render</kbd> to format an HTML response using the <kbd>views/error.hbs</kbd> template. The <kbd>res.render</kbd> function takes data, rendering it with a template to produce HTML.</p>
<p>This means any error in our application will land here, bypassing any remaining middleware functions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calculating the Fibonacci sequence with an Express application</h1>
                </header>
            
            <article>
                
<p>The Fibonacci numbers are the integer sequence: <em>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, ...</em></p>
<p>Each entry in the list is the sum of the previous two entries in the list. The sequence was invented in 1202 by Leonardo of Pisa, who was also known as Fibonacci. One method to calculate entries in the Fibonacci sequence is the recursive algorithm we showed earlier. We will create an Express application that uses the Fibonacci implementation and then explore several methods to mitigate performance problems in computationally intensive algorithms.</p>
<p>Let's start with the blank application we created in the previous step. We had you name that application <em>Fibonacci</em> for a reason. We were thinking ahead.</p>
<p>In <kbd>app.js</kbd>, make the following changes to the top portion of the file:</p>
<pre>const express = require('express');<br/><strong>const hbs = require('hbs');</strong><br/>const path = require('path');<br/>const favicon = require('serve-favicon');<br/>const logger = require('morgan');<br/>const cookieParser = require('cookie-parser');<br/>const bodyParser = require('body-parser');<br/><br/>const index = require('./routes/index');<br/><strong>const fibonacci = require('./routes/fibonacci');</strong><br/><br/>const app = express();<br/><br/>// view engine setup<br/>app.set('views', path.join(__dirname, 'views'));<br/>app.set('view engine', 'hbs');<br/><strong>hbs.registerPartials(path.join(__dirname, 'partials'));</strong><br/><br/>// uncomment after placing your favicon in /public<br/>//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico')));<br/>app.use(logger('dev'));<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: false }));<br/>app.use(cookieParser());<br/>app.use(express.static(path.join(__dirname, 'public')));<br/><br/>app.use('/', index);<br/><strong>app.use('/fibonacci', fibonacci);</strong></pre>
<p>Most of this is what <kbd>express-generator</kbd> gave us. The <kbd>var</kbd> statements have been changed to <kbd>const</kbd>, for that little teensy bit of extra comfort. We explicitly imported the <kbd>hbs</kbd> module so we could do some configuration. And we imported a router module for Fibonacci, which we'll see in a minute.</p>
<p>For the <kbd>Fibonacci</kbd> application, we don't need to support users, and therefore deleted that routing module.  The <kbd>fibonacci</kbd> module, which we'll show next, serves to query a number for which we'll calculate the Fibonacci number.</p>
<p>In the top-level directory, create a file, <kbd>math.js</kbd>, containing this extremely simplistic Fibonacci implementation:</p>
<pre>exports.fibonacci = function(n) {<br/>    if (n === 0) return 0;<br/>    else if (n === 1 || n === 2) return 1;<br/>    else return exports.fibonacci(n-1) + exports.fibonacci(n-2);<br/>};</pre>
<p>In the <kbd>views</kbd> directory, look at the file named <kbd>layout.hbs</kbd> which <kbd>express-generator</kbd> created:</p>
<pre>&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;{{title}}&lt;/title&gt;<br/>    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    {{{body}}}<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</pre>
<p>This file contains the structure we'll use for HTML pages. Going by the Handlebars syntax, we see that <kbd>{{title}}</kbd> appears within the HTML <kbd>title</kbd> tag. It means when we call <kbd>res.render</kbd>, we should supply a <kbd>title</kbd> attribute. The <kbd>{{{body}}}</kbd> tag is where the view template content lands.</p>
<p>Change <kbd>views/index.hbs</kbd> to just contain the following:</p>
<pre>&lt;h1&gt;{{title}}&lt;/h1&gt;<br/>{{&gt; navbar}}</pre>
<p>This serves as the front page of our application. It will be inserted in place of <kbd>{{{body}}}</kbd> in <kbd>layout.hbs</kbd>. The marker, <kbd>{{&gt; navbar}}</kbd>, refers to a partial named <kbd>navbar</kbd>. Earlier, we configured a directory named <kbd>partials</kbd> to hold partials. Now let's create a file, <kbd>partials/navbar.html</kbd>, containing:</p>
<pre>&lt;div class='navbar'&gt;<br/>&lt;p&gt;&lt;a href='/'&gt;home&lt;/a&gt; | &lt;a href='/fibonacci'&gt;Fibonacci's&lt;/a&gt;&lt;/p&gt;<br/>&lt;/div&gt;</pre>
<p>This will serve as a navigation bar that's included on every page.</p>
<p>Create a file, <kbd>views/fibonacci.hbs</kbd>, containing the following code:</p>
<pre>&lt;h1&gt;{{title}}&lt;/h1&gt;<br/>{{&gt; navbar}}<br/>{{#if fiboval}}<br/>  &lt;p&gt;Fibonacci for {{fibonum}} is {{fiboval}}&lt;/p&gt;<br/>  &lt;hr/&gt;<br/>{{/if}}<br/>&lt;p&gt;Enter a number to see its' Fibonacci number&lt;/p&gt;<br/>&lt;form name='fibonacci' action='/fibonacci' method='get'&gt;<br/>&lt;input type='text' name='fibonum' /&gt;<br/>&lt;input type='submit' value='Submit' /&gt;<br/>&lt;/form&gt;</pre>
<div class="packt_tip"><span>Remember that the files in </span><kbd>views</kbd><span> are templates into which data is rendered. They serve the </span>View<span> aspect of the </span><strong>Model-View-Controller</strong> (<strong>MVC</strong>)<span> paradigm, hence the directory name.</span></div>
<p>In the <kbd>routes</kbd> directory, delete the <kbd>user.js</kbd> module. It is generated by the Express framework, but we will not use it in this application.</p>
<p>In <kbd>routes/index.js</kbd>, change the router function to the following:</p>
<pre>/* GET home page. */ 
router.get('/', function(req, res, next) { 
  res.render('index', { title: "Welcome to the Fibonacci Calculator" }); 
}); </pre>
<p>The anonymous object passed to <kbd>res.render</kbd> contains the data values we provide to the layout and view templates. </p>
<p>Then, finally, in the <kbd>routes</kbd> directory, create a file named <kbd>fibonacci.js</kbd> containing the following code:</p>
<pre>const express = require('express'); 
const router = express.Router(); 
 
const math = require('../math'); 
router.get('/', function(req, res, next) { 
  if (req.query.fibonum) { 
    // Calculate directly in this server 
    res.render('fibonacci', { 
      title: "Calculate Fibonacci numbers", 
      fibonum: req.query.fibonum, 
      fiboval: math.fibonacci(req.query.fibonum) 
    }); 
  } else { 
    res.render('fibonacci', { 
      title: "Calculate Fibonacci numbers", 
      fiboval: undefined 
    }); 
  } 
}); 
 
module.exports = router; </pre>
<p>The <kbd>package.json</kbd> is already set up so we can use <kbd>npm start</kbd> to run the script and always have debugging messages enabled. And now we're ready to do so:</p>
<pre><strong>$ npm start
   
&gt; fibonacci@0.0.0 start /Users/david/chap04/fibonacci
&gt; DEBUG=fibonacci:* node ./bin/www
    
fibonacci:server Listening on port 3000 +0ms</strong> </pre>
<p>As it suggests, you can visit <kbd>http://localhost:3000/</kbd> and see what we have:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/eaa7f981-70a5-4eed-8d6f-766670e06c67.png" style="width:36.67em;height:20.25em;" width="691" height="382"/></div>
<p>This page is rendered from the <kbd>views/index.hbs</kbd> template. Simply click on the <span class="packt_screen">Fibonacci's</span> link to go to the next page, which is of course rendered from the <kbd>views/fibonacci.hbs</kbd> template. On that page, you'll be able to enter a number, click on the <span class="packt_screen">Submit</span> button, and get an answer (hint: pick a number below <kbd>40</kbd> if you want your answer in a reasonable amount of time):</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/c358759e-47e0-4436-8932-df9af39f49dc.png" style="width:35.25em;height:19.50em;" width="689" height="382"/></div>
<p>Let's walk through the application to discuss how it works.</p>
<p>There are two routes in <kbd>app.js</kbd>: the route for <kbd>/</kbd>, which is handled by <kbd>routes/index.js</kbd>, and the route for <kbd>/fibonacci</kbd>, which is handled by <kbd>routes/fibonacci.js</kbd>.</p>
<p>The <kbd>res.render</kbd> function renders the named template using the provided data values and emits the result as an HTTP response. For the home page of this application, the rendering code (<kbd>routes/index.js</kbd>) and template (<kbd>views/index.hbs</kbd>) aren't much, and it is on the Fibonacci page where all the action is happening.</p>
<p>The <kbd>views/fibonacci.hbs</kbd> template contains a form in which the user enters a number. Because it is a <kbd>GET</kbd> form, when the user clicks on the <span class="packt_screen">Submit</span> button, the browser will issue an HTTP <kbd>GET</kbd> on the <kbd>/fibonacci</kbd> URL. What distinguishes one <kbd>GET</kbd> on <kbd>/fibonacci</kbd> from another is whether the URL contains a query parameter named <kbd>fibonum</kbd>. When the user first enters the page, there is no <kbd>fibonum</kbd> and hence nothing to calculate. After the user has entered a number and clicked on <span class="packt_screen">Submit</span>, there is a <kbd>fibonum</kbd> and something to calculate.</p>
<p>Express automatically parses the query parameters, making them available as <kbd>req.query</kbd>. That means <kbd>routes/fibonacci.js</kbd> can quickly check whether there is a <kbd>fibonum</kbd>. If there is, it calls the <kbd>fibonacci</kbd> function to calculate the value.</p>
<p>Earlier, we asked you to enter a number less than <kbd>40</kbd>. Go ahead and enter a larger number, such as <kbd>50</kbd>, but go take a coffee break because this is going to take a while to calculate. Or proceed on to reading the next section where we start to discuss use of computationally intensive code.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Computationally intensive code and the Node.js event loop</h1>
                </header>
            
            <article>
                
<p>This Fibonacci example is purposely inefficient to demonstrate an important consideration for your applications. What happens to the Node.js event loop when running long computations? To see the effect, open two browser windows, each opened to the Fibonacci page. In one, enter the number <kbd>55</kbd> or greater, and in the other, enter <kbd>10</kbd>. Note that the second window freezes, and if you leave it running long enough, the answer will eventually pop up in both windows. What's happening is the Node.js event loop is blocked from processing events because the Fibonacci algorithm is running and does not ever yield to the event loop.</p>
<p>Since Node.js has a single execution thread, processing requests depend on request handlers quickly returning to the event loop. Normally, the asynchronous coding style ensures that the event loop executes regularly.</p>
<p>This is true even for requests that load data from a server halfway around the globe, because the asynchronous I/O is non-blocking and control is quickly returned to the event loop. The naïve Fibonacci function we chose doesn't fit into this model because it's a long-running blocking operation. This type of event handler prevents the system from processing requests and stops Node.js from doing what it's meant to do, namely to be a blisteringly fast web server.</p>
<p>In this case, the long-response-time problem is obvious. Response time quickly escalates to the point where you can take a vacation to Tibet and perhaps get reincarnated as a llama in Peru during the time it takes to respond with the Fibonacci number!</p>
<p>To see this more clearly, create a file named <kbd>fibotimes.js</kbd> containing the following code:</p>
<pre>const math = require('./math'); 
const util = require('util'); 
 
for (var num = 1; num &lt; 80; num++) {<br/>    let now = new Date().toISOString();<br/>    console.log(`${now} Fibonacci for ${num} = ${math.fibonacci(num)}`);
} </pre>
<p>Now run it. You will get the following output:</p>
<pre><strong>$ node fibotimes.js </strong><br/><strong>2017-12-10T23:04:42.342Z Fibonacci for 1 = 1</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 2 = 1</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 3 = 2</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 4 = 3</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 5 = 5</strong><br/><strong>...</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 10 = 55</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 11 = 89</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 12 = 144</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 13 = 233</strong><br/><strong>2017-12-10T23:04:42.345Z Fibonacci for 14 = 377</strong><br/><strong>...</strong><br/><strong>2017-12-10T23:04:44.072Z Fibonacci for 40 = 102334155</strong><br/><strong>2017-12-10T23:04:45.118Z Fibonacci for 41 = 165580141</strong><br/><strong>2017-12-10T23:04:46.855Z Fibonacci for 42 = 267914296</strong><br/><strong>2017-12-10T23:04:49.723Z Fibonacci for 43 = 433494437</strong><br/><strong>2017-12-10T23:04:54.218Z Fibonacci for 44 = 701408733</strong><br/><strong>...</strong><br/><strong>2017-12-10T23:06:07.531Z Fibonacci for 48 = 4807526976</strong><br/><strong>2017-12-10T23:07:08.056Z Fibonacci for 49 = 7778742049</strong><br/><strong>^C</strong></pre>
<p>This quickly calculates the first 40 or so members of the Fibonacci sequence, but after the 40th member, it starts taking a couple of seconds per result and quickly degrades from there. It is untenable to execute code of this sort on a single-threaded system that relies on a quick return to the event loop. A web service containing such code would give poor performance to the users.</p>
<p>There are two general ways to solve this problem <span>in Node.js</span>:</p>
<ul>
<li><strong>Algorithmic refactoring</strong>: Perhaps, like the Fibonacci function we chose, one of your algorithms is suboptimal and can be rewritten to be faster. Or, if not faster, it can be split into callbacks dispatched through the event loop. We'll look at one such method in a moment.</li>
<li><strong>Creating a backend service</strong>: Can you imagine a backend server dedicated to calculating Fibonacci numbers? Okay, maybe not, but it's quite common to implement backend servers to offload work from frontend servers, and we will implement a backend Fibonacci server at the end of this chapter.</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Algorithmic refactoring</h1>
                </header>
            
            <article>
                
<p>To prove that we have an artificial problem on our hands, here is a much more efficient <kbd>Fibonacci</kbd> function:</p>
<pre>exports.fibonacciLoop = function(n) { 
    var fibos = []; 
    fibos[0] = 0; 
    fibos[1] = 1; 
    fibos[2] = 1; 
    for (var i = 3; i &lt;= n; i++) { 
        fibos[i] = fibos[i-2] + fibos[i-1]; 
    } 
    return fibos[n]; 
} </pre>
<p>If we substitute a call to <kbd>math.fibonacciLoop</kbd> in place of <kbd>math.fibonacci</kbd>, the <kbd>fibotimes</kbd> program runs much faster. Even this isn't the most efficient implementation; for example, a simple prewired lookup table is much faster at the cost of some memory.</p>
<p>Edit <kbd>fibotimes.js</kbd> as follows and rerun the script. The numbers will fly by so fast your head will spin:</p>
<pre>for (var num = 1; num &lt; 8000; num++) {<br/>    let now = new Date().toISOString();<br/>    console.log(`${now} Fibonacci for ${num} = ${math.fibonacciLoop(num)}`);<br/>}</pre>
<p>Some algorithms aren't so simple to optimize and still take a long time to calculate the result. In this section, we're exploring how to handle inefficient algorithms, and therefore will stick with the inefficient Fibonacci implementation.</p>
<p>It is possible to divide the calculation into chunks and then dispatch the computation of those chunks through the event loop. Add the following code to <kbd>math.js</kbd>:</p>
<pre>exports.fibonacciAsync = function(n, done) {<br/>    if (n === 0) done(undefined, 0);<br/>    else if (n === 1 || n === 2) done(undefined, 1);<br/>    else {<br/>        setImmediate(() =&gt; {<br/>            exports.fibonacciAsync(n-1, (err, val1) =&gt; {<br/>                if (err) done(err);<br/>                else setImmediate(() =&gt; {<br/>                    exports.fibonacciAsync(n-2, (err, val2) =&gt; {<br/>                        if (err) done(err);<br/>                        else done(undefined, val1+val2);<br/>                    });<br/>                });<br/>            });<br/>        });<br/>    }<br/>};</pre>
<p>This converts the <kbd>fibonacci</kbd> function from asynchronous function to a traditional callback-oriented asynchronous function. We're using <kbd>setImmediate</kbd> at each stage of the calculation to ensure the event loop executes regularly and that the server can easily handle other requests while churning away on a calculation. It does nothing to reduce the computation required; this is still the silly, inefficient Fibonacci algorithm. All we've done is spread the computation through the event loop.</p>
<p>In <kbd>fibotimes.js</kbd>, we can use this:</p>
<div>
<pre><span>const</span><span> </span><span>math</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>'./math'</span><span>);<br/></span><span>const</span><span> </span><span>util</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>'util'</span><span>);<br/><br/></span>(<span>async</span><span> () </span><span>=&gt;</span><span> {<br/></span>   <span>for</span><span> (</span><span>var</span><span> </span><span>num</span><span> </span><span>=</span><span> </span><span>1</span><span>; </span><span>num</span><span> </span><span>&lt;</span><span> </span><span>8000</span><span>; </span><span>num</span><span>++</span><span>) {<br/></span>       <span>await</span><span> </span><span>new</span><span> </span><span>Promise</span><span>((</span><span>resolve</span><span>, </span><span>reject</span><span>) </span><span>=&gt;</span><span> {<br/></span>           <span>math</span><span>.</span><span>fibonacciAsync</span><span>(</span><span>num</span><span>, (</span><span>err</span><span>, </span><span>fibo</span><span>) </span><span>=&gt;</span><span> {<br/></span>               <span>if</span><span> (</span><span>err</span><span>) </span><span>reject</span><span>(</span><span>err</span><span>);<br/></span>               <span>else</span><span> {<br/></span>                   <span>let</span><span> </span><span>now</span><span> </span><span>=</span><span> </span><span>new</span><span> </span><span>Date</span><span>().</span><span>toISOString</span><span>();<br/></span>                   <span>console</span><span>.</span><span>log</span><span>(</span><span>`</span><span>${</span><span>now</span><span>}</span><span> Fibonacci for </span><span>${</span><span>num</span><span>}</span><span> = <br/></span><span>                   ${</span><span>fibo</span><span>}</span><span>`</span><span>);<br/></span>                   <span>resolve</span><span>();<br/></span>               }<br/>           })<br/>       })<br/>    }<br/>})().<span>catch</span><span>(</span><span>err</span><span> </span><span>=&gt;</span><span> { </span><span>console</span><span>.</span><span>error</span><span>(</span><span>err</span><span>); });</span></pre></div>
<p>This version of <kbd>fibotimes.js</kbd> executes the same, we simply type <kbd>node fibotimes</kbd>.  However, using <kbd>fibonacciAsync</kbd> will require changes in the server.</p>
<p>Because it's an asynchronous function, we will need to change our router code. Create a new file, named <kbd>routes/fibonacci-async1.js</kbd>, containing the following:</p>
<pre>const express = require('express');<br/>const router = express.Router();<br/><br/>const math = require('../math');<br/><br/>router.get('/', function(req, res, next) {<br/>  if (req.query.fibonum) {<br/>    // Calculate using async-aware function, in this server<br/>    <strong>math.fibonacciAsync(req.query.fibonum, (err, fiboval) =&gt; {</strong><br/>      res.render('fibonacci', {<br/>        title: "Calculate Fibonacci numbers",<br/>        fibonum: req.query.fibonum,<br/>        fiboval: fiboval<br/>      });<br/>    <strong>});</strong><br/>  } else {<br/>    res.render('fibonacci', {<br/>      title: "Calculate Fibonacci numbers",<br/>      fiboval: undefined<br/>    });<br/>  }<br/>});<br/><br/>module.exports = router;</pre>
<p>This is the same as earlier, just rewritten for an asynchronous Fibonacci calculation.</p>
<p>In <kbd>app.js</kbd>, make this change to the application wiring:</p>
<div>
<pre><span>// const fibonacci = require('./routes/fibonacci');<br/></span><span>const</span><span> </span><span>fibonacci</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>'./routes/fibonacci-async1'</span><span>);</span></pre></div>
<p>With this change, the server no longer freezes when calculating a large Fibonacci number. The calculation of course still takes a long time, but at least other users of the application aren't blocked.</p>
<p>You can verify this by again opening two browser windows in the application. Enter 60 in one window, and in the other start requesting smaller Fibonacci numbers. Unlike with the original <kbd>fibonacci</kbd> function, using <kbd>fibonacciAsync</kbd> allows both windows to give answers, though if you really did enter 60 in the first window you might as well take that three-month vacation to Tibet:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/ec067649-82e1-43c2-8987-b932f0255f23.png" style="width:30.67em;height:28.83em;" width="665" height="627"/></div>
<p>It's up to you, and your specific algorithms, to choose how to best optimize your code and to handle any long-running computations you may have.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Making HTTP Client requests</h1>
                </header>
            
            <article>
                
<p>The next way to mitigate computationally intensive code is to push the calculation to a backend process. To explore that strategy, we'll request computations from a backend Fibonacci server, using the HTTP Client object to do so. However, before we look at that, let's first talk in general about using the HTTP Client object.</p>
<p>Node.js includes an HTTP Client object, useful for making HTTP requests. It has the capability to issue any kind of HTTP request. In this section, we'll use the HTTP Client object to make HTTP requests similar to calling a <strong>Representational State Transfer</strong> (<strong>REST</strong>) web service.</p>
<p>Let's start with some code inspired by the <kbd>wget</kbd> or <kbd>curl</kbd> commands to make HTTP requests and show the results. Create a file named <kbd>wget.js</kbd> containing this code:</p>
<pre>const http = require('http');<br/>const url = require('url');<br/>const util = require('util');<br/><br/>const argUrl = process.argv[2];<br/>const parsedUrl = url.parse(argUrl, true);<br/><br/>// The options object is passed to http.request<br/>// telling it the URL to retrieve<br/>const options = {<br/>  host: parsedUrl.hostname,<br/>  port: parsedUrl.port,<br/>  path: parsedUrl.pathname,<br/>  method: 'GET'<br/>};<br/><br/>if (parsedUrl.search) options.path += "?"+parsedUrl.search;<br/><br/>const req = http.request(options);<br/>// Invoked when the request is finished<br/>req.on('response', res =&gt; {<br/>  console.log('STATUS: ' + res.statusCode);<br/>  console.log('HEADERS: ' + util.inspect(res.headers));<br/>  res.setEncoding('utf8');<br/>  res.on('data', chunk =&gt; { console.log('BODY: ' + chunk); });<br/>  res.on('error', err =&gt; { console.log('RESPONSE ERROR: ' + err); });<br/>});<br/>// Invoked on errors<br/>req.on('error', err =&gt; { console.log('REQUEST ERROR: ' + err); });<br/>req.end();</pre>
<p>You can run the script as follows:</p>
<pre><strong>$ node wget.js http://example.com</strong><br/><strong>STATUS: 200</strong><br/><strong>HEADERS: { 'accept-ranges': 'bytes',</strong><br/><strong>  'cache-control': 'max-age=604800',</strong><br/><strong>  'content-type': 'text/html',</strong><br/><strong>  date: 'Sun, 10 Dec 2017 23:40:44 GMT',</strong><br/><strong>  etag: '"359670651"',</strong><br/><strong>  expires: 'Sun, 17 Dec 2017 23:40:44 GMT',</strong><br/><strong>  'last-modified': 'Fri, 09 Aug 2013 23:54:35 GMT',</strong><br/><strong>  server: 'ECS (rhv/81A7)',</strong><br/><strong>  vary: 'Accept-Encoding',</strong><br/><strong>  'x-cache': 'HIT',</strong><br/><strong>  'content-length': '1270',</strong><br/><strong>  connection: 'close' }</strong><br/><strong>BODY: &lt;!doctype html&gt;</strong><br/><strong>&lt;html&gt;</strong><br/><strong>...</strong></pre>
<p>There's more in the printout, namely the HTML of the page at <kbd>http://example.com/</kbd>. The purpose of <kbd>wget.js</kbd> is to make an HTTP request and show you voluminous details of the response. An HTTP request is initiated with the <kbd>http.request</kbd> method, as follows:</p>
<pre>var http = require('http'); 
var options = { 
  host: 'example.com', 
  port: 80, 
  path: null, 
  method: 'GET' 
}; 
var request = http.request(options); <br/>request.on('response', response =&gt; {<br/>  ...<br/>});</pre>
<p>The <kbd>options</kbd> object describes the request to make, and the <kbd>callback</kbd> function is called when the response arrives. The <kbd>options</kbd> object is fairly straightforward, with the <kbd>host</kbd>, <kbd>port</kbd>, and <kbd>path</kbd> fields specifying the URL being requested. The <kbd>method</kbd> field must be one of the HTTP verbs (<kbd>GET</kbd>, <kbd>PUT</kbd>, <kbd>POST</kbd>, and so on). You can also provide a <kbd>headers</kbd> array for the headers in the HTTP request. For example, you might need to provide a cookie:</p>
<pre>var options = { 
  headers: { 'Cookie': '.. cookie value' } 
}; </pre>
<p>The <kbd>response</kbd> object is itself an <kbd>EventEmitter</kbd>, which emits the <kbd>data</kbd> and <kbd>error</kbd> events. The <kbd>data</kbd> event is called as data arrives, and the <kbd>error</kbd> event is, of course, called on errors.</p>
<p>The request object is a <kbd>WritableStream</kbd>, which is useful for HTTP requests containing data, such as <kbd>PUT</kbd> or <kbd>POST</kbd>. This means the <kbd>request</kbd> object has a <kbd>write</kbd> function that writes data to the requester. The data format in an HTTP request is specified by the standard <strong>Multipurpose Internet Mail Extensions</strong> (<span><strong>MIME</strong>)</span> originally created to give us better email. Around 1992, the WWW community worked with the MIME standard committee which was developing a format for multi-part, multi-media-rich electronic mail. Receiving fancy-looking email is so commonplace today that one might not be aware that email used to be plain text. MIME-types were developed to describe the format of each piece of data, and the WWW community adopted this for use on the web. HTML forms will post with a Content-Type of <kbd>multipart/form-data</kbd>, for example.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Calling a REST backend service from an Express application</h1>
                </header>
            
            <article>
                
<p>Now that we've seen how to make HTTP client requests, we can look at how to make a REST query inside an Express web application. What that effectively means is to make an HTTP <kbd>GET</kbd> request to a backend server, which responds with the Fibonacci number represented by the URL. To do so, we'll refactor the <kbd>Fibonacci</kbd> application to make a Fibonacci server that is called from the application. While this is overkill for calculating Fibonacci numbers, it lets us look at the basics of implementing a multitier application stack in Express.</p>
<p>Inherently, calling a REST service is an asynchronous operation. That means calling the REST service will involve a function call to initiate the request and a callback function to receive the response. REST services are accessed over HTTP, so we'll use the HTTP client object to do so.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementing a simple REST server with Express</h1>
                </header>
            
            <article>
                
<p>While Express has a powerful templating system, making it suitable for delivering HTML web pages to browsers, it can also be used to implement a simple REST service. The parameterized URLs we showed earlier (<kbd>/user/profile/:id</kbd>) can act like parameters to a REST call. And Express makes it easy to return data encoded in JSON.</p>
<p>Now, create a file named <kbd>fiboserver.js</kbd> containing this code:</p>
<pre>const math  = require('./math'); 
const express = require('express'); 
const logger = require('morgan'); 
const app = express(); 
app.use(logger('dev')); 
app.get('/fibonacci/:n', (req, res, next) =&gt; { 
    math.fibonacciAsync(Math.floor(req.params.n), (err, val) =&gt; { 
        if (err) next('FIBO SERVER ERROR ' + err); 
        else res.send({ n: req.params.n, result: val });
    }); 
}); 
app.listen(process.env.SERVERPORT); </pre>
<p>This is a stripped-down Express application that gets right to the point of providing a Fibonacci calculation service. The one route it supports handles the Fibonacci computation using the same functions we've already worked with.</p>
<p>This is the first time we've seen <kbd>res.send</kbd> used. It's a flexible way to send responses which can take an array of header values (for the HTTP response header), and an HTTP status code. As used here, it automatically detects the object, formats it as JSON text, and sends it with the correct <kbd>Content-Type</kbd>.</p>
<p>In <kbd>package.json</kbd>, add this to the <kbd>scripts</kbd> section:</p>
<pre>"server": "SERVERPORT=3002 node ./fiboserver" </pre>
<p>This automates launching our Fibonacci service.</p>
<div class="packt_tip"><span>Note that we're specifying the TCP/IP port via an environment variable and using that variable in the application. This is another aspect of the Twelve-Factor application model: to put configuration data in the environment.</span></div>
<p>Now, let's run it:</p>
<pre><strong>$ npm run server</strong><br/><strong>&gt; fibonacci@0.0.0 server /Users/David/chap04/fibonacci</strong><br/><strong>&gt; SERVERPORT=3002 node ./fiboserver</strong> </pre>
<p>Then, in a separate command window, we can use the <kbd>curl</kbd> program to make some requests against this service:</p>
<pre><strong>$ curl -f http://localhost:3002/fibonacci/10
{"n":"10","result":55}
$ curl -f http://localhost:3002/fibonacci/11
{"n":"11","result":89}
$ curl -f http://localhost:3002/fibonacci/12
{"n":"12","result":144} </strong> </pre>
<p>Over in the window where the service is running, we'll see a log of <kbd>GET</kbd> requests and how long each took to process:</p>
<pre><strong>$ npm run server</strong><br/><br/><strong>&gt; fibonacci@0.0.0 server /Users/David/chap04/fibonacci</strong><br/><strong>&gt; SERVERPORT=3002 node ./fiboserver </strong><br/><br/><strong>GET /fibonacci/10 200 0.393 ms - 22</strong><br/><strong>GET /fibonacci/11 200 0.647 ms - 22</strong><br/><strong>GET /fibonacci/12 200 0.772 ms - 23</strong></pre>
<p>Now, let's create a simple client program, <kbd>fiboclient.js</kbd>, to programmatically call the Fibonacci service:</p>
<pre>const http = require('http');<br/>[<br/>  "/fibonacci/30", "/fibonacci/20", "/fibonacci/10",<br/>  "/fibonacci/9", "/fibonacci/8", "/fibonacci/7",<br/>  "/fibonacci/6", "/fibonacci/5", "/fibonacci/4",<br/>  "/fibonacci/3", "/fibonacci/2", "/fibonacci/1"<br/>].forEach(path =&gt; {<br/>    console.log(`${new Date().toISOString()} requesting ${path}`);<br/>    var req = http.request({<br/>      host: "localhost",<br/>      port: process.env.SERVERPORT,<br/>      path: path,<br/>      method: 'GET'<br/>    }, res =&gt; {<br/>      res.on('data', chunk =&gt; {<br/>          console.log(`${new Date().toISOString()} BODY: ${chunk}`);<br/>      });<br/>    });<br/>    req.end();<br/>});</pre>
<p>Then, in <kbd>package.json</kbd>, add this to the <kbd>scripts</kbd> section:</p>
<pre>"scripts": {<br/>  "start": "node ./bin/www",<br/>  "server": "SERVERPORT=3002 node ./fiboserver" ,<br/>  "client": "SERVERPORT=3002 node ./fiboclient" <br/>}</pre>
<p>Then run the <em>client</em> app:</p>
<pre><strong>$ npm run client</strong><br/><br/><strong>&gt; fibonacci@0.0.0 client /Users/David/chap04/fibonacci</strong><br/><strong>&gt; SERVERPORT=3002 node ./fiboclient</strong><br/><br/><strong>2017-12-11T00:41:14.857Z requesting /fibonacci/30</strong><br/><strong>2017-12-11T00:41:14.864Z requesting /fibonacci/20</strong><br/><strong>2017-12-11T00:41:14.865Z requesting /fibonacci/10</strong><br/><strong>2017-12-11T00:41:14.865Z requesting /fibonacci/9</strong><br/><strong>2017-12-11T00:41:14.866Z requesting /fibonacci/8</strong><br/><strong>2017-12-11T00:41:14.866Z requesting /fibonacci/7</strong><br/><strong>2017-12-11T00:41:14.866Z requesting /fibonacci/6</strong><br/><strong>2017-12-11T00:41:14.866Z requesting /fibonacci/5</strong><br/><strong>2017-12-11T00:41:14.866Z requesting /fibonacci/4</strong><br/><strong>2017-12-11T00:41:14.866Z requesting /fibonacci/3</strong><br/><strong>2017-12-11T00:41:14.867Z requesting /fibonacci/2</strong><br/><strong>2017-12-11T00:41:14.867Z requesting /fibonacci/1</strong><br/><strong>2017-12-11T00:41:14.884Z BODY: {"n":"9","result":34}</strong><br/><strong>2017-12-11T00:41:14.886Z BODY: {"n":"10","result":55}</strong><br/><strong>2017-12-11T00:41:14.891Z BODY: {"n":"6","result":8}</strong><br/><strong>2017-12-11T00:41:14.892Z BODY: {"n":"7","result":13}</strong><br/><strong>2017-12-11T00:41:14.893Z BODY: {"n":"8","result":21}</strong><br/><strong>2017-12-11T00:41:14.903Z BODY: {"n":"3","result":2}</strong><br/><strong>2017-12-11T00:41:14.904Z BODY: {"n":"4","result":3}</strong><br/><strong>2017-12-11T00:41:14.905Z BODY: {"n":"5","result":5}</strong><br/><strong>2017-12-11T00:41:14.910Z BODY: {"n":"2","result":1}</strong><br/><strong>2017-12-11T00:41:14.911Z BODY: {"n":"1","result":1}</strong><br/><strong>2017-12-11T00:41:14.940Z BODY: {"n":"20","result":6765}</strong><br/><strong>2017-12-11T00:41:18.200Z BODY: {"n":"30","result":832040}</strong></pre>
<p>We're building our way toward adding the REST service to the web application. At this point, we've proved several things, one of which is the ability to call a REST service in our program.</p>
<p>We also inadvertently demonstrated an issue with long-running calculations. You'll notice the requests were made from the largest to the smallest, but the results appeared in a very different order. Why? It's because of the processing time for each request, and the inefficient algorithm we're using. The computation time increases enough to ensure that the larger request values require enough processing time to reverse the order.</p>
<p>What happens is that <kbd>fiboclient.js</kbd> sends all its requests right away, and then each one waits for the response to arrive. Because the server is using <kbd>fibonacciAsync</kbd>, it will work on calculating all responses simultaneously. The values that are quickest to calculate are the ones that will be ready first. As the responses arrive in the client, the matching response handler fires, and in this case, the result prints to the console. The results will arrive when they're ready and not a millisecond sooner.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Refactoring the Fibonacci application for REST</h1>
                </header>
            
            <article>
                
<p>Now that we've implemented a REST-based server, we can return to the <kbd>Fibonacci</kbd> application, applying what we've learned to improve it. We will lift some of the code from <kbd>fiboclient.js</kbd> and transplant it into the application to do this. Create a new file, <kbd>routes/fibonacci-rest.js</kbd>, with the following code:</p>
<pre>const express = require('express');<br/>const router = express.Router();<br/>const http = require('http');<br/>const math = require('../math');<br/><br/>router.get('/', function(req, res, next) {<br/>  if (req.query.fibonum) {<br/>    var httpreq = http.request({ <br/>      host: "localhost", <br/>      port: process.env.SERVERPORT, <br/>      path: "/fibonacci/"+Math.floor(req.query.fibonum), <br/>      method: 'GET' <br/>    });<br/>    httpreq.on('response', response =&gt; {<br/>      response.on('data', chunk =&gt; { <br/>        var data = JSON.parse(chunk); <br/>        res.render('fibonacci', { <br/>          title: "Calculate Fibonacci numbers", <br/>          fibonum: req.query.fibonum, <br/>          fiboval: data.result <br/>        }); <br/>      }); <br/>      response.on('error', err =&gt; { next(err); }); <br/>    });<br/>    httpreq.on('error', err =&gt; { next(err); }); <br/>    httpreq.end(); <br/>  } else {<br/>    res.render('fibonacci', {<br/>      title: "Calculate Fibonacci numbers",<br/>      fiboval: undefined<br/>    });<br/>  }<br/>});<br/><br/>module.exports = router;</pre>
<p>In <kbd>app.js</kbd>, make this change:</p>
<pre><span>const</span><span> </span><span>index</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>'./routes/index'</span><span>);<br/></span><span>// const fibonacci = require('./routes/fibonacci');<br/></span><span>// const fibonacci = require('./routes/fibonacci-async1');<br/></span><span>// const fibonacci = require('./routes/fibonacci-await');<br/></span><span>const</span><span> </span><span>fibonacci</span><span> </span><span>=</span><span> </span><span>require</span><span>(</span><span>'./routes/fibonacci-rest'</span><span>);</span></pre>
<p>Then, in <kbd>package.json</kbd>, change the <kbd>scripts</kbd> entry to the following:</p>
<pre>"scripts": {<br/>  "start": "DEBUG=fibonacci:* node ./bin/www",<br/>  "startrest": "DEBUG=fibonacci:* SERVERPORT=3002 node ./bin/www",<br/>  "server": "DEBUG=fibonacci:* SERVERPORT=3002 node ./fiboserver" ,<br/>  "client": "DEBUG=fibonacci:* SERVERPORT=3002 node ./fiboclient" <br/>},</pre>
<p>How can we have the same value for <kbd>SERVERPORT</kbd> for all three <kbd>scripts</kbd> entries?  The answer is that the variable is used differently in different places. In <kbd>startrest</kbd>, that variable is used in <kbd>routes/fibonacci-rest.js</kbd> to know at which port the REST service is running. Likewise, in <kbd>client</kbd>, <kbd>fiboclient.js</kbd> uses that variable for the same purpose. Finally, in <kbd>server</kbd>, the <kbd>fiboserver.js</kbd> script uses the <kbd>SERVERPORT</kbd> variable to know which port to listen on.</p>
<p>In <kbd>start</kbd> and <kbd>startrest</kbd>, no value is given for <kbd>PORT</kbd>. In both cases, <kbd>bin/www</kbd> defaults to <kbd>PORT=3000</kbd> if it is not specified.</p>
<p>In one command window, start the backend server, and in the other, start the application. Open a browser window as before, and make a few requests. You should see output similar to this:</p>
<pre><strong>$ npm run server</strong><br/><br/><strong>&gt; fibonacci@0.0.0 server /Users/David/chap04/fibonacci</strong><br/><strong>&gt; DEBUG=fibonacci:* SERVERPORT=3002 node ./fiboserver</strong><br/><br/><strong>GET /fibonacci/34 200 21124.036 ms - 27</strong><br/><strong>GET /fibonacci/12 200 1.578 ms - 23</strong><br/><strong>GET /fibonacci/16 200 6.600 ms - 23</strong><br/><strong>GET /fibonacci/20 200 33.980 ms - 24</strong><br/><strong>GET /fibonacci/28 200 1257.514 ms - 26</strong></pre>
<p>The output like this for the application:</p>
<pre><strong>$ npm run startrest</strong><br/><br/><strong>&gt; fibonacci@0.0.0 startrest /Users/David/chap04/fibonacci</strong><br/><strong>&gt; DEBUG=fibonacci:* SERVERPORT=3002 node ./bin/www</strong><br/><br/><strong>  fibonacci:server Listening on port 3000 +0ms</strong><br/><strong>GET /fibonacci?fibonum=34 200 21317.792 ms - 548</strong><br/><strong>GET /stylesheets/style.css 304 20.952 ms - -</strong><br/><strong>GET /fibonacci?fibonum=12 304 109.516 ms - -</strong><br/><strong>GET /stylesheets/style.css 304 0.465 ms - -</strong><br/><strong>GET /fibonacci?fibonum=16 200 83.067 ms - 544</strong><br/><strong>GET /stylesheets/style.css 304 0.900 ms - -</strong><br/><strong>GET /fibonacci?fibonum=20 200 221.842 ms - 545</strong><br/><strong>GET /stylesheets/style.css 304 0.778 ms - -</strong><br/><strong>GET /fibonacci?fibonum=28 200 1428.292 ms - 547</strong><br/><strong>GET /stylesheets/style.css 304 19.083 ms - -</strong><br/><br/></pre>
<p>Because we haven't changed the templates, the screen will look exactly as it did earlier.</p>
<p>We may run into another problem with this solution. The asynchronous implementation of our inefficient Fibonacci algorithm may cause the Fibonacci service process to run out of memory. In the Node.js FAQ, <a href="https://github.com/nodejs/node/wiki/FAQ"><span class="URLPACKT">https://github.com/nodejs/node/wiki/FAQ</span></a>, it's suggested to use the <kbd>--max_old_space_size</kbd> flag. You'd add this in <kbd>package.json</kbd> as follows:</p>
<pre>"server": "SERVERPORT=3002 node ./fiboserver --max_old_space_size 5000",</pre>
<p>However, the FAQ also says that if you're running into maximum memory space problems, your application should probably be refactored. This gets back to our point several pages ago that there are several approaches to addressing performance problems, one of which is the algorithmic refactoring of your application.</p>
<p>Why go to the trouble of developing this REST server when we could just directly use <kbd>fibonacciAsync</kbd>?</p>
<p>We can now push the CPU load for this heavyweight calculation to a separate server. Doing so would preserve CPU capacity on the frontend server so it can attend to web browsers. GPU co-processors are now widely used for numerical computing and can be accessed via a simple network API. The heavy computation can be kept separate, and you can even deploy a cluster of backend servers sitting behind a load balancer, evenly distributing requests.</p>
<p>What we've demonstrated is that it's possible to implement simple multitier REST services in a few lines of Node.js and Express.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Some RESTful modules and frameworks</h1>
                </header>
            
            <article>
                
<p>Here are a few available packages and frameworks to assist your REST-based projects:</p>
<ul>
<li>Restify (<a href="http://restify.com/">&gt;<span class="URLPACKT">http://restify.com/</span></a>): This offers both client-side and server-side frameworks for both ends of REST transactions. The server-side API is similar to Express.</li>
<li>Loopback (<a href="http://loopback.io/">http://loopback.io/</a>): This is an offering from StrongLoop, the current sponsor of the Express project. It offers a lot of features and is, of course, built on top of Express.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>You learned a lot in this chapter about Node's HTTP support, implementing web applications, and REST service implementation.</p>
<p>Now we can move on to implementing a more complete application: one for taking notes. We will use the Notes application for several upcoming chapters as a vehicle to explore the Express application framework, database access, deployment to cloud services or on your own server, and user authentication.</p>
<p>In the next chapter, we will build the basic infrastructure.</p>


            </article>

            
        </section>
    </div>



  </body></html>