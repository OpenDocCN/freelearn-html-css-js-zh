- en: Chapter 2. Your First Bot
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 你的第一个机器人
- en: 'Readers will be amazed at how few lines of code are required to get a basic
    bot up and running in their Slack environment. This chapter will walk the reader
    through the basics of building a Slack bot:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 读者将会对在他们的Slack环境中仅需要少量代码行就能启动一个基本的机器人感到惊讶。本章将引导读者了解构建Slack机器人的基础知识：
- en: Preparing your environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备你的环境
- en: Creating a Slack API token
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Slack API令牌
- en: Connecting your bot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接你的机器人
- en: Joining a channel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加入频道
- en: Sending a message to a channel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向频道发送消息
- en: Basic responses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本响应
- en: Sending a direct message
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送直接消息
- en: Restricting access
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制访问
- en: Debugging your bot
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试你的机器人
- en: Although some of the concepts first outlined will be known to a more advanced
    reader, it is still recommended to read through the first few sections of this
    chapter to ensure that your environment is up and ready to go.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一些概念可能对更高级的读者来说已知，但仍然建议阅读本章的前几节，以确保你的环境已经准备好并可以运行。
- en: 'In this chapter, we will build a bot that performs the following actions:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个执行以下操作的机器人：
- en: Connects to your Slack team
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到你的Slack团队
- en: Says hello to all the members of a channel after successfully connecting, distinguishing
    between real users and bot users
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在成功连接后向频道的所有成员打招呼，区分真实用户和机器人用户
- en: Responds to users saying hello
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对说“你好”的用户做出回应
- en: Sends a direct message to users who ask for the total amount of time the bot
    has been running (also known as uptime)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向询问机器人总运行时间（也称为运行时间）的用户发送直接消息
- en: Ensures that only administrative users can request the bot's uptime
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保只有管理员用户可以请求机器人的运行时间
- en: Preparing your environment
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备你的环境
- en: Before we can get started with the first bot, the programming environment must
    be set up and configured to run Node.js applications and packages. Let's start
    at the very beginning with Node.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写第一个机器人之前，编程环境必须设置并配置为运行Node.js应用程序和包。让我们从Node.js开始。
- en: In brief, Node.js (also referred to as Node) is a JavaScript runtime built on
    Chrome's v8 JavaScript Engine. In practice, this means that JavaScript can be
    run outside of the usual browser environment, making JavaScript both a frontend
    and backend language.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Node.js（也称为Node）是建立在Chrome的v8 JavaScript引擎之上的JavaScript运行时环境。在实践中，这意味着JavaScript可以在常规浏览器环境之外运行，使JavaScript成为一种既可用于前端也可用于后端的语言。
- en: Google Chrome's v8 JavaScript engine ensures that your JavaScript code runs
    fast and efficiently. Unlike in the world of browsers (and excepting Node versions),
    Node is maintained by a single open source foundation with hundreds of volunteer
    developers. This makes developing for Node much simpler than for browsers as you
    will not run into problems with varying JavaScript implementations across platforms.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Google Chrome的v8 JavaScript引擎确保你的JavaScript代码运行得既快又高效。与浏览器世界（以及Node版本）不同，Node由一个单一的开源基金会维护，拥有数百名志愿者开发者。这使得为Node开发比浏览器简单得多，因为你不会遇到跨平台JavaScript实现不一致的问题。
- en: In this book, we will be using major Version 5 (any version starting with 5)
    of Node. This allows us to use the newly implemented features of ECMAScript 2015
    (better known as **ES2015** or **ES6**). Whenever an ES6 feature is used in this
    book for the first time, look for the accompanying code comment for a brief explanation
    on the feature.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用主要版本5（任何以5开头的版本）的Node。这使我们能够使用新实施的ECMAScript 2015（更广为人知为**ES2015**或**ES6**）的新特性。每当本书首次使用ES6特性时，请查找相应的代码注释以获得该特性的简要说明。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Although many are implemented, not all ES6 features are currently available
    in Node and some are only available in **strict** mode. For more information,
    please visit the Node ES6 guide: [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多特性已经实现，但并非所有ES6特性目前都在Node中可用，其中一些仅在**严格**模式下可用。有关更多信息，请访问Node ES6指南：[https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/)。
- en: This section will briefly explain how to install Node.js and the Slack API on
    your development machine.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要说明如何在开发机器上安装Node.js和Slack API。
- en: Installing Node.js
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Node.js
- en: To install Node.js, head to the official Node website, [https://nodejs.org/](https://nodejs.org/),
    download a v5 version and follow the onscreen instructions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Node.js，请访问官方Node网站，[https://nodejs.org/](https://nodejs.org/)，下载一个v5版本并遵循屏幕上的说明。
- en: 'To test whether the installation succeeded, open up a terminal, type the following,
    and then hit *Enter*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试安装是否成功，打开终端，输入以下内容，然后按*Enter*：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If node installed correctly, you should be able to type JavaScript commands
    and see the result:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点安装正确，你应该能够输入 JavaScript 命令并看到结果：
- en: '![Installing Node.js](img/B05384_02_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![安装 Node.js](img/B05384_02_01.jpg)'
- en: Hello World in Node.js
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 中的 Hello World
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Hit *Ctrl* + *C* twice to exit Node.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 两次退出 Node。
- en: Installing the development tools using NPM
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NPM 安装开发工具
- en: '**Node Package Manager** (**NPM**) is Node.js'' package ecosystem and the tool
    used to install Node packages. As of the time of writing, there are more than
    240,000 NPM packages available for download, with more being added every day.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Node 包管理器** (**NPM**) 是 Node.js 的包生态系统，也是用于安装 Node 包的工具。截至写作时，有超过 240,000
    个 NPM 包可供下载，并且每天都有更多被添加。'
- en: 'Fortunately, NPM is automatically installed once the Node installation is complete.
    Let''s start by installing a useful Node development tool called `nodemon` ([http://nodemon.io/](http://nodemon.io/)).
    Run the following in your terminal or command prompt:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，一旦 Node 安装完成，NPM 就会自动安装。让我们首先安装一个有用的 Node 开发工具，名为 `nodemon` ([http://nodemon.io/](http://nodemon.io/))。在你的终端或命令提示符中运行以下命令：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will install the `nodemon` package globally (note the `-g` flag),
    meaning it can be run from any location on your computer. After the `install`
    command, you must specify the package you wish to install and can optionally select
    some flags that configure how the package is installed. Later on, we'll explore
    flags such as `--save` and `--save-dev` and their uses.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将全局安装 `nodemon` 包（注意 `-g` 标志），这意味着它可以从电脑上的任何位置运行。在 `install` 命令之后，你必须指定你希望安装的包，并且可以选择一些配置包安装方式的标志。稍后，我们将探讨
    `--save` 和 `--save-dev` 标志及其用法。
- en: '`nodemon` is a Node utility that will monitor any changes in your code and
    automatically restart your Node process. For our purposes, this will save us from
    having to stop the Node process and restart it every time we make a change to
    our code.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodemon` 是一个 Node 工具，它将监视你的代码中的任何更改，并自动重新启动你的 Node 进程。对我们来说，这将使我们不必每次更改代码时都停止并重新启动
    Node 进程。'
- en: 'To demonstrate `nodemon`, let''s look at an example. In your code editor of
    choice, paste the following and save it as `hello-world.js`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `nodemon`，让我们看一个例子。在你的代码编辑器中粘贴以下内容，并将其保存为 `hello-world.js`：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In your terminal, run the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中运行以下命令：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Your output should look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应该看起来像这样：
- en: '![Installing the development tools using NPM](img/B05384_02_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![使用 NPM 安装开发工具](img/B05384_02_02.jpg)'
- en: The same Hello World as before but using nodemon
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前相同的 Hello World，但使用 nodemon
- en: Note how the console command ran and then the program exited. `nodemon` then
    enters "watch mode", where it will wait for any files (indicated by the `*.*`
    wildcard) to change and then subsequently restart the Node process. `nodemon`
    can be further customized to watch or ignore specific files. Visit the website
    [http://nodemon.io/](http://nodemon.io/) for more information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意控制台命令的运行方式以及程序如何退出。`nodemon` 然后进入“监视模式”，在此模式下，它将等待任何文件（由 `*.*` 通配符表示）的更改，然后随后重新启动
    Node 进程。`nodemon` 可以进一步自定义以监视或忽略特定文件。有关更多信息，请访问网站 [http://nodemon.io/](http://nodemon.io/)。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To manually restart the Node process without changing a file that `nodemon`
    watches, type *rs* followed by the *Enter* key.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不更改 `nodemon` 监视的文件的情况下手动重新启动 Node 进程，请输入 *rs* 然后按 *Enter* 键。
- en: Creating a new project
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的项目
- en: Now that the basics of Node and NPM are covered, we will look at creating a
    new Node project and expanding our knowledge of NPM.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经了解了 Node 和 NPM 的基础知识，我们将探讨创建一个新的 Node 项目并扩展我们对 NPM 的了解。
- en: A Node project can contain dependencies and development dependencies. The former
    are segments of code (or packages) that are required to run the project whereas
    the latter are segments of code used solely for development. In our previous example,
    `nodemon` would be considered a development dependency, as it would not be used
    in a production environment.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Node 项目可以包含依赖项和开发依赖项。前者是运行项目所需的代码段（或包），而后者是仅用于开发的代码段。在我们的上一个例子中，`nodemon`
    被视为开发依赖项，因为它不会在生产环境中使用。
- en: The dependencies of a Node project are stored in a **JavaScript Object Notation**
    (**JSON**) file named `package.json`. The JSON file contains information about
    the Node project, including a list of dependencies, the versions of the dependencies,
    and information about the package author(s). This allows easy installation of
    a project via NPM.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Node项目的依赖项存储在一个名为`package.json`的**JavaScript对象表示法**（**JSON**）文件中。该JSON文件包含有关Node项目的信息，包括依赖项列表、依赖项的版本以及包作者的信息。这使得通过NPM轻松安装项目成为可能。
- en: 'Let''s create one of our own. Open up a terminal window and create a new folder
    by typing in the following and hitting *Enter*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个自己的。打开一个终端窗口，通过输入以下内容并按*Enter*键来创建一个新的文件夹：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This creates a new directory and navigates to said directory. Next, enter the
    following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的目录并导航到该目录。接下来，输入以下内容：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Follow the onscreen prompts and you will end up with something like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的提示操作，您最终会得到类似以下内容：
- en: '![Creating a new project](img/B05384_02_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![创建新项目](img/B05384_02_03.jpg)'
- en: Example of NPM init running successfully
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: NPM init 运行成功的示例
- en: Once completed, you'll find that a `package.json` file has been created in your
    directory; see the preceding screenshot for an example of what that JSON file
    contains.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，您会发现您的目录中已创建了一个`package.json`文件；请参阅前面的截图以了解该JSON文件包含的内容。
- en: 'Now that we''ve created a template for our app, let''s create an entry point
    JavaScript file and install some dependencies:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的应用程序创建了一个模板，让我们创建一个入口点JavaScript文件并安装一些依赖项：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: These commands create an empty JavaScript file named `index` and install the
    Slack **Real Time Messaging** (**RTM**) client. Note how `@slack/client` now appears
    under dependencies in `package.json`. This is due to the `--save` flag used in
    the last command. The save flag indicates that this NPM package is required to
    run this app.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令创建了一个名为`index`的空JavaScript文件并安装了Slack**实时消息传递**（**RTM**）客户端。注意`@slack/client`现在出现在`package.json`的依赖项下。这是由于在最后一个命令中使用了`--save`标志。保存标志表示此NPM包是运行此应用程序所必需的。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of Version 2, the Slack client API has moved to using NPM organizations.
    Indicated by the `@` character in the package name, this means that Slack (the
    company) can publish packages under the umbrella organization of `@slack`. Other
    than the additional character, the package does not differ from other, non-organization
    packages.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本2起，Slack客户端API已迁移到使用NPM组织。通过包名中的`@`字符表示，这意味着Slack（公司）可以在`@slack`的母组织下发布包。除了额外的字符外，该包与其他非组织包没有区别。
- en: Should you wish to distribute your bot and allow others to work on or with it,
    you can easily install all required packages as dictated in `package.json` by
    running `npm install` in the project's directory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望分发您的机器人并允许其他人对其进行或与之工作，您可以通过在项目目录中运行`npm install`来轻松安装`package.json`中指定的所有必需的包。
- en: Alternatively to the save flag, you can specify that a package is only required
    for development by using the `--save-dev` flag. This will add the package to the
    `devDependencies` section in `package.json`. This allows us to specify that this
    package only needs to be installed if the user intends to do some development.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 除了保存标志之外，您还可以通过使用`--save-dev`标志来指定一个包仅用于开发。这将把该包添加到`package.json`中的`devDependencies`部分。这允许我们指定，如果用户打算进行一些开发，则此包才需要安装。
- en: This is particularly useful for servers running your code, where you would want
    to omit development packages altogether.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于运行您代码的服务器特别有用，您可能希望完全省略开发包。
- en: 'Your `package.json` file should now look something like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`package.json`文件现在可能看起来像这样：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that the Slack client is listed as a dependency, it will be automatically
    installed when the following command is run from within this directory:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Slack客户端被列为依赖项，当从这个目录运行以下命令时，它将被自动安装：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can test this by deleting the `node_modules` folder and then running the
    preceding command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过删除`node_modules`文件夹然后运行前面的命令来测试这一点：
- en: '![Creating a new project](img/B05384_02_03a.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![创建新项目](img/B05384_02_03a.jpg)'
- en: All our dependencies are installed
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有依赖项都已安装
- en: Note how the `slack-client` package has its own dependencies, which were automatically
    installed into the `node_modules` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`slack-client`包有自己的依赖项，这些依赖项已自动安装到`node_modules`文件夹中。
- en: 'Now, we will add some code to our entry point JavaScript file. Open up `index.js`
    and enter the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向我们的入口点JavaScript文件添加一些代码。打开`index.js`并输入以下代码：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Save the file and run the program by executing the following command:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件并执行以下命令来运行程序：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You should immediately notice that something is wrong:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该立即注意到有问题：
- en: '![Creating a new project](img/B05384_02_03b.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![创建新项目](img/B05384_02_03b.jpg)'
- en: Debug and error logs are shown
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和错误日志显示
- en: Notice how the built-in logger outputs both debug and error messages. The error
    indicates that Slack cannot connect due to an authentication error. This is because
    we have not provided a Slack API token. The access token is a unique ID generated
    for your bot. By using it, you enable your bot to authenticate with Slack's servers
    and interact with the Slack client.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意内置的日志记录器如何输出调试和错误信息。错误表明由于认证错误，Slack 无法连接。这是因为我们没有提供 Slack API 令牌。访问令牌是为您的机器人生成的唯一
    ID。通过使用它，您使您的机器人能够通过 Slack 服务器进行认证并与 Slack 客户端交互。
- en: In our example, the token is set to an empty string, which will not work. Let's
    then retrieve an access token from Slack.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，令牌被设置为空字符串，这是不起作用的。那么，让我们从 Slack 获取一个访问令牌。
- en: Tip
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Detailed steps to download the code bundle are mentioned in the *Preface* of
    this book. Please have a look.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的 *前言* 中提到了下载代码包的详细步骤。请查看。
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Building-Slack-Bots](https://github.com/PacktPublishing/Building-Slack-Bots).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing](https://github.com/PacktPublishing). Check
    them out!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码包也托管在 GitHub 上，网址为 [https://github.com/PacktPublishing/Building-Slack-Bots](https://github.com/PacktPublishing/Building-Slack-Bots)。我们还有其他来自我们丰富图书和视频目录的代码包，可在
    [https://github.com/PacktPublishing](https://github.com/PacktPublishing) 获取。查看它们！
- en: Creating a Slack API token
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Slack API 令牌
- en: Open up a browser and navigate to [https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并导航到 [https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration)。
- en: 'Follow these steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Select **Bots** from the list of available custom integrations.![Creating a
    Slack API token](img/B05384_02_04.jpg)
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从可用的自定义集成列表中选择 **Bots**。![创建 Slack API 令牌](img/B05384_02_04.jpg)
- en: Custom integrations list
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自定义集成列表
- en: Select a name and click on **Add Bot Integration**. The name of your bot can
    be changed later, so don't worry about picking a well thought-out name immediately.![Creating
    a Slack API token](img/B05384_02_05.jpg)
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个名称并点击 **添加机器人集成**。您的机器人名称可以在以后更改，所以不必担心立即选择一个经过深思熟虑的名称。![创建 Slack API 令牌](img/B05384_02_05.jpg)
- en: Adding a bot integration
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加机器人集成
- en: Copy down the newly generated API token. As an optional step, you can choose
    to customize the bot further in this screen.![Creating a Slack API token](img/B05384_02_06.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制下新生成的 API 令牌。作为一个可选步骤，您可以选择在此屏幕上进一步自定义机器人。![创建 Slack API 令牌](img/B05384_02_06.jpg)
- en: Optional settings for your bot
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 机器人可选设置
- en: Note
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although optional, it is recommended to choose an icon for your bot. For this
    example, we will use the `robot_face` emoji; however, a good bot should have an
    icon that represents the purpose of the bot.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然是可选的，但建议为您的机器人选择一个图标。在这个例子中，我们将使用 `robot_face` 表情符号；然而，一个好的机器人应该有一个代表其目的的图标。
- en: Although you can give bots duplicate first and last names, the bot's username
    must be unique to your team. Providing a first name, last name, and description
    is optional but advisable as it provides information at a glance on what your
    bot does.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然您可以给机器人提供重复的首字母和姓氏，但机器人的用户名必须对您的团队是唯一的。提供首字母、姓氏和描述是可选的，但建议这样做，因为它可以提供有关机器人做什么的快速信息。
- en: Click on **Save** **Integration** at the bottom of the page.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面底部的 **保存** **集成**。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you wish to remove or disable this bot at a later stage, you can do that
    from this same page.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望在以后阶段删除或禁用此机器人，您可以从同一页面进行操作。
- en: Connecting a bot
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接机器人
- en: Now that we've generated an API token, replace the empty string assigned to
    `token` in `index.js` and run the program again.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经生成了一个 API 令牌，请将 `index.js` 中分配给 `token` 的空字符串替换，然后再次运行程序。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Now is a good time to use `nodemon` rather than `node` to ensure automatic restarts
    when code is changed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是使用 `nodemon` 而不是 `node` 的好时机，以确保代码更改时自动重启。
- en: You will probably see a whole page of debug information show up. While useful,
    this can also hinder our progress as our own console logs might be difficult to
    spot. Instead of playing hide and seek, let's first change our logging settings
    in the client.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在终端中看到一整页的调试信息。虽然这些信息很有用，但它们也可能阻碍我们的进度，因为我们的控制台日志可能难以找到。与其玩捉迷藏，不如首先更改客户端的日志设置。
- en: 'Switch this line:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将此行切换：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use the following line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下行：
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will instruct the client to only output error messages when the program
    crashes or a syntax error occurs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示客户端仅在程序崩溃或发生语法错误时输出错误消息。
- en: 'Restart the program (or just save the file and let `nodemon` do the work):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动程序（或者只保存文件，让 `nodemon` 做工作）：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you see something similar to the preceding output in your terminal, congratulations!
    Your first bot is successfully connected to Slack! You will now see your bot in
    the **Direct Messages** section of your Slack client; click on the bot's name
    to open a private direct message.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在终端中看到类似前面的输出，恭喜！您的第一个机器人已成功连接到 Slack！现在您将在 Slack 客户端的 **直接消息** 部分看到您的机器人；点击机器人的名字以打开一个私人的直接消息。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout this book, you will encounter the title `Building Bots`. This is
    simply the title of the Slack team the author used and will be different from
    your own.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，您将遇到标题 `Building Bots`。这仅仅是作者使用的 Slack 团队的名称，并且可能与您的不一样。
- en: '![Connecting a bot](img/B05384_02_08.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![连接机器人](img/B05384_02_08.jpg)'
- en: A direct message (DM) with your bot
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 向您的机器人发送直接消息（DM）
- en: Your bot is alive and well. However, it is fairly limited in its abilities.
    We will remedy that shortly, but first let's ensure that the bot can interact
    with a wider audience.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您的机器人正在正常运行。然而，它的能力相当有限。我们将很快解决这个问题，但首先让我们确保机器人可以与更广泛的受众互动。
- en: Joining a channel
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加入一个频道
- en: Bots cannot join channels programmatically; this is a design choice as bots
    should not be allowed to enter private channels without being invited. When a
    bot joins a channel, all the channel's activity can be monitored by the bot. A
    bot could potentially save all channel messages, a potentially nefarious activity
    that shouldn't be allowed to happen automatically.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人不能通过编程方式加入频道；这是一个设计选择，因为机器人不应该在没有被邀请的情况下进入私人频道。当机器人加入频道时，机器人可以监控频道中的所有活动。机器人可能保存所有频道消息，这是一种潜在的恶意活动，不应该自动发生。
- en: For a complete list of what actions bots can and cannot perform, see the Slack
    bot user documentation at [https://api.slack.com/bot-users](https://api.slack.com/bot-users).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有关机器人可以和不能执行的操作的完整列表，请参阅 Slack 机器人用户文档，网址为 [https://api.slack.com/bot-users](https://api.slack.com/bot-users)。
- en: 'Bots are restricted in the actions they can perform themselves. As such, bots
    need to be invited to channels via the `invite` command within the Slack client:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人对其自身可以执行的操作有限制。因此，机器人需要通过 Slack 客户端中的 `invite` 命令被邀请到频道中：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After this, you''ll get confirmation of the bot entering the channel like this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您将收到机器人进入频道的确认，如下所示：
- en: '![Joining a channel](img/B05384_02_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![加入频道](img/B05384_02_09.jpg)'
- en: The bot enters the world
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人进入世界
- en: Note that when a bot joins a channel, it remains there even if the bot's Node
    process is stopped. It shows the same characteristics as an offline user. This
    ensures that invitation needs only to happen once per bot and per channel.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当机器人加入频道时，即使机器人的 Node 进程停止，它也会留在那里。它表现出与离线用户相同的特征。这确保了每个机器人每个频道只需要进行一次邀请。
- en: 'To remove a bot from a channel, use the remove command within the Slack client:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要从频道中移除机器人，请在 Slack 客户端中使用移除命令：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although all users can invite into a channel, only admins can actively remove
    users and bots from channels.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然所有用户都可以邀请进入频道，但只有管理员可以主动从频道中移除用户和机器人。
- en: To make testing easier and to not disrupt other users in your team, it is a
    good idea to create a bot testing channel and invite your bot. For the purposes
    of this book, the testing channel is named `bot-test`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试更容易，并且不干扰您团队中的其他用户，创建一个机器人测试频道并邀请您的机器人是一个好主意。在本书的范围内，测试频道被命名为 `bot-test`。
- en: Sending a message to a channel
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向频道发送消息
- en: We now have a connected bot, but it admittedly is a rather useless one. Let's
    remedy that by getting our bot to say "Hello" to every channel that it resides
    in.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个已连接的机器人，但诚然，它相当无用了。让我们通过让我们的机器人向它所在的每个频道说“你好”来解决这个问题。
- en: The slack object
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Slack 对象
- en: 'You might have noticed the following on line 18 in the preceding code example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在前面的代码示例的第 18 行有如下内容：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we see that the `slack` object contains a myriad of information about
    the bot''s current environment. Let''s explore the data contained within. Replace
    line 18 with this modified `console.log` method:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到 `slack` 对象包含了关于机器人当前环境的各种信息。让我们探索其中包含的数据。将第 18 行替换为以下修改后的 `console.log`
    方法：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see a large object printed out in your terminal. While we won''t
    go through all the values, here are some of interest:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端中看到一个大型对象被打印出来。虽然我们不会遍历所有值，但以下是一些有趣的值：
- en: '| Name | Type | Function |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 类型 | 功能 |'
- en: '| --- | --- | --- |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `activeUserId` | String | The internal user ID. This can be used to get more
    information about the current user. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `activeUserId` | 字符串 | 内部用户 ID。这可以用来获取更多关于当前用户的信息。|'
- en: '| `activeUserId` | String | The internal team ID. Again, it can be used to
    get more information about the team. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `activeUserId` | 字符串 | 内部团队 ID。同样，它可以用来获取更多关于团队的信息。|'
- en: '| `dataStore` | Object | If a data store is initialized, this object contains
    a myriad of information stored within the Slack API. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `dataStore` | 对象 | 如果初始化了数据存储，则此对象包含 Slack API 中存储的大量信息。|'
- en: '| `channels` (child of `dataStore`) | Object | Contains a list of all the channels
    available in this team. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `channels`（`dataStore` 的子对象）| 对象 | 包含该团队中所有可用频道的列表。|'
- en: '| `channel` (child of channels) | Object | Contains further info on the channel.
    Whether the user requesting this information is a member or not is available through
    the `is_member` property |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `channel`（`channels` 的子对象）| 对象 | 包含关于频道的更多信息。是否请求此信息的用户是成员可以通过 `is_member`
    属性来获取 |'
- en: '| `dms` (child of `dataStore`) | Object | A list of all the direct message
    channels this user is a part of. Note: even if no messages were ever sent the
    direct message channel is still considered open. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `dms`（`dataStore` 的子对象）| 对象 | 该用户是其中一员的直接消息频道的列表。注意：即使从未发送过消息，直接消息频道仍然被认为是开放的。|'
- en: '| `users` (child of `dataStore`) | Object | A list of all users in this team.
    |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `users`（`dataStore` 的子对象）| 对象 | 该团队中所有用户的列表。|'
- en: Getting all the channels
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取所有频道
- en: 'You''ll note from the preceding table that the `channels` object returns all
    the channels in this team. For our purposes, we only want the channels in which
    our bot resides. To achieve this, we can loop through the `channels` object and
    return exactly what we need. Add the following to the end of `index.js`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，从前面的表格中，`channels` 对象返回了该团队中的所有频道。就我们的目的而言，我们只想获取我们的机器人所在的频道。为了实现这一点，我们可以遍历
    `channels` 对象，并返回我们确切需要的。将以下内容添加到 `index.js` 的末尾：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, replace the Slack `open` event listener with this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 Slack `open` 事件监听器替换为以下内容：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Switch to your terminal and you should see the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到您的终端，您应该看到以下输出：
- en: '![Getting all the channels](img/B05384_02_10.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![获取所有频道](img/B05384_02_10.jpg)'
- en: Listing the channels the bot resides in
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列出机器人所在的频道
- en: Now that your bot knows which channels it's in, it can start to send messages.
    We'll start with the bot sending a simple "Hello" message to everyone in the channel.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的机器人知道它所在的频道，它就可以开始发送消息了。我们将从机器人向频道中的每个人发送一个简单的 "Hello" 消息开始。
- en: Getting all members in a channel
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取频道中的所有成员
- en: 'We have the channel object, so getting the members within is easy. Add this
    to the `RTM_CONNECTION_OPENED` event listener:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了频道对象，因此获取其中的成员很容易。将其添加到 `RTM_CONNECTION_OPENED` 事件监听器中：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the result:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是结果：
- en: '![Getting all members in a channel](img/B05384_02_11.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![获取频道中的所有成员](img/B05384_02_11.jpg)'
- en: A list of user IDs
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 用户 ID 列表
- en: 'Well that wasn''t quite what we expected, perhaps. The Slack API has returned
    a list of user IDs rather than an array of member objects. This makes sense as
    a large channel containing several hundred users would result in an unwieldy and
    large array of member objects. Not to worry, the Slack API provides us with the
    tools we need to get more information by using these user IDs. Replace the previous
    snippet with this and then save the file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这并不完全符合我们的预期。Slack API 返回了一个用户 ID 列表，而不是成员对象的数组。这对于包含数百个用户的频道来说是有意义的，因为这会导致一个庞大且庞大的成员对象数组。不用担心，Slack
    API 提供了我们需要的工具，通过使用这些用户 ID 来获取更多信息。用以下代码替换之前的片段，然后保存文件：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output for this code can be seen in the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出可以在以下屏幕截图中看到：
- en: '![Getting all members in a channel](img/B05384_02_12.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![获取频道中的所有成员](img/B05384_02_12.jpg)'
- en: The users of the channel using their usernames
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户名在该频道中的用户
- en: Notice how the bot is also listed in the channel members list. Our current goal
    is to say hello to everyone in the channel; however, we should try to avoid having
    the bot talking to itself.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意机器人也被列在频道成员列表中。我们当前的目标是向频道中的每个人打招呼；然而，我们应该尽量避免机器人自言自语。
- en: 'We can use the `is_bot` property on the `member` object to determine whether
    a user is a bot:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `member` 对象上的 `is_bot` 属性来确定用户是否是机器人：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Getting all members in a channel](img/B05384_02_13.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![获取频道中所有成员](img/B05384_02_13.jpg)'
- en: The users of the channel, without bots
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 频道中的用户，不包括机器人
- en: Wonderful! Now that we are done with this, the next step is to send a message
    to the channel.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们已经完成了这个步骤，下一步是将消息发送到频道。
- en: Sending a message to a channel
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向频道发送消息
- en: 'The channel object contains all the tools required for bot communication. In
    the following code, we will build upon the previous code snippets and send a "Hello"
    message addressing each person in the channel once the bot connects. All of these
    actions will happen in the open event listener. Here it is in its entirety:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 频道对象包含机器人通信所需的所有工具。在下面的代码中，我们将基于之前的代码片段，在机器人连接后向频道中的每个人发送一条“Hello”消息。所有这些操作都将发生在公开的事件监听器中。以下是它的全部内容：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As soon as you run the code, you should be greeted by a notification from the
    Slack client that you have been mentioned in a message, as shown in the following
    screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行了代码，你应该会收到 Slack 客户端的提示通知，显示你被提及在一条消息中，如下面的截图所示：
- en: '![Sending a message to a channel](img/B05384_02_14.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![向频道发送消息](img/B05384_02_14.jpg)'
- en: Our bot speaks its first words
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的机器人说出了它的第一句话
- en: Let's ramp up our bot's complexity by giving it the ability to respond to messages.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过让机器人能够响应消息来提高它的复杂性。
- en: Basic responses
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本响应
- en: The Slack API can be configured to execute methods once certain events are dispatched,
    as seen earlier with the `RTM_CONNECTION_OPENED` event. Now, we will dive into
    other useful events provided to us.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Slack API 可以配置为在派发某些事件时执行方法，就像之前用 `RTM_CONNECTION_OPENED` 事件所看到的那样。现在，我们将深入了解我们提供的其他有用的事件。
- en: The authenticated event
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证事件
- en: 'So far, we have seen how to add functionality to Slack''s `RTM_CONNECTION_OPENED`
    event triggered by the bot entering a channel and an error occurring, respectively.
    If you wish to execute some code when a bot logs in but before it connects to
    a channel, you can use the `AUTHENTICATED` event:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何为机器人进入频道并发生错误时触发的 Slack 的 `RTM_CONNECTION_OPENED` 事件添加功能。如果你希望在机器人登录但尚未连接到频道之前执行一些代码，你可以使用
    `AUTHENTICATED` 事件：
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This gives the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we will introduce the *message* event.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍 *消息* 事件。
- en: Using the message event
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用消息事件
- en: The message event will trigger every time a message is sent to a channel the
    bot is in or in a direct message to the bot. The message object contains useful
    data such as the originating user, the originating channel, and the timestamp
    it was sent.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 消息事件将在每次向机器人所在的频道或直接向机器人发送消息时触发。消息对象包含有用的数据，例如发送用户、发送频道和发送时间戳。
- en: 'Paste the following into `index.js` and then send the message "Hello bot!"
    to a channel that your bot is a member of:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容粘贴到 `index.js` 中，然后向你的机器人是成员的频道发送消息“Hello bot!”：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This should result in something like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生类似以下的结果：
- en: '![Using the message event](img/B05384_02_15.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![使用消息事件](img/B05384_02_15.jpg)'
- en: A more personal greeting from the bot
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人更个性化的问候
- en: 'Let''s look at the code again in detail, starting from the top:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次详细查看代码，从顶部开始：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This should be familiar, as it''s similar to what we''ve used before, except
    we''re now using the `MESSAGE` event from the `RTM_EVENTS` object. We also make
    sure the message sender isn''t a bot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该很熟悉，因为它与我们之前使用的类似，只是我们现在使用的是 `RTM_EVENTS` 对象中的 `MESSAGE` 事件。我们还确保消息发送者不是机器人：
- en: '[PRE28]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `getChannelGroupOrDMById` method lets us grab the channel for every message
    sent. This is particularly useful if our bot happens to inhabit multiple channels.
    The code is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`getChannelGroupOrDMById` 方法让我们能够获取每个消息发送的频道。如果我们的机器人恰好居住在多个频道中，这尤其有用。代码如下：'
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A message does not necessarily contain text; it is also possible that the message
    is a file, an image, or even an emoji. Therefore, we have to do a little type
    checking to make sure the message received is indeed text based. Once the text
    type is confirmed, we use a regular expression to test whether the message received
    contains certain keywords in a specific order. The `RegExp.test` method will return
    true when the message received contains the words "Hello" or "Hi" followed by
    either "bot" or "awesomebot." If true, a response is sent back to the channel
    using the familiar `slack.sendMessage` method.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 消息不一定包含文本；它也可能是文件、图片或甚至表情符号。因此，我们必须进行一些类型检查，以确保接收到的消息确实是基于文本的。一旦确认文本类型，我们使用正则表达式来测试接收到的消息是否包含特定顺序的关键词。当接收到的消息包含“Hello”或“Hi”后跟“bot”或“awesomebot”时，`RegExp.test`
    方法将返回 true。如果是真的，将使用熟悉的 `slack.sendMessage` 方法将响应发送回通道。
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When evaluating incoming text, it is almost always a good idea to first convert
    the body of the text message to lowercase in order to avoid case sensitive errors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估传入的文本时，几乎总是先将文本消息的主体转换为小写，以避免大小写敏感的错误。
- en: Avoiding spam
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免垃圾邮件
- en: 'Infinite loops happen occasionally when developing; it is entirely possible
    that you accidentally program a bot to send a message in an infinite loop, flooding
    the channel with spam. Observe the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中偶尔会发生无限循环；完全有可能不小心编写了一个机器人，使其在无限循环中发送消息，从而在通道中产生垃圾邮件。观察以下代码：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Take a look at the screenshot of the result:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 查看结果的截图：
- en: '![Avoiding spam](img/B05384_02_16.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![避免垃圾邮件](img/B05384_02_16.jpg)'
- en: A bot spamming the channel
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人正在垃圾邮件通道
- en: 'In the terminal or command prompt, you should see this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端或命令提示符中，你应该看到以下内容：
- en: '![Avoiding spam](img/B05384_02_17.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![避免垃圾邮件](img/B05384_02_17.jpg)'
- en: The Slack API deals with the spam
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Slack API 处理垃圾邮件
- en: Luckily, the Slack API has a built in guard against such unfortunate events.
    If 20 messages are sent by a single user in a very short time frame, the Slack
    server will refuse to post more messages and return an error. This has the added
    effect of causing our bot to get stuck and eventually crash.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Slack API 内置了对这类不幸事件的防护。如果单个用户在非常短的时间内发送了 20 条消息，Slack 服务器将拒绝发布更多消息并返回错误。这还有一个附加效果，就是导致我们的机器人卡住并最终崩溃。
- en: The Slack platform will guard against spam attacks flooding the channel; however,
    it is likely that the offending bot will crash.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Slack 平台将保护通道免受垃圾邮件攻击；然而，可能被攻击的机器人会崩溃。
- en: To prevent this from happening, it is highly advisable to *never* place a `slack.sendMessage`
    method call within a loop or within a `setInterval` method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，强烈建议*永远不要*在循环或 `setInterval` 方法中放置 `slack.sendMessage` 方法调用。
- en: 'Channels with many users and thus high volume could potentially lead to accidentally
    triggering the "slow down" response from the Slack platform. To prevent this,
    keep track of the time difference between messages:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 用户众多且因此流量大的通道可能会意外触发 Slack 平台的“减速”响应。为了防止这种情况，跟踪消息之间的时间差：
- en: '[PRE31]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![Avoiding spam](img/B05384_02_18.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![避免垃圾邮件](img/B05384_02_18.jpg)'
- en: Limiting the bot's messages
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 限制机器人的消息
- en: Every time the `setInterval` function is called, we generate a new timestamp
    called `currentTime`. By comparing `currentTime` to the timestamp of the message
    (defined as `sentTime`), we can artificially limit the messages being sent on
    the bot side by making sure the difference between the two is more than 1,000
    milliseconds in length.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `setInterval` 函数时，我们都会生成一个新的时间戳，称为 `currentTime`。通过比较 `currentTime` 与消息的时间戳（定义为
    `sentTime`），我们可以通过确保两者之间的差异超过 1,000 毫秒来人工限制机器人端发送的消息。
- en: The Slack API provides a timestamp on the channel object accessible via `channel.latest.ts`;
    this provides a timestamp for the latest message received in the channel. While
    still useful, it is recommended to use local timestamps instead, as the Slack
    API provides information on the latest message received rather than the latest
    message sent by the bot.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Slack API 在 `channel.latest.ts` 对象上提供了一个时间戳；这提供了通道中接收到的最新消息的时间戳。虽然仍然有用，但建议使用本地时间戳，因为
    Slack API 提供的是接收到的最新消息的信息，而不是机器人发送的最新消息。
- en: Sending a direct message
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送直接消息
- en: A **direct** **message** (**DM**) channel is a channel that only operates between
    two users. By design, it cannot have more or less than two users and is meant
    for private communication. Sending a DM is remarkably similar to sending a message
    to a channel, as the `dm` object is almost identical to the `channel` object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '**直接** **消息** (**DM**) 频道是仅存在于两个用户之间的频道。按照设计，它不能有更多或更少的用户，并且旨在进行私人通信。发送私信与向频道发送消息非常相似，因为
    `dm` 对象几乎与 `channel` 对象相同。'
- en: 'Consider the following snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this example, our bot will send a DM with the current uptime to any user
    who uses the key phrase `uptime`:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们的机器人将向任何使用关键词 `uptime` 的用户发送包含当前 Uptime 的私信：
- en: '![Sending a direct message](img/B05384_02_19.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![发送私信](img/B05384_02_19.jpg)'
- en: Uptime can be a very useful statistic
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Uptime 可以是一个非常有用的统计数据
- en: Note that the bot will send a DM to the user, regardless of which channel the
    command `uptime` is sent as long as the bot is around to hear the command as a
    member of that channel or DM. In the preceding image, the command was issued in
    the DM itself. This is because both channels and DMs subscribe to the `message`
    event; it is important to remember this when sending responses meant for channels
    rather than DMs and vice versa.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，无论命令 `uptime` 是在哪个频道发送，只要机器人作为该频道或 DM 的成员能够听到该命令，它都会向用户发送私信。在上面的图像中，命令是在
    DM 中发出的。这是因为频道和 DM 都订阅了 `message` 事件；当发送针对频道而非 DM 的响应，反之亦然时，这一点非常重要。
- en: Restricting access
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制访问
- en: Occasionally, you might wish to restrict bot commands to administrators of your
    Slack team. A good example is a bot that controls a project's deploy process.
    This can be immensely powerful but perhaps not something that you want every user
    to have access to. Only administrators (also known as admins) should have the
    authority to access such functions. Admins are special users who have administrative
    powers over the Slack team. Luckily, restricting such access is easy with the
    `is_admin` property attached to a user object.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望将机器人命令限制为您的 Slack 团队管理员。一个很好的例子是控制项目部署过程的机器人。这可以非常强大，但可能不是您希望每个用户都能访问的功能。只有管理员（也称为管理员）才有权访问此类功能。管理员是拥有
    Slack 团队管理权限的特殊用户。幸运的是，通过用户对象附加的 `is_admin` 属性，限制此类访问很容易。
- en: 'In the following example, we''ll restrict the `uptime` command demonstrated
    in the previous topic to admin users, notifying the restricted user that they
    can''t use that command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将限制在前一个主题中演示的 `uptime` 命令，使其仅对管理员用户有效，并通知受限用户他们无法使用该命令：
- en: '[PRE33]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now when non-admin users issue the `uptime` command, they will get the following
    message:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当非管理员用户发出 `uptime` 命令时，他们将收到以下消息：
- en: '![Restricting access](img/B05384_02_20.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![限制访问](img/B05384_02_20.jpg)'
- en: Restricting the bot to admin users
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 限制机器人只对管理员用户
- en: Note
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of `user.is_admin` is to determine whether a user is an admin or not.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `user.is_admin` 是为了确定用户是否是管理员。
- en: Adding and removing admins
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和删除管理员
- en: To add or remove admins to your team, visit [https://my.slack.com/admin#active](https://my.slack.com/admin#active)
    and click on a user.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加或删除管理员到您的团队，请访问 [https://my.slack.com/admin#active](https://my.slack.com/admin#active)
    并点击一个用户。
- en: Admins and owners have the ability to kick other members from channels and to
    delete messages that aren't their own. Although these are the default settings,
    they can be edited at [https://my.slack.com/admin/settings#channel_management_restrictions](https://my.slack.com/admin/settings#channel_management_restrictions).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员和所有者有权将其他成员从频道中踢出，并删除不属于他们的消息。尽管这些是默认设置，但可以在 [https://my.slack.com/admin/settings#channel_management_restrictions](https://my.slack.com/admin/settings#channel_management_restrictions)
    编辑。
- en: Bots cannot be admins or owners; for more information on team permissions, visit
    [https://get.slack.help/hc/en-us/articles/201314026-Understanding-r](https://get.slack.help/hc/en-us/articles/201314026-Understanding-r).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人不能是管理员或所有者；有关团队权限的更多信息，请访问 [https://get.slack.help/hc/en-us/articles/201314026-Understanding-r](https://get.slack.help/hc/en-us/articles/201314026-Understanding-r)。
- en: Debugging a bot
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试机器人
- en: It is inevitable that eventually you will encounter a bug in your bot that is
    difficult to squash. The worst are bugs that don't cause your program to crash
    and thus don't provide a useful stack trace and line number for where the crash
    happened. For most issues, the `console.log()` method will be enough to help you
    track down the bug, for the more tenacious bugs however we will need a true debugging
    environment. This section will introduce you to `iron-node` ([https://s-a.github.io/iron-node/](https://s-a.github.io/iron-node/)),
    a cross-platform JavaScript debugging environment based on Chrome's dev tools.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最终您可能会遇到难以解决的机器人中的错误。最糟糕的是那些不会导致程序崩溃的错误，因此不会提供有关崩溃发生位置的有用的堆栈跟踪和行号。对于大多数问题，`console.log()`
    方法就足够帮助您追踪错误，但对于更顽固的错误，我们需要一个真正的调试环境。本节将向您介绍 `iron-node` ([https://s-a.github.io/iron-node/](https://s-a.github.io/iron-node/))，这是一个基于
    Chrome 开发工具的跨平台 JavaScript 调试环境。
- en: 'Start by installing `iron-node`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '首先安装 `iron-node`:'
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note again the use of the `-g` flag, which installs the application globally.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意 `-g` 标志的使用，它将应用程序全局安装。
- en: 'Before we can start debugging, we need to add a breakpoint to our code, which
    tells the debugger to stop the code and allow for deeper inspection. Add the `debugger`
    statement to our previous code, within the `slack.openDM()` code block:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始调试之前，我们需要在我们的代码中添加一个断点，这将告诉调试器停止代码并允许进行更深入的检查。将 `debugger` 语句添加到我们之前的代码中的
    `slack.openDM()` 代码块内：
- en: '[PRE35]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Save the file and then run the code via `iron-node` in your terminal:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件，然后在终端通过 `iron-node` 运行代码：
- en: '[PRE36]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Immediately, you should see the `iron-node` interface pop up:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，您应该会看到 `iron-node` 界面弹出：
- en: '![Debugging a bot](img/B05384_02_21.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![调试机器人](img/B05384_02_21.jpg)'
- en: The iron-node interface
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: iron-node 界面
- en: Chrome users will perhaps notice that this interface is exactly like Chrome's
    developer tools window. It is advisable to spend some time familiarizing yourself
    with this interface if you haven't used it before. Let's discuss some basic functionality
    to get you started.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome 用户可能会注意到这个界面与 Chrome 的开发者工具窗口完全一样。如果您以前没有使用过它，建议花些时间熟悉这个界面。让我们讨论一些基本功能，以便您开始。
- en: You can switch to the console tab to see the node output, or you can also hit
    *Esc* to show the console at the bottom of the screen.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以切换到控制台标签以查看节点输出，或者也可以按 *Esc* 显示屏幕底部的控制台。
- en: Our debugger was placed within a message event listener, so send a command to
    the bot (`uptime` in the last example) and watch what happens next.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的调试器被放置在消息事件监听器中，因此向机器人发送命令（在最后一个例子中是 `uptime`）并观察接下来会发生什么。
- en: '![Debugging a bot](img/B05384_02_22.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![调试机器人](img/B05384_02_22.jpg)'
- en: Setting a breakpoint with the "debugger" statement
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 "debugger" 语句设置断点
- en: The bot's execution has been paused by the debugger, so you can inspect properties
    and determine the source of the bug.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人的执行已被调试器暂停，因此您可以检查属性并确定错误的来源。
- en: Either click on the **Step** **over** button in the top-right corner, symbolized
    by an arrow curving around a dot, or hit *F10* to step over to the next line.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要么点击右上角的 **Step over** 按钮，其符号为一个围绕点的弯曲箭头，要么按 *F10* 跳到下一行。
- en: Use your mouse to hover over the different objects in this line of code to retrieve
    more information about them.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用鼠标悬停在代码这一行中的不同对象上以获取有关它们更多信息。
- en: '![Debugging a bot](img/B05384_02_23.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![调试机器人](img/B05384_02_23.jpg)'
- en: Inspecting a property in the paused program
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 检查暂停程序中的属性
- en: Keep clicking on the **Step over** button to progress through the code, or click
    on the **Resume script execution** button to the left of the **Step over** button
    to allow the program to continue until it encounters another debugger breakpoint.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 持续点击 **Step over** 按钮以逐步通过代码，或者点击 **Step over** 按钮左侧的 **Resume script execution**
    按钮以允许程序继续执行，直到遇到另一个调试器断点。
- en: 'Not only can you inspect variables and properties while the bot is executing,
    but you can also edit their values, causing different outputs. Observe how we
    can edit the uptime variable in our code and set it to 1000:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以在机器人执行时检查变量和属性，还可以编辑它们的值，产生不同的输出。观察我们如何编辑代码中的 uptime 变量并将其设置为 1000：
- en: '![Debugging a bot](img/B05384_02_24.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![调试机器人](img/B05384_02_24.jpg)'
- en: '`uptime` is set by the program to 40.064'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`uptime` 被程序设置为 40.064'
- en: 'In the console area, we can edit JavaScript variables whilst the program is
    running:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台区域，我们可以在程序运行时编辑 JavaScript 变量：
- en: '![Debugging a bot](img/B05384_02_25.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![调试机器人](img/B05384_02_25.jpg)'
- en: 'In the console, we check the value of uptime again, and then set it to a value
    of 1000\. Now when we look back at the variables, we should see the updated values:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台，我们再次检查了运行时间的值，并将其设置为1000。现在当我们回顾变量时，我们应该看到更新的值：
- en: '![Debugging a bot](img/B05384_02_26.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![调试机器人](img/B05384_02_26.jpg)'
- en: The new value of uptime is reflected in the next few lines
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 新的运行时间值反映在接下来的几行中
- en: 'When we resume the program, our bot will send its message based on our updated
    variables:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们恢复程序时，我们的机器人将根据我们更新的变量发送其消息：
- en: '![Debugging a bot](img/B05384_02_27.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![调试机器人](img/B05384_02_27.jpg)'
- en: We continue the program and the bot sends the new values to the channel.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续程序，机器人将新的值发送到频道。
- en: Note
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For best debugging practices, either disable your bot's ability to send messages
    or invite your bot to a private channel to avoid spamming other users.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最佳调试实践，要么禁用机器人发送消息的能力，要么邀请你的机器人加入一个私人频道，以避免向其他用户发送垃圾邮件。
- en: As `iron-node` is based on Chrome's developer tools, you can use the previous
    techniques interchangeably with Chrome.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`iron-node`基于Chrome的开发者工具，你可以与Chrome互换使用之前的技术。
- en: 'To debug and fix memory issues, you can use the developer tools'' profiler
    and heap snapshot tool. For more information on these topics, please visit the
    following links:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试和修复内存问题，你可以使用开发者工具的性能分析器和堆快照工具。有关这些主题的更多信息，请访问以下链接：
- en: '[https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution](https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution](https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution)'
- en: '[https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en](https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en](https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en)'
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw how to install the prerequisite technologies, how to
    obtain a Slack token for a bot, and how to set up a new Slack bot project. As
    a result, you can reuse the lessons learned to easily scaffold a new bot project.
    You should now be able to program a bot that can send messages to channels, direct
    messages as well as craft basic responses. Finally, we discussed how to debug
    a Node.js-based bot using the `iron-node` debugger.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了如何安装先决技术，如何为机器人获取Slack令牌，以及如何设置一个新的Slack机器人项目。因此，你可以重用所学知识，轻松构建新的机器人项目。你现在应该能够编写一个可以向频道发送消息、发送直接消息以及编写基本响应的机器人。最后，我们讨论了如何使用`iron-node`调试器调试基于Node.js的机器人。
- en: In the next chapter, we will see how to make our bot more complex by adding
    third-party API support and by programming our first bot command.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何通过添加第三方API支持和编写我们的第一个机器人命令来使我们的机器人更加复杂。
