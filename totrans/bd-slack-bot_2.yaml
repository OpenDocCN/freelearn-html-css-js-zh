- en: Chapter 2. Your First Bot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Readers will be amazed at how few lines of code are required to get a basic
    bot up and running in their Slack environment. This chapter will walk the reader
    through the basics of building a Slack bot:'
  prefs: []
  type: TYPE_NORMAL
- en: Preparing your environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Slack API token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting your bot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joining a channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a message to a channel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic responses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending a direct message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your bot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although some of the concepts first outlined will be known to a more advanced
    reader, it is still recommended to read through the first few sections of this
    chapter to ensure that your environment is up and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will build a bot that performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Connects to your Slack team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Says hello to all the members of a channel after successfully connecting, distinguishing
    between real users and bot users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responds to users saying hello
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sends a direct message to users who ask for the total amount of time the bot
    has been running (also known as uptime)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensures that only administrative users can request the bot's uptime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing your environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can get started with the first bot, the programming environment must
    be set up and configured to run Node.js applications and packages. Let's start
    at the very beginning with Node.
  prefs: []
  type: TYPE_NORMAL
- en: In brief, Node.js (also referred to as Node) is a JavaScript runtime built on
    Chrome's v8 JavaScript Engine. In practice, this means that JavaScript can be
    run outside of the usual browser environment, making JavaScript both a frontend
    and backend language.
  prefs: []
  type: TYPE_NORMAL
- en: Google Chrome's v8 JavaScript engine ensures that your JavaScript code runs
    fast and efficiently. Unlike in the world of browsers (and excepting Node versions),
    Node is maintained by a single open source foundation with hundreds of volunteer
    developers. This makes developing for Node much simpler than for browsers as you
    will not run into problems with varying JavaScript implementations across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we will be using major Version 5 (any version starting with 5)
    of Node. This allows us to use the newly implemented features of ECMAScript 2015
    (better known as **ES2015** or **ES6**). Whenever an ES6 feature is used in this
    book for the first time, look for the accompanying code comment for a brief explanation
    on the feature.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although many are implemented, not all ES6 features are currently available
    in Node and some are only available in **strict** mode. For more information,
    please visit the Node ES6 guide: [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/).'
  prefs: []
  type: TYPE_NORMAL
- en: This section will briefly explain how to install Node.js and the Slack API on
    your development machine.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install Node.js, head to the official Node website, [https://nodejs.org/](https://nodejs.org/),
    download a v5 version and follow the onscreen instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the installation succeeded, open up a terminal, type the following,
    and then hit *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If node installed correctly, you should be able to type JavaScript commands
    and see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Node.js](img/B05384_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hello World in Node.js
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *C* twice to exit Node.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the development tools using NPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Node Package Manager** (**NPM**) is Node.js'' package ecosystem and the tool
    used to install Node packages. As of the time of writing, there are more than
    240,000 NPM packages available for download, with more being added every day.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, NPM is automatically installed once the Node installation is complete.
    Let''s start by installing a useful Node development tool called `nodemon` ([http://nodemon.io/](http://nodemon.io/)).
    Run the following in your terminal or command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command will install the `nodemon` package globally (note the `-g` flag),
    meaning it can be run from any location on your computer. After the `install`
    command, you must specify the package you wish to install and can optionally select
    some flags that configure how the package is installed. Later on, we'll explore
    flags such as `--save` and `--save-dev` and their uses.
  prefs: []
  type: TYPE_NORMAL
- en: '`nodemon` is a Node utility that will monitor any changes in your code and
    automatically restart your Node process. For our purposes, this will save us from
    having to stop the Node process and restart it every time we make a change to
    our code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate `nodemon`, let''s look at an example. In your code editor of
    choice, paste the following and save it as `hello-world.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In your terminal, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Your output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing the development tools using NPM](img/B05384_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The same Hello World as before but using nodemon
  prefs: []
  type: TYPE_NORMAL
- en: Note how the console command ran and then the program exited. `nodemon` then
    enters "watch mode", where it will wait for any files (indicated by the `*.*`
    wildcard) to change and then subsequently restart the Node process. `nodemon`
    can be further customized to watch or ignore specific files. Visit the website
    [http://nodemon.io/](http://nodemon.io/) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To manually restart the Node process without changing a file that `nodemon`
    watches, type *rs* followed by the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the basics of Node and NPM are covered, we will look at creating a
    new Node project and expanding our knowledge of NPM.
  prefs: []
  type: TYPE_NORMAL
- en: A Node project can contain dependencies and development dependencies. The former
    are segments of code (or packages) that are required to run the project whereas
    the latter are segments of code used solely for development. In our previous example,
    `nodemon` would be considered a development dependency, as it would not be used
    in a production environment.
  prefs: []
  type: TYPE_NORMAL
- en: The dependencies of a Node project are stored in a **JavaScript Object Notation**
    (**JSON**) file named `package.json`. The JSON file contains information about
    the Node project, including a list of dependencies, the versions of the dependencies,
    and information about the package author(s). This allows easy installation of
    a project via NPM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create one of our own. Open up a terminal window and create a new folder
    by typing in the following and hitting *Enter*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a new directory and navigates to said directory. Next, enter the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow the onscreen prompts and you will end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new project](img/B05384_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Example of NPM init running successfully
  prefs: []
  type: TYPE_NORMAL
- en: Once completed, you'll find that a `package.json` file has been created in your
    directory; see the preceding screenshot for an example of what that JSON file
    contains.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created a template for our app, let''s create an entry point
    JavaScript file and install some dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These commands create an empty JavaScript file named `index` and install the
    Slack **Real Time Messaging** (**RTM**) client. Note how `@slack/client` now appears
    under dependencies in `package.json`. This is due to the `--save` flag used in
    the last command. The save flag indicates that this NPM package is required to
    run this app.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of Version 2, the Slack client API has moved to using NPM organizations.
    Indicated by the `@` character in the package name, this means that Slack (the
    company) can publish packages under the umbrella organization of `@slack`. Other
    than the additional character, the package does not differ from other, non-organization
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Should you wish to distribute your bot and allow others to work on or with it,
    you can easily install all required packages as dictated in `package.json` by
    running `npm install` in the project's directory.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively to the save flag, you can specify that a package is only required
    for development by using the `--save-dev` flag. This will add the package to the
    `devDependencies` section in `package.json`. This allows us to specify that this
    package only needs to be installed if the user intends to do some development.
  prefs: []
  type: TYPE_NORMAL
- en: This is particularly useful for servers running your code, where you would want
    to omit development packages altogether.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `package.json` file should now look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the Slack client is listed as a dependency, it will be automatically
    installed when the following command is run from within this directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test this by deleting the `node_modules` folder and then running the
    preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new project](img/B05384_02_03a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All our dependencies are installed
  prefs: []
  type: TYPE_NORMAL
- en: Note how the `slack-client` package has its own dependencies, which were automatically
    installed into the `node_modules` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will add some code to our entry point JavaScript file. Open up `index.js`
    and enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and run the program by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should immediately notice that something is wrong:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a new project](img/B05384_02_03b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debug and error logs are shown
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the built-in logger outputs both debug and error messages. The error
    indicates that Slack cannot connect due to an authentication error. This is because
    we have not provided a Slack API token. The access token is a unique ID generated
    for your bot. By using it, you enable your bot to authenticate with Slack's servers
    and interact with the Slack client.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the token is set to an empty string, which will not work. Let's
    then retrieve an access token from Slack.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Detailed steps to download the code bundle are mentioned in the *Preface* of
    this book. Please have a look.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for the book is also hosted on GitHub at [https://github.com/PacktPublishing/Building-Slack-Bots](https://github.com/PacktPublishing/Building-Slack-Bots).
    We also have other code bundles from our rich catalog of books and videos available
    at [https://github.com/PacktPublishing](https://github.com/PacktPublishing). Check
    them out!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Slack API token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Open up a browser and navigate to [https://my.slack.com/apps/build/custom-integration](https://my.slack.com/apps/build/custom-integration).
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Bots** from the list of available custom integrations.![Creating a
    Slack API token](img/B05384_02_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Custom integrations list
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select a name and click on **Add Bot Integration**. The name of your bot can
    be changed later, so don't worry about picking a well thought-out name immediately.![Creating
    a Slack API token](img/B05384_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding a bot integration
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy down the newly generated API token. As an optional step, you can choose
    to customize the bot further in this screen.![Creating a Slack API token](img/B05384_02_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optional settings for your bot
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Although optional, it is recommended to choose an icon for your bot. For this
    example, we will use the `robot_face` emoji; however, a good bot should have an
    icon that represents the purpose of the bot.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Although you can give bots duplicate first and last names, the bot's username
    must be unique to your team. Providing a first name, last name, and description
    is optional but advisable as it provides information at a glance on what your
    bot does.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Save** **Integration** at the bottom of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to remove or disable this bot at a later stage, you can do that
    from this same page.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting a bot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we've generated an API token, replace the empty string assigned to
    `token` in `index.js` and run the program again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now is a good time to use `nodemon` rather than `node` to ensure automatic restarts
    when code is changed.
  prefs: []
  type: TYPE_NORMAL
- en: You will probably see a whole page of debug information show up. While useful,
    this can also hinder our progress as our own console logs might be difficult to
    spot. Instead of playing hide and seek, let's first change our logging settings
    in the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will instruct the client to only output error messages when the program
    crashes or a syntax error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the program (or just save the file and let `nodemon` do the work):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you see something similar to the preceding output in your terminal, congratulations!
    Your first bot is successfully connected to Slack! You will now see your bot in
    the **Direct Messages** section of your Slack client; click on the bot's name
    to open a private direct message.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, you will encounter the title `Building Bots`. This is
    simply the title of the Slack team the author used and will be different from
    your own.
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting a bot](img/B05384_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A direct message (DM) with your bot
  prefs: []
  type: TYPE_NORMAL
- en: Your bot is alive and well. However, it is fairly limited in its abilities.
    We will remedy that shortly, but first let's ensure that the bot can interact
    with a wider audience.
  prefs: []
  type: TYPE_NORMAL
- en: Joining a channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bots cannot join channels programmatically; this is a design choice as bots
    should not be allowed to enter private channels without being invited. When a
    bot joins a channel, all the channel's activity can be monitored by the bot. A
    bot could potentially save all channel messages, a potentially nefarious activity
    that shouldn't be allowed to happen automatically.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of what actions bots can and cannot perform, see the Slack
    bot user documentation at [https://api.slack.com/bot-users](https://api.slack.com/bot-users).
  prefs: []
  type: TYPE_NORMAL
- en: 'Bots are restricted in the actions they can perform themselves. As such, bots
    need to be invited to channels via the `invite` command within the Slack client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, you''ll get confirmation of the bot entering the channel like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Joining a channel](img/B05384_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The bot enters the world
  prefs: []
  type: TYPE_NORMAL
- en: Note that when a bot joins a channel, it remains there even if the bot's Node
    process is stopped. It shows the same characteristics as an offline user. This
    ensures that invitation needs only to happen once per bot and per channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a bot from a channel, use the remove command within the Slack client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although all users can invite into a channel, only admins can actively remove
    users and bots from channels.
  prefs: []
  type: TYPE_NORMAL
- en: To make testing easier and to not disrupt other users in your team, it is a
    good idea to create a bot testing channel and invite your bot. For the purposes
    of this book, the testing channel is named `bot-test`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to a channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have a connected bot, but it admittedly is a rather useless one. Let's
    remedy that by getting our bot to say "Hello" to every channel that it resides
    in.
  prefs: []
  type: TYPE_NORMAL
- en: The slack object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might have noticed the following on line 18 in the preceding code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see that the `slack` object contains a myriad of information about
    the bot''s current environment. Let''s explore the data contained within. Replace
    line 18 with this modified `console.log` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a large object printed out in your terminal. While we won''t
    go through all the values, here are some of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Type | Function |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `activeUserId` | String | The internal user ID. This can be used to get more
    information about the current user. |'
  prefs: []
  type: TYPE_TB
- en: '| `activeUserId` | String | The internal team ID. Again, it can be used to
    get more information about the team. |'
  prefs: []
  type: TYPE_TB
- en: '| `dataStore` | Object | If a data store is initialized, this object contains
    a myriad of information stored within the Slack API. |'
  prefs: []
  type: TYPE_TB
- en: '| `channels` (child of `dataStore`) | Object | Contains a list of all the channels
    available in this team. |'
  prefs: []
  type: TYPE_TB
- en: '| `channel` (child of channels) | Object | Contains further info on the channel.
    Whether the user requesting this information is a member or not is available through
    the `is_member` property |'
  prefs: []
  type: TYPE_TB
- en: '| `dms` (child of `dataStore`) | Object | A list of all the direct message
    channels this user is a part of. Note: even if no messages were ever sent the
    direct message channel is still considered open. |'
  prefs: []
  type: TYPE_TB
- en: '| `users` (child of `dataStore`) | Object | A list of all users in this team.
    |'
  prefs: []
  type: TYPE_TB
- en: Getting all the channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ll note from the preceding table that the `channels` object returns all
    the channels in this team. For our purposes, we only want the channels in which
    our bot resides. To achieve this, we can loop through the `channels` object and
    return exactly what we need. Add the following to the end of `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, replace the Slack `open` event listener with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Switch to your terminal and you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting all the channels](img/B05384_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Listing the channels the bot resides in
  prefs: []
  type: TYPE_NORMAL
- en: Now that your bot knows which channels it's in, it can start to send messages.
    We'll start with the bot sending a simple "Hello" message to everyone in the channel.
  prefs: []
  type: TYPE_NORMAL
- en: Getting all members in a channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have the channel object, so getting the members within is easy. Add this
    to the `RTM_CONNECTION_OPENED` event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting all members in a channel](img/B05384_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A list of user IDs
  prefs: []
  type: TYPE_NORMAL
- en: 'Well that wasn''t quite what we expected, perhaps. The Slack API has returned
    a list of user IDs rather than an array of member objects. This makes sense as
    a large channel containing several hundred users would result in an unwieldy and
    large array of member objects. Not to worry, the Slack API provides us with the
    tools we need to get more information by using these user IDs. Replace the previous
    snippet with this and then save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output for this code can be seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting all members in a channel](img/B05384_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The users of the channel using their usernames
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the bot is also listed in the channel members list. Our current goal
    is to say hello to everyone in the channel; however, we should try to avoid having
    the bot talking to itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `is_bot` property on the `member` object to determine whether
    a user is a bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Getting all members in a channel](img/B05384_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The users of the channel, without bots
  prefs: []
  type: TYPE_NORMAL
- en: Wonderful! Now that we are done with this, the next step is to send a message
    to the channel.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message to a channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The channel object contains all the tools required for bot communication. In
    the following code, we will build upon the previous code snippets and send a "Hello"
    message addressing each person in the channel once the bot connects. All of these
    actions will happen in the open event listener. Here it is in its entirety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you run the code, you should be greeted by a notification from the
    Slack client that you have been mentioned in a message, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending a message to a channel](img/B05384_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our bot speaks its first words
  prefs: []
  type: TYPE_NORMAL
- en: Let's ramp up our bot's complexity by giving it the ability to respond to messages.
  prefs: []
  type: TYPE_NORMAL
- en: Basic responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Slack API can be configured to execute methods once certain events are dispatched,
    as seen earlier with the `RTM_CONNECTION_OPENED` event. Now, we will dive into
    other useful events provided to us.
  prefs: []
  type: TYPE_NORMAL
- en: The authenticated event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have seen how to add functionality to Slack''s `RTM_CONNECTION_OPENED`
    event triggered by the bot entering a channel and an error occurring, respectively.
    If you wish to execute some code when a bot logs in but before it connects to
    a channel, you can use the `AUTHENTICATED` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will introduce the *message* event.
  prefs: []
  type: TYPE_NORMAL
- en: Using the message event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The message event will trigger every time a message is sent to a channel the
    bot is in or in a direct message to the bot. The message object contains useful
    data such as the originating user, the originating channel, and the timestamp
    it was sent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste the following into `index.js` and then send the message "Hello bot!"
    to a channel that your bot is a member of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This should result in something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the message event](img/B05384_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A more personal greeting from the bot
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the code again in detail, starting from the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This should be familiar, as it''s similar to what we''ve used before, except
    we''re now using the `MESSAGE` event from the `RTM_EVENTS` object. We also make
    sure the message sender isn''t a bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getChannelGroupOrDMById` method lets us grab the channel for every message
    sent. This is particularly useful if our bot happens to inhabit multiple channels.
    The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: A message does not necessarily contain text; it is also possible that the message
    is a file, an image, or even an emoji. Therefore, we have to do a little type
    checking to make sure the message received is indeed text based. Once the text
    type is confirmed, we use a regular expression to test whether the message received
    contains certain keywords in a specific order. The `RegExp.test` method will return
    true when the message received contains the words "Hello" or "Hi" followed by
    either "bot" or "awesomebot." If true, a response is sent back to the channel
    using the familiar `slack.sendMessage` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When evaluating incoming text, it is almost always a good idea to first convert
    the body of the text message to lowercase in order to avoid case sensitive errors.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding spam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Infinite loops happen occasionally when developing; it is entirely possible
    that you accidentally program a bot to send a message in an infinite loop, flooding
    the channel with spam. Observe the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the screenshot of the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Avoiding spam](img/B05384_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A bot spamming the channel
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal or command prompt, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Avoiding spam](img/B05384_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Slack API deals with the spam
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Slack API has a built in guard against such unfortunate events.
    If 20 messages are sent by a single user in a very short time frame, the Slack
    server will refuse to post more messages and return an error. This has the added
    effect of causing our bot to get stuck and eventually crash.
  prefs: []
  type: TYPE_NORMAL
- en: The Slack platform will guard against spam attacks flooding the channel; however,
    it is likely that the offending bot will crash.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this from happening, it is highly advisable to *never* place a `slack.sendMessage`
    method call within a loop or within a `setInterval` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Channels with many users and thus high volume could potentially lead to accidentally
    triggering the "slow down" response from the Slack platform. To prevent this,
    keep track of the time difference between messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![Avoiding spam](img/B05384_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Limiting the bot's messages
  prefs: []
  type: TYPE_NORMAL
- en: Every time the `setInterval` function is called, we generate a new timestamp
    called `currentTime`. By comparing `currentTime` to the timestamp of the message
    (defined as `sentTime`), we can artificially limit the messages being sent on
    the bot side by making sure the difference between the two is more than 1,000
    milliseconds in length.
  prefs: []
  type: TYPE_NORMAL
- en: The Slack API provides a timestamp on the channel object accessible via `channel.latest.ts`;
    this provides a timestamp for the latest message received in the channel. While
    still useful, it is recommended to use local timestamps instead, as the Slack
    API provides information on the latest message received rather than the latest
    message sent by the bot.
  prefs: []
  type: TYPE_NORMAL
- en: Sending a direct message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **direct** **message** (**DM**) channel is a channel that only operates between
    two users. By design, it cannot have more or less than two users and is meant
    for private communication. Sending a DM is remarkably similar to sending a message
    to a channel, as the `dm` object is almost identical to the `channel` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, our bot will send a DM with the current uptime to any user
    who uses the key phrase `uptime`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sending a direct message](img/B05384_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Uptime can be a very useful statistic
  prefs: []
  type: TYPE_NORMAL
- en: Note that the bot will send a DM to the user, regardless of which channel the
    command `uptime` is sent as long as the bot is around to hear the command as a
    member of that channel or DM. In the preceding image, the command was issued in
    the DM itself. This is because both channels and DMs subscribe to the `message`
    event; it is important to remember this when sending responses meant for channels
    rather than DMs and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Occasionally, you might wish to restrict bot commands to administrators of your
    Slack team. A good example is a bot that controls a project's deploy process.
    This can be immensely powerful but perhaps not something that you want every user
    to have access to. Only administrators (also known as admins) should have the
    authority to access such functions. Admins are special users who have administrative
    powers over the Slack team. Luckily, restricting such access is easy with the
    `is_admin` property attached to a user object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we''ll restrict the `uptime` command demonstrated
    in the previous topic to admin users, notifying the restricted user that they
    can''t use that command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when non-admin users issue the `uptime` command, they will get the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Restricting access](img/B05384_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Restricting the bot to admin users
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of `user.is_admin` is to determine whether a user is an admin or not.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing admins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To add or remove admins to your team, visit [https://my.slack.com/admin#active](https://my.slack.com/admin#active)
    and click on a user.
  prefs: []
  type: TYPE_NORMAL
- en: Admins and owners have the ability to kick other members from channels and to
    delete messages that aren't their own. Although these are the default settings,
    they can be edited at [https://my.slack.com/admin/settings#channel_management_restrictions](https://my.slack.com/admin/settings#channel_management_restrictions).
  prefs: []
  type: TYPE_NORMAL
- en: Bots cannot be admins or owners; for more information on team permissions, visit
    [https://get.slack.help/hc/en-us/articles/201314026-Understanding-r](https://get.slack.help/hc/en-us/articles/201314026-Understanding-r).
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a bot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is inevitable that eventually you will encounter a bug in your bot that is
    difficult to squash. The worst are bugs that don't cause your program to crash
    and thus don't provide a useful stack trace and line number for where the crash
    happened. For most issues, the `console.log()` method will be enough to help you
    track down the bug, for the more tenacious bugs however we will need a true debugging
    environment. This section will introduce you to `iron-node` ([https://s-a.github.io/iron-node/](https://s-a.github.io/iron-node/)),
    a cross-platform JavaScript debugging environment based on Chrome's dev tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing `iron-node`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note again the use of the `-g` flag, which installs the application globally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can start debugging, we need to add a breakpoint to our code, which
    tells the debugger to stop the code and allow for deeper inspection. Add the `debugger`
    statement to our previous code, within the `slack.openDM()` code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file and then run the code via `iron-node` in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Immediately, you should see the `iron-node` interface pop up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a bot](img/B05384_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The iron-node interface
  prefs: []
  type: TYPE_NORMAL
- en: Chrome users will perhaps notice that this interface is exactly like Chrome's
    developer tools window. It is advisable to spend some time familiarizing yourself
    with this interface if you haven't used it before. Let's discuss some basic functionality
    to get you started.
  prefs: []
  type: TYPE_NORMAL
- en: You can switch to the console tab to see the node output, or you can also hit
    *Esc* to show the console at the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Our debugger was placed within a message event listener, so send a command to
    the bot (`uptime` in the last example) and watch what happens next.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a bot](img/B05384_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting a breakpoint with the "debugger" statement
  prefs: []
  type: TYPE_NORMAL
- en: The bot's execution has been paused by the debugger, so you can inspect properties
    and determine the source of the bug.
  prefs: []
  type: TYPE_NORMAL
- en: Either click on the **Step** **over** button in the top-right corner, symbolized
    by an arrow curving around a dot, or hit *F10* to step over to the next line.
  prefs: []
  type: TYPE_NORMAL
- en: Use your mouse to hover over the different objects in this line of code to retrieve
    more information about them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a bot](img/B05384_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Inspecting a property in the paused program
  prefs: []
  type: TYPE_NORMAL
- en: Keep clicking on the **Step over** button to progress through the code, or click
    on the **Resume script execution** button to the left of the **Step over** button
    to allow the program to continue until it encounters another debugger breakpoint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not only can you inspect variables and properties while the bot is executing,
    but you can also edit their values, causing different outputs. Observe how we
    can edit the uptime variable in our code and set it to 1000:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a bot](img/B05384_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '`uptime` is set by the program to 40.064'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the console area, we can edit JavaScript variables whilst the program is
    running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a bot](img/B05384_02_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the console, we check the value of uptime again, and then set it to a value
    of 1000\. Now when we look back at the variables, we should see the updated values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a bot](img/B05384_02_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The new value of uptime is reflected in the next few lines
  prefs: []
  type: TYPE_NORMAL
- en: 'When we resume the program, our bot will send its message based on our updated
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a bot](img/B05384_02_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We continue the program and the bot sends the new values to the channel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For best debugging practices, either disable your bot's ability to send messages
    or invite your bot to a private channel to avoid spamming other users.
  prefs: []
  type: TYPE_NORMAL
- en: As `iron-node` is based on Chrome's developer tools, you can use the previous
    techniques interchangeably with Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug and fix memory issues, you can use the developer tools'' profiler
    and heap snapshot tool. For more information on these topics, please visit the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution](https://developers.google.com/web/tools/chrome-devtools/profile/rendering-tools/js-execution)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en](https://developers.google.com/web/tools/chrome-devtools/profile/memory-problems/?hl=en)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to install the prerequisite technologies, how to
    obtain a Slack token for a bot, and how to set up a new Slack bot project. As
    a result, you can reuse the lessons learned to easily scaffold a new bot project.
    You should now be able to program a bot that can send messages to channels, direct
    messages as well as craft basic responses. Finally, we discussed how to debug
    a Node.js-based bot using the `iron-node` debugger.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to make our bot more complex by adding
    third-party API support and by programming our first bot command.
  prefs: []
  type: TYPE_NORMAL
