- en: Chapter 3. Using Databases and Managing Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing your database's Ti.Filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DbTableChecker SQLite table existence checking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recursively handling files using Dossier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning your SQLite database for maximum performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access using DbLazyProvider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NoSQL using MongloDb
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Titanium has several components designed to assist in handling your data needs.
    Additionally, the Titanium open source community has provided a wealth of alternative
    data-handling options.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter demonstrate a variety of helpful approaches to work
    with data while on the device. With topics ranging from file-system management
    to SQLite tuning, there will be an approach to assist your Enterprise data needs,
    no matter what your preferred approach is.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing your database's Ti.Filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Titanium includes a powerful database API that provides easy access to the underlying
    platform's SQLite implementation. Having access to `Ti.Filesystem` for your app's
    SQLite database allows you the flexibility to handle updates, migrations, and
    installations more effectively.
  prefs: []
  type: TYPE_NORMAL
- en: The `DbFileExt` module provides easy access to your SQLite `Ti.Filesystem` object.
    The module also includes other convenient methods to help work with database files.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding the `DbFileExt` module to your project is easy. Simply copy the `dbfileext.js`
    file into your project, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve added the `dbfileext.js` file to your project, you need to use
    `require` to import the module into your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Finding our database Ti.Filesystem.File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `dbFile` function provides easy access to the `Ti.Filesystem.File` object
    for your database. Simply provide the database name you wish to access, and the
    associated `Ti.Filesystem.File` object will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an invalid database name is provided to the `dbFile` function, a new `Ti.Filesystem.File`
    object will be returned. This allows you to add a database or file later. It is
    recommended to use the `exists` method when any operations are performed.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the database directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Determining your application''s database folder can be challenging, as it differs
    according to the platform. Leveraging the `dbDirectory` function assists with
    this challenge, providing you specify the appropriate directory path based on
    the device your app is running on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: File exist check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You will often need to check if a database has been installed, before opening.
    The `DbFileExt` module makes this straightforward with the `dbExists` function.
    Simply paste in the database name and a Boolean is returned, identifying if the
    database has been installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: RemoteBackup – iOS-specific attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With iOS 5, Apple included the ability to back up files to the iCloud service.
    You can enable or disable this feature on your SQLite database file through the
    use of the `dbRemoteBackup` function. When you provide the database name and a
    Boolean, you are indicating if you would like to have remote backup enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If this function is called on the Android platform, no action will be performed,
    as this relates to iOS-specific functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming a database file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `DbFileExt` module allows you to rename your database files. This can be
    helpful when versioning or keeping backups of your database. To rename a database,
    provide the current database name and the new name as parameters to the `dbRename`
    method, as the following statement shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Listing all databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When dealing with large apps, or apps that require database versioning, you
    will often need a list of all the databases installed within your app''s sandbox.
    The `dbList` function provides the name and native path for each SQLite database
    within your app''s database folder. You can then use this array to remove any
    unneeded database files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Removing a database file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `dbRemove` function provides an easy and safe way to remove any unwanted
    database files. Provide the database name you wish to delete and the `DbFileExt`
    module will remove the file from your device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next series of tests demonstrate how the `DbFileExt` module works within
    a windowless sample `app.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we use the `Ti.Database.open` function to create a sample database.
    The following highlighted code demonstrates how to create a database named `testdb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next, we build a `Ti.Filesystem` object with a known reference to our `testdb`
    database. This will later be used to verify if the `DbFileExt` module is returning
    the correct values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The iOS `Ti.Database` object has a file property that can be used in your tests.
    On Android, you need to create the file object using the proper directory and
    file names.
  prefs: []
  type: TYPE_NORMAL
- en: Finding our database Ti.Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we compare the `Ti.Filesystem.File` object returned by the `DbFileExt`
    module to see if it matches our test file. These should always match no matter
    what the platform.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Determining database directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The directory where your SQLite file is installed differs by platform. For
    example, it is in the `data` directory on Android and the `Private Documents`
    folder on iOS. The next example demonstrates how to write the path to your devices
    database directory to Titanium Studio''s console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: File exist check
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common use of the `DbFileExt` module is to check if a database has
    already been installed. The next test compares the `dbExists` result in `DbFileExt`
    with those generated by our test `Ti.Filesystem.File` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Renaming a database file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You will encounter the need to rename databases for a variety of reasons, the
    most common being archiving or versioning. The following highlighted code demonstrates
    how to rename the `testdb` database to `oldtest`. The `dbExists` method is then
    called on both the new and old names to demonstrate that the rename function has
    worked properly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Listing all databases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is often helpful to have a list of all the databases that are available within
    your app. This can be particularly helpful with large apps or apps containing
    third-party components.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this functionality, first we create several databases in our
    sample app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dbList` function of the `DbFileExt` module is used to return all the databases
    installed into our app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The following snippet writes the list of databases provided by the `installedDb`
    variable to Titanium Studio's console. This will list all of the databases used
    in this sample, along with any that might also be installed within your Titanium
    project.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Removing a database file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final test in this recipe demonstrates how to use the `dbRemove` function
    to delete an installed database. The following highlighted snippet shows how to
    delete the `oldtest` database that we used earlier in the sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: DbTableChecker SQLite table existence checking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SQLite and the `Ti.Database` API provide many powerful features. This recipe
    demonstrates how to use the existing `Ti.Database` API and SQL statements to check
    if a table has already been created.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to check if database objects exist is critical for Enterprise apps,
    for versioning and data migration purposes A typical usage of this process would
    be to check if a table already exists during schema migration. For example, a
    specific data migration might be performed if the client table in your app already
    exists while creating the table for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe relies on the Titanium framework's `Ti.Database` API, requiring
    no dependencies. In the next section, we create a simple `app.js` file, demonstrating
    how to perform the table-exists check.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following steps demonstrate how to check if a table exists within an SQLite
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Titanium Studio, create a module called `db` `tablechecker.js`. This module
    should have the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Namespace and app setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, in our application''s `app.js` file, we create our application namespace
    and use the `require` method to import the `CommonJS` module into our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating our window
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To help demonstrate this recipe, a window with three buttons is created. These
    buttons will allow you to create, test whether the table exists, and remove the
    `myTable` sample table.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Testing if a table exists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first button in the recipe demonstrates how to call the `tableExists` function
    created earlier in the `CommonJS` module of `dbTableChecker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When the button is pressed, the `tableExists` function is called within our
    `CommonJS` module to determine if the specified table exists. The next highlighted
    code snippet demonstrates checking if a table named `myTable` exists within the
    `myDatabase` SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Creating a table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next button in this recipe is used to create a sample table, which is to
    be used in our tests. When exploring this recipe, this button will allow you to
    drop and re-create a sample table several times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following highlighted code demonstrates calling the `my.testers.makeTable`
    function to create a table named `myTable` in the `myDatabase` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See this recipe's *How it works…* section for more information on `my.testers`.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last button in this recipe is used to drop the sample table. When exploring
    this recipe, this button will allow you to drop and re-create a sample table several
    times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted line in the following code snippet demonstrates how to call
    the `my.testers.removeTable` function to drop a table named `myTable` in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See this recipe's *How it works…* section for more information on `my.testers`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the SQLite data dictionary and several helper methods to support
    testing. The functionality of these methods and how they are composed, is discussed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Testing helpers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This recipe uses two helper functions, `makeTable` and `dropTable`, to manage
    our sample table. These methods allow for the `tableExists` method to be tested
    repeatedly without conflict.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `makeTable` function uses `dbName` to open a database connection. Once
    the database has been opened, a table is created (if it doesn''t exist) using
    the provided `tableName` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `removeTable` function uses `dbName` to open a database connection. Once
    the database has been opened, the table name provided in the `tableName` parameter
    is dropped, if the table exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The tableExists method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dbTableCheck` module has a single method named `tableExists` which returns
    a Boolean result if the provided table name exists within the database. This check
    is performed by querying the data dictionary of the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The following SQL statements will query the SQLite data dictionary table, `sqlite_master`,
    for a list of tables with a specified table name. The `?` character is a parameter
    that is replaced by the execute method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The data dictionary query is then executed using the `tableName` variable as
    its parameter. A `Ti.Database.DbResultSet` is returned and allocated to the `getReader`
    variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the `getRowCount` method is used to determine if any rows are returned.
    This is converted into a Boolean statement that will later be returned by this
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `DbResultSet` and database is then closed to reduce the number of active
    objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Boolean result determined earlier is returned by the following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Recursively handling files using Dossier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When creating your Titanium Enterprise app, you will often find the need to
    copy the contents of a directory to another place. Two of the most common examples
    of this would be: implementing a caching approach and performing lazy, loaded
    installations. For example, Dossier can be used to create an initial content cache,
    by copying files from your app''s `Resources` directory into a working directory
    under `Ti.Filesystem.applicationDataDirectory`. This would allow for the user
    to see the initial content while data is being refreshed in the background.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Dossier` CommonJS module provides a cross-platform API for handling these
    types of folder operations. The next section demonstrates how to install and use
    the `Dossier` module within your Titanium Enterprise app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Dossier` CommonJS module is installed by including the `dossier.js` file
    into your project.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Dossier module into your project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding the `dossier` module to your project is easy. Simply copy the `dossier.js`
    file and the `SampleData` folder into the `Resources` folder of your Titanium
    project, as highlighted in the following screenshot. This will install all the
    files needed for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Dossier module into your project](img/5343OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you''ve added the `dossier.js` file to your project, you need to use `require`
    in order to import the module into your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Creating sample directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To demonstrate the copy and move features of Dossier, a `Ti.Filesystem` object
    is created for both our source and destination directories. In the next snippet,
    the `sourceDir` variable contains a directory reference to the `SampleData` folder
    we copied as part of the recipe setup, and `targetDir` references a new folder
    named `NewSampleData`, to be created in your device's `data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Recursive listing of directory contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When dealing with dynamic or downloadable content, you will often need to list
    all of the content of a specific directory. The `listContents` method allows you
    to recursively query the content of a directory, listing all files and subdirectories
    within.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet demonstrates how to query our recipe''s `sourceDir`
    for a list of all files and folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `listContents` method returns a file explorer dictionary object, listing
    all of the files and subdirectories in a hierarchal format, as highlighted in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Recursive listing of directory contents](img/5343OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Recursively copying directory contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many Enterprise apps are content driven. To improve your first-time installation
    experience, you might wish to bundle introductory content within your app and
    copy this bundled content into local cache on startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `dossier` module''s `copy` method, you can copy the entire content of
    one folder to another. The following code demonstrates how to copy all the content
    of our source directory to our new target directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the copy process, any existing content in the target folder will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Recursively moving directory contents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `move` method creates a new copy of all the content of your source directory
    to your target folder. Once the copying process has been successfully completed,
    the source directory is removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During the move process, any existing content in the target folder will be removed
    and replaced with the content of our source folder. Additionally, after all the
    files have been moved, the source content will be removed if possible. In cases
    where the source directory is read-only, the contents will be retained.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Dossier` module used in this recipe is an open source project available
    on Github. If you are interested in learning more or contributing, please visit
    the project at [https://github.com/benbahrenburg/Dossier](https://github.com/benbahrenburg/Dossier).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuning your SQLite database for maximum performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data access is a common bottleneck in Titanium Enterprise development. Through
    proper use of SQLite transactions, you can experience up to a 10x improvement
    in bulk insert operations.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite transactions provide reliable units of work that allow for data recovery
    and keep the database consistent. By default, each time an insert, update, or
    delete operation is performed on an SQLite database, an implicit transaction is
    created before and after your statement is executed. This helps keep your database
    in a consistent state. For batch operations however, this introduces an additional
    level of overhead and can drastically reduce your app's performance.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how to use SQLite transactions to improve app performance
    when conducting batch SQL actions and working with large datasets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe will run a performance comparison using 100,000 rows. Included in
    this recipe is the following basic UI that allows you to benchmark your different
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the TimeLogger module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This recipe uses `TimeLogger` to record the duration of each performance test.
    To add the `TimeLogger` module to your project, copy the `timelogger.js` file
    into your project, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the TimeLogger module](img/5343OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in this recipe is to create the application namespace and import
    the timer module, as the following snippet demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Creating our testing Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to create a `Ti.UI.Window` for our recipe. This will be used
    to provide a launching point for our performance tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, a label is created to track the results of our `No Transactions` performance
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, a label is created to track the results of our `With Transactions` performance
    test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final UI element we create is a button that, when pressed, will launch
    our tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Benchmarking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the `runTestButton` button is pressed, a benchmark 100,000 record insert
    is performed, both with and without the use of transactional scoping. The screen
    is then updated with the elapsed milliseconds for each test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how each test is run when the button''s click
    event is triggered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, a test is run without explicitly creating a transaction. This test returns
    the number of milliseconds elapsed while running, and stores the result in the
    `noTransactions` variable, as the following snippet demonstrates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, the same test is run using `BEGIN` and `COMMIT` statements to create
    an explicit transaction. This test returns the milliseconds elapsed during the
    test, and stores the result in the `withTransactions` variable, as shown in the
    following snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe uses the helper objects discussed in this section, to perform the
    benchmarking operations.
  prefs: []
  type: TYPE_NORMAL
- en: Database setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`dbTestHelpers` is the first helper object used during benchmarking. This object
    contains all the code needed to set up, create, and manage the database used in
    our tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `maxIterations` property controls the number of iterations in our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `createOrResetDb` method is used to return a known and consistent database
    to test against:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `resetTestTable` method is then called to drop and re-create our test table.
    This allows us to run our tests several times, while maintaining a consistent
    sample size:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `createSQLStatement` method returns the SQL that will be used to perform
    our insert operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `createDummyObject` function creates a unique object, to be inserted into
    each row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Performing the tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `performanceTest` object runs and times the recipe database''s inserts.
    The `run` method starts our benchmark and provides an indicator if the test is
    to use transactions or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step in our test is to create a database connection and to reset
    our table. This is done by calling the `dbTestHelper` method, discussed earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After our database has been set up, the next step is to create our `insert`
    statement and `timer` objects, as demonstrated here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `useTransaction` flag has been set, we then explicitly begin a transaction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next step of this recipe, a loop is created, to insert records into the
    test table, a specific number of times. By default, this test will insert 100,000
    records, and time the total duration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the `useTransaction` flag has been set, we then explicitly "commit" the
    transaction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final step of this method is to retrieve our execution duration from our
    timer object. This value (in milliseconds) is then returned for later comparison
    operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about SQLite transactions and how they are implemented, please
    read the official documentation at [http://www.sqlite.org/lang_transaction.html](http://www.sqlite.org/lang_transaction.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data access using DbLazyProvider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data access is a common challenge when building any Enterprise app. The `DbLazyProvider`
    module provides a lightweight wrapper around the `Ti.Database` API. This module
    provides helpers for commonly required operations such as managing transactions
    and lazy-loading connections.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading is a common efficiency pattern that defers the initialization of
    an object until needed. By lazy-loading app-database connections, any memory usage
    or IO operation associated with creating a database connection is deferred until
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: The following section demonstrates how to use the `DbLazyProvider` module to
    implement a lazy-loading pattern in your app, while maintaining control over your
    database transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding the `DbLazyProvider` module to your project is easy. Simply copy the
    `dblazyprovider.js` file into your project, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in this recipe is to create the application namespace and import
    the `DbLazyProvider` module, as demonstrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Next, a sample table named `MY_TEST` is created. If the table already exists,
    any existing records will be purged so we can start a new test.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Creating our testing Interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, we create a `Ti.UI.Window` for our recipe. This will be used to provide
    a launching point for our tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Lazy-loading using transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `insertDemoBtn` button is used to trigger our recipe, showing how to use
    transactions with `DbLazyProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Clicking on the `insertDemoBtn` button will insert 1,000 rows into our table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The following code shows using the `connect` method with a transaction parameter
    of `true` to obtain the `Ti.Database` object that is used to execute the SQL statement.
    This will automatically create a transaction on the first insert for you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When the `close` method is called, any transactions that were created will
    be committed, and the database connection will be closed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Creating a select statement using lazy-loading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all SQL statements benefit from transactions. The following snippet demonstrates
    how to perform a select statement without using transactions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Click on the `selectDemoBtn` button to create a new `DbLazyProvider` object,
    and run a select statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The highlighted code shows how to use the `connect` method without providing
    any parameters. This will, by default, avoid using transactions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On using the `close` method, the database connection will be closed and all
    objects will be set to null:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DbLazyProvider` module is a lightweight, yet powerful, wrapper over `Ti.Database`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new DbLazyProvider object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a new `DbLazyProvider` object, simply use the `require` method to
    import the module and create a new object using the reference in the following
    highlighted snippet. This will create a new object wrapper for the database name
    provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Getting a connection object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most frequently used method of `DbLazyProvder` is `connect`. This method
    will create a new `Ti.Database` connection if needed, and then return the database
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to have your SQL statement start a transaction, you simply pass
    in a Boolean parameter of `true` when calling the `connect` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The transaction created will be used until either the `close` or `commit` method
    is called on your `DbLazyProvider` object.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning a transaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, transactions are handled automatically for you, using the `connect`
    and `close` methods. You can also explicitly create a transaction at any time
    using the `beginTransaction` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Ending a transaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, transactions are handled automatically for you, using the `connect`
    and `close` methods. You can also explicitly commit or finish a transaction at
    any time using the `commit` method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Opening a database connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The module, by default, will wait until a database connection is needed, before
    opening the `Ti.Database` object. If a connection is needed in advance, you can
    call the `open` method at any time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also pass in a new database name to switch your database reference.
  prefs: []
  type: TYPE_NORMAL
- en: Closing a database connection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the `close` method on your `DbLazyProvider` objects is important, as it
    both commits any pending transactions and closes your database connection. The
    `close` method should be called after each transaction grouping or when the database
    connection is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: NoSQL using MongloDb
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NoSQL databases are often a perfect fit for managing your application's data,
    as it allows you to work with objects instead of tables. In addition to the benefit
    of working with objects, using NoSQL on mobile reduces complexity by removing
    the need for schema management, data migration, and other common maintenance issues
    associated with maintaining a relational data model.
  prefs: []
  type: TYPE_NORMAL
- en: MongloDb is a pure JavaScript implementation of the popular MongoDb NoSQL solution.
    The `MongloDb` module allows you to query and persist objects using the familiar
    MongoDb syntax in your Titanium app. This recipe demonstrates how to leverage
    the `MongloDb` module within your new or existing Titanium project.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Installing MongloDb for Titanium is a straightforward process. You can either
    copy the `Monglo` folder from the recipe's source code, or create the bundle yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the bundle is a three-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Titanium Studio, create a folder called `Monglo` in the `Resources` folder
    of your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the latest `monglodb.js` file from [monglodb.com](http://monglodb.com)
    into the `Monglo` folder created in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download into the `Monglo` folder the latest `index.js` file from the Titanium
    Store project available on [monglodb.com](http://monglodb.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Whether you copied the bundle from the recipe source or created your own, the
    `Monglo` folder in your Titanium project should resemble the highlighted part
    of the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/5343OT_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have installed MongloDb, you will need to use `require` to import
    the module into your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Initializing your database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the module has been imported, a new instance of the database needs to
    be initialized. The following code demonstrates how to create a new instance of
    `Monglo` with the name `myDb`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Adding the Titanium storage provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MongloDb has the ability to support a wide range of storage providers. This
    recipe implements the Titanium Store provider to persist data. Associating a storage
    provider with MongloDb is a two-step process. First, we `require` the Titanium
    storage provider, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: After the storage provider has been created, the provider is passed into the
    `use` method, as demonstrated in the following statement. Once the `use` method
    is called, MongloDb will perform all persistence operations using the Titanium
    Storage provider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Initializing our collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the storage provider has been associated, durable collections can be created
    using the `collection` method. The following line demonstrates how to create a
    document collection named `foo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: When initializing a named collection, any documents previously persisted by
    this collection will automatically be reloaded. In the previous example, any documents
    previously saved in the `foo` document collection will be reloaded when the collection
    is initialized.
  prefs: []
  type: TYPE_NORMAL
- en: Using events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MongloDb provides events for monitoring a majority of the actions performed.
    The following snippet demonstrates how to add an event for each supported listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Inserting documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step is to insert three new documents. The next snippet demonstrates
    how to insert a new document into `someCollection`. The `insert` method has two
    parameters. The first parameter is a document object to be stored. The second
    parameter is a callback that lists the errors and provides document information.
    This is shown in the following highlighted snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: The `error` and `doc` objects are returned as part of the `callback` function.
    The `error` object contains any issues encountered during the insert action, and
    the `doc` object contains a copy of the `Monglo` document created.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Using find to query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With three records now created, we can use the `find` function to search for
    all the documents that have the batch ID `sample_test`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `find` method returns both an `error` and `cursor` object. The cursor''s
    `forEach` iterator provides a convenient way to inspect each document that is
    returned. The following snippet demonstrates how to print each document within
    the `cursor` to the Titanium Studio console as a JSON string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Updating documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to a traditional database, MongloDb provides the ability to change a
    document using the `update` method. The `update` method has three parameters.
    The first parameter is used to find the object you wish to update. The next example
    shows updating any object with the text property equal to `record 1`. The second
    parameter is the update statement. The example updates each matching object's
    text property to `updated record 1`. The final parameter is a callback which returns
    an `error` and `doc` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrated how to update the text property on the first document inserted
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Using findOne to query for a single document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `findOne` method provides the means to query your collection for a specific
    document. The following snippet demonstrates how to query `someCollection` for
    the document we just updated. The resulting single-matching document is then printed
    to the Titanium Studio console as a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Removing documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final section of this recipe demonstrates how to remove documents from a
    collection. The following snippet demonstrates how to remove all documents that
    have the batch ID `sample_test`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous code snippet removes all records created in this recipe, allowing
    you to run the sample several times without creating unwanted records.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the NoSQL examples shown in this recipe use the MongloDb open source project.Please
    see the following to learn more about this project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Project site: [http://monglodb.com/](http://monglodb.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Github project: [https://github.com/Monglo/MongloDB](https://github.com/Monglo/MongloDB)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Titanium Store: [https://github.com/Monglo/MongloDB-Titanium-Store](https://github.com/Monglo/MongloDB-Titanium-Store)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Groups: [https://groups.google.com/forum/#!forum/monglodb](https://groups.google.com/forum/#!forum/monglodb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
