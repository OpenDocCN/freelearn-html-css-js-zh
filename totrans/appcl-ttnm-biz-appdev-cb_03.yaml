- en: Chapter 3. Using Databases and Managing Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用数据库和管理文件
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Accessing your database's Ti.Filesystem
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问您的数据库的Ti.Filesystem
- en: DbTableChecker SQLite table existence checking
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DbTableChecker SQLite表存在性检查
- en: Recursively handling files using Dossier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dossier递归处理文件
- en: Tuning your SQLite database for maximum performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对SQLite数据库进行调优以获得最佳性能
- en: Data access using DbLazyProvider
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用DbLazyProvider进行数据访问
- en: NoSQL using MongloDb
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MongloDb进行NoSQL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Titanium has several components designed to assist in handling your data needs.
    Additionally, the Titanium open source community has provided a wealth of alternative
    data-handling options.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Titanium有几个组件旨在帮助处理您的数据需求。此外，Titanium开源社区还提供了丰富的替代数据处理选项。
- en: The recipes in this chapter demonstrate a variety of helpful approaches to work
    with data while on the device. With topics ranging from file-system management
    to SQLite tuning, there will be an approach to assist your Enterprise data needs,
    no matter what your preferred approach is.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱展示了在设备上处理数据时各种有用的方法。从文件系统管理到SQLite调优，无论您首选哪种方法，都将有一个方法来协助您的企业数据需求。
- en: Accessing your database's Ti.Filesystem
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问您的数据库的Ti.Filesystem
- en: Titanium includes a powerful database API that provides easy access to the underlying
    platform's SQLite implementation. Having access to `Ti.Filesystem` for your app's
    SQLite database allows you the flexibility to handle updates, migrations, and
    installations more effectively.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 钛金属包含一个强大的数据库API，它提供了对底层平台SQLite实现的便捷访问。通过为您的应用程序的SQLite数据库访问`Ti.Filesystem`，您可以更有效地处理更新、迁移和安装。
- en: The `DbFileExt` module provides easy access to your SQLite `Ti.Filesystem` object.
    The module also includes other convenient methods to help work with database files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbFileExt`模块提供了对您的SQLite `Ti.Filesystem`对象的便捷访问。该模块还包括其他方便的方法来帮助处理数据库文件。'
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Adding the `DbFileExt` module to your project is easy. Simply copy the `dbfileext.js`
    file into your project, as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将`DbFileExt`模块添加到您的项目中很简单。只需将`dbfileext.js`文件复制到您的项目中，如下截图所示：
- en: '![Getting ready](img/5343OT_03_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/5343OT_03_01.jpg)'
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Once you''ve added the `dbfileext.js` file to your project, you need to use
    `require` to import the module into your code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您将`dbfileext.js`文件添加到您的项目中，您需要使用`require`将模块导入到您的代码中：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Finding our database Ti.Filesystem.File
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找我们的数据库Ti.Filesystem.File
- en: 'The `dbFile` function provides easy access to the `Ti.Filesystem.File` object
    for your database. Simply provide the database name you wish to access, and the
    associated `Ti.Filesystem.File` object will be returned:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbFile`函数提供了对您的数据库`Ti.Filesystem.File`对象的便捷访问。只需提供您希望访问的数据库名称，相关的`Ti.Filesystem.File`对象将被返回：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If an invalid database name is provided to the `dbFile` function, a new `Ti.Filesystem.File`
    object will be returned. This allows you to add a database or file later. It is
    recommended to use the `exists` method when any operations are performed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果向`dbFile`函数提供了无效的数据库名称，将返回一个新的`Ti.Filesystem.File`对象。这允许您稍后添加数据库或文件。建议在执行任何操作时使用`exists`方法。
- en: Determining the database directory
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定数据库目录
- en: 'Determining your application''s database folder can be challenging, as it differs
    according to the platform. Leveraging the `dbDirectory` function assists with
    this challenge, providing you specify the appropriate directory path based on
    the device your app is running on:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 确定您的应用程序的数据库文件夹可能具有挑战性，因为它根据平台而异。利用`dbDirectory`函数有助于解决这一挑战，前提是您根据应用程序运行的设备指定适当的目录路径：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: File exist check
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件存在性检查
- en: 'You will often need to check if a database has been installed, before opening.
    The `DbFileExt` module makes this straightforward with the `dbExists` function.
    Simply paste in the database name and a Boolean is returned, identifying if the
    database has been installed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开之前，您通常会需要检查数据库是否已安装。`DbFileExt`模块通过`dbExists`函数使这一过程变得简单。只需粘贴数据库名称，就会返回一个布尔值，标识数据库是否已安装：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: RemoteBackup – iOS-specific attribute
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程备份 – iOS特定的属性
- en: 'With iOS 5, Apple included the ability to back up files to the iCloud service.
    You can enable or disable this feature on your SQLite database file through the
    use of the `dbRemoteBackup` function. When you provide the database name and a
    Boolean, you are indicating if you would like to have remote backup enabled:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 5 中，Apple 包含了将文件备份到 iCloud 服务的功能。您可以通过使用 `dbRemoteBackup` 函数来启用或禁用此功能。当您提供数据库名称和布尔值时，您表示是否希望启用远程备份：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If this function is called on the Android platform, no action will be performed,
    as this relates to iOS-specific functionality.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在 Android 平台上调用此函数，则不会执行任何操作，因为这涉及到 iOS 特定的功能。
- en: Renaming a database file
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名数据库文件
- en: 'The `DbFileExt` module allows you to rename your database files. This can be
    helpful when versioning or keeping backups of your database. To rename a database,
    provide the current database name and the new name as parameters to the `dbRename`
    method, as the following statement shows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbFileExt` 模块允许您重命名数据库文件。这在进行数据库版本控制或备份时非常有用。要重命名数据库，请将当前数据库名称和新名称作为参数传递给
    `dbRename` 方法，如下所示：'
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Listing all databases
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出所有数据库
- en: 'When dealing with large apps, or apps that require database versioning, you
    will often need a list of all the databases installed within your app''s sandbox.
    The `dbList` function provides the name and native path for each SQLite database
    within your app''s database folder. You can then use this array to remove any
    unneeded database files:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理大型应用程序或需要数据库版本控制的应用程序时，您通常会需要列出应用程序沙盒内安装的所有数据库。`dbList` 函数提供了应用程序数据库文件夹中每个
    SQLite 数据库的名称和本地路径。然后，您可以使用此数组删除任何不需要的数据库文件：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Removing a database file
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除数据库文件
- en: 'The `dbRemove` function provides an easy and safe way to remove any unwanted
    database files. Provide the database name you wish to delete and the `DbFileExt`
    module will remove the file from your device:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbRemove` 函数提供了一个简单且安全的方法来删除任何不需要的数据库文件。提供您希望删除的数据库名称，`DbFileExt` 模块将文件从您的设备中删除：'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The next series of tests demonstrate how the `DbFileExt` module works within
    a windowless sample `app.js`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下一系列测试演示了 `DbFileExt` 模块在无窗口的 `app.js` 示例中的应用。
- en: Setting up our test
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置我们的测试
- en: 'First, we use the `Ti.Database.open` function to create a sample database.
    The following highlighted code demonstrates how to create a database named `testdb`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用 `Ti.Database.open` 函数创建一个示例数据库。以下高亮代码演示了如何创建名为 `testdb` 的数据库：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we build a `Ti.Filesystem` object with a known reference to our `testdb`
    database. This will later be used to verify if the `DbFileExt` module is returning
    the correct values.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个 `Ti.Filesystem` 对象，该对象具有对 `testdb` 数据库的已知引用。这将在以后用于验证 `DbFileExt`
    模块是否返回正确的值。
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The iOS `Ti.Database` object has a file property that can be used in your tests.
    On Android, you need to create the file object using the proper directory and
    file names.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 的 `Ti.Database` 对象有一个文件属性，可以在您的测试中使用。在 Android 上，您需要使用正确的目录和文件名创建文件对象。
- en: Finding our database Ti.Filesystem
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找我们的数据库 Ti.Filesystem
- en: Next, we compare the `Ti.Filesystem.File` object returned by the `DbFileExt`
    module to see if it matches our test file. These should always match no matter
    what the platform.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们比较 `DbFileExt` 模块返回的 `Ti.Filesystem.File` 对象是否与我们的测试文件匹配。无论平台如何，这些都应该始终匹配。
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Determining database directory
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定数据库目录
- en: 'The directory where your SQLite file is installed differs by platform. For
    example, it is in the `data` directory on Android and the `Private Documents`
    folder on iOS. The next example demonstrates how to write the path to your devices
    database directory to Titanium Studio''s console:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 文件安装的目录因平台而异。例如，在 Android 上位于 `data` 目录中，而在 iOS 上位于 `Private Documents`
    文件夹中。以下示例演示了如何将设备数据库目录的路径写入 Titanium Studio 的控制台：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: File exist check
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件存在检查
- en: 'The most common use of the `DbFileExt` module is to check if a database has
    already been installed. The next test compares the `dbExists` result in `DbFileExt`
    with those generated by our test `Ti.Filesystem.File` object:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbFileExt` 模块最常用的用途是检查数据库是否已经安装。下一个测试比较了 `DbFileExt` 中的 `dbExists` 结果和由我们的测试
    `Ti.Filesystem.File` 对象生成的结果：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Renaming a database file
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名数据库文件
- en: You will encounter the need to rename databases for a variety of reasons, the
    most common being archiving or versioning. The following highlighted code demonstrates
    how to rename the `testdb` database to `oldtest`. The `dbExists` method is then
    called on both the new and old names to demonstrate that the rename function has
    worked properly.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会因为各种原因需要重命名数据库，最常见的是存档或版本控制。以下突出显示的代码演示了如何将`testdb`数据库重命名为`oldtest`。然后对新的和旧的名字都调用了`dbExists`方法，以演示重命名功能已正确工作。
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Listing all databases
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列出所有数据库
- en: It is often helpful to have a list of all the databases that are available within
    your app. This can be particularly helpful with large apps or apps containing
    third-party components.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列出应用中所有可用的数据库通常很有帮助，这对于大型应用或包含第三方组件的应用尤其有用。
- en: 'To demonstrate this functionality, first we create several databases in our
    sample app:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示此功能，首先在我们的示例应用中创建几个数据库：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `dbList` function of the `DbFileExt` module is used to return all the databases
    installed into our app:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbFileExt`模块的`dbList`函数用于返回安装到我们的应用中的所有数据库：'
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following snippet writes the list of databases provided by the `installedDb`
    variable to Titanium Studio's console. This will list all of the databases used
    in this sample, along with any that might also be installed within your Titanium
    project.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段将`installedDb`变量提供的数据库列表写入Titanium Studio的控制台。这将列出本示例中使用的所有数据库，以及可能也安装在你Titanium项目中的任何数据库。
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Removing a database file
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除数据库文件
- en: 'The final test in this recipe demonstrates how to use the `dbRemove` function
    to delete an installed database. The following highlighted snippet shows how to
    delete the `oldtest` database that we used earlier in the sample:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的最终测试演示了如何使用`dbRemove`函数删除已安装的数据库。以下突出显示的代码片段显示了如何删除我们在示例中之前使用的`oldtest`数据库：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: DbTableChecker SQLite table existence checking
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DbTableChecker SQLite表存在性检查
- en: SQLite and the `Ti.Database` API provide many powerful features. This recipe
    demonstrates how to use the existing `Ti.Database` API and SQL statements to check
    if a table has already been created.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite和`Ti.Database` API提供了许多强大的功能。此配方演示了如何使用现有的`Ti.Database` API和SQL语句来检查表是否已经创建。
- en: The ability to check if database objects exist is critical for Enterprise apps,
    for versioning and data migration purposes A typical usage of this process would
    be to check if a table already exists during schema migration. For example, a
    specific data migration might be performed if the client table in your app already
    exists while creating the table for the first time.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '检查数据库对象是否存在的能力对于企业应用至关重要，用于版本控制和数据迁移目的。此过程的典型用法是在模式迁移期间检查表是否已经存在。例如，如果客户端表在创建表时已经存在，则可能执行特定的数据迁移。 '
- en: Getting ready
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe relies on the Titanium framework's `Ti.Database` API, requiring
    no dependencies. In the next section, we create a simple `app.js` file, demonstrating
    how to perform the table-exists check.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方依赖于Titanium框架的`Ti.Database` API，无需任何依赖。在下一节中，我们将创建一个简单的`app.js`文件，演示如何执行表存在性检查。
- en: How to do it…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The following steps demonstrate how to check if a table exists within an SQLite
    database.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤演示了如何在SQLite数据库中检查表是否存在。
- en: Creating our module
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的模块
- en: 'In Titanium Studio, create a module called `db` `tablechecker.js`. This module
    should have the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在Titanium Studio中，创建一个名为`db`的模块，名为`tablechecker.js`。此模块应包含以下代码片段：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Namespace and app setup
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间和应用设置
- en: 'Next, in our application''s `app.js` file, we create our application namespace
    and use the `require` method to import the `CommonJS` module into our application:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的应用程序的`app.js`文件中，我们创建应用程序命名空间，并使用`require`方法将`CommonJS`模块导入到我们的应用程序中：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating our window
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的窗口
- en: To help demonstrate this recipe, a window with three buttons is created. These
    buttons will allow you to create, test whether the table exists, and remove the
    `myTable` sample table.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助演示此配方，创建了一个包含三个按钮的窗口。这些按钮将允许你创建、测试表是否存在，以及删除`myTable`示例表。
- en: '[PRE20]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Testing if a table exists
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试表是否存在
- en: 'The first button in the recipe demonstrates how to call the `tableExists` function
    created earlier in the `CommonJS` module of `dbTableChecker`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 配方中的第一个按钮演示了如何在`dbTableChecker`的`CommonJS`模块中创建的`tableExists`函数中进行调用：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the button is pressed, the `tableExists` function is called within our
    `CommonJS` module to determine if the specified table exists. The next highlighted
    code snippet demonstrates checking if a table named `myTable` exists within the
    `myDatabase` SQLite database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时，在 `CommonJS` 模块中调用 `tableExists` 函数以确定指定的表是否存在。下一个突出显示的代码片段演示了检查 `myDatabase`
    SQLite 数据库中是否存在名为 `myTable` 的表。
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating a table
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个表格
- en: The next button in this recipe is used to create a sample table, which is to
    be used in our tests. When exploring this recipe, this button will allow you to
    drop and re-create a sample table several times.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个按钮在本菜谱中用于创建一个用于测试的示例表。在探索本菜谱时，此按钮将允许您多次删除和重新创建示例表。
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following highlighted code demonstrates calling the `my.testers.makeTable`
    function to create a table named `myTable` in the `myDatabase` database:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下突出显示的代码演示了调用 `my.testers.makeTable` 函数来在 `myDatabase` 数据库中创建名为 `myTable` 的表：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: See this recipe's *How it works…* section for more information on `my.testers`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本菜谱的 *如何工作…* 部分，以获取有关 `my.testers` 的更多信息。
- en: Removing a table
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除一个表
- en: 'The last button in this recipe is used to drop the sample table. When exploring
    this recipe, this button will allow you to drop and re-create a sample table several
    times:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中的最后一个按钮用于删除示例表。在探索本菜谱时，此按钮将允许您多次删除和重新创建示例表：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The highlighted line in the following code snippet demonstrates how to call
    the `my.testers.removeTable` function to drop a table named `myTable` in our database:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段中突出显示的行演示了如何调用 `my.testers.removeTable` 函数来删除我们数据库中的名为 `myTable` 的表：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: See this recipe's *How it works…* section for more information on `my.testers`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本菜谱的 *如何工作…* 部分，以获取有关 `my.testers` 的更多信息。
- en: How it works…
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: This recipe uses the SQLite data dictionary and several helper methods to support
    testing. The functionality of these methods and how they are composed, is discussed
    here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱使用 SQLite 数据字典和几个辅助方法来支持测试。这些方法的函数性和它们的组合方式在此进行讨论。
- en: Testing helpers
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试辅助工具
- en: This recipe uses two helper functions, `makeTable` and `dropTable`, to manage
    our sample table. These methods allow for the `tableExists` method to be tested
    repeatedly without conflict.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱使用两个辅助函数 `makeTable` 和 `dropTable` 来管理我们的示例表。这些方法允许 `tableExists` 方法在无冲突的情况下重复测试。
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `makeTable` function uses `dbName` to open a database connection. Once
    the database has been opened, a table is created (if it doesn''t exist) using
    the provided `tableName` parameter:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`makeTable` 函数使用 `dbName` 打开数据库连接。一旦数据库已打开，就会使用提供的 `tableName` 参数创建一个表（如果不存在）：'
- en: '[PRE28]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `removeTable` function uses `dbName` to open a database connection. Once
    the database has been opened, the table name provided in the `tableName` parameter
    is dropped, if the table exists:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`removeTable` 函数使用 `dbName` 打开数据库连接。一旦数据库已打开，如果提供的 `tableName` 参数中指定的表存在，则将其删除：'
- en: '[PRE29]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The tableExists method
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`tableExists` 方法'
- en: The `dbTableCheck` module has a single method named `tableExists` which returns
    a Boolean result if the provided table name exists within the database. This check
    is performed by querying the data dictionary of the SQLite database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbTableCheck` 模块有一个名为 `tableExists` 的单一方法，如果提供的表名存在于数据库中，则返回一个布尔结果。此检查是通过查询
    SQLite 数据库的数据字典来执行的。'
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The following SQL statements will query the SQLite data dictionary table, `sqlite_master`,
    for a list of tables with a specified table name. The `?` character is a parameter
    that is replaced by the execute method.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 SQL 语句将查询 SQLite 数据字典表 `sqlite_master`，以获取具有指定表名的表列表。`?` 字符是一个参数，它将由执行方法替换。
- en: '[PRE31]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The data dictionary query is then executed using the `tableName` variable as
    its parameter. A `Ti.Database.DbResultSet` is returned and allocated to the `getReader`
    variable:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用 `tableName` 变量作为其参数执行数据字典查询。返回一个 `Ti.Database.DbResultSet` 并分配给 `getReader`
    变量：
- en: '[PRE32]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, the `getRowCount` method is used to determine if any rows are returned.
    This is converted into a Boolean statement that will later be returned by this
    method:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `getRowCount` 方法来确定是否有任何行返回。这被转换为一个布尔语句，稍后该方法将返回此语句：
- en: '[PRE33]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `DbResultSet` and database is then closed to reduce the number of active
    objects:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DbResultSet` 和数据库随后关闭，以减少活动对象的数量：'
- en: '[PRE34]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The Boolean result determined earlier is returned by the following method:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之前确定的布尔结果由以下方法返回：
- en: '[PRE35]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Recursively handling files using Dossier
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Dossier 递归处理文件
- en: 'When creating your Titanium Enterprise app, you will often find the need to
    copy the contents of a directory to another place. Two of the most common examples
    of this would be: implementing a caching approach and performing lazy, loaded
    installations. For example, Dossier can be used to create an initial content cache,
    by copying files from your app''s `Resources` directory into a working directory
    under `Ti.Filesystem.applicationDataDirectory`. This would allow for the user
    to see the initial content while data is being refreshed in the background.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建你的 Titanium 企业应用程序时，你通常会需要将目录的内容复制到另一个位置。最常见的两个例子是：实现缓存策略和执行懒加载安装。例如，可以使用
    Dossier 创建初始内容缓存，通过将文件从你的应用程序的 `Resources` 目录复制到 `Ti.Filesystem.applicationDataDirectory`
    下的工作目录。这将使用户能够在后台刷新数据时看到初始内容。
- en: The `Dossier` CommonJS module provides a cross-platform API for handling these
    types of folder operations. The next section demonstrates how to install and use
    the `Dossier` module within your Titanium Enterprise app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dossier` CommonJS 模块提供了一个跨平台的 API，用于处理这些类型的文件夹操作。下一节将演示如何在你的 Titanium 企业应用程序中安装和使用
    `Dossier` 模块。'
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `Dossier` CommonJS module is installed by including the `dossier.js` file
    into your project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dossier` CommonJS 模块通过将 `dossier.js` 文件包含到你的项目中来安装。'
- en: Adding the Dossier module into your project
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Dossier 模块添加到你的项目中
- en: Adding the `dossier` module to your project is easy. Simply copy the `dossier.js`
    file and the `SampleData` folder into the `Resources` folder of your Titanium
    project, as highlighted in the following screenshot. This will install all the
    files needed for this recipe.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `dossier` 模块添加到你的项目中很简单。只需将 `dossier.js` 文件和 `SampleData` 文件夹复制到你的 Titanium
    项目中的 `Resources` 文件夹，如下面的截图所示。这将安装此食谱所需的全部文件。
- en: '![Adding the Dossier module into your project](img/5343OT_03_02.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![将 Dossier 模块添加到你的项目中](img/5343OT_03_02.jpg)'
- en: How to do it…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Once you''ve added the `dossier.js` file to your project, you need to use `require`
    in order to import the module into your code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将 `dossier.js` 文件添加到你的项目中，你需要使用 `require` 来将模块导入到你的代码中：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating sample directories
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建示例目录
- en: To demonstrate the copy and move features of Dossier, a `Ti.Filesystem` object
    is created for both our source and destination directories. In the next snippet,
    the `sourceDir` variable contains a directory reference to the `SampleData` folder
    we copied as part of the recipe setup, and `targetDir` references a new folder
    named `NewSampleData`, to be created in your device's `data` directory.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 Dossier 的复制和移动功能，我们为源目录和目标目录创建了一个 `Ti.Filesystem` 对象。在下一个片段中，`sourceDir`
    变量包含一个指向我们作为食谱设置的一部分复制的 `SampleData` 文件夹的目录引用，而 `targetDir` 指向一个名为 `NewSampleData`
    的新文件夹，该文件夹将创建在你的设备 `data` 目录下。
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Recursive listing of directory contents
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归列出目录内容
- en: When dealing with dynamic or downloadable content, you will often need to list
    all of the content of a specific directory. The `listContents` method allows you
    to recursively query the content of a directory, listing all files and subdirectories
    within.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理动态或可下载的内容时，你通常会需要列出特定目录下的所有内容。`listContents` 方法允许你递归查询目录的内容，列出目录内的所有文件和子目录。
- en: 'The following code snippet demonstrates how to query our recipe''s `sourceDir`
    for a list of all files and folders:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了如何查询我们食谱的 `sourceDir` 以获取所有文件和文件夹的列表：
- en: '[PRE38]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `listContents` method returns a file explorer dictionary object, listing
    all of the files and subdirectories in a hierarchal format, as highlighted in
    the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`listContents` 方法返回一个文件浏览器字典对象，以分层格式列出所有文件和子目录，如下面的截图所示：'
- en: '![Recursive listing of directory contents](img/5343OT_03_03.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![递归列出目录内容](img/5343OT_03_03.jpg)'
- en: Recursively copying directory contents
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归复制目录内容
- en: Many Enterprise apps are content driven. To improve your first-time installation
    experience, you might wish to bundle introductory content within your app and
    copy this bundled content into local cache on startup.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业应用程序都是内容驱动的。为了改善你的首次安装体验，你可能希望在应用程序中捆绑介绍性内容，并在启动时将捆绑的内容复制到本地缓存中。
- en: 'Using `dossier` module''s `copy` method, you can copy the entire content of
    one folder to another. The following code demonstrates how to copy all the content
    of our source directory to our new target directory:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dossier` 模块的 `copy` 方法，你可以将一个文件夹的全部内容复制到另一个文件夹。以下代码演示了如何将我们源目录的所有内容复制到我们的新目标目录：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: During the copy process, any existing content in the target folder will be removed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在复制过程中，目标文件夹中现有的内容将被删除。
- en: Recursively moving directory contents
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 递归移动目录内容
- en: The `move` method creates a new copy of all the content of your source directory
    to your target folder. Once the copying process has been successfully completed,
    the source directory is removed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`move` 方法创建源目录所有内容的副本到目标文件夹。一旦复制过程成功完成，源目录将被删除。'
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: During the move process, any existing content in the target folder will be removed
    and replaced with the content of our source folder. Additionally, after all the
    files have been moved, the source content will be removed if possible. In cases
    where the source directory is read-only, the contents will be retained.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动过程中，目标文件夹中现有的内容将被删除，并替换为源文件夹的内容。此外，在所有文件都已移动后，如果可能，将删除源内容。在源目录为只读的情况下，将保留内容。
- en: See also
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: The `Dossier` module used in this recipe is an open source project available
    on Github. If you are interested in learning more or contributing, please visit
    the project at [https://github.com/benbahrenburg/Dossier](https://github.com/benbahrenburg/Dossier).
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此菜谱中使用的 `Dossier` 模块是一个开源项目，可在 Github 上找到。如果您想了解更多信息或贡献，请访问该项目：[https://github.com/benbahrenburg/Dossier](https://github.com/benbahrenburg/Dossier)。
- en: Tuning your SQLite database for maximum performance
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整 SQLite 数据库以获得最佳性能
- en: Data access is a common bottleneck in Titanium Enterprise development. Through
    proper use of SQLite transactions, you can experience up to a 10x improvement
    in bulk insert operations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 数据访问是钛企业开发中的常见瓶颈。通过正确使用 SQLite 事务，您可以体验到批量插入操作高达 10 倍的性能提升。
- en: SQLite transactions provide reliable units of work that allow for data recovery
    and keep the database consistent. By default, each time an insert, update, or
    delete operation is performed on an SQLite database, an implicit transaction is
    created before and after your statement is executed. This helps keep your database
    in a consistent state. For batch operations however, this introduces an additional
    level of overhead and can drastically reduce your app's performance.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 事务提供可靠的工作单元，允许数据恢复并保持数据库的一致性。默认情况下，每次在 SQLite 数据库上执行插入、更新或删除操作时，在您的语句执行前后都会创建一个隐式事务。这有助于保持数据库的一致状态。然而，对于批量操作，这引入了额外的开销，并且可能会大幅降低您的应用程序性能。
- en: This recipe demonstrates how to use SQLite transactions to improve app performance
    when conducting batch SQL actions and working with large datasets.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱演示了如何使用 SQLite 事务在执行批量 SQL 操作和处理大量数据时提高应用程序性能。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe will run a performance comparison using 100,000 rows. Included in
    this recipe is the following basic UI that allows you to benchmark your different
    devices.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将使用 100,000 行进行性能比较。其中包括以下基本 UI，允许您基准测试您的不同设备。
- en: '![Getting ready](img/5343OT_03_04.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/5343OT_03_04.jpg)'
- en: Adding the TimeLogger module
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 TimeLogger 模块
- en: 'This recipe uses `TimeLogger` to record the duration of each performance test.
    To add the `TimeLogger` module to your project, copy the `timelogger.js` file
    into your project, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱使用 `TimeLogger` 记录每个性能测试的持续时间。要将 `TimeLogger` 模块添加到您的项目中，将 `timelogger.js`
    文件复制到您的项目中，如下截图所示：
- en: '![Adding the TimeLogger module](img/5343OT_03_05.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![添加 TimeLogger 模块](img/5343OT_03_05.jpg)'
- en: How to do it…
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The first step in this recipe is to create the application namespace and import
    the timer module, as the following snippet demonstrates:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的第一步是创建应用程序命名空间并导入计时器模块，如下代码片段所示：
- en: '[PRE41]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Creating our testing Interface
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的测试界面
- en: The next step is to create a `Ti.UI.Window` for our recipe. This will be used
    to provide a launching point for our performance tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 `Ti.UI.Window` 用于我们的菜谱。这将用于为我们的性能测试提供一个启动点。
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, a label is created to track the results of our `No Transactions` performance
    test:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个标签来跟踪我们的 `No Transactions` 性能测试的结果：
- en: '[PRE43]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, a label is created to track the results of our `With Transactions` performance
    test:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个标签来跟踪我们的 `With Transactions` 性能测试的结果：
- en: '[PRE44]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The final UI element we create is a button that, when pressed, will launch
    our tests:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建的最后一个 UI 元素是一个按钮，当按下时，将启动我们的测试：
- en: '[PRE45]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Benchmarking
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基准测试
- en: When the `runTestButton` button is pressed, a benchmark 100,000 record insert
    is performed, both with and without the use of transactional scoping. The screen
    is then updated with the elapsed milliseconds for each test.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `runTestButton` 按钮被按下时，执行一个基准测试，插入 100,000 条记录，既有使用事务范围的情况，也有不使用的情况。然后屏幕会更新每个测试的经过的毫秒数。
- en: 'The following code demonstrates how each test is run when the button''s click
    event is triggered:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码演示了当按钮的点击事件被触发时，每个测试是如何运行的：
- en: '[PRE46]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'First, a test is run without explicitly creating a transaction. This test returns
    the number of milliseconds elapsed while running, and stores the result in the
    `noTransactions` variable, as the following snippet demonstrates:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行一个不显式创建事务的测试。此测试返回运行期间经过的毫秒数，并将结果存储在 `noTransactions` 变量中，如下所示：
- en: '[PRE47]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, the same test is run using `BEGIN` and `COMMIT` statements to create
    an explicit transaction. This test returns the milliseconds elapsed during the
    test, and stores the result in the `withTransactions` variable, as shown in the
    following snippet:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用 `BEGIN` 和 `COMMIT` 语句创建一个显式事务，运行相同的测试。此测试返回测试期间经过的毫秒数，并将结果存储在 `withTransactions`
    变量中，如下所示：
- en: '[PRE48]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe uses the helper objects discussed in this section, to perform the
    benchmarking operations.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱使用本节中讨论的辅助对象来执行基准测试操作。
- en: Database setup
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库设置
- en: '`dbTestHelpers` is the first helper object used during benchmarking. This object
    contains all the code needed to set up, create, and manage the database used in
    our tests:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbTestHelpers` 是在基准测试中首先使用的辅助对象。此对象包含设置、创建和管理我们测试中使用的数据库所需的所有代码：'
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `maxIterations` property controls the number of iterations in our test:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`maxIterations` 属性控制测试中的迭代次数：'
- en: '[PRE50]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `createOrResetDb` method is used to return a known and consistent database
    to test against:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createOrResetDb` 方法用于返回一个已知且一致的数据库以供测试：'
- en: '[PRE51]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `resetTestTable` method is then called to drop and re-create our test table.
    This allows us to run our tests several times, while maintaining a consistent
    sample size:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后调用 `resetTestTable` 方法来删除并重新创建我们的测试表。这允许我们多次运行测试，同时保持样本大小一致：
- en: '[PRE52]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `createSQLStatement` method returns the SQL that will be used to perform
    our insert operations:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createSQLStatement` 方法返回用于执行我们插入操作的 SQL 语句：'
- en: '[PRE53]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `createDummyObject` function creates a unique object, to be inserted into
    each row:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createDummyObject` 函数创建一个唯一的对象，用于插入到每一行：'
- en: '[PRE54]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Performing the tests
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行测试
- en: 'The `performanceTest` object runs and times the recipe database''s inserts.
    The `run` method starts our benchmark and provides an indicator if the test is
    to use transactions or not:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`performanceTest` 对象运行并计时食谱数据库的插入操作。`run` 方法启动基准测试并提供一个指示器，以确定测试是否要使用事务：'
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The first step in our test is to create a database connection and to reset
    our table. This is done by calling the `dbTestHelper` method, discussed earlier:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们测试的第一步是创建数据库连接并重置我们的表。这是通过调用前面讨论过的 `dbTestHelper` 方法来完成的：
- en: '[PRE56]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'After our database has been set up, the next step is to create our `insert`
    statement and `timer` objects, as demonstrated here:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的数据库设置完成后，下一步是创建我们的 `insert` 语句和 `timer` 对象，如下所示：
- en: '[PRE57]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If the `useTransaction` flag has been set, we then explicitly begin a transaction:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已设置 `useTransaction` 标志，我们随后显式开始一个事务：
- en: '[PRE58]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the next step of this recipe, a loop is created, to insert records into the
    test table, a specific number of times. By default, this test will insert 100,000
    records, and time the total duration.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本食谱的下一步中，创建一个循环，将特定数量的记录插入测试表。默认情况下，此测试将插入 100,000 条记录，并计时总持续时间。
- en: '[PRE59]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If the `useTransaction` flag has been set, we then explicitly "commit" the
    transaction:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果已设置 `useTransaction` 标志，我们随后显式“提交”事务：
- en: '[PRE60]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The final step of this method is to retrieve our execution duration from our
    timer object. This value (in milliseconds) is then returned for later comparison
    operations:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法的最后一步是从我们的计时器对象中检索执行持续时间。此值（以毫秒为单位）随后返回以供后续比较操作：
- en: '[PRE61]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: See also
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: To learn more about SQLite transactions and how they are implemented, please
    read the official documentation at [http://www.sqlite.org/lang_transaction.html](http://www.sqlite.org/lang_transaction.html)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于 SQLite 事务及其实现方式的信息，请阅读官方文档，链接为 [http://www.sqlite.org/lang_transaction.html](http://www.sqlite.org/lang_transaction.html)
- en: Data access using DbLazyProvider
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 DbLazyProvider 进行数据访问
- en: Data access is a common challenge when building any Enterprise app. The `DbLazyProvider`
    module provides a lightweight wrapper around the `Ti.Database` API. This module
    provides helpers for commonly required operations such as managing transactions
    and lazy-loading connections.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何企业应用程序时，数据访问是一个常见的挑战。`DbLazyProvider`模块在`Ti.Database` API周围提供了一个轻量级的包装器。此模块为常见操作提供辅助器，例如管理事务和懒加载连接。
- en: Lazy loading is a common efficiency pattern that defers the initialization of
    an object until needed. By lazy-loading app-database connections, any memory usage
    or IO operation associated with creating a database connection is deferred until
    needed.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是一种常见的效率模式，它将对象的初始化推迟到需要时。通过懒加载应用程序数据库连接，与创建数据库连接相关的任何内存使用或I/O操作都将推迟到需要时。
- en: The following section demonstrates how to use the `DbLazyProvider` module to
    implement a lazy-loading pattern in your app, while maintaining control over your
    database transactions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分演示了如何使用`DbLazyProvider`模块在您的应用程序中实现懒加载模式，同时保持对数据库事务的控制。
- en: Getting ready
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Adding the `DbLazyProvider` module to your project is easy. Simply copy the
    `dblazyprovider.js` file into your project, as shown in the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将`DbLazyProvider`模块添加到您的项目中很简单。只需将`dblazyprovider.js`文件复制到您的项目中，如下面的截图所示：
- en: '![Getting ready](img/5343OT_03_06.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/5343OT_03_06.jpg)'
- en: How to do it…
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The first step in this recipe is to create the application namespace and import
    the `DbLazyProvider` module, as demonstrated here:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的第一步是创建应用程序命名空间并导入`DbLazyProvider`模块，如下所示：
- en: '[PRE62]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Next, a sample table named `MY_TEST` is created. If the table already exists,
    any existing records will be purged so we can start a new test.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`MY_TEST`的示例表。如果表已存在，任何现有记录将被清除，以便我们可以开始新的测试。
- en: '[PRE63]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Creating our testing Interface
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的测试接口
- en: Now, we create a `Ti.UI.Window` for our recipe. This will be used to provide
    a launching point for our tests.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为我们的菜谱创建一个`Ti.UI.Window`。这将用于为我们的测试提供一个启动点。
- en: '[PRE64]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Lazy-loading using transactions
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事务进行懒加载
- en: 'The `insertDemoBtn` button is used to trigger our recipe, showing how to use
    transactions with `DbLazyProvider`:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`insertDemoBtn`按钮用于触发我们的菜谱，展示了如何使用`DbLazyProvider`进行事务处理：'
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Clicking on the `insertDemoBtn` button will insert 1,000 rows into our table:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`insertDemoBtn`按钮将向我们的表插入1,000行：
- en: '[PRE66]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The following code shows using the `connect` method with a transaction parameter
    of `true` to obtain the `Ti.Database` object that is used to execute the SQL statement.
    This will automatically create a transaction on the first insert for you.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码展示了使用带有`true`事务参数的`connect`方法来获取用于执行SQL语句的`Ti.Database`对象。这将自动为您在第一次插入时创建一个事务。
- en: '[PRE67]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'When the `close` method is called, any transactions that were created will
    be committed, and the database connection will be closed:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当调用`close`方法时，任何创建的交易将被提交，数据库连接将被关闭：
- en: '[PRE68]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Creating a select statement using lazy-loading
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用懒加载创建选择语句
- en: 'Not all SQL statements benefit from transactions. The following snippet demonstrates
    how to perform a select statement without using transactions:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有SQL语句都从事务中受益。以下代码片段演示了如何在不使用事务的情况下执行选择语句：
- en: '[PRE69]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Click on the `selectDemoBtn` button to create a new `DbLazyProvider` object,
    and run a select statement:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`selectDemoBtn`按钮创建一个新的`DbLazyProvider`对象，并运行一个选择语句：
- en: '[PRE70]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The highlighted code shows how to use the `connect` method without providing
    any parameters. This will, by default, avoid using transactions.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 突出显示的代码展示了如何使用不带任何参数的`connect`方法。这将默认避免使用事务。
- en: '[PRE71]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'On using the `close` method, the database connection will be closed and all
    objects will be set to null:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`close`方法时，数据库连接将被关闭，所有对象都将设置为null：
- en: '[PRE72]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: How it works…
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `DbLazyProvider` module is a lightweight, yet powerful, wrapper over `Ti.Database`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbLazyProvider`模块是`Ti.Database`的一个轻量级但强大的包装器。'
- en: Creating a new DbLazyProvider object
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个新的DbLazyProvider对象
- en: To create a new `DbLazyProvider` object, simply use the `require` method to
    import the module and create a new object using the reference in the following
    highlighted snippet. This will create a new object wrapper for the database name
    provided.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的`DbLazyProvider`对象，只需使用`require`方法导入模块，并使用以下突出显示的代码片段中的引用创建一个新的对象。这将创建一个数据库名称的新对象包装器。
- en: '[PRE73]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Getting a connection object
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取连接对象
- en: 'The most frequently used method of `DbLazyProvder` is `connect`. This method
    will create a new `Ti.Database` connection if needed, and then return the database
    object:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`DbLazyProvder`最常用的方法是`connect`。此方法将在需要时创建一个新的`Ti.Database`连接，然后返回数据库对象：'
- en: '[PRE74]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If you wish to have your SQL statement start a transaction, you simply pass
    in a Boolean parameter of `true` when calling the `connect` method, as shown here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望SQL语句开始一个事务，您只需在调用`connect`方法时传入一个布尔参数`true`，如下所示：
- en: '[PRE75]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The transaction created will be used until either the `close` or `commit` method
    is called on your `DbLazyProvider` object.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的事务将一直使用，直到在您的`DbLazyProvider`对象上调用`close`或`commit`方法。
- en: Beginning a transaction
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始事务
- en: 'By default, transactions are handled automatically for you, using the `connect`
    and `close` methods. You can also explicitly create a transaction at any time
    using the `beginTransaction` method, as shown here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，事务会自动为您处理，使用`connect`和`close`方法。您也可以在任何时候显式创建一个事务，使用`beginTransaction`方法，如下所示：
- en: '[PRE76]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Ending a transaction
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结束事务
- en: 'By default, transactions are handled automatically for you, using the `connect`
    and `close` methods. You can also explicitly commit or finish a transaction at
    any time using the `commit` method, as shown here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，事务会自动为您处理，使用`connect`和`close`方法。您也可以在任何时候显式提交或完成事务，使用`commit`方法，如下所示：
- en: '[PRE77]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Opening a database connection
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打开数据库连接
- en: 'The module, by default, will wait until a database connection is needed, before
    opening the `Ti.Database` object. If a connection is needed in advance, you can
    call the `open` method at any time:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模块将在需要数据库连接之前等待，然后打开`Ti.Database`对象。如果需要提前建立连接，您可以在任何时候调用`open`方法：
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Tip
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can also pass in a new database name to switch your database reference.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以传入一个新的数据库名称来切换数据库引用。
- en: Closing a database connection
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭数据库连接
- en: Using the `close` method on your `DbLazyProvider` objects is important, as it
    both commits any pending transactions and closes your database connection. The
    `close` method should be called after each transaction grouping or when the database
    connection is no longer needed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`DbLazyProvider`对象上使用`close`方法很重要，因为它会提交任何挂起的交易并关闭您的数据库连接。应在每个事务分组之后或当数据库连接不再需要时调用`close`方法。
- en: '[PRE79]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: NoSQL using MongloDb
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongloDb的NoSQL
- en: NoSQL databases are often a perfect fit for managing your application's data,
    as it allows you to work with objects instead of tables. In addition to the benefit
    of working with objects, using NoSQL on mobile reduces complexity by removing
    the need for schema management, data migration, and other common maintenance issues
    associated with maintaining a relational data model.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库通常非常适合管理您的应用程序数据，因为它允许您使用对象而不是表来工作。除了使用对象的优点外，在移动设备上使用NoSQL通过消除模式管理、数据迁移和其他与维护关系数据模型相关联的常见维护问题，可以降低复杂性。
- en: MongloDb is a pure JavaScript implementation of the popular MongoDb NoSQL solution.
    The `MongloDb` module allows you to query and persist objects using the familiar
    MongoDb syntax in your Titanium app. This recipe demonstrates how to leverage
    the `MongloDb` module within your new or existing Titanium project.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: MongloDb是MongoDb流行的NoSQL解决方案的纯JavaScript实现。`MongloDb`模块允许您在Titanium应用程序中使用熟悉的MongoDb语法查询和持久化对象。本菜谱演示了如何在新的或现有的Titanium项目中利用`MongloDb`模块。
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Installing MongloDb for Titanium is a straightforward process. You can either
    copy the `Monglo` folder from the recipe's source code, or create the bundle yourself.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为Titanium安装MongloDb是一个简单的过程。您可以从菜谱的源代码中复制`Monglo`文件夹，或者自己创建捆绑包。
- en: 'Creating the bundle is a three-step process:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 创建捆绑包是一个三步过程：
- en: Using Titanium Studio, create a folder called `Monglo` in the `Resources` folder
    of your project.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Titanium Studio，在项目的`Resources`文件夹中创建一个名为`Monglo`的文件夹。
- en: Download the latest `monglodb.js` file from [monglodb.com](http://monglodb.com)
    into the `Monglo` folder created in the previous step.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[monglodb.com](http://monglodb.com)下载最新的`monglodb.js`文件到之前步骤中创建的`Monglo`文件夹。
- en: Download into the `Monglo` folder the latest `index.js` file from the Titanium
    Store project available on [monglodb.com](http://monglodb.com).
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从钛存储项目下载最新的`index.js`文件到`Monglo`文件夹，该文件可在[monglodb.com](http://monglodb.com)上找到。
- en: 'Whether you copied the bundle from the recipe source or created your own, the
    `Monglo` folder in your Titanium project should resemble the highlighted part
    of the following screenshot:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是从食谱源复制了捆绑包还是创建了您自己的，您的Titanium项目中`Monglo`文件夹应类似于以下截图的高亮部分：
- en: '![Getting ready](img/5343OT_03_07.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/5343OT_03_07.jpg)'
- en: How to do it…
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Once you have installed MongloDb, you will need to use `require` to import
    the module into your code:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 安装MongloDb后，您需要使用`require`将模块导入到您的代码中：
- en: '[PRE80]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Initializing your database
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化您的数据库
- en: 'After the module has been imported, a new instance of the database needs to
    be initialized. The following code demonstrates how to create a new instance of
    `Monglo` with the name `myDb`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块导入之后，需要初始化一个新的数据库实例。以下代码演示了如何创建一个名为`myDb`的`Monglo`新实例：
- en: '[PRE81]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Adding the Titanium storage provider
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加钛存储提供程序
- en: 'MongloDb has the ability to support a wide range of storage providers. This
    recipe implements the Titanium Store provider to persist data. Associating a storage
    provider with MongloDb is a two-step process. First, we `require` the Titanium
    storage provider, as shown here:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: MongloDb具有支持广泛存储提供程序的能力。本食谱实现了钛存储提供程序以持久化数据。将存储提供程序与MongloDb关联是一个两步过程。首先，我们`require`钛存储提供程序，如下所示：
- en: '[PRE82]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: After the storage provider has been created, the provider is passed into the
    `use` method, as demonstrated in the following statement. Once the `use` method
    is called, MongloDb will perform all persistence operations using the Titanium
    Storage provider.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建存储提供程序后，提供程序被传递到`use`方法，如下所示。一旦调用`use`方法，MongloDb将使用钛存储提供程序执行所有持久化操作。
- en: '[PRE83]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Initializing our collection
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化我们的集合
- en: 'Once the storage provider has been associated, durable collections can be created
    using the `collection` method. The following line demonstrates how to create a
    document collection named `foo`:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦存储提供程序已关联，可以使用`collection`方法创建持久集合。以下行演示了如何创建一个名为`foo`的文档集合：
- en: '[PRE84]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: When initializing a named collection, any documents previously persisted by
    this collection will automatically be reloaded. In the previous example, any documents
    previously saved in the `foo` document collection will be reloaded when the collection
    is initialized.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当初始化一个命名集合时，任何之前由该集合持久化的文档将自动重新加载。在上一个示例中，当集合初始化时，之前保存在`foo`文档集合中的任何文档都将被重新加载。
- en: Using events
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件
- en: 'MongloDb provides events for monitoring a majority of the actions performed.
    The following snippet demonstrates how to add an event for each supported listener:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: MongloDb提供了用于监控大多数操作的监听器事件。以下片段演示了如何为每个支持的监听器添加事件：
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Inserting documents
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入文档
- en: 'The next step is to insert three new documents. The next snippet demonstrates
    how to insert a new document into `someCollection`. The `insert` method has two
    parameters. The first parameter is a document object to be stored. The second
    parameter is a callback that lists the errors and provides document information.
    This is shown in the following highlighted snippet:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是插入三个新的文档。以下片段演示了如何将新文档插入到`someCollection`中。`insert`方法有两个参数。第一个参数是要存储的文档对象。第二个参数是一个回调函数，它列出错误并提供文档信息。这在上面的高亮片段中显示：
- en: '[PRE86]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `error` and `doc` objects are returned as part of the `callback` function.
    The `error` object contains any issues encountered during the insert action, and
    the `doc` object contains a copy of the `Monglo` document created.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`error`和`doc`对象作为`callback`函数的一部分返回。`error`对象包含在插入操作期间遇到的任何问题，而`doc`对象包含创建的`Monglo`文档的副本。'
- en: '[PRE87]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Using find to query
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用find进行查询
- en: With three records now created, we can use the `find` function to search for
    all the documents that have the batch ID `sample_test`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已创建三个记录，我们可以使用`find`函数来搜索所有具有批次ID`sample_test`的文档。
- en: '[PRE88]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `find` method returns both an `error` and `cursor` object. The cursor''s
    `forEach` iterator provides a convenient way to inspect each document that is
    returned. The following snippet demonstrates how to print each document within
    the `cursor` to the Titanium Studio console as a JSON string:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`find`方法返回一个`error`对象和一个`cursor`对象。游标的`forEach`迭代器提供了一个方便的方式来检查返回的每个文档。以下片段演示了如何将`cursor`中的每个文档作为JSON字符串打印到Titanium
    Studio控制台：'
- en: '[PRE89]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Updating documents
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新文档
- en: Similar to a traditional database, MongloDb provides the ability to change a
    document using the `update` method. The `update` method has three parameters.
    The first parameter is used to find the object you wish to update. The next example
    shows updating any object with the text property equal to `record 1`. The second
    parameter is the update statement. The example updates each matching object's
    text property to `updated record 1`. The final parameter is a callback which returns
    an `error` and `doc` object.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统数据库类似，MongloDb提供了使用`update`方法更改文档的能力。`update`方法有三个参数。第一个参数用于查找你希望更新的对象。下一个示例展示了如何更新具有等于`record
    1`的文本属性的任何对象。第二个参数是更新语句。示例将每个匹配对象的文本属性更新为`updated record 1`。最后一个参数是一个回调，它返回一个`error`和`doc`对象。
- en: '[PRE90]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This demonstrated how to update the text property on the first document inserted
    in this recipe.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了如何更新本菜谱中插入的第一个文档的文本属性。
- en: Using findOne to query for a single document
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`findOne`查询单个文档
- en: The `findOne` method provides the means to query your collection for a specific
    document. The following snippet demonstrates how to query `someCollection` for
    the document we just updated. The resulting single-matching document is then printed
    to the Titanium Studio console as a JSON string.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`findOne`方法提供了查询你的集合以获取特定文档的手段。以下代码片段演示了如何查询`someCollection`以获取我们刚刚更新的文档。然后，单个匹配的文档作为JSON字符串打印到Titanium
    Studio控制台。'
- en: '[PRE91]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Removing documents
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除文档
- en: The final section of this recipe demonstrates how to remove documents from a
    collection. The following snippet demonstrates how to remove all documents that
    have the batch ID `sample_test`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的最后一部分演示了如何从集合中删除文档。以下代码片段演示了如何删除所有具有批处理ID`sample_test`的文档。
- en: '[PRE92]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Tip
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The previous code snippet removes all records created in this recipe, allowing
    you to run the sample several times without creating unwanted records.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段删除了在此菜谱中创建的所有记录，允许你多次运行示例而不会创建不想要的记录。
- en: See also
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'All the NoSQL examples shown in this recipe use the MongloDb open source project.Please
    see the following to learn more about this project:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱中展示的所有NoSQL示例都使用了MongloDb开源项目。请参阅以下内容以了解更多关于此项目的信息：
- en: 'Project site: [http://monglodb.com/](http://monglodb.com/)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目网站：[http://monglodb.com/](http://monglodb.com/)
- en: 'Github project: [https://github.com/Monglo/MongloDB](https://github.com/Monglo/MongloDB)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Github项目：[https://github.com/Monglo/MongloDB](https://github.com/Monglo/MongloDB)
- en: 'Titanium Store: [https://github.com/Monglo/MongloDB-Titanium-Store](https://github.com/Monglo/MongloDB-Titanium-Store)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Titanium Store：[https://github.com/Monglo/MongloDB-Titanium-Store](https://github.com/Monglo/MongloDB-Titanium-Store)
- en: 'Google Groups: [https://groups.google.com/forum/#!forum/monglodb](https://groups.google.com/forum/#!forum/monglodb)'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Groups：[https://groups.google.com/forum/#!forum/monglodb](https://groups.google.com/forum/#!forum/monglodb)
