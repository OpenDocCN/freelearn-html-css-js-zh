<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-185"><a id="_idTextAnchor186"/>9</h1>
<h1 id="_idParaDest-186"><a id="_idTextAnchor187"/>Calculating and Displaying Scoring Results</h1>
<p>Whether a game is implemented as a piece of software or a cut-out piece of cardboard, almost all games, regardless of origin or format, feature intrinsic ways to give players feedback on their performance throughout a game session. Whether it reflects the number of goals scored or the player’s ability to keep a steel ball from dropping between bumpers, the scoring process is where a game connects to its players at a most visceral level. </p>
<p>In this chapter, we’ll be introducing two new powerful tools for your game development toolbox, both completely new to version 5 of Babylon.js: the <code>src/route-planning/route-plan-gui.js</code> and recall that there is a large amount of boilerplate, typo-prone, and ultimately tedious code that needs to be written just to get a bare-bones basic GUI displayed. Much of the code involved is of the <em class="italic">make this object that color, and place it here</em> variety, making it more difficult to visualize how components and elements will look at runtime. The GUIE allows a developer or designer to separate the presentation from the behavioral logic of the application – a concept very familiar to most developers! In addition to the GUIE, we’re going to introduce another incredibly powerful tool – the coroutine.</p>
<p>A coroutine behaves and is constructed in a fashion that will be very familiar to those who have read the <em class="italic">Space-Truckers – The State Machine</em> section of <a href="B17266_04_Final_AM.xhtml#_idTextAnchor070"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating the Application</em>, but instead of having the specific purpose of managing our application state, a coroutine is built from an arbitrarily defined function generator (see <a href="B17266_04_Final_AM.xhtml#_idTextAnchor070"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating</em><em class="italic"> the Application</em>, for a refresher on <code>function*</code> generators in JavaScript) and attached to a <code>BabylonJS.Observable</code>. Most of the time, this Observable will be the Scene’s <code>onBeforeRenderObservable</code>, meaning that the coroutine executes before every frame, but any Observable can run a coroutine. The behavior of the <code>yield</code> keyword in conjunction with some other elements that we’ll look at shortly makes coroutines a perfect tool to use when a game’s logic needs to span multiple rendered frames, a quality we’re going to be using to our advantage to display the scoring results. </p>
<p>As part of and in addition to our examinations of the GUIE and coroutines, we’ll build out a reusable dialog system that will serve as the base for our Scoring Dialog and Results screen before putting score tracking logic into the rest of the game. Though this might seem like a backward approach, having the ability to display scores first will help us discover what needs to be tracked and calculated by the rest of the application. Is there much still that could and should be done? Of course! There will always be more to do, but an important skill in software development is knowing which things <em class="italic">must</em> be done versus which things only <em class="italic">need</em> to be done.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Introducing the Babylon.js GUI Editor</li>
<li>Building a Reusable Dialog Box Component</li>
<li>Calculating Scores</li>
<li>Creating the Scoring Dialog Using Coroutines</li>
</ul>
<h1 id="_idParaDest-187"><a id="_idTextAnchor188"/>Technical Requirements</h1>
<p>There aren’t any new or additional requirements from the software or hardware side of things that are needed for this chapter, but there are some topics in the Babylon.js documentation or elsewhere that might be handy as we explore some of these areas:</p>
<ul>
<li>The Babylon.js 2D GUI system at <a href="https://doc.babylonjs.com/divingDeeper/gui">https://doc.babylonjs.com/divingDeeper/gui</a></li>
<li>Coroutines (Babylon.js) at <a href="https://doc.babylonjs.com/divingDeeper/events/coroutines">https://doc.babylonjs.com/divingDeeper/events/coroutines</a></li>
<li>GUI Editor user’s guide/manual at <a href="https://doc.babylonjs.com/toolsAndResources/tools/guiEditor">https://doc.babylonjs.com/toolsAndResources/tools/guiEditor</a></li>
</ul>
<h1 id="_idParaDest-188"><a id="_idTextAnchor189"/>Introducing the Babylon.js GUI Editor</h1>
<p>Boilerplate code is a term given to code that has the characteristics of being simple, standardized, and frequently repeated. As a software developer, it’s generally best not to write that type of code yourself for some very good reasons. First, the nature of boilerplate code is that it is repetitive, making it prone to syntax or other superficial logical defects (that is, typos, fat-fingers, and more). Second, it’s tough to maintain, since when changes need to be introduced, those changes are generally needed throughout the expanse of the boilerplate. Finally (at least for our purposes), it’s really, really, <em class="italic">really</em> boring to read and write code of this nature.</p>
<p>To solve these (and other related) problems, the Babylon.js team created the GUIE. As just one of a huge number of new tools and features introduced with v5.0 of Babylon.js the GUIE fills an important niche in the Babylon.js ecosystem. Like its brethren, the Animation Curve Editor, the Node Material Editor, and the Playground, the GUIE and its associated snippet server are hosted online at <a href="https://gui.babylonjs.com">https://gui.babylonjs.com</a> and possess similar dual capabilities to work with unique IDs and revisions for persistence or directly with JSON files. </p>
<p class="callout-heading">Important note</p>
<p class="callout">There are two basic kinds of GUIs that Babylon.js supports: 2D and 3D. The 2D GUI renders to a utility layer using an Advanced Dynamic Texture (see <em class="italic">The Advanced Dynamic Texture</em> section), whereas the 3D GUI system renders meshes on a utility layer. The content in this chapter and through much of this book focuses mainly on the 2D GUI. However, the 2D and 3D systems have very similar APIs. See <a href="https://doc.babylonjs.com/divingDeeper/gui/gui3D">https://doc.babylonjs.com/divingDeeper/gui/gui3D</a> for more on the 3D GUI system.</p>
<p>Before we start looking at the GUIE’s interface and capabilities, it will be useful if we start with either a refresher or a primer on how the Babylon.js GUI components operate at the level of the <strong class="bold">Advanced Dynamic Texture</strong> (<strong class="bold">ADT</strong>).</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor190"/>The Advanced Dynamic Texture</h2>
<p>Throughout this book, we’ve been making use of ADTs and the 2D GUI system, but to this point, we haven’t tried to peek inside an ADT and see what it does. To do so, let’s peel off the <em class="italic">Advanced</em> part of the term and focus first on the more basic <strong class="bold">Dynamic Texture</strong> (<strong class="bold">DT</strong>).</p>
<p>A DT is a design-time integration component<a id="_idIndexMarker648"/> that exposes the HTML5 Canvas drawing API on one end of it; on the other, on the Babylon.js side, it exposes a <code>BABYLON.DynamicTexture</code>. Because it derives from a regular <code>BABYLON.Texture</code>, it is typically rendered by assigning the DT to an appropriate Texture slot in a Material. The Playground at <a href="https://playground.babylonjs.com/%235ZCGRM%232">https://playground.babylonjs.com/#5ZCGRM#2</a> demonstrates the basics of how this works for drawing simple text, but any Canvas API is accessible via the DT’s <code>getContext</code> function. </p>
<p class="callout-heading">Note</p>
<p class="callout">See <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API</a> to learn more about the Canvas API and<a id="_idIndexMarker649"/> its different functions and capabilities, and <a href="https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture">https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture</a> to learn more about the BablyonJS DT.</p>
<p>Accessing the Canvas APIs in this way allows for a huge amount of flexibility for developers wishing to render strings or other UI elements but at the cost of requiring those same developers to have to manage a large amount of what is essentially boilerplate code. Sound familiar? The BABYLON.GUI system is a higher layer of abstraction over the Canvas APIs on one end of the integration, and like its antecedent <strong class="bold">Dynamic Texture</strong>, the <strong class="bold">Advanced Dynamic Texture</strong> comprises the other.</p>
<p>Put one way, an ADT is a <strong class="bold">procedural texture</strong> generated and managed by the BABYLON.GUI APIs. That’s it. If it feels like this is somewhat of a letdown considering how much build-up there’s been to this definition, then you’re in luck because the details are far more involved than a simple procedural texture. We can start by picturing how an ADT fits into the overall scene and rendering process:</p>
<div><div><img alt="Figure 9.1 – The Canvas API and Babylon.js render layers that host a multitude of different features, such as the Inspector, Glow Layers, Gizmos, and more" height="1538" src="img/Figure_9.01_B17266.jpg" width="1647"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The Canvas API and Babylon.js render layers that host a multitude of different features, such as the Inspector, Glow Layers, Gizmos, and more</p>
<p>If we follow the analogy of an HTML Canvas being like a cloth canvas used for painting, a layer is like a distinct coat of paint on the canvas; multiple layers overlap and blend to create the whole piece. As with a real-world canvas, the order in which pixels (or swatches of paint) are laid down is important to the final appearance – whichever color is placed last on the canvas is generally going to be the dominant color for that pixel. </p>
<p>The ADT is rendered as one of those layers when created using <code>AdvancedDynamicTexture.CreateFullScreenUI</code>, with the <code>isForeground</code> property of the <a id="_idIndexMarker650"/>ADT determining whether its layer <a id="_idIndexMarker651"/>is rendered in front of all other layers. Crucially, this also means that the ADT can be affected by the same sorts of factors that affect other layers (for example, Layer Masks and Post-Processes; see <a href="B17266_08_Final_AM.xhtml#_idTextAnchor166"><em class="italic">Chapter 8</em></a>, <em class="italic">Building the Driving Game</em>, the <em class="italic">Loading Assets Asynchronously</em> section for more). When a full-screen UI isn’t the right tool for the job, <code>AdvancedDynamicTexture</code> can be used identically to any texture by creating it using the <code>AdvancedDynamicTexture.CreateMeshTexture</code> function. This is what we did in <a href="B17266_08_Final_AM.xhtml#_idTextAnchor166"><em class="italic">Chapter 8</em></a>, <em class="italic">Building the Driving Game</em>, in the <em class="italic">Making the Minimap</em> section, so it’s a good sign that we’re ready to progress up the ladder to the point where we can start using better tools to work with <code>AdvancedDynamicTexture</code> regardless of its type. In a similar vein, the GUIE will save us enormous amounts of time and effort, so let’s take a brief tour and get cranking!</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor191"/>UI Design with the GUIE</h2>
<p>As always, the latest documentation on the Babylon.js GUIE can be found at <a href="https://doc.babylonjs.com/toolsAndResources/tools/guiEditor">https://doc.babylonjs.com/toolsAndResources/tools/guiEditor</a>, but some basic principles are still <a id="_idIndexMarker652"/>worth going over. The top-most horizontal menu, featuring the <em class="italic">hamburger</em> icon, has controls for managing the zoom level, copying and pasting controls, and more. </p>
<p>Clicking on empty space in the navigation panel displays the properties for the ADT. These are used to render the layout canvas in addition to buttons for loading and saving the GUI in various formats. The following screenshot contains, from right to left, the different areas of the GUI editor – the navigation tree, layout canvas, and property panes, respectively:</p>
<div><div><img alt="Figure 9.2 – The GUIE’s three primary workspace areas, from left to right: navigation panel, layout canvas, and property pane. The layout shows the currently selected layoutGrid container element. Source: https://gui.babylonjs.com/#923BBT#37" height="942" src="img/Figure_9.2_B17866.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The GUIE’s three primary workspace areas, from left to right: navigation panel, layout canvas, and property pane. The layout shows the currently selected layoutGrid container element. Source: <a href="https://gui.babylonjs.com/%23923BBT%2337">https://gui.babylonjs.com/#923BBT#37</a></p>
<p>The control tree can be seen on the left-hand navigation pane, separated from the layout canvas by the vertical list of control icons available to insert. Probably one of the more important sets of these controls is going to be the various types of containers. </p>
<p>From <strong class="bold">StackPanels</strong> to <strong class="bold">Grids</strong> with a sprinkling of <strong class="bold">ScrollViewers</strong> and <strong class="bold">Rectangles</strong> to round things out, the container elements behave exactly as you may expect them to if you are accustomed to the concepts. The GUI shown in <em class="italic">Figure 9.2</em> is a simple dialog box design, with content broken out into the three separate rows of the layoutGrid Grid Control. That <a id="_idIndexMarker653"/>control, in turn, is contained within the Rectangle dialogBorder, which is contained within the dialogRoot Container for the entire UI. </p>
<p>If you’re not familiar with containers and their behavior, a review of the BJS Docs section on containers might be worth a quick (and informative!) read at <a href="https://doc.babylonjs.com/divingDeeper/gui/gui#containers">https://doc.babylonjs.com/divingDeeper/gui/gui#containers</a>. Resizing and laying out visual elements can be done by dragging around handles in the visual layout pane or by directly setting properties to specific values – use the former to get an approximation and the latter to “dial in” to pixel-perfect precision! </p>
<p class="callout-heading">Note</p>
<p class="callout">The current list of supported controls and links to their associated documentation sections can be found at <a href="https://doc.babylonjs.com/toolsAndResources/tools/guiEditor#supported-controls">https://doc.babylonjs.com/toolsAndResources/tools/guiEditor#supported-controls</a>.</p>
<p>Row indices start at zero, so the middle row is row number one and contains the primary content of the dialog. The following diagram illustrates how the layoutGrid’s three rows allocate 25%, 50%, and 25% of the available height between them, respectively:</p>
<div><div><img alt="Figure 9.3 – A simplified view of the layoutGrid and its child controls. The top and bottom rows each get 25% of the available height, while the middle row is allocated the remaining 50% of the available height at render time&#13;&#10;" height="1310" src="img/Figure_9.03_B17866.jpg" width="1389"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – A simplified view of the layoutGrid and its child controls. The top and bottom rows each get 25% of the available height, while the middle row is allocated the remaining 50% of the available height at render time</p>
<p>Let’s go through the rows in turn. The first row contains the <code>titleText</code> control; as its name suggests, it is exactly what it seems like it is – a container for displaying the dialog’s title heading. The second, middle row contains the primary display content and therefore needs <a id="_idIndexMarker654"/>the most room for its scroll viewer (to allow arbitrarily long or wide child content – a useful quality to note for later…) and its own <code>userCancel</code> and <code>userAccept</code> buttons. These will be hooked up to click logic in the next section and will be spaced using relative (percentage) positioning to ensure the buttons stick to their respective sides.</p>
<p class="callout-heading">Note</p>
<p class="callout">HTML/CSS folks are probably angrily wondering why we’re not using columns and span cells, or a justified alignment with a horizontal StackPanel. Those would indeed be wonderful approaches – if cell spanning or full justification alignment were available, but as they are not (at the time of writing), alternative approaches must be sought!</p>
<p>The final stop on our GUIE tour is less of a feature of the editor and more of a very strongly <a id="_idIndexMarker655"/>recommended workflow practice of naming the controls in the tree:</p>
<div><div><img alt="Figure 9.4 – Control tree structure with named controls. Having clear, indicative names is crucial to effectively integrating the GUIE with applications. The child elements of the layoutGrid Grid container display their respective [row:column] indices in the tree&#13;&#10;" height="582" src="img/Figure_9.4_B17866.jpg" width="402"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Control tree structure with named controls. Having clear, indicative names is crucial to effectively integrating the GUIE with applications. The child elements of the layoutGrid Grid container display their respective [row:column] indices in the tree</p>
<p>If you have read a certain type of genre fantasy, then you will know that having the name of something gives one power over the thing being named, and our GUI control tree is no different! Our integration pattern for combining the GUI definition with JavaScript logic will hinge on using the power of a control’s name to summon it forth when needed, but instead of relying on magic spells and summoning circles, we’ll see how to <a id="_idIndexMarker656"/>use <code>Control.findByName</code> as part of the tidy integration options made possible by features in both the Babylon.js GUI and its core framework!</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor192"/>Integration with the GUIE</h2>
<p>It’s time to move past the GUIE and see how we can make use of its output in a simple Playground <a id="_idIndexMarker657"/>setting. The Playground at https://playground.babylonjs.com/#WIVN8Z#6 is what we’ll be using as the starting point for this <a id="_idIndexMarker658"/>section; we’ll build it out and finish it up in the next section; that is, <em class="italic">Building a Reusable Dialog Box Component</em>. For now, let’s run the Playground and click or tap anywhere in the display area to summon a Dialog Box. Clicking one of the buttons will either dismiss or spawn a new dialog box, depending on which is clicked.</p>
<p>Now, let’s focus on the <code>createScene</code> function. It’s very short – under 40 lines of code, with most of the code devoted to subscribing to various Observables of the <code>DialogBox</code> component and the scene’s <code>onPointerObservable</code>. Defining the initial dialog <code>opts</code> object and creating the <code>DialogBox</code> instance rounds out the scene creation logic of our Playground, leaving us free to focus our attention on how to convert the <code>const DIALOG_GUI_SNIPPET = "923BBT#32"</code> line into an interactive component, bringing us one step closer to seeing how <code>DialogBox</code> works. </p>
<p>Right above the <code>DialogBox</code> class definition – line 60 – is where the <code>CONTROL_NAMES</code> constant is defined: </p>
<pre class="source-code">&#13;
const CONTROL_NAMES = Object.freeze({&#13;
    cancel: 'userCancel',&#13;
    accept: 'userAccept',&#13;
    titleText: 'titleText',&#13;
    bodyText: 'dialogText',&#13;
    acceptText: 'userAcceptText',&#13;
    cancelText: 'userCancelText',&#13;
    dialog: 'dialogBorder',&#13;
    bodyScrollViewer: 'bodyContainer',&#13;
    bodyStackPanel: 'bodyStackPanel',&#13;
});</pre>
<p>Recall when we mentioned the importance of names. This is where that discussion becomes important! It also becomes the only place in our code that needs to know anything specific about how our GUI is structured, allowing us to modify our GUI to a certain extent without the need to make corresponding changes to our application code. </p>
<p>OK – now, we have a map of control names that we can use to access controls via code, but we haven’t <a id="_idIndexMarker659"/>loaded up anything for our code to access yet. We’ll need to create an instance of an <code>AdvancedDynamicTexture</code> – fullscreen mode is fine – and we also want to make sure that the text and lines are crisp and sharp at whatever size it ends up being rendered:</p>
<pre class="source-code">&#13;
this.advancedTexture = AdvancedDynamicTexture&#13;
     .CreateFullscreenUI("dialog", false, scene,&#13;
          Texture.NEAREST_NEAREST, true);</pre>
<p>Using <code>NEAREST_NEAREST</code> as the sampling method when scaling the texture gives the best results for text while the <code>true</code> flag for the last parameter enables adaptive scaling for a nice look whatever the scale. Now that we have something to host the GUI, it’s time to go ahead and load said GUI into the ADT.</p>
<p>Because we want to use <code>DIALOG_GUI_SNIPPET</code> as the source to load our GUI from, we’ll need to use the <code>parseFromSnippetAsync</code> method from an instance of <code>AdvancedDynamicTexture</code>. Since the function is asynchronous, this means we can await its completion from an appropriately marked <code>async</code> function:</p>
<pre class="source-code">&#13;
this.scene.executeWhenReady(async () =&gt; {&#13;
     await this.advancedTexture&#13;
           .parseFromSnippetAsync(DIALOG_GUI_SNIPPET,&#13;
             false);&#13;
     this.dialogContainer.isVisible = false;</pre>
<p>Once <code>advancedTexture</code> has completed loading the GUI definition from the snippet server (and, in the preceding case, opting out of rescaling the texture), it can be accessed from <code>advancedTexture.getControlByName()</code>. To avoid repetition in our code, we can define property accessors in a class or object to wrap the logic for getting or setting these control values:</p>
<pre class="source-code">&#13;
get dialogContainer() {&#13;
    return this.advancedTexture&#13;
           .getControlByName(CONTROL_NAMES.dialog);&#13;
}&#13;
get titleText() {&#13;
    let ctrl = this.advancedTexture&#13;
            .getControlByName(CONTROL_NAMES.titleText);&#13;
    return ctrl.text;&#13;
}&#13;
set titleText(value) {&#13;
    let ctrl = this.advancedTexture&#13;
            .getControlByName(CONTROL_NAMES.titleText);&#13;
    ctrl.text = value;&#13;
}</pre>
<p>In the preceding code, there are two examples of retrieving a control, as well as a control’s text <a id="_idIndexMarker660"/>value. Additionally, the final property shows a similar process for setting the text value of the <code>titleText</code> control. These property accessors and others like them form a core part of the <code>DialogBox</code> class, which is the topic of the next section. </p>
<p>The <code>AdvancedDynamicTexture.getControlByName</code>. </p>
<p>Now, using this combination of tools, data, and code, it’s time to put theory into practice. We need an easier way to implement the concept of a dialog box in our application, and there are at least two places that need dialog box functionality – route confirmation and scoring. This problem speaks to the need to build something once that can be used in multiple situations.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor193"/>Building a Reusable Dialog Box Component</h1>
<p>A reusable component is capable of utilization in multiple places and contexts within a particular <a id="_idIndexMarker663"/>code base. Designing a reusable component is different from designing a single-purpose one in several ways. The most relevant one of these ways is that the reusable component’s functionality must be designed to be customizable by users without the basic code needing to be reinvented for it to be worked with. </p>
<p>We examined parts of <code>DialogBox</code> previously when we looked at how to wrap <code>advancedTexture.getControlByName</code> in a get or set accessor, so let’s build off that to make an important reminder/note.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The <code>CONTROL_NAMES</code> enumeration lists all the properties implemented by the <code>DialogBox</code> class, but there are more properties than there are controls. Getting or setting a property such as <code>titleText</code> or <code>bodyText</code> operates against a text control’s <code>text</code> property directly.</p>
<p>The key parts of our component are going to be the initialization (construction) logic, which is important because it needs to parse the GUI data, entrance, and exit management, and event handling things such as button clicks. After examining how each of these works, we’ll put the individual pieces together to build the route confirmation dialog prompt.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor194"/>Constructing the DialogBox Class</h2>
<p>The constructor function for the <code>DialogBox</code> class accepts an options object and a Scene instance <a id="_idIndexMarker664"/>as its two <a id="_idIndexMarker665"/>parameters. These parameters are mostly for pre-populating the dialog box’s content, but the <code>displayOnLoad</code> parameter is a behavioral flag that instead controls whether or not <code>DialogBox</code> is supposed to be visible when it’s finished loading and initializing. When the value is <code>false</code>, then the <code>show()</code> method must be explicitly invoked to display the dialog:</p>
<pre class="source-code">&#13;
const {&#13;
  bodyText, titleText,&#13;
  <strong class="bold">displayOnLoad</strong>, acceptText,&#13;
  cancelText&#13;
} = options; //...later...&#13;
if (bodyText) { this.bodyText = bodyText; }&#13;
this.titleText = titleText ?? "Space-Truckers: The Dialog&#13;
  Box";&#13;
this.acceptText = acceptText ?? "OK";&#13;
this.cancelText = cancelText ?? "Cancel";</pre>
<p>The constructor logic ensures that the dialog box will have any required pieces of content populated, even if they’re not specified by the caller. Previously, we looked at the creation of <code>AdvancedDynamicTexture</code>, along with how to populate the GUI elements using <code>parseFromSnippetAsync</code>. This is a pattern that we’re using for the Playground to load from the snippet server. For the application, we will load a JSON file defining the UI using <code>advancedTexture.parseContent()</code> – a non-async method that also obviates the need to run the initialization logic in the callback from <code>scene.executeWhenReady</code>, which we used in the Playground. This is the only meaningful difference between our Playground’s <code>DialogBox</code> class and what will eventually end up in the Space-Truckers Application. This highlights the power of iterative code design using the PG!</p>
<p>The rest of the constructor is devoted to subscribing to and wiring the subcomponents of the <code>DialogBox</code> class. Our two buttons have their click event handlers wrapped by the class and the respective <code>onAcceptedObservable</code> and <code>onCancelledObservable</code>:</p>
<pre class="source-code">&#13;
this.#acceptPointerObserver =&#13;
  this.acceptButton.onPointerClickObservable&#13;
    .add(async (evt) =&gt; {&#13;
        await this.onAccepted();&#13;
        this.onAcceptedObservable.notifyObservers();&#13;
    });&#13;
this.#cancelPointerObserver =&#13;
  this.cancelButton.onPointerClickObservable&#13;
    .add((evt) =&gt; {&#13;
        await this.onCancelled();&#13;
        this.onCancelledObservable.notifyObservers();&#13;
    });&#13;
this.scene.onDisposeObservable.add(() =&gt; {&#13;
    this.dispose();&#13;
});</pre>
<p>To avoid leaking resources, we are capturing the Observers that have been returned from the <a id="_idIndexMarker666"/>subscription <a id="_idIndexMarker667"/>methods in non-public class members (denoted with the <code>#</code> prefix), which we clean up in the <code>dispose</code> method:</p>
<pre class="source-code">&#13;
dispose() {&#13;
    if (this.#showTimer) {&#13;
        this.#showTimer = null;&#13;
    }&#13;
    this.onAcceptedObservable?.clear();&#13;
    this.onAcceptedObservable?.cancelAllCoroutines();&#13;
    this.onCancelledObservable?.clear();&#13;
    this.onCancelledObservable?.cancelAllCoroutines();&#13;
    this.advancedTexture?.clear();&#13;
} </pre>
<p>Any ongoing asynchronous operations must be canceled along, with any coroutines (see the <em class="italic">Creating the Scoring Dialog with Coroutines</em> section for a definition). The <code>createScene</code> function of our Playground demonstrates how this works when the initial <a id="_idIndexMarker668"/>confirmation <code>DialogBox</code> is <a id="_idIndexMarker669"/>disposed of in the <code>onAccept</code> handler, spawning a new <code>DialogBox</code> in its place.</p>
<p>Our basic <code>DialogBox</code> defines two explicit interaction points with users: the accept and cancel buttons. It also defines two behaviors: show and hide. Next, we’ll learn how the two relate to each other and how to make the show and hide methods complete only after the <code>DialogBox</code> class has finished transitioning.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor195"/>Handling Button Clicks and Changing Visibility</h2>
<p>In addition <a id="_idIndexMarker670"/>to handling the <code>acceptButton</code> and <code>cancelButton</code> click events, the <code>onAccepted</code> and <code>onCancelled</code> functions <a id="_idIndexMarker671"/>both offer customizers for the <code>DialogBox</code> class to run custom logic before notifying external observers of the event – the default behavior shows this by hiding the dialog before triggering the Observable:</p>
<pre class="source-code">&#13;
    onAccepted() {&#13;
        return this.hide();&#13;
    }&#13;
    onCancelled() {&#13;
        return this.hide();&#13;
    }</pre>
<p>Both <code>onAccepted</code> and <code>OnCancelled</code> return a <code>Promise</code> that resolves when the dialog box has finished hiding itself. If the caller cares about waiting for the dialog to fully <a id="_idIndexMarker672"/>show or hide itself, it can either <a id="_idIndexMarker673"/>use the standard async or Promise resolution patterns – that is, <code>await myDialog.show()</code> or <code>myDialog.hide().then(…)</code>. As for the logic to show or hide <code>DialogBox</code>, it uses the <code>BABYLON.setAndStartTimer</code> utility function to trigger the fade-in or fade-out of the <code>DialogBox</code> class in conjunction with the <code>Scalar.SmoothStep</code> function (note that some code has been elided in the following listing for space reasons):</p>
<pre class="source-code">&#13;
return new Promise((resolve, reject) =&gt; {&#13;
   this.dialogContainer.alpha = 1;&#13;
   this.#showTimer = setAndStartTimer(&#13;
   {&#13;
       timeout: this.#fadeInTransitionDurationMs,&#13;
       onTick: (d) =&gt; this.dialogContainer.alpha = Scalar&#13;
                      .SmoothStep(0.998, 0, d.completeRate),&#13;
       onEnded: () =&gt; {&#13;
           this.advancedTexture.isForeground = false;&#13;
           this.dialogContainer.isVisible = false;  &#13;
           resolve();&#13;
        },&#13;
        breakCondition: this.dialogContainer == null&#13;
     });&#13;
   }&#13;
});</pre>
<p>In the preceding code, most of the action happens in the <code>onTick</code> and <code>onEnded</code> callbacks of the <code>setAndStartTimer</code> option. The dialog starts with an alpha of <code>1</code> and ends after <a id="_idIndexMarker674"/>a period of <code>#fadeInTransitionDurationMs</code> (800 ms or so) with an alpha of <code>0</code>. In between, values <a id="_idIndexMarker675"/>are interpolated using the <code>onTick</code> argument’s <code>completeRate</code>, giving a value from <code>0</code> to <code>1</code> regarding how far the timer has progressed to finishing. </p>
<p>The <code>onEnded</code> callback removes the <code>DialogBox</code> class from foreground rendering (see <em class="italic">The Advanced Dynamic Texture</em> section, earlier in this chapter) and sets the GUI’s <code>isVisible</code> to <code>false</code> before resolving the original Promise. On the other hand, <code>breakCondition</code> ensures that if the <code>DialogBox</code> instance is disposed of before completing the hide or show animation, the timer won’t attempt to call disposed of objects. </p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>show()</code> function is almost identical to the <code>hide()</code> function, except that it is more like a mirror inverse image than it is a clone. This is because it starts as being fully transparent and ends up being completely hidden. </p>
<p>Let’s review how to use the <code>DialogBox</code> class in five easy steps:</p>
<ol>
<li>Create an <code>opts</code> object containing, at a minimum, a <code>guiData</code> field containing a snippet ID:     <pre>let opts = {
    bodyText: "Your flight plan appears to be viable!"
        + '\n'
        + "Would you like to file it with Space-
          Truckers Traffic Control (STC)?",
    titleText: 'Route Planning Success',
    displayOnLoad: false,
    acceptText: 'Launch!',
    cancelText: 'Retry',
    guiData: DIALOG_GUI_SNIPPET // e.g., "923BBT#32"
};</pre></li>
<li>Instantiate <a id="_idIndexMarker676"/>a new instance <a id="_idIndexMarker677"/>of <code>DialogBox</code>, passing in the previously created <code>opts</code> object and a reference to the Scene:<pre>let dialog = new DialogBox(opts, scene);</pre></li>
<li>Attach observers to the dialog box’s <code>onAcceptedObservable</code> and <code>onCancelledObservable</code> to respond to user input (in this case, calling <code>createScoringDialog</code>):<pre>dialog.onAcceptedObservable.add(async () =&gt; {
        dialog.dispose();
        dialog = createScoringDialog(null, scene);
});
dialog.onCancelledObservable.add(()=&gt;console.log
  ('cancelled'))</pre></li>
<li>Call the <code>show</code> method to display the <code>DialogBox</code> class if the (optional) <code>displayOnLoad</code> flag is not set to <code>true</code>:<pre>dialog.show();</pre></li>
<li>To dismiss or hide the dialog, click <code>cancelButton</code> or call the <code>hide()</code> function. To defer action until the <code>DialogBox</code> class has completely faded out, the Promise that’s returned from <code>hide</code> can be awaited:<pre>await dialog.hide();</pre></li>
</ol>
<p>With our reusable <code>DialogBox</code> completed in proof-of-concept form, let’s quickly look at the practice of integrating with the Space-Truckers Application by looking at how the route <a id="_idIndexMarker678"/>planning screen uses it to <a id="_idIndexMarker679"/>prompt the player to move to the next phase of gameplay.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor196"/>Prompting Users after Successful Route Planning</h2>
<p>Not too many changes need to be made to the <code>DialogBox</code> class from the Playground. However, as <a id="_idIndexMarker680"/>mentioned in the <em class="italic">Constructing the DialogBox Class</em> section, we’ll be changing from using a snippet loaded from a remote server to a JSON file loaded from the game’s assets folder.</p>
<p>After saving the GUI JSON definition from the GUIE, the definition is added to the <code>/src/guis</code> folder as <code>gui-dialog-buttons-scroll.json</code>. One important change is needed, though, so open up the file and find any external resources (*<code>.png</code>) to change their URLs from absolute to relative ones pointing to the appropriate file in the <code>assets</code> folder. For example, the image that’s used as the <code>DialogBox</code> background will look like this after being modified:</p>
<pre class="source-code">&#13;
"source":"/assets/menuBackground.png"</pre>
<p>The <code>DialogBox</code> class itself is housed next door to the GUI JSON, in <code>guiDialog.js</code>, and as per our change from the snippet server to JSON, we must add that import to the top of the file before passing it into the <code>DialogBox</code> constructor as the <code>guiData</code> property value:</p>
<pre class="source-code">&#13;
import <strong class="bold">stackedDialog</strong> from "./gui-dialog-buttons-&#13;
  scroll.json";&#13;
// later…&#13;
this.advancedTexture.parseContent(<strong class="bold">stackedDialog</strong>, false);</pre>
<p>Pivoting to <code>SpaceTruckerPlanningScreen</code>, we need to add an <code>import</code> for <code>DialogBox</code> to the file:</p>
<pre class="source-code">&#13;
import DialogBox from "../guis/guiDialog";</pre>
<p>A new <code>routeConfirmationDialog</code> attribute has been added to <code>SpaceTruckerPlanningScreen</code>, initialized near the end of the constructor function with logic that should be very familiar if you have read the entirety of this chapter thus far:</p>
<pre class="source-code">&#13;
this.routeConfirmationDialog = new DialogBox({&#13;
    bodyText: 'Successful route planning! Use route and&#13;
      launch?',&#13;
    titleText: 'Confirm Flight Plan',&#13;
    acceptText: 'Launch!',&#13;
    cancelText: 'Reset',&#13;
    displayOnLoad: false&#13;
}, this.scene);&#13;
this.routeConfirmationDialog.onAcceptedObservable.add(() =&gt;&#13;
  {&#13;
    this.routeAcceptedObservable.notifyObservers();&#13;
    this.gameState = PLANNING_STATE.RouteAccepted;&#13;
    this.routeConfirmationDialog.hide();&#13;
});&#13;
this.routeConfirmationDialog.onCancelledObservable.add(()&#13;
  =&gt; {&#13;
    this.routeConfirmationDialog.hide();&#13;
    this.setReadyToLaunchState();&#13;
});</pre>
<p>Now, there is no doubt that the actual copy used in the confirmation dialog box could use some work, but it does the job for now – maybe you’ll be the one to submit a Pull Request to change it to something a bit more interesting? </p>
<p>On the topic of interesting, the <code>onAcceptedObservable</code> handler for the dialog does several <a id="_idIndexMarker681"/>interesting things. First, it notifies any interested parties that the player has accepted the route. Then, it updates <code>gameState</code> to reflect the new reality before hiding <code>routeConfirmationDialog</code> and allowing whatever logic is subscribed to <code>routeAcceptedObservable</code> to take things from that point. This is not too different from the Playground example, and not too much time is needed to get that up and <a id="_idIndexMarker682"/>running either! We’ll want to hold onto that feeling for now though because next, we’re going to be making a series of targeted changes to the application to gather, process, and calculate scoring data for the game.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor197"/>Calculating Scores</h1>
<p>Much of the fun that comes from playing a game is through the different ways that a game can provide feedback to the player – positive or negative. This is a great opportunity for <a id="_idIndexMarker683"/>game designers to connect with players at an emotional level. Connecting positive events and outcomes to a player’s actions creates a feedback loop between the game and the player, and one of the oldest and truest connections in gaming is the concept of a point score that accumulates throughout gameplay. </p>
<p>The scoring system used in <code>DialogBox</code> that is initially empty, but which displays each category of scores in a line-by-line fashion before giving the final score. </p>
<p>Before building out the logic to capture and calculate scores, it’s useful to define the desired scoring data model in a sample score. This is the desired output of the scoring process logic, irrespective of how that logic generates the data. This will clue us into what sorts of changes are needed elsewhere in the application to support the scoring system.</p>
<h2 id="_idParaDest-197"><a id="_idTextAnchor198"/>Scoring System Design</h2>
<p>The score data that is generated and used by <strong class="bold">Space-Truckers</strong> can be broken down into three broad groups: <strong class="bold">score factors</strong>, <strong class="bold">multipliers</strong>, and <strong class="bold">final scores</strong>. Score factors are categories <a id="_idIndexMarker684"/>reflecting base attributes of both route planning and driving performance. The number of encounters, length of the route, and initial launch force are all fixed and set in the Route Planning Phase, but the cargo condition is dynamic up until the player reaches their destination in the driving phase (sample values have been provided for context):</p>
<pre class="source-code">&#13;
scoreFactors: {&#13;
    routeLength: 12450.25,&#13;
    cargoCondition: 0.768,&#13;
    encounters: 125,&#13;
    launch: 100.00&#13;
},&#13;
multipliers: {&#13;
    transitTime: { expected: 180, actual: 150, factor: 1.2  },&#13;
    delivery: 1.0,&#13;
    condition: 0.768,&#13;
    encounterTypes: 1.05&#13;
},&#13;
finalScores: {&#13;
    'Base Delivery': 1000,&#13;
    'Route Score': 14940,&#13;
    'Cargo Score': 11474,&#13;
    'Delivery Bonus': 10000,&#13;
    'Encounters': 1312,&#13;
    'Final Total': 38726&#13;
}</pre>
<p>Below <code>scoreFactors</code> are the multipliers. These values are used by the scoring calculations to <a id="_idIndexMarker685"/>modify one or more <code>scoreFactors</code> in various ways that we’ll get into in the next section, <em class="italic">Adding Up and Tallying Scores</em>. However, before we move on, there’s just one more thing to do. One last – you may even say final – section to cover. <code>finalScores</code> are the categorized and summed up values that come out of the combination of <code>scoreFactor</code> and multipliers. This is what will ultimately be displayed to the players in a “here’s the bottom line…” type of fashion. </p>
<p>Continuing to ignore <a id="_idIndexMarker686"/>any sort of details on how the scoring data is captured is still a useful tactic because although we may know the general shape of the scoring data, until we know how to calculate those scores, we won’t know precisely what and where data needs to be captured. </p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor199"/>Adding Up and Tallying Scores</h2>
<p>The scoring <a id="_idIndexMarker687"/>logic is contained within the <code>src/scoring/spaceTruckerScoreManager.js</code> file. Similar to how we are compartmentalizing <a id="_idIndexMarker688"/>using the sample score shown previously, consumers of this component only need to call the default export <code>computeScores</code> and pass in a route data structure to get a <code>score</code> object in return. The <code>computeScores</code> function is a simple orchestration function – its only purpose is to coordinate the invocation of the various other functions that are calculating the individual scoring areas:</p>
<pre class="source-code">&#13;
let computeScores = function (route) {&#13;
    let score = createDefaultScoring();&#13;
    calculateEncounterScoreToRef(route, score);&#13;
    calculateRouteScoreToRef(route, score);&#13;
    calculateCargoScoreToRef(route, score);&#13;
    calculateBonusScoreToRef(route, score);&#13;
    calculateFinalScoreToRef(score);&#13;
    console.log(score);&#13;
    return score;&#13;
}</pre>
<p>The <code>createDefaultScoring</code> function in the second line of the preceding listing is a <code>0</code> or blank values. As the <code>score</code> object is passed between each of the various <code>calculateXXXScoreToRef</code> methods, its values are built up and used by successive function calls. </p>
<p>The <code>ToRef</code> suffix on these function names indicates that they will be mutating a parameter (usually the last parameter provided by convention) rather than creating a new instance of one. This is most seen with <code>Vector</code> and <code>Matrix</code> objects but consistency in <a id="_idIndexMarker689"/>naming is crucial to the long-term health of a code base! Following that <a id="_idIndexMarker690"/>are individual subsections that go through the details of each aspect of the scoring calculations. </p>
<p>Because we’re still in the development process, we’re not going to worry too much about getting these calculations balanced and tweaked to the extent we may want. What we need to do is establish a basic way to provide a dynamic scoring experience that is easy to come back to later when we’re ready to balance and tweak. </p>
<h3>Encounter Scores</h3>
<p>We start by calculating the encounter score. Right off, we know that we want to get a list of encounters <a id="_idIndexMarker691"/>and that we will want to use that list to add up the individual modifiers for each encounter to get the final encounter modifier. If we assume that the route parameter contains a <code>pathPoints</code> object collection (see the <code>/src/driving/spaceTruckerDrivingScreen.calculateRouteParameters</code> function for details) and that any given entry in the <code>pathPoints</code> collection may or may not have an associated encounter containing a decimal <code>scoreModifier</code> value, then we can use a simple <code>map</code> and <code>reduce</code> operation:</p>
<pre class="source-code">&#13;
const { pathPoints } = route;&#13;
const encounters = pathPoints&#13;
    .<strong class="bold">map</strong>(p =&gt; p.encounter)&#13;
    .filter(e =&gt; e);&#13;
scoreFactors.encounters = encounters.length;&#13;
let encounterModifier = &#13;
    1 + encounters.<strong class="bold">map</strong>(e =&gt; e.scoreModifier)&#13;
        .<strong class="bold">reduce</strong>((prev, curr, cidx, arr) =&gt; {&#13;
            return prev + curr;&#13;
        });&#13;
multipliers.encounterTypes = encounterModifier;&#13;
let encounterScore = 100 * encounters.length * &#13;
  multipliers.encounterTypes;&#13;
finalScores['Encounters'] = encounterScore;</pre>
<p>The preceding code calls <code>map</code> with a simple extraction function that retrieves the <code>scoreModifier</code> value – a number. Next, it passes the array of <code>scoreModifier</code> numbers to the <code>reduce</code> function. <code>Array.reduce</code> (if you aren’t already familiar with it) is a useful aggregation tool that takes a function as its primary parameter. Looping (or iterating) over the <a id="_idIndexMarker692"/>array, <code>arr</code>, the function is invoked for each <code>curr</code> element in turn, with the results of the <code>prev</code> operation being passed along with the value of the <code>curr</code> element at the <code>cidx</code> position. This is just a fancy way of saying that the <code>reduce</code> operation sums up the total of all the elements in an array of numbers! This aggregated value becomes <code>encounterModifier</code>, which is used in conjunction with the overall number of encounters to determine the total encounters score value. </p>
<h3>Route Scores</h3>
<p>Route scoring calculations are performed slightly differently from encounter scoring. The main factor for route <a id="_idIndexMarker693"/>scoring is the length of the overall route (how far the cargo had to travel before arriving), but there are several equally important modifiers. When it comes to <code>transitTime</code> of the route, there are two relevant values: the planned transit time and the actual (driving phase) transit time. The ratio between those values, when added to a constant, gives us <code>transit.factor</code>, an important multiplier that’s used in two ways. First, it is applied to <code>distanceTraveled</code>; after it is applied to the <code>launchForce</code> value, which is used during the Route Planning Phase. The first is subtracted from the second to produce the final Route Score value: </p>
<pre class="source-code">&#13;
transit.factor = 0.5 + route.transitTime /&#13;
  route.actualTransitTime;&#13;
finalScores['Route Score'] = &#13;
(route.distanceTraveled * transit.factor) – &#13;
(route.launchForce * transit.factor);</pre>
<h3>Cargo Scores</h3>
<p>Cargo scoring is based primarily on the condition of the cargo upon arrival, meaning that it reflects player <a id="_idIndexMarker694"/>performance from the Driving phase. The cargo starts with a condition value of 100. When collisions with encounters or with sufficient velocity occur, the route path can reduce that value (see the <em class="italic">Capturing Scoring Data</em> section for more), which is used as the basis for the Cargo Score after it’s been scaled by the condition multiplier:</p>
<pre class="source-code">&#13;
const { cargoCondition } = route;&#13;
scoreFactors.cargoCondition = cargoCondition;&#13;
let cargoScore = 10 * cargoCondition *&#13;
  multipliers.condition;&#13;
finalScores['Cargo Score'] = cargoScore;</pre>
<h3>Bonus Scoring</h3>
<p>If the player <a id="_idIndexMarker695"/>delivers their cargo in pristine condition, extra rewards are in order. In that case, the Delivery Bonus is applied to <code>finalScores</code>:</p>
<pre class="source-code">&#13;
if (route.cargoCondition &gt;= 100) {&#13;
   s.finalScores['Delivery Bonus'] = DELIVERY_BONUS;&#13;
} else { s.finalScores['Delivery Bonus'] = 0;}</pre>
<h3>Final Scoring</h3>
<p>Once all the various <a id="_idIndexMarker696"/>sub-scores have been tallied and multiplied, it’s time to sum them all up to get our total value. After populating with <code>BASE_DELIVERY_SCORE</code>, we use <code>Object.values</code> to produce an array of numbers that we (sound familiar?) pass to another <code>reduce</code> operation to give the <code>Final Total</code> score value:</p>
<pre class="source-code">&#13;
let { finalScores } = score;&#13;
finalScores['Base Delivery'] = BASE_DELIVERY_SCORE;&#13;
let finalScore = Object.values(finalScores)&#13;
  .reduce((prev, curr) =&gt; prev + Number(curr));&#13;
score.finalScores['Final Total'] = finalScore;</pre>
<p>Putting these <a id="_idIndexMarker697"/>computations together helps give us an idea of what data is already available in the route and what needs to be collected. There’s more information about a game session than just the route path, after all!</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor200"/>Capturing Scoring Data</h2>
<p>With the sample scoring data serving as a guide, we can work backward to identify the places in the <a id="_idIndexMarker698"/>application where scoring data is generated before capturing it. This may result in the need to update or change existing data structures and code, but that’s OK because we will also make the needed changes to allow players to complete the driving phase and see their final scores displayed in their full glory! </p>
<h3>Enriching the Route Data</h3>
<p>The first and <a id="_idIndexMarker699"/>possibly the biggest change is that we’ve added a new <code>routeData</code> property to <code>SpaceTruckerPlanningScreen</code>, which packages up all data needed by the scoring calculations later in the game (see the <em class="italic">Adding Up and Tallying Scores</em> section for more):</p>
<pre class="source-code">&#13;
    get routeData() {&#13;
        return {&#13;
            route: this.cargo.routePath,&#13;
            launchForce: this.launchForce,&#13;
            transitTime: this.cargo.timeInTransit,&#13;
            distanceTraveled: this.cargo.distanceTraveled&#13;
        }&#13;
    }</pre>
<p><code>routePath</code> of the <code>Cargo</code> object tracks encounters and other path-specific data, while the other values <a id="_idIndexMarker700"/>provide a baseline travel time and the length of the route. Encounters were already being captured as part of <code>cargoData</code> associated with the encounter, but the additional <code>scoreModifier</code> field is needed for every encounter listed in the <code>route-planning/gameData.js</code> file:</p>
<pre class="source-code">&#13;
{&#13;
   name: 'Rock Hazard',&#13;
   id: 'rock_hazard',&#13;
   image: hazard_icon,&#13;
   probability: 0.89,&#13;
   <strong class="bold">scoreModifier: 0.019</strong>&#13;
}</pre>
<p>There’s still more to do, but this completes the data collection aspect of scoring. Next, we need to add a trigger that will initiate the scoring process (provided the player has finished the route…) and show the Scoring Dialog.</p>
<h3>Completing the Driving Phase</h3>
<p>So far, the <code>SpaceTruckerDrivingScreen.killTruck</code> function has indiscriminately <a id="_idIndexMarker701"/>performed the grim responsibilities implied in its name. Today, though, is different. Today, the Grim Reaper of trucks gets a conscience:</p>
<pre class="source-code">&#13;
let closestPathPosition =&#13;
  path3d.getClosestPositionTo(mesh.absolutePosition);&#13;
// not close enough!&#13;
if (closestPathPosition &lt; 0.976) {&#13;
    this.reset();&#13;
    return;&#13;
}&#13;
this.completeRound();</pre>
<p>When the method is called by the <code>onMeshIntersectExit</code> action trigger, it checks the absolute (World reference) position of the mesh against the closest Path3D segment of the route. See <a href="B17266_08_Final_AM.xhtml#_idTextAnchor166"><em class="italic">Chapter 8</em></a>, <em class="italic">Building the Driving Game</em>, the <em class="italic">Generating the Driving Path</em> section for more on Path3D and how it relates to the route path.</p>
<p class="callout-heading">Note</p>
<p class="callout">Path3D exposes positions as a normalized route with positions between 0 (beginning) and 1 (end).</p>
<p>Should the truck happen to exit its route path (thus triggering this method) too far from its destination, the Grim Task of reaping continues as it did in the past. Let’s not dwell on the past and <a id="_idIndexMarker702"/>instead look to the alternative, happy future that involves calling the <code>completeRound</code> method of the <code>SpaceTruckerDrivingScreen</code> class. The first two things that need to happen are that we want to hide the driving phase GUI, which we do by setting the appropriate <code>layerMask</code> to <code>0</code>. Next, we transition the screen to the <code>DRIVING_STATE.RouteComplete</code> state to prevent further updates to the simulation that may impact scoring, which, speaking of, is what immediately follows:</p>
<pre class="source-code">&#13;
completeRound() {&#13;
    this.gui.guiCamera.layerMask = 0x0;&#13;
    this.currentState = DRIVING_STATE.RouteComplete;&#13;
    this.route.actualTransitTime = this.currentTransitTime;&#13;
    // gather data for score computation&#13;
    let scoring = computeScores(this.route);&#13;
    let scoreDialog = createScoringDialog(scoring, this);&#13;
    scoreDialog.onAcceptedObservable&#13;
     .addOnce(() =&gt;&#13;
       this.onExitObservable.notifyObservers());&#13;
    scoreDialog.onCancelledObservable&#13;
     .addOnce(() =&gt; this.reset());&#13;
    this.scoreDialog = scoreDialog;&#13;
}</pre>
<p>Once the scoring data has been gathered and computed, <code>createScoringDialog</code> (from <code>/src/scoring/scoringDialog.js</code>) is invoked to do the necessary <code>DialogBox</code> creation and management; all that remains for <code>completeRound</code> to do is hook up the <code>onAcceptedObservable</code> and <code>onCancelledObservable</code> properties to the appropriate logic. Then, we are good to go from the standpoint of the driving screen!</p>
<p>The <code>createScoringDialog</code> function is a nice analogy to this book; it starts with the familiar, then mixes <a id="_idIndexMarker703"/>in something completely unexpected and/or unfamiliar as it progresses until, by the end, it seems like everything works by magic. Let’s finish this section by looking at the familiar parts of the function:</p>
<pre class="source-code">&#13;
    let opts = {&#13;
        bodyText: 'Time to earn payday!',&#13;
        titleText: 'The Drayage Report',&#13;
        displayOnLoad: true,&#13;
        acceptText: 'Main Menu',&#13;
        cancelText: 'Retry'&#13;
    };&#13;
    const { scene, soundManager } = drivingScreen;&#13;
    const sound = soundManager.sound('scoring');&#13;
    &#13;
    let scoreDialog = new DialogBox(opts, scene);&#13;
    let dialog = { scoreDialog };&#13;
    dialog.height = "98%";&#13;
    <strong class="bold">let scoringCo = scoringAnimationCo();</strong></pre>
<p>This is slightly different from the Playground at <a href="https://playground.babylonjs.com/%23SQG1LV%2328">https://playground.babylonjs.com/#SQG1LV#28</a>, but only because the PG doesn’t have <code>SpaceTruckerSoundManager</code> to retrieve and manage the sound used by the next section. There’s nothing unusual in this code until the very last line. What a fantastic opportunity as well to introduce one of the more exciting features of Babylon.js v5 – coroutines! </p>
<p>The logic involved in calculating the scores themselves is as simple as possible and no more – it requires nothing but the data passed into it directly to operate, but that data needs to come from <a id="_idIndexMarker704"/>somewhere. The different categories of scores are sourced from different components of the game; encounters contribute to their multiplier, transit times are calculated in both driving and route planning, and the cargo’s health is tracked by the truck during driving. Each of these factors and multipliers contributes to the overall final scores that get displayed in the Scoring Dialog.</p>
<h1 id="_idParaDest-200"><a id="_idTextAnchor201"/>Creating the Scoring Dialog Using Coroutines</h1>
<p>If you have come from a background working with Unity, Unreal, or other game engines, you might <a id="_idIndexMarker705"/>be familiar with the concept of a <a id="_idIndexMarker706"/>coroutine. A coroutine in those contexts is defined much the same way as it is in Babylon.js: a stateful method that runs across multiple frames of rendering. </p>
<p>Though it may imply the presence of multiple threads, typically, in most frameworks (for example, Unity and most certainly JavaScript!), this is not the case. The C# programming language uses Iterators along with the <strong class="bold">yield</strong> keyword to implement coroutines, but in JavaScript, we use a (spoiler alert!) <strong class="bold">function* generator</strong>. Bet no one saw that callback to <a href="B17266_04_Final_AM.xhtml#_idTextAnchor070"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating the Application</em> coming! Instead of using them as part of our application’s state machine, we’re going to define the logic that will make the score dialog’s scoring entries count upwards from zero, along with playing a cash-register type of sound. Lastly, we’ll crank things up to 11 by looking at a standalone Playground sample to show how it’s possible to devise a controller system composed of multiple, independently reusable behaviors.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor202"/>Reviewing Function Generators</h2>
<p>For a more detailed <a id="_idIndexMarker707"/>overview of JavaScript <a id="_idIndexMarker708"/>function generators, see <a href="B17266_04_Final_AM.xhtml#_idTextAnchor070"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating the Application</em>, the <em class="italic">Space-Truckers – The State Machine</em> section. Here’s a quick example of a <code>function</code> generator to help remind us how they work and how to use them. Let’s say that our designers have devised a color palette for printing the rows of a report. We can define a <code>nextColor()</code> star function that will produce a new hex color string at every iteration:</p>
<pre class="source-code">&#13;
function* nextColor() {&#13;
    while (true) {&#13;
        yield "#0d5088";&#13;
        yield "#94342c";&#13;
        yield "#e2ba77";&#13;
        yield "#787b6d";&#13;
    }&#13;
}&#13;
let colorPicker = nextColor();</pre>
<p>When a function is generated by calling <code>nextColor()</code>, it will always produce a color from the list, in order, when requested. Where does this come into play? The <code>createScoringBlock(label)</code> function is responsible for creating and styling the actual GUI element that is displayed in the scoring <code>DialogBox</code>, calling <code>colorPicker.next()</code> to produce a new value each time it is called:</p>
<pre class="source-code">&#13;
// ...inside the createScoringDialog function scope&#13;
// ...inside the function* scoringAnimationCo scope&#13;
function createScoringBlock(label) {&#13;
    let scoreBlock = new TextBlock("scoreLine",&#13;
      `${label}`);&#13;
    scoreBlock.width = "100%";&#13;
    <strong class="bold">scoreBlock.color = colorPicker.next().value;</strong>&#13;
    scoreBlock.textHorizontalAlignment =&#13;
      Control.HORIZONTAL_ALIGNMENT_LEFT;&#13;
    // …snip…&#13;
    return scoreBlock;&#13;
}</pre>
<p>There’s our brief review of <code>function*</code> concepts, all packed up nice and tidy. Now, let’s see how <a id="_idIndexMarker709"/>those fit into coroutines and <a id="_idIndexMarker710"/>Babylon.js by looking deeper into <code>scoringDialog.js</code>, where we’ll unwrap <code>scoringAnimationCo</code> and put it to work in our <code>DialogBox</code>!</p>
<h2 id="_idParaDest-202"><a id="_idTextAnchor203"/>Counting Player Scores with a Coroutine</h2>
<p>Coroutines are <a id="_idIndexMarker711"/>neat because they <a id="_idIndexMarker712"/>allow the developer to express complex behavior via relatively simple logic (when done right). Any time a coroutine wants to return control to the caller, it calls <code>yield</code> – with or without arguments (see the <em class="italic">Advanced Coroutine Usage</em> section). The timing and manner in which a <code>BABYLON.Observable</code> for that CoRo. </p>
<p class="callout-heading">Important note</p>
<p class="callout">New in the Babylon.js v5 Observable API is the <code>Observable.runCoroutineAsync</code> and <code>Observable.cancelAllCoroutines</code> functions. See <a href="https://doc.babylonjs.com/divingDeeper/events/coroutines">https://doc.babylonjs.com/divingDeeper/events/coroutines</a> for more!</p>
<p>If attached to one of the Scene’s render event Observables, the CoRo will run every frame, whenever the host Observable is triggered. If attached to <code>scene.onPointerObservable</code>, the CoRo will fire any time the pointer moves or interacts with the scene. This is incredibly powerful when combined with the way that JavaScript closures work – since an iterator function is a stateful construct, it can remember and track past events and conditions as they evolve over multiple frames of simulation/rendering. </p>
<p>This makes a coroutine ideal for implementing a sort-of “cash register” style of tallying up the player’s scores and presenting the final totals in conjunction with the <code>DialogBox</code> class <a id="_idIndexMarker713"/>created earlier as part <a id="_idIndexMarker714"/>of the <code>createScoringDialog</code> function. The coroutine logic can be deceptively simple: given a score object generated by the Scoring Manager (see the <em class="italic">Adding Up and Tallying Scores</em> section) and a scene, loop over each property of the Final Scores property and display its value in the <code>DialogBox</code> class by counting up to it from zero:</p>
<div><div><img alt="Figure 9.5 – A logical flowchart of the scoringAnimationCo behavior. Circles represent yield statements with the optional use of Tools.DelayAsync. Rectangles list the actions taken&#13;&#10;" height="1375" src="img/Figure_9.05_B17866.jpg" width="1569"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – A logical flowchart of the scoringAnimationCo behavior. Circles represent yield statements with the optional use of Tools.DelayAsync. Rectangles list the actions taken</p>
<p>The preceding diagram shows that several other pieces need to be handled: the height of the <code>bodyStack</code> StackPanel needs to be adjusted to account for the new row that was added to it, the scrollbar that contains the <code>bodyStack</code> control needs to be set to its new maximum value to ensure that the current line of text is fully visible, and so on. </p>
<p>Despite the <a id="_idIndexMarker715"/>seeming complexity <a id="_idIndexMarker716"/>of this logic, it comprises well under 100 lines of code! If we only look at the actual logic of the coroutine and exclude the state management code, we have even fewer lines of code to write:</p>
<pre class="source-code">&#13;
for (let i in finalScores) {&#13;
    yield Tools.DelayAsync(500);&#13;
    // ...snip... compute and adjust height    &#13;
    yield Tools.DelayAsync(1800);&#13;
    if (skipCountUp) {&#13;
        // display score right away&#13;
    }&#13;
    else {&#13;
        const MAX_COUNT = 50;&#13;
        while (frameCounter &lt;= MAX_COUNT) {&#13;
            let currProgress = frameCounter / MAX_COUNT;&#13;
            sound.play();&#13;
            let speed = Scalar&#13;
                    .SmoothStep(0, score, currProgress);&#13;
            scoreBlock.text =&#13;
                     `${label}.........${speed.toFixed()&#13;
                      .toLocaleString()}`;&#13;
            frameCounter++;&#13;
            yield Tools.DelayAsync(50);&#13;
          }&#13;
        }&#13;
        yield;&#13;
      }&#13;
      return;</pre>
<p>The value for <code>MAX_COUNT</code> was arbitrarily determined via experimentation; it controls the length of <a id="_idIndexMarker717"/>the counting animation. The progress <a id="_idIndexMarker718"/>is governed by the <code>SmoothStep</code> function, which starts slow before speeding up greatly just before coming to a gentle stop at the end. Every time <code>Tools.DelayAsync</code> is passed as the argument to <code>yield</code>, the coroutine will pause itself for the indicated amount of time – or as close to it as possible – before resuming execution. </p>
<p class="callout-heading">Note</p>
<p class="callout">Because frame delta times don’t always add up to the exact amount of time specified, a coroutine can be paused for slightly longer than the indicated amount of time. </p>
<p>When all is said and done and the final <code>returns</code> rather than <code>yields</code>, indicating completion and signaling to the hosting <code>onBeforeRenderObservable</code> that it’s OK to clean up and dispose of that coroutine function instance. From the perspective of the code that started things off, we have two simple lines – one to create the iterator function and another to start it running:</p>
<pre class="source-code">&#13;
let scoringCo = scoringAnimationCo();    &#13;
scene.onBeforeRenderObservable.runCoroutineAsync(scoringCo);</pre>
<p>In this scenario, we don’t want to block execution and wait until the coroutine completes to continue executing <code>createScoringDialog</code>, but if we were doing something different, such as making asynchronous HTTP calls as part of a coroutine, it would be prudent to await or capture the returned Promise of <code>runCoRoutineAsync</code>. Thus, it can <a id="_idIndexMarker719"/>be used and passed around <a id="_idIndexMarker720"/>just like any other asynchronous operation, allowing for more advanced scenarios and complex behaviors.</p>
<h2 id="_idParaDest-203"><a id="_idTextAnchor204"/>Advanced Coroutine Usage</h2>
<p>Unless you’re a passenger on the Titanic, there’s good news: this is just the tip of the iceberg! Because <a id="_idIndexMarker721"/>coroutines leverage the underlying mechanics of function iterators, it’s possible to use the <code>yield*</code> operator to chain together multiple <code>function*</code> iterations into a single coroutine, as exemplified in the Playground at <a href="https://playground.babylonjs.com/%235Z2QLW%231">https://playground.babylonjs.com/#5Z2QLW#1</a>.</p>
<p class="callout-heading">Note</p>
<p class="callout">See <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*</a> for more details and examples of using the <code>yield*</code> operator.</p>
<p>The <code>yield*</code> operator is used in the context of a <code>function*</code> body, and provides a way to “pass through” the results of another iterator function – or, and this is easily missed part of the definition (emphasis added):</p>
<p class="author-quote">“The yield* expression is used to delegate to another generator or iterable object.”</p>
<p>Although not used in our example, this would allow a developer to, for example, write a coroutine that produced a stream of values from an array populated by device sensors, among many other applications. In our example, we are using the <code>yield*</code> operator analogously as we may extract reusable code into a function by invoking another <code>function*</code>. </p>
<p>Seemingly a small detail, this ability to execute other iterator functions allows us to use the powerful Compositional pattern of software design to put simple building blocks together to express complex behavior. We start with the <code>function* think()</code> coroutine. It is named appropriately because its job is to decide what the sphere mesh is going to do next:</p>
<pre class="source-code">&#13;
function* think() {&#13;
    while (true) {&#13;
        yield Tools.DelayAsync(1500);&#13;
        yield* moveToTarget(new Vector3(PERIMETER / 2, 1,&#13;
          0));&#13;
        yield Tools.DelayAsync(1500);&#13;
        yield* patrolCo();&#13;
        yield* moveToTarget(new Vector3(0, 1, 0));&#13;
    }&#13;
}</pre>
<p>Think of the preceding code as the <em class="italic">primary controller</em> or, more colloquially, the AI for a game object. It can read the environment and make decisions on what to do. In our case, it waits for a <a id="_idIndexMarker722"/>second and a half before invoking the <code>moveToTarget</code> function (listed in the following code snippet) with the desired target position. This moves the sphere from wherever it is positioned in the middle of the right-hand side of the perimeter Plane. After another short delay, the <code>patrolCo</code> function is invoked.</p>
<p><code>function* patrolCo</code> is another compositional element that combines multiple <code>moveToTarget</code> iterations, along with logic, to change the color of the sphere on every movement direction change:</p>
<pre class="source-code">&#13;
function* patrolCo() {&#13;
    let targetVector = new BABYLON.Vector3(0, 1, 0)&#13;
    yield;&#13;
    sphereMat.diffuseColor = BABYLON.Color3.Random();&#13;
    targetVector.set(PERIMETER / 2, 1, 0);&#13;
    yield* moveToTarget(targetVector);&#13;
    sphereMat.diffuseColor = BABYLON.Color3.Random();&#13;
    targetVector.addInPlaceFromFloats(0, 0, PERIMETER / 2);&#13;
    // ...snip... &#13;
    yield* moveToTarget(targetVector);&#13;
    return;&#13;
}</pre>
<p>Each set of <code>yield*</code> statements delegates execution to the <code>moveToTarget</code> function, which is the real workhorse of this example. This behavior does what it says on the tin – it moves the <a id="_idIndexMarker723"/>subject (the sphere mesh, in our case) of the behavior as close as it can to the given target world position. A <code>maxDelta</code> value caps the amount of ground the sphere can cover in any given frame (due to the coroutine being hosted and executed by <code>onBeforeRenderObservable</code>):</p>
<pre class="source-code">&#13;
const maxDelta = 0.0075;&#13;
function* moveToTarget(targetPosition) {&#13;
    let hasArrived = false;&#13;
    while (!hasArrived) {&#13;
        let dir = targetPosition.subtract(sphere.position);&#13;
        if (dir.length() &lt;= 0.75) {&#13;
            hasArrived = true;&#13;
        }&#13;
        dir.scaleInPlace(maxDelta);&#13;
        sphere.position.addInPlace(dir);&#13;
        yield;&#13;
    }&#13;
    return;&#13;
}</pre>
<p>The direction of movement is computed by subtracting the two relevant position vectors, the result of which is used to determine whether the sphere has arrived at its destination, as well as moving the sphere by adding a scaled vector pointing toward <code>targetPosition</code>. Upon arrival, the iterator function returns control to the calling iterator function – either <code>patrolCo()</code> or <code>think()</code>, which then proceeds to the next step in its iterator chain. </p>
<p>This simple example can easily be extended with additional behavior and logic, simply by adding additional <code>function*</code> definitions. Like a library or toolbox of behaviors, simple behaviors <a id="_idIndexMarker724"/>such as <code>moveToTarget</code> are stitched together into more complex behaviors such as <code>patrolCo</code>, which is, in turn, orchestrated by the overall <code>think</code> function iterator endlessly pondering the game’s world. An entire non-player actor/controller can be quickly put together in this fashion! Hopefully, by presenting the concepts in an isolated Playground, it’s easier to see how composition can make the whole greater than the sum of its parts.</p>
<h1 id="_idParaDest-204"><a id="_idTextAnchor205"/>Summary</h1>
<p>We’ve accomplished a lot in this chapter. Starting with the <code>DialogBox</code> was designed and saved to both the snippet server and JSON. After learning how to use it in conjunction with the <code>DialogBox</code> component and tested it by adding the Route Planning confirmation dialog.</p>
<p>Armed with those initial results, we turned to the scoring system used in Space-Truckers and the logic needed to calculate each area of the scoring game. The data to accomplish this became apparent throughout, so we made the needed modifications to the <strong class="bold">Space-Trucker Application</strong> to capture scoring data. Because we already have the foundational dialog structure in place, it’s easy to create the <strong class="bold">Scoring Dialog</strong> from both captured and sample scoring data.</p>
<p>It’s not enough to simply display the scores in our Scoring Dialog, though, so we employed another new feature in v5 of Babylon.js: <code>BablyonJS.Observable</code> (but mostly used in <code>onBeforeRenderObservable</code>), coroutines allow complex multi-frame logic to be simply written and executed. Through <code>scoringAnimationCo</code>, each line of the Final Scores object is displayed and counted to its final value from zero. </p>
<p>Moving away from the Scoring Dialog, we wrapped up this chapter by learning how to use coroutines with multiple <code>moveToTarget</code> and <code>patrolCo</code>. </p>
<p>In the next chapter, we’re going to look at the space of Space-Truckers by diving into environments, <strong class="bold">Image-Based Lighting</strong> (<strong class="bold">IBL</strong>), and how to use <strong class="bold">Physically-Based Rendering</strong> (<strong class="bold">PBR</strong>) with Babylon.js. From workflows for converting images for use with IBL to adding post-processes for effect, we’ll see how easy it is to take a few lines of code and make something attractive and performant!</p>
<h1 id="_idParaDest-205"><a id="_idTextAnchor206"/>Extended Topics</h1>
<p>It’s important not to focus too much on the particulars of the <code>DialogBox</code> design UI – this book isn’t a book on graphic design, much to everyone’s relief – so here are some ideas and resources for taking your UI adventures to the next level:</p>
<ul>
<li>The Babylon.js team ran a summer event in August 2022 that urged community members to submit the amazing UI builds they had created with the GUIE. Two “starter” templates were provided for people that didn’t have an existing project:<ul><li><a href="https://playground.babylonjs.com/%23QCH724%231">https://playground.babylonjs.com/#QCH724#1</a></li><li><a href="https://playground.babylonjs.com/%23QCH724%231">https://playground.babylonjs.com/#QCH724#1</a> </li></ul></li>
</ul>
<p>These two samples are for a main menu system and an in-game menu and inventory system – what sorts of things can you build when you combine those as a starting point with what you’ve learned in this chapter?</p>
<ul>
<li>The Space-Truckers Main Menu is very much imperatively coded as opposed to the GUIE JSON files, which are declarative. As we’ve seen, a declarative data-driven UI is much easier to build and maintain, so try applying that knowledge to the Main Menu by replacing some of the GUI components created in code with a <code>DialogBox</code>.</li>
<li>Composable coroutines can provide a simple and easy way to add interesting behaviors to a game or application. Add a way for an arbitrary encounter instance in the Driving Phase to run a coroutine “behavior.” The encounter itself should provide the coroutine, but it will need to be provided with current game state information:<ul><li>Three components working together can help cleanly separate and define this functionality: <ul><li>A Behavior component that does the “thinking”</li><li>A Think Context that provides a vehicle for state information </li><li>A set of actions that the behavior(s) can perform (for example, “Move,” “Eat,” “Disperse,” “Acquire Target,” and so on)</li></ul></li><li>An encounter coroutine may load a mesh and material, set some values, and perform other initialization tasks before beginning its behavioral “think” loop. </li><li>Actions can be other coroutine behaviors, such as patrolling behavior.</li></ul></li>
</ul>
</div>
<div><div></div>
</div>
</div></body></html>