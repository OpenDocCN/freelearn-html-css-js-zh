<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Knockout Essentials</h1></div></div></div><p class="calibre8">Though it is expected that you have experience with both JavaScript and <a id="id0" class="calibre1"/>
<strong class="calibre9">KnockoutJS</strong>, we will still be covering the basics to establish a common foundation. This book wouldn't be complete if we didn't cover at least the basics. After that, we will look at building a simple application to create and manage contact information. This application will be used throughout the book to explore new techniques in Knockout and see how they fit into the larger process of application development. In this chapter, you will learn how to:</p><div><ul class="itemizedlist"><li class="listitem">Define viewmodels</li><li class="listitem">Write standard bindings</li><li class="listitem">Use extenders</li><li class="listitem">Use templates</li><li class="listitem">Put all these pieces together into a functional application</li></ul></div><p class="calibre8">This covers most of the standard functionalities in Knockout. In the next chapter, we will look at creating our own bindings to extend Knockout.</p><p class="calibre8">Even if you have used Knockout before and don't think you need a refresher, I encourage you to at least read the section that covers the <code class="literal">Contacts List</code> application example. It's something we will be using throughout the book as we explore more advanced concepts.</p><p class="calibre8">Before we get started, let's get our development environment set up.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec09" class="calibre1"/>The environment setup</h1></div></div></div><p class="calibre8">We will be using a<a id="id1" class="calibre1"/> simple <strong class="calibre9">Node.js</strong> server to host our application because it will run on any operating system. If you haven't done so, install Node.js by following the<a id="id2" class="calibre1"/> instructions at <a class="calibre1" href="http://nodejs.org/download">http://nodejs.org/download</a>.</p><p class="calibre8">We will be using <strong class="calibre9">Git</strong> <a id="id3" class="calibre1"/>to manage the code for each chapter. If you haven't done so, install Git by following the<a id="id4" class="calibre1"/> instructions at <a class="calibre1" href="http://git-scm.com/book/en/Getting-Started-Installing-Git">http://git-scm.com/book/en/Getting-Started-Installing-Git</a>. The code for this book can be downloaded from <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. All the code needed to start each chapter can be found in a branch named <code class="literal">cp[chapter#]-[sample]</code>. For example, the first sample we will look at is going to be in the <code class="literal">cp1-computeds</code> branch.</p><p class="calibre8">To begin, clone the<a id="id5" class="calibre1"/> repository from <a class="calibre1" href="https://github.com/tyrsius/MasteringKnockout">https://github.com/tyrsius/MasteringKnockout</a>. You can either use the provided download links or run the following command:</p><div><pre class="programlisting">
<strong class="calibre9">git clone git@github.com:tyrsius/MasteringKnockout</strong>
</pre></div><p class="calibre8">Then, check out the<a id="id6" class="calibre1"/> first sample using:</p><div><pre class="programlisting">
<strong class="calibre9">git checkout cp1</strong>
</pre></div><p class="calibre8">All the examples follow the same pattern. At the root is a <code class="literal">server.js</code> file that contains a boilerplate Node.js server. Inside the client directory is all the code for the application. To run the application, run this from the command line:</p><div><pre class="programlisting">
<strong class="calibre9">node server.js</strong>
</pre></div><p class="calibre8">Keep the command-line window open else the server will stop running. Then, open your web browser and navigate to <code class="literal">http://localhost:3000</code>. If you've set up your environment correctly, you should be looking at the empty <code class="literal">Contacts List</code> application, as shown in the following screenshot:</p><div><img src="img/00002.jpeg" alt="The environment setup" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The <code class="literal">cp1</code> branch contains a skeleton with some blank pages. Until we get to the <strong class="calibre9">Contacts</strong> application, most of the samples will not have the <strong class="calibre9">Contacts</strong> or <strong class="calibre9">Settings</strong> pages; they will just present the code on the home page.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec07" class="calibre1"/>Looking at the samples</h2></div></div></div><p class="calibre8">Samples of running code are<a id="id7" class="calibre1"/> provided throughout the book. They are in branches in the Git repository. You can look at them by checking out the branch, using the following command:</p><div><pre class="programlisting">
<strong class="calibre9">git checkout [BranchName]</strong>
</pre></div><p class="calibre8">Since the repository is a functional app, most of the code is not relevant to the samples. The <code class="literal">client</code> directory contains the <code class="literal">index.html</code> and <code class="literal">shell.html</code> pages, as well as the <code class="literal">app</code>, <code class="literal">content</code>, and <code class="literal">lib</code> directories. The <code class="literal">app</code> directory is where our JavaScript is located. The <code class="literal">content</code> directory contains the included CSS and <code class="literal">lib</code> contains third-party code (Knockout, jQuery, and Twitter Bootstrap).</p><p class="calibre8">The included Node server has a very simple view composition that places the contents of a page in the <code class="literal">{{ body }}</code> section of the shell. If you have worked with any server-side MVC frameworks, such as Ruby on Rails or ASP.NET MVC, you will be familiar with this. The mechanism is not related to Knockout, but it will help us keep our code separated as we add files. The shell is in the <code class="literal">shell.html</code> file. You can take a look at it, but it's not directly related to the samples. The HTML for samples is in the <code class="literal">client/index.html</code> file. The JavaScript for samples is in the <code class="literal">client/app/sample.js</code> file.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec08" class="calibre1"/>JavaScript's compatibility</h2></div></div></div><p class="calibre8">Throughout this book, we will be <a id="id8" class="calibre1"/>using code that relies on ECMAScript 5 features, which are supported on all modern browsers. I encourage you to run these examples using a compatible browser. If you cannot, or if you are interested in running them in an older environment, you can use a <strong class="calibre9">polyfill</strong>
<a id="id9" class="calibre1"/> for them. A polyfill is a JavaScript library that adds standard features to old environments to allow them to run modern code. For the ECMAScript 5 functions, I recommend<a id="id10" class="calibre1"/> <strong class="calibre9">Sugar.js</strong>. For the CSS3 media query support, I recommend <a id="id11" class="calibre1"/>
<strong class="calibre9">Respond.js</strong>.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>An overview of Knockout</h1></div></div></div><p class="calibre8">Knockout<a id="id12" class="calibre1"/> is a library designed for <strong class="calibre9">Model-View-ViewModel</strong> (<strong class="calibre9">MVVM</strong>)<a id="id13" class="calibre1"/> development. This pattern, a descendant of Martin Fowler's Presentation model, encourages the separation of <strong class="calibre9">User Interface</strong> (<strong class="calibre9">UI</strong>)<a id="id14" class="calibre1"/> from the business logic of the domain model. To facilitate this separation, Knockout provides the three necessary components for implementing this pattern, namely, a declarative syntax for the view (the data-bind HTML attribute), a mechanism to notify changes from the viewmodel (the observable object), and a data binder to mediate between the two (Knockout's binding handler).</p><p class="calibre8">We will be covering the data-bind and observable object syntax here; the binding handler syntax and its use will be covered in the next chapter.</p><p class="calibre8">Using the MVVM pattern means your viewmodel operates on data with JavaScript, and your HTML view is described using the declarative data-binding syntax. Your JavaScript code should not be directly accessing or modifying the view—data-binding should handle that by translating your observable objects into HTML using binding handlers.</p><p class="calibre8">The best way to think about the<a id="id15" class="calibre1"/> separation between view and viewmodel is to consider whether two different views could use your viewmodel. While this is often not done, it is still helpful to keep it in mind because it forces you to maintain the separation between them. MVVM allows you to redesign the view without affecting the viewmodel.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Observables</h1></div></div></div><p class="calibre8">Knockout follows a <a id="id16" class="calibre1"/>publish/subscribe pattern to keep data in sync between different parts of the application, such as the UI and the viewmodel. The publisher in Knockout is the observable object. If you've used MVVM before in <strong class="calibre9">Windows Presentation Foundation</strong> (<strong class="calibre9">WPF</strong>)<a id="id17" class="calibre1"/> development, then observable objects can be thought of as Knockout's <code class="literal">INotifyPropertyChanged</code> implementation.</p><p class="calibre8">To construct an observable, the <code class="literal">observable</code> function is called on the global <code class="literal">ko</code> object:</p><div><pre class="programlisting">this.property = ko.observable('default value');</pre></div><p class="calibre8">The <code class="literal">observable</code> function<a id="id18" class="calibre1"/> returns a new observable. If <code class="literal">ko.observable</code> is called with a value, it returns an observable with that value.</p><div><h3 class="title2"><a id="note02" class="calibre1"/>Note</h3><p class="calibre8">The reason why Knockout observables are JavaScript functions instead of normal properties is to allow support for older browsers such as Internet Explorer 6, which did not support getters and setters on properties. Without that ability, setting properties would have no mechanism to notify subscribers about changes.</p></div><p class="calibre8">Observables are JavaScript functions that record subscribers reading their value, then call these subscribers when the value has been changed. This is done using Knockout's dependency tracking mechanism.</p><p class="calibre8">Observables are read by calling them without any parameters. To write to an observable, call it with the value as the first and only parameter (further parameters are ignored):</p><div><pre class="programlisting">var total = vm.total();// read value
vm.total(50);// write new value</pre></div><div><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre8">
<strong class="calibre9">Downloading the sample code</strong>
</p><p class="calibre8">You can download the sample code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div><p class="calibre8">Observables can contain any legal JavaScript value: primitives, arrays, objects, functions, and even other observables (though this wouldn't be that useful). It doesn't matter what the value is; observables merely provide a mechanism to report when that value has been changed.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec09" class="calibre1"/>Observable arrays</h2></div></div></div><p class="calibre8">Though standard observables can<a id="id19" class="calibre1"/> contain<a id="id20" class="calibre1"/> arrays, they aren't well suited to track changes in them. This is because the observable is looking for changes in the value of the array, a reference to the array itself, which is not affected by adding or removing elements. As this is what most people expect change notification to look like on an array, Knockout provides the <code class="literal">observableArray</code>:</p><div><pre class="programlisting">this.users = ko.observableArray(myUsers);</pre></div><p class="calibre8">Like observables, arrays can be constructed with an initial value. Normally, you access an observable by calling it or setting its value by passing it a parameter. With observable arrays it's a little different. As the value of the array is its reference, setting that value would change the entire array. Instead, you usually want to operate on the array by adding or removing elements. Consider the following action:</p><div><pre class="programlisting">this.users().push(new User("Tim"));</pre></div><p class="calibre8">By calling <code class="literal">this.users()</code>, the underlying array is retrieved before a new user is pushed to it. In this case, Knockout is not aware that the array was changed, as the change was made to the array itself and not the observable. To allow Knockout to properly track changes, these changes need to be made to the observable, not the underlying value.</p><p class="calibre8">To do this, Knockout provides the standard array methods on the observable, namely, <code class="literal">push</code>, <code class="literal">pop</code>, <code class="literal">shift</code>, <code class="literal">unshift</code>, <code class="literal">sort</code>, <code class="literal">reverse</code>, and <code class="literal">splice</code>. The call should look like this:</p><div><pre class="programlisting">this.users.push(new User("Tim"));</pre></div><p class="calibre8">Notice that instead of retrieving the array from the observable, we are calling <code class="literal">push</code> directly on the observable. This will ensure that subscribers are notified of the change with an updated array.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec10" class="calibre1"/>Computed observables</h2></div></div></div><p class="calibre8">Observables are properties that are set<a id="id21" class="calibre1"/> manually, either through your code or by bindings<a id="id22" class="calibre1"/> from the UI. Computed observables are properties that automatically update their value by responding to changes in their dependencies, as shown in the following code:</p><div><pre class="programlisting">var subtotal = ko.observable(0);
var tax = ko.observable(0.05);
var total  = ko.computed(function() {
  return parseFloat(subtotal()) * (1 + parseFloat(tax()));
});</pre></div><p class="calibre8">In this example, <code class="literal">subtotal</code> and <code class="literal">tax</code> are the dependencies of the <code class="literal">total</code> computed observable. For the first time, the computed observable calculates records of any other observables that were accessed and creates a subscription for them. The result is that whenever <code class="literal">subtotal</code> or <code class="literal">tax</code> are changed, the <code class="literal">total</code> is recalculated and notified to its subscribers. It helps to think of computed observables as declarative values; you define their value as a formula and they will keep themselves up to date.</p><p class="calibre8">The <code class="literal">parseFloat</code> calls are to ensure that they are treated as numbers instead of strings, which would cause concatenation instead of arithmetic. As Knockout binds data against HTML attributes, which are always strings, updates from data binding produce strings. When we discuss extenders, you will see another way to manage this issue.</p><p class="calibre8">You can see a sample of this on the <code class="literal">cp1-computeds</code> branch:</p><div><img src="img/00003.jpeg" alt="Computed observables" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Try changing some of the numbers and watch the <code class="literal">total</code> computed value update automatically. You can see that the viewmodel code contains just this sample by looking in the <code class="literal">client/app/sample.js</code> file.</p><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Writable computed observables</h3></div></div></div><p class="calibre8">The <a id="id23" class="calibre1"/>preceding <code class="literal">total</code> example is a read-only computed. While<a id="id24" class="calibre1"/> they are less common, it is also possible to make a computed observable writable. To do so, pass an object with a <code class="literal">read</code> and <code class="literal">write</code> function to <code class="literal">ko.computed</code>:</p><div><pre class="programlisting">var subtotal = ko.observable(0);
var tax = ko.observable(0.05);
var total  = ko.computed({
  write: function(newValue) {
      subtotal(newValue / (1 + parseFloat(self.tax())));
  },
  read: function() {
      parseFloat(subtotal()) * (1 + parseFloat(tax()));
 }
});</pre></div><p class="calibre8">When something attempts to write to the <code class="literal">total</code> computed now, it will cause the <code class="literal">subtotal</code> observable to be updated by the <code class="literal">write</code> function. This is a very powerful technique, but it is not always necessary. In some cases being unable to write directly to <code class="literal">total</code> might be a good thing, such as when <code class="literal">total</code> might involve conditionally applying tax to a list of items. You should use writeable computeds only when it makes sense to do so.</p><p class="calibre8">You can see an example of this in the <code class="literal">cp1-writecomputed</code> branch. The <code class="literal">total</code> computed is now bound to an <code class="literal">input</code> element such as the <code class="literal">subtotal</code> and <code class="literal">tax</code> properties, and changes to the value will reflect back into the <code class="literal">subtotal</code> observable.</p></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Pure computed observables</h3></div></div></div><p class="calibre8">Nonpure computed <a id="id25" class="calibre1"/>observables re-evaluate <a id="id26" class="calibre1"/>themselves whenever any of their dependencies change, even if there are no subscribers to receive the updated value. This re-evaluation can be useful if the computed also has intentional side effects, but it wastes memory and the processor's cycles if it has no side effects. Pure computed observables, on the other hand, do not re-evaluate when there are no subscribers.</p><p class="calibre8">Pure computed observables have two states: <strong class="calibre9">listening</strong> and <strong class="calibre9">sleeping</strong>. When a pure computed has subscribers, it will be<a id="id27" class="calibre1"/> listening and behaving exactly like a <a id="id28" class="calibre1"/>normal computed. When a pure computed has no subscribers, it will enter its sleeping state and dispose off all of its dependency subscriptions. When it wakes up, the pure computed will re-evaluate itself to ensure its value is correct.</p><p class="calibre8">Pure computed observables are useful when a value may go unused for an extended period of time, as they do not re-evaluate. However, since a pure computed always re-evaluates when accessed from a sleeping state, it can sometimes perform worse than a normal computed observable. Since normal computeds only re-evaluate when their dependencies change, a computed observable that is frequently woken from a sleeping state could potentially evaluate its dependencies more often.</p><p class="calibre8">There are two ways to<a id="id29" class="calibre1"/> create a pure computed: by <a id="id30" class="calibre1"/>using <code class="literal">ko.pureComputed</code> or by passing <code class="literal">{ pure: true }</code> as the third parameter to <code class="literal">ko.computed</code>:</p><div><pre class="programlisting">var total = ko.pureComputed(function() {
  return parseFloat(subtotal()) * (1 + parseFloat(tax()));
});
//OR
var total = ko.computed(function() {
  return parseFloat(subtotal()) * (1 + parseFloat(tax()));
}, this, { pure: true });</pre></div><div><h3 class="title2"><a id="note03" class="calibre1"/>Note</h3><p class="calibre8">Pure computed observables were introduced in Knockout 3.2, which was not released at the time this book was written. None of the code samples take advantage of pure computed observables, even though many of the samples would have benefited from them.</p></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec11" class="calibre1"/>Manual subscriptions</h2></div></div></div><p class="calibre8">Sometimes you need to do more than update a <a id="id31" class="calibre1"/>dependent value when an observable changes, such as make a web request for additional data based on the new value of your observable. Observables provide a <code class="literal">subscribe</code> function that lets you register a function to be called when the observable is updated.</p><p class="calibre8">Subscriptions use the same internal mechanism in Knockout that binding handlers and computed observables use to receive changes.</p><p class="calibre8">This is an example of setting up a subscription on an observable:</p><div><pre class="programlisting">var locationId = ko.observable();
locationId.subscribe(function (newLocationId) {
  webService.getLocationDetails(newLocationId);
});</pre></div><p class="calibre8">This subscription will be called any time when the <code class="literal">locationId</code> is updated, whether it happens from a UI binding or from somewhere else in JavaScript.</p><p class="calibre8">The <code class="literal">subscribe</code> function<a id="id32" class="calibre1"/> also allows you to provide a target for the subscription and the name of the event you want to subscribe to. The target is the value of <code class="literal">this</code> for the subscription handler you provide. The event defaults to change, which receives the value after it has been updated, but can also be <code class="literal">beforeChange</code>, which is called with the old value before a change happens:</p><div><pre class="programlisting">locationId.subscribe(function (oldValue) {
  console.log("the location " + oldValue + " is about to change");
}, self, 'beforeChange');});</pre></div><p class="calibre8">Finally, you can stop a subscription<a id="id33" class="calibre1"/> from continuing to fire by capturing it and calling dispose. This can be useful if you want to stop the handler or to make subscriptions that only fire a single time:</p><div><pre class="programlisting">var subscription = locationId.subscribe(function (newValue) {
  console.log("the location " + oldValue + " is about to change");
  subscription.dispose();
});</pre></div><p class="calibre8">Once a subscription has been disposed, it cannot be restarted. If you need it, you will have to recreate the subscription.</p><p class="calibre8">The <code class="literal">cp1-subscribe</code> branch has a subscription example that logs any changes to the <code class="literal">subtotal</code> observable on the JavaScript console, as well as a button that stops the subscription. Try changing the subtotal or total value and watch out for the console messages. Changing the total causes an update of the subtotal, which is why it still fires the subscription. Remember, changes from any source will cause an observable to report changes to all of its subscribers. This is the same reason updating the <code class="literal">total</code> computed causes the <code class="literal">subtotal</code> observable's <code class="literal">input</code> element to update; the <code class="literal">input</code> element is a subscriber to the viewmodel's property.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Defining viewmodels</h1></div></div></div><p class="calibre8">Viewmodels are the <a id="id34" class="calibre1"/>objects whose properties your view binds with; they form the binding context. It is the representation of your data and operations for your view (we will cover them in detail in the <em class="calibre12">Control flow bindings</em> section later in this chapter). Like regular objects in JavaScript, there are many ways to actually create them, but Knockout introduces some specific challenges.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec12" class="calibre1"/>The this and self keywords</h2></div></div></div><p class="calibre8">In JavaScript, <code class="literal">this</code> has <a id="id35" class="calibre1"/>a special meaning; it refers to the object calling the function. Functions<a id="id36" class="calibre1"/> called from an object get that object set to <code class="literal">this</code>. However, for functions that are anonymously called by code, that is merely the <em class="calibre12">inside</em> of an object, the behavior is different. Consider the following viewmodel:</p><div><pre class="programlisting">function Invoice() {
  this.subtotal = ko.observable();
  this.total = ko.computed(function() {
  return this.subtotal() * 1.08; //Tax Rate
  });
}</pre></div><p class="calibre8">The function inside the computed observable is not a property of the <code class="literal">Invoice</code> object. As it runs in a different context, its value for this will be the window object, not the <code class="literal">Invoice</code> object. It will not be able to find the <code class="literal">subtotal</code> property. There are two ways to handle this.</p><p class="calibre8">The first is by using the second parameter of the <code class="literal">ko.computed</code> function to bind the function to <code class="literal">this</code>:</p><div><pre class="programlisting">function Invoice() {
  this.subtotal = ko.observable();
  this.total = ko.computed(function() {
    return this.subtotal() * 1.08; //Tax Rate
  }, this);
}</pre></div><p class="calibre8">This gives the computed observable a reference to the <code class="literal">Invoice</code> that originally defined it, which allows the computed observable to call the supplied function in the correct context.</p><p class="calibre8">The second way to ensure the computed observable can reference the <code class="literal">subtotal</code>, is to capture the value of <code class="literal">this</code> in a closure. You can then use the closure to safely refer to the properties of the parent viewmodel. There<a id="id37" class="calibre1"/> are several conventional names for such a <a id="id38" class="calibre1"/>closure: <code class="literal">that</code>, <code class="literal">_this</code>, or <code class="literal">self</code>.</p><p class="calibre8">I prefer to use <code class="literal">self</code> as it is visually distinct from <code class="literal">this</code> while still carrying a similar meaning, but it's up to you:</p><div><pre class="programlisting">function Invoice() {
  var self = this;
  self.subtotal = ko.observable();
  self.total = ko.computed(function() {
return self.subtotal() * 1.08; //Tax Rate
  });
}</pre></div><p class="calibre8">I find the second method easier to remember. If you always use <code class="literal">self</code> to refer to the model, it will always work. If you have another anonymous function inside the computed, you will have to remember to bind that function as well; <code class="literal">self</code> continues to work as a closure no matter how many levels deep you nest. The <code class="literal">self</code> variable works as a closure inside any function defined in your viewmodel, including subscriptions. It's also easier to spot when <code class="literal">self</code> isn't being used, which is very helpful while debugging your code.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec13" class="calibre1"/>Problems with prototypes</h2></div></div></div><p class="calibre8">If you are working with <a id="id39" class="calibre1"/>viewmodels that will be inherited by other viewmodels, you might think that putting all the base observable properties on the prototype is the way to go. In vanilla JavaScript, if you are inheriting an object, try to change the value of a property stored on the prototype; the property would be added to the inheriting object leaving the prototype intact. When using observables in Knockout though, this isn't the case. The observables are functions, and their values are set by calling them with a single parameter, not by assigning new values to them. Because prototypical inheritance would result in multiple objects referring to a single observable; observables cannot be safely placed on viewmodel prototypes. Nonobservable functions can still be safely included in prototypes. For example, consider the following objects:</p><div><pre class="programlisting">var protoVm = {
  name: ko.observable('New User')
};

var base1 = Object.create(protoVm);
var base2 = Object.create(protoVm);

base2.name("Base2");</pre></div><p class="calibre8">The last line will cause the name of both objects to be updated, as it is referring to the same function. This example can be seen in the <code class="literal">cp1-prototype</code> branch, which includes two input elements bound to the name of each viewmodel. As they are really the same observable, changing one will affect the other.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec14" class="calibre1"/>Serializing viewmodels</h2></div></div></div><p class="calibre8">When you are ready to <a id="id40" class="calibre1"/>send your viewmodels to the server, or really do anything that requires you to work with their values instead of observables, Knockout provides two very handy utility methods:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">ko.toJS</code>: This <a id="id41" class="calibre1"/>function takes an object and does a deep copy, unwrapping all <a id="id42" class="calibre1"/>observables, into a new JavaScript object whose properties are normal (nonobservable) JavaScript values. This function is perfect to get copies of viewmodels.</li><li class="listitem"><code class="literal">ko.toJSON</code>: This <a id="id43" class="calibre1"/>function uses the output from <code class="literal">ko.toJS</code> with <code class="literal">JSON.stringify</code> to produce a JSON string of the supplied object. This function <a id="id44" class="calibre1"/>accepts the same parameters as <code class="literal">JSON.stringify</code>.</li></ul></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec13" class="calibre1"/>The data-bind syntax</h1></div></div></div><p class="calibre8">Knockout takes advantage of the<a id="id45" class="calibre1"/> HTML5 <code class="literal">data-*</code> attribute specification to define its <code class="literal">data-bind</code> attribute. Though all HTML attributes are necessarily strings, Knockout parses them as name:value pairs. The name refers to the binding handler to be used and the value refers to the value the binding will use:</p><div><pre class="programlisting">&lt;button data-bind="enable: canSave"&gt;Save&lt;/button&gt;</pre></div><p class="calibre8">The <code class="literal">data-bind</code> attribute<a id="id46" class="calibre1"/> can also contain multiple bindings separated by commas. This allows multiple properties to be bound on an element:</p><div><pre class="programlisting">&lt;input data-bind="value: firstName, enable: canEdit" /&gt;</pre></div><p class="calibre8">In the preceding example, the enable binding uses <code class="literal">canEdit</code> as a value. The binding will set the <code class="literal">disabled</code> attribute on the button element when <code class="literal">canEdit</code> is <code class="literal">false</code>, and remove the <code class="literal">disabled</code> attribute when <code class="literal">canEdit</code> is <code class="literal">true</code>. If <code class="literal">canEdit</code> is an observable, the enable binding will update whenever <code class="literal">canEdit</code> is updated. If <code class="literal">canEdit</code> is a literal value, such as <code class="literal">true</code>, it will only use the value to set the initial state.</p><p class="calibre8">Enable is a <a id="id47" class="calibre1"/>
<strong class="calibre9">one-way binding</strong>; it will update the element with changes from the value but it will not update the value with changes from the element. This is because when enable is being used to control the element, Knockout assumes that nothing will be programmatically updating the element. Updates should happen in the viewmodel, and binding handlers should be responsible for ensuring the view is kept in sync.</p><p class="calibre8">When users update the UI of data-bound input elements, those changes need to be synced to the viewmodel. This is done with <strong class="calibre9">two-way bindings</strong>,
<a id="id48" class="calibre1"/> such as the <code class="literal">value</code> binding:</p><div><pre class="programlisting">&lt;input data-bind="value: firstName" /&gt;</pre></div><p class="calibre8">This binding will set the initial value of the <code class="literal">input</code> element to the current value of the <code class="literal">firstName</code> property, and after that, it will ensure that any changes to either the element's value or the property cause the other to update. If the user types something into the input, the <code class="literal">firstName</code> property will receive the value. If the <code class="literal">firstName</code> property is updated programmatically, the input's value will be updated.</p><p class="calibre8">These are both examples of binding against a simple property on the viewmodel. This is the most common case, but Knockout supports more complex scenarios as well.</p><div><h3 class="title2"><a id="note04" class="calibre1"/>Note</h3><p class="calibre8">For a complete list of the standard Knockout binding handlers, see the<a id="id49" class="calibre1"/> Knockout documentation (<a class="calibre1" href="http://knockoutjs.com/documentation/introduction.html">http://knockoutjs.com/documentation/introduction.html</a>).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec15" class="calibre1"/>Binding with nested properties</h2></div></div></div><p class="calibre8">In the previous example, Knockout <a id="id50" class="calibre1"/>parsed the binding value for the name of a property and looked for that property on the current viewmodel. You can also provide deep property references. Consider the following object:</p><div><pre class="programlisting">var viewmodel = {
  user: {
    firstName: ko.observable('Tim'),
    age: ko.observable(27)
  }
};</pre></div><p class="calibre8">We can bind directly against the <code class="literal">firstName</code> property of the viewmodel's user by using standard dot notation:</p><div><pre class="programlisting">&lt;input data-bind="value: user.firstName" /&gt;</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec16" class="calibre1"/>Binding against functions</h2></div></div></div><p class="calibre8">If you are using the <code class="literal">click</code> or <code class="literal">event</code> bindings <a id="id51" class="calibre1"/>to bind some UI event, the binding expects the property to be a function. Functions will receive the current model (the binding context) as their first parameter, and the JavaScript event as the second parameter (though you shouldn't need to do this very often).</p><p class="calibre8">In this example, the parent viewmodel receives the contact to be removed from the <code class="literal">click</code> binding because the <code class="literal">foreach</code> loop creates a nested binding context for each contact. The parent reference in the binding moves the context up to the parent viewmodel to get access to the remove function:</p><div><pre class="programlisting">&lt;ul data-bind="foreach: contacts"&gt;
    &lt;li&gt;
      &lt;span data-bind="text: name"&gt;&lt;/span&gt;
      &lt;button data-bind="click: $parent.remove"&gt;Remove&lt;/button&gt;
    &lt;/li&gt;
&lt;/ul&gt;

var ViewModel = function() {
    var self = this;
    self.contacts = ko.observableArray([{ name: 'Tim' }, { name: 'Bob' }]);
    self.remove = function (contact) {
         self.contacts.remove(contact);
    };
};</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec17" class="calibre1"/>Binding with expressions</h2></div></div></div><p class="calibre8">In addition to property references, Knockout<a id="id52" class="calibre1"/> also supports the use of JavaScript expressions as binding values. For bindings that expect true or false values, such as enable, we can use Boolean expressions to set them:</p><div><pre class="programlisting">&lt;button data-bind="enable: age &gt; 18"&gt;Approve&lt;/button&gt;</pre></div><p class="calibre8">We can also use ternary expressions to control the result of the expression. This is useful in cases where Booleans are not expected, such as text bindings:</p><div><pre class="programlisting">Old enough to Drink in the U.S. 
&lt;span data-bind="text: age &gt; 18 ? 'Yes' : 'No'"&gt;&lt;/span&gt;</pre></div><p class="calibre8">Now the <code class="literal">span</code> will have <code class="literal">Yes</code> as content.</p><p class="calibre8">Both forms of expressions will use dependency tracking to rerun if they read from an observable the first time they are run. If <code class="literal">age</code> was an observable value, we could update it and the element's binding would re-evaluate the expression, changing the text or enabled state if the result changed.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec18" class="calibre1"/>Binding with function expressions</h2></div></div></div><p class="calibre8">The last method to set binding <a id="id53" class="calibre1"/>values is by using functions. You can call a function by referencing it in the binding:</p><div><pre class="programlisting">&lt;button data-bind="enable: canApprove(age)"&gt;Approve&lt;/button&gt;</pre></div><p class="calibre8">You can also write an anonymous function as a string directly in the binding. When creating a function for the <code class="literal">click</code> binding, the parameters are the binding context (viewmodel) and the JavaScript <code class="literal">click</code> event. If you bind against a viewmodel function using its property name, it would receive the same parameters:</p><div><pre class="programlisting">&lt;button data-bind="text: 
function(data) { console.log(data.age)  }"&gt;Log Age&lt;/button&gt;</pre></div><p class="calibre8">Though this is possible, I wouldn't encourage it. It places logic directly in the view instead of in the viewmodel where it belongs. You should only use this last method in very special cases. It's much <a id="id54" class="calibre1"/>better to place the method on the viewmodel and just use a property reference.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec19" class="calibre1"/>Using parentheses in bindings</h2></div></div></div><p class="calibre8">It can be confusing trying to<a id="id55" class="calibre1"/> figure out when to use parentheses in bindings to use an observable as a value. Knockout tries to be helpful by not requiring the parentheses in simple binding expressions like this one:</p><div><pre class="programlisting">&lt;input data-bind="value: firstName" /&gt;</pre></div><p class="calibre8">In this example, the <code class="literal">firstName</code> property could be either an observable or a literal value, and it would work just fine. However, there are two cases when the parentheses are needed in bindings: when binding against a nested property and when binding with an expression. Consider the following viewmodel:</p><div><pre class="programlisting">var viewmodel = {
  user: ko.observable({
    firstName: ko.observable('Tim'),
    age: ko.observable(27)
  })
};</pre></div><p class="calibre8">The user object here is an observable property, as are each of its properties. If we wanted to write the same binding now, it would need to include parentheses on the <code class="literal">user</code> function but still not on the <code class="literal">firstName</code> property:</p><div><pre class="programlisting">&lt;input data-bind="value: user().firstName" /&gt;</pre></div><p class="calibre8">In cases where we are binding directly against a property, the parentheses of that property are never needed. This is because Knockout is smart enough to understand how to access the value of the observable that it is given in bindings.</p><p class="calibre8">However, if we are binding against an expression, they are always needed:</p><div><pre class="programlisting">&lt;button data-bind="enable: user().age &gt; 18"&gt;Approve&lt;/button&gt;
&lt;button data-bind="enable: user().age() &gt; 18"&gt;Approve&lt;/button&gt;</pre></div><p class="calibre8">Neither of these bindings will cause errors, but the first one will not work as expected. This is because the first expression will try to evaluate on the <code class="literal">age</code> observable itself (which is a function, not a number) instead of the observable's value. The second one correctly compares the value of the observable to <code class="literal">18</code>, producing the expected result.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_6"><a id="ch01lvl2sec20" class="calibre1"/>Debugging with ko.toJSON</h2></div></div></div><p class="calibre8">Because <code class="literal">ko.toJSON</code> accepts<a id="id56" class="calibre1"/> the spaces argument for <code class="literal">JSON.stringify</code>, you can use it in a text binding to get a live copy of your viewmodel with nice, readable formatting:</p><div><pre class="programlisting">&lt;pre data-bind="text: ko.toJSON($root, null, 2)"&gt;&lt;/pre&gt;</pre></div><p class="calibre8">The <code class="literal">cp1-databind</code> branch has an interactive example of each of these bindings.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec14" class="calibre1"/>Control flow bindings</h1></div></div></div><p class="calibre8">So far, we have looked at <a id="id57" class="calibre1"/>one-way and two-way bindings that set or sync data with an attribute on an HTML element. There is a different kind of binding that Knockout uses for modifying the DOM by adding or removing nodes. These are the control flow bindings, and they include <code class="literal">foreach</code>, <code class="literal">if</code>, <code class="literal">with</code>, and <code class="literal">template</code>.</p><p class="calibre8">All of the control flow bindings work by actually removing their content from the DOM and creating an in-memory template from it. This template is used to add and remove the content as necessary.</p><p class="calibre8">Control flow bindings (except <code class="literal">if</code>) also introduce a binding context hierarchy. Your root binding context is the viewmodel passed to <code class="literal">ko.applyBindings</code>. The <code class="literal">data-bind</code> attributes have access to properties in the current context. Control flow bindings (other than <code class="literal">if</code>) create a child-binding context, meaning that <code class="literal">data-bind</code> attributes inside the control flow binding's template have access to the properties of their context and not the root context. Bindings inside a child context have access to special properties to allow them to navigate the context hierarchy. The most commonly used are:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">$parent</code>: This<a id="id58" class="calibre1"/> accesses the binding context of the immediate parent. In this example, <code class="literal">group</code> and <code class="literal">$parent.group</code> refer to the same property because <code class="literal">$parent</code> accesses the context outside of the person:<div><pre class="programlisting">&lt;span data-bind="text: group"&gt;&lt;/span&gt;
&lt;div data-bind="with: person"&gt;
  &lt;span data-bind="text: name"&gt;&lt;/span&gt;
&lt;span data-bind="text: $parent.group"&gt;&lt;/span&gt;
  &lt;/div&gt;</pre></div></li><li class="listitem"><code class="literal">$parents[n]</code>: This is an <a id="id59" class="calibre1"/>array of parent contexts. The <code class="literal">$parents[0]</code> array is same as <code class="literal">$parent</code>.</li><li class="listitem"><code class="literal">$root</code>: This is the root <a id="id60" class="calibre1"/>viewmodel, the highest context in the hierarchy.</li><li class="listitem"><code class="literal">$data</code>: This is the current <a id="id61" class="calibre1"/>viewmodel, useful inside <code class="literal">foreach</code> loops.<div><h3 class="title2"><a id="note05" class="calibre1"/>Note</h3><p class="calibre8">For a complete list of context properties, see the <a id="id62" class="calibre1"/>Knockout documentation for them at <a class="calibre1" href="http://knockoutjs.com/documentation/binding-context.html">http://knockoutjs.com/documentation/binding-context.html</a>.</p></div></li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec21" class="calibre1"/>The if binding</h2></div></div></div><p class="calibre8">The <code class="literal">if</code> binding<a id="id63" class="calibre1"/> takes a <a id="id64" class="calibre1"/>value or expression to evaluate and only renders the contained template when the value or expression is truthy (in the JavaScript sense). If the expression is falsy, the template is removed from the DOM. When the expression becomes true, the template is recreated and any contained <code class="literal">data-bind</code> attributes are reapplied. The <code class="literal">if</code> binding does not create a new binding context:</p><div><pre class="programlisting">&lt;div data-bind="if: isAdmin"&gt;
  &lt;span data-bind="text: user.username"&gt;&lt;/span&gt;
  &lt;button data-bind="click: deleteUser"&gt;Delete&lt;/button&gt;
&lt;/div&gt;</pre></div><p class="calibre8">This <code class="literal">div</code> would be empty when <code class="literal">isAdmin</code> is <code class="literal">false</code> or <code class="literal">null</code>. If the value of <code class="literal">isAdmin</code> is updated, the binding will re-evaluate and add or remove the template as necessary.</p><p class="calibre8">There is also an <code class="literal">ifnot</code> binding that just inverts the expression. It's useful if you want to still use a property reference without needing to add a bang and parentheses. The following two lines are equivalent:</p><div><pre class="programlisting">&lt;div data-bind="if: !isAdmin()" &gt;
&lt;div data-bind="ifnot: isAdmin"&gt;</pre></div><p class="calibre8">The parentheses are needed in the first example because it is an expression, not a property name. They are not needed in the second example because it is a simple property reference.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec22" class="calibre1"/>The with binding</h2></div></div></div><p class="calibre8">The <code class="literal">with</code> binding<a id="id65" class="calibre1"/> creates a new<a id="id66" class="calibre1"/> binding context using the supplied value, which causes bindings inside the bound element to be scoped to the new context. These two snippets are functionally similar:</p><div><pre class="programlisting">&lt;div&gt;
  First Name:
&lt;span data-bind="text: selectedPerson().firstName"&gt;&lt;/span&gt;
  Last Name:
&lt;span data-bind="text: selectedPerson().lastName"&gt;&lt;/span&gt;
&lt;/div&gt;

&lt;div data-bind="with: selectedPerson"&gt;
  First Name:
&lt;span data-bind="text: firstName"&gt;&lt;/span&gt;
  Last Name:
&lt;span data-bind="text: lastName"&gt;&lt;/span&gt;
&lt;/div&gt;</pre></div><p class="calibre8">While saving a few<a id="id67" class="calibre1"/> keystrokes and keeping your bindings easier to read is nice, the real benefit of the <code class="literal">with</code> binding is<a id="id68" class="calibre1"/> that it is an implicit <code class="literal">if</code> binding. If the value is <code class="literal">null</code> or <code class="literal">undefined</code>, the content of the HTML element will be removed from the DOM. In the cases where this is possible, it saves you from the need to make null checks for each descendant binding.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec23" class="calibre1"/>The foreach binding</h2></div></div></div><p class="calibre8">The <code class="literal">foreach</code> binding creates an<a id="id69" class="calibre1"/> implicit template using the contents of the <a id="id70" class="calibre1"/>HTML element and repeats that template for every element in the array.</p><p class="calibre8">This viewmodel contains a list of people we need to render:</p><div><pre class="programlisting">var viewmodel = {
  people: [{name: 'Tim'}, {name: 'Justin}, {name: 'Mark'}]
}</pre></div><p class="calibre8">With this binding, we create an implicit template for the <code class="literal">li</code> element:</p><div><pre class="programlisting">&lt;ul data-bind="foreach: people"&gt;
  &lt;li data-bind="text: name"&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">This binding produces the following HTML:</p><div><pre class="programlisting">&lt;ul&gt;
  &lt;li&gt;Tim&lt;/li&gt;
  &lt;li&gt;Justin&lt;/li&gt;
  &lt;li&gt;Mark&lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">The thing to note here is that the <code class="literal">li</code> element is binding against <code class="literal">name</code>, which is the property of a person. Inside the <code class="literal">foreach</code> binding, the binding context is the child element. If you need to refer to the child itself, you can either use <code class="literal">$data</code> or supply an alias to the <code class="literal">foreach</code> binding.</p><p class="calibre8">The <code class="literal">$data</code> option is useful when the array only contains primitives that you want to bind against:</p><div><pre class="programlisting">var viewmodel = {
  people: ['Tim', 'Justin, 'Mark']
}
...
&lt;ul data-bind="foreach: people"&gt;
  &lt;li data-bind="text: $data"&gt;&lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">The <code class="literal">alias</code> option can clean <a id="id71" class="calibre1"/>up your code, but it is particularly useful when you<a id="id72" class="calibre1"/> have a nested context and want to refer to the parent. Refer to the following code:</p><div><pre class="programlisting">&lt;ul data-bind="foreach: { data: categories, as: 'category' }"&gt;
    &lt;li&gt;
        &lt;ul data-bind="foreach: { data: items, as: 'item' }"&gt;
          &lt;li&gt;
            &lt;span data-bind="text: category.name"&gt;&lt;/span&gt;:
            &lt;span data-bind="text: item"&gt;&lt;/span&gt;
          &lt;/li&gt;
         &lt;/ul&gt;
    &lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">This can be achieved with <code class="literal">$parent</code>, of course, but it is more legible when using an <code class="literal">alias</code>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec15" class="calibre1"/>Template binding</h1></div></div></div><p class="calibre8">The template binding<a id="id73" class="calibre1"/> is a special control flow binding. It has a parameter for each of the other control flow bindings. It might be more accurate to say that the other control flow bindings are all <strong class="calibre9">aliases</strong> for the template binding:</p><div><pre class="programlisting">  &lt;ul data-bind="foreach: { data: categories, as: 'category' }"&gt;
  &lt;ul data-bind="template: { foreach: categories, as: 'category' }"&gt;</pre></div><p class="calibre8">Both of these are functionally equivalent. The template binding <code class="literal">as</code> has a parameter for <code class="literal">if</code> and <code class="literal">data</code> (which together make a <code class="literal">with</code> binding).</p><p class="calibre8">However, unlike the other control flow bindings, it can also generate its template from a named source using the <code class="literal">name</code> parameter. By default, the only source Knockout looks for is a <code class="literal">&lt;script&gt;</code> tag with an <code class="literal">id</code> parameter matching the <code class="literal">name</code> parameter:</p><div><pre class="programlisting">&lt;div data-bind="template: { name: 'person-template', data: seller }"&gt;&lt;/div&gt;
&lt;script type="text/html" id="person-template"&gt;
    &lt;h3 data-bind="text: name"&gt;&lt;/h3&gt;
    &lt;p&gt;Credits: &lt;span data-bind="text: credits"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/script&gt;</pre></div><p class="calibre8">To stop the <code class="literal">script</code> block from being executed as JavaScript, you need a dummy script type, such as <code class="literal">text/html</code> or <code class="literal">text/ko</code>. Knockout will not apply bindings to script elements, but it will use them as a source for templates.</p><p class="calibre8">Though it is much more common to use the inline templates seen in <code class="literal">foreach</code> or <code class="literal">with</code>, named templates have three very important uses.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec24" class="calibre1"/>Reusable templates</h2></div></div></div><p class="calibre8">As templates can reference an<a id="id74" class="calibre1"/> external source for the HTML, it is <a id="id75" class="calibre1"/>possible to have multiple template bindings pointing to a single source:</p><div><pre class="programlisting">&lt;div&gt;
  &lt;div data-bind="template: { name: 'person', data: father} "&gt;&lt;/div&gt;
  &lt;div data-bind="template: { name: 'person', data: mother} "&gt;&lt;/div&gt;
&lt;/div&gt;
...
&lt;script type="text/html" id="person"&gt;
  &lt;h3 data-bind="text: name"&gt;&lt;/h3&gt;
  &lt;strong&gt;Age: &lt;/strong&gt;
&lt;span data-bind="text: age"&gt;&lt;/span&gt;&lt;br&gt;
  &lt;strong&gt;Location: &lt;/strong&gt;
&lt;span data-bind="text: location"&gt;&lt;/span&gt;&lt;br&gt;
  &lt;strong&gt;Favorite Color: &lt;/strong&gt;
&lt;span data-bind="text: favoriteColor"&gt;&lt;/span&gt;&lt;br&gt;
&lt;/script&gt;</pre></div><p class="calibre8">The branch <code class="literal">cp1-reuse</code> has an example of this technique.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec25" class="calibre1"/>Recursive templates</h2></div></div></div><p class="calibre8">Because templates participate in <a id="id76" class="calibre1"/>data-binding themselves, it is possible for a<a id="id77" class="calibre1"/> template to bind against itself. If a template references itself, the result is recursive:</p><div><pre class="programlisting">&lt;div data-bind="template: { name: 'personTemplate', data: forefather} "&gt;&lt;/div&gt;

&lt;script type="text/html" id="personTemplate"&gt;
  &lt;h4 data-bind="text: name"&gt;&lt;/h4&gt;
  &lt;ul data-bind="foreach: children"&gt;
    &lt;li data-bind="template: 'personTemplate'"&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/script&gt;</pre></div><p class="calibre8">The template reference in the preceding template is using the shorthand binding, which just takes the name of the template directly. When using this shorthand, the current binding context is used for the template's <code class="literal">data</code> parameter, which is perfect inside a <code class="literal">foreach</code> loop like this one. This is a common technique when using recursive templates, as trees of information are the most common place to find visual recursion.</p><p class="calibre8">An example of this<a id="id78" class="calibre1"/> recursive <a id="id79" class="calibre1"/>template is in the <code class="literal">cp1-recurse</code> branch.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec26" class="calibre1"/>Dynamic templates</h2></div></div></div><p class="calibre8">The name of the template in the <a id="id80" class="calibre1"/>previous example is a string, but it could be a<a id="id81" class="calibre1"/> property reference too. Binding the template name to an observable allows you to control which template is rendered. This could be useful to swap a viewmodel's template between a display and edit mode. Consider this template binding:</p><div><pre class="programlisting">&lt;div data-bind="template: { name: template, data: father} "&gt;&lt;/div&gt;</pre></div><p class="calibre8">This template binding backed by a viewmodel property such as this one:</p><div><pre class="programlisting">self.template = ko.computed(function() {
  return self.editing() ? 'editTemplate' : 'viewTemplate';
});</pre></div><p class="calibre8">If we update the <code class="literal">editing</code> property from <code class="literal">true</code> to <code class="literal">false</code>, the template will re-render from <code class="literal">viewTemplate</code> to <code class="literal">editTemplate</code>. This allows us to programmatically switch between them.</p><p class="calibre8">An example of a dynamic edit/view template is in the <code class="literal">cp1-dynamic</code> branch.</p><p class="calibre8">In an advanced scenario, you could use a technique such as this for creating a generic container on a page to display entirely different views. Switching the template name and the data at the same time would mimic navigation, creating a <a id="id82" class="calibre1"/>
<strong class="calibre9">Single Page Application</strong> (<strong class="calibre9">SPA</strong>). We will take a look at a similar technique when we get to <a class="calibre1" title="Chapter 4. Application Development with Components and Modules" href="part0037_split_000.html#page">Chapter 4</a>, <em class="calibre12">Application Development with Components and Modules</em>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec16" class="calibre1"/>Containerless control flow</h1></div></div></div><p class="calibre8">So far, we have looked at <a id="id83" class="calibre1"/>using the control flow bindings (<code class="literal">if</code>, <code class="literal">with</code>, <code class="literal">foreach</code>, and <code class="literal">template</code>) and the standard <code class="literal">data-bind</code> attribute on an HTML element. It is also possible to use control flow bindings without an element by using special comment tags that are parsed by Knockout. This is called containerless control flow.</p><p class="calibre8">Adding a <code class="literal">&lt;!— ko --&gt;</code> comment starts a virtual element that ends with a <code class="literal">&lt;!-- /ko --&gt;</code> comment. This virtual element <a id="id84" class="calibre1"/>causes a control flow binding to treat all contained elements as children. The following block of code demonstrates how sibling elements can be grouped by a virtual comment container:</p><div><pre class="programlisting">&lt;ul&gt;
    &lt;li&gt;People&lt;/li&gt;
    &lt;li&gt;Locations&lt;/li&gt;
    &lt;!-- ko if: isAdmin --&gt;
    &lt;li&gt;Users&lt;/li&gt;
    &lt;li&gt;Admin&lt;/li&gt;
    &lt;!-- /ko --&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">List elements only allow specific elements as children. The preceding containerless syntax applies the <code class="literal">if</code> binding to the last two elements in the list, which causes them to add or remove from the DOM based in the <code class="literal">isAdmin</code> property:</p><div><pre class="programlisting">&lt;ul&gt;
    &lt;li&gt;Nav Header&lt;/li&gt;
    &lt;!-- ko foreach: navigationItems --&gt;
    &lt;li&gt;&lt;span data-bind="text: $data"&gt;&lt;/span&gt;&lt;/li&gt;
    &lt;!-- /ko --&gt;
&lt;/ul&gt;</pre></div><p class="calibre8">The preceding containerless syntax allows us to have a <code class="literal">foreach</code> binding to create a list of items while maintaining a header item at the top of the list.</p><p class="calibre8">All of the control flow bindings can be used in this way. The preceding two examples can be seen in the <code class="literal">cp1-containerless</code> branch.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec17" class="calibre1"/>Extenders</h1></div></div></div><p class="calibre8">The last "basic" feature<a id="id85" class="calibre1"/> to cover is extenders (don't worry, there is still plenty of advanced stuff to cover). Extenders offer a way to modify individual observables. Two common uses of extenders are as follows:</p><div><ul class="itemizedlist"><li class="listitem">Adding properties or functions to the observable</li><li class="listitem">Adding a wrapper around the observable to modify writes or reads</li></ul></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec27" class="calibre1"/>Simple extenders</h2></div></div></div><p class="calibre8">Adding an extender is as<a id="id86" class="calibre1"/> simple as adding a new function to the <code class="literal">ko.extenders</code> object <a id="id87" class="calibre1"/>with the name you want to use. This function receives the observable being extended (called the target) as the first argument, and any configuration passed to the extender is received as the second argument, as shown in the following code:</p><div><pre class="programlisting">ko.extenders.recordChanges = function(target, options) {
  target.previousValues = ko.observableArray();
  target.subscribe(function(oldValue) {
    target.previousValues.push(oldValue);
  }, null, 'beforeChange');
  return target;
};</pre></div><p class="calibre8">This extender will<a id="id88" class="calibre1"/> create a new <code class="literal">previousValues</code> property on the observable. This<a id="id89" class="calibre1"/> new property is as an observable array and old values are pushed to it as the original observable is changed (the current value is already in the observable of course).</p><p class="calibre8">The reason the extender has to return the target is because the result of the extender is the new observable. The need for this is apparent when looking at how the extender is called:</p><div><pre class="programlisting">var amount = ko.observable(0).extend({ recordChanges: true});</pre></div><p class="calibre8">The <code class="literal">true</code> value sent to <code class="literal">recordChanges</code> is received by the extender as the <code class="literal">options</code> parameter. This value can be any JavaScript value, including objects and functions.</p><p class="calibre8">You can also add multiple extenders to an observable in the same call. The object sent to the <code class="literal">extend</code> method will call an observable for every property it contains:</p><div><pre class="programlisting">var amount = ko.observable(0).extend({ recordChanges: true,anotherExtender: { intOption: 1});</pre></div><p class="calibre8">As the <code class="literal">extend</code> method is called on the observable, usually during its initial creation, the result of the <code class="literal">extend</code> call is what is actually stored. If the target is not returned, the <code class="literal">amount</code> variable would not be the intended observable.</p><p class="calibre8">To access the extended value, you would use <code class="literal">amount.previousValues()</code> from JavaScript, or <code class="literal">amount.previousValues</code> if accessing it from a binding. Note the lack of parentheses after amount; because <code class="literal">previousValues</code> is a property of the observable, not a property of the observable's value, it is accessed directly. This might not be immediately obvious, but it should make sense as long as you remember that the observable and the value the observable contains are two different JavaScript objects.</p><p class="calibre8">An example of this extender is in the <code class="literal">cp1-extend</code> branch.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec28" class="calibre1"/>Extenders with options</h2></div></div></div><p class="calibre8">The previous example<a id="id90" class="calibre1"/> does not pass any options to the <code class="literal">recordChanges</code> extender, it just uses <code class="literal">true</code> because the property requires a value to be a valid JavaScript. If you want a configuration for your extender, you can pass it as this value, and a complex configuration can be achieved by using another object as the value.</p><p class="calibre8">If we wanted to supply a list of values that are not to be recorded, we could modify the extender to use the options as an array:</p><div><pre class="programlisting">ko.extenders.recordChanges = function(target, options) {
  target.previousValues = ko.observableArray();
  target.subscribe(function(oldValue) {
    if (!(options.ignore &amp;&amp; options.ignore.indexOf(oldValue) !== -1))
      target.previousValues.push(oldValue)
  }, null, 'beforeChange');
  return target;
};</pre></div><p class="calibre8">Then we could call the <a id="id91" class="calibre1"/>extender with an array:</p><div><pre class="programlisting">var history = ko.observable(0).extend({ 
  recordChanges: { ignore: [0, null] } 
});</pre></div><p class="calibre8">Now our <code class="literal">history</code> observable won't record values for <code class="literal">0</code> or <code class="literal">null</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec29" class="calibre1"/>Extenders that replace the target</h2></div></div></div><p class="calibre8">Another common use for extenders is to<a id="id92" class="calibre1"/> wrap the observable with a computed observable that modifies reads or writes, in which case, it would return the new observable instead of the original target.</p><p class="calibre8">Let's take our <code class="literal">recordChanges</code> extender a step further and actually block writes that are in our <code class="literal">ignore</code> array (never mind that an extender named <code class="literal">recordChanges</code> should never do something like this in the real world!):</p><div><pre class="programlisting">ko.extenders.recordChanges = function(target, options) {
  var ignore = options.ignore instanceof Array ? options.ignore : [];
  //Make sure this value is available
  var result = ko.computed({
    read: target,
    write: function(newValue) {
      if (ignore.indexOf(newValue) === -1) {
        result.previousValues.push(target());
        target(newValue);
      } else {
        target.notifySubscribers(target());
      }
    }
  }).extend({ notify: 'always'});

  result.previousValues = ko.observableArray();

  //Return the computed observable
  return result;
};</pre></div><p class="calibre8">That's a lot of changes, so let's unpack them.</p><p class="calibre8">First, to make <code class="literal">ignore</code> <a id="id93" class="calibre1"/>easier to reference, I've set a new variable that will either be the <code class="literal">options.ignore</code> property or an empty array. Defaulting to an empty array lets us skip the null check later, which makes the code a little easier to read. Second, I created a writable computed observable. The <code class="literal">read</code> function just routes to the target observable, but the <code class="literal">write</code> function will only write to the target if the <code class="literal">ignore</code> option doesn't contain the new value. Otherwise, it will notify the target subscribers of the old value. This is necessary because if a UI binding on the observable initiated the change, it needs the illegal change to be reverted. The UI element would already have updated and the easiest way to change it back is through the standard binding notification mechanism that is already listening for changes.</p><p class="calibre8">The last change is the <code class="literal">notify: always</code> extender that's on the <code class="literal">result</code>. This is one of Knockout's default extenders. Normally, an observable will only report changes to subscribers when the value has been modified. To get the observable to reject changes, it needs to be able to notify subscribers of its current unchanged value. The notify extender forces the observable to always report changes, even when they are the same.</p><p class="calibre8">Finally, the extender returns the new computed observable instead of the target, so that anyone trying to write a value does so against the computed.</p><p class="calibre8">The <code class="literal">cp1-extendreplace</code> branch has an example of this binding. Notice that trying to enter values into the input box that are included in the ignored options (<code class="literal">0</code> or an empty string) are immediately reverted.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec18" class="calibre1"/>The Contacts List application</h1></div></div></div><p class="calibre8">It's time to start putting these<a id="id94" class="calibre1"/> concepts together into a usable application. Isolated samples can only take you so far. We are going to cover the application in the <code class="literal">cp1-contacts</code> branch in detail. The application's functionality is all on the <strong class="calibre9">Contacts</strong> page, which you can get to from the navigation bar in your browser. Before we start digging into the code, I encourage you to play around with the application a bit (it does persist data). It will help in understanding the relationships in the code.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec30" class="calibre1"/>Overview</h2></div></div></div><p class="calibre8">The application has three<a id="id95" class="calibre1"/> main JavaScript objects:</p><div><ul class="itemizedlist"><li class="listitem">The contact model</li><li class="listitem">The <strong class="calibre9">Contacts</strong> page viewmodel</li><li class="listitem">The mock data service</li></ul></div><p class="calibre8">The application only uses the HTML in the <code class="literal">index.html</code> file, but the two sections are mostly independent.</p><div><ul class="itemizedlist"><li class="listitem">The entry form (create and edit)</li><li class="listitem">The contacts list</li></ul></div><p class="calibre8">The JavaScript code in the example follows the <strong class="calibre9">Immediately-Invoked Function Expression</strong> (<strong class="calibre9">IIFE</strong>)<a id="id96" class="calibre1"/> pattern (sometimes pronounced "iffy") to isolate code from the global scope, and a namespace called <code class="literal">app</code> to share code between files:</p><div><pre class="programlisting">(function(app, $, ko) {
  /* CODE IN HERE */
})(window.app = window.app || {}, jQuery, ko);</pre></div><p class="calibre8">This is definitely not the only way to organize JavaScript code, and you may have a pattern you prefer. If you <a id="id97" class="calibre1"/>want to understand this pattern better, here are a few online resources:</p><div><ul class="itemizedlist"><li class="listitem"><a class="calibre1" href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">http://benalman.com/news/2010/11/immediately-invoked-function-expression/</a></li><li class="listitem"><a class="calibre1" href="http://addyosmani.com/blog/essential-js-namespacing/">http://addyosmani.com/blog/essential-js-namespacing/</a></li></ul></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec31" class="calibre1"/>The contact model</h2></div></div></div><p class="calibre8">The <code class="literal">client/app/contacts.js</code> file defines <a id="id98" class="calibre1"/>our basic contact object. Let's go over it piece by piece.</p><p class="calibre8">It starts with a standard declaration of observable properties with some default values. There are a lot of reasons to organize code in a variety of ways, but for the smaller models, I prefer to keep all of their persistable properties together at the top:</p><div><pre class="programlisting">app.Contact = function(init) {
  var self = this;
  self.id = ko.observable(0);
  self.firstName = ko.observable('');
  self.lastName = ko.observable('');
  self.nickname = ko.observable('');
  self.phoneNumber = ko.observable('');
  /* More below */</pre></div><p class="calibre8">Next is the <code class="literal">displayName</code> property, some simple logic to generate a nice "title" for UI display. The JavaScript or operator (<code class="literal">||</code>) is used here to ensure we don't try to read the <code class="literal">length</code> property on a <code class="literal">null</code> or <code class="literal">undefined</code> value by returning a default value in case all the names are empty. This <a id="id99" class="calibre1"/>essentially makes it a null-coalescing operator when used during an assignment:</p><div><pre class="programlisting">self.displayName = ko.computed(function() {
      var nickname = self.nickname() || '';
      if (nickname.length &gt; 0)
        return nickname;
      else if ((self.firstName() || '').length &gt; 0)
        return self.firstName() + ' ' + self.lastName();
      else
        return 'New Contact';
    });</pre></div><p class="calibre8">Next is a utility method to update the model that accepts an object and merges in its properties. I generally put a similar method onto all of my models so that I have a standard way of updating them. Once again, we are using <code class="literal">||</code> as a safety net, in case the method is called without a parameter (in the real world, you would want a stronger check, one that ensured <code class="literal">update</code> was an object and not a primitive value or an array):</p><div><pre class="programlisting">//Generic update method, merge all properties into the viewmodel
self.update = function(update) {
  data = update || {};
  Object.keys(data).forEach(function(prop) {
    if (ko.isObservable(self[prop]))
      self[prop](data[prop]);
  });
};

//Set the initial values using our handy-dandy update method.
self.update(init);</pre></div><p class="calibre8">Also note that after defining the <code class="literal">update</code> function, the model calls it with the constructor argument. This lets the constructor provide the ability to create a new model from existing data and partial data as well. This is very useful when deserializing data, for example, JSON from an Ajax request.</p><p class="calibre8">Lastly, we have the <code class="literal">toJSON</code> method. The standard <code class="literal">JSON.stringify</code> method in JavaScript will look for this method to allow an object to control how it is serialized. As Knockout's <code class="literal">ko.toJSON</code> calls <code class="literal">JSON.stringify</code> underneath after it unwraps all the observables so that the serialization gets values and not functions.</p><p class="calibre8">As the serialized form of our model is the one we will try to persist, usually by sending it to the server with Ajax, we don't want to include things such as our computed display name. Our <code class="literal">toJSON</code> method override takes care of this by just deleting the property:</p><div><pre class="programlisting">//Remove unwanted properties from serialized data
    self.toJSON = function() {
      var copy = ko.toJS(self);
      delete copy.displayName;
      return copy;
    };</pre></div><p class="calibre8">The copy with <code class="literal">ko.toJS</code> is important. We don't want to delete <code class="literal">displayName</code> from the actual model; we only want<a id="id100" class="calibre1"/> it removed from the serialized model. If we made the variable with <code class="literal">copy = self</code>, we would just have a reference to the same object. The <code class="literal">ko.toJS</code> method is a simple way to get a plain JavaScript copy that we can safely delete properties from without affecting the original object.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec32" class="calibre1"/>The Contacts page viewmodel</h2></div></div></div><p class="calibre8">The <code class="literal">client/app/contactspage.js</code> file <a id="id101" class="calibre1"/>defines the viewmodel for the <strong class="calibre9">Contacts</strong> page. Unlike our contacts model, the page does a lot more than expose some observable properties, and it isn't designed to be constructed from existing data either. Instead of taking an object to control its starting values, which doesn't make much sense for a page, the constructor's argument is designed for dependency injection; its constructor arguments take in its external dependencies.</p><p class="calibre8">In this example, <code class="literal">dataService</code> is a dependency used by the page viewmodel:</p><div><pre class="programlisting">app.ContactsPageViewmodel = function(dataService)</pre></div><p class="calibre8">Very briefly, if you aren't familiar with dependency injection, it lets us define our page against an API (sometimes called a contract or interface) of methods to get and save data. This is especially useful for us, as in this sample application, we aren't using real Ajax but mocking it with an object that just writes to the DOM's local storage:</p><div><pre class="programlisting">ko.applyBindings(new app.ContactsPageViewmodel(app.mockDataService));</pre></div><div><h3 class="title2"><a id="note06" class="calibre1"/>Note</h3><p class="calibre8">For more information on the <a id="id102" class="calibre1"/>DOM local storage, see the page on the Mozilla Developer Network at <a class="calibre1" href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage">https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage</a>.</p></div><p class="calibre8">However, when we write the real Ajax service later, our <code class="literal">ContactsPageViewmodel</code> doesn't need to <a id="id103" class="calibre1"/>change at all. We will just construct it with a different <code class="literal">dataService</code> parameter. As long as they expose the same methods (the same API) it will just work.</p><p class="calibre8">The first section inside the constructor is for the contacts list. We expose an observable array and get the contacts from our data service:</p><div><pre class="programlisting">self.contacts = ko.observableArray();

dataService.getContacts(function(contacts) {
  self.contacts(contacts);
});</pre></div><p class="calibre8">We are passing callback to the <code class="literal">getContacts</code> call because our data service provides an asynchronous API. When the data service has finished getting our contacts, it will call the callback with them. All our callback needs to do is put them into the <code class="literal">contacts</code> array.</p><p class="calibre8">The next block of code is to control the <a id="id104" class="calibre1"/>
<strong class="calibre9">CRUD</strong> (<strong class="calibre9">Create, Read, Update, Delete</strong>) operations for individual contacts. First, we expose an observable object that we will use for all edits:</p><div><pre class="programlisting">self.entryContact = ko.observable(null);

    self.newEntry = function() {
      self.entryContact(new app.Contact());
    };
    self.cancelEntry = function() {
      self.entryContact(null);
    };</pre></div><p class="calibre8">Our UI is going to bind an edit form against the <code class="literal">entryContact</code> property. The entry contact property is pulling a double duty here; it contains the contact that is being created or edited, and it indicates that editing is occurring. If the entry contact is null, then we aren't editing; if it has an object, then we are editing. The UI will use <code class="literal">with</code> and <code class="literal">if</code> bindings to control which content to show based on this logic.</p><p class="calibre8">The <code class="literal">newEntry</code> and <code class="literal">cancelEntry</code> functions provide the UI with a means to switch between these two states.</p><p class="calibre8">For editing existing contacts, we just expose another function that takes a contact and sets the entry contact to it:</p><div><pre class="programlisting">self.editContact = function(contact) {
      self.entryContact(contact);
    };</pre></div><p class="calibre8">The last thing we need for real editing is the ability to persist our changes. As in the real world, we have three scenarios, namely creating new objects, saving existing objects, and deleting existing objects.</p><p class="calibre8">Creating and updating are both going to be done using the <code class="literal">entryContact</code> property, and we want to be able to bind the same form for both, which means we need to target a single function:</p><div><pre class="programlisting">self.saveEntry = function() {
  if (self.entryContact().id() === 0) {
    dataService.createContact(self.entryContact(), function() {
      self.contacts.push(self.entryContact());
      self.entryContact(null);
    });
  } else {
    dataService.updateContact(self.entryContact(), function() {
      self.entryContact(null);
    });
  }
};</pre></div><p class="calibre8">Internally, our <code class="literal">saveEntry</code> method checks for a non-default <code class="literal">id</code> value to determine whether or not it's <a id="id105" class="calibre1"/>making a new object or updating an existing one. Both are calls to the data service using the entry contact with a callback to clear the <code class="literal">entryContact</code> property out (as we are done with editing). In the creation case, we also want to add the newly created contact to our local list of contacts before emptying the entry contact:</p><div><pre class="programlisting">self.contacts.push(self.entryContact());
self.entryContact(null);</pre></div><p class="calibre8">You might think that the contact is going to be null out by the second line, but that is not the case. The <code class="literal">entryContact</code> property is an observable and its value is a contact. The first line reads this value and pushes it into the <code class="literal">contacts</code> array. The second line sets the value of the <code class="literal">entryContact</code> property to <code class="literal">null</code>; it does not affect the contact that was just pushed. It's the same as if we had set a variable to null after adding it to an array. The variable was a reference to the object, and making the variable null removes the reference, not the object itself.</p><p class="calibre8">The delete function is simple by comparison:</p><div><pre class="programlisting">self.deleteContact = function(contact) {
      dataService.removeContact(contact.id(), function() {
        self.contacts.remove(contact);
      });
    };</pre></div><p class="calibre8">It's going to take an existing contact, like <code class="literal">editContact</code> did, and call the data service. As we are deleting the contact, the only thing we need is the <code class="literal">id</code> property. The callback will remove the contact from the list of contacts when the service is done, using the <code class="literal">remove</code> function provided on all observable arrays by Knockout.</p><p class="calibre8">The last piece of functionality on the page is the search mechanism. It starts with an observable to track the search and a function to clear it out:</p><div><pre class="programlisting">self.query = ko.observable('');
self.clearQuery = function() { self.query(''); };</pre></div><p class="calibre8">The <code class="literal">query</code> property is going to be used to filter out any contacts that don't have a matching or partially-matching property. If we wanted to be as flexible as possible, we could search against every property. However, since our list of contacts is only going to show our computed <code class="literal">displayName</code> and phone number, it would look odd to return results matching on<a id="id106" class="calibre1"/> properties we didn't show. This is the computed observable from the code sample that filters the contacts list:</p><div><pre class="programlisting">self.displayContacts = ko.computed(function() {  
  //No query, just return everything
  if (self.query() === '')
    return self.contacts();
  var query = self.query().toLowerCase();
  //Otherwise, filter all contacts using the query
  return ko.utils.arrayFilter(self.contacts(), function(c) {
    return c.displayName().toLowerCase().indexOf(query) !== -1 
        || c.phoneNumber().toLowerCase().indexOf(query) !== -1;
  });
});</pre></div><div><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre8">If you want to filter all of the contact's properties, they are listed in the repository code as comments. They can easily be re-enabled by uncommenting each line.</p></div><p class="calibre8">First, we check to see whether the query is empty, because if it is, we aren't going to filter anything so we don't want to waste cycles iterating the contacts anyway.</p><p class="calibre8">Before starting, we call the <code class="literal">toLowerCase()</code> function on the query to avoid any case sensitivity issues. Then, we iterate on the contacts. Knockout provides several utilities methods for arrays (among other things) on the <code class="literal">ko.utils</code> object. The <code class="literal">arrayFilter</code> function takes an array and an iterator function, which is called on each element of the array. If the function returns <code class="literal">true</code>, <code class="literal">arrayFilter</code> will include that element in its return value; otherwise it will filter the element out. All our iterator needs to do is compare the properties we want to keep the filter on (remembering to put them in lowercase first).</p><p class="calibre8">Now if the UI binds against <code class="literal">displayContacts</code>, the search functionality will filter the UI.</p><p class="calibre8">However, we might experience poor performance with a large list of contacts if we are looping through them all every time the query is updated, especially if the query updates every time a key is pressed. To address this, we can use the standard Knockout <code class="literal">rateLimit</code> extender on our filtered computed to stop it from updating too frequently:</p><div><pre class="programlisting">self.displayContacts = ko.computed(function() {
  /* computed body */
}).extend({
  rateLimit: {
    timeout: 100,
    method: 'notifyWhenChangesStop'
  }
});</pre></div><p class="calibre8">This extender has two modes: <code class="literal">notifyAtFixedRate</code> and <code class="literal">notifyWhenChangesStop</code>. These two options will throttle or debounce the computed.</p><div><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre8">If you aren't familiar with the throttling<a id="id107" class="calibre1"/> and <a id="id108" class="calibre1"/>debouncing functions, there is an excellent explanation with visuals at <a class="calibre1" href="http://drupalmotion.com/article/debounce-and-throttle-visual-explanation">http://drupalmotion.com/article/debounce-and-throttle-visual-explanation</a>.</p></div><p class="calibre8">This lets us <a id="id109" class="calibre1"/>control how often the computed re-evaluates itself. The preceding example will only re-evaluate the computed once all dependencies have stopped changing for 100 ms. This will let the UI update when the query typing settles down while still appearing to filter as the user types.</p><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>A philosophical note on a model versus a viewmodel</h3></div></div></div><p class="calibre8">The line between model and <a id="id110" class="calibre1"/>viewmodel in client-server application can get blurry, and <a id="id111" class="calibre1"/>even after reading Knockout's <a id="id112" class="calibre1"/>documentation (<a class="calibre1" href="http://knockoutjs.com/documentation/observables.html">http://knockoutjs.com/documentation/observables.html</a>) it can be unclear whether or not our contact object is really a model or viewmodel. Most would probably argue that it is a viewmodel as it has observables. I like to think of these smaller objects, which are barely more than their persisted data, as models and to think of viewmodels as the objects containing operations and view representations, such as our <strong class="calibre9">Contacts</strong> page viewmodel <code class="literal">removeContact</code> operation or the <code class="literal">entryContact</code> property.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch01lvl2sec33" class="calibre1"/>Mock data service</h2></div></div></div><p class="calibre8">Normally, you would use an <a id="id113" class="calibre1"/>Ajax call, probably with jQuery, to retrieve data and submit data to and from the server. Because this is a book on Knockout and not Node.js, I wanted to keep the server as thin as possible. From the "Mastering Knockout" perspective, whether we call a JavaScript object making Ajax requests or store it in the DOM is immaterial. As long as we are working with something that looks and functions like an asynchronous service, we can explore how Knockout viewmodels might interact with it. That being said, there is some functionality in the data service that would be used in an Ajax data service object, and it is interesting from a Knockout application development perspective.</p><p class="calibre8">You might have noticed in the previous section that when the <strong class="calibre9">Contacts</strong> page view model communicated with the data service, it wasn't dealing with JSON but real JavaScript objects. In fact, not even plain JavaScript objects but our contact model. This is because part of the data service's responsibility, whether it's a mock or a real Ajax service, is to abstract away the knowledge of the service mechanisms. In our case, this means translating between JSON and our Knockout models:</p><div><pre class="programlisting">createContact: function(contact, callback) {
  $.ajax({
      type: "POST",
      url: "/contacts",
      data: ko.toJS(contact)
    })
    .done(function(response) {
      contact.id(response.id);
      callback()
    });
}</pre></div><p class="calibre8">This is the <code class="literal">createContact</code> method from our mock data service  if it was rewritten to use real Ajax (this code is in the <code class="literal">mockDataService.js</code> file as a comment). The data service is part of our application, so it knows that it's working with observable properties and that it needs to translate them into plain JavaScript for jQuery to properly serialize it, so it unwraps the contact that it's given with <code class="literal">ko.toJS</code>. Then, in the <code class="literal">done</code> handler, it takes the <code class="literal">id</code> that it gets back from the server's response and updates the contact's observable <code class="literal">id</code> property with it. Finally, it calls the callback to signify that it's done.</p><p class="calibre8">You might wonder why it doesn't pass <code class="literal">contact</code> as an argument to the callback. It certainly could, but it isn't necessary. The original caller already had the contact, and the only thing that the caller is going to need is the new <code class="literal">id</code> value. We've already updated the <code class="literal">id</code>, and as it's observable, any subscriber will pick that new value up. If we needed some special handling before setting the <code class="literal">id</code> value, that would be a different case and we could raise the callback with <code class="literal">id</code> as an argument.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch01lvl2sec34" class="calibre1"/>The view</h2></div></div></div><p class="calibre8">Hopefully, you have already played<a id="id114" class="calibre1"/> with the application a bit. If you haven't, now is the time. I'll wait.</p><p class="calibre8">You would have noticed that when <a id="id115" class="calibre1"/>adding or editing contacts, the contacts list is removed. What you might not have noticed is that the URL doesn't change; the browser isn't actually navigating when we switch between these two views. Though they are in the same HTML file, these two different views are mostly independent and they are controlled through a <code class="literal">with</code> and an <code class="literal">ifnot</code> binding.</p><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec04" class="calibre1"/>The edit form</h3></div></div></div><p class="calibre8">This is what is shown when adding or <a id="id116" class="calibre1"/>editing contacts:</p><div><pre class="programlisting">&lt;form class="form" role="form" data-bind="with: entryContact, submit: saveEntry"&gt;
      &lt;h2 data-bind="text: displayName"&gt;&lt;/h2&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="firstName" class="control-label"&gt;First Name&lt;/label&gt;
        &lt;input type="text" class="form-control" id="firstName"placeholder="First Name" data-bind="value: firstName"&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="lastName" class="control-label"&gt;Last Name&lt;/label&gt;
        &lt;input type="text" class="form-control" id="lastName" placeholder="First Name" data-bind="value: lastName"&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="nickname" class="control-label"&gt;Nickname&lt;/label&gt;
        &lt;input type="text" class="form-control" id="nickname" placeholder="First Name" data-bind="value: nickname"&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;label for="phoneNumber" class="control-label"&gt;Phone Number&lt;/label&gt;
        &lt;input type="tel" class="form-control" id="phoneNumber" placeholder="First Name" data-bind="value: phoneNumber"&gt;
      &lt;/div&gt;
      &lt;div class="form-group"&gt;
        &lt;button type="submit" class="btn btn-primary"&gt;Save&lt;/button&gt;
        &lt;button data-bind="click: $parent.cancelEntry" class="btn btn-danger"&gt;Cancel&lt;/button&gt;
      &lt;/div&gt;
    &lt;/form&gt;</pre></div><p class="calibre8">Because the <code class="literal">with</code> binding is also implicitly an <code class="literal">if</code> binding, the entire form is hidden when the <code class="literal">entryContact</code> property is null or undefined.</p><p class="calibre8">The rest of the form is pretty straightforward. A <code class="literal">submit</code> binding is used so that clicking the save button or hitting the enter key on any field calls the submit handler, a header showing the display name, value<a id="id117" class="calibre1"/> bindings for each field, a save button with <code class="literal">type="submit</code>" (so that it uses the submit handler), and a cancel button that binds to <code class="literal">$parent.cancelEntry</code>. Remember, the <code class="literal">$parent</code> scope is necessary because the <code class="literal">with</code> binding creates a binding context on the <code class="literal">entry</code> contact and <code class="literal">cancelEntry</code> is a function on <code class="literal">ContactPageViewmodel</code>.</p></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec05" class="calibre1"/>Contacts list</h3></div></div></div><p class="calibre8">The list starts with an <code class="literal">ifnot</code> binding <a id="id118" class="calibre1"/>on the <code class="literal">entryContact</code> property, ensuring that it only shows in the case that the previous form is hidden. We only want one or the other to be seen at a time:</p><div><pre class="programlisting">&lt;div data-bind="ifnot: entryContact"&gt;
  &lt;h2&gt;Contacts&lt;/h2&gt;
  &lt;div class="row"&gt;
    &lt;div class="col-xs-8"&gt;
      &lt;input type="search" class="form-control" data-bind="value: query, valueUpdate: 'afterkeydown'" placeholder="Search Contacts"&gt;
    &lt;/div&gt;
    &lt;div class="col-xs-4"&gt;
      &lt;button class="btn btn-primary" data-bind="click: newEntry"&gt;Add Contact&lt;/button&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;ul class="list-unstyled" data-bind="foreach: displayContacts"&gt;
    &lt;li&gt;
      &lt;h3&gt;
        &lt;span data-bind="text: displayName"&gt;&lt;/span&gt; 
          &lt;small data-bind="text: phoneNumber"&gt;&lt;/small&gt;
        &lt;button class="btn btn-sm btn-default" data-bind="click: $parent.editContact"&gt;Edit&lt;/button&gt;
        &lt;button class="btn btn-sm btn-danger" data-bind="click: $parent.deleteContact"&gt;Delete&lt;/button&gt;
      &lt;/h3&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;</pre></div><p class="calibre8">The search input has a <code class="literal">value</code> binding as well as the <code class="literal">valueUpdate</code> option. The value update option controls when the <code class="literal">value</code> binding reports changes. By default, changes are reported on blur, but the <code class="literal">afterkeydown</code> setting causes changes to be reported immediately after the input gets a new letter. This would cause the search to update in real time, but remember that the display contacts have a <code class="literal">rateLimit</code> extender that debounces the updates to 100 ms.</p><p class="calibre8">Next to the search box is a<a id="id119" class="calibre1"/> button to add a new contact. Then, of course, the list of contacts is bound with a <code class="literal">foreach</code> binding on the <code class="literal">displayContacts</code> property. If it was bound against <code class="literal">contacts</code> directly, the list would not show the filtering. Depending on your application, you might even want to keep the unfiltered contacts list private and only expose the filtered lists. The best option really does depend on what else you're doing, and in most cases, it's okay to use your personal preference.</p><p class="calibre8">Inside the contacts list, each item shows the display name for the phone number, with a button to edit or delete the contact. As <code class="literal">foreach</code> creates a binding context on the individual contact and the edit and delete functions are on the parent, the <code class="literal">click</code> binding uses the <code class="literal">$parent</code> context property. The <code class="literal">click</code> binding also sends the current model to each of the edit and delete functions, so that these functions don't have to try to find the right JavaScript object by looking through the full list.</p><p class="calibre8">That's really all there is to the application. We've got a list view with searching that switches to a view that's reused easily for both editing and creating.</p></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec19" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In most of this chapter, we reviewed the use of standard Knockout. Hopefully, I didn't lose you in the weeds back there. The important thing is that before we move on to extending Knockout with custom functionality or building larger applications, you must feel comfortable with the basic use of observables and data binding. This includes:</p><div><ul class="itemizedlist"><li class="listitem"><code><strong class="calibre9">Extenders</code>: This includes creating extenders and extending observables</li><li class="listitem"><strong class="calibre9">Templates</strong>: This tells us how the flow of control works, what a binding context is, inline versus named templates, and containerless control flow</li></ul></div><p class="calibre8">In the next chapter, we will be adding new functionalities to Knockout by creating our own binding handlers.</p></div></body></html>