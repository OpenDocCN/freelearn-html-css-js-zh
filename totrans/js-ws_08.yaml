- en: 8\. Browser APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 浏览器API
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: By the end of this chapter, you will be able to explain what a web/browser API
    is; draw in HTML using JavaScript; create and control audio in the browser; store
    data in the browser; decide on the type of storage to use in different circumstances;
    measure and track a website's performance; and create and manage a sustained,
    two-way connection between the browser and server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够解释什么是Web/浏览器API；使用JavaScript在HTML中绘制；在浏览器中创建和控制音频；在浏览器中存储数据；在不同情况下决定使用哪种存储类型；测量和跟踪网站的性能；以及创建和管理浏览器与服务器之间的持续、双向连接。
- en: In this chapter, you will learn about interesting browser APIs and look at JavaScript's
    extended capabilities.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解有趣的浏览器API，并查看JavaScript的扩展功能。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In the previous chapter, we looked at the different examples of JavaScript runtime
    environments and had an overview of their components. We'll now look at one of
    those components in greater depth, that is, the **Browser Object Model** (**BOM**),
    and the APIs it exposes to JavaScript.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了不同的JavaScript运行时环境的不同示例，并对它们的组件进行了概述。现在，我们将更深入地研究这些组件之一，即**浏览器对象模型**（**BOM**），以及它向JavaScript公开的API。
- en: The BOM is a set of properties and methods that are made available to JavaScript
    by the browser. Now, you've come across many parts of the BOM already, with methods
    such as `setTimeOut()`, and the document property, with its many methods, such
    as `addEventListener()`. It's a subtle but important point that the methods and
    properties we'll cover in this chapter are not part of the JavaScript programming
    language; that is to say, they're not part of the ECMAScript specification – the
    specification to which JavaScript engines are built – but they are methods and
    properties of the browser, and they form the interface between JavaScript and
    the browser (and by extension, between JavaScript and the rest of the system it's
    being run on).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: BOM是一组属性和方法，浏览器通过这些属性和方法将它们提供给JavaScript。现在，你已经遇到了BOM的许多部分，例如`setTimeOut()`方法和文档属性，它具有许多方法，如`addEventListener()`。这是一个微妙但重要的观点，我们将在本章中讨论的方法和属性不是JavaScript编程语言的一部分；也就是说，它们不是ECMAScript规范的一部分——JavaScript引擎是按照这个规范构建的——但它们是浏览器的方法和属性，并且构成了JavaScript和浏览器（以及通过扩展，与它运行的其他系统）之间的接口。
- en: In the same way that every browser has its own implementation of the JavaScript
    engine, each browser implements the BOM in a slightly different way. So, it's
    important to check cross-browser compatibility for the features you want to use
    as a developer and implement **fallbacks** or **polyfills** for browsers that
    don't support certain features. It's often the case that the current version of
    a particular browser supports a certain functionality, but older versions do not.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如每个浏览器都有自己的JavaScript引擎实现一样，每个浏览器都以略微不同的方式实现BOM。因此，作为开发者，检查你想要使用的功能的跨浏览器兼容性非常重要，并为不支持某些功能的浏览器实现**回退**或**polyfills**。通常情况下，特定浏览器的当前版本支持某些功能，但旧版本则不支持。
- en: As we've already mentioned, you've seen many of the more commonly used methods
    of the BOM. Here, we will look at some of the most commonly used and useful browser
    APIs in more detail, as well as some less frequently used yet powerful aspects
    of the BOM that will greatly increase the number and functionality of tools at
    your disposal, and which can allow you to build some super cool and possibly even
    useful features into your sites and apps.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，你已经看到了BOM中一些更常用的方法。在这里，我们将更详细地探讨一些最常用且实用的浏览器API，以及一些不太常用但功能强大的BOM方面，这将大大增加你可用工具的数量和功能，并允许你将一些超级酷甚至可能很有用的功能构建到你的网站和应用程序中。
- en: Canvas
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Canvas
- en: Images and diagrams are a fundamental part of creating engaging websites and
    applications. We already know how to include images and videos in our pages, but
    we can also draw our own images, diagrams, and even complex visuals such as charts
    or game elements by using JavaScript and the `<canvas>` element using JavaScript.
    With it, we can draw paths and rectangles, and control things such as stroke and
    fill color, line dashes, and arc radiuses (or radii, if that's your flavor).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图片和图表是创建引人入胜的网站和应用程序的基本组成部分。我们已经知道如何在我们的页面中包含图片和视频，但我们可以通过使用JavaScript和`<canvas>`元素来绘制自己的图片、图表，甚至复杂的视觉元素，如图表或游戏元素。有了它，我们可以绘制路径和矩形，并控制诸如描边和填充颜色、线段虚线、圆弧半径（或半径，如果你喜欢这样称呼）等。
- en: 'The process of drawing inside an HTML canvas using JavaScript can be broken
    down into a few distinct steps:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript在HTML画布内绘制图形的过程可以分解为几个不同的步骤：
- en: Get a reference to the HTML's canvas element.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取HTML的画布元素的引用。
- en: Get a new canvas rendering context that the graphic is drawn onto.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取一个新的画布渲染上下文，图形将绘制在其上。
- en: Set various drawing styles and options as required (for example, line width
    and fill color).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要设置各种绘图样式和选项（例如，线宽和填充颜色）。
- en: Define the paths that will make up the graphics.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义构成图形的路径。
- en: '"Stroke" or fill the defined paths and shapes – this is the step where the
    actual drawing takes place.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “描边”或填充定义的路径和形状——这是实际绘图发生的步骤。
- en: 'In the following exercise, we will start by using the `fillRect()` method.
    This method is one of the methods we can use for drawing on the canvas and, as
    its name suggests, draws a rectangle and fills it with color. To describe the
    rectangle, we require four pieces of information: the `x` and `y` coordinates
    of the top-left corner, the rectangle''s width, and its height. Therefore, the
    parameters we will pass to `fillRect()` are an `x` coordinate, a `y` coordinate,
    the width, and the height.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的练习中，我们将首先使用`fillRect()`方法。这个方法是我们可以在画布上绘制的方法之一，正如其名称所暗示的，它绘制一个矩形并用颜色填充它。为了描述矩形，我们需要四个信息：左上角`x`和`y`坐标，矩形的宽度和高度。因此，我们将传递给`fillRect()`的参数是一个`x`坐标，一个`y`坐标，宽度，和高度。
- en: 'Exercise 8.01: Drawing Shapes Using Canvas Elements'
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：使用Canvas元素绘制形状
- en: 'Let''s get started with an exercise in which we''ll learn how to work with
    a Canvas element, some of the components that make up the API, and how we can
    use it to draw simple shapes. The Canvas API has many methods and interfaces.
    In this exercise, we''ll look at a few of the most commonly used ones. Let''s
    get started:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一项练习开始，我们将学习如何与Canvas元素一起工作，API的一些组成部分，以及我们如何使用它来绘制简单的形状。Canvas API有许多方法和接口。在这个练习中，我们将查看一些最常用的方法。让我们开始吧：
- en: 'Create an HTML file called `index.html` with a `<canvas>` element and a reference
    to a JavaScript file in the HTML body in the `DevTools` console. We''ll call the
    JavaScript file `canvas.js`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`index.html`的HTML文件，其中包含一个`<canvas>`元素，并在HTML主体的`DevTools`控制台中引用一个JavaScript文件。我们将把这个JavaScript文件命名为`canvas.js`：
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We''ve given the canvas element an ID of `''canvas''` so that we can select
    it easily in JavaScript, and an inline style of `"border: 1px solid"` so that
    we can see the area that the canvas takes up on the HTML page.'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们已经给画布元素分配了一个ID为`''canvas''`，这样我们就可以在JavaScript中轻松选择它，并且有一个内联样式`"border: 1px
    solid"`，这样我们就可以看到画布在HTML页面中占据的区域。'
- en: 'Next, we''ll create our `canvas.js` file in the same directory as `index.html`
    and declare a variable that will hold a reference to our HTML canvas element:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在与`index.html`相同的目录下创建一个名为`canvas.js`的文件，并声明一个变量来保存对HTML画布元素的引用：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we''ll create a rendering context by calling the `getContext()` method
    with the `''2d''` parameter since we will be drawing 2D graphics. This method
    takes in a string to denote the context type and returns a drawing context that''s
    used to draw and modify the graphics we want to display. There are several types
    of context, but for this introduction to Canvas, we will be looking only at `''2d''`
    contexts:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将通过使用带有`'2d'`参数的`getContext()`方法创建一个渲染上下文，因为我们将会绘制2D图形。此方法接收一个字符串来表示上下文类型，并返回一个用于绘制和修改我们想要显示的图形的绘图上下文。有几种类型的上下文，但在这个Canvas的介绍中，我们只会查看`'2d'`上下文：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that we have the context, we can start drawing. The canvas object works
    on a grid system, with its origin in the top left, so that the `0`,`0` coordinates
    are at the top left of the canvas. It's from this origin that we can draw our
    graphics.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们有了上下文，我们可以开始绘图了。画布对象使用网格系统，其原点位于左上角，因此`0`,`0`坐标位于画布的左上角。我们从这个原点开始绘制我们的图形。
- en: 'Finally, we''ll use the `fillRect()` method to draw a `100` by `100` pixel
    rectangle on the canvas:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`fillRect()`方法在画布上绘制一个`100`乘`100`像素的矩形：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, open the HTML file in your browser. You should see something like this:'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开HTML文件。你应该会看到如下内容：
- en: '![Figure 8.1: Simple canvas with a square inside'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.1：带有内部正方形的简单画布'
- en: '](img/C14377_08_01.jpg)'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_08_01.jpg)'
- en: 'Figure 8.1: Simple canvas with a square inside'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.1：带有内部正方形的简单画布
- en: 'You''ve probably already noticed that the canvas element is fairly small. By
    default, a canvas is `300` by `150` pixels, so let''s add a couple of lines to
    our JavaScript so that the canvas'' dimensions match the size of our window when
    we load the HTML page. We''ll use the window object''s `innerWidth` and `innerHeight`
    properties – which tell us the viewport''s width and height – to set the canvas''
    width and height:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到了画布元素相当小。默认情况下，画布是 `300` x `150` 像素，所以让我们在我们的 JavaScript 中添加几行代码，以便在加载
    HTML 页面时画布的尺寸与窗口的大小相匹配。我们将使用窗口对象的 `innerWidth` 和 `innerHeight` 属性——它们告诉我们视口的宽度和高度——来设置画布的宽度和高度：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have a much larger canvas (assuming your browser window is bigger
    than `300` x `150` pixels), we can start to play around with this and other drawing
    methods. Let''s add a few more rectangles but mix things up a bit:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个更大的画布（假设你的浏览器窗口比 `300` x `150` 像素大），我们可以开始尝试使用这些和其他绘图方法。让我们添加几个更多的矩形，但稍微改变一下：
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We should now have five new rectangles that look something like this (there''s
    actually six if you include `clearRect()` inside the filled black rectangle at
    the end):![Figure 8.2: Six more rectangles'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在应该有五个新的矩形，看起来像这样（如果包括填充黑色矩形的末尾的 `clearRect()`，实际上有六个）：![图 8.2：六个更多矩形
- en: '](img/C14377_08_02.jpg)'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_08_02.jpg)'
- en: 'Figure 8.2: Six more rectangles'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：六个更多矩形
- en: In this exercise, we learned how to draw all formats of rectangles using the
    `canvas` element.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用 `canvas` 元素绘制所有格式的矩形。
- en: 'The additional lines of code in the exercise are pretty self-explanatory, but
    there are still a few things to point out:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 练习中额外的代码相当直观，但仍有一些事情需要指出：
- en: The `fillStyle` and `strokeStyle` properties can take any valid CSS color value
    (hexadecimal, RBG, RGBA, HSL, HSLA, or named color).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fillStyle` 和 `strokeStyle` 属性可以接受任何有效的 CSS 颜色值（十六进制、RGB、RGBA、HSL、HSLA 或命名颜色）。'
- en: The `setLineDash` property takes an array of numbers that determine the distances
    of drawn lines and spaces. The list is repeated, so if you pass [`5`], the lines
    and spaces will repeat at `5` pixels in length each. If you pass [`5`, `15`],
    then all the lines will be `5` pixels, and all the spaces will be `15` pixels.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setLineDash` 属性接受一个数字数组，用于确定绘制线条和空白的距离。列表会重复，所以如果你传入 `[5]`，线条和空白将重复，每个长度为
    `5` 像素。如果你传入 `[5, 15]`，则所有线条都将为 `5` 像素，所有空白都将为 `15` 像素。'
- en: Once set, `fillStyle`, `strokeStyle`, and `setLineDashvalues` persist for anything
    drawn in the same context, so you need to make sure that you reset the value if
    you need to, as we have with the `setLineDash` property (otherwise the red rectangle
    will be dashed) and `fillStyle`.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦设置，`fillStyle`、`strokeStyle` 和 `setLineDashvalues` 将持续应用于同一上下文中绘制的任何内容，所以如果你需要，请确保重置值，就像我们用
    `setLineDash` 属性（否则红色矩形将是虚线）和 `fillStyle` 所做的那样。
- en: The `clearRect` method can be used to remove a drawn area from another part
    of the canvas.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clearRect` 方法可以用来从画布的另一部分移除绘制的区域。'
- en: Manipulate Shapes Using Path
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用路径操纵形状
- en: 'Now that we''ve mastered drawing rectangles, we''ll start drawing more interesting
    shapes with paths using some of the other methods available on the context object.
    A path is a list of points that are joined by lines. We can manipulate the properties
    of these paths, such as their curvature, color, and thickness. This time, we''ll
    go through the methods first, and then see them in action:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了绘制矩形的技巧，我们将开始使用上下文对象上可用的其他一些方法绘制更有趣的形状。路径是一系列由线条连接的点。我们可以操纵这些路径的属性，如它们的曲率、颜色和粗细。这次，我们将首先介绍方法，然后看看它们是如何工作的：
- en: '`beginPath()`: Starts a new path list'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beginPath()`: 开始一个新的路径列表'
- en: '`moveTo(x,y)`: Sets the point at which the next path will be drawn from'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`moveTo(x,y)`: 设置下一个路径绘制的起点'
- en: '`lineTo(x,y)`: Creates a line from the current point to the coordinates passed
    to the method'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lineTo(x,y)`: 从当前点创建一条到方法传入坐标的线'
- en: '`closePath()`: Creates a line from the most recent point to the first point,
    thereby closing off the shape'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closePath()`: 从最近的一个点创建一条到第一个点的线，从而封闭形状'
- en: '`stroke()`: Draws the shape that''s been described'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stroke()`: 绘制已描述的形状'
- en: '`fill()`: Fills in the described shape with a solid color'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill()`: 用纯色填充所描述的形状'
- en: 'These methods can be used to draw a big triangle that takes up most of the
    canvas'' width and height. You can replace the previous code in canvas.js with
    the following, or create a new JavaScript file and change the `<script>` tag''s
    source attribute in the HTML file to reflect the new JavaScript file:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法可以用来画一个占据大部分画布宽度和高度的三角形。你可以用以下代码替换canvas.js中的上一段代码，或者创建一个新的JavaScript文件，并在HTML文件中的`<script>`标签的源属性中更改以反映新的JavaScript文件：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: First of all, we assigned the window's innerWidth and innerHeight values to
    a variable because we'll be using them more than once. After getting a reference
    to the canvas object, we begin a new path and move our starting point to `50`
    pixels on both axes. Next, we plot a line from our current point to a point `50`
    pixels less than the innerWidth, and `50` pixels from the top. Then, we plot a
    line to a point half the innerWidth, and `50` pixels from the bottom. The final
    two methods are used to close the path and draw the entire shape with the `stroke()`
    method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将窗口的内部宽度和高度值赋给一个变量，因为我们将会多次使用它们。在获取到画布对象的引用后，我们开始一个新的路径，并将起始点移动到两个轴上的`50`像素处。然后，我们从一个当前点画一条线到内宽度的`50`像素处，顶部`50`像素处的一个点。接着，我们画一条线到一个内宽度的半数，底部`50`像素处的一个点。最后两个方法用于关闭路径，并使用`stroke()`方法绘制整个形状。
- en: '![Figure 8.3: A triangle'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3：一个三角形'
- en: '](img/C14377_08_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_08_03.jpg)'
- en: 'Figure 8.3: A triangle'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：一个三角形
- en: 'The steps to create a fractal pattern are fairly straightforward, but here
    are some pointers to keep in mind:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分形图案的步骤相当直接，但以下是一些需要记住的要点：
- en: The starting point should be the middle of the `canvas` element.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 起始点应该是`canvas`元素的中部。
- en: The line is drawn in one of four directions.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线条在四个方向之一绘制。
- en: The line drawing part of the function should repeat as long as the point is
    within the bounds of the canvas.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当点在画布边界内时，函数的线条绘制部分应重复执行。
- en: In the preceding example, the lines increase in length after every two plots
    of a line. You can, however, get a similar result by increasing the line length
    on every line.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的例子中，线条在每画两条线后长度增加。然而，你也可以通过在每条线上增加线条长度来得到类似的结果。
- en: 'Activity 8.01: Creating a Simple Fractal'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动8.01：创建一个简单的分形
- en: 'We''re now going to put what we''ve learned about HTML Canvas into practice.
    This time, we''ll be using JavaScript to repeat the drawing steps to create a
    very **simple fractal**. Have a go at creating a pattern like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将把关于HTML Canvas所学的知识应用到实践中。这次，我们将使用JavaScript重复绘制步骤以创建一个非常**简单的分形**。尝试创建一个像这样的图案：
- en: '![Figure 8.4: A basic pattern'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4：一个基本模式'
- en: '](img/C14377_08_04.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_08_04.jpg)'
- en: 'Figure 8.4: A basic pattern'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：一个基本模式
- en: 'Follow these steps to create a fractal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建分形：
- en: Initialize a variable with coordinates for a starting point in the middle of
    the canvas.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在画布中部初始化一个坐标变量作为起始点。
- en: 'Create a loop. For every iteration of the loop, alternate between increasing
    and decreasing the coordinates and drawing the line:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个循环。对于循环的每一次迭代，交替增加和减少坐标并绘制线条：
- en: Increase or decrease the coordinate values to move the point outward in a spiral
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过增加或减少坐标值来使点向外螺旋移动
- en: Draw a line from the previous point to the new one
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从上一个点到新点画一条线
- en: End the loop when the point reaches any edge of the canvas.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点达到画布的任何边缘时，结束循环。
- en: Spend some time trying to do this on your own before checking the solution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看解决方案之前，先花些时间自己尝试做这个。
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 732.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第732页找到。
- en: 'For now, we''ll move on to another web API: the Web Audio API.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将继续学习另一个Web API：Web Audio API。
- en: Web Audio API
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Audio API
- en: This API provides a set of methods and objects that we can use to add audio
    to HTML from a variety of sources, even allowing developers to create new sounds
    from scratch. The API is feature-rich and supports effects such as panning, low-pass
    filters, and many others that can be combined to create different kinds of audio
    applications.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此API提供了一套方法和对象，我们可以使用它们从各种来源向HTML添加音频，甚至允许开发者从头创建新声音。该API功能丰富，支持诸如声像、低通滤波器等多种效果，可以组合起来创建不同类型的音频应用程序。
- en: 'Like the Canvas API, the **Audio API** starts with an audio context, and then
    multiple audio nodes are created within the context to form an audio processing
    graph:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与Canvas API类似，**Audio API**从音频上下文开始，然后在上下文中创建多个音频节点，形成一个音频处理图：
- en: '![Figure 8.5\. The audio context and its audio processing graph'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_08_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5\. The audio context and its audio processing graph
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: An **audio node** can be a source, a destination, or an audio processor, such
    as a filter or a gain node, and they can be combined to create the desired audio
    output, which can then be passed to the user's speakers or headphones.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 8.02: Creating an Oscillator Waveform'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will see how we can create **a simple oscillator waveform**
    in JavaScript and output it to the system''s audio output device. Let''s get started:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating an audio context and adding a volume and oscillator
    node. Type or copy and paste the following code into the console window of Google
    Chrome''s Developer Tools (accessible using the *F12* key):'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we''ll set the oscillator type to `''sawtooth''` and set the frequency
    of oscillation to `100`. Instead of `''sawtooth''`, you can set the oscillator
    type to `''sine''`, `''square''`, or `''triangle''`. Feel free to experiment with
    the frequencies as well:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The frequency of a waveform refers to how often the waveform completes one cycle
    or period, with **1 Hertz** (1 Hz) being 1 cycle per second. We perceive higher
    frequency sound waves as being higher pitched.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we''ll connect the oscillator to the gain node and call the oscillator''s
    `start()` method:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you run this code with the volume up, you should hear a continuous oscillating
    sound (the sound is similar to the static noise you hear on the radio when the
    channel you want cannot be found). Some browsers will not play a sound with the
    Audio API until the user has interacted in some way with the screen. This is to
    stop developers from making annoying pages that play unwanted sounds. If you encounter
    an error, just click somewhere on the screen before running the code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: We can add multiple source nodes, either of the same type (an oscillator, in
    our example) or of different types, and they can each be controlled separately,
    or share other audio nodes such as gain or pan nodes. Of course, we can also make
    our audio contexts respond to some external input, such as user inputs or time
    events.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 8.02: Playing Sound and Controlling Frequency Using Two Oscillators'
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's make better use of the audio API by adding some interactivity. In this
    activity, we will have two oscillators playing a sound, and the user will be able
    to control their frequencies by moving their cursor around on an HTML page. One
    oscillator's frequency will be controlled by the cursor's `x` position, with the
    frequency increasing as the cursor moves toward the right of the page, and the
    other oscillator's frequency is controlled by the `y` position, with the frequency
    increasing as the cursor moves toward the bottom of the page.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Before checking the solution, see if you can achieve this goal; it'll be good
    practice for the activity at the end of this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Some points to get you started:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The two oscillators should be in the same context and be connected to the same
    volume node.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个振荡器应该在同一个上下文中，并且连接到同一个音量节点。
- en: 'There are four preset oscillator types available to the oscillator node interface:
    `''sine''` (default), `''square''`, `''sawtooth''`, and `''triangle''`. Both our
    oscillators can have different types, so play around with them.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 振荡器节点接口提供了四种预设的振荡器类型：`'sine'`（默认）、`'square'`、`'sawtooth'`和`'triangle'`。我们的两个振荡器可以有不同的类型，所以可以尝试不同的组合。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的概要步骤如下：
- en: Initialize an audio context and a volume node.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个音频上下文和一个音量节点。
- en: Create a gain node and connect it to the context's destination.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个增益节点并将其连接到上下文的目的地。
- en: Initialize two oscillators (one for each coordinate of the cursor).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化两个振荡器（一个用于光标的每个坐标）。
- en: Set the oscillator types, connect them to the gain node, and call their `start()`
    methods.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置振荡器类型，将它们连接到增益节点，并调用它们的`start()`方法。
- en: Create an `document`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`document`。
- en: Set the oscillators' frequencies based on the cursor's position.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据光标的位置设置振荡器的频率。
- en: Note
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 733.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以在第733页找到。
- en: Before we move on to the next web API, here's some information on how we can
    extract data from a currently playing sound and use it to visualize that sound
    in our app.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到下一个Web API之前，这里有一些关于如何从当前播放的声音中提取数据并将其用于在我们的应用程序中可视化该声音的信息。
- en: Audio Visualization
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频可视化
- en: 'Audio visualization is a graphical representation of a sound. It''s common
    to see this in an audio program, and it can produce very interesting patterns
    and shapes. Web audio has many kinds of audio nodes. One that opens up a lot of
    possibilities for audio visualization is the analyzer node, which gives you access
    to the waveform and frequency data of its audio input. Unless you''re a sound
    technician, the inner workings of the node are quite arcane, so we''ll just get
    straight into how we access the data. There is one additional property and one
    method we''ll use to get some data that is useful for visualization:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 音频可视化是声音的图形表示。在音频程序中常见这种表示，它可以产生非常有趣的图案和形状。Web音频有许多种类的音频节点。其中一种为音频可视化打开了许多可能性的是分析节点，它允许你访问其音频输入的波形和频率数据。除非你是声音技术人员，否则节点的内部工作原理相当晦涩，所以我们直接进入如何访问数据的方法。我们将使用一个额外的属性和一个方法来获取一些对可视化有用的数据：
- en: '`frequencyBinCount`: This essentially tells us how many data points we have
    available to us for our data visualizations.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`frequencyBinCount`：这实际上告诉我们我们有多少数据点可用于我们的数据可视化。'
- en: '`getFloatTimeDomainData()`: This method takes in a **Float32Array** as a parameter
    and copies the current waveform data to it. (A Float32Array is a special kind
    of array that takes in 32-bit floating-point numbers. The array represents the
    waveform when broken up into however many items there are in the array. Each item
    represents the amplitude of that part of the waveform, from -1 to 1).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getFloatTimeDomainData()`：此方法接受一个**Float32Array**作为参数，并将当前波形数据复制到它。（Float32Array是一种特殊的数组，它接受32位浮点数。当数组被分成数组中的项目数量时，它表示波形。每个项目代表波形那一部分的振幅，从-1到1）。'
- en: 'If we have, for example, an oscillator node, we can create an analyzer node,
    connect it to the oscillator, and use the preceding two properties to get the
    waveform data for the sound that''s playing at that precise moment:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个振荡器节点，我们可以创建一个分析节点，将其连接到振荡器，并使用前面的两个属性来获取在那个精确时刻播放的声音的波形数据：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `getFloatTimeDomainData` function would be called every frame when creating
    an audio visualization. The information in this subsection will be useful for
    the activity at the end of this chapter, so refer back to it then.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建音频可视化时，`getFloatTimeDomainData`函数会在每一帧被调用。本小节中的信息将在本章末尾的活动中有用，所以届时请参考它。
- en: Web Storage API
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web存储API
- en: Storing data in the browser can be a great way of improving the user's experience.
    It can save the user having to wait while the same data is fetched from the server,
    and it can be used to instantly bring a previously visited page back to the state
    it was left in, meaning, for example, that the user doesn't have to refill in
    the same parts of a form. The **Web Storage API** is used to store data in the
    browser in the form of key/value pairs. It can be used to store data that a user
    has entered into a form to allow them to easily come back to it and complete it
    later, or it could be preferences a user has chosen in the web app, data that
    you want to pass from one page to another within the same origin, or any other
    piece of data that you think would be useful to store. The Web Storage API is
    synchronous, so setting and retrieving data will block other JavaScript code until
    the web storage methods have completed. Web storage is intended for storing relatively
    small amounts of data, in which case being synchronous won't have a noticeable
    effect on performance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中存储数据可以是一种提高用户体验的绝佳方式。它可以避免用户等待从服务器获取相同数据，并且可以用来立即将之前访问过的页面恢复到离开时的状态，这意味着，例如，用户不需要重新填写表单中的相同部分。《Web
    Storage API》用于以键/值对的形式在浏览器中存储数据。它可以用来存储用户在表单中输入的数据，以便他们可以轻松返回并稍后完成它，或者它可能是用户在Web应用程序中选择的偏好，您想要在相同源内的页面之间传递的数据，或者您认为有保存价值的其他任何数据。《Web
    Storage API》是同步的，因此设置和检索数据将阻塞其他JavaScript代码，直到Web存储方法完成。Web存储旨在存储相对较小的数据量，在这种情况下，同步不会对性能产生明显影响。
- en: 'You''ve probably heard of cookies as being an example of data storage within
    a browser. Web storage is somewhat similar to cookies, although their respective
    use cases are different: cookies are meant for sending data to the server, whereas
    web storage is designed for storage on the client-side only. Also, web storage
    allows for much more data to be stored – typically, web storage has a limit of
    `10 MB` (although, like with so much in the world of web development, this depends
    entirely on the browser in question), while cookies are limited to `4 KB`. Another
    key difference is that cookies must either have an expiration date set, or they
    will expire at the end of the session, while on the other hand, one kind of web
    storage is only removed via JavaScript, or by clearing the browser''s cache.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过cookie，它是浏览器内数据存储的一个例子。Web存储与cookie有些相似，尽管它们各自的使用场景不同：cookie是用来向服务器发送数据的，而Web存储仅设计用于客户端存储。此外，Web存储允许存储更多的数据——通常，Web存储的极限是`10
    MB`（尽管，就像在Web开发的世界中许多事情一样，这完全取决于浏览器），而cookie的限制是`4 KB`。另一个关键的区别是，cookie必须设置过期日期，否则它们将在会话结束时过期，而另一方面，一种Web存储只能通过JavaScript或清除浏览器缓存来删除。
- en: The Web Storage API is very simple, but before we get into that, let's look
    at the two variants of web storage and cover some other key points about the interface.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Web Storage API非常简单，但在我们深入探讨之前，让我们看看Web存储的两种变体，并介绍一些关于该接口的其他关键点。
- en: 'There are two kinds of web storage available through the API: `sessionStorage`
    and `localStorage`. The main difference between these two is that `sessionStorage`
    will only persist for as long as the current session is active; that is to say
    until the browser window is closed. `localStorage`, on the other hand, has no
    expiration date and will live on the client machine until cleared, either via
    JavaScript or by clearing the browser''s cache. Both `sessionStorage` and `localStorage`
    work on the same origin principle, meaning that data that''s stored by a particular
    domain is only available to that domain.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过API提供的两种Web存储方式是`sessionStorage`和`localStorage`。这两种存储方式的主要区别在于`sessionStorage`仅在当前会话活跃期间持续存在；也就是说，直到浏览器窗口关闭。另一方面，`localStorage`没有过期日期，将在客户端机器上持续存在，直到通过JavaScript或清除浏览器缓存来清除。`sessionStorage`和`localStorage`都遵循相同的源原则，这意味着由特定域名存储的数据只能由该域名访问。
- en: 'The methods that are available to both `sessionStorage` and `localStorage`
    are the same, and the API is very simple to use. There are five methods at our
    disposal, but only three or four are commonly used:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可用于`sessionStorage`和`localStorage`的方法是相同的，API的使用非常简单。我们有五种方法可供使用，但只有三到四种是常用的：
- en: 'The `setItem()` method is how we store a key/value pair in web storage. It
    takes two parameters, both of the string type. The first is the item''s key, while
    the second is its value:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setItem()` 方法是我们将键/值对存储在 Web 存储中的方式。它接受两个参数，都是字符串类型。第一个是项目的键，而第二个是其值：'
- en: '[PRE11]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `getItem()` method allows us to get any item set in the store. It takes
    a single parameter, that is, the key of the item we want to retrieve. If an item
    of the supplied key doesn''t exist in the store, then it will return null:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getItem()` 方法允许我们获取存储中设置的任何项目。它接受一个参数，即我们想要检索的项目的键。如果提供的键在存储中不存在，则它将返回 null：'
- en: '[PRE12]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `removeItem()` method takes one parameter, that is, the key of the item
    you wish to remove:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeItem()` 方法接受一个参数，即您希望删除的项目的键：'
- en: '[PRE13]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `clear()` method clears the whole storage for the current page''s origin
    and takes no parameters:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()` 方法清除当前页面的整个存储，并且不接受任何参数：'
- en: '[PRE14]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `key()` method takes an index as its parameter and returns the key of the
    items at that index, or `null` if no item exists for the index:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`key()` 方法接受一个索引作为其参数，并返回该索引处的项目的键，如果该索引没有项目存在，则返回 `null`：'
- en: '[PRE15]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There are also the `sessionStorage.length` and `localStorage.length` properties,
    which return the number of items stored in the browser storage object.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有 `sessionStorage.length` 和 `localStorage.length` 属性，它们返回浏览器存储对象中存储的项目数量。
- en: 'Web storage objects behave much like JavaScript objects in that we can access
    their properties through dot notation as well as by using the `setItem` and `getItem`
    methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Web 存储对象的行为与 JavaScript 对象非常相似，我们可以通过点符号以及使用 `setItem` 和 `getItem` 方法来访问它们的属性：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An important point to note is that the value of an item must be a primitive
    data type, but that doesn''t mean we can''t store more complicated objects using
    web storage. If we want to store an object in web storage, we can stringify it
    using the JSON object `obj` when we set it, and then parse it when we want to
    retrieve it again:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要注意的重要点是，项目的值必须是基本数据类型，但这并不意味着我们不能使用 Web 存储存储更复杂的对象。如果我们想在 Web 存储中存储一个对象，我们可以在设置时使用
    JSON 对象 `obj` 将其序列化，然后在再次检索时解析它：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can then combine `sessionStorage.getItem()` with `JSON.parse()` to retrieve
    the object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将 `sessionStorage.getItem()` 与 `JSON.parse()` 结合起来检索对象：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Exercise 8.03: Storing and Populating Name Using the localStorage API'
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.03：使用 localStorage API 存储和填充姓名
- en: 'Let''s make a simple web page that takes some user information and stores it
    using the `localStorageAPI` so that it will be displayed when the user visits
    the page next. Browser support for web storage is very strong these days. Still,
    it''s important to account for the possibility that web storage is not supported,
    so make sure to warn the user in case web storage is unsupported in their browser.
    In this exercise, let''s ask the user for their first name and last name. Let''s
    get started:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的网页，它接受一些用户信息，并使用 `localStorageAPI` 存储这些信息，以便用户下次访问页面时可以显示。如今，浏览器对
    Web 存储的支持非常强大。尽管如此，考虑到 Web 存储可能不被支持的可能性，确保在用户的浏览器不支持 Web 存储时提醒用户。在这个练习中，我们将要求用户提供他们的名字和姓氏。让我们开始吧：
- en: 'First of all, let''s create an HTML file with standard boilerplate HTML, and
    add a couple of input boxes for the user''s first and last name, along with a
    warning message in case the browser doesn''t support web storage. We''ll set the
    `<p>` tags'' display style to none by default:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个带有标准样板 HTML 的 HTML 文件，并为用户的名字和姓氏添加几个输入框，如果浏览器不支持 Web 存储，则添加一个警告消息。我们将默认设置
    `<p>` 标签的显示样式为 none：
- en: '[PRE19]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you open this HTML file in the browser, it will look like this:'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在浏览器中打开这个 HTML 文件，它看起来会是这样：
- en: '![Figure 8.6\. The HTML page with two input boxes'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.6\. 带有两个输入框的 HTML 页面'
- en: '](img/C14377_08_06.jpg)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_08_06.jpg)'
- en: Figure 8.6\. The HTML page with two input boxes
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.6\. 带有两个输入框的 HTML 页面
- en: 'Next, we''ll create a JavaScript file, starting off with a check to see whether
    the `localStorage` method is available on the window object. If it''s not available,
    we simply return and set the warning message to display block, thus alerting the
    user that there will be reduced functionality on the page:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 JavaScript 文件，首先检查 `localStorage` 方法是否在窗口对象上可用。如果不可用，我们简单地返回并将警告消息的显示样式设置为
    block，从而提醒用户页面将会有减少的功能：
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the browser does support localStorage, we''ll proceed to assigning any values
    for the `firstName` and `lastName` keys that are currently held in `localStorage`
    to variables of the same name:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果浏览器支持`localStorage`，我们将继续将当前保存在`localStorage`中的`firstName`和`lastName`键的任何值分配给同名变量：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we''ll grab the two input elements, and if `firstName` or `lastName`
    have a value, then that value is set as the respective text input''s value, thereby
    populating any string saved in `localStorage` back into the relevant text input:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将获取两个输入元素，如果`firstName`或`lastName`有值，那么这个值将被设置为相应的文本输入的值，从而将保存在`localStorage`中的任何字符串重新填充到相关的文本输入中：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The final thing we need to do is add an event listener to the two text inputs
    and store their current values in `localStorage` each time the input event is
    fired:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是为两个文本输入添加事件监听器，并在每次输入事件触发时将它们的当前值存储在`localStorage`中：
- en: '[PRE23]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The error output will be displayed as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 错误输出将如下所示：
- en: '![Figure 8.7: Output error'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7：输出错误'
- en: '](img/C14377_08_07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_08_07.jpg)'
- en: 'Figure 8.7: Output error'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：输出错误
- en: 'The output is displayed as follows, with the two names stored:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示，显示了存储的两个名称：
- en: '![Figure 8.8: The HTML page with two input variables stored and populated'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8：存储并填充了两个输入变量的HTML页面'
- en: '](img/C14377_08_08.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_08_08.jpg)'
- en: 'Figure 8.8: The HTML page with two input variables stored and populated'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：存储并填充了两个输入变量的HTML页面
- en: This completes our simple application. Assuming `localStorage` is supported,
    any string that's entered into either of the text inputs will be saved and repopulated,
    even after the page is refreshed or the browser or tab is closed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们的简单应用程序。假设`localStorage`被支持，任何输入到文本输入中的字符串都将被保存并重新填充，即使页面刷新或浏览器或标签关闭后也是如此。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Here, our method of feature detection is not robust, and it will not detect,
    for example, when the feature has been disabled in the browser. A better approach
    for production code is to attempt to set and get an item in `localStorage`. If
    the get value is as expected, then we know that local storage is working.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的特性检测方法不够稳健，它不会检测，例如，当特性在浏览器中被禁用时。对于生产代码来说，更好的方法是在`localStorage`中尝试设置和获取一个项。如果获取的值符合预期，那么我们知道本地存储正在工作。
- en: While the web storage API is extremely useful for storing relatively small amounts
    of data, it's not well suited for storing larger files or data structures. Firstly,
    we can only store string values in web storage, and more importantly, since the
    API is synchronous, an application would take a performance hit if it were storing
    and retrieving large amounts of data.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Web存储API对于存储相对较小的数据量非常有用，但它并不适合存储较大的文件或数据结构。首先，我们只能在Web存储中存储字符串值，更重要的是，由于API是同步的，如果应用程序存储和检索大量数据，将会影响性能。
- en: 'In cases where we want the client to store large datasets, files, or blobs,
    we can make use of anther browser API: the `IndexedDB` API.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们想要客户端存储大量数据集、文件或blob的情况下，我们可以利用另一个浏览器API：`IndexedDB` API。
- en: IndexedDB
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IndexedDB
- en: '**IndexedDB** is another form of client-side data storage that differs from
    web storage in some important ways:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**IndexedDB**是另一种客户端数据存储形式，它在某些重要方面与Web存储不同：'
- en: Unlike web storage, it is well suited to storing large amounts of data, and
    for storing many different data types.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Web存储不同，它非常适合存储大量数据，并且可以存储许多不同的数据类型。
- en: The API has much greater functionality than the web storage API, allowing us
    to do things such as perform queries against indexed data.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该API比Web存储API具有更强大的功能，允许我们执行对索引数据的查询等操作。
- en: It's an asynchronous API, so working with data stored in indexedDB won't block
    the execution of other code.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个异步API，因此使用存储在indexedDB中的数据不会阻塞其他代码的执行。
- en: 'These last two points hint at the biggest drawback with using indexedDB over
    web storage: its API and workflow are more complex than the simple get and set
    methods we use for web storage. IndexedDB is often criticized for having an overly
    complex API, but it''s necessary to ensure data integrity (more on that soon),
    and anyway, if we take the time to understand some core concepts, then we''ll
    see that it''s actually not that complex after all.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两点暗示了使用indexedDB而不是Web存储的最大缺点：它的API和工作流程比Web存储的简单获取和设置方法更复杂。IndexedDB经常被批评API过于复杂，但这是确保数据完整性的必要条件（关于这一点稍后讨论），而且无论如何，如果我们花时间理解一些核心概念，那么我们会发现它实际上并不那么复杂。
- en: Like web storage, indexedDB follows the same origin rule, meaning that only
    pages at the same domain, protocol, and port can access a particular instance
    of indexedDB. Before we start working with indexedDB, let's examine some of its
    components and core concepts.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 与 web 存储一样，indexedDB 遵循相同的源规则，这意味着只有位于同一域名、协议和端口的页面才能访问 indexedDB 的特定实例。在我们开始使用
    indexedDB 之前，让我们检查一些其组件和核心概念。
- en: An indexedDB database comprises one or more **object stores**. An object store,
    as its name suggests, is a container for the objects we are storing in the database.
    Like web storage, objects in indexedDB are stored as key/value pairs, but unlike
    web storage, the value doesn't need to be of the string type. The value could
    be any JavaScript data type, or even blobs or files.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 indexedDB 数据库包含一个或多个 **对象存储**。正如其名称所暗示的，对象存储是我们存储在数据库中的对象的容器。与 web 存储一样，indexedDB
    中的对象以键/值对的形式存储，但与 web 存储 不同，值不需要是字符串类型。值可以是任何 JavaScript 数据类型，甚至是 blob 或文件。
- en: These objects are typically all of the same type, but they do not need to have
    the exact same structure as each other, as you may expect with traditional databases.
    For example, let's say we're storing data on employees. Two objects in the object
    store may have the salary property, but one's value could be 30,000 and the other
    could be thirty thousand.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象通常是同一类型，但它们不需要具有完全相同的结构，正如您可能期望的传统数据库那样。例如，假设我们正在存储员工数据。对象存储中的两个对象可能都有薪资属性，但一个的值可能是
    30,000，而另一个可能是三十万。
- en: 'Object stores can be linked to indexes (which are actually just a different
    kind of object store). These indexes are used to efficiently query the data we
    store in the database. The indexes are maintained automatically. We''ll look at
    how we can use them in more detail shortly:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储可以链接到索引（这些索引实际上是不同类型的对象存储）。这些索引用于高效查询我们存储在数据库中的数据。索引是自动维护的。我们将在稍后更详细地了解如何使用它们：
- en: '![Figure 8.9: Layout of indexedDB'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.9：indexedDB 的布局'
- en: '](img/C14377_08_09.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_08_09.jpg](img/C14377_08_09.jpg)'
- en: 'Figure 8.9: Layout of indexedDB'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9：indexedDB 的布局
- en: With indexedDB, all of our **Create, Read, Update, and Delete** (**CRUD**) operations
    are performed inside of a **transaction**, which we'll look at in detail soon.
    Working inside of a transaction can seem like a convoluted way of doing things,
    but it's an effective way of preventing write operations happening on the same
    record at the same time. Consider two pages open on the same page, both of which
    are trying to update the same record. When a transaction is open on one page,
    the other is unable to perform operations on the same record.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 indexedDB 中，我们所有的 **创建、读取、更新和删除** （**CRUD**）操作都是在 **事务** 中执行的，我们将在稍后详细讨论。在事务内部工作可能看起来是一种复杂的方式，但它是一种有效的方法，可以防止同时在对同一记录进行写操作。考虑在同一页面上打开的两个页面，它们都在尝试更新同一记录。当一个页面打开事务时，另一个页面无法对同一记录执行操作。
- en: 'The process of working with indexedDB can be broken down into four steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 与 indexedDB 一起工作的过程可以分为四个步骤：
- en: Open the database.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开数据库。
- en: Create an object store if the required store doesn't exist yet.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果所需的存储尚不存在，则创建对象存储。
- en: 'Process the transaction: create, read, update, or delete a record or records.'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理事务：创建、读取、更新或删除记录或记录。
- en: Close the transaction.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭事务。
- en: 'Exercise 8.04: Creating an Object Store and Adding Data'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.04：创建对象存储并添加数据
- en: 'Let''s create a database that will hold records of animals. We''ll go through
    the preceding steps in more detail to create a database, create an object store,
    start a transaction, and add some data to the database. Add the code that follows
    into the console of the Google Chrome developer tools:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个将保存动物记录的数据库。我们将更详细地执行前面的步骤来创建数据库、创建对象存储、开始事务并向数据库添加一些数据。将以下代码添加到 Google
    Chrome 开发者工具的控制台：
- en: 'We''ll initialize a variable called request with the `indexedDB.open()` method
    and pass the database name `animals` and the database version number `1` as parameters.
    It returns a request object, which in turn will receive one of three events: `success`,
    `error`, or `upgradeneeded`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `indexedDB.open()` 方法初始化一个名为 `request` 的变量，并将数据库名称 `animals` 和数据库版本号 `1`
    作为参数传递。它返回一个请求对象，该对象将接收三个事件之一：`success`、`error` 或 `upgradeneeded`：
- en: '[PRE24]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When we call open for the first time, the `upgradeneeded` event is triggered,
    and we can attach an `onupgradeneeded` event handler function, in which we will
    define our object store.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们第一次调用 open 时，将触发 `upgradeneeded` 事件，我们可以附加一个 `onupgradeneeded` 事件处理函数，在其中我们将定义我们的对象存储。
- en: 'Then, we''ll define a function to handle the `onupgradeneeded` event, assign
    the database at `event.target.results` in a `db` variable, and create a `''mammals''`
    object store:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个函数来处理`onupgradeneeded`事件，将`event.target.results`中的数据库分配给`db`变量，并创建一个`'mammals'`对象存储：
- en: '[PRE25]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Notice that we pass a second parameter, `1`, to the open method. This is the
    database's version number, which we can change to allow changes to object stores,
    or to add new object stores. We'll see how this works later.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们在`open`方法中传递了第二个参数`1`。这是数据库的版本号，我们可以更改它以允许对对象存储进行更改，或者添加新的对象存储。我们稍后会看到它是如何工作的。
- en: The database itself is accessible at the request object's result property. We
    can access it either through the event object at event.target, or through the
    request object (the event target is the request object).
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据库本身可通过请求对象的`result`属性访问。我们可以通过事件对象的`event.target`或通过请求对象（事件目标是请求对象）来访问它。
- en: We then use the `createObjectStore()` method of the database to create a new
    store. We pass this method a name, which can be any string, but which should typically
    describe what kind of data is being stored. We also pass in an object, with a
    key of keypath and a value of the key we want to use to address the objects we
    store, and for accessing the objects stored.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们使用数据库的`createObjectStore()`方法创建一个新的存储。我们向此方法传递一个名称，这个名称可以是任何字符串，但通常应该描述正在存储的数据类型。我们还传递一个对象，其中包含键`keypath`和值为我们想要用于访问存储的对象的键，以及访问存储的对象。
- en: 'Now that we''ve created our database, we can go ahead and insert some objects.
    This time, when we call the open method of the indexedDB object -- assuming there
    are no errors -- the success event will be triggered, and we access the database
    and proceed with the transaction. Let''s run through what we are doing with the
    `onsuccess` handler. Assign the database to a `db` variable again and handle the
    errors that may occur (for now, we''ll just log them to the console):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了数据库，我们可以继续插入一些对象。这次，当我们调用`indexedDB`对象的`open`方法时——假设没有错误——成功事件将被触发，我们访问数据库并继续事务。让我们回顾一下我们在`onsuccess`处理程序中做了什么。再次将数据库分配给`db`变量，并处理可能发生的错误（现在，我们只是将它们记录到控制台）：
- en: '[PRE26]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a transaction with the `storeName` property of `''mammals''` and the
    type of `''readwrite''`. This limits the transaction to only be able to perform
    read/write operations to the `''mammals''` object store:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`storeName`属性为`'mammals'`和类型为`'readwrite'`创建一个事务。这限制了事务只能对`'mammals'`对象存储执行读写操作：
- en: '[PRE27]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we assign the object store to the store variable and add two records
    to the store:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将对象存储分配给`store`变量，并向存储中添加两个记录：
- en: '[PRE28]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we define the action that should happen when the transaction receives
    the `''complete''` event, which is to close the database, thereby completing our
    transaction:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义当事务接收到`'complete'`事件时应执行的操作，即关闭数据库，从而完成我们的事务：
- en: '[PRE29]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After running this code, and assuming there were no errors, you can open Chrome''s
    developer tools, navigate to the `Application` tab, and expand the IndexedDB storage
    item on the left-hand side. In here, you''ll see your newly created `animals`
    database, containing its mammals object store, and the two entries we added previously:![Figure
    8.10: Viewing IndexedDB in DevTools'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行此代码后，假设没有错误，你可以打开Chrome的开发者工具，导航到`应用程序`标签页，并展开左侧的IndexedDB存储项。在这里，你会看到你刚刚创建的`animals`数据库，其中包含其哺乳动物对象存储，以及我们之前添加的两个条目：![图8.10：在开发者工具中查看IndexedDB
- en: '](img/C14377_08_10.jpg)'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_08_10.jpg)'
- en: 'Figure 8.10: Viewing IndexedDB in DevTools'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.10：在开发者工具中查看IndexedDB
- en: 'Now that you''ve saved some data in the database, let''s learn how to retrieve
    it again. The process of retrieving data follows a similar pattern to storing
    it in the first place. When we created the object store, we set the `keyPath`
    to species as we know this will be a unique property. We can use this property
    to access a particular entry in the object store:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经在数据库中保存了一些数据，让我们学习如何再次检索它。检索数据的过程与最初存储它的过程类似。当我们创建对象存储时，我们将`keyPath`设置为物种，因为我们知道这将是一个唯一的属性。我们可以使用这个属性来访问对象存储中的特定条目：
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Like we did previously, we must initiate a request to open the database and
    attach an `onsuccess` handler to that request. When the success event is emitted,
    we can access the database through either request.result or through the event
    object, that is, event.target.result. We can now create a transaction by calling
    the database's `transaction()` method and specify the object store and transaction
    type we want with mammals and readwrite.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们之前做的那样，我们必须发起一个请求来打开数据库，并将一个`onsuccess`处理程序附加到该请求上。当成功事件被触发时，我们可以通过请求的结果或通过事件对象来访问数据库，即`event.target.result`。我们现在可以通过调用数据库的`transaction()`方法来创建一个事务，并指定我们想要的存储对象和事务类型，即哺乳动物和读写。
- en: Next, we access the store by calling the `objectStore()` method of the transaction.
    We can now call the `get()` method and pass in the keyPath value of the entry
    we want to access. This `get()` method returns another request object, which also
    receives events for successes and errors. We attach one final success handler
    to the `onsuccess` property, which will access the `event.target.result` property.
    This contains the entry we are looking for.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过调用事务的`objectStore()`方法来访问存储。我们现在可以调用`get()`方法，并传入我们想要访问的条目的`keyPath`值。这个`get()`方法返回另一个请求对象，它也会接收到成功和错误的事件。我们将一个最终的成功处理程序附加到`onsuccess`属性，它将访问`event.target.result`属性。这包含我们要找的条目。
- en: When we first created the database, and every time we subsequently made a request
    to open it, we passed a database version number as the second parameter to the
    `indexedDB.open()` method. As long as we keep the version number the same, the
    database will open with consistent object stores, but we will not be allowed to
    make any changes to the structure of the stores, nor will we be able to add new
    object stores to the database. If we want to modify an object store or add a new
    one, we need to upgrade our database. We do this by simply creating an open request
    and passing a new version number to the second parameter.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们第一次创建数据库时，以及每次我们随后的请求打开它时，我们都将数据库版本号作为`indexedDB.open()`方法的第二个参数传递。只要我们保持版本号不变，数据库将以一致的对象存储打开，但我们不允许对存储的结构进行任何更改，也无法将新对象存储添加到数据库中。如果我们想修改对象存储或添加新的，我们需要升级我们的数据库。我们通过简单地创建一个打开请求并将新版本号传递给第二个参数来完成此操作。
- en: This will trigger the request's onupgradeneeded event and allow us to create
    a version change transaction, which is the only type of transaction in which we
    can modify or add an object store. Version numbers must be integers, and any new
    version must be of a higher value than the database's current version number.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将触发请求的`onupgradeneeded`事件，并允许我们创建一个版本更改事务，这是唯一可以修改或添加对象存储的事务类型。版本号必须是整数，并且任何新版本都必须比数据库的当前版本号高。
- en: 'Let''s say we want to add another object store, this time for animals in the
    `upgradeneeded` event is the same as when we first created the database. When
    a new object store is added, the success event will be triggered on the request
    object. This means we can add entries to our new object store immediately after
    creating it:'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设我们想要添加另一个对象存储，这次是为了`upgradeneeded`事件中的动物。当我们第一次创建数据库时，这个过程是相同的。当添加一个新的对象存储时，请求对象上的成功事件将被触发。这意味着我们可以在创建它之后立即向我们的新对象存储添加条目：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Looking again at the Application tab of Chrome''s developer tools, we will
    see our newly created cephalopod store and its two new entries:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看Chrome开发者工具的应用程序标签页，我们将看到我们新创建的头足类存储及其两个新条目：
- en: '![Figure 8.11: New object store and entries in indexedDB'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11：新的对象存储和indexedDB中的条目'
- en: '](img/C14377_08_11.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_08_11.jpg)'
- en: 'Figure 8.11: New object store and entries in indexedDB'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：新的对象存储和indexedDB中的条目
- en: In this exercise, we created a database that holds records of animals. You can
    further try to add different object stores and add data to it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建了一个包含动物记录的数据库。你可以进一步尝试添加不同的对象存储并向其中添加数据。
- en: Querying IndexedDB
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询IndexedDB
- en: As well as accessing data by its key (species, in our examples so far), we can
    run simple queries against an object store to return multiple entries that match
    our query term. The data in indexedDB needs to be indexed by any key that we want
    to use for queries; unlike other databases, there is no in-built search functionality
    with indexedDB. If we decided we wanted to use a different key than the keyPath
    we set when we created our objectStore, we would need to create a new index.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过其键（在我们的例子中是物种）访问数据外，我们还可以对对象存储运行简单查询，以返回与我们的查询词匹配的多个条目。在 indexedDB 中的数据需要通过我们想要用于查询的任何键进行索引；与其他数据库不同，indexedDB
    没有内置的搜索功能。如果我们决定想要使用与我们创建对象存储时设置的键路径不同的键，我们需要创建一个新的索引。
- en: 'Exercise 8.05: Querying the Database'
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.05：查询数据库
- en: 'In this exercise, we will see how we can use a different key to the `keyPath`
    that we used when we created our `objectStore`. To do so, we will use the `createIndex`
    method, which takes in two parameters and an `options` object as the third parameter.
    The first is the name we want to associate the new index with, while the second
    is the data key we want to link to the index. Doing this requires updating the
    database version once again when we create the database open request. Let''s work
    through the exercise to see how we can achieve this. Like we did previously, follow
    along in a code snippet in Google Chrome''s developer tools:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何使用与我们在创建 `objectStore` 时使用的 `keyPath` 不同的键。为此，我们将使用 `createIndex`
    方法，该方法接受两个参数和一个作为第三个参数的 `options` 对象。第一个是我们想要与新的索引关联的名称，而第二个是我们想要链接到索引的数据键。这样做需要在创建数据库打开请求时再次更新数据库版本。让我们通过练习来看看我们如何实现这一点。就像我们之前做的那样，在
    Google Chrome 的开发者工具中的代码片段中跟随：
- en: 'Make a new request to open the animals database and assign a function to the
    `onupgradeneeded` event:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向打开动物数据库发出新的请求，并将一个函数分配给 `onupgradeneeded` 事件：
- en: '[PRE32]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Access the mammals store through `event.target.transaction.objectStore` and
    call the `createIndex()` method on it:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 `event.target.transaction.objectStore` 访问哺乳动物存储，并在其上调用 `createIndex()` 方法：
- en: '[PRE33]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we mentioned previously, the `createIndex` method takes in two parameters.
    In our example, we use traits for both of these parameters. The third parameter
    is an `options` object. Here, you can set the unique property to true so that
    the database does not allow duplicates of this key to be stored, or to `false`
    to allow multiple records with the same value for this key. You can also set a
    `multiEntry` parameter. If it's set to `true`, then the database will add an entry
    for every item in an array; if it's set to `false`, then the entire array will
    be indexed as one entry. Setting this to true will allow us to query entries by
    a single trait, as we'll see now.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`createIndex` 方法接受两个参数。在我们的例子中，我们使用特征作为这两个参数。第三个参数是一个 `options` 对象。在这里，你可以将唯一属性设置为
    `true` 以确保数据库不允许存储此键的重复项，或者设置为 `false` 以允许具有此键相同值的多个记录。你还可以设置一个 `multiEntry` 参数。如果设置为
    `true`，则数据库将为数组中的每个项目添加一个条目；如果设置为 `false`，则整个数组将作为一个条目进行索引。将此设置为 `true` 将允许我们通过单个特征查询条目，正如我们现在将看到的。
- en: 'Next, we instantiate a database open request object for version 3 of our database
    and create another `onsuccess` event handler function:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为数据库的第三个版本创建一个数据库打开请求对象并创建另一个 `onsuccess` 事件处理函数：
- en: '[PRE34]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We then get hold of the resulting database, create a transaction, access the
    store, and call the store''s `index()` method with the name of the index we wish
    to query against:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们获取结果数据库，创建一个事务，访问存储，并使用我们想要查询的索引名称调用存储的 `index()` 方法：
- en: '[PRE35]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we call `index.getAll()` with the value of `Furry` and assign the returned
    value to the `animalReq` variable. As usual, this object receives a success event,
    through which we can access an array of all the records matching our query:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们调用 `index.getAll()` 并将 `Furry` 的值作为参数，将返回的值分配给 `animalReq` 变量。像往常一样，此对象通过成功事件接收，我们可以通过该事件访问与我们的查询匹配的所有记录的数组：
- en: '[PRE36]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lastly, we create an error event handler to deal with any errors that may arise:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个错误事件处理函数来处理可能出现的任何错误：
- en: '[PRE37]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we run this code, we should get all the database entries that match our
    query:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们应该得到所有与我们的查询匹配的数据库条目：
- en: '![Figure 8.12: The result from accessing all the Furry mammals in the database'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12：访问数据库中所有毛茸茸哺乳动物的结果'
- en: '](img/C14377_08_12.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_08_12.jpg]'
- en: 'Figure 8.12: The result from accessing all the Furry mammals in the database'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12：访问数据库中所有毛茸茸哺乳动物的结果
- en: In this exercise, we learned to use a different key to the `keyPath` and the
    `createIndex` method, which took two parameters and an `options` object as the
    third parameter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学会了使用与 `keyPath` 和 `createIndex` 方法不同的键，该方法接受两个参数和一个作为第三个参数的 `options`
    对象。
- en: IndexedDB Cursor
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IndexedDB 光标
- en: 'As we mentioned previously, indexedDB does not have native record search functionality
    for unindexed record keys. If we want this functionality in our database, we''re
    on our own. IndexedDB does, however, provide us with a cursor, which is an object
    representing a location in an object store, and which we can use to iterate through
    objects in the database. Like other parts of the indexedDB API, the cursor object
    is event-based, so we must wait for a success event to be fired before proceeding
    with our operations:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，indexedDB 没有对未索引记录键的本地记录搜索功能。如果我们想在我们的数据库中实现这个功能，我们就得自己动手。然而，indexedDB
    确实为我们提供了一个光标，它是一个表示对象存储中位置的对象，我们可以使用它来遍历数据库中的对象。与其他 indexedDB API 的部分一样，光标对象是基于事件的，因此我们必须等待成功事件触发后才能继续我们的操作：
- en: '[PRE38]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Once again, we''ll walk through the processes of gaining access to the database,
    opening a transaction, and accessing the store we''re interested in. We can now
    use the `openCursor()` method of the object store to create our cursor. This method
    can take two optional parameters: a range of keys within which the cursor can
    iterate, and a direction that tells the cursor which direction to move in through
    the records when its `continue()` method or `advance()` method is called. The
    possible values for the direction parameter are `next`, `nextunique`, `prev`,
    and `prevunique`, with the default of next.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们将回顾获取数据库访问权限、打开事务和访问我们感兴趣的存储的过程。现在，我们可以使用对象存储的 `openCursor()` 方法来创建我们的光标。此方法可以接受两个可选参数：光标可以遍历的键的范围，以及当调用其
    `continue()` 方法或 `advance()` 方法时告诉光标在记录中移动方向的参数。方向参数的可能值是 `next`、`nextunique`、`prev`
    和 `prevunique`，默认为 `next`。
- en: In our case, we haven't provided any parameters to the `openCursor()` method,
    so it will iterate through all the keys and will move forward over each individual
    record.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们没有向 `openCursor()` 方法提供任何参数，所以它将遍历所有键，并逐个记录地向前移动。
- en: We then define an `cursor.delete()` method. In our example, we are simply logging
    the record to the console and then calling the `continue()` method. Calling `continue()`
    moves the cursor on to the next record, which then triggers the `cursorReq` object's
    success event, starting this part of the process again. If the cursor has reached
    the end of the records, the cursor object will be `null`, and we can terminate
    the process.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个 `cursor.delete()` 方法。在我们的例子中，我们只是将记录记录到控制台，然后调用 `continue()` 方法。调用
    `continue()` 会将光标移动到下一个记录，然后触发 `cursorReq` 对象的成功事件，再次启动这个过程。如果光标已经到达记录的末尾，光标对象将是
    `null`，我们可以终止这个过程。
- en: There's been a lot to cover in indexedDB – this is unsurprising, really, given
    that it's a comprehensive client-side database that comes with a lot more functionality,
    and therefore complexity, than the Web Storage API we looked at previously.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 indexedDB 中有很多内容需要介绍——这实际上并不令人惊讶，因为它是比我们之前查看的 Web Storage API 更全面、功能更多、复杂性也更高的客户端数据库。
- en: 'Before we move on to an exercise to solidify our understanding of indexedDB,
    here is a quick recap of what we''ve covered:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行练习以巩固对 indexedDB 的理解之前，这里是对我们所学内容的快速回顾：
- en: IndexedDB is suitable for storing large amounts of data.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IndexedDB 适合存储大量数据。
- en: It can store many more data types than web storage (any JavaScript data type,
    files, or blobs).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以存储比 Web Storage（任何 JavaScript 数据类型、文件或 blob）更多的数据类型。
- en: It's event-based – pretty much all operations are requested from the database
    and receive various events.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是基于事件的——几乎所有的操作都是从数据库请求的，并接收各种事件。
- en: It's asynchronous.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是异步的。
- en: It comprises the database, one or more object stores, data objects, and indexes
    (a kind of object store).
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括数据库、一个或多个对象存储、数据对象和索引（一种对象存储）。
- en: All operations happen inside of a transaction, which ensures that all the operations
    complete successfully or that the object store is reverted back to its pre-transaction
    state.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有操作都在事务内部发生，这确保了所有操作都成功完成，或者对象存储被回滚到事务前的状态。
- en: We can query records against specified indexes.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以针对指定的索引查询记录。
- en: We can use a cursor to iterate through records in an object store and use this
    to create our own search features, as required for our application.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用游标遍历对象存储中的记录，并使用它来创建我们自己的搜索功能，这符合我们应用程序的需求。
- en: 'Exercise 8.06: Fetching, Storing, and Querying Data'
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.06：获取、存储和查询数据
- en: In this exercise, we'll be fetching some data from a remote API, storing it
    in an indexedDB database, and then writing our own function to query the database
    for a particular subset of data. We'll do this by adding 200 `todo` items to the
    database and retrieving the tasks that are not complete.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将从远程 API 获取一些数据，将其存储在 indexedDB 数据库中，然后编写我们自己的函数来查询数据库以获取特定子集的数据。我们将通过向数据库添加
    200 个 `todo` 项目并检索未完成的任务来实现这一点。
- en: The API we'll be calling can be found at [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com).
    If we make a get request to its `todos` route, we will get a list of `todo` items
    in response.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要调用的 API 可以在 [https://jsonplaceholder.typicode.com](https://jsonplaceholder.typicode.com)
    找到。如果我们向它的 `todos` 路径发起 GET 请求，我们将得到一个 `todo` 项目的列表作为响应。
- en: 'We will then create an indexedDB database and an object store and store all
    this data in the store. In this example, we will use the fetch API, which is another
    Browser API that''s used for making HTTP requests in JavaScript. Let''s get started:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个 indexedDB 数据库和一个对象存储，并将所有这些数据存储在存储中。在这个例子中，我们将使用 fetch API，这是另一个用于在
    JavaScript 中发起 HTTP 请求的浏览器 API。让我们开始吧：
- en: 'In a new snippet in Google Chrome''s developer tools, we''ll get the data from
    the API:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Google Chrome 开发者工具的新片段中，我们将从 API 获取数据：
- en: '[PRE39]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we're using the `XMLHttpRequest()` constructor to make a new HTTP get
    request to our API endpoint.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `XMLHttpRequest()` 构造函数向我们的 API 端点发起一个新的 HTTP GET 请求。
- en: 'Then, we''re setting a function to the load event listener of the HTTP request
    object. This event handler is where we receive our `todos` data from the API and
    is where we will write the rest of our code. If we were to console log the `todos`
    variable, we would see an array of objects in the following format:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将一个函数设置到 HTTP 请求对象的 load 事件监听器上。这个事件处理器是我们从 API 接收 `todos` 数据的地方，也是我们将编写其余代码的地方。如果我们要在控制台输出
    `todos` 变量，我们会看到以下格式的对象数组：
- en: '[PRE40]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once we have our data in the `todos` variable, we''ll create a new database
    called tasks and a new object store called `todos` and set the object store''s
    `keyPath` to the id property of our `todo` items (again, everything is happening
    inside the http object''s onload handler):'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们将数据放入 `todos` 变量中，我们将创建一个名为 tasks 的新数据库和一个名为 `todos` 的新对象存储，并将对象存储的 `keyPath`
    设置为 `todo` 项目的 id 属性（再次强调，所有这些都在 http 对象的 onload 处理器内部发生）：
- en: '[PRE41]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now go ahead and add our `todo` items to the database. Like we did previously,
    we''ll add some lines of code to our http.onload event handler. This time, we''ll
    add an `onsuccess` function to our `dbRequest` object, in which we''ll get the
    database from the success event object and start a `readwrite` transaction targeting
    the `todos` store. We''ll access the store from the transaction use a `forEach`
    loop to loop through the items in the `todos` array, and push each one into the
    database:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以继续将 `todo` 项目添加到数据库中。就像我们之前做的那样，我们将在 http.onload 事件处理器中添加一些代码。这次，我们将在
    `dbRequest` 对象中添加一个 `onsuccess` 函数，在这个函数中，我们将从成功事件对象中获取数据库，并开始一个针对 `todos` 存储的
    `readwrite` 事务。我们将使用 `forEach` 循环从事务中访问存储，并遍历 `todos` 数组中的每个项目，将其推入数据库：
- en: '[PRE42]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Select the `Application` tab of the developer tools and expand the IndexedDB
    list on the left-hand side. Here, you should find our tasks database containing
    the `todos` object store, which should now have our 200 `todo` items:![Figure
    8.13: Showing indexedDB after the data has been added'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择开发者工具的 `Application` 选项卡，并在左侧展开 IndexedDB 列表。在这里，你应该找到包含 `todos` 对象存储的任务数据库，它现在应该包含
    200 个 `todo` 项目：![图 8.13：添加数据后的 indexedDB
- en: '](img/C14377_08_13.jpg)'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_08_13.jpg)'
- en: 'Figure 8.13: Showing indexedDB after the data has been added'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.13：添加数据后的 indexedDB
- en: 'With our data safely in the database, we''ll write a query function to get
    all of our `todo` items that have completed set to false. First, we''ll instantiate
    an empty array to hold our uncompleted `todos`. Then, we''ll use the indexedDB
    cursor interface to iterate through the records. For each record, we''ll check
    to see whether the completed property is `false`. If it is, we''ll push the record
    into the array. Since we already have our data in the database, it''s best to
    comment out the last block of code, otherwise, we''ll make the HTTP request again
    and save duplicates of all the `todos`:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的数据安全地存储在数据库中后，我们将编写一个查询函数来获取所有未完成的`todo`项。首先，我们将实例化一个空数组来存储我们的未完成`todos`。然后，我们将使用indexedDB游标接口遍历记录。对于每条记录，我们将检查完成属性是否为`false`。如果是，我们将该记录推入数组。由于我们已经在数据库中有了我们的数据，最好注释掉最后一块代码，否则，我们将再次进行HTTP请求并保存所有`todos`的副本：
- en: '[PRE43]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This results in the following output:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '![Figure 8.14: The console output from our query function'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.14: The console output from our query function](img/C14377_08_14.jpg)'
- en: '](img/C14377_08_14.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_08_14.jpg](img/C14377_08_14.jpg)'
- en: 'Figure 8.14: The console output from our query function'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：我们的查询函数的控制台输出
- en: We can see that the completed property is `false` from the preceding figure
    and uncompleted are `true`. In this exercise, we learned to fetch some data from
    a remote API, storing it in an `indexedDB` database, and then writing our own
    function to query the database for a particular subset of data.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从前面的图中看到，完成属性是`false`，未完成的是`true`。在这个练习中，我们学习了如何从远程API获取一些数据，将其存储在`indexedDB`数据库中，然后编写我们自己的函数来查询数据库以获取特定子集的数据。
- en: 'This section has covered one of the more complicated web APIs. Here''s a quick
    recap of the IndexedDB API''s core principles:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了一个更复杂的Web API。以下是IndexedDB API的核心原则的快速回顾：
- en: IndexedDB databases comprise the database, which contains one or more object
    stores, which contain the actual data objects
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IndexedDB数据库包含数据库，其中包含一个或多个对象存储，这些对象存储包含实际的数据对象
- en: (Almost) everything happens with events, so you use event handlers a lot.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （几乎）所有事情都是通过事件发生的，所以你经常使用事件处理器。
- en: Transactions are where the business happens. Transactions apply to only one
    object store and can be read-only, read-write, or version-change.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事务是业务发生的地方。事务仅适用于一个对象存储，可以是只读、读写或版本更改。
- en: You can fetch items by their key name if they have been indexed by that key,
    or you can use a cursor to iterate through a set of records.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果项目已经被该键索引，你可以通过其键名获取项目，或者你可以使用游标遍历一组记录。
- en: Now, we'll look at a browser API we can use to give us information on how performant
    a site or application is. This API is surprisingly called the Performance API.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将查看一个浏览器API，我们可以使用它来获取有关网站或应用程序性能的信息。这个API出人意料地被称为性能API。
- en: Performance API
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能API
- en: When we're building sites and web apps, it's important to be able to measure
    the performance of our applications to help ensure good user experiences. We do
    this during development, testing stages, and in production. As our application
    grows and we add new features, it's equally important to make sure that the changes
    we're making aren't negatively affecting performance. There are a number of ways
    to measure this and some useful tools to help us. One such set of tools is the
    browser's **Performance API** and other closely related APIs.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建网站和Web应用程序时，能够衡量我们应用程序的性能对于确保良好的用户体验非常重要。我们在开发、测试阶段和在生产环境中这样做。随着我们的应用程序增长并添加新功能，确保我们正在进行的更改不会对性能产生负面影响同样重要。有几种方法可以衡量这一点，还有一些有用的工具可以帮助我们。其中一套工具是浏览器的**性能API**和其他密切相关API。
- en: 'The Performance API allows us to time events with extreme accuracy: the time
    measurements we have access to are expressed in milliseconds but are accurate
    to about 5 microseconds. With these APIs, we can accurately measure the time it
    takes to complete specific actions, such as the following:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 性能API允许我们以极高的精度计时事件：我们可以访问的时间测量以毫秒为单位表示，但准确到大约5微秒。使用这些API，我们可以准确测量完成特定动作所需的时间，例如以下动作：
- en: The time it took to render the first pixel on our page
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染我们页面第一个像素所需的时间
- en: The time between a user clicking an element and the next action (for example,
    the start of an animation, or sending a request to the server)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击一个元素与下一个动作（例如，动画的开始或向服务器发送请求）之间的时间
- en: The time it takes for various page resources to load
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种页面资源加载所需的时间
- en: The time it takes for information to be sent from the browser to the server,
    and then to get a reply
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信息从浏览器发送到服务器，然后获取回复所需的时间
- en: 'The API also gives us access to particular data that the browser collects during
    events leading up to our site being loaded, such as the following:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 该API还使我们能够访问在网站加载前浏览器收集的特定数据，例如以下内容：
- en: The type of navigation that leads to the page being loaded (from history, navigation
    event, or page reload)
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导致页面加载的导航类型（从历史记录、导航事件或页面刷新）
- en: How long it took for the DNS to respond with the IP address of the webserver
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS响应IP地址所需的时间
- en: How long it took to establish a TCP connection
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立TCP连接所需的时间
- en: You can also create custom measurements to see how long particular processes
    take in the application. Together, all of this information can be used to create
    detailed accounts of a site's performance, help identify areas of the application
    which need optimization, and track the performance improvements (or hits) as you
    make changes to your site.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建自定义测量来查看特定过程在应用程序中花费的时间。所有这些信息都可以用来创建一个网站的详细性能报告，帮助识别需要优化的应用程序区域，并跟踪你在对网站进行更改时的性能改进（或打击）。
- en: 'Let''s say you want to know how long your page takes to load. That''s a reasonable
    question to ask, but you have to be a bit more specific about what you mean before
    answering this question accurately and usefully. First, you need to ask yourself
    what information you actually want: from a developer''s point of view, this question
    could be interpreted as "how long does it take for my webserver to send all the
    requested resources to the browser, and for the browser to then process and render
    them?", but from the user''s perspective, the question would be more akin to,
    "how long does it take from the moment I click a link to the moment the page has
    fully loaded?". Both of these questions are important, but the user''s question
    requires more information to answer than the developer''s. So, we can start to
    see that we need to break down all the events taking place to be able to answer
    these, and other, questions. This is where the Performance API comes in: it gives
    us many metrics we can use, including from processes that happen before our page
    is requested.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想知道你的页面加载需要多长时间。这是一个合理的问题，但在准确和有用地回答这个问题之前，你必须更具体地说明你的意思。首先，你需要问自己你实际上想要什么信息：从开发者的角度来看，这个问题可以解释为“我的web服务器发送所有请求的资源到浏览器，以及浏览器处理和渲染这些资源需要多长时间？”，但从用户的角度来看，这个问题更像是，“从我点击链接到页面完全加载需要多长时间？”。这两个问题都很重要，但用户的问题需要更多的信息来回答，而不仅仅是开发者的问题。因此，我们可以开始看到，我们需要分解所有发生的事件，以便能够回答这些问题，以及其他问题。这正是性能API发挥作用的地方：它为我们提供了许多我们可以使用的指标，包括在我们请求页面之前发生的过程。
- en: 'First, let''s break down some of the key steps that take place when a user
    clicks on a link to a site at a new domain. In practice, there are more steps
    involved than those shown here, but it''s not really necessary to unpick the whole
    process for this example:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分解一下当用户点击新域名网站链接时发生的一些关键步骤。实际上，涉及的步骤比这里显示的要多，但在这个例子中，真正没有必要剖析整个流程：
- en: '![Figure 8.15: Overview of processes after a user clicks a link'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15：用户点击链接后的过程概述](img/C14377_08_15.jpg)'
- en: '](img/C14377_08_15.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15：用户点击链接后的过程概述](img/C14377_08_15.jpg)'
- en: 'Figure 8.15: Overview of processes after a user clicks a link'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：用户点击链接后的过程概述
- en: 'Let''s go through the following steps:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按以下步骤进行：
- en: When a user clicks on a link – say a Google search result – the browser sends
    a request to the **domain name server** (**DNS**) and receives the IP address
    of the webserver for that domain.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户点击链接——比如一个Google搜索结果——浏览器向域名服务器（DNS）发送请求，并接收该域的web服务器IP地址。
- en: The browser then opens a TCP connection with the server at the IP address.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览器随后与IP地址处的服务器建立TCP连接。
- en: When this connection process has finished, the browser requests the page data.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当这个连接过程完成后，浏览器请求页面数据。
- en: The server responds with that data and the browser process and displays the
    page to the user. This is a very high-level, stripped-down, simplified account
    of what happens when a browser wants to load a page, and it assumes nothing went
    wrong. The takeaway here is that there's a lot going on and that there are many
    potential areas for navigation and page loads to be slowed down. Using the Performance
    API gives us the timings for many key events.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应这些数据，浏览器处理并显示页面给用户。这是一个非常高级、简化、概括的描述，当浏览器想要加载一个页面时会发生什么，并且假设没有出错。这里的要点是事情很多，并且有许多潜在的导航和页面加载被减慢的区域。使用性能
    API 给我们提供了许多关键事件的计时。
- en: 'Open your browser to any page. In the console, you can view the performance
    data for that page. We can get a navigation timing object from the browser, which
    will give us much of the information we''re looking for. First, we''ll assign
    the navigation entry of the Performance API to a variable:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器到任意页面。在控制台，你可以查看该页面的性能数据。我们可以从浏览器中获取一个导航时间对象，它将给我们提供我们寻找的大部分信息。首先，我们将性能
    API 的导航条目分配给一个变量：
- en: '[PRE44]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `getEntriesByType` method returns all the performance timing entries that
    the browser has stored of the specified type. Here, we've said we want all the
    navigation type entries (there's only one entry, so we'll get an array with one
    object).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`getEntriesByType` 方法返回浏览器存储的指定类型的所有性能计时条目。在这里，我们说我们想要所有导航类型的条目（只有一个条目，所以我们将得到一个包含一个对象的数组）。'
- en: 'After assigning a reference to the `0th` object in the returned array, we can
    view the object by entering the variable''s name (that is, `navTiming`) in the
    console:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在将返回数组中的 `0th` 对象的引用分配后，我们可以在控制台中通过输入变量的名称（即 `navTiming`）来查看该对象：
- en: '![Figure 8.16: Expanded navigation timing object'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.16：Expanded navigation timing object]'
- en: '](img/C14377_08_16.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_08_16.jpg]'
- en: 'Figure 8.16: Expanded navigation timing object'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.16：展开的导航时间对象
- en: 'Expanding the navigation entry object, we can see many properties that we can
    use to calculate how long the various actions took during navigation and loading
    the current page. Let''s run through a couple of examples so that you get the
    idea:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 展开导航条目对象，我们可以看到许多属性，我们可以使用这些属性来计算在导航和加载当前页面期间各种操作所花费的时间。让我们通过几个例子来了解一下，这样你就能抓住这个概念：
- en: '[PRE45]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will give us the total time take for the domain name service to respond
    with the IP address of the requested domain. The browser will typically cache
    the IP address of a particular domain, so it may well result in zero if you''ve
    previously visited the page you''re testing. Let''s take a look at the following
    code:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们提供域名服务响应请求域的 IP 地址所需的总时间。浏览器通常会缓存特定域的 IP 地址，所以如果你之前访问过你正在测试的页面，这可能会得到零。让我们看看以下代码：
- en: '[PRE46]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `connectStart` and `connectEnd` properties are the times at which the client
    established a TCP connection with the server and the time at which the connection
    process was complete. Taking one from the other gives us the total connection
    time. Let''s take a look at the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectStart` 和 `connectEnd` 属性是客户端与服务器建立 TCP 连接的时间和连接过程完成的时间。从其中一个减去另一个，我们得到总连接时间。让我们看看以下代码：'
- en: '[PRE47]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `domComplete` property is the time at which the browser finished loading
    the document and all its resources, such as CSS and images, and the `document.readyState`
    property is set to complete. This would be the answer to our user''s question:
    "how long does it take from the moment I click a link to the moment page has fully
    loaded?".'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`domComplete` 属性是浏览器完成加载文档及其所有资源（如 CSS 和图片）的时间，而 `document.readyState` 属性被设置为
    complete。这将回答我们用户的问题：“从点击链接的那一刻到页面完全加载需要多长时间？”。'
- en: As you can see, there are many other metrics you can use in this navigation
    timing entry for timing the navigation and loading a page. But what about once
    our page has loaded and the user is interacting with it? We obviously want to
    be able to measure the performance of our site during its usage, and the Performance
    API gives us some useful methods for doing just that.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这个导航时间条目中，你可以使用许多其他指标来计时导航和加载页面。但是，一旦我们的页面加载完成，用户开始与之交互，怎么办？显然，我们希望能够在网站使用期间测量其性能，性能
    API 给我们提供了一些非常有用的方法来实现这一点。
- en: 'We can use the Performance API to measure the performance of any part of our
    site or application by making use of the `mark()` and `measure()` methods of the
    interface. For example, let''s say part of your application involves some CPU-intensive
    processing that you want to optimize. You can use performance marks to measure
    the time it takes to a high degree of precision and measure the success of different
    optimization approaches:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用性能API通过使用接口的`mark()`和`measure()`方法来测量我们网站或应用程序任何部分的性能。例如，假设你的应用程序涉及一些需要优化的CPU密集型处理，你可以使用性能标记来以高精度测量所需时间并测量不同优化方法的成功程度：
- en: '[PRE48]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here, we''ve defined a function that performs some arbitrary calculation `for`
    loop, we can use the `performance.mark()` method at the beginning and end of the
    loop, then use the `performance.measure()` method to measure the two marks and
    return the resulting measure:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个执行一些任意计算的`for`循环的函数，我们可以在循环的开始和结束处使用`performance.mark()`方法，然后使用`performance.measure()`方法来测量这两个标记并返回结果：
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Calling the mark method creates a performance timeline entry with the name
    provided (we called our `compStart` and `compEnd`). We can then use `performance.measure()`
    to create a `performance.measure` entry, which will give us the precise times
    between the start and end marks. Running `complicatedFunction()` will give us
    the following output:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 调用标记方法会创建一个带有提供名称的性能时间线条目（我们称之为`compStart`和`compEnd`）。然后我们可以使用`performance.measure()`来创建一个`performance.measure`条目，这将给我们提供开始和结束标记之间的精确时间。运行`complicatedFunction()`将给出以下输出：
- en: '![Figure 8.17: Output from running the function'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：函数运行输出'
- en: '](img/C14377_08_17.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：函数运行输出](img/C14377_08_17.jpg)'
- en: 'Figure 8.17: Output from running the function'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：函数运行输出
- en: 'Exercise 8.07: Assessing Performance'
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.07：评估性能
- en: Let's say we want to add a new feature to our app that involves a similar CPU-intensive
    process to our preceding example, so we want to make sure we write the function
    in the most efficient way possible. We can use the Performance API's `mark()`
    and `measure()` methods to find the precise time taken to run a particular section
    of code, and we can then compare two different implementations of the same logic.
    In this exercise, we will use the `mark()` method to mark the start and endpoints
    of the blocks of code we want to compare, and we will use the `measure()` method
    to measure the exact time between the marks. Our output will be the time difference.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要向我们的应用程序添加一个新功能，该功能涉及与上一个示例中类似的CPU密集型过程，因此我们想要确保以尽可能高效的方式编写函数。我们可以使用性能API的`mark()`和`measure()`方法来找到运行特定代码段的确切时间，然后我们可以比较相同逻辑的两种不同实现。在这个练习中，我们将使用`mark()`方法标记我们想要比较的代码块的开始和结束点，并使用`measure()`方法来测量标记之间的确切时间。我们的输出将是时间差。
- en: 'Let''s take the preceding example and compare the performance of different
    looping functions in JavaScript. Let''s get started:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们拿上一个示例来比较JavaScript中不同循环函数的性能。让我们开始吧：
- en: 'This first function will measure the performance of a `for` loop. Start by
    declaring a function and initializing a variable that will hold a value that was
    used in the loop:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个第一个函数将测量`for`循环的性能。首先，声明一个函数并初始化一个变量，该变量将保存循环中使用的值：
- en: '[PRE50]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we''ll use the `performance.mark()` method to mark the start of the looping
    function, and we''ll give the mark a name of `forLoopStart`:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`performance.mark()`方法标记循环函数的开始，并给标记一个名为`forLoopStart`的名字：
- en: '[PRE51]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we''ll run the for loop, which does the same calculations as it did in
    the preceding example:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将运行`for`循环，它执行的计算与上一个示例中的相同：
- en: '[PRE52]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This second function will measure the performance of a while loop:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个函数将测量`while`循环的性能：
- en: '[PRE53]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, let''s run both of these functions and see how the performance compares:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行这两个函数并比较性能：
- en: '[PRE54]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we have declared two functions, both of which produce the same result,
    but using different JavaScript looping functions: a `for` loop and a `while` loop.
    We are marking the moment before each loop starts, and again marking the moment
    the loops end. We then measure the marks and log the measured duration to the
    console. What results did you get?'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了两个函数，它们都产生相同的结果，但使用不同的JavaScript循环函数：一个`for`循环和一个`while`循环。我们在每个循环开始之前标记，并在循环结束时再次标记。然后我们测量标记，并将测量的持续时间记录到控制台。你得到了什么结果？
- en: '![Figure 8.18: Results from the performance tests on a for loop and a while
    loop'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18：对`for`循环和`while`循环的性能测试结果'
- en: '](img/C14377_08_18.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17：函数运行输出](img/C14377_08_17.jpg)'
- en: 'Figure 8.18: Results from the performance tests on a for loop and a while loop'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：for循环和while循环的性能测试结果
- en: Your results may be quite different, depending on the system and the JavaScript
    engine you're running the code on, but you should still see a marked difference
    between the two loop statements. This section has dipped into a fairly advanced
    topic and one that may not be quite as exciting as, say, drawing triangles. However,
    application performance is important to keep in mind as failing to do so can lead
    to slow apps that people will find frustrating and may ultimately abandon.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 您的结果可能会有很大差异，这取决于您运行的系统和JavaScript引擎，但您应该仍然能在两个循环语句之间看到明显的差异。本节深入探讨了相当高级的主题，可能不如绘制三角形那样令人兴奋。然而，应用程序的性能是需要牢记在心的，因为未能做到这一点可能会导致应用程序运行缓慢，人们会感到沮丧，并最终放弃使用。
- en: Web Socket API
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebSocket API
- en: Typically, when a browser connects to a server during normal browsing, it does
    so over HTTP or HTTPS. For the purposes of this topic, all we really need to know
    about HTTP is that each time a browser wants to send or receive a piece of information
    from the server, it has to open a new connection to that server, make its request,
    and then close the connection. This is fine for most situations, but it's a one-way
    street; the server cannot open a connection with the browser. This means that
    if the server receives some new data, it has no way of alerting the browser, and
    instead has to rely on the browser querying the server at some point and asking
    for the data. A lot of the time, this is ok because we developers know when we
    can expect new data to be available, or we know when in our application we want
    to request any new data.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当浏览器在正常浏览过程中连接到服务器时，它使用HTTP或HTTPS。就本主题而言，我们真正需要了解的HTTP是，每次浏览器想要从服务器发送或接收信息时，它都必须打开到该服务器的新连接，发出请求，然后关闭连接。这在大多数情况下是可以的，但它是一条单行道；服务器无法与浏览器建立连接。这意味着如果服务器收到一些新数据，它无法通知浏览器，而必须依赖于浏览器在某个时刻查询服务器并请求数据。很多时候，这是可以接受的，因为作为开发者，我们知道何时可以期待新数据可用，或者我们知道在应用程序中何时需要请求任何新数据。
- en: 'Relying on a developers'' savviness falls short, of course, in situations where
    we don''t have full control over when or how often new data is made available
    to the server. The classic example of such a situation is with real-time chat
    apps, for example, Facebook''s instant messaging or WeChat. We''re probably all
    familiar with the basic functionality of these apps: two or more people can send
    messages to each other, and they will appear on the receiver''s device instantly
    (minus the network latency and processing time).'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅依赖开发者的敏锐度是不够的，因为在某些情况下，我们无法完全控制新数据何时以及以何种频率提供给服务器。这类情况的经典例子是实时聊天应用，例如Facebook的即时消息或微信。我们可能都熟悉这些应用的基本功能：两个人或更多人可以互相发送消息，并且消息会立即出现在接收者的设备上（除去网络延迟和处理时间）。
- en: 'But how is this functionality achieved? If we think about this in terms of
    HTTP, there''s no elegant solution: Client A wants to send a message to Client
    B via the server. Sending the message from Client A to the server is no problem
    – the client can open an HTTP connection, send the message over, and the server
    will receive the message. But when it comes to the server relaying that message
    to Client B, the server is unable to open the connection on its end. In this situation,
    the solution would be for all connected clients to ask the server whether there
    are any new messages at regular intervals, say every 30 seconds. This is not a
    great solution; it means there will be lots of unnecessary opening and closing
    of connections, each one carrying a relatively large amount of data, in the form
    of HTTP headers. Also, if a client sends a message at second 1, then the receiving
    client won''t know about that message for at least 29 seconds – and what if it''s
    something important?'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种功能是如何实现的呢？如果我们从HTTP的角度来考虑这个问题，就没有优雅的解决方案：客户端A想要通过服务器向客户端B发送消息。从客户端A发送消息到服务器没有问题——客户端可以打开一个HTTP连接，发送消息，服务器就会收到消息。但当服务器需要将这条消息转发给客户端B时，服务器无法在其端打开连接。在这种情况下，解决方案是所有已连接的客户端定期询问服务器是否有新消息，比如每30秒一次。这不是一个好的解决方案；这意味着会有很多不必要的连接打开和关闭，每个连接都携带相对大量的数据，以HTTP头部形式存在。此外，如果客户端在第一秒发送消息，那么接收客户端至少需要29秒才能知道这条消息——如果这是一条重要消息怎么办？
- en: '**WebSockets** are an alternative way for browsers and clients to communicate
    with each other and allow for bidirectional communication; that is to say that
    the server can send a message to the client at any time. The connection process
    is fairly simple at a high level: the client connects to a server over HTTP with
    a WebSocket handshake request containing an Upgrade header (which basically tells
    the server that the client wants to upgrade the protocol to WebSocket), the server
    sends a handshake response, and the HTTP connection is upgraded to a WebSocket
    connection. And then the party starts.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket**是浏览器和客户端之间通信的另一种方式，允许双向通信；也就是说，服务器可以在任何时候向客户端发送消息。从高层次来看，连接过程相当简单：客户端通过HTTP连接到服务器，并包含一个包含Upgrade头部的WebSocket握手请求（这基本上告诉服务器客户端想要将协议升级到WebSocket），服务器发送握手响应，然后将HTTP连接升级为WebSocket连接。然后就开始了。'
- en: This WebSocket connection stays active indefinitely, and the server keeps a
    list of connected clients that it can talk to at any moment. If a connection breaks,
    then the client can try to open the connection again. As long as the connection
    is active, then either side can send messages to the other at any moment, and
    the other side can reply to those messages if necessary. It's an open, bidirectional
    channel of communication, and it's up to us developers to decide what we're going
    to use it for.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WebSocket连接会无限期地保持活跃，服务器会保持一个可以随时与之通信的已连接客户端列表。如果连接中断，则客户端可以尝试重新打开连接。只要连接保持活跃，任何一方都可以在任何时候向另一方发送消息，如果需要，另一方也可以回复这些消息。这是一个开放的、双向的通信通道，由我们开发者决定如何使用它。
- en: WebSocket messages can contain data of several types, including **Strings**,
    **ArrayBuffers**, and **Blobs**. To send and receive JavaScript objects, we can
    easily convert them into strings by using the JSON object before sending them
    and then parse them on the receiving side.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket消息可以包含多种类型的数据，包括**字符串**、**ArrayBuffers**和**Blobs**。为了发送和接收JavaScript对象，我们可以在发送之前使用JSON对象将它们转换为字符串，然后在接收端解析它们。
- en: Setting up a WebSocket server is fairly involved and would be too much detail
    to include in this chapter. However, we can easily set up a WebSocket client and
    connect to one of a number of WebSocket testing servers online.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 设置WebSocket服务器相当复杂，本章节中包含太多细节。然而，我们可以轻松设置WebSocket客户端并连接到多个在线WebSocket测试服务器之一。
- en: There are several WebSocket testing servers that we can use. In this example,
    we will use the server at `wss://echo.websocket.org`. If it's not working, feel
    free to find another online. One thing to note is that the client and server must
    start on the same HTTP protocol, so if the page that you've opened the console
    on is on HTTPS, then the WebSocket server must be on the WSS protocol (and not
    WS).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个WebSocket测试服务器我们可以使用。在这个例子中，我们将使用位于`wss://echo.websocket.org`的服务器。如果它不起作用，请随意寻找另一个在线服务器。需要注意的是，客户端和服务器必须在同一HTTP协议上启动，所以如果您在控制台打开的页面是HTTPS，那么WebSocket服务器必须在WSS协议上（而不是WS）。
- en: Open your browser to any page of your choosing, open the developer tools, and
    open the console.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您浏览器中的任意页面，打开开发者工具，然后打开控制台。
- en: WebSocket connections are event-driven, so when we create a connection, we must
    assign functions to the events we want to handle.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket连接是事件驱动的，因此当我们创建连接时，我们必须为要处理的事件分配函数。
- en: 'To start off, let''s create a new WebSocket connection using the browser''s
    WebSocket constructor function. It takes the server address as a parameter:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用浏览器的WebSocket构造函数创建一个新的WebSocket连接。它需要一个服务器地址作为参数：
- en: '[PRE55]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If you run this code, and then access the socket object in the console, you
    will see the new connection object we have created:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此代码，然后在控制台中访问socket对象，您将看到我们创建的新连接对象：
- en: '![Figure 8.19: The WebSocket connection object'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19：WebSocket连接对象](img/C14377_08_19.jpg)'
- en: '](img/C14377_08_19.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/C14377_08_19.jpg)'
- en: 'Figure 8.19: The WebSocket connection object'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：WebSocket连接对象
- en: 'Here, we can see the URL of the server we''re connected to, and also that there
    are event listeners for `onmessage` property:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们连接到的服务器URL，以及`onmessage`属性的事件监听器：
- en: '[PRE56]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we are ready to send a message to the WebSocket server:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已准备好向WebSocket服务器发送消息：
- en: '[PRE57]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The server I have chosen – and surely any other WebSocket testing server –
    will simply output whatever message you send to it back as a response. Since we
    have an event handler attached to the message event, which will log the event
    to the console, we should get this event object logged to our console soon after
    we send the message:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择的 - 以及当然任何其他 WebSocket 测试服务器 - 将简单地输出你发送给它的任何消息作为响应。由于我们有一个附加到消息事件的处理器，该处理器将事件记录到控制台，我们应该在发送消息后不久在我们的控制台中看到这个事件对象：
- en: '![Figure 8.20: The response from the WebSocket server'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.20：WebSocket 服务器的响应'
- en: '](img/C14377_08_20.jpg)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/C14377_08_20.jpg)'
- en: 'Figure 8.20: The response from the WebSocket server'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20：WebSocket 服务器的响应
- en: We now have a functioning WebSocket connection. If the server were programmed
    to do so, it would be able to send us messages at any time, as long as the connection
    stays open. Because WebSockets are useful for many different kinds of applications,
    there is no specific functionality built into them, even though there are some
    very common use cases. It's up to us to develop systems to handle different kinds
    of messages, for example, sending a message with a "join chat group" action versus
    a regular "send message to the user" action.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个工作的 WebSocket 连接。如果服务器被编程为这样做，它可以在任何时候发送消息，只要连接保持打开。由于 WebSockets 对许多不同类型的应用程序都很有用，它们中没有内置特定的功能，尽管有一些非常常见的用例。我们需要开发系统来处理不同类型的消息，例如，发送一个带有“加入聊天组”操作的消息与一个常规的“向用户发送消息”操作。
- en: 'Exercise 8.08: Creating Chat Rooms Using Websockets'
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.08：使用 WebSocket 创建聊天室
- en: 'Let''s create a small application to make some extended use of this WebSocket
    server. We''ll be creating an application with two chat rooms: one is a group
    chat and one is a direct message chat room with a single user. We''re a bit limited
    by the WebSocket server''s functionality since all it does it send the message
    it receives back to the client. Since we''re only one client, and the server will
    only respond with the message we send, it''ll be a bit of a lonely chat.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个小型应用，以便更充分地使用这个 WebSocket 服务器。我们将创建一个包含两个聊天室的应用程序：一个是群聊，另一个是只有一个用户的直接消息聊天室。由于
    WebSocket 服务器功能有限，因为它所做的只是将接收到的消息发送回客户端。由于我们只有一个客户端，服务器将只响应我们发送的消息，所以这将是一个有点孤独的聊天。
- en: 'For this application, we''ll need an HTML page with two lists of chat messages:
    one for the group chat and one for the direct messaging chat. We''ll also need
    an input box for both chat threads so that we can type our messages in, as well
    as a few other elements along the way. We''ll give most of the elements relevant
    IDs so that we can easily get hold of them in JavaScript later on. Let''s get
    started:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用，我们需要一个包含两个聊天消息列表的 HTML 页面：一个用于群聊，另一个用于直接消息聊天。我们还需要为这两个聊天线程添加一个输入框，以便我们可以输入我们的消息，以及沿途的一些其他元素。我们将为大多数元素分配相关的
    ID，这样我们就可以在 JavaScript 中轻松获取它们。让我们开始吧：
- en: 'Let''s start off by creating an HTML page, adding our opening HTML tag, adding
    a head tag with a script referencing a JavaScript file in the `DevTools` console,
    and adding our opening body tag:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个 HTML 页面开始，添加我们的 HTML 开头标签，在 `DevTools` 控制台中添加一个引用 JavaScript 文件的 head
    标签，并添加我们的 body 开头标签：
- en: '[PRE58]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, inside the body, we''ll add an `<h1>` element as our page''s title:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在主体内部，我们将添加一个 `<h1>` 元素作为我们页面的标题：
- en: '[PRE59]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s add an `<h4>` element, which will let us know if the socket is open
    or closed (the default is closed):'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个 `<h4>` 元素，这将让我们知道套接字是打开还是关闭（默认是关闭）：
- en: '[PRE60]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s add an `<h6>` element for our group chat message list header:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个 `<h6>` 元素作为我们的群聊消息列表标题：
- en: '[PRE61]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let''s add a  `<ul>` element to which we will append new group messages:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个 `<ul>` 元素，我们将向其中追加新的群组消息：
- en: '[PRE62]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s add an `<input>` element in which we will write messages to the group
    chat:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在群聊中添加一个 `<input>` 元素，我们将在这里输入消息：
- en: '[PRE63]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s add another `<h6>` element for the private chat room:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个 `<h6>` 元素用于私人聊天室：
- en: '[PRE64]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Let''s add a `<ul>` element for the private chat messages list:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加一个 `<ul>` 元素用于私人聊天消息列表：
- en: '[PRE65]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following is the input we need for writing private messages:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是我们编写私人消息所需的输入：
- en: '[PRE66]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we need to add our closing `<body>` and `<html>` tags:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加我们的关闭 `<body>` 和 `<html>` 标签：
- en: '[PRE67]'
  id: totrans-406
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This results in the following output:'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![Figure 8.21: Our new chat app''s HTML'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图 8.21：我们新的聊天应用的 HTML'
- en: '](img/C14377_08_21.jpg)'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/C14377_08_21.jpg)'
- en: 'Figure 8.21: Our new chat app''s HTML'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 8.21：我们新的聊天应用的 HTML
- en: 'Now for the JavaScript: let''s go through the functionality we need in a bit
    more detail. We''ll need to get hold of some of our HTML elements so that we can
    work with them in our JavaScript. We need to open a new web socket connection
    to our server, that is, `wss://echo.websocket.org`. We''ll want to notify the
    user when the socket is open or closed, so we''ll add socket event handlers for
    `onopen` and `onclose` and set our `<h4>` element''s text accordingly. We''ll
    listen for when a user has pressed the *Enter* key on either of the input boxes
    and then send a message to the socket server. The server will echo our messages
    back to us, so we''ll want to listen for incoming messages, decode them, and attach
    them to the end of the correct message list.'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在让我们更详细地了解一下JavaScript的功能。我们需要获取一些HTML元素，以便在JavaScript中处理它们。我们需要打开一个新的WebSocket连接到我们的服务器，即`wss://echo.websocket.org`。我们希望在套接字打开或关闭时通知用户，因此我们将添加`onopen`和`onclose`套接字事件处理程序，并相应地设置我们的`<h4>`元素的文本。我们将监听用户在任一输入框中按下*Enter*键时的情况，然后向套接字服务器发送消息。服务器将回显我们的消息，因此我们将监听传入的消息，解码它们，并将它们附加到正确的消息列表的末尾。
- en: That's a high-level breakdown of what our JavaScript will do, so let's walk
    through the code.
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是对我们的JavaScript将执行的操作的高级概述，让我们逐步通过代码。
- en: 'We''ll start the JavaScript file with an event listener listening for the `DOMContentLoaded`
    event, and we''ll put our code inside the event listener''s callback function:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用一个监听`DOMContentLoaded`事件的监听器来开始JavaScript文件，并将我们的代码放在事件监听器的回调函数中：
- en: '[PRE68]'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, we''ll create a new socket connection to our chosen server:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个新的套接字连接到我们选择的服务器：
- en: '[PRE69]'
  id: totrans-416
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Let''s grab the references to the various HTML elements we''ll need:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们获取我们需要的各种HTML元素的引用：
- en: '[PRE70]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, we''ll set the socket''s onopen event handler function, which will set
    the socket-status element''s inner text to Socket is open:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将设置套接字的`onopen`事件处理函数，该函数将`socket-status`元素的内部文本设置为Socket is open：
- en: '[PRE71]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We''ll also set a function for the socket''s `onclose` event, which will revert
    the status to Socket is closed:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将为套接字的`onclose`事件设置一个函数，该函数将状态重置为Socket is closed：
- en: '[PRE72]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we''ll set the socket''s `onmessage` function. This event is triggered
    when a message is received from the websocket server:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置套接字的`onmessage`函数。此事件在从WebSocket服务器接收到消息时触发：
- en: '[PRE73]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We''ll parse the incoming data from a string back to a JavaScript object using
    the JSON object''s `parse()` method and assign the result to a variable:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用JSON对象的`parse()`方法将传入的数据从字符串解析回JavaScript对象，并将结果分配给一个变量：
- en: '[PRE74]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'We''ll create a new `<li>` element and assign it to a variable called `newMessage`:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的`<li>`元素，并将其分配给一个名为`newMessage`的变量：
- en: '[PRE75]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, we''ll set the inner text value of `newMessage` `<li>` to the value of
    the message data''s message property:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将`newMessage` `<li>`的内部文本值设置为消息数据的消息属性值：
- en: '[PRE76]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, we''ll check whether the message is meant for the group chat, and if it
    is, we''ll append it to the `groupList`:'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将检查消息是否是针对群聊的，如果是，我们将将其追加到`groupList`中：
- en: '[PRE77]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If it''s not meant for the group chat, then we''ll append it to the DM list
    instead, and then close off this event handler function:'
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它不是针对群聊的，那么我们将将其追加到DM列表中，然后关闭此事件处理函数：
- en: '[PRE78]'
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Next, will iterate through both of the HTML''s input elements:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将迭代HTML的两个输入元素：
- en: '[PRE79]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We''ll add a `keydown` event listener to the input elements and assign a handler
    function to the event:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在输入元素上添加一个`keydown`事件监听器，并将处理函数分配给该事件：
- en: '[PRE80]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If the `keydown` event was triggered by the key with `messageData`:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`keydown`事件是由具有`messageData`的键触发的：
- en: '[PRE81]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, we''ll check whether the target input is the one with the ID of `group-input`,
    in which case we''ll set an action property on the `messageData` variable with
    a value of group:'
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将检查目标输入是否是具有`group-input` ID的那个，如果是的话，我们将在`messageData`变量上设置一个值为group的动作属性：
- en: '[PRE82]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Otherwise, we''ll assign the same property, but with a value of dm:'
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，我们将分配相同的属性，但值为dm：
- en: '[PRE83]'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Then, we''ll turn the `messageData` object into a string with the `JSON.stringify()`
    method and send it to the websocket server with the `send()` method of the socket
    connection object we created at the start:'
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`JSON.stringify()`方法将`messageData`对象转换为字符串，并使用我们最初创建的套接字连接对象的`send()`方法将其发送到WebSocket服务器：
- en: '[PRE84]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Finally, we''ll clear the target input box and close off the functions:'
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将清除目标输入框并关闭函数：
- en: '[PRE85]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Open the HTML file in your browser and if you type a message into either of
    the input boxes, you should see it echoed back in the chat list:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 HTML 文件，如果你在任一输入框中输入消息，你应该在聊天列表中看到它被回显：
- en: '![Figure 8.22: The Echo Chamber chat app with message'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.22：Echo Chamber 聊天应用的消息'
- en: '](img/C14377_08_22.jpg)'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_08_22.jpg](img/C14377_08_22.jpg)'
- en: 'Figure 8.22: The Echo Chamber chat app with message'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.22：Echo Chamber 聊天应用的消息
- en: This is a quick insight into how we can add our own functionality to the WebSocket
    API. Websockets can be useful any time we need real-time data to be shown in the
    browser, such as stock market price updates, or when it makes sense to have a
    sustained open connection with the server, such as in a chat app.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对我们如何向 WebSocket API 添加自己的功能的一个快速了解。在任何需要实时数据在浏览器中显示的时候，WebSockets 都很有用，比如股票市场价格的更新，或者当与服务器保持持续开放连接有意义时，例如在聊天应用中。
- en: 'Activity 8.03: Audio Visualization'
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.03：音频可视化
- en: We're going to tie together a couple of the interfaces we looked at right at
    the start of this chapter, that is, the Canvas API and the Web Audio API. The
    aim of this activity is to create a page that is displaying a graphic, and for
    that graphic to animate based on the Audio `API's getFloatTimeDomainData` method
    that we looked in the *Audio API* section. The Audio API's sound should be controlled
    by the user, and the graphic should represent the audio in some way (the animation
    could change based on the sound's volume, or its frequency, for example).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把本章一开始就探讨的一些接口结合起来，即画布 API 和 Web Audio API。这个活动的目的是创建一个显示图形的页面，并且这个图形将根据我们在
    *音频 API* 部分查看的 Audio `API 的 getFloatTimeDomainData` 方法进行动画处理。音频 API 的声音应由用户控制，图形应以某种方式表示音频（例如，动画可以根据声音的音量或频率变化）。
- en: This is quite a broad specification for the activity, but you can build the
    exercises for the two APIs to come up with something, or you can make use of information
    in the *Audio Visualization* subsection of the *Web Audio API* section earlier
    in this chapter. See what you can come up with before checking out the solution.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动规格相当广泛，但你可以为两个 API 构建练习来提出一些想法，或者你可以利用本章前面 *Web Audio API* 部分的 *音频可视化* 子部分的中的信息。在查看解决方案之前，看看你能想出什么。
- en: 'The high-level steps for the activity are as follows:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的高级步骤如下：
- en: Create a simple HTML file with a link to a JavaScript file.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的 HTML 文件，其中包含一个指向 JavaScript 文件的链接。
- en: Add an event listener on the document that's listening for a click event.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档上添加一个事件监听器，监听点击事件。
- en: Set up an HTML canvas element and a canvas rendering context.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个 HTML 画布元素和画布渲染上下文。
- en: Set up an Audio context with one or more oscillators, or other audio sources
    if you like.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个包含一个或多个振荡器或其他音频源的音频上下文。
- en: Connect an audio analyzer to the audio context.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将音频分析仪连接到音频上下文。
- en: Start the audio source.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始音频源。
- en: Inside a continuous loop, draw in the Canvas context using the output from the
    audio API's `getFloatTimeDomainData()` method to modify one or more of the parameters
    of the graphic on each iteration of the loop.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个连续的循环中，使用音频 API 的 `getFloatTimeDomainData()` 方法的输出在画布上下文中绘制，以修改循环每次迭代中图形的一个或多个参数。
- en: 'The expected output should be as follows:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出应如下所示：
- en: '![Figure 8.23: One frame of the audio visualization output image'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.23：音频可视化输出图像的一帧'
- en: '](img/C14377_08_23.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/C14377_08_23.jpg](img/C14377_08_23.jpg)'
- en: 'Figure 8.23: One frame of the audio visualization output image'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23：音频可视化输出图像的一帧
- en: Note
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 734.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第 734 页找到。
- en: Summary
  id: totrans-471
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've looked at a few of the most useful and interesting browser
    APIs that open up a wide range of functionality that we can make use of in our
    JavaScript applications. We've seen that while these APIs are commonly accessed
    through JavaScript, they are not a part of the ECMAScript specification to which
    JavaScript engines are programmed and are not part of JavaScript's core functionality.
    Even though we covered quite a lot of information in this chapter, there are many
    more APIs available to us. When working with browser APIs, it's important to check
    how much browser support there is for that particular feature, as some APIs are
    experimental or non-standard, while others are deprecated or obsolete. Often,
    some browsers will fully support a feature, others will support certain aspects
    of the same interface, and then others will not support it at all. It is a bit
    of a minefield, but make use of [caniuse.com](http://caniuse.com), which you looked
    at earlier in this book, to steer yourself and your projects in the right direction.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了几个最有用和有趣的浏览器API，这些API为我们打开了广泛的功能，我们可以在JavaScript应用程序中使用。我们了解到，尽管这些API通常通过JavaScript访问，但它们并不是JavaScript引擎编程的ECMAScript规范的一部分，也不是JavaScript的核心功能的一部分。尽管我们在本章中涵盖了相当多的信息，但还有许多其他API可供我们使用。当与浏览器API一起工作时，检查特定功能在浏览器中的支持程度非常重要，因为一些API是实验性的或非标准的，而其他API则已过时或废弃。通常，某些浏览器将完全支持一个功能，其他浏览器将支持同一接口的某些方面，而其他浏览器则完全不支持。这有点像雷区，但请利用[caniuse.com](http://caniuse.com)，这是你在本书早期看到的，来引导你自己和你的项目走向正确的方向。
- en: 'For a list of available Web APIs, check out the Mozilla Developer Network''s
    page: [https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API).'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看可用的Web API列表，请查看Mozilla开发者网络页面：[https://developer.mozilla.org/en-US/docs/Web/API](https://developer.mozilla.org/en-US/docs/Web/API)。
- en: So far, you have been mostly learning about traditional, browser-based JavaScript.
    However, there are many other environments outside of the browser where JavaScript
    can run. In the next chapter, we'll look at some of these other environments,
    notably **Node.js**, which is typically used for server-side JavaScript execution.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你主要学习的是基于浏览器的传统JavaScript。然而，JavaScript还可以在浏览器之外的其他许多环境中运行。在下一章中，我们将探讨这些其他环境，特别是**Node.js**，它通常用于服务器端JavaScript执行。
