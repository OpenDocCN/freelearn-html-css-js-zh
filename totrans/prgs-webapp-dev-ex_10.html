<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Service Worker Tools</h1>
                
            
            
                
<p class="calibre2">Web development has become complicated today with so many options, steps, and tools. <strong class="calibre4">Progressive Web Apps</strong> (<strong class="calibre4">PWAs</strong>) require a new model but that can produce many opportunities for errors to creep into the code. The good news is that there are several tools that you can integrate into your workflow to improve your application code's integrity.</p>
<p class="calibre2">In this chapter, I will review several tools I have found invaluable in helping me ensure that my applications meet a level of consistent quality before I ship them. These include <strong class="calibre4">PWABuilder</strong>, <strong class="calibre4">Lighthouse</strong>, <strong class="calibre4">Sonar</strong>, and <strong class="calibre4">WorkBox</strong>.</p>
<p class="calibre2">Lighthouse and Sonar are <em class="calibre13">linting tools</em> you can use to audit your web pages to ensure that a minimum criteria is met, including PWA, performance, hosting, and SEO requirements. PWABuilder and Workbox are very helpful in scaffolding important aspects of progressive web apps including the manifest, icons, and service workers.</p>
<p class="calibre2">As a bonus, all of these tools are available as node modules which you can execute as part of a script and from the command line. This means that you can include much of this functionality as part of your automated workflow and build processes.</p>
<p class="calibre2">The following topics will be covered in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">Scaffolding PWA assets with PWABuilder</li>
<li class="calibre11">Auditing web pages using Lighthouse</li>
<li class="calibre11">Auditing web pages using Sonar</li>
<li class="calibre11">Making complex service workers with WorkBox</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using PWABuilder to scaffold your PWA</h1>
                
            
            
                
<p class="calibre2">PWABuilder is a progressive web application scaffolding tool built by the Microsoft Edge team and publicly hosted at <a href="https://pwabuilder.com" class="calibre9">https://pwabuilder.com</a>. I love this tool because you can quickly scaffold the assets you need to upgrade any website to a progressive web app in less than a minute.</p>
<p class="calibre2">There are three steps to scaffolding the PWA components, which are generating a web manifest file, picking a simple service worker, and downloading the assets:</p>
<div><div><img src="img/00121.jpeg" class="calibre133"/></div>
</div>
<p class="calibre2">Let's check each of these steps in detail.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Generating a valid web manifest file</h1>
                
            
            
                
<p class="calibre2">A valid web manifest file is one of the primary PWA requirements, but you would be surprised at how many sites miss this simple step. Most of them just forget an important field or to supply values that don't meet the guidelines, such as a long and short name value.</p>
<p class="calibre2">The biggest mistake is not including the minimum set of icons required by all the different browsers and operating systems.</p>
<p class="calibre2">To use the online tool, you need to supply a public URL, two primary application colors, and a logo or image you want to make application icons:</p>
<div><div><img src="img/00122.jpeg" class="calibre134"/></div>
</div>
<p class="calibre2">The wizard will try to parse values to supply properties, such as full name, short name, and description. If your site already has a web manifest file, it will use those properties. Don't worry: you can supply or change any value in the online form, as well as specify display orientation and language, as shown in the following screenshot:</p>
<p class="cdpaligncenter1"><img src="img/00123.jpeg" class="calibre135"/></p>
<p class="calibre2">The next step in the PWABuilder wizard is to generate a set of application icons, and there are over 100 at the time of writing this book. You can either supply a URL to a public image or upload a base image. The image generator will create a set of images to meet the criteria of each major platform: iOS, Android, and Windows. It also covers Chrome and FireFox requirements.</p>
<p class="calibre2">My favorite feature is how it includes proper references for each image in the generated web manifest file. I can't emphasize how much time this saves and how it eliminates potential errors. The fact that the service creates a complete set of images also means that you won't miss an important icon size that could keep your PWA from qualifying as a progressive web app on different platforms. Check out the following screenshot:</p>
<p class="cdpaligncenter1"><img src="img/00124.jpeg" class="calibre136"/></p>
<p class="calibre2">When you click the Input Image input field, you are greeted with a form so that you can upload an image. You can choose a file on your hard drive:</p>
<div><img src="img/00125.jpeg" class="calibre137"/></div>
<p class="calibre2">When the wizard completes, the product is a package containing all the icons and a manifest file with the icons referenced:</p>
<p class="cdpaligncenter1"><img src="img/00126.jpeg" class="calibre138"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Building a service worker</h1>
                
            
            
                
<p class="calibre2">After uploading a source image to make the application icons, the service worker step displays. Here, you are given a selection of premade service workers. These are all basic service workers that can work with most sites so that you can start the progressive web application journey.</p>
<p class="calibre2">There are five starter service worker options:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">Offline page</strong>: Initializes the service worker cache with an offline fallback page</li>
<li class="calibre11"><strong class="calibre1">Offline copy of pages</strong>: As the user visits pages on your site, they are cached, making return visits fast and offline capable</li>
<li class="calibre11">Offline copy with a backup of offline pages</li>
<li class="calibre11"><strong class="calibre1">Cache-First Network</strong>: Checks the cache for a valid response before hitting the network, which adds network responses to the cache</li>
<li class="calibre11"><strong class="calibre1">Advanced Pre-Caching</strong>: Currently under development, but designed to give you more control over site assets that are cached when the service worker is installed</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Downloading your site's PWA assets</h1>
                
            
            
                
<p class="calibre2">After selecting a starter service worker, PWABuilder provides links to download packaged versions of your PWA and native apps. You have the option to download just the progressive web app assets, a pre-packaged Windows appx file, and native apps for the Google Play and iOS App stores.</p>
<p class="calibre2">In most cases, the native app versions won't be needed, but can be handy just in case you need access to platform-specific APIs and integrations.</p>
<p class="calibre2">You can click the buttons corresponding to the package you need. PWABuilder will then generate a package, a ZIP file, containing the assets you need. The site also provides instructions for integrating the scaffolded code into your site and submitting the app store packages to the various stores.</p>
<p class="calibre2">This is an example of the generated web manifest file:</p>
<div><img src="img/00127.jpeg" class="calibre139"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Scaffolded PWA images</h1>
                
            
            
                
<p class="calibre2">I think the best part to PWABuilder is how it quickly generates all the application icons as the web manifest file that properly references each image. It generates over 100 images, and I don't know about you, but I don't have the time or patience to create that many variations, much less add the code to my web manifest file.</p>
<p class="calibre2">This is part of the PWABuilder wizard, but you may have already created a valid web manifest file and a service worker and only need a collection of icons.</p>
<p class="calibre2">This is where you can access the image generation service directly at <a href="https://www.pwabuilder.com/imageGenerator" class="calibre9">https://www.pwabuilder.com/imageGenerator</a>. You'll see the same form that's included in the wizard interface. The only difference is that once you provide the base image, you can directly click the Download button to get just your PWA icons and the web manifest JSON.</p>
<p class="calibre2">You are not limited to just using the online image generator. The source code is an open source ASP.NET project, <a href="https://github.com/pwa-builder/App-Image-Generator" class="calibre9">https://github.com/pwa-builder/App-Image-Generator</a>. You will need to stand up a web server that's capable of servicing an ASP.NET site, which you could do using Docker. I don't think this version is built on .NET Core, which means you will need an instance of IIS on Windows.</p>
<p class="calibre2">The tool does not modify any files in your site, so you still need to update your pages to register the service worker and web manifest file. You will also need to copy the icons, manifest, and service worker files to your site's folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Running PWABuilder locally</h1>
                
            
            
                
<p class="calibre2">If your site is not public, don't worry: you can still take advantage of PWABuilder by running it locally. PWABuilder is actually the second generation of PWA tools produced by Microsoft. In its previous life, it was called Manifold JS, and still uses that engine.</p>
<p class="calibre2">Manifold is a collection of node modules, used by the PWABuilder site, that generate the files needed for your PWA. The Manifold JS components are available both on GitHub (<a href="https://github.com/pwa-builder" class="calibre9">https://github.com/pwa-builder</a>) and npm (<a href="https://www.npmjs.com/package/manifoldjs" target="_blank" class="calibre9">https://www.npmjs.com/package/manifoldjs</a>).</p>
<p class="calibre2">You can run PWABuilder directly from the command line. Since it is a node module, you will need Nodejs installed, and so on.</p>
<p class="calibre2">I recommend installing the PWABuilder node library globally:</p>
<pre class="calibre17"><strong class="calibre1">npm install -g pwabuilder</strong> </pre>
<p class="calibre2">Now, you can execute <kbd class="calibre12">pwabuilder</kbd> from any command line. In the following example, I added a couple of options, one to specify the target directly to save the generated assets and another to designate what platform to generate assets:</p>
<div><img src="img/00128.jpeg" class="calibre140"/></div>
<p class="calibre2">If you want to get even more ambitious, you can build your own node script to execute the PWABuilder libraries directly. You can clone the PWABuilder projects and examine the source code and how the command-line utility executes to see how you can incorporate parts of the library in your own scaffolding routines.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Auditing web pages using Lighthouse</h1>
                
            
            
                
<p class="calibre2">Lighthouse (<a href="https://developers.google.com/web/tools/lighthouse/" target="_blank" class="calibre9">https://developers.google.com/web/tools/lighthouse/</a>) is an automated tool managed by the Chrome team that can help you audit your site to identify problems that need attention. The tools audits more than just progressive web app requirements, as it checks for many best practices including performance, accessibility, and SEO.</p>
<p>Lighthouse is an open source project, and contributions are welcome.</p>
<p class="calibre2">As mentioned earlier in this book, Lighthouse can be executed two different ways:</p>
<ul class="calibre10">
<li class="calibre11">Built-in to the Chrome Developer tools' Audit tab</li>
<li class="calibre11">Node Module (<a href="https://www.npmjs.com/package/Lighthouse" target="_blank" class="calibre9">https://www.npmjs.com/package/Lighthouse</a>)</li>
</ul>
<p class="calibre2">The Chrome extension was the original implementation, but this is being phased out. Today, the extension is redundant since Lighthouse is built-in to the Developer tools.</p>
<p class="calibre2">Lighthouse will exercise a given URL in Chrome and run it through a battery of tests. These tests cover different scenarios emulating mobile cellular network and desktop versions.</p>
<p class="calibre2">It runs a battery of test against the URL in these different scenarios, looking for potential issues. It can establish a baseline for your application's performance and how well it meets minimum requirements, like being a PWA.</p>
<p class="calibre2">Lighthouse produces a score/report card, listing how a page has performed against the battery of tests. Over the course of a minute or so, an audit will reload the page several times under different conditions, with loads capturing traces each time. How long it took to load pages, become interactive, how well it worked offline, and so on are all logged.</p>
<p class="calibre2">The primary categories the Lighthouse audits are for progressive web application features, web performance optimization, accessibility, and general best practices. Recently, the tool added an SEO audit section, but this functionality is still limited at this time.</p>
<p class="calibre2">After you run a Lighthouse audit, you will see a report card. This is an example of the five top level audit type scores. These scores are based on a 0-100 scale, with 100 being perfect. The score is comprised of a weighted score for each point in the audit group:</p>
<div><img src="img/00129.jpeg" class="calibre141"/></div>
<p class="calibre2">Each one of these top-level audits runs granular tests and provides a very detailed report. Lighthouse can produce a report as either JSON or the default HTML. You can also save the data collected during a Developer tools test so that you can review and compare it with a later test.</p>
<p class="calibre2">The HTML report will automatically highlight areas you either failed on or need to address. It also provides helpful links to documentation that will help point you to a solution:</p>
<div><img src="img/00130.jpeg" class="calibre142"/></div>
<p class="calibre2">From time to time, I like to run Lighthouse from the Chrome Developer tools, just to see where I'm at in my development process. It's a quick and automated tool that can help me get insight into where I may have missed something mundane that can have a measurable impact.</p>
<p class="calibre2">For progressive web apps, it runs through a set of checklist items to be a full-blown progressive web app. Most can be automatically tested, but a few must be manually evaluated. The Lighthouse report list items should be manually verified.</p>
<p class="calibre2">The big two are obvious, HTTPS, web manifest file in a service worker, but it goes to a deeper level. It also looks at your performance and if you can load in under three seconds over a cellular connection. It does this by simulating slower network conditions and CPUs.</p>
<p class="calibre2">It also checks to make sure that you have valid icons for the different viewports and that you can prompt the Homescreen banner.</p>
<p class="calibre2">All tests are run, emulating a 3G connection and throttle down your CPU 4x from its default speed. This last part can obviously skew your test results from device to device based on the available CPU. I work on a very new i7 Surface Laptop, which runs much faster than a more seasoned i3 or i5 processor. You will also see variability as you use different virtual machines with different CPU power allocated.</p>
<p class="calibre2">Collectively, all these little things will help you know if your website will provide a good user experience or not. It's not the only way to test, but it does give you a good baseline that covers most of the areas that you need to audit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Running Lighthouse from the Chrome Developer Tools</h1>
                
            
            
                
<p class="calibre2">The easiest way to use Lighthouse is from the Chrome Developers Tools. By now, you should know how to open these tools. All desktop browsers contain Developer tools and they can be opened by pressing <em class="calibre13">F12</em> or <em class="calibre13">Ctrl</em> + <em class="calibre13">Shift</em> + <em class="calibre13">I</em>.</p>
<p class="calibre2">Once the Developer tools are open ,you have multiple options. Lighthouse is one of those options. It is labeled Audits and is presented as the last native tab. If you are like me, you may have an extension that has parked a custom tab in the tools as well. They are listed after the Audits tab:</p>
<div><img src="img/00131.jpeg" class="calibre143"/></div>
<p class="calibre2">Initially, there is not much to the Audits tab when you open it, just the Lighthouse dialog.</p>
<p class="calibre2">The dialog has a list of the five current audit categories, and the Run audit and Cancel buttons. Each category can be toggled on or off. Pressing the Run audit button starts the audit process:</p>
<div><img src="img/00132.jpeg" class="calibre144"/></div>
<p class="calibre2">During the audit process, you will see a new dialog, assuring you that the audit is running and sharing useful web development facts and stats to keep you entertained. Meanwhile, the corresponding browser tab is being exercised by Lighthouse.</p>
<p class="calibre2">If you watch the browser tab, you will see it use the built-in emulation tools to load the target page in different virtual devices and under different network conditions, including offline.</p>
<p class="calibre2">Based on how the page behaves and loads, the different tests either pass or fail. In the end, Lighthouse produces a report, which you can then use to evaluate how your page stands. Use the report to identify different aspects of the page and site to improve:</p>
<div><img src="img/00133.jpeg" class="calibre145"/></div>
<p class="calibre2">After the audit completes, you are presented with a nicely formatted report featuring a high-level grade in each category at the top. Below the scores, each category lists any failing tests or tests that you did not quite meet target numbers but should investigate. All tests that passed are grouped together and collapsed out of view but can still be viewed.</p>
<p class="calibre2">Every test should have a link with more details, indicated with a separate Learn more link, about what was tested and hopefully guidance to help you improve the page, so that you can pass the test:</p>
<div><img src="img/00134.jpeg" class="calibre146"/></div>
<p class="calibre2">You should also consider the hosting environment you are testing against. Some tests will fail on a local site because you may not have a full production scale web server. While the node http-server makes it easy to run a local web server, it does not have HTTPS and HTTP/2 by default. This makes your page fail any tests that are looking for these two features.</p>
<p class="calibre2">In these scenarios, you can safely ignore these test results due to environment limitations. I do advise performing additional tests once the site is deployed to full scale environments like development, staging, and production.</p>
<p class="calibre2">Remember, when running in the Developer tools, you should use this as an important triage step to ensure that your code and site updates improve the overall site's experience. They are not the actual experience a real user may have, because the site is hosted in a different environment. Also remember the conditions Lighthouse emulates are just that, emulated, and may not perfectly reflect a real-world device or network conditions.</p>
<p class="calibre2">Another big issue with the Developer tools Lighthouse implementation is that there is the inability to customize the audit beyond toggling major test categories. You cannot extend the audit with your own tests and categories.</p>
<p class="calibre2">This is where running Lighthouse directly as a node module offers big benefits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Running Lighthouse as a command-line utility</h1>
                
            
            
                
<p class="calibre2">I really enjoy the ability to execute Lighthouse as a node module. The Lighthouse node module has a dependency on Chrome Launcher (<a href="https://www.npmjs.com/package/chrome-launcher" target="_blank" class="calibre9">https://www.npmjs.com/package/chrome-launcher</a>), which will open an instance of Chrome to execute the test.</p>
<p class="calibre2">This means the machine executing Lighthouse should have Chrome installed. The tool uses a full instance of Chrome because it needs to render the page and use the Developer tools to emulate different modes.</p>
<p class="calibre2">Because Lighthouse is a node module, you need to install it using either npm or yarn. Like the other tools, I recommend installing it globally:</p>
<pre class="calibre17"><strong class="calibre1">&gt;npm install -g Lighthouse</strong> </pre>
<p class="calibre2">You can run a full audit right from the command line by executing Lighthouse followed by the target URL:</p>
<pre class="calibre17"><strong class="calibre1">&gt;Lighthouse https://tickets.love2dev.com</strong> </pre>
<p class="calibre2">This launches a new instance of Chrome and runs the test battery against the target URL. When completed, an HTML report file is created in the current folder. You can load this in a browser to review. It is the same report that's loaded in the Developer tools.</p>
<p class="calibre2">This is an example of an automated test report file loaded into the Lighthouse report viewer:</p>
<div><img src="img/00135.jpeg" class="calibre147"/></div>
<p class="calibre2">You can customize Lighthouse to perform the tests you need and report in the format you want. These are just some of the common options I use on my projects:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">--config-path</kbd>: The local path to the configuration file you want to use for the audit.</li>
<li class="calibre11"><kbd class="calibre12">--output</kbd>: The report format. Options are JSON, CSV, and HTML with HTML by default. You can designate more than one format.</li>
<li class="calibre11"><kbd class="calibre12">--output-path</kbd>: The location to write the report. If multiple formats are designated, the path is ignored, but each format is saved to the current path based on the target's basename.</li>
<li class="calibre11"><kbd class="calibre12">--view</kbd>: Launches a HTML report in the browser once it is written.</li>
<li class="calibre11"><kbd class="calibre12">--block-url-patterns</kbd>: Forces the browser to ignore certain assets. This is good to test without third-party scripts.</li>
<li class="calibre11"><kbd class="calibre12">--throttling-*</kbd>: Different options here to granularly control how network and CPU throttling is set during tests.</li>
<li class="calibre11"><kbd class="calibre12">--save-assets</kbd>: Persists test assets like screenshots to disks.</li>
</ul>
<p class="calibre2">In this example, a full audit is run and saved in both JSON and HTML formats:</p>
<pre class="calibre17"><strong class="calibre1">&gt;Lighthouse https://tickets.love2dev.com --output json --output html --output-path ./myfile.json</strong> </pre>
<p class="calibre2">The report is saved locally in both output formats. I like doing this because the HTML report is easy to read and the JSON report is easy to consume into third party or custom reporting solutions.</p>
<p class="calibre2">The default Lighthouse audit may not cover the rules you need to monitor or more than you want to test. You can also create your own tests, which need to be included. You can customize the audit with your own configuration.</p>
<p class="calibre2">Custom configurations are written as JSON objects. This example extends the default configuration, but limits the tests to just the performance and progressive web app tests:</p>
<pre class="calibre17">{ 
    "extends": "Lighthouse:default", 
    "settings": { 
        "onlyCategories": ["performance", "pwa"] 
    } 
} </pre>
<p class="calibre2">To use the custom configuration file, you must supply the path as a command-line switch:</p>
<pre class="calibre17"><strong class="calibre1">&gt;Lighthouse https://tickets.love2dev.com --config-path=./custom.Lighthouse.config.js --output json --output html --output-path ./pwa-tickets.json</strong> </pre>
<p class="calibre2">Ultimately, you can control everything Lighthouse uses to run an audit, including gathers, test groups, categories, and how different passes execute.</p>
<p class="calibre2">A custom configuration file makes it very easy for you to control how Lighthouse is exercised against your web app without fussing with extended command-line options. This also makes testing very repeatable and you can include the configuration files in your source control to easily restore and audit how tests were executed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Lighthouse and headless testing</h1>
                
            
            
                
<p class="calibre2">Recently, the Chrome team also released a tool called Puppeteer (<a href="https://github.com/GoogleChrome/puppeteer" target="_blank" class="calibre9">https://github.com/GoogleChrome/puppeteer</a>), which executes a headless instance of Chromium. This is not Chrome, but a variation in the code base upon which many popular applications such as Visual Studio Code are built.</p>
<p class="calibre2">A headless browser can execute a page, but not with the ability to view the page. Because the page is not visibly rendered, some of the tests are not run. You should keep this mind when executing an audit using a headless browser.</p>
<p class="calibre2">The ability to exercise Lighthouse against a headless browser has opened up opportunities for the tool to be integrated in different tools. For example, WebPageTest, HTTPArchive, Calibre, and others use Lighthouse to add additional test points to their reports. You can follow their lead and incorporate the Lighthouse node module in your in-house test and auditing work flows.</p>
<p class="calibre2">Because Lighthouse can be executed from a script as a node module, you can create an automated test to exercise over your entire website or a sample set of URLs in your website. You can then audit the results and find the common area areas you need to address.</p>
<p class="calibre2">I do advise running it over more than one URL in your site because there are many different types of pages that compose most applications. But a word of caution: limit the number of pages you automate testing. Each test instance will launch a new instance of Chrome, which can quickly get out of hand if you try to test an entire site.</p>
<p class="calibre2">The lightcrawler (<a href="https://github.com/github/lightcrawler" target="_blank" class="calibre9">https://github.com/github/lightcrawler</a>) project is a possible tool you can use to automate testing your entire site. Lighthouse Cron (<a href="https://github.com/thearegee/lighthouse-cron" target="_blank" class="calibre9">https://github.com/thearegee/Lighthouse-cron</a>) allows you to audit a site at scheduled and random intervals using cron jobs to collect scores over time. These are just a couple of examples of how Lighthouse and similar tools are being used to provide valuable testing and performance audits to make web applications better.</p>
<p class="calibre2">I would also recommend running multiple test cycles to create a comparison. Any time I run a site or page audit, I find result variations. Sometimes, like any real scientific experiment, you find outliers that do not accurately reflect the overall experience.</p>
<p class="calibre2">For example, the test machine may have a high CPU background task running or one that consumes disk and memory I/O, causing performance issues. When testing against a live site, you may also encounter network issues that fall outside of your control.</p>
<p class="calibre2">These can all lead to failed tests and poor audit results. When I see poor performance results, I will typically run 3-5 more tests to see what sort of variations I may have. When I consistently see a test fail or log poor results, I then work to improve the issue. If a failed test is consistent, the problem is my site, not the environment around the site.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Running Lighthouse in a Node script</h1>
                
            
            
                
<p class="calibre2">Like Sonar (which will be covered in the next section) and the other node-based utilities, you can also use Lighthouse in your own node scripts and modules. You need to create references to both the <kbd class="calibre12">Lighthouse</kbd> and <kbd class="calibre12">chrome-launcher</kbd> modules:</p>
<pre class="calibre17">const Lighthouse = require("Lighthouse"), 
   chromeLauncher = require('chrome-launcher'); </pre>
<p class="calibre2">Both the Chrome Launcher and Lighthouse modules return promises. You must create a new Chrome instance before launching Lighthouse.</p>
<p class="calibre2">Chrome Launcher resolves a reference to a Chrome instance. You need to pass the developer port number to the Lighthouse module. This is how Lighthouse communicates with Chrome to perform the tests:</p>
<pre class="calibre17">function launchChromeAndRunLighthouse(url, flags, config = null) { 
 
    return chromeLauncher.launch({ 
        chromeFlags: flags.chromeFlags 
    }).then(chrome =&gt; { 
 
        flags.port = chrome.port; 
        return Lighthouse(url, flags, config).then(results =&gt; { 
        // The gathered artifacts are typically removed as they can be         <br class="title-page-name"/>        //quite large (~50MB+) 
            delete results.artifacts; 
            return chrome.kill().then(() =&gt; results); 
        }); 
    }); 
} </pre>
<p class="calibre2">You should also supply your custom configuration to the Lighthouse method. You can leave this empty and the default audit is executed.</p>
<p class="calibre2">When Lighthouse starts, a new instance of Chrome is opened, just like from the command line. You can watch your site run through all the tests.</p>
<p class="calibre2">When Lighthouse is finished, it resolves the results in the target format.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Continuous build with Lighthouse</h1>
                
            
            
                
<p class="calibre2">Another way to use Lighthouse is to embed it as part of your build and deployment workflow. For example, you may use a tool like <strong class="calibre4">Travis</strong>, which exercises a script to deploy and test applications. This way, you can make sure that the project passes the Lighthouse audits before deploying to a production server.</p>
<p class="calibre2">There is a problem running more modern sites requiring authentication like the PWA ticket application. Because Lighthouse exercises web pages using an unprimed environment and sometimes when storage is not available, persisted tokens may not be available.</p>
<p class="calibre2">In the PWA ticket application, this means the site redirects to the login page. I have seen a few mentions of potential solutions to this issue, but have not had much success.</p>
<p class="calibre2">Finally, one of the cool Lighthouse tools I found is Eric Bidel's Score badges (<a href="https://github.com/ebidel/lighthouse-badge" target="_blank" class="calibre9">https://github.com/ebidel/Lighthouse-badge</a>). You can include the badges as part of your project's <kbd class="calibre12">readme</kbd> file:</p>
<div><img src="img/00136.jpeg" class="calibre148"/></div>
<p class="calibre2">Lighthouse is a fantastic tool that can help you find and diagnose many common issues that will affect your overall application user experience. It provides valid valued insight into things like progressive web application features, web performance, accessibility, and feature acts. And as we've recently seen, the team is continually adding new test sets to Lighthouse. The SEO set is just the start of a new air area that Lighthouse will cover.</p>
<p class="calibre2">The built-in tooling gives you, the developer, or any concerned party, the ability to quickly test a page to see how well you meet expectations in the default categories. You should remember the default tests run by the Chrome tool are what the Chrome team considers important and they may not match exactly to your needs.</p>
<p class="calibre2">I do recommend starting with the default tests to benchmark your site's current state. The default tests are a great set of baseline tests that I personally think every site should use as a minimum standard.</p>
<p class="calibre2">The ability to run Lighthouse directly using node gives you the ability to not only tailor tests to your requirements, but gives you the ability to customize and extend the test battery. You can dig into the Lighthouse documentation to see how to create your own tests.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Auditing web pages with Sonar</h1>
                
            
            
                
<p class="calibre2">Similar to Lighthouse, the Microsoft Edge team has also released a new site linting tool called <strong class="calibre4">Sonar </strong>(<a href="https://sonarwhal.com/" target="_blank" class="calibre9">https://sonarwhal.com/</a>). Like Lighthouse, it is an open source node module that serves as a testing harness to execute rules over a web page.</p>
<p class="calibre2">The two tools offer similar testing abilities, but also offer a different set of abilities and test batteries. Both provide a default starting point to execute a base set of tests on a page. Both can be customized with your own configurations and even extended with custom tests and reports.</p>
<p class="calibre2">Unlike Lighthouse, Sonar is not built into the browser developers tools. At least not yet, and I only say that because I could see the tool being integrated into Edge at some point, like Lighthouse is in Chrome.</p>
<p class="calibre2">Sonar also differs because it can execute tests in either Microsoft Edge, Chrome, or other testing libraries. For example, Sonar ships with a jsdom parser.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the Sonar CLI</h1>
                
            
            
                
<p class="calibre2">Because Sonar is not part of a browser, but a node module, it needs to be executed either within a custom node script or by using its command-line interface. The CLI is the best place to start using Sonar, and like Lighthouse, you need to install Sonar first. Again, I recommend a global install:</p>
<pre class="calibre17"><strong class="calibre1">npm install -g sonarwhal</strong> </pre>
<p class="calibre2">Before you can run Sonar, you need to create a configuration file, <kbd class="calibre12">.sonarwhalrc</kbd>. You can do this by hand or use the command line to initialize a configuration file:</p>
<pre class="calibre17"><strong class="calibre1">&gt; sonarwhal --init</strong> </pre>
<p class="calibre2">This kicks off a wizard, asking you a series of questions to initialize your configuration. You can choose a predefined configuration or make a custom configuration:</p>
<div><img src="img/00137.jpeg" class="calibre149"/></div>
<p class="calibre2">There are two predefined configurations available at this time: <kbd class="calibre12">web-recommended</kbd> and <kbd class="calibre12">progressive-web-apps</kbd>. Depending on which configuration you choose, the wizard will install any required node dependencies. I will cover the Sonar components a little later:</p>
<div><img src="img/00138.jpeg" class="calibre150"/></div>
<p class="calibre2">This produces a started config file, extending the built-in <kbd class="calibre12">web-recommended</kbd> package:</p>
<pre class="calibre17">{ 
    "extends": [ 
        "web-recommended" 
    ] 
} </pre>
<p class="calibre2">This contains a base configuration with a minimum set of rules, a formatter, and connector definition. This is what the <kbd class="calibre12">web-recommended</kbd> configuration file looks like. You can use the following code as a reference to see how to create your own configuration files:</p>
<pre class="calibre17">{ 
    "connector": { 
        "name": "jsdom", 
        "options": { 
            "waitFor": 5000 
        } 
    }, 
    "formatters": [ 
        "summary" 
    ], 
    "rules": { 
        "axe": "error", 
        "content-type": "error", 
        "disown-opener": "error", 
        "highest-available-document-mode": "error", 
        "html-checker": "error", 
        "http-cache": "error", 
        "http-compression": "error", 
        "meta-charset-utf-8": "error", 
        "meta-viewport": "error", 
        "no-bom": "error", 
        "no-disallowed-headers": "error", 
        "no-friendly-error-pages": "error", 
        "no-html-only-headers": "error", 
        "no-http-redirects": "error", 
        "no-protocol-relative-urls": "error", 
        "no-vulnerable-javascript-libraries": "error", 
        "sri": "error", 
        "ssllabs": "error", 
        "strict-transport-security": "error", 
        "validate-set-cookie-header": "error", 
        "x-content-type-options": "error" 
    }, 
    "rulesTimeout": 120000 
} </pre>
<p class="calibre2">I will demonstrate how to customize this configuration a little later.</p>
<p class="calibre2">You are not limited to a single configuration to extend, as you can extend multiple configurations, as mentioned in the following code:</p>
<pre class="calibre17">{ 
    "extends": [ 
        "config1", "config2" 
    ] 
} </pre>
<p class="calibre2">You are not limited to the built-in configurations and you don't need to run the initialization wizard. You can create your own configuration file, as they are just JSON documents:</p>
<pre class="calibre17">{ 
    "connector": { 
        "name": "edge" 
    }, 
    "formatters": ["json"], 
    "rules": { 
        "rule1": "error", 
        "rule2": "warning", 
        "rule3": "off" 
    }, 
    "rulesTimeout": 120000 
    ... 
} </pre>
<p class="calibre2">Once Sonar has a configuration, you can execute it from the command line. Like Lighthouse, you just need to execute Sonar followed by a valid URL:</p>
<pre class="calibre17"><strong class="calibre1">&gt; sonarwhal https://tickets.love2dev.com</strong></pre>
<p class="calibre2">You can customize the test by creating a custom configuration file. Sonar will look for the <kbd class="calibre12">.sonarwhalrc</kbd> file in the current folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Sonar components</h1>
                
            
            
                
<p class="calibre2">There are five components of Sonar you need to familiarize yourself with to understand how the tool works.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Configurations</h1>
                
            
            
                
<p class="calibre2">These are the <kbd class="calibre12">.sonarwhalrc</kbd> files I covered earlier. These are the files that drive a specific test or audit against your site.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Connectors</h1>
                
            
            
                
<p class="calibre2">The connector is the interface between the rules Sonar executes and the URL. Right now, there are three official connectors available:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">jsdom</kbd>: A nodejs implementation of the WHATWG DOM, which means it provides a pretty good engine to test how the page renders.</li>
<li class="calibre11"><kbd class="calibre12">chrome</kbd>: Executes the rules by launching Chrome, using it's debugging protocol.</li>
<li class="calibre11"><kbd class="calibre12">edge</kbd>: Exercises the rules using Microsoft Edge. This requires Windows 10 because Edge only works on Windows.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Formatters</h1>
                
            
            
                
<p class="calibre2">Formatters take the test results and <em class="calibre13">print</em> them. There are currently five formatters being maintained by the Sonar team:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">json</kbd>: Creates a JSON formatted report</li>
<li class="calibre11"><kbd class="calibre12">stylish</kbd>: Produces a table formatted report</li>
<li class="calibre11"><kbd class="calibre12">excel</kbd>: Generates the report as an Excel worksheet</li>
<li class="calibre11"><kbd class="calibre12">codeframe</kbd>: Produces the report in a codeframe style</li>
<li class="calibre11"><kbd class="calibre12">summary</kbd>: Formats the report in a table</li>
</ul>
<p class="calibre2">My personal favorite is JSON because I can then use that as a raw data source to add it to a custom report or combine it with other tools like Lighthouse's reports to complete a full site audit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Parsers</h1>
                
            
            
                
<p class="calibre2">Rules subscribe to parsers and the events they emit to perform tests. They are designed to focus on specific resource types, like JavaScript and web manifest files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Rules</h1>
                
            
            
                
<p class="calibre2">Rules are the heart of Sonar because they are responsible for exercising the page to see if the desired criteria are met. There are a number of rules included in the default Sonar installation. Like the rest of Sonar, you are free to create your own rules.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Automating site audits with the Sonar node module</h1>
                
            
            
                
<p class="calibre2">The combination of being a nodejs module and the command-line interface gives you multiple ways to integrate Sonar as part of your build and deployment process.</p>
<p class="calibre2">Unlike Lighthouse, there are no command-line switches because it relies on the configuration file. If you want to execute different configurations, you need to run sonarwhal from the target folder so that the desired custom configuration is loaded.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Making complex service workers with workbox</h1>
                
            
            
                
<p class="calibre2"><strong class="calibre4">Workbox</strong> (<a href="https://developers.google.com/web/tools/workbox/" class="calibre9">https://developers.google.com/web/tools/workbox/</a>) is another open source project to help you create service workers. It is maintained by the Chrome team, but like the other projects, I have reviewed those open to public contributions.</p>
<p class="calibre2">The goal of Workbox is to help scaffold complete service workers or add complex components to existing service workers. Workbox allows you to build on a solid foundation, so you can configure to meet your specific needs. It gives you control over how you build your service worker. You can manually add features to existing service workers and tooling to scaffold a service worker from scratch.</p>
<p class="calibre2">A properly configured service worker uses a combination of appropriate caching strategies. The key part of that sentence is a <em class="calibre13">properly configured service worker</em>, which is, as you should know by now, not simple.</p>
<p class="calibre2">Workbox is a tool to scaffold the caching components in your service worker. The tool focuses on providing boilerplate code to help with the following service worker areas:</p>
<ul class="calibre10">
<li class="calibre11">Precaching</li>
<li class="calibre11">Runtime caching</li>
<li class="calibre11">Strategies</li>
<li class="calibre11">Request routing</li>
<li class="calibre11">Background sync</li>
<li class="calibre11">Helpful debugging</li>
</ul>
<p class="calibre2">Workbox's history is rooted in a pair of now deprecated projects, <kbd class="calibre12">sw_precache</kbd> and <kbd class="calibre12">sw_toolbox. sw_precache</kbd>, which are managed precaching assets and <kbd class="calibre12">sw_toolbox</kbd> handled dynamic caching. Workbox focuses on managing all caching and invalidation strategies.</p>
<p class="calibre2">At the time of writing this book, Workbox is currently at version 3.2 and has come a long way in the past 18 months. Its strength is its ability to abstract complex code away from you, the developer. Instead, you can focus on configuration and in some cases, customization.</p>
<p class="calibre2">For the rest of this chapter, I will focus on updating the PWA ticket application to replace most of the code covered in <a target="_blank" href="part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 8</a>, <em class="calibre13">Applying Advanced Service Worker Cache Strategies</em>, with Workbox. I created a separate branch in the source repository called workbox.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Installing workbox</h1>
                
            
            
                
<p class="calibre2">Workbox is a collection of library and node modules. To get the full breadth of the tool, you need to install the node modules globally and clone the GitHub repository. Cloning the library is not required, but I recommend it so that you can study how the library is structured:</p>
<pre class="calibre17"><strong class="calibre1">&gt; npm install -g workbox-cli</strong> </pre>
<p class="calibre2">The Workbox node modules include command-line interfaces to help you scaffold your service worker and Workbox components. I will cover how to use the CLI as I explain the different parts of the tool.</p>
<p class="calibre2">The first step you need to take after installing the CLI is to run the Workbox wizard:</p>
<pre class="calibre17"><strong class="calibre1">&gt; workbox wizard</strong>  </pre>
<p class="calibre2">This will start a series of questions about your application:</p>
<div><img src="img/00139.jpeg" class="calibre151"/></div>
<p class="calibre2">This will create a configuration file that the <kbd class="calibre12">workbox-cli</kbd> tool can use during additional steps. This is what it generates when run and choosing the default options for the PWA ticket app:</p>
<pre class="calibre17">module.exports = { 
  "globDirectory": "C:\Source Code\PWA\pwa-ticket\www\public", 
  "globPatterns": [ 
    "**/*.{html,css,eot,svg,ttf,woff,woff2,png,txt,jpg,json,js,gif,manifest}" 
  ], 
  "swDest": "C:\Source Code\PWA\pwa-ticket\www\public\sw.js" 
}; </pre>
<p class="calibre2">The CLI commands use the settings in the configuration file to find all the files matching the <kbd class="calibre12">globPatterns</kbd> and creates an entry in the precache array. I will cover the precache list format in the next section:</p>
<div><img src="img/00140.jpeg" class="calibre152"/></div>
<p class="calibre2">I don't advise precaching 600 files and 11 MB like this example demonstrates. Instead, you should customize the configuration to trim the list to a proper amount. In this case, the PWA tickets app has all the ticket barcodes generated as part of the build process, so there is data to develop against.</p>
<p class="calibre2">I'll circle back around to show you how to customize the configuration file to maximize your Workbox service worker experience. The configuration file and the workbox-cli commands to compose your service worker are key to using the library.</p>
<p class="calibre2">You are free to use the Workbox library any way you see fit. The configuration is for the command-line tools. If you are not familiar with the different nuances to how Workbox works, then I suggest starting with the wizard first.</p>
<p class="calibre2">Once you have mastered or at least feel very comfortable with how the Workbox library works, you can start integrating it by hand. It all starts with importing the library to your service worker.</p>
<p class="calibre2">In previous chapters, I demonstrated how you can use <kbd class="calibre12">importScripts</kbd> to reference additional scripts within your service worker. You will need to reference the workbox library using <kbd class="calibre12">importScripts</kbd>:</p>
<pre class="calibre17">self.importScripts("https://storage.googleapis.com/workbox-cdn/releases/3.2.0/workbox-sw.js", 
    "js/libs/2ae25530a0dd28f30ca44f5182f0de61.min.js", 
    "js/app/libs/e392a867bee507b90b366637460259aa.min.js", 
    "sw/sw-push-manager.js" 
); </pre>
<p class="calibre2">This example shows how I replaced some of the supporting libraries in the PWA tickets app with a reference to the CDN hosted Workbox script. The library is hosted in the Google Cloud CDN.</p>
<p class="calibre2">You can also use the <kbd class="calibre12">workbox-cli copyLibrary</kbd> command to copy the library to your site. The library is not a single file, but a collection of many files containing different JavaScript classes. These files are all copied to the target directory. I used the <kbd class="calibre12">/sw</kbd> folder in the PWA tickets app.</p>
<p class="calibre2">A folder with the current Workbox version number is created within the target folder. To add a reference to the library, you need to reference the <kbd class="calibre12">workbox-sw.js</kbd> file:</p>
<pre class="calibre17">self.importScripts("sw/workbox-v3.2.0/workbox-sw.js", 
    "js/libs/2ae25530a0dd28f30ca44f5182f0de61.min.js", 
    "js/app/libs/e392a867bee507b90b366637460259aa.min.js", 
    "sw/sw-push-manager.js" 
); </pre>
<p class="calibre2">In previous Workbox versions, the entire library was loaded, which is a lot of code. This has been improved, so that now only the files needed by your service worker are loaded, reducing the payload and required storage. The 3.2 version I am using for this example has 23 different files or classes.</p>
<p class="calibre2">If you look in the folder that's created by the <kbd class="calibre12">copyFiles</kbd> method, you will see more. There are two versions for each class, production and debug. There are also source map files as well. I will show you how to toggle which versions are used as well as how to tell Workbox how to find the local modules a little later.</p>
<p class="calibre2">The CLI tool is a great way to familiarize yourself with using Workbox to scaffold your service worker, but it is really just a library. In the next section, I will review how the library is structured and get you started with how to use Workbox in your service workers to maximize your experience.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Workbox structure</h1>
                
            
            
                
<p class="calibre2">When you import the Workbox library, you are importing the root level module. The module loads additional components belonging to the workbox namespace, such as:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">workbox</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.core</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.precaching</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.routing</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.strategies</kbd></li>
<li class="calibre11"><kbd class="calibre12"><kbd class="calibre31">workbox.expiration</kbd></kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.backgroundSync</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.googleAnalytics</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.cacheableResponse</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.broadcastUpdate</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.rangeRequest</kbd></li>
<li class="calibre11"><kbd class="calibre12">workbox.streams</kbd></li>
</ul>
<p class="calibre2">Each library has its own API. Some are higher level and others work within or even extend others. Routing uses the strategies classes, which in turn can be extended through plugins. The Workbox libraries can handle most scenarios out of the box, but are configurable and extensible to allow you to customize them as needed.</p>
<p class="calibre2">You are not limited to the modules included in the library. You can create your own components and add even more value to Workbox's functionality. You can also use their modules as references to build your own custom solutions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Service worker setup</h1>
                
            
            
                
<p class="calibre2">By default, Workbox uses a debug version of the library with extra logging capabilities. You can turn this off and use the production version by setting the debug flag to false in the <kbd class="calibre12">setConfig</kbd> method. The production version is more lightweight, which means you won't be as much of a burden on your customer's data plans. The production code is minified and has heavier logging capabilities removed:</p>
<pre class="calibre17">workbox.setConfig({ 
    debug: false 
  }); </pre>
<p class="calibre2">By default, Workbox loads modules from the CDN. If you are hosting Workbox on your server, then you need to configure Workbox to load modules from your server. This requires using the <kbd class="calibre12">modulePathPrefix</kbd> in the configuration object.</p>
<p class="calibre2">To configure Workbox to use a local production version, the <kbd class="calibre12">setConfig</kbd> call would look like:</p>
<pre class="calibre17">workbox.setConfig({ 
    debug: false, 
    modulePathPrefix: "sw/ workbox-v3.2.0/" 
  }); </pre>
<p class="calibre2">You can let Workbox manage everything about your service worker, including life cycle events. If you want your service worker to immediately become active, you should do this for the <kbd class="calibre12">skipWaiting</kbd> (in <a target="_blank" href="part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 5</a>, <em class="calibre13">The Service Worker Life Cycle</em>) and <kbd class="calibre12">clientsClaim</kbd> methods:</p>
<pre class="calibre17">workbox.skipWaiting(); 
workbox.clientsClaim(); </pre>
<p class="calibre2">If you are integrating Workbox components in your service worker and are not outsourcing all life cycle management to Workbox, then you can still manage this within the install and active events, as you learned earlier in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Pre-caching with Workbox</h1>
                
            
            
                
<p class="calibre2">Earlier in this book, I covered the concept of pre-caching assets within the install event. The standard pattern used is to create a list of URLs to cache and pass those to the <kbd class="calibre12">cache.addAll</kbd> method. This is great when your application is very stable and rarely changes assets. But what if you only need to update a handful of the pre-cached responses?</p>
<p class="calibre2">Instead of using the <kbd class="calibre12">cache.addAll</kbd> method, you need to create more sophisticated routines to check revisions against cached assets and perform updates.</p>
<p class="calibre2">This is where the Workbox precaching module is helpful. It abstracts the complex logic required to manage your pre-cached assets. You can still supply a simple array of URLs, as I have demonstrated in previous chapters, and it will cache those. But you have the option of also including a corresponding hash or revision value Workbox which you can use to track the asset.</p>
<p class="calibre2">The <kbd class="calibre12">workbox.precaching.precahceAndRoute</kbd> method accepts an array which can contain strings, objects, or a combination of both. In this example, I have just copied the PWA tickets pre-cache list into the method:</p>
<pre class="calibre17">workbox.precaching.precacheAndRoute([ 
    "/", 
    "img/pwa-tickets-logo-320x155.png", 
    "js/app/512df4f42ca96bc22908ff3a84431452.min.js", 
    "js/libs/ca901f49ff220b077f4252d2f1140c68.min.js", 
     //...the remaining URLs to pre-cache 
    "cart/" 
]); </pre>
<p class="calibre2">Workbox maintains an index of cached responses with extra meta data in <kbd class="calibre12">IndexedDB</kbd>. It can only use this to update precached assets when needed. The change you need to make is converting your pre-cache list from just strings to objects containing the URL and a revision value.</p>
<p class="calibre2">Here, I have a modified the version of the list, showing just a few of the entries:</p>
<pre class="calibre17">workbox.precaching.precacheAndRoute([ 
     ... 
  { 
    "url": "error.html", 
    "revision": "24d4cb67d5da47a373764712eecb7d86" 
  }, 
  { 
    "url": "event/index.html", 
    "revision": "7127ba50c2b316ccbc33f2fad868c6a7" 
  }, 
  { 
    "url": "events/index.html", 
    "revision": "6702e4d3b1554047e8655696875b396d" 
  }, 
  { 
    "url": "fallback/index.html", 
    "revision": "d03fa5c7471ec4c84ca8bf8fefaddc2b" 
  }, 
    .... 
]); </pre>
<p class="calibre2">The most common way to generate a revision value is to calculate the file's hash. I demonstrated how to generate file hashes in <a target="_blank" href="part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 8</a>, <em class="calibre13">Applying Advanced Service Worker Cache Strategies</em>. You can leverage this routine as part of your build process or you can leverage the Workbox CLI to help.</p>
<p class="calibre2">When you run the Workbox CLI wizard, it uses the glob patterns to identify your site's assets. It creates a list of files to pre-cache with a hash value assigned to the corresponding revision values. You have two options: let the wizard scaffold your entire service worker, or have it inject the precaching code into an existing service worker.</p>
<p class="calibre2">The <kbd class="calibre12">injectManifest</kbd> functionality allows you to inject pre-caching code using the Workbox infrastructure. This is done using the CLI and the <kbd class="calibre12">injectManifest</kbd> command. You need to supply the path to the configuration script:</p>
<pre class="calibre17"><strong class="calibre1">&gt; workbox injectManifest path/to/config.js</strong> </pre>
<p class="calibre2">The CLI tool looks for the following to replace with a call to <kbd class="calibre12">preCacheAndRoute</kbd>:</p>
<pre class="calibre17">workbox.precaching.precacheAndRoute([]); </pre>
<p class="calibre2">This method allows you to maintain a source service worker you can modify as part of your build process. It also allows you to lean on the wizard to create the file hashes for you.</p>
<p class="calibre2">If you are using a file naming convention that includes a hash or revision value, you can continue to do this without supplying the hash to Workbox. For these scenarios, you can just supply the string reference.</p>
<p class="calibre2">Some files cannot use revision values in their file names, like the path to any HTML. Changing the URL changes the address, which means you either need to configure complex 301 redirect rules or worse, break links to assets.</p>
<p class="calibre2">In this example, the <kbd class="calibre12">precacheAndRoute</kbd> method is passed an array of both strings, URLs with revision values built into the names, and objects for the HTML files without a revisioned name:</p>
<pre class="calibre17">workbox.precaching.precacheAndRoute([ 
     ... 
        "js/app/libs/e392a867bee507b90b366637460259aa.min.js", 
        "js/app/libs/8fd5a965abed65cd11ef13e6a3408641.min.js", 
        "js/app/pages/5b4d14af61fc40df7d6bd62f3e2a86a4.min.js", 
        "js/app/pages/8684e75675485e7af7aab5ca10cc8da5.min.js", 
        "js/app/pages/88ea734e66b98120a5b835a5dfdf8f6c.min.js", 
  { 
    "url": "error.html", 
    "revision": "24d4cb67d5da47a373764712eecb7d86" 
  }, 
  { 
    "url": "event/index.html", 
    "revision": "7127ba50c2b316ccbc33f2fad868c6a7" 
  }, 
  { 
    "url": "events/index.html", 
    "revision": "6702e4d3b1554047e8655696875b396d" 
  }, 
  { 
    "url": "fallback/index.html", 
    "revision": "d03fa5c7471ec4c84ca8bf8fefaddc2b" 
  }, 
    .... 
]); </pre>
<p class="calibre2">You can build your list and call the <kbd class="calibre12">preCacheAndRoute</kbd> method, as I have shown, but you can also break the precache list into logical groups so that you can supply those individually using the <kbd class="calibre12">workbox.precaching.precache</kbd> method. After you have supplied all the precache references, you must call the <kbd class="calibre12">addRoute</kbd> method to complete the process:</p>
<pre class="calibre17">workbox.precaching.precache([ 
     ... 
        "js/app/libs/e392a867bee507b90b366637460259aa.min.js", 
        "js/app/libs/8fd5a965abed65cd11ef13e6a3408641.min.js", 
        "js/app/pages/5b4d14af61fc40df7d6bd62f3e2a86a4.min.js", 
        "js/app/pages/8684e75675485e7af7aab5ca10cc8da5.min.js", 
        "js/app/pages/88ea734e66b98120a5b835a5dfdf8f6c.min.js", 
     ... 
]); 
workbox.precaching.precache([ 
     ... 
  { 
    "url": "error.html", 
    "revision": "24d4cb67d5da47a373764712eecb7d86" 
  }, 
  { 
    "url": "event/index.html", 
    "revision": "7127ba50c2b316ccbc33f2fad868c6a7" 
  }, 
  { 
    "url": "events/index.html", 
    "revision": "6702e4d3b1554047e8655696875b396d" 
  }, 
  { 
    "url": "fallback/index.html", 
    "revision": "d03fa5c7471ec4c84ca8bf8fefaddc2b" 
  }, 
    .... 
]); 
 
workbox.precaching.andRoute(); </pre>
<p class="calibre2">If you are using the CLI to generate a list of files and hash values to pre-cache, you need to trim or limit the files it includes in the list. For example, the PWA tickets application automatically creates hashed names for style sheets and scripts, but not the templates and HTML assets.</p>
<p class="calibre2">A simple modification of the site's Workbox configuration file removes the css and js files from the automated process. Just remove those extensions from the <kbd class="calibre12">globPatterns</kbd> regular expression:</p>
<pre class="calibre17">module.exports = { 
  "globDirectory": "C:\Source Code\PWA\pwa-ticket\www\public", 
  "globPatterns": [ 
    "**/*.{html,eot,svg,ttf,woff,woff2,png,txt,jpg,json,gif,manifest}" 
  ], 
  "globIgnores": ["qrcodes/*.gif", "img/venues/**/*.*", "img/people/*.*", "meta/**/*.*",  
    "html/pages/*.*", "css/webfonts/*.*", "img/pwa-tickets-logo*.*", "sw/cache.manifest"], 
  "swDest": "C:\Source Code\PWA\pwa-ticket\www\public\sw.js", 
  "swSrc": "C:\Source Code\PWA\pwa-ticket\www\public\sw.src.js" 
}; </pre>
<p class="calibre2">Also note that I added a <kbd class="calibre12">globIgnores</kbd> property to the config as well. This tells the wizard to ignore any files matching these patterns. I know that the QR codes are generated by ticket and the venue images should only be loaded as needed. I also added a few additional patterns to the ignore list. Now, those assets are not pre-cached, and instead of precaching over 11 MB of assets, the service worker will now pre-cache 886 KB in 39 files:</p>
<div><img src="img/00141.jpeg" class="calibre153"/></div>
<p class="calibre2">Workbox ships with three ways you can use it to generate the revision values:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">workbox-build</kbd>: Can be included in a task runner like grunt, gulp, or npm script</li>
<li class="calibre11"><kbd class="calibre12">workbox-cli</kbd>: Can generate a list and add it to a scaffolded service worker</li>
<li class="calibre11"><kbd class="calibre12">workbox-webpack-plugin</kbd>: For webpack users</li>
</ul>
<p class="calibre2">You are not limited to the revision values the Workbox tools generate, and you can generate them as part of your own build process. The revision value just needs to be unique for each version of the file so that the Workbox service worker libraries can check to see if it needs to update the resource.</p>
<p class="calibre2">Workbox can manipulate requests to match variations to cached versions. For example, often, marketing tags are added in the <kbd class="calibre12">QueryString</kbd> and vary for many reasons. Workbox can be configured to ignore <kbd class="calibre12">QueryString</kbd> patterns to avoid duplicate content caching.</p>
<p class="calibre2">These are the common variation scenarios Workbox can be configured to optimize:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="calibre1">queryStrings and URL parameters</strong></li>
<li class="calibre11"><strong class="calibre1">Default documents</strong>: <kbd class="calibre12">index.html</kbd> and <kbd class="calibre12">default.html</kbd></li>
<li class="calibre11"><strong class="calibre1">Cean URLs</strong>: Automatically appending <kbd class="calibre12">.html</kbd> to extension-less URLs</li>
<li class="calibre11"><strong class="calibre1">Custom manipulations</strong>: An opportunity for you to define a callback method to return an array of possible matches</li>
</ul>
<p class="calibre2">This requires using the <kbd class="calibre12">precaching.PrecacheController</kbd> object. To do so, you need to create a new instance of the controller and use the <kbd class="calibre12">addToCacheList</kbd> method. This method consumes the same array(s) used with the precaching methods.</p>
<p class="calibre2">The difference is that you must manage the service worker install, activate, and fetch events manually:</p>
<pre class="calibre17">const precacheController = new workbox.precaching.PrecacheController(); 
precacheController.addToCacheList([ 
    "/", 
    "img/pwa-tickets-logo-320x155.png", 
    "js/app/512df4f42ca96bc22908ff3a84431452.min.js", 
    "js/libs/ca901f49ff220b077f4252d2f1140c68.min.js", 
    //... the remaining URLs to pre-cache 
    "cart/" 
]); 
 
precacheController.addToCacheList([ 
  { 
    "url": "html/pages/tickets.html", 
    "revision": "11c6e0cb67409cf544b162cd6a7ebfbf" 
  }, 
  { 
    "url": "html/polyfils.html", 
    "revision": "337170ad8814e7571a7b8ddb8831ae04" 
  } 
]); 
 
self.addEventListener('install', (event) =&gt; { 
  event.waitUntil(precacheController.install()); 
}); 
self.addEventListener('activate', (event) =&gt; { 
  event.waitUntil(precacheController.cleanup()); 
}); 
self.addEventListener('fetch', (event) =&gt; { 
  event.respondWith(caches.match(event.request).then(...)); 
}); </pre>
<p class="calibre2">Inside the service worker event install and activate handlers, you need to call the <kbd class="calibre12">precacheController</kbd> <kbd class="calibre12">install</kbd> and <kbd class="calibre12">cleanup</kbd> methods.</p>
<p class="calibre2">Pre-caching is just one of Workbox's strengths. Its pre-caching system solves a common issue encountered with pre-caching, and that is how to keep the cached assets up to date without flushing the entire cache and reloading. Now, you can update the service worker and it will only update changed assets, a big win.</p>
<p class="calibre2">The pre-caching system is also highly configurable and customizable. Even though Workbox performs a lot of work behind abstractions, you don't need to feel like you lost control.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Dynamic routes with Workbox</h1>
                
            
            
                
<p class="calibre2">Up to this point, the Workbox section has focused on scaffolding, pre-caching, and configuration concerns. But as you should know by this point, the complexity of a service worker grows, managing dynamic requests or any request that does not have a pre-cached response.</p>
<p class="calibre2">This is where Workbox really flexes its muscles.</p>
<p class="calibre2">Dynamic routes, like the PWA tickets event pages, need to have custom caching logic applied to them. This is where the <kbd class="calibre12">workbox.routing</kbd> object comes into play. For each dynamic route, you need to register what the route is and a handler using the <kbd class="calibre12">registerRoute</kbd> method. Its signature looks like this:</p>
<pre class="calibre17">workbox.routing.registerRoute(matchCb, handlerCb); </pre>
<p class="calibre2">The method requires a match and handler callback method. Each one of these callback methods is supplied a URL and event (<kbd class="calibre12">FetchEvent</kbd>) object. The callback methods use these parameters to determine what to do.</p>
<p class="calibre2">The callback signatures should look something like this:</p>
<pre class="calibre17">const routeCallback = ({url, event}) =&gt; { 
  //do something here 
}; </pre>
<p class="calibre2">The match callback should evaluate the request and return back a truthy value, indicating if the request matches the pattern or not:</p>
<pre class="calibre17">const EventsMatch = ({url, event}) =&gt; { 
  return (url.pathname.includes("/event/"); 
}; </pre>
<p class="calibre2">You can also supply a regular expression object (<kbd class="calibre12">RegEx</kbd>). This gives you the flexibility to assign a route handler to multiple, related assets at the same time. This is the most common way you will use Workbox routing.</p>
<p class="calibre2">The handler callback is free to apply any caching strategy needed. Again, the method should use the URL and event objects to perform these actions, just like you learned in previous chapters.</p>
<p class="calibre2">This example shows how you might integrate the <kbd class="calibre12">fetchAndRenderResponseCache</kbd> functionality demonstrated in <a target="_blank" href="part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 8</a>, <em class="calibre13">Applying Advanced Service Worker Cache Strategies</em>:</p>
<pre class="calibre17">const eventsHandler = ({url, event, params}) =&gt; { 
            return responseManager.fetchAndRenderResponseCache({ 
                request: event.request, 
                pageURL: rule.options.pageURL, 
                template: rule.options.template, 
                api: rule.options.api, 
                cacheName: cacheName     
            }) 
                .then(response =&gt; { 
                    invalidationManager.cacheCleanUp(cacheName); 
                    return response; 
                }); 
}; </pre>
<p class="calibre2">In most cases, you won't need to create your own custom callback methods because Workbox has strategy modules for most common scenarios.</p>
<p class="calibre2">You can also define a default handler for any route that may not have an explicit handler registered:</p>
<pre class="calibre17">  workbox.routing.setDefaultHandler(workbox.strategies.cacheFirst()); </pre>
<p class="calibre2">Notice how I used one of the caching strategies as the default, <kbd class="calibre12">cacheFirst</kbd>? This should help us segway to the next step in dynamic routes, using caching strategies.</p>
<p class="calibre2">You should probably have a handler any time there is an exception retrieving a response. Workbox can do this with the <kbd class="calibre12">routing.setCacheHandler</kbd> method:</p>
<pre class="calibre17">workbox.routing.setCatchHandler(({url, event, params}) =&gt; { 
  //create a custom response to provide a proper response for the error 
}); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Caching strategies</h1>
                
            
            
                
<p class="calibre2">Workbox has the five most common caching strategies built into the library:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">Stale-While-Revalidate</kbd></li>
<li class="calibre11"><kbd class="calibre12">Cache-First</kbd></li>
<li class="calibre11"><kbd class="calibre12">Network-First</kbd></li>
<li class="calibre11"><kbd class="calibre12">Network-Only</kbd></li>
<li class="calibre11"><kbd class="calibre12">Cache-Only</kbd></li>
</ul>
<p class="calibre2">Each one of these strategies is available as a method in the <kbd class="calibre12">workbox.strategies</kbd> namespace. You can use these strategies without any custom configuration, but as you have seen, everything in Workbox of highly configurable.</p>
<p class="calibre2">The best part is that these strategy methods return a reference to a properly configured route response handler.</p>
<p class="calibre2">If you want to use any of these strategies with your own fetch handler, feel free. Create a new instance of the desired strategy. Then, use the <kbd class="calibre12">event.respondWith</kbd> method, suppling the strategy's handle method. You just need to supply the <kbd class="calibre12">fetch</kbd> <kbd class="calibre12">event</kbd> object to the handle method:</p>
<pre class="calibre17">self.addEventListener('fetch', (event) =&gt; { 
  if (event.request.url === '/my-special-url/') { 
    const staleWhileRevalidate = new workbox.strategies.StaleWhileRevalidate(); 
    event.respondWith(staleWhileRevalidate.handle({event})); 
  } 
}); </pre>
<p class="calibre2">Each strategy method lets you configure the following properties:</p>
<ul class="calibre10">
<li class="calibre11">The cache name</li>
<li class="calibre11">Expiration policy</li>
<li class="calibre11">Plugins to extend the functionality</li>
</ul>
<p class="calibre2">Each caching strategy method accepts an <kbd class="calibre12">options</kbd> object. Here, you can specify these customizations. First, is the <kbd class="calibre12">cacheName</kbd>. In this example, I am registering a custom route to catch individual event page requests and cache them in the events named cache:</p>
<pre class="calibre17">workbox.routing.registerRoute( 
    new RegExp('/event/'), 
    workbox.strategies.cacheFirst({ 
        cacheName: 'events' 
    }) 
); </pre>
<p class="calibre2">I like this option because it makes it easier to manage how different asset types are cached and invalidated. Workbox makes managing invalidation easier with a custom module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Workbox cache invalidation</h1>
                
            
            
                
<p class="calibre2">Cache invalidation is handled by the Workbox Expiration plugin. This plugin allows you to control how many responses, lifetime, or a combination of both can be cached for a specific rule.</p>
<p class="calibre2">The expiration plugin is applied to the route's handler or caching strategy method. This is done by adding a new expiration plugin reference to the strategy's plugins array:</p>
<pre class="calibre17">workbox.routing.registerRoute( 
    new RegExp('/event/'), 
    workbox.strategies.cacheFirst({ 
        cacheName: 'events', 
        plugins: [ 
           new workbox.expiration.Plugin({ 
             maxEntries: 20, 
             maxAgeSeconds: 24 * 60 * 60  //1 day 
           }) 
         ] 
    }) 
); </pre>
<p class="calibre2">If you want to limit the number of cached responses for the rule, supply a numeric value for the <kbd class="calibre12">maxEntries</kbd> property. If you want to limit a responses time to live, supply a numeric value matching the number of seconds a response is valid for. As the preceding example demonstrates, you can use both at the same time. In this situation when either of the conditions is true, the clean-up logic is triggered.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding background sync functionality</h1>
                
            
            
                
<p class="calibre2">Service worker background sync is a little complicated. It requires that you wrap all network-related activities you want to include in your sync logic in tags. This means in many cases that you must modify or completely rewrite your caching logic.</p>
<p class="calibre2">Plus, most browsers do not have support for this feature yet. We are on the verge of ubiquitous support, but that has limited this important feature's appeal.</p>
<p class="calibre2">However, Workbox includes a plugin module to make background sync a breeze. Just like the Expiration plugin, you add the Background Sync plugin to a strategy's list:</p>
<pre class="calibre17">workbox.routing.registerRoute( 
    new RegExp('/event/'), 
    workbox.strategies.cacheFirst({ 
        cacheName: 'events', 
        plugins: [ 
           new workbox.expiration.Plugin({ 
             maxEntries: 20, 
             maxAgeSeconds: 24 * 60 * 60  //1 day 
           }), 
           new workbox.backgroundSync.Plugin('events', { 
             maxRetentionTime: 24 * 60 // Retry for max of 24 Hours 
           }); 
         ] 
    }) 
); </pre>
<p class="calibre2">Inside the plugin, a queue is managed that works with the background sync API to make sure requests are sent to the server. You can limit how long the service worker will try to connect with the server. In this example, I limited the retry to a single day. Unlike the expiration plugin, the <kbd class="calibre12">maxRetentionTime</kbd> property is measured in minutes, not seconds.</p>
<p class="calibre2">The added complexity background sync adds to your service worker code, which been a big roadblock for my enthusiasm. Workbox making this feature easy to integrate means it is much easier for you and I to add an extra layer of functionality to our web apps without writing this complex code.</p>
<p class="calibre2">Background sync is an important feature if you are expecting responses or data from end users. I know many enterprise applications rely on internet connectivity, but employees may not be on stable Wi-Fi. This gives them to the ability to be productive when there is intermittent or no connectivity.</p>
<p class="calibre2">As a word of caution, I do advise you to give the user advice about the state of the requests hanging in the background synch queue. This way, they know the form they submitted has not been submitted to the server.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using Google Analytics, even when the user is offline</h1>
                
            
            
                
<p class="calibre2">A common question I am asked and see others asking in various forums is, "how can I use analytics services like Google Analytics with a service worker?"</p>
<p class="calibre2">What they are ultimately asking is how they can use an analytics package when the device is offline, but the service worker allows the user to continue using the application. How do user activities get logged to the analytics tool?</p>
<p class="calibre2">The good news is that you can track offline activity with a service worker, but it does require extra plumbing on your part to store all the activities in a custom queue and sync those to the analytics package when the device comes back online.</p>
<p class="calibre2">Sounds simple, right?</p>
<p class="calibre2">One area I did not spend any time on in this book is the background sync API. There were a few good reasons, mostly due to limited browser support and the added complexity it brings to your service worker.</p>
<p class="calibre2">If you have ever written an application with a dependency on an analytics package like GA, Ensighten, and so on, you know things can be complex. Stakeholders use this data to know if their marketing campaigns and websites are working and where they can focus improvement activities.</p>
<p class="calibre2">The good news is that Workbox has you covered, at least for Google Analytics. Workbox is a Google project, so you should expect them to offer easy support for one of their products! Easy might be understating their solution, as it is a single line of code:</p>
<pre class="calibre17">workbox.googleAnalytics.initialize(); </pre>
<p class="calibre2">This turns on the Workbox library that manages Google analytics. Every request and response is managed through a background sync layer. If you need to perform some advanced configurations, you have that option as well.</p>
<p class="calibre2">For instance, if you need to differentiate online versus offline activities, you can provide overrides. If you understand custom dimensions, the cd1 parameter will make sense to you:</p>
<pre class="calibre17">workbox.googleAnalytics.initialize({ 
  parameterOverrides: { 
    cd1: 'offline', 
  } 
}); </pre>
<p class="calibre2">Even though Workbox only includes a Google Analytics provider does not mean you can't create a similar handler for your analytics package. You can use the GA provider as a reference or template to create your own analytics package provider. The production code is located in the <kbd class="calibre12">workbox-google-analytics.prod.js</kbd> file.</p>
<p class="calibre2">Don't limit yourself to just thinking about analytics packages when it comes to synchronizing offline activities. Use this as a model for any online API you may need to interact with where the user can continue interaction, even when their device is offline. This can be very handy for companies with line of business apps for field agents.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">I have always been a fan of tooling and automation to make my applications faster to code with more maintainability and hopefully fewer bugs, but it is important you have a firm understanding of what any generate code or component is doing. This is why even when you are using the progressive web application tools I highlighted in this chapter that you need to be able recognize their strengths and limitations.</p>
<p class="calibre2">You also need to have a firm understanding of how complex features like service workers function before you start using a tool like Workbox. Without this fundamental knowledge, you can quickly make a service worker that does not work as you expect. You also need to have a strong knowledge foundation to help you debug issues when these tools break.</p>
<p class="calibre2">I chose four tools I think add the most value for the developers to review in this chapter. This by no means that all the tools available to you help you build great progressive web applications.</p>
<p class="calibre2">Pinterest has a small collection of tools you may find useful on GitHub (<a href="https://github.com/pinterest/service-workers" target="_blank" class="calibre9">https://github.com/pinterest/service-workers</a>). They also have a tool to generate a service worker. There is also a webpack plugin. But the most intriguing tool may be their service worker unit testing mocking environment. This allows you to write unit tests against your service worker without running a browser instance.</p>
<p class="calibre2">Most of the major frameworks have also released command-line utilities to help you generate routing logic against your single page applications. I am also very intrigued with the rapid inclusion of CLI tools to convert these rendering engines into server engines using the same logic they have shipped to the client. I think these static sites are much easier to build PWA logic around as they have real URLs.</p>
<p class="calibre2">With the increased demand for PWAs by businesses, developers are put in the position where we need to have a deep knowledge of how to create new and update existing web apps so that they can be progressive web apps with a range of service worker complexity. The tools surveyed in this chapter should help you craft those solutions. I hope this book has helped give you the firm foundation you need to make those applications.</p>


            

            
        
    </body></html>