<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing an MEVN Application</h1>
                </header>
            
            <article>
                
<p class="mce-root"><span>Let's do a quick recap of what we have done so far in previous chapters:</span><br/></p>
<ul>
<li>We created different Vue components for different pages</li>
<li class="mce-root">We implemented Vuex—centralized state management for Vue.js applications, and defined state, getters, mutations, and actions for the components</li>
<li>We created controllers and models to interact with the Node.js backend</li>
</ul>
<p>In this chapter, we will discuss how to write test code to make sure that everything in the application works well. Writing test code is an integral part of any application. It helps to ensure that the functionalities that we have written do not break, and maintains the quality of the code we write.</p>
<p>Different practices can be followed while writing tests. It's always a good practice to write test code first, before writing the actual code. Writing tests ensures that our application will not break and everything will work as expected.</p>
<p>This helps us to write better code and also helps to reveal the potential problems before they arise.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits of writing tests</h1>
                </header>
            
            <article>
                
<p>Writing test code when developing an application has a lot of benefits. Some of them are as follows:</p>
<ul>
<li><strong>Ensures code works as expected</strong>: It helps to ensure that each piece of functionality that we have written in our application works exactly as expected.</li>
<li><strong>Improves the quality of code</strong>: It improves the quality of code. Since writing test code helps to  <span>pre-empt d</span>efects that may arise, before we write actual code, it improves the quality of the code.</li>
<li><strong>Identifies bugs beforehand</strong>: It helps to identify bugs in the early stages. Since test code is written for every functionality, bugs and issues can be identified early.</li>
<li><strong>Serves as documentation for new developers</strong>: Test code is like documentation. If we need new developers to start work on the same application, test code helps them to understand how the application works instead of going through all the application code.</li>
<li><strong>Application development is faster with test code</strong>: If we write code without the test code, we will code faster. However, if we skip the process, we will later spending most of our time later fixing the bugs that will start to crawl in, which could have been identified earlier with the test code.</li>
<li><strong>Application doesn't need to be run</strong>: Writing test code and running it doesn't require the application to be up and running. It also doesn't require the application to be built either. This reduces the development time significantly.</li>
</ul>
<p>So, in this chapter, we will discuss the following topics:</p>
<ul>
<li>Learn why and how to write unit tests and end-to-end tests</li>
<li>Learn about the technologies for writing test code for a Vue.js and Node.js application</li>
<li>Modify our application's structure to implement unit and end-to-end code</li>
<li>Write test code for Vue components</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to unit tests</h1>
                </header>
            
            <article>
                
<p>Unit testing is a software development process in which the smallest functionality of the application is tested and examined to check whether it works as expected or not. A unit is the smallest part of any application. Every test code written for a unit of an application is independent of each other. The goal of unit testing itself is to perform an individual tests and make sure that each piece is correct.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Convention for writing unit tests</h1>
                </header>
            
            <article>
                
<p><span>If you follow certain guidelines and principles while writing unit tests, it makes your code maintainable and readable. The following are a few techniques that we can use while writing unit tests for any application:</span></p>
<ul>
<li>Unit testing should be carried out in small units—for a single class or a method.</li>
<li>Unit testing should be carried out in isolation, meaning that a unit test should not be dependent on any other classes or methods, which is achieved by mocking such dependencies.</li>
<li>Since unit testing is done in smaller parts, these should be very lightweight, which makes the tests run faster.</li>
<li>A unit test should test the behavior of a unit of an application. It should expect a certain value and return a certain output.</li>
<li>Since unit tests are done in isolation, the ordering of tests for different units does not create a problem.</li>
<li>Follow <strong>Do not Repeat Yourself</strong> (<strong><span>DRY</span></strong><span>)</span>; the code should not be repeatable.</li>
<li>Add comments explaining where you can, which explains the why part of the test so that it is understandable.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An introduction to end-to-end test</h1>
                </header>
            
            <article>
                
<p>End-to-end testing is the testing of our application from start to finish. Where as unit testing tests whether the functionalities of your application work independently or not—end-to-end testing checks whether the flow of the application is performing as expected or not. Usually, the end-to-end testing makes sure that all the user interactions are carried out the way as expected. End-to-end testing ensures that the flow of the application is working as expected.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Convention for writing end-to-end tests</h1>
                </header>
            
            <article>
                
<p>There are certain guidelines to be followed when writing the end-to-end tests:</p>
<ul>
<li>Test cases should be written considering the end users and considering the real scenario</li>
<li>Multiple test cases should be created for different scenarios</li>
<li>The requirements should be gathered for all the software or applications that are involved</li>
<li>For each requirement, gather as many conditions or scenarios as possible</li>
<li>Write separate test cases for each scenario</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technologies we will be using</h1>
                </header>
            
            <article>
                
<p>Here are some of the packages that we will be working with to write the tests for our application:</p>
<ul>
<li><strong>Mocha</strong>: A JavaScript test framework to write unit testing (<a href="https://mochajs.org/">https://mochajs.org/</a>)</li>
<li><strong>Chai</strong>: An assertion library for the Node.js framework (<a href="http://chaijs.com/">http://chaijs.com/</a>)</li>
<li><strong>Sinon</strong>: <kbd>sinon</kbd> is for test spies, stubs, and mocks (<a href="http://sinonjs.org/">http://sinonjs.org/</a>)</li>
<li><strong>Nightwatch</strong>: A JavaScript library for writing end-to-end tests (<a href="http://nightwatchjs.org/">http://nightwatchjs.org/</a>)</li>
<li><strong>Karma</strong>: <kbd>karma</kbd> is the test runner for JavaScript (<a href="https://karma-runner.github.io/2.0/index.html">https://karma-runner.github.io/2.0/index.html</a>)</li>
</ul>
<p>We will discuss each of these technologies as we go along.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Mocha</h1>
                </header>
            
            <article>
                
<p>Let's create a separate working directory to learn to write tests. Create a folder called <kbd>test_js</kbd>  and switch to the <kbd><span><span>test_js</span></span></kbd> directory:</p>
<pre><strong>&gt; mkdir test_js</strong><br/><strong>&gt; cd test_js</strong></pre>
<p>Let's also create a separate folder for <kbd>test</kbd> inside the <kbd>test_js</kbd> folder:</p>
<pre><strong>&gt; mkdir test</strong></pre>
<p>To access <kbd>mocha</kbd>, you have to install it globally:</p>
<pre><strong>$ npm install mocha -g --save-dev</strong></pre>
<p>Let's write a simple test code in <kbd>mocha</kbd>. We will write a test for a simple function, which takes two arguments and returns the sum of the arguments.</p>
<p>Let's create a file called <kbd>add.spec.js</kbd> inside the <kbd>test</kbd> folder and add the following code:</p>
<pre><strong>const addUtility = require('./../add.js');</strong></pre>
<p>Then, run the following command from the <kbd>test_js</kbd> folder:</p>
<pre><strong>$ mocha</strong></pre>
<p>This test will fail, and we will require a utility called <kbd>add.js</kbd>, which does not exist. It displays the following error:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-541 image-border" src="assets/7fb7cc82-8cec-40c1-8d5f-584929a7e921.png" style="width:44.25em;height:28.92em;"/></div>
<p>Let's go ahead and write just enough code to pass the test. Create a file called <kbd>add.js</kbd> in the root of the <span><kbd>test_js</kbd> </span>project and run the code again, which should pass:</p>
<div class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-542 image-border" src="assets/4fb775f9-cbe4-48e8-bfec-babd34f2c394.png" style="width:20.25em;height:8.83em;"/></div>
<p>Let's go ahead and add the logic to the test code to check our <kbd>add</kbd> function. In <kbd>add.spec.js</kbd>, add the following lines of code:</p>
<pre>var addUtility = require('./../add.js');<br/><br/><strong>describe('Add', function(){</strong><br/><strong>  describe('addUtility', function(){</strong><br/><strong>    it('should have a sum method', function(){</strong><br/><strong>      assert.equal(typeof addUtility, 'object');</strong><br/><strong>      assert.equal(typeof addUtility.sum, 'function');</strong><br/><strong>    })</strong><br/><strong>  })</strong><br/><strong>});</strong></pre>
<p>Now comes the <kbd>assert</kbd> library. The <kbd>assert</kbd> library helps to check whether the passed expression is right or wrong. Here, we will use the built-in assertion library for Node.js.</p>
<p>To include the <kbd>assert</kbd> library, let's add the following lines of code in <kbd>add.spec.js</kbd>:</p>
<pre><strong>var assert = require("assert")</strong><br/>var addUtility = require("./../add.js");<br/><br/>describe('Add', function(){<br/>  describe('addUtility', function(){<br/>    it('should have a sum method', function(){<br/>      assert.equal(typeof addUtility, 'object');<br/>      assert.equal(typeof addUtility.sum, 'function');<br/>    })<br/>  })<br/>});</pre>
<p>Let's rerun <kbd>mocha</kbd>. This should again fail, because we haven't added a method to our module. So, let's go ahead and do that.  In <kbd>add.js</kbd>, let's add the following code:</p>
<pre><strong>var addUtility = {}</strong><br/><br/><strong>addUtility.sum = function () {</strong><br/><strong>  'use strict';</strong><br/><strong>  return true;</strong><br/><strong>}</strong><br/><br/><strong>module.exports = addUtility;</strong></pre>
<p>Let's rerun <kbd>mocha</kbd>. The spec should pass now:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1e2c62a1-ff29-41b8-a5d3-13c0548354fe.png" style="width:48.67em;height:17.17em;"/></div>
<p>Now, let's add the functional part to the sum method. In <kbd>add_spec.js</kbd>, add the following code:</p>
<pre>var assert = require("assert")<br/>var addUtility = require("./../add.js");<br/><br/>describe('Add', function(){<br/>  describe('addUtility', function(){<br/>    it('should have a sum method', function(){<br/>      assert.equal(typeof addUtility, 'object');<br/>      assert.equal(typeof addUtility.sum, 'function');<br/>    })<br/><br/>    <strong>it('addUtility.sum(5, 4) should return 9', function(){</strong><br/><strong>      assert.deepEqual(addUtility.sum(5, 4), 9)</strong></pre>
<pre><strong>    })</strong><br/>  })<br/>});</pre>
<p>Then, take a look at the test; it fails. Then, add the logic to our module:</p>
<pre>var addUtility = {}<br/><br/><strong>addUtility.sum = function (a, b) {</strong><br/>  'use strict';<br/>  <strong>return a + b;</strong><br/>}<br/><br/>module.exports = addUtility;</pre>
<p>Then, rerun <kbd>mocha</kbd> and the test should pass. That's it!:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/031b7203-8a24-4c76-a0ea-cfa3dcfb0996.png" style="width:27.92em;height:14.42em;"/></div>
<p>You can go on adding a few more cases to the test to ensure that nothing breaks.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing chai</h1>
                </header>
            
            <article>
                
<p>Let's discuss <kbd>chai</kbd>. <kbd>chai</kbd> is an assertion library, used with <kbd>mocha</kbd>. We could also use the native <kbd>assertion</kbd> library , but <kbd>chai</kbd> adds a lot of flexibility.</p>
<p><kbd>chai</kbd> makes it a lot easier to write test definitions. Let's install <kbd>chai</kbd> and modify the preceding test to make it look more simple and easy to understand:</p>
<pre><strong>$ npm install chai -g</strong></pre>
<p>We passed the <kbd>-g</kbd> option to install it globally, since we do not have a <kbd>package.json</kbd> configuration.</p>
<p>Let's use <kbd>chai</kbd> in our previous test. In <kbd>add.spec.js</kbd>, add the following lines of code:</p>
<pre><strong>var expect = require('chai').expect;</strong><br/>var addUtility = require("./../add.js");<br/><br/>describe('Add', function(){<br/>  describe('addUtility', function(){<br/>    it('should have a sum method', function(){<br/>      <strong>expect(addUtility).to.be.an('object');</strong><br/><strong>      expect(addUtility).to.have.property('sum');</strong><br/>    })<br/><br/>    it('addUtility.sum(5, 4) should return 9', function(){<br/>      <strong>expect(addUtility.sum(5, 4)).to.deep.equal(9);</strong><br/>    })<br/><br/>    it('addUtility.sum(100, 6) should return 106', function(){<br/>      <strong>expect(addUtility.sum(100, 6)).to.deep.equal(106);</strong><br/>    })<br/>  })<br/>});</pre>
<p>We have replaced the <kbd>assertion</kbd> library with, <kbd>chai</kbd> <kbd>expect()</kbd> method, which makes the code very much simpler and understandable.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing sinon</h1>
                </header>
            
            <article>
                
<p><kbd>sinon</kbd> is used to test spies, stubs, and mocks for JavaScript tests. To learn about these, let's move on to the movie rating application we have in our <kbd>controller</kbd> file, <kbd>controller/movies.js</kbd>:</p>
<pre>const Movie = require("../models/Movie");<br/>const passport = require("passport");<br/><br/>module.exports.controller = (app) =&gt; {<br/>  // fetch all movies<br/>  app.get("/movies", function(req, res) {<br/>    Movie.find({}, 'name description release_year genre', function <br/>    (error, movies) {<br/>      if (error) { console.log(error); }<br/>       res.send({<br/>        movies: movies<br/>      })<br/>    })<br/>  })<br/><br/>  // add a new movie<br/>  app.post('/movies', (req, res) =&gt; {<br/>    const movie = new Movie({<br/>      name: req.body.name,<br/>      description: req.body.description,<br/>      release_year: req.body.release_year,<br/>      genre: req.body.genre<br/>    })<br/><br/>    movie.save(function (error, movie) {<br/>      if (error) { console.log(error); }<br/>      res.send(movie)<br/>    })<br/>  })<br/>}               </pre>
<p>In the preceding code, each<span> </span>API<span> </span>call needs a request and a response object, which we need to mock. For this purpose, we have <kbd>sinon</kbd>. <kbd>sinon</kbd> provides us with a mechanism to<span> </span><kbd>stub</kbd><span> </span>and<span> </span><kbd>mock</kbd><span> </span>the requests.</p>
<p>The three major methods that <kbd>sinon</kbd> provides are spies, stubs, and mocks:</p>
<ul>
<li><strong>Spies</strong>: Spies helps to create fake functions. We can use spies to track whether the functions are executed or not.</li>
<li><strong>Stubs</strong>: Stubs helps us to make functions return whatever we want. This is useful when we want to test different scenarios for the given function.</li>
<li><strong>Mocks</strong>: Mocks are used to fake network connections. They help to create a dummy class instance, which helps to set the predetermined expectations.</li>
</ul>
<p>Let's write a test for a <kbd>get</kbd> call in the <kbd>movies</kbd> controller:</p>
<pre>// fetch all movies<br/>  app.get("/movies", function(req, res) {<br/>    Movie.find({}, 'name description release_year genre', function <br/>    (error, movies) {<br/>      if (error) { console.log(error); }<br/>       res.send({<br/>        movies: movies<br/>      })<br/>    })<br/>  })</pre>
<p>Let's<span> </span>create a new file, called <kbd>movies.spec.js</kbd>, inside the <kbd>test/units</kbd> folder:</p>
<pre><strong>var movies = require("./../../../controllers/movies.js");</strong><br/><strong>var expect = require('chai').expect;</strong><br/><br/><strong>describe('controllers.movies.js', function(){</strong><br/><strong>  it('exists', function(){</strong><br/><strong>    expect(movies).to.exist</strong><br/><strong>  })</strong><br/><strong>})</strong></pre>
<p>This test code simply checks whether the <kbd>controller</kbd> exists or not, which should pass when we run the following command:</p>
<pre><strong>$ mocha test/unit/controllers/movies.spec.js</strong></pre>
<p>This command runs the tests for our <kbd>controller/movies.js</kbd> and should pass with the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/19083b7c-1469-4580-99ad-672027db64f7.png" style="width:55.33em;height:14.25em;"/></div>
<p>Let's first write a test for a simple method. Let's create a request that responds with just an object with a name. In <kbd>movies.js</kbd>,  let's add the following code to create a dummy API:</p>
<pre>const Movie = require("../models/Movie");<br/>const passport = require("passport");<br/><br/><strong>module.exports.controller = (app) =&gt; {</strong><br/><strong>  // send a dummy test</strong><br/><strong>  app.get("/dummy_test", function(req, res) {</strong><br/><strong>    res.send({</strong><br/><strong>      name: 'John'</strong><br/><strong>    })</strong><br/><strong>  })</strong></pre>
<p>In the preceding code, we have a simple method that returns an object.</p>
<p>Let's<span> </span>move on to add the functional test part. We will be writing the test for the <kbd>/dummy_test</kbd> method.</p>
<p>In <kbd>movies.spec.js</kbd>, let's add the following lines of code:</p>
<pre><strong>var controller = require("./../../../controllers/movies.js");</strong><br/><strong>let chaiHttp = require('chai-http');</strong><br/><strong>let chai = require('chai');</strong><br/><strong>var expect = chai.expect;</strong><br/><strong>var should = chai.should();</strong><br/><strong>var express = require("express");</strong><br/><strong>let server = require('./../../../server.js');</strong><br/><strong>var app = express();</strong><br/><strong>chai.use(chaiHttp);</strong><br/><br/><br/><strong>function buildResponse() {</strong><br/><strong>  return http_mocks.createResponse({eventEmitter: require('events').EventEmitter})</strong><br/><strong>}</strong><br/><br/><strong>describe('controllers.movies', function(){</strong><br/><strong>  it('exists', function(){</strong><br/><strong>    expect(controller).to.exist</strong><br/><strong>  })</strong><br/><strong>})</strong><br/><br/><strong>describe('/GET dummy_test', () =&gt; {</strong><br/><strong>  it('it should respond with a name object', (done) =&gt; {</strong><br/><strong>    chai.request(server)</strong><br/><strong>      .get('/dummy_test')</strong><br/><strong>      .end((err, res) =&gt; {</strong><br/><strong>          res.should.have.status(200);</strong><br/><strong>          res.body.should.be.an('object');</strong><br/><strong>        done();</strong><br/><strong>      });</strong><br/><strong>  });</strong><br/><strong>});</strong></pre>
<p>In the preceding code, we have added a new package called <kbd>chai-http</kbd>, which is used to mock the request. Let's install this package, as follows:</p>
<pre><strong>$ npm install chai-http --save</strong></pre>
<p>Let's now run the test with the following command:</p>
<pre><strong>$ mocha test/unit/controllers/movies.spec.js</strong></pre>
<p>The preceding command should give us the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f7e5559c-b74b-43cb-ab62-d6998504a05a.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing tests for Node.js server</h1>
                </header>
            
            <article>
                
<p>Let's start writing the tests for the application we built for the backend part of the <kbd>node</kbd> server. </p>
<p>We will be using the following folder structure:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d12847d5-9326-47f1-a4c8-c06f8178230f.png" style="width:30.42em;height:17.67em;"/> </div>
<p>There are two folders inside the <kbd>test</kbd> folder. One for unit testing, called <kbd>unit</kbd>, and another for end-to-end testing, called <kbd>e2e</kbd>. We will start by writing the unit tests, which go under the <kbd>unit</kbd> directory. The naming convention is appending the <kbd>.spec</kbd> part to the filename for every file we will be writing tests for.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing tests for controllers</h1>
                </header>
            
            <article>
                
<p>Let's get started with writing tests for the controllers we added. Create a folder called <kbd>controllers</kbd> inside the <kbd>test/unit/specs</kbd> and create a new file inside it called <kbd>movies.spec.js</kbd>. This will be the naming convention that we will follow while creating the test files for any components: controllers, models, or Vue components—the actual filename followed by <kbd>.spec.js</kbd>. This helps to maintain the readability of the code.</p>
<p>Let's first recap what we have in our <kbd>movies.js</kbd> file: </p>
<pre>var Movie = require("../models/Movie");<br/><br/>module.exports.controller = (app) =&gt; {<br/>  // fetch all movies<br/>  app.get("/movies", function(req, res) {<br/>    Movie.find({}, 'name description release_year genre', function  <br/>    (error, movies) {<br/>      if (error) { console.log(error); }<br/>       res.send({<br/>        movies: movies<br/>      })<br/>    })<br/>  })<br/><br/>  // add a new movie<br/>  app.post('/movies', (req, res) =&gt; {<br/>    const movie = new Movie({<br/>      name: req.body.name,<br/>      description: req.body.description,<br/>      release_year: req.body.release_year,<br/>      genre: req.body.genre<br/>    })<br/><br/>    movie.save(function (error, movie) {<br/>      if (error) { console.log(error); }<br/>      res.send(movie)<br/>    })<br/>  })<br/>}</pre>
<p>This controller has two methods—one GET request and a POST request. The GET request is for fetching all the movies from the database, and the POST request saves the movies with the given parameters to the database.</p>
<p>Let's move on to adding the spec for the GET request first. Add the following contents in the <kbd>movies.spec.js</kbd> file that we just created:</p>
<pre><strong>const controller = require("./../../../../controllers/movies.js");</strong><br/><strong>const Movie = require("./../../../../models/Movie.js");</strong><br/><strong>let server = require('./../../../../server.js');</strong><br/><strong>let chai = require('chai');</strong><br/><strong>let sinon = require('sinon');</strong><br/><strong>const expect = chai.expect;</strong><br/><strong>let chaiHttp = require('chai-http');</strong><br/><strong>chai.use(chaiHttp);</strong><br/><strong>const should = chai.should();</strong></pre>
<p>The first two lines required the corresponding controller and model for the <kbd>Movie</kbd> component, which we will need later. We will also require the server file. </p>
<p>The other packages, such as <kbd>chai</kbd>, <kbd>sinon</kbd>, <kbd>expect</kbd>, and <kbd>should</kbd>, are needed for the assertions.</p>
<p>The next thing that we will need to make requests to the server is a package called <kbd>chai-http</kbd>.  This package will be used for HTTP request assertions. So, let's install this package first with the following command:</p>
<pre><strong>$ npm install chai-http --save</strong></pre>
<p>Now, we can get ahead with adding the first test. Replace the contents in <kbd>movies.spec.js</kbd> with the following code:</p>
<pre>const controller = require("./../../../../controllers/movies.js");<br/>const Movie = require("./../../../../models/Movie.js");<br/>let server = require('./../../../../server.js');<br/>let chai = require('chai');<br/>let sinon = require('sinon');<br/>const expect = chai.expect;<br/>let chaiHttp = require('chai-http');<br/>chai.use(chaiHttp);<br/>const should = chai.should();<br/><br/><strong>describe('controllers.movies', function(){</strong><br/><strong>  it('exists', function(){</strong></pre>
<pre><strong>    expect(controller).to.exist</strong><br/><strong>  })</strong><br/><strong>})</strong></pre>
<p>The preceding method describes the <kbd>movies</kbd> controller. It simply checks whether the controller we are describing exists or not.</p>
<p>To make sure we have the connection of our <kbd>node</kbd> server, let's export the server from <kbd>server.js</kbd>. Add the following code into <kbd>server.js</kbd>:</p>
<pre>...<br/>const port = process.env.API_PORT || 8081;<br/>app.use('/', router);<br/><strong>var server =</strong> app.listen(port, function() {<br/>  console.log(`api running on port ${port}`);<br/>});<br/><br/><strong>module.exports = server</strong></pre>
<p>Now, let's run the test using the following command:</p>
<pre><strong>$ mocha test/unit/specs/controllers/movies.spec.js</strong></pre>
<p>The test should pass.</p>
<p>Let's move on to adding the test for the GET request. In <kbd>movies.js</kbd>, we have the following code:</p>
<pre>var Movie = require("../models/Movie");<br/><br/>module.exports.controller = (app) =&gt; {<br/>  // fetch all movies<br/>  <strong>app.get("/movies", function(req, res) {</strong><br/><strong>    Movie.find({}, 'name description release_year genre', function <br/>    (error, movies) {</strong><br/><strong>      if (error) { console.log(error); }</strong><br/><strong>       res.send({</strong><br/><strong>        movies: movies</strong><br/><strong>      })</strong><br/><strong>    })</strong><br/><strong>  })<br/></strong>  ...<br/>}</pre>
<p>Since this method fetches all the existing movies from the database, we will first need to build the mock movies here to actually test it. Let's replace the contents of <kbd>movies.spec.js</kbd> with the following code:</p>
<pre>const controller = require("./../../../../controllers/movies.js");<br/>const Movie = require("./../../../../models/Movie.js");<br/>let server = require('./../../../../server.js');<br/>let chai = require('chai');<br/>let sinon = require('sinon');<br/>const expect = chai.expect;<br/>let chaiHttp = require('chai-http');<br/>chai.use(chaiHttp);<br/>const should = chai.should();<br/><br/>describe('controllers.movies', function(){<br/>  it('exists', function(){<br/>    expect(controller).to.exist<br/>  })<br/><br/>  <strong>describe('/GET movies', () =&gt; {</strong><br/><strong>    it('it should send all movies', (done) =&gt; {</strong><br/><strong>      var movie1 = {</strong><br/><strong>        name: 'test1',</strong><br/><strong>        description: 'test1',</strong><br/><strong>        release_year: 2017,</strong><br/><strong>        genre: 'test1'</strong><br/><strong>      };</strong><br/><strong>      var movie2 = {</strong><br/><strong>        name: 'test2',</strong><br/><strong>        description: 'test2',</strong><br/><strong>        release_year: 2018,</strong><br/><strong>        genre: 'test2'</strong><br/><strong>      };</strong><br/><strong>      var expectedMovies = [movie1, movie2];</strong><br/><strong>      sinon.mock(Movie)</strong><br/><strong>        .expects('find')</strong><br/><strong>        .yields('', expectedMovies);</strong><br/><strong>      chai.request(server)</strong><br/><strong>        .get('/movies')</strong><br/><strong>        .end((err, res) =&gt; {</strong><br/><strong>          res.should.have.status(200);</strong><br/><strong>          res.body.should.be.an('object');</strong><br/><strong>          expect(res.body).to.eql({</strong><br/><strong>            movies: expectedMovies</strong><br/><strong>          });</strong><br/><strong>          done();</strong><br/><strong>      });</strong><br/><strong>    });</strong><br/><strong>  });</strong><br/>})</pre>
<p>Let's learn step by step what we did here:</p>
<ul>
<li>We created a couple of movies with <kbd>sinon</kbd> mocks</li>
<li>We created an HTTP GET request using <kbd>chai</kbd></li>
<li>We had three expectations:
<ul>
<li>The status of the request should be <kbd>200</kbd></li>
<li>The request response should be an object</li>
<li>The response should contain the list of movies that we created with the mock</li>
</ul>
</li>
</ul>
<p>Let's run the test again with the following command:</p>
<pre><strong>$ mocha test/unit/specs/controllers/movies.spec.js<br/></strong></pre>
<p>The tests should pass.</p>
<p>Let's now move on to add the tests for the POST request for <kbd>movies.js</kbd>. In <kbd>movies.js</kbd>, here is what we have so far:</p>
<pre>var Movie = require("../models/Movie");<br/><br/>module.exports.controller = (app) =&gt; {<br/>  ...<br/><br/>  // add a new movie<br/>  app.post('/movies', (req, res) =&gt; {<br/>    const movie = new Movie({<br/>      name: req.body.name,<br/>      description: req.body.description,<br/>      release_year: req.body.release_year,<br/>      genre: req.body.genre<br/>    })<br/><br/>    movie.save(function (error, movie) {<br/>      if (error) { console.log(error); }<br/>      res.send(movie)<br/>    })<br/>  })<br/>}</pre>
<p>The POST method takes the preceding four attributes of the movie and saves them to the database. Let's add the test for this POST request. Replace the contents of <kbd>movies.spec.js</kbd> with the following code:</p>
<pre>const controller = require("./../../../../controllers/movies.js");<br/>const Movie = require("./../../../../models/Movie.js");<br/>let server = require('./../../../../server.js');<br/>let chai = require('chai');<br/>let sinon = require('sinon');<br/>const expect = chai.expect;<br/>let chaiHttp = require('chai-http');<br/>chai.use(chaiHttp);<br/>const should = chai.should();<br/><br/>describe('controllers.movies', function(){<br/>  it('exists', function(){<br/>    expect(controller).to.exist<br/>  })<br/><br/>  describe('/GET movies', () =&gt; {<br/>    it('it should send all movies', (done) =&gt; {<br/>      var movie1 = {<br/>        name: 'test1',<br/>        description: 'test1',<br/>        release_year: 2017,<br/>        genre: 'test1'<br/>      };<br/>      var movie2 = {<br/>        name: 'test2',<br/>        description: 'test2',<br/>        release_year: 2018,<br/>        genre: 'test2'<br/>      };<br/>      var expectedMovies = [movie1, movie2];<br/>      sinon.mock(Movie)<br/>        .expects('find')<br/>        .yields('', expectedMovies);<br/>      chai.request(server)<br/>        .get('/movies')<br/>        .end((err, res) =&gt; {<br/>          res.should.have.status(200);<br/>          res.body.should.be.an('object');<br/>          expect(res.body).to.eql({<br/>            movies: expectedMovies<br/>          });<br/>          done();<br/>      });<br/>    });<br/>  });<br/><br/>  <strong>describe('POST /movies', () =&gt; {</strong><br/><strong>    it('should respond with the movie that was added', (done) =&gt; {</strong><br/><strong>      chai.request(server)</strong><br/><strong>      .post('/movies')</strong><br/><strong>      .send({</strong><br/><strong>        name: 'test1',</strong><br/><strong>        description: 'test1',</strong><br/><strong>        release_year: 2018,</strong><br/><strong>        genre: 'test1'</strong><br/><strong>      })</strong><br/><strong>      .end((err, res) =&gt; {</strong><br/><strong>        should.not.exist(err);</strong><br/><strong>        res.status.should.equal(200);<br/>        res.body.should.be.an('object');</strong><br/><strong>        res.body.should.include.keys(</strong><br/><strong>          '_id', 'name', 'description', 'release_year', 'genre'</strong><br/><strong>        );</strong><br/><strong>        done();</strong><br/><strong>      });</strong><br/><strong>    });</strong><br/><strong>  });</strong><br/>})</pre>
<p>Here, in the preceding code block, what we have done is, for the POST request:</p>
<ul>
<li>We are sending <span>the POST request with movie parameters: <kbd>name</kbd>, <kbd>description</kbd>, <kbd>release_year</kbd>, and <kbd>genre</kbd></span></li>
<li>We had three expectations:
<ul>
<li>The status of the request should be <kbd>200</kbd></li>
<li>The request response should be an object</li>
<li>The response <span>should </span>contain<span> all four attributes, along with the ID of the movie<br/></span></li>
</ul>
</li>
</ul>
<p>Now if we run the tests again, they should all pass.</p>
<p>Similarly, we can add tests for other controllers as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing tests for models</h1>
                </header>
            
            <article>
                
<p>Let's move on to adding the tests for the models that we have defined. Let's create a folder called <kbd>models</kbd> inside <kbd>test/unit/specs</kbd> and create a test file for our <kbd>Movie.js</kbd><span> model. So,</span> the name of the spec file would be <kbd>Movie.spec.js</kbd>.</p>
<p>Let's first take a look at what we have in our <kbd>Movie.js</kbd>:</p>
<pre>const mongoose = require('mongoose');<br/>const Schema = mongoose.Schema<br/>const MovieSchema = new Schema({<br/>  name: String,<br/>   description: String,<br/>   release_year: Number,<br/>   genre: String<br/>})<br/><br/>const Movie = mongoose.model('Movie', MovieSchema)<br/>module.exports = Movie</pre>
<p>We just have a <kbd>Schema</kbd> defined here, which defines the data type for the <kbd>Movie</kbd> collection.</p>
<p>Let's add the specs for this model. Add the following contents to the <kbd>Movie.spec.js</kbd>:</p>
<pre><strong>var Movie = require("./../../../../models/Movie.js");</strong><br/><strong>let chai = require('chai');</strong><br/><strong>var expect = chai.expect;</strong><br/><strong>var should = chai.should();</strong></pre>
<p>We do not need all the components that we added to the controller test here. We just have simple assertion tests here, so we will need the <kbd>Movie</kbd> model and the <kbd>chai</kbd> methods.</p>
<p>Let's add the test for the <kbd>Movie</kbd> existence just like we did for the controller. Replace the contents in <kbd>Movie.spec.js</kbd> with the following code:</p>
<pre>var Movie = require("./../../../../models/Movie.js");<br/>let chai = require('chai');<br/>var expect = chai.expect;<br/>var should = chai.should();<br/><br/><strong>describe('models.Movie', function(){</strong><br/><strong>  it('exists', function(){</strong><br/><strong>    expect(Movie).to.exist</strong><br/><strong>  })</strong><br/><strong>})</strong></pre>
<p>This test checks whether the <kbd>Model</kbd> we are describing exists or not. Let's run the test using the following command:</p>
<pre><strong>$ mocha test/unit/specs/models/Movie.spec.js</strong></pre>
<p>The test should pass with the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4da3257a-1664-4b20-b273-9196fb3ba7eb.png" style="width:48.58em;height:13.50em;"/></div>
<p>Let's move on to add a test when we send the <kbd>release_year</kbd> attribute of the <kbd>Movie</kbd> a string. Since we have a validation for the <kbd>release_year</kbd> attribute, sending a string value to it should throw an error. </p>
<p>Replace the contents in <kbd>Movie.spec.js</kbd> with the following code:</p>
<pre>var Movie = require("./../../../../models/Movie.js");<br/>let chai = require('chai');<br/>var expect = chai.expect;<br/>var should = chai.should();<br/><br/>describe('models.Movie', function(){<br/>  it('exists', function(){<br/>    expect(Movie).to.exist<br/>  })<br/><br/>  <strong>describe('Movie', function() {</strong><br/><strong>    it('should be invalid if release_year is not an integer', <br/>    function(done){</strong><br/><strong>      var movie = new Movie({</strong><br/><strong>        name: 'test',</strong><br/><strong>        description: 'test',</strong><br/><strong>        release_year: 'test',</strong><br/><strong>        genre: 'test'</strong><br/><strong>      });</strong><br/><br/><strong>      movie.validate(function(err){</strong><br/><strong>        expect(err.errors.release_year).to.exist;</strong><br/><strong>        done();</strong><br/><strong>      })</strong><br/><strong>    })</strong><br/><strong>  })</strong><br/>})</pre>
<p>Here, we have prepared a movie object with <kbd>release_year</kbd> with an invalid value. The expectation we have here is that, when validating the model, it should send an error. </p>
<p>Let's run the test, and it should pass with the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4860ebca-061b-41d0-855f-a41f93c04a9e.png" style="width:53.08em;height:15.67em;"/></div>
<p>Similarly, we can add tests for other models as well.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing tests for Vue.js components</h1>
                </header>
            
            <article>
                
<p>Let's move on to write the test specs for our Vue.js components. We will start with the simplest component, which is the <kbd>Contact.vue</kbd> page.</p>
<p>This is what we have in our <kbd>Contact.vue</kbd> page so far:</p>
<pre>&lt;template&gt;<br/>  &lt;v-layout&gt;<br/>    this is contact<br/>  &lt;/v-layout&gt;<br/>&lt;/template&gt;</pre>
<p>Let's modify the component a little bit to make the tests more understandable. Replace the contents in <kbd>Contact.vue</kbd> with the following code:</p>
<pre><strong>&lt;template&gt;</strong><br/><strong>  &lt;div class="contact"&gt;</strong><br/><strong>    &lt;h1&gt;this is contact&lt;/h1&gt;</strong><br/><strong>  &lt;/div&gt;</strong><br/><strong>&lt;/template&gt;</strong></pre>
<p>Now, let's first create the necessary folder and file to write our tests. Create a file called <kbd>Contact.spec.js</kbd> inside the <kbd>test/unit/specs</kbd> directory and add the following contents to it:</p>
<pre><strong>import Vue from 'vue';</strong><br/><strong>import Contact from '@/components/Contact';</strong><br/><br/><strong>describe('Contact.vue', () =&gt; {</strong><br/><strong>  it('should render correct contents', () =&gt; {</strong><br/><strong>    const Constructor = Vue.extend(Contact);</strong><br/><strong>    const vm = new Constructor().$mount();</strong><br/><strong>    expect(vm.$el.querySelector('.contact h1').textContent)</strong><br/><strong>      .to.equal('this is contact');</strong><br/><strong>  });</strong><br/><strong>});</strong></pre>
<p>In the preceding code, we have added a test to check whether the <kbd>vue</kbd> component <kbd>Contact.vue</kbd> renders the correct contents or not. We expected to have a <kbd>div</kbd> element with the <kbd>contact</kbd> <span>class, </span>and inside it, there should be an <kbd>h1</kbd> tag, which should contain the <kbd>this is contact</kbd><span> content.</span></p>
<p>Now, to make sure that our tests run, let's verify that we have the correct script set up to run the unit test in <kbd>package.json</kbd>:</p>
<pre>...<br/>"scripts": {<br/>    "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",<br/>    "start": "nodemon server.js",<br/>    <strong>"unit": "cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run",</strong><br/>    "e2e": "node test/e2e/runner.js",<br/><strong>    "test": "npm run unit &amp;&amp; npm run e2e",</strong><br/>    "lint": "eslint --ext .js,.vue src test/unit test/e2e/specs",<br/>    "build": "node build/build.js",<br/>    "heroku-postbuild": "npm install --only=dev --no-shrinkwrap &amp;&amp; npm run build"<br/>  },<br/>...</pre>
<p>Now, let's run the test with the following command:</p>
<pre><strong>$ npm run unit</strong></pre>
<p>The test should pass with the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/78d15aee-07a0-4fb6-bea0-efe3af6bb819.png" style="width:43.58em;height:17.25em;"/></div>
<p>Let's move on to add specs for the component called <kbd>AddMovie.vue.</kbd> Create a file called <kbd>AddMovie.spec.js</kbd> inside <kbd>test/unit/specs</kbd> and add the following contents:</p>
<pre><strong>import Vue from 'vue';</strong><br/><strong>import AddMovie from '@/components/AddMovie';</strong><br/><br/><strong>describe('AddMovie', () =&gt; {</strong><br/><strong>  let cmp, vm;</strong><br/><br/><strong>  beforeEach(() =&gt; {</strong><br/><strong>    cmp = Vue.extend(AddMovie);</strong><br/><strong>    vm = new cmp({</strong><br/><strong>      data: {</strong><br/><strong>        years: ['2018', '2017', '2016', '2015']</strong><br/><strong>      }</strong><br/><strong>    }).$mount()</strong><br/><strong>  })</strong><br/><br/><strong>  it('equals years to ["2018", "2017", "2016", "2015"]', () =&gt; {</strong><br/><strong>    console.log(vm.years);</strong></pre>
<pre><strong>    expect(vm.years).to.eql(['2018', '2017', '2016', '2015'])</strong><br/><strong>  })</strong><br/><strong>})</strong></pre>
<p>This test states that the <kbd>years</kbd> variable should have the given values, which is <kbd>['2018', '2017', '2016', '2015']</kbd>.</p>
<p>Let's add another test to check whether the required methods exist in our <kbd>vue</kbd> component, <kbd>AddMovie.js</kbd>, or not. Replace the contents in <kbd>AddMovie.spec.js</kbd> with the following code:</p>
<pre>import Vue from 'vue';<br/>import AddMovie from '@/components/AddMovie';<br/><br/>describe('AddMovie', () =&gt; {<br/>  let cmp, vm;<br/><br/>  beforeEach(() =&gt; {<br/>    cmp = Vue.extend(AddMovie);<br/>    vm = new cmp({<br/>      data: {<br/>        years: ['2018', '2017', '2016', '2015']<br/>      }<br/>    }).$mount()<br/>  })<br/><br/>  it('equals years to ["2018", "2017", "2016", "2015"]', () =&gt; {<br/>    console.log(vm.years);<br/>    expect(vm.years).to.eql(['2018', '2017', '2016', '2015'])<br/>  })<br/><br/>  <strong>it('has a submit() method', () =&gt; {</strong><br/><strong>    assert.deepEqual(typeof vm.submit, 'function')</strong><br/><strong>  })</strong><br/><br/><strong>  it('has a clear() method', () =&gt; {</strong><br/><strong>    assert.deepEqual(typeof vm.clear, 'function')</strong><br/><strong>  })</strong><br/>})</pre>
<p>Now, let's run the tests with the following command:</p>
<pre><strong>$ npm run unit</strong></pre>
<p>The tests should pass.</p>
<p>Finally, to run all the tests, we can simply run the following command:</p>
<pre><strong>$ npm run test<br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing e2e testing</h1>
                </header>
            
            <article>
                
<p><span>The vue.js applications created with <kbd>vue-cli</kbd> command contains the support for end-to-end testing which uses </span><kbd>Nightwatch</kbd>. <kbd>Nightwatch</kbd> is a very easy framework to write end-to-end test. <kbd>Nightwatch</kbd> uses <kbd>Selenium</kbd> commands to run the JavaScript.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installing Nightwatch</h1>
                </header>
            
            <article>
                
<p>If you haven't set up the application for <kbd>e2e</kbd>, then let's first install the package needed to run the <kbd>e2e</kbd> tests:</p>
<pre><strong>$ npm install nightwatch --save</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring Nightwatch</h1>
                </header>
            
            <article>
                
<p>Now, we need a configuration file to run the test. Create a folder called <kbd>e2e</kbd> inside the <kbd>test</kbd> folder. Add the <kbd>nightwatch.conf.js</kbd> <span>file </span>and add the following contents to it:</p>
<pre><strong>require('babel-register')</strong><br/><strong>var config = require('../../config')</strong><br/><br/><strong>// http://nightwatchjs.org/gettingstarted#settings-file</strong><br/><strong>module.exports = {</strong><br/><strong>  src_folders: ['test/e2e/specs'],</strong><br/><strong>  custom_assertions_path: ['test/e2e/custom-assertions'],</strong><br/><br/><strong>  selenium: {</strong><br/><strong>    start_process: true,</strong><br/><strong>    server_path: require('selenium-server').path,</strong><br/><strong>    host: '127.0.0.1',</strong><br/><strong>    port: 4444,</strong><br/><strong>    cli_args: {</strong><br/><strong>      'webdriver.chrome.driver': require('chromedriver').path</strong><br/><strong>    }</strong><br/><strong>  },</strong><br/><br/><strong>  test_settings: {</strong><br/><strong>    default: {</strong><br/><strong>      selenium_port: 4444,</strong><br/><strong>      selenium_host: 'localhost',</strong><br/><strong>      silent: true,</strong><br/><strong>      globals: {</strong><br/><strong>        devServerURL: 'http://localhost:' + (process.env.PORT || config.dev.port)</strong><br/><strong>      }</strong><br/><strong>    },</strong><br/><br/><strong>    chrome: {</strong><br/><strong>      desiredCapabilities: {</strong><br/><strong>        browserName: 'chrome',</strong><br/><strong>        javascriptEnabled: true,</strong><br/><strong>        acceptSslCerts: true</strong><br/><strong>      }</strong><br/><strong>    },</strong><br/><br/><strong>    firefox: {</strong><br/><strong>      desiredCapabilities: {</strong><br/><strong>        browserName: 'firefox',</strong><br/><strong>        javascriptEnabled: true,</strong><br/><strong>        acceptSslCerts: true</strong><br/><strong>      }</strong><br/><strong>    }</strong><br/><strong>  }</strong><br/><strong>}</strong></pre>
<p>In the preceding code, in the setting inside the <kbd>test_settings</kbd><span> attribute,</span> we can see the different setups for different browsers. In this case, Chrome, Firefox, and the host and port settings for the development environment to run on the browser.</p>
<p>Also, in the preceding code, we have specified two folders: <kbd>specs</kbd> and <kbd>custom-assertions</kbd>.</p>
<ul>
<li>The <kbd>specs</kbd> folder contains the main test code for the application</li>
<li><kbd>custom-assertion</kbd> contains a script, which contains custom messages that get displayed when assertion tests are run on the command line</li>
</ul>
<p>Let's first set up our <kbd>custom-assertions</kbd>. Create a file called <kbd>elementCount.js</kbd> inside <kbd>custom-assertions</kbd> and add the following contents to it:</p>
<pre><strong>// A custom Nightwatch assertion.</strong><br/><strong>// The assertion name is the filename.</strong><br/><strong>// Example usage:</strong><br/><strong>//</strong><br/><strong>// browser.assert.elementCount(selector, count)</strong><br/><strong>//</strong><br/><strong>// For more information on custom assertions see:</strong><br/><strong>// http://nightwatchjs.org/guide#writing-custom-assertions</strong><br/><br/><strong>exports.assertion = function (selector, count) {</strong><br/><strong>  this.message = 'Testing if element &lt;' + selector + '&gt; has count: ' + count</strong><br/><strong>  this.expected = count</strong><br/><strong>  this.pass = function (val) {</strong><br/><strong>    return val === this.expected</strong><br/><strong>  }</strong><br/><strong>  this.value = function (res) {</strong><br/><strong>    return res.value</strong><br/><strong>  }</strong><br/><strong>  this.command = function (cb) {</strong><br/><strong>    var self = this</strong><br/><strong>    return this.api.execute(function (selector) {</strong><br/><strong>      return document.querySelectorAll(selector).length</strong><br/><strong>    }, [selector], function (res) {</strong><br/><strong>      cb.call(self, res)</strong><br/><strong>    })</strong><br/><strong>  }</strong><br/><strong>}</strong></pre>
<p>If you checked the <kbd>e2e</kbd> option when creating this application, you should also have the <span><kbd>test/e2e/specs/test.js</kbd> file. If not, go ahead and create this file and add the following contents into it:</span></p>
<pre><strong>// For authoring Nightwatch tests, see</strong><br/><strong>// http://nightwatchjs.org/guide#usage</strong><br/><br/><strong>module.exports = {</strong><br/><strong>  'default e2e tests': function test(browser) {</strong><br/><strong>    // automatically uses dev Server port from /config.index.js</strong><br/><strong>    // default: http://localhost:8080</strong><br/><strong>    // see nightwatch.conf.js</strong><br/><strong>    const devServer = browser.globals.devServerURL;</strong><br/><strong>    console.log(devServer);</strong><br/><br/><strong>    browser</strong><br/><strong>      .url(devServer)</strong><br/><strong>      .waitForElementVisible('#app', 5000)</strong><br/><strong>      .assert.elementPresent('.hello')</strong><br/><strong>      .assert.containsText('h1', 'Welcome to Your Vue.js App')</strong><br/><strong>      .assert.elementCount('img', 1)</strong></pre>
<pre><strong>      .end();</strong><br/><strong>  },</strong><br/><strong>};</strong></pre>
<p>This is the main file, where we will add our test cases for the application.</p>
<p>The end-to-end testing makes sure that all the the flow of our application is performing as expected or not. When we run the <kbd>e2e</kbd> test, we want certain parts of our application to be clicked and behave the way it should. This can be described as testing the behavior of the application.</p>
<p>To be able to run the <kbd>e2e</kbd> tests, we will need to start a <kbd>selenium-server</kbd>. If we take a look at the <kbd>test/e2e/nightwatch.conf.js</kbd><span> file,</span> we can find a line that says:</p>
<pre>...<br/>selenium: {<br/><strong>    start_process: true,</strong><br/>    server_path: require('selenium-server').path,<br/>    host: '127.0.0.1',<br/>    port: 4444,<br/>    cli_args: {<br/>      'webdriver.chrome.driver': require('chromedriver').path<br/>    }<br/>  },<br/>...</pre>
<p>This means that when we run the <kbd>e2e</kbd> test, a <kbd>selenium-server</kbd> is started automatically, and we don't have to run a separate server. The port defines which port to use for <kbd>selenium-server</kbd>. You can leave this as it is and run the test, or you can change the values and configure it yourself.</p>
<p>Finally, we need a <kbd>runner</kbd> file for <kbd>Nightwatch</kbd> to run the test. Create a file called <kbd>runner.js</kbd> inside the <kbd>e2e</kbd> folder and add the following contents:</p>
<pre><strong>// 1. start the dev server using production config</strong><br/><strong>process.env.NODE_ENV = 'testing'</strong><br/><br/><strong>const webpack = require('webpack')</strong><br/><strong>const DevServer = require('webpack-dev-server')</strong><br/><br/><strong>const webpackConfig = require('../../build/webpack.prod.conf')</strong><br/><strong>const devConfigPromise = require('../../build/webpack.dev.conf')</strong><br/><br/><strong>let server</strong><br/><br/><strong>devConfigPromise.then(devConfig =&gt; {</strong><br/><strong>  const devServerOptions = devConfig.devServer</strong><br/><strong>  const compiler = webpack(webpackConfig)</strong><br/><strong>  server = new DevServer(compiler, devServerOptions)</strong><br/><strong>  const port = devServerOptions.port</strong><br/><strong>  const host = devServerOptions.host</strong><br/><strong>  return server.listen(port, host)</strong><br/><strong>})</strong><br/><strong>.then(() =&gt; {</strong><br/><strong>  // 2. run the nightwatch test suite against it</strong><br/><strong>  // to run in additional browsers:</strong><br/><strong>  // 1. add an entry in test/e2e/nightwatch.conf.js under "test_settings"</strong><br/><strong>  // 2. add it to the --env flag below</strong><br/><strong>  // or override the environment flag, for example: `npm run e2e -- --env chrome,firefox`</strong><br/><strong>  // For more information on Nightwatch's config file, see</strong><br/><strong>  // http://nightwatchjs.org/guide#settings-file</strong><br/><strong>  let opts = process.argv.slice(2)</strong><br/><strong>  if (opts.indexOf('--config') === -1) {</strong><br/><strong>    opts = opts.concat(['--config', 'test/e2e/nightwatch.conf.js'])</strong><br/><strong>  }</strong><br/><strong>  if (opts.indexOf('--env') === -1) {</strong><br/><strong>    opts = opts.concat(['--env', 'chrome'])</strong><br/><strong>  }</strong><br/><br/><strong>  const spawn = require('cross-spawn')</strong><br/><strong>  const runner = spawn('./node_modules/.bin/nightwatch', opts, { stdio: 'inherit' })</strong><br/><br/><strong>  runner.on('exit', function (code) {</strong><br/><strong>    server.close()</strong><br/><strong>    process.exit(code)</strong><br/><strong>  })</strong><br/><br/><strong>  runner.on('error', function (err) {</strong><br/><strong>    server.close()</strong><br/><strong>    throw err</strong><br/><strong>  })</strong><br/><strong>})</strong></pre>
<p>We will use a stand-alone Selenium server and port <kbd>5555</kbd> for this application. For that, we will need to install the standalone server first:</p>
<pre><strong>$ npm install selenium-standalone</strong></pre>
<p>Let's run the package using the following command:</p>
<pre><strong>$ npx selenium-standalone start -- -port 5555</strong></pre>
<p>The <kbd>npx</kbd> is a command that runs the npm packages.<br/>
Since we are using the <kbd>5555</kbd> port, we will need to update it in the <kbd>nightwatch.conf.js</kbd> file as well.</p>
<p>Update the Selenium config in <kbd>nightwatch.conf.js</kbd> with the following code:</p>
<pre>...<br/>selenium: {<br/>    start_process: false,<br/>    server_path: require('selenium-server').path,<br/>    host: '127.0.0.1',<br/>    port: <strong>5555</strong>,<br/>    cli_args: {<br/>      'webdriver.chrome.driver': require('chromedriver').path<br/>    }<br/>  },<br/><br/>  test_settings: {<br/>    default: {<br/>      selenium_port: <strong>5555</strong>,<br/>      selenium_host: 'localhost',<br/>      silent: true,<br/>      globals: {<br/><strong>        devServerURL: 'http://localhost:8081'</strong><br/>      }<br/>    },<br/>...</pre>
<p>Since we are using the <kbd>8081</kbd> port to run the <kbd>node</kbd> server, make sure that you update the <kbd>devServerURL</kbd> <span>attribute </span>as well, as was done in the preceding piece of code.</p>
<p>Now, we are all set to run the tests with the following command:</p>
<pre><strong>$ npm run e2e</strong></pre>
<p>The test should fail with the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/61bec658-6b51-44f6-a8dc-a8dba79c76cb.png" style="width:47.67em;height:33.08em;"/></div>
<p>The tests are failing because we do not have the element present with the <kbd>.hello</kbd> <span>class </span>in our application. So, to make the tests pass, we first need to add an identifier to the elements, which we will be doing as a part the <kbd>e2e</kbd> tests by following the below steps. </p>
<p>Here are the things that we want to capture with the <kbd>e2e</kbd> test:</p>
<ol>
<li>Open the browser using <kbd>http://localhost:8081</kbd></li>
<li class="mce-root"><span>Check whether the element with the </span><kbd>#inspire</kbd><span> ID exists.</span> We <span>have defined that in</span> <kbd>App.vue</kbd> <span>with the following code:</span></li>
</ol>
<pre style="color: black;padding-left: 60px">&lt;template&gt;<br/>  <strong>&lt;v-app id="inspire"&gt;</strong><br/>    &lt;v-navigation-drawer<br/>      fixed<br/>      v-model="drawer"<br/>      app<br/>    &gt;</pre>
<ol start="3">
<li>Check that the sidebar consists of the <kbd>Home</kbd> and <kbd>Contact</kbd> page links</li>
<li>Click on the <kbd>Contact</kbd> page</li>
<li>The contact page should contain the text <kbd>this is contact</kbd> </li>
<li>Click on the login page to make sure that the login works fine</li>
<li>Add a movie to our application</li>
<li>Rate the movie</li>
<li>Finally, add the ability for users to log out of the application</li>
</ol>
<p>These are the important parts of our application. So, we will need to add an identifier to all of preceding components. <span>The best practice for adding an identifier to the elements is to define a <kbd>class</kbd> or an <kbd>id</kbd> while building the application itself</span>. However, we will assign an identifier to the now.</p>
<p>In <kbd>App.vue</kbd>, update the highlighted parts with the following code:</p>
<pre>&lt;template&gt;<br/>  &lt;v-app id="inspire"&gt;<br/>    &lt;v-navigation-drawer<br/>      fixed<br/>      v-model="drawer"<br/>      app<br/>    &gt;<br/>      &lt;v-list dense&gt;<br/>        &lt;router-link v-bind:to="{ name: 'Home' }" class="side_bar_link"&gt;<br/>          &lt;v-list-tile&gt;<br/>            &lt;v-list-tile-action&gt;<br/>              &lt;v-icon&gt;home&lt;/v-icon&gt;<br/>            &lt;/v-list-tile-action&gt;<br/>            &lt;v-list-tile-content id="home"&gt;Home&lt;/v-list-tile-content&gt;<br/>          &lt;/v-list-tile&gt;<br/>        &lt;/router-link&gt;<br/>        &lt;router-link v-bind:to="{ name: 'Contact' }" class="side_bar_link"&gt;<br/>          &lt;v-list-tile&gt;<br/>            &lt;v-list-tile-action&gt;<br/>              &lt;v-icon&gt;contact_mail&lt;/v-icon&gt;<br/>            &lt;/v-list-tile-action&gt;<br/>            &lt;v-list-tile-content id="contact"&gt;Contact&lt;/v-list-tile-content&gt;<br/>          &lt;/v-list-tile&gt;<br/>        &lt;/router-link&gt;<br/>      &lt;/v-list&gt;<br/>    &lt;/v-navigation-drawer&gt;<br/>    &lt;v-toolbar color="indigo" dark fixed app&gt;<br/>      &lt;v-toolbar-side-icon<strong> id="drawer"</strong> @click.stop="drawer = !drawer"&gt;&lt;/v-toolbar-side-icon&gt;<br/>      &lt;v-toolbar-title&gt;Home&lt;/v-toolbar-title&gt;<br/>      &lt;v-spacer&gt;&lt;/v-spacer&gt;<br/>      &lt;v-toolbar-items class="hidden-sm-and-down"&gt;<br/>        &lt;v-btn <strong>id="add_movie_link"</strong> flat v-bind:to="{ name: 'AddMovie' }"<br/>          v-if="current_user &amp;&amp; current_user.role === 'admin'"&gt;<br/>          Add Movie<br/>        &lt;/v-btn&gt;<br/>        &lt;v-btn<strong> id="user_email"</strong> flat v-if="current_user"&gt;{{ current_user.email }}&lt;/v-btn&gt;<br/>        &lt;v-btn flat v-bind:to="{ name: 'Register' }" v-if="!current_user" <strong>id="register_btn"</strong>&gt;<br/>          Register<br/>        &lt;/v-btn&gt;<br/>        &lt;v-btn flat v-bind:to="{ name: 'Login' }" v-if="!current_user" <strong>id="login_btn"</strong>&gt;Login&lt;/v-btn&gt;<br/>        &lt;v-btn<strong> id="logout_btn"</strong> flat v-if="current_user" @click="logout"&gt;Logout&lt;/v-btn&gt;<br/>      &lt;/v-toolbar-items&gt;<br/>    &lt;/v-toolbar&gt;<br/>    &lt;v-content&gt;<br/>      &lt;v-container fluid&gt;<br/>        &lt;div id="app"&gt;<br/>          &lt;router-view/&gt;<br/>        &lt;/div&gt;<br/>      &lt;/v-container&gt;<br/>    &lt;/v-content&gt;<br/>    &lt;v-footer color="indigo" app&gt;<br/>      &lt;span class="white--text"&gt;&amp;copy; 2017&lt;/span&gt;<br/>    &lt;/v-footer&gt;<br/>  &lt;/v-app&gt;<br/>&lt;/template&gt;<br/><br/>&lt;script&gt;<br/>import axios from 'axios';<br/><br/>import './assets/stylesheets/main.css';<br/>import bus from './bus';<br/><br/>export default {<br/>  name: 'app',<br/>  data: () =&gt; ({<br/>    drawer: null,<br/>    current_user: null,<br/>  }),<br/>  props: {<br/>    source: String,<br/>  },<br/>  mounted() {<br/>    this.fetchUser();<br/>    this.listenToEvents();<br/>  },<br/>  methods: {<br/>    listenToEvents() {<br/>      bus.$on('refreshUser', () =&gt; {<br/>        this.fetchUser();<br/>      });<br/>    },<br/>    async fetchUser() {<br/>      return axios({<br/>        method: 'get',<br/>        url: '/api/current_user',<br/>      })<br/>        .then((response) =&gt; {<br/>          this.current_user = response.data.current_user;<br/>        })<br/>        .catch(() =&gt; {<br/>        });<br/>    },<br/>    logout() {<br/>      return axios({<br/>        method: 'get',<br/>        url: '/api/logout',<br/>      })<br/>        .then(() =&gt; {<br/>          <strong>bus.$emit('refreshUser');</strong><br/><strong>          this.$router.push({ name: 'Home' });</strong><br/>        })<br/>        .catch(() =&gt; {<br/>        });<br/>    },<br/>  },<br/>};<br/>&lt;/script&gt;<br/><a href="https://github.com/anaida07/movie_rating_app/pull/2/files#diff-ea994a51b0d9884f4fc046eca11a5c99"/></pre>
<p>Also, let's update the <kbd>id</kbd> in <kbd>AddMovie.vue</kbd>:</p>
<pre>&lt;template&gt;<br/>  &lt;v-form v-model="valid" ref="form" lazy-validation&gt;<br/>    &lt;v-text-field<br/>      label="Movie Name"<br/>      v-model="name"<br/>      :rules="nameRules"<br/>      <strong>id="name"</strong><br/>      required<br/>    &gt;&lt;/v-text-field&gt;<br/>    &lt;v-text-field<br/>      name="input-7-1"<br/>      label="Movie Description"<br/>      v-model="description"<br/>      <strong>id="description"</strong><br/>      multi-line<br/>    &gt;&lt;/v-text-field&gt;<br/>    &lt;v-select<br/>      label="Movie Release Year"<br/>      v-model="release_year"<br/>      required<br/>      :rules="releaseRules"<br/>      :items="years"<br/>      <strong>id="release_year"</strong><br/>    &gt;&lt;/v-select&gt;<br/>    &lt;v-text-field<br/>      label="Movie Genre"<br/>      v-model="genre"<br/>      <strong>id="genre"</strong><br/>      required<br/>      :rules="genreRules"<br/>    &gt;&lt;/v-text-field&gt;<br/>    &lt;v-btn<br/>      @click="submit"<br/>      :disabled="!valid"<br/>      <strong>id="add_movie_btn"</strong><br/>    &gt;<br/>      submit<br/>    &lt;/v-btn&gt;<br/>    &lt;v-btn @click="clear"&gt;clear&lt;/v-btn&gt;<br/>  &lt;/v-form&gt;<br/>&lt;/template&gt;<a href="https://github.com/anaida07/movie_rating_app/pull/2/files#diff-2e267bf38ed287649a94b59f286a7b39"/></pre>
<p>Also, in <kbd>Login.vue</kbd>, let's add corresponding <kbd>id</kbd> for the form fields:</p>
<pre>&lt;template&gt;<br/>  &lt;div&gt;<br/>    &lt;div class="login"&gt;<br/>      &lt;a href="/login/facebook"&gt;Facebook&lt;/a&gt;<br/>      &lt;a href="/login/twitter"&gt;Twitter&lt;/a&gt;<br/>      &lt;a href="/login/google"&gt;Google&lt;/a&gt;<br/>      &lt;a href="/login/linkedin"&gt;Linkedin&lt;/a&gt;<br/>    &lt;/div&gt;<br/>    &lt;v-form v-model="valid" ref="form" lazy-validation&gt;<br/>      &lt;v-text-field<br/>        label="Email"<br/>        v-model="email"<br/>        :rules="emailRules"<br/>        <strong>id="email"</strong><br/>        required<br/>      &gt;&lt;/v-text-field&gt;<br/>      &lt;v-text-field<br/>        label="Password"<br/>        v-model="password"<br/>        :rules="passwordRules"<br/>        <strong>id="password"</strong><br/>        required<br/>      &gt;&lt;/v-text-field&gt;<br/>      &lt;v-btn<br/>        @click="submit"<br/>        :disabled="!valid"<br/>        <strong>id="login"</strong><br/>      &gt;<br/>        submit<br/>      &lt;/v-btn&gt;<br/>      &lt;v-btn @click="clear"<strong> id="clear_input"</strong>&gt;clear&lt;/v-btn&gt;&lt;br/&gt;<br/>    &lt;/v-form&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</pre>
<p>In <kbd>Movie.vue</kbd>, update the <kbd>id</kbd> for <kbd>Rate this Movie</kbd> with:</p>
<pre>&lt;template&gt;<br/>  &lt;v-layout row wrap&gt;<br/>    &lt;v-flex xs4&gt;<br/>      &lt;v-card&gt;<br/>        &lt;v-card-title primary-title&gt;<br/>          &lt;div&gt;<br/>            &lt;div class="headline"&gt;{{ movie.name }}&lt;/div&gt;<br/>            &lt;span class="grey--text"&gt;{{ movie.release_year }} ‧ {{ movie.genre }}&lt;/span&gt;<br/>          &lt;/div&gt;<br/>        &lt;/v-card-title&gt;<br/>        &lt;h6 class="card-title"<strong> id="rate_movie"</strong> v-if="current_user" @click="rate"&gt;<br/>          Rate this movie<br/>        &lt;/h6&gt;<br/>        &lt;v-card-text&gt;<br/>          {{ movie.description }}<br/>        &lt;/v-card-text&gt;<br/>      &lt;/v-card&gt;<br/>    &lt;/v-flex&gt;<br/>  &lt;/v-layout&gt;<br/>&lt;/template&gt;</pre>
<p>We have added the necessary identifier to all of the components. Now, let's add the <kbd>e2e</kbd> tests for the previously mentioned scenarios.</p>
<p>Replace the contents of <kbd>test/e2e/specs/test.js</kbd> with the following code:</p>
<pre>// For authoring Nightwatch tests, see<br/>// http://nightwatchjs.org/guide#usage<br/><br/>module.exports = {<br/>  'default e2e tests': function test(browser) {<br/>    // automatically uses dev Server port from /config.index.js<br/>    // default: http://localhost:8080<br/>    // see nightwatch.conf.js<br/>    const devServer = browser.globals.devServerURL;<br/>    console.log(devServer)<br/><br/>    <strong>browser</strong><br/><strong>      .url(devServer)</strong><br/><strong>      .waitForElementVisible('#inspire', 9000)</strong><br/><strong>      .assert.elementPresent('.list')</strong><br/><strong>      .assert.elementPresent('.list .side_bar_link')</strong><br/><strong>      .assert.elementPresent('.side_bar_link #home')</strong><br/><strong>      .assert.elementPresent('.side_bar_link #contact')</strong><br/><strong>      .click('#drawer')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('#contact')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .assert.elementPresent('#inspire .contact')</strong><br/><strong>      .assert.containsText('#inspire .contact h1', 'this is contact')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('#login_btn')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .assert.elementCount('input', 2)</strong><br/><strong>      .setValue('input#email', 'get.aneeta@gmail.com')</strong><br/><strong>      .setValue('input#password', 'secret')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('#login')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('.swal-button--confirm')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .assert.containsText('#user_email', 'GET.ANEETA@GMAIL.COM')</strong><br/><strong>      .click('#add_movie_link')</strong><br/><strong>      .pause(2000)</strong><br/><strong>      .assert.elementCount('input', 3)</strong><br/><strong>      .assert.elementCount('textarea', 1)</strong><br/><strong>      .setValue('input#name', 'Avengers: Infinity War')</strong><br/><strong>      .setValue('textarea#description', 'Iron Man, Thor, the Hulk and the rest of the Avengers unite <br/>      to battle their most powerful enemy yet -- the evil Thanos. On a mission to collect all six <br/>      Infinity Stones, Thanos plans to use the artifacts to inflict his twisted will on reality.')</strong><br/><strong>      .click('.input-group__selections')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('.list a ')</strong><br/><strong>      .setValue('input#genre', 'Fantasy/Science fiction film')</strong><br/><strong>      .click('#add_movie_btn')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('.swal-button--confirm')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('.headline:nth-child(1)')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .assert.containsText('#rate_movie', 'Rate this movie')</strong><br/><strong>      .click('#rate_movie')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('.vue-star-rating span:nth-child(3)')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('.swal-button--confirm')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('.swal-button--confirm')</strong><br/><strong>      .pause(1000)</strong><br/><strong>      .click('#logout_btn')</strong><br/><strong>      .end();</strong><br/>  },<br/>};</pre>
<p>To run the <kbd>e2e</kbd> script, make sure that we have set up the correct command in <kbd>package.json</kbd>:</p>
<pre>...<br/>"scripts": {<br/>    "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",<br/>    "start": "nodemon server.js",<br/>    "unit": "cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run",<br/>    <strong>"e2e": "node test/e2e/runner.js",</strong><br/>    "test": "npm run unit &amp;&amp; npm run e2e",<br/>    "lint": "eslint --ext .js,.vue src test/unit test/e2e/specs",<br/>    "build": "node build/build.js",<br/>    "heroku-postbuild": "npm install --only=dev --no-shrinkwrap &amp;&amp; npm run build"<br/>  },<br/>...</pre>
<p>After adding the <kbd>e2e</kbd> script, we should be able to run the test with the following command:</p>
<pre><strong>$ npm run e2e<br/></strong></pre>
<p>Now, all the tests should pass, and the output should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/4288c176-6724-4551-ae71-395d9b03501b.png" style="width:40.92em;height:28.33em;"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned how to write unit tests and we discussed the different technologies you can use to write them, such as <kbd>chai</kbd>, <kbd>mocha</kbd>, and <kbd>sinon</kbd>. You also learned to write tests for controllers, models, and Vue component.</p>
<p>In the next chapter, you will learn about continuous integration and how to deploy your apps to Heroku using GitHub.</p>


            </article>

            
        </section>
    </body></html>