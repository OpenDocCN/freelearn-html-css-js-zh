<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Putting Alternative Values in Types</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we saw how to build values that capture multiple types of values together, and the different ways that we can build those types. This lets us say that we have a value of the composite (product) type only if we have <em>all</em> of the values of their composed types. Sometimes though, we need values that must be <em>only one</em> type out of several types.</p>
<p>In this chapter, we will cover these <em>only one</em> types, namely:</p>
<ul>
<li>Variant types</li>
<li>Polymorphic variant types</li>
<li>Generalized algebraic data types</li>
</ul>
<p>Collectively, these types are known as <em>sum types</em> because the number of possible values that a sum type can contain is the <em>sum</em> of the number of possible values of each of its component types. We'll see how this is true in this chapter!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Variant types</h1>
                </header>
            
            <article>
                
<p>Variant types are Reason's simple, idiomatic sum types. You can think of them as similar to enums (a limited set of values that are declared to form a type) from other languages, only more powerful because each <em>variant case</em> (possible alternative value) can optionally carry a payload inside it. Here's an example:</p>
<pre>/* src/Ch05/Ch05_Variants.re */<br/><span class="underline">type</span> <strong>education</strong> = <em>School</em> | <em>College</em> | <em>Postgrad</em> | <em>Other</em>; /* (1) */<br/><br/><span class="underline">type</span> <strong>poNumber</strong> = <strong>string</strong>;<br/><span class="underline">type</span> <strong>paymentMethod</strong> = <em>Cash</em> | <em>PurchaseOrder</em>(<strong>poNumber</strong>); /* (2) */<br/><br/><span class="underline">let</span> <em>bobEducation</em> = <em>College</em>; /* (3) */<br/><span class="underline">let</span> <em>bobPaymentMethod</em> = <em>Cash</em>;<br/><span class="underline">let</span> <em>jimEducation</em> = <em>Other</em>;<br/><span class="underline">let</span> <em>jimPaymentMethod</em> = <em>PurchaseOrder</em>("PO-1234"); /* (4) */</pre>
<p>This module defines some types for storing someone's education level and a payment method of either cash or purchase order:</p>
<ol>
<li>Variant type definitions start with <kbd>type typeName =</kbd> just like any other type of definition, and have one or more <em>variant constructors</em> (also known as <em>data constructors</em>) on the right-hand side of the equals sign. These constructors all have the exact same type and can be used as literal values.</li>
<li>Variant constructors must start with an uppercase letter and can each carry any number of payloads, as defined within parentheses. This can be a comma-separated list of types that will make up the payload. Here we defined the <kbd>poNumber</kbd> type instead of just using <kbd>string</kbd> directly, to make the code more self-documenting.</li>
<li>We can use variant cases directly as literal values. Now, <kbd>bobEducation</kbd> has the type <kbd>education</kbd>.</li>
<li>For variant constructors that carry payloads, we can pass them in as a comma-separated list between parentheses, a syntax that mirrors their definition.</li>
</ol>
<p>The first variant type, <kbd>education</kbd>, is a simple one that we can find in a lot of languages. It just defines an allowed set of values for a person's education. Of course, this may not be realistic in all scenarios, but sometimes we just need types to be realistic enough to model our problem.</p>
<p>The next variant type, <kbd>paymentMethod</kbd>, is the really interesting one. It's saying that valid payment methods are cash or a purchase order with a PO number. Note that for cash we don't need any extra info, but for a purchase order we require its number; it's impossible to describe a PO with a corresponding number.</p>
<p>Let's think about this for a second. To represent a payment method in other languages, you might do something like the following:</p>
<pre>// JavaScript<br/><span class="underline">const</span> <em>bobPaymentMethod</em> = {<em>type</em>: 'PaymentMethod.Cash'};<br/><span class="underline">const</span> <em>jimPaymentMethod</em> = <br/>{<br/>  <em>type</em>: 'PaymentMethod.PurchaseOrder',<br/>  <em>poNumber</em>: 'PO-1234'<br/>};</pre>
<p>Notice the problem? Nothing's stopping us from creating objects with <kbd>type: 'PaymentMethod.Cash'</kbd> and a <kbd>poNumber</kbd> property, or even worse, <kbd>type: 'PaymentMethod.PurchaseOrder'</kbd> and no <kbd>poNumber</kbd> property. We'd have no static guarantees that purchase orders would always have an associated ID. Variant types give us this static guarantee.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pattern matching</h1>
                </header>
            
            <article>
                
<p>We can construct variant values easily enough—just type in the variant constructors and give them any data they need. But variants really shine when we work with their values.</p>
<p>For example, suppose you want to write a function that returns a thank you message for any given payment. Part of the message will hinge on the payment method:</p>
<pre>/* src/Ch05/Ch05_PatternMatching.re */<br/><span class="underline">type</span> <strong>paymentMethod</strong> = <em>Ch05_Variants</em>.<strong>paymentMethod</strong> = /* (1) */<br/>| <em>Cash</em><br/>| <em>PurchaseOrder</em>(<em>Ch05_Variants</em>.<strong>poNumber</strong>);<br/><br/><span class="underline">let</span> <em>paymentMethodThanks</em>(<em>paymentMethod</em>) = <span class="underline">switch</span> (<em>paymentMethod</em>) { /* (2) */<br/>| <em>Cash</em> =&gt; "Thank you for your cash payment"<br/>| <em>PurchaseOrder</em>(<em>poNumber</em>) =&gt;<br/>  "Thank you for your purchase order # " ++ <em>poNumber</em><br/>};</pre>
<p>We will introduce some new syntax here:</p>
<ol>
<li>We use a <strong>type equation</strong> to tell the compiler that this variant type defined in this module is the same as the other variant type defined in <kbd>Ch05_Variants</kbd>, and crucially that its constructors are also exactly the same.</li>
<li>We <strong>pattern match</strong> on the given payment method using Reason's <kbd>switch</kbd> expression, which can <strong>destructure</strong> data that can match against patterns.</li>
</ol>
<p>We could have simply redefined the variant type in both modules; but variant types in Reason are nominal (that is, even the same variant type definition is considered a distinct type if it's in a different module) unless we use a type equation. In this simple example it's not critical that the compiler equates the two types, but sometimes in a Reason codebase, you'll want to <em>bring in</em> the variant constructors from another module for ease of access. Otherwise, you'll need to either open the other module (risky) or prefix the constructors with the modules (verbose), for example, <kbd>Ch05_Variants.Cash</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The power of switch</h1>
                </header>
            
            <article>
                
<p>In the previous section, we saw how to use the <kbd>switch</kbd> expression. But that barely scratched the surface of what <kbd>switch</kbd> can do. Switch expressions match against arbitrary patterns and evaluate the branch that corresponds to the <em>first</em> matching pattern.</p>
<p>Here's a slightly more formal syntax for a switch expression:</p>
<pre><span class="underline">switch</span> (<em>expr</em>) {<br/>| <em>pat1</em> =&gt; <em>res1</em><br/>| <em>pat2</em> =&gt; <em>res2</em><br/>...<br/>| <em>patN</em> =&gt; <em>resN</em><br/>}</pre>
<p>This entire syntactic form evaluates to a single value. Each subsection of the expression that starts with a bar character (<kbd>|</kbd>) is called a <strong>branch</strong>.</p>
<p>The steps for evaluating the expression are as follows:</p>
<ol>
<li>Evaluate <kbd>expr</kbd>.</li>
<li>Match the  value of <kbd>expr</kbd> against <kbd>pat1</kbd>; if it matches, evaluate the entire expression to <kbd>res1</kbd> and ignore all the other branches.</li>
<li>Otherwise, continue matching the value against each pattern in turn, and evaluate to the first result that corresponds to the matching pattern.</li>
<li>If none of the patterns match, throw a runtime error (called an exception), <kbd>Match_failure</kbd>.</li>
</ol>
<p>Each branch of the expression must have the same return type for it to compile. Note that the order of the branches may or may not be important, depending on what kind of patterns we're matching. If we're matching against a variant type's exact cases, order is not important because variant cases naturally don't have any concept of <em>ordering</em>. That is, even if we defined <kbd>Cash</kbd> before <kbd>PurchaseOrder</kbd> in the <kbd>paymentMethod</kbd> type definition, that doesn't mean that <kbd>Cash</kbd> is intrinsically <em>less</em> than <kbd>PurchaseOrder</kbd>. There is no precedence.</p>
<p>However, patterns don't have to be variant cases. They can be any valid combination of names and literal values. In this context, a name is anything that is a valid Reason identifier, such as <kbd>age</kbd> or <kbd>_123</kbd>. Literal values include variant cases, but also values of basic types such as <kbd>char</kbd>, <kbd>string</kbd>, <kbd>int</kbd>, <kbd>float</kbd>, and so on; and also tuples and record values. If a pattern matches against the input expression, any names it contains get <em>bound</em> to the relevant parts of the expression and are made available in the scope of the result expression on the right-hand side of the <kbd>=&gt;</kbd>.</p>
<p>With name binding, literal values, and ordering, patterns can get quite sophisticated; let's see a few examples:</p>
<pre>/* src/Ch05/Ch05_PatternMatchOrder.re */<br/><span class="underline">type</span> <strong>person</strong> = <em>Ch04_RecordLiterals</em>.<strong>person</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>};<br/><br/><span class="underline">let</span> <em>classifyId</em>(<em>id</em>) = <span class="underline">switch</span> (<em>id</em>) {<br/>| 1 | 2 | 3 | 4 | 5 =&gt; "Low" /* (1) */<br/>| 6 | 7 | 8 | 9 | 10 =&gt; "Medium"<br/>| _ =&gt; "High"<br/>};<br/><br/><span class="underline">let</span> <em>greet1</em>(<em>person</em>) = <span class="underline">switch</span> (<em>person.id</em>, <em>person.name</em>) { /* (2) */<br/>| (_, "Dave") =&gt; "I'm sorry, Dave, I can't let you do that."<br/>| (1, _) =&gt; "Hello, boss."<br/>| (<em>id</em>, <em>name</em>) =&gt; "Hi, " ++ <em>name</em> ++ " with ID " ++ <em>string_of_int</em>(<em>id</em>) ++ "!"<br/>};<br/><br/><span class="underline">let</span> <em>greet2</em>(<em>person</em>) = <span class="underline">switch</span> (<em>person</em>) {<br/>| {<em>name</em>: "Dave"} =&gt; "I'm sorry, Dave, I can't let you do that." /* (3) */<br/>| {<em>id</em>: 1} =&gt; "Hello, boss."<br/>| {<em>id</em>, <em>name</em>} =&gt; "Hi, " ++ <em>name</em> ++ " with ID " ++ <em>string_of_int</em>(<em>id</em>) ++ "!"<br/>};</pre>
<p>There are a few interesting things here:</p>
<ol>
<li>We're switching on an <kbd>int</kbd> ID, listing multiple alternative patterns on a single line, separated by bars. Patterns are in fact recursively defined; this means that patterns can contain more patterns! In other words, we can combine several individual patterns, such as <kbd>1</kbd>, <kbd>2</kbd>, and so on, with the vertical bar to indicate that any of these should match. This is called an <strong>or pattern</strong>. Note that the ordering of the patterns means that at runtime, the input ID will first be checked against the numbers 1 to 5, and only then with the other patterns. In this pattern match, the underscore symbol (<kbd>_</kbd>) means <em>anything, I don't care and don't bind the value</em>.</li>
<li>Given a <kbd>person</kbd> value, we switch on its name and ID. We're actually switching on a single expression; the expression <kbd>(person.id, person.name)</kbd> is a tuple that we create on the spot and match against immediately. The really interesting thing here is the ordering of the patterns. We're expressing the logic that we always show a special message for Dave, and if it's not Dave and if it's someone with ID 1, we greet them as the boss, and only if it's not Dave or the boss, we greet the person by name and ID.</li>
</ol>
<ol start="3">
<li>In <kbd>greet2</kbd>, we switch on the <kbd>person</kbd> directly using record literal patterns and express the same ordered logic as before, only this time we don't need to construct a temporary tuple since we know we can pattern match directly against records. There's not necessarily a performance benefit to this, but you may find the code slightly neater–it's subjective.</li>
</ol>
<p>Pattern matching can handle quite sophisticated data structures, because of the special property of patterns that they are <em>composable.</em> However, with this great power come two warnings: first, we need to understand the order in which we list the branches of our switch expressions so that we don't get unexpected results; second, we need to avoid potential runtime errors arising from the use of refutable patterns.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Refutable patterns</h1>
                </header>
            
            <article>
                
<p>It's important to understand that the <kbd>switch</kbd> expression is one form of pattern matching in Reason, out of three:</p>
<ul>
<li>Switch expression</li>
<li>Let binding (see <a href="ff0971a6-9cf3-4680-8010-47acb7663764.xhtml">Chapter 2</a>, <em>Program with Types and Values</em>)</li>
<li>Function arguments (we'll cover functions in a future chapter)</li>
</ul>
<p>With all three forms of pattern matching, we run the risk of runtime errors if we use refutable patterns incorrectly. <em>Refutable patterns</em> are patterns that type-check, but could <em>potentially</em> fail at runtime. Here are a couple of simple examples:</p>
<pre><span class="underline">let</span> 3 = 3;<br/><span class="underline">let</span> <em>getPoNumber</em>(<em>paymentMethod</em>) = <br/>{<br/>  <span class="underline">let</span> <em>PurchaseOrder</em>(<em>poNumber</em>) = <em>paymentMethod</em>;<br/>  <em>poNumber</em><br/>};</pre>
<div class="packt_infobox">Surprised by <kbd>let 3 = 3</kbd>? Remember that the left-hand side of the equals sign can be any pattern–even a single literal value! Also, let <kbd>PurchaseOrder(poNumber) = ...</kbd> is a destructuring of a variant case, not a function definition. The difference is the case of the first letter, <kbd>P</kbd>. Remember that Reason modules and data constructors start with an uppercase letter, while types and values start with a lowercase letter.</div>
<p>If you try the first binding, you'll see the following warning:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  Warning number 8<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch05/Ch05_PatternMatchOrder.re 22:5<br/>  <br/>  20 │ };<br/>  21 │ <br/>  22 │ let 3 = 3;<br/>  <br/>  You forgot to handle a possible value here, for example: <br/>0</pre>
<p class="mce-root">It's not really obvious what the problem is: the value being bound is literally 3, it could never be 0, so how could we forget to handle it? The thing to realize is that the compiler looks only at the types–it sees that we used a refutable pattern of type <kbd>int</kbd>, and warns us about the simplest <kbd>int</kbd> that it knows we didn't handle: <kbd>0</kbd>.</p>
<p>If you try the second:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  Warning number 8<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch05/Ch05_VariantPatternMatching.re 13:7-29<br/>  <br/>  11 │ <br/>  12 │ let getPoNumber(paymentMethod) = {<br/>  13 │   let PurchaseOrder(poNumber) = paymentMethod;<br/>  14 │   poNumber<br/>  15 │ };<br/>  <br/>  You forgot to handle a possible value here, for example: <br/>Cash</pre>
<p class="mce-root">This time, it's quite obvious: at runtime, the <kbd>getPoNumber</kbd> function could get called with the <kbd>Cash</kbd> value (because that type-checks!) but it doesn't know how to handle it. There's nothing it can do but throw a runtime error. The compiler figures this out in the same way as before, by looking at the <kbd>paymentMethod</kbd> type and looking for values of the type that it knows weren't handled.</p>
<p>This feature that checks if we handled all possible patterns of any given type is called <strong>exhaustivity checking</strong> and is one of the most powerful and useful features of Reason's type system. It's also present in a few languages that are either derived from the same ML (Meta Language) heritage as Reason or took inspiration from it. No matter what language, if you have exhaustivity checking at your disposal, try to use it as much as possible because it's a great safety net.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The when clause and general branching</h1>
                </header>
            
            <article>
                
<p>Not only do switch expressions pattern match on their inputs, but they can also add a general test condition called a <kbd>when</kbd> <strong>clause</strong> to the end of each pattern. This lets you check completely general conditions in each branch to match against that branch. Note that using a <kbd>when</kbd> clause does give up exhaustivity checking, though, so before reaching for it, think about if you can do without. Sometimes, you just can't. For example:</p>
<pre>/* src/Ch05/Ch05_Branching.re */<br/><span class="underline">type</span> <strong>education</strong> = <em>Ch05_Variants</em>.<strong>education</strong> = /* (1) */<br/>| <em>School</em><br/>| <em>College</em><br/>| <em>Postgrad</em><br/>| <em>Other</em>;<br/><br/><span class="underline">type</span> <strong>paymentMethod</strong> = <em>Ch05_Variants</em>.<strong>paymentMethod</strong> =<br/>| <em>Cash</em><br/>| <em>PurchaseOrder</em>(<em>Ch05_Variants</em>.<strong>poNumber</strong>);<br/><br/>/** Returns purchase order IDs that start with 'ACME', otherwise<br/>    nothing. */<br/><span class="underline">let</span> <em>getAcmeOrder</em>(<em>paymentMethod</em>) = <span class="underline">switch</span> (<em>paymentMethod</em>) {<br/>| <em>PurchaseOrder</em>(<em>poNumber</em>)<br/>  /* (2),                                      (3) */<br/>  <span class="underline">when</span> <em>String.sub</em>(<em>poNumber</em>, 0, 4) == "ACME" =&gt; <em>Some</em>(<em>poNumber</em>)<br/>| _ =&gt; <em>None</em> /* (4) */<br/>};<br/><br/><span class="underline">let</span> <em>decidePaymentMethod</em>(<em>orderTotal</em>, <em>orderId</em>) =<br/> <span class="underline">if</span> (<em>orderTotal</em> &lt;= 50.0) <em>Cash</em> /* (5) */<br/> <span class="underline">else</span> <em>PurchaseOrder</em>("PO-" ++ <em>orderId</em>);</pre>
<p>This code sample shows a scenario for using a <kbd>when</kbd> clause:</p>
<ol>
<li>We redefine the types we need and equate them for interoperability. Strictly speaking, in this case, we didn't need to do that. But in most real-world code, you would.</li>
<li>We add a <kbd>when</kbd> clause to the <kbd>PurchaseOrder(poNumber)</kbd> base pattern to check that the PO number starts with the word ACME. This is something we can't do with pattern matching because we can't match against parts of strings.</li>
<li>We also evaluate the branch to a <kbd>Some(poNumber)</kbd>. <kbd>Some</kbd> is a built-in data constructor that expresses the idea that <em>there is a value here (as opposed to no value)</em>. It actually accepts <em>any</em> type, not just a <kbd>string</kbd>, and we'll see how that works in the next chapter.</li>
</ol>
<ol start="4">
<li>The case where the PO number doesn't start with the word ACME evaluates to <kbd>None</kbd>, which is the same type as <kbd>Some(whatever)</kbd>, but it expresses the idea that <em>there's no value here</em>. The type of <kbd>Some(whatever)</kbd> and <kbd>None</kbd> is a variant type <kbd>option(whateverType)</kbd>, and it's very useful for safely passing around values that might not logically exist. In this case, it's useful for our function <kbd>getAcmeOrder</kbd> because, given any payment method at runtime, it might not actually contain an ACME purchase order, so we need a way to say <em>it's not an ACME PO</em>, and <kbd>None</kbd> gives us that.</li>
<li>Reason also has a traditional <kbd>if</kbd>-<kbd>else</kbd> syntax, which is also an expression and evaluates to a value. Both the <kbd>if</kbd> and <kbd>else</kbd> branches must evaluate to values of the same type; if we leave out the <kbd>else</kbd> branch, it's assumed to evaluate to <kbd>()</kbd> of type <kbd>unit</kbd>. In Reason, <kbd>()</kbd>—pronounced <em>unit</em>—roughly means the same thing that <kbd>void</kbd> means in C, C++, and so on, except that it's an actual assignable value and it can come in handy sometimes. In the case of <kbd>if</kbd> expressions, concretely this means that we should either include an <kbd>else</kbd> clause or ensure that the <kbd>if</kbd> clause evaluates to type <kbd>unit</kbd>. Typically, this happens with functions that carry out an action and don't evaluate to a useful value, for example, <kbd>Js.log("Hello")</kbd>.</li>
</ol>
<div class="packt_infobox">So far in this book, we've seen a couple of types that look like <kbd>typeName(typeParam)</kbd>, but we haven't delved into what they are or how they work. In the next chapter, we'll learn about parameterized types and how they can help write safe, reusable code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stricter safety checks</h1>
                </header>
            
            <article>
                
<p>It's worth digressing a bit to the compiler's exhaustivity check warning. As you'll recall, it looks as follows:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  Warning number 8<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch05/Ch05_Branching.re 25:5<br/>  <br/>  23 │   else PurchaseOrder("PO-" ++ orderId);<br/>  24 │ <br/>  25 │ let 3 = 3;<br/>  <br/>  You forgot to handle a possible value here, for example: <br/>0</pre>
<p>The problem with a compile warning is that it doesn't fail the compile. We can end up with code running in production that type-checked, but is not actually type-safe, because it forgot to handle some corner case. It would really be ideal if we could tell the compiler to fail the compile if it finds any non-exhaustive patterns, so we can rule out shipping them to production.</p>
<p>Fortunately, we can tell the compiler to <em>promote</em> a warning to an error. In our case, since we're using a BuckleScript project, we can edit the <kbd>bsconfig.json</kbd> file slightly:</p>
<pre>// bsconfig.json<br/>{<br/>  // ... rest of the file ...<br/>  "warnings": <br/>  {<br/>    "error": "+8"<br/>  }<br/>}</pre>
<p>After editing the file, we can restart <kbd>bsb -w</kbd> to have the new setting take effect. The <kbd>"warnings"</kbd> property contains an object with potentially a couple of properties, one of which is an <kbd>"error"</kbd> property that has a corresponding string value listing the warning numbers that we want to promote into errors with the <kbd>"+NUM"</kbd> syntax. We can get the exact number from the compiler warning message (see preceding snippet).</p>
<p>Now, this same warning will fail the compile:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  Warning number 8<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch05/Ch05_Branching.re 25:5<br/>  <br/>  23 │   else PurchaseOrder("PO-" ++ orderId);<br/>  24 │ <br/>  25 │ let 3 = 3;<br/>  <br/>  You forgot to handle a possible value here, for example: <br/>0<br/><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch05/Ch05_Branching.re<br/>  <br/>  Some fatal warnings were triggered (1 occurrences)</pre>
<p>Now the compiler will stop the compiling when it encounters a <em>fatal warning</em> and we can enjoy safer pattern matching.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Polymorphic variant types</h1>
                </header>
            
            <article>
                
<p>While Reason's variant types are conceptually simple, much of their power comes from the ability to use them with pattern matching and exhaustivity checking. Reason also provides a more powerful, but also more complex sum type, called <strong>polymorphic variants</strong><em>.</em> As the name suggests, these variants are more flexible than regular variants. Here are a few things that we can do with polymorphic variants, but not with regular variants:</p>
<ul>
<li>Create values without defining the types beforehand, letting the compiler infer the type</li>
<li>Compose multiple sets of variant cases together</li>
<li>Define functions that handle <em>at least</em> a set of variant cases as input</li>
<li>Define functions that output <em>at most</em> a set of variant cases as output</li>
</ul>
<p>In a sense, we can think of polymorphic variants as being related to regular variants in the same way that objects are related to records. They are, in fact, structural types in the same way that objects and modules are because the compiler infers the types of values by inspecting their structures.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating and typing values</h1>
                </header>
            
            <article>
                
<p>Let's see a few examples to get a feel for how polymorphic variants work:</p>
<pre>/* src/Ch05/Ch05_PolymorphicVariantBasics.re */<br/><span class="underline">let</span> <em>colour</em> = <em>`Red</em>; /* (1) */<br/><span class="underline">let</span> <em>angle</em> = <em>`degrees</em>(45.0); /* (2) */<br/><br/><span class="underline">type</span> <strong>event</strong> = [ /* (3) */<br/>| <em>`clickTap</em>(<strong>int</strong>, <strong>int</strong>) /* x, y */<br/>| <em>`keypress</em>(<strong>char</strong>)<br/>| <em>`pointerMove</em>(<strong>int</strong>, <strong>int</strong>, <strong>int</strong>, <strong>int</strong>) /* x1, y1, x2, y2 */<br/>];<br/><br/><span class="underline">type</span> <strong>mobileEvent</strong> = [<br/>| <strong>event</strong> /* (4) */<br/>| <em>`deviceShake</em>(<strong>int</strong>) /* how many times */<br/>| <em>`accel</em>(<strong>float</strong>) /* m/s^2 */<br/>];<br/><br/><span class="underline">let</span> <em>pressA</em>: <strong>mobileEvent</strong> = <em>`keypress</em>('a'); /* (5) */<br/>/* <span class="underline">let</span> <em>shakeThrice</em>: <strong>event</strong> = <em>`deviceShake</em>(3); /* (6) */ */</pre>
<p>There's a lot of new syntaxes here, but hopefully it should look somewhat similar to regular variant syntax:</p>
<ol>
<li>We can define an adhoc polymorphic variant value and let the compiler figure out its type. In this case, the editor support should show us a type <kbd>[&gt; `Red]</kbd>. This means a polymorphic variant type that has at least the <kbd>`Red</kbd> data constructor that I've seen, and possibly more. The brackets (<kbd>[...]</kbd>) around the type syntactically distinguish it from regular variants and also suggest that we should think of it as like a bounded set.</li>
<li>Polymorphic variant constructors can contain payloads just like regular variant constructors. Also, unlike regular constructors, polymorphic constructors can start with a lowercase letter. This is still unambiguous though because polymorphic variant constructors must always be prefixed with a back-tick character.</li>
<li>We can explicitly define polymorphic variant types using the syntax shown. Note that the compiler doesn't automatically infer any later values that use the defined constructors as being of the defined type. I'll explain this a bit more in the <em>fifth</em> point.</li>
<li>Polymorphic variant types can compose other polymorphic variant types and become an expanded set of cases. This lets us model cases that can be considered part of the set (type), but can also be considered separately, for example, device input events.</li>
<li>We must explicitly annotate a value with a polymorphic variant type to tell the compiler that it must be <em>exactly</em> this type. Without this annotation, within the module the compiler will infer the type from the structure of the data constructor, that is, in this case <kbd>[&gt; `keypress(char)]</kbd>. Note that declaring the exact types of the polymorphic variant values in module signatures will work, but only from the point of view of other modules, not internally within the module. Usually, that's good enough!</li>
<li>We can't declare that a polymorphic variant constructor has some type if that type doesn't actually declare the constructor first. Here's what the error would look like:</li>
</ol>
<pre style="padding-left: 60px"><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch05/Ch05_PolymorphicVariantBasics.re 18:26-40<br/>  <br/>  16 │ <br/>  17 │ let pressA: mobileEvent = `keypress('a'); /* (5) */<br/>  18 │ let shakeThrice: event = <strong>`deviceShake(3)</strong>; /* (6) */<br/>  <br/>  This has type:<br/>    <strong>[&gt; `deviceShake(int) ]</strong><br/>  But somewhere wanted:<br/>    event<br/>  The second variant type does not allow tag(s) `deviceShake</pre>
<p>We can visualize the error as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d205b705-478c-4df8-8136-cd6a8659f9aa.png" style="width:40.17em;height:10.75em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Polymorphic variant type mismatch</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inputting values into functions</h1>
                </header>
            
            <article>
                
<p>Now that we can create polymorphic variant values, let's do something useful with them. How can we handle a value that we get at runtime? It turns out, the same way we'd handle a normal variant: pattern matching:</p>
<pre>/* src/Ch05/Ch05_PolymorphicVariantInputs.re */<br/><span class="underline">let</span> <em>eventToString</em>(<em>event</em>) = <span class="underline">switch</span> (<em>event</em>) {<br/>| <em>`clickTap</em>(<em>x</em>, <em>y</em>) =&gt; {j|`clickTap($<em>x</em>, $<em>y</em>)|j} /* (1), (2) */<br/>| <em>`keypress</em>(<em>char</em>) =&gt; {j|`keypress($<em>char</em>)|j}<br/>| <em>`pointerMove</em>(<em>x1</em>, <em>y1</em>, <em>x2</em>, <em>y2</em>) =&gt; {j|`pointerMove($<em>x1</em>, $<em>y1</em>, $<em>x2</em>, $<em>y2</em>)|j}<br/>| <em>`deviceShake</em>(<em>times</em>) =&gt; {j|`deviceShake($<em>times</em>)|j}<br/>| <em>`accel</em>(<em>mssq</em>) =&gt; {j|`accel($<em>mssq</em>)|j}<br/>};<br/><br/>/* (3) */<br/><span class="underline">let</span> <em>pressAString</em> = <em>eventToString</em>(<em>Ch05_PolymorphicVariantBasics.pressA</em>);<br/><br/>/* (4) */<br/><span class="underline">let</span> <em>`degrees</em>(<em>angleVal</em>) = <em>Ch05_PolymorphicVariantBasics.angle</em>;</pre>
<ol>
<li>We can pattern match on an input polymorphic variant data constructor the same way we'd match against a regular constructor: by writing out the constructor as a pattern and binding any of its contained data that we want to use.</li>
</ol>
<ol start="2">
<li>We use a BuckleScript-specific string interpolation syntax for convenience here: <kbd>{j| ... $name ... |j}</kbd>. The <kbd>name</kbd> must be in scope, and it must be only a name, not an arbitrary expression such as <kbd>1 + 2</kbd>. The <kbd>{j|</kbd> and <kbd>|j}</kbd> act as string delimiters and can be used for multiline and Unicode string literals as well.</li>
<li>We can call the function with any value that conforms to its inferred input type, which <kbd>pressA</kbd> does because we made sure both its type and our new function have the same polymorphic variant cases.</li>
<li>We can as usual pattern match directly with a <kbd>let</kbd>-binding, but notice that there's no exhaustivity warning here. The compiler now doesn't know what other cases there might be, so it doesn't warn us. For this reason, it's best to avoid let-binding pattern matching of polymorphic variant values.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding polymorphic variant inference</h1>
                </header>
            
            <article>
                
<p>If you have type hinting enabled in your editor, it should tell you that the type of <kbd>eventToString</kbd> is as follows:</p>
<pre>[&lt;<br/>| <em>`accel</em>(<strong>'a</strong>)<br/>| <em>`clickTap</em>(<strong>'b</strong>, <strong>'c</strong>)<br/>| <em>`deviceShake</em>(<strong>'d</strong>)<br/>| <em>`keypress</em>(<strong>'e</strong>)<br/>| <em>`pointerMove</em>(<strong>'f</strong>, <strong>'g</strong>, <strong>'h</strong>, <strong>'i</strong>)<br/>] =&gt;<br/><strong>string</strong></pre>
<div class="packt_tip">The compiler alphabetizes the variant cases when printing them out, but just like with regular variants, the cases don't have any intrinsic ordering.</div>
<p>This function type is divided into two main parts: the input on the left of the arrow, and the output on the right. The input is a polymorphic variant type that can contain any of the listed cases or less, and these cases can have payloads in the given positions. Notice that the payloads all have types that look like <kbd>'x</kbd>, that is, starting with an apostrophe character. As we mentioned before, this character means that this type will be filled in later. Specifically, it's known as a type parameter.</p>
<p>The most important thing to understand about this inferred function type is that the input polymorphic variant is given an upper bound (<kbd>&lt;</kbd>), meaning this function can handle a polymorphic variant type that has these cases, and also polymorphic variant types that have a <em>subset</em> of these cases, but it certainly can't handle any <em>more</em> cases.</p>
<p>Now, let's tackle the reason why all the payload types are going to be filled in later. We already know that they're just ints and floats. Why couldn't the compiler figure that out?</p>
<p>It turns out that when we used the payloads in BuckleScript's special string interpolation syntax sugar, the compiler was never told what their exact types were. String interpolation just lets us stuff anything in a JavaScript string, without having to be specific to the compiler as we usually would, for example, with a string concatenation such as <kbd>"Hello" ++ " world"</kbd>. This is very convenient for producing output, but can lead to pitfalls where the compiler can't infer a type; so it's good to be aware of this.</p>
<p>Overall, notice the important safety property we achieve that's very similar to the type safety of objects: we can (to a certain extent) use adhoc variant constructors safely with the compiler's help.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Outputting values from functions</h1>
                </header>
            
            <article>
                
<p>What if we want to go in the opposite direction? That is, output polymorphic variant values from functions:</p>
<pre>/* src/Ch05/Ch05_PolymorphicVariantOutputs.re */<br/><span class="underline">let</span> <em>stringToColour</em>(<em>string</em>) = <span class="underline">switch</span> (<em>string</em>) {<br/>| "red" =&gt; <em>`red</em><br/>| "green" =&gt; <em>`green</em><br/>| "blue" =&gt; <em>`blue</em><br/>| _ =&gt; <em>`unknown</em> /* we need to handle the edge case */<br/>};</pre>
<p>This time, two interesting things happen:</p>
<ul>
<li>The compiler does exhaustivity checking on the input, which is a string, so we need to handle <em>all</em> possible string inputs (the last one is the catch-all)</li>
<li>The compiler swaps the polymorphic variant type's bound, making the type (of the function):</li>
</ul>
<pre style="padding-left: 60px"><strong>string</strong> =&gt; [&gt; <em>`blue</em> | <em>`green</em> | <em>`red</em> | <em>`unknown</em>]</pre>
<p>This time, the compiler infers a <em>lower bound</em> for the polymorphic variant return type, because it seems that the function returns those cases and it may potentially return more, but it will certainly never return <em>fewer</em> cases.</p>
<p>Polymorphic variant types are a deep and powerful part of Reason, and we'll explore them a bit more in the coming chapters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generalized algebraic data types</h1>
                </header>
            
            <article>
                
<p><strong>Generalized algebraic data types</strong> (<strong>GADTs</strong>) are another deep and powerful area of the language. As with polymorphic variant types, much of their true power is exposed when they're used with type parameters. But we can understand their surface syntax and how they relate to regular variant types, for now.</p>
<p>GADTs are, as the name suggests, a generalized form of algebraic data types. The name is a slight misnomer because they are really more of a generalized form of regular variant types only. <em>Algebraic data types</em> is a general name for both product and sum types taken together. Syntactically, GADTs look as follows:</p>
<pre>/* src/Ch05/Ch05_GADTs.re */<br/><span class="underline">type</span> <strong>poNumber</strong> = <strong>string</strong>;<br/><br/><span class="underline">type</span> <strong>paymentMethod</strong> =<br/>| <em>Cash</em>: <strong>paymentMethod</strong><br/>| <em>PurchaseOrder</em>(<strong>poNumber</strong>): <strong>paymentMethod</strong>; /* (1) */<br/><br/><span class="underline">let</span> <em>paymentCash</em> = <em>Cash</em>; /* (2) */<br/><br/><span class="underline">let</span> <em>paymentMessage</em>(<em>paymentMethod</em>) = <span class="underline">switch</span> (<em>paymentMethod</em>) {<br/>| <em>Cash</em> =&gt; "Paid in cash" /* (3) */<br/>| <em>PurchaseOrder</em>(<em>poNumber</em>) =&gt; {j|Paid with PO#$<em>poNumber</em>|j}<br/>};</pre>
<ol>
<li>GADT definition syntax looks much like regular variant definition syntax, except that the data constructors explicitly declare their type at the end. For monomorphic types (that is, ones that don't have any type parameters), this doesn't look very useful. In the next chapter, we'll see why it's so powerful.</li>
<li>Value construction looks the same as for regular variants.</li>
<li>Pattern matching also looks the same as for regular variants.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing for correctness with types</h1>
                </header>
            
            <article>
                
<p>Now that we've seen the product and sum types in action, let's take a step back and ask how they can work together. Intuitively, product types let us group values together, and sum types let us choose one among a restricted set of values. Together, they express a wide range of data modeling scenarios. Let's look at a couple of examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Products and sums together</h1>
                </header>
            
            <article>
                
<p>First, a simple example to warm up. Suppose we're asked to track the following attributes of a person for a Customer Relationship Management software:</p>
<ul>
<li>ID number: A string</li>
<li>Name: A string</li>
<li>Education level: O<em>ne of</em> school, college, postgrad, or other</li>
</ul>
<p>A valid person record must have <em>all of</em> these attributes. Notice how we're using the specific phrasing <em>one of</em> and <em>all of</em>. These give us a hint about how to model the data: <em>one of</em> means a sum type and <em>all of</em> means a product type! It's very useful to think about the requirements in these terms as we break down a data structure into its component parts.</p>
<p>The main choice after that is specifically which implementations of product and sum types to use. Usually, we'll reach for the simplest possible implementations: records and variants. So, in this case:</p>
<pre>/* src/Ch05/Ch05_CrmPerson.re */<br/><span class="underline">type</span> <strong>education</strong> = <em>Ch05_Variants</em>.<strong>education</strong> =<br/>| <em>School</em><br/>| <em>College</em><br/>| <em>Postgrad</em><br/>| <em>Other</em>;<br/><br/><span class="underline">type</span> <strong>t</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>, <strong>education</strong>}; /* (1) */<br/><br/>/* (2) */<br/><span class="underline">let</span> <em>bob</em> = {<em>id</em>: 1, <em>name</em>: "Bob", <em>education</em>: <em>College</em>};<br/><span class="underline">let</span> <em>jim</em> = {<em>id</em>: 2, <em>name</em>: "Jim", <em>education</em>: <em>Other</em>};</pre>
<ol>
<li>The person record type <kbd>Ch05_CrmPerson.t</kbd> is a record type composed out of three other types: an <kbd>int</kbd>, a <kbd>string</kbd>, <em>and</em> an <kbd>education</kbd>. The <kbd>education</kbd> type is a variant type that admits <em>one of</em> the four legal education values.</li>
</ol>
<ol start="2">
<li>The valid <kbd>t</kbd> values are built by grouping together all the required component values, including the <kbd>education</kbd> values.</li>
</ol>
<p>Notice how the values are constructed by obeying the business logic laid out by the types: for a person record, we need an ID, a name, and an education; for an education value, we need only one of the allowable values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Recursive types</h1>
                </header>
            
            <article>
                
<p>Now, let's look at a more interesting example. Suppose we need to model not just one, but a <em>list</em> of person records. Suppose we also need to be able to walk through this list, one person at a time, and carry out some actions based on the data from each person. A natural data structure for this would be a <em>singly linked list.</em> As you might know, a singly linked list is a series of nodes that each point to the next node in the list, or to <em>nothing</em> in case there is no next node (that is, for the last node of the list).</p>
<p>In Reason, a natural way to model this list is with a recursive variant type. A <em>recursive type</em> is one that contains values of its <em>own</em> type. This neat trick works because Reason internally separates the storage of values from their types, so they don't end up taking infinite storage. Here's an example implementation of our person record list scenario:</p>
<pre>/* src/Ch05/Ch05_PersonList.re */<br/><span class="underline">type</span> <strong>t</strong> = <em>Node</em>(<em>Ch05_CrmPerson</em>.<strong>t</strong>, <strong>t</strong>) | <em>Empty</em>; /* (1) */<br/><br/><span class="underline">let</span> <em>people</em> = <em>Ch05_CrmPerson</em>.(<em>Node</em>(<em>bob</em>, <em>Node</em>(<em>jim</em>, <em>Empty</em>))); /* (2) */<br/><br/><span class="underline">let</span> <span class="underline">rec</span> <em>greet</em>(<em>t</em>) = <span class="underline">switch</span> (<em>t</em>) { /* (3) */<br/>| <em>Node</em>(<em>person</em>, <em>list</em>) =&gt; { /* (4) */<br/>    <em>print_endline</em>("Hello, " ++ <em>person.name</em> ++ "!");<br/>    <em>greet</em>(<em>list</em>)<br/>  }<br/>| <em>Empty</em> =&gt; () /* (5) */<br/>};</pre>
<p>Using a recursive type reveals some new and interesting syntax:</p>
<ol>
<li>The type definition of a recursive type doesn't look any different from what we saw before, except that it contains a reference to its own type. We're not having to do anything special because, in Reason, all type definitions are recursive by default. In fact, if we want to make a type definition <em>non-recursive</em> (which we do in some circumstances), we'll need to use an extra keyword: <kbd>type nonrec t = ...</kbd>.</li>
</ol>
<ol start="2">
<li>We can define a value of a recursive type like normal, except it can contain other values of its own type. We locally open the <kbd>Ch05_CrmPerson</kbd> module to get access to the people values defined there.</li>
<li>To walk through all the values of a recursive type, we'll usually need a <em>recursive function</em> (that is, a function that calls itself). Unlike types, functions aren't recursive by default, because traditionally recursive functions are slightly more expensive in terms of runtime performance. So when we need recursion, we specify it with the <kbd>let rec ...</kbd> syntax.</li>
<li>We can destructure a recursive value in the normal way, just as if it were non-recursive; we just need to make sure we pass its recursive portion, <kbd>list</kbd>, into the recursive <kbd>greet</kbd> call.</li>
<li>To handle the non-recursive portion of <kbd>Ch05_PersonList.t</kbd> (<kbd>Empty</kbd>), we just need to <em>do nothing</em>, so we return unit, the <em>empty value</em>.</li>
</ol>
<p>Our recursive <kbd>greet</kbd> function has an interesting property: it is tail-recursive. <em>Tail recursion</em> is the property that a recursive function has if it calls itself in tail position, that is, if it calls itself as the last (tail) operation of any of its branches of evaluation. For example, <kbd>greet</kbd> calls itself as the last operation of its first branch, where it handles the <kbd>Node</kbd> variant case.</p>
<p>We're paying attention to this tail recursion property because the BuckleScript compiler has a special ability to convert tail recursion into a simple, efficient loop in the output JavaScript. If you examine the output, you'll see that the loop looks almost handwritten.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered what collectively are known as sum types: variants and pattern matching, polymorphic variants, and GADTs. These are some of the bread-and-butter typing techniques in Reason, and they enable powerful data modeling techniques when used in the right combinations.</p>
<p>However, it's becoming increasingly clear that a lot of typing power still remains to be explored. In the next chapter, we will fully cover the type parameters (generics) that we've glimpsed at so far while using different kinds of type techniques.</p>


            </article>

            
        </section>
    </body></html>