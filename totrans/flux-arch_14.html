<html><head></head><body><div class="chapter" title="Chapter&#xA0;14.&#xA0;Flux and the Software Development Lifecycle"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"/>Chapter 14. Flux and the Software Development Lifecycle</h1></div></div></div><p>Flux is about information architecture, first and foremost. This is the reason that Flux is a set of patterns instead of a framework implementation. When we design front-end architectures that scale, the specific implementation matters very little, relative to the design of the overall system. It's things like unidirectional data-flows and synchronous update rounds that have a lasting impact on the scalability of the system. In fact, Flux can be influential enough that it changes the way we develop our software.</p><p>In this chapter we'll look at the software development lifecycle through the lens of Flux. We'll open the chapter with a discussion on the open-ended possibilities with Flux implementations. Then we'll compare the types of development activities that take place at the beginning of a new Flux project with what happens with a maturing Flux project.</p><p>We'll also think about the concepts that make Flux appealing to begin with, and how to extract these ideas and apply them to other software systems. Lastly, we'll end the chapter with a look at creating monolithic Flux systems versus packaging Flux components.</p><div class="section" title="Flux is open to interpretation"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec82"/>Flux is open to interpretation</h1></div></div></div><p>One problem with JavaScript frameworks is that they're just one instantiation of a full spectrum of possible solutions. One solution isn't as universal as we might hope. Even a specification such as Flux that<a id="id525" class="indexterm"/> contains just a handful of patterns is open for interpretation. The fact that they're just patterns makes it easier for one group to go and implement their software one way, while another group uses the same patterns to implement their software how they see fit.</p><p>In this section, we'll reiterate the fact that Flux is just a set of patterns to follow. We'll revisit the possibility of using a Flux library, each of which has a different take on implementing the Flux patterns. Then we'll consider the trade-offs of implementing our own Flux components.</p><div class="section" title="Implementation option 1 – just the patterns"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec172"/>Implementation option 1 – just the patterns</h2></div></div></div><p>Flux is just patterns for us to follow. We might not even follow them exactly. Pattern efficacy isn't what's important—what's important is that we get the fundamental value of Flux out of our design. For <a id="id526" class="indexterm"/>example, actions describe something that has happened, and they carry with them a payload of new data to enter the system. Once the new data has been dispatched, it continues in one direction until it is rendered. Flux just happens to use the concept of a dispatcher and a store. We could call our implementation of Flux a conveyor belt if we wanted to. If the data-flow is unidirectional and predictable, then we've met one Flux goal.</p><p>Likewise, we can implement the dispatcher and the store components to our liking. There are probably tweaks that we could make to a store component that would better serve our application. These could be for performance reasons, or they could be simple developer conveniences. Either of these things are fine to introduce, as long as the data-flow stays unidirectional and synchronous.</p><p>These ideas of unidirectional data-flow and synchronous update rounds aren't unique to Flux. We could work within the confines of other architectures, such as MVC, and achieve the same principles. What is unique about Flux is that it was born out of frustration. Engineers at Facebook decided that they needed a vehicle to explicitly state just how to get these design principles right.</p></div><div class="section" title="Implementation option 2 – use a Flux library"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec173"/>Implementation option 2 – use a Flux library</h2></div></div></div><p>We certainly don't have to implement every Flux component ourselves. There's plenty of choice out there<a id="id527" class="indexterm"/> when it comes to Flux libraries. What's interesting is that this Flux library ecosystem reinforces the assertion that Flux is open to interpretation. Perhaps the best example of this is Redux. This library is not an implementation of the concepts<a id="id528" class="indexterm"/> outlined in the Flux documentation. Instead, Redux takes a different route to implementing Flux principles.</p><p>For example, there's no dispatcher in Redux, and we can only create one store, which consists of reducer functions. What's important is that we still get the unidirectional data-flow and that the update rounds are synchronous. Then there's <code class="literal">Alt.js</code>, which takes a more traditional approach to implementing Flux in that it has the same abstractions as outlined in the Flux documentation. But <code class="literal">Alt.js</code> also builds its own ideas on top of these concepts to make implementing Flux that much easier and more enjoyable.</p><p>Is it all-or-nothing when we decide to leverage a Flux library? Not necessarily. This fear of all-or-nothing stems from monolithic frameworks that prescribe a certain way of doing things, and there's no easy way to work around these. With libraries, the idea is to be able to pick and choose the bits that you need in order to compose larger behavior. Take the view layer in a Flux architecture—this is most commonly made up of React components. However, neither Redux or <code class="literal">Alt.js</code> require that we use React. Redux is small enough that we can just use its store component for our application state, and <code class="literal">Alt.js</code> has several smaller modules that we<a id="id529" class="indexterm"/> can pick and choose from—there are probably several<a id="id530" class="indexterm"/> that we'll never use.</p></div><div class="section" title="Roll your own Flux"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec174"/>Roll your own Flux</h2></div></div></div><p>Given that there are so many <a id="id531" class="indexterm"/>approaches to implementing a Flux system, is there any utility in implementing our own? In other words, would we be re-inventing the wheel by rolling our own Flux components instead of depending on one of the many Flux libraries out there? Not at all. There's a strong possibility that none of the Flux libraries meet the needs of what we're trying to accomplish. Or maybe there are several things about the Flux components that we want to customize, so that it makes less sense to depend on an implementation that we're going to change completely.</p><p>Most of the code in this book has been based on our own implementations of Flux components. We've relied on the reference implementation of the Flux dispatcher, but then we went and implemented our own, without much difficulty. The positive aspect of implementing our own Flux components is that we have the freedom to tweak the components to meet the needs of our application as it evolves. This is more difficult to do when we depend on someone else's implementation.</p><p>One possibility is that we use a library like <code class="literal">Alt.js</code> for inspiration for rolling our own implementation. This way, we can implement the cool features from that library while modifying them as we see fit. On the other hand, we could be better off just using a Flux library as-is. The best bet is to think about this sort of thing while you're building a skeleton Flux architecture. Don't depend on any libraries upfront, but decide early on if you're going to use something like Redux, so you don't have to throw out too many components.</p></div></div></div>
<div class="section" title="Development methodologies"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec83"/>Development methodologies</h1></div></div></div><p>In this section, we'll look at the development methodologies that take place at different stages of a Flux project. Keep in mind that these are just guidelines, as methodologies can vary quite drastically from team to team. If two different teams are implementing a Flux system, there will no doubt be some commonalities.</p><p>First we'll think<a id="id532" class="indexterm"/> about what happens during the initial phases of a new Flux project. Then we'll think about Flux projects that have had a chance to mature, and what the process might look like for adding a new feature to the system.</p><div class="section" title="Upfront Flux activities"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec175"/>Upfront Flux activities</h2></div></div></div><p>Many software <a id="id533" class="indexterm"/>development methodologies frown upon big upfront design. The reason is simple—we spend too much time designing before any software is written and tested. Incrementally delivering pieces of software gives us a chance to validate any assumptions we may have made while writing code. The question is, does Flux require big upfront design, or can we incrementally implement parts of a Flux system?</p><p>As you saw earlier in the book, the first step to designing a Flux architecture is writing code. At first, we're only interested in producing a skeleton architecture so that we can get a feel for the types of information our components will need. We don't spend time implementing UI components initially, because doing so will likely be a time sink and a distraction from thinking about the other Flux components that we'll need—such as stores and actions.</p><p>The question is, can building a skeleton architecture fit into the regular flow of developing software without being big on upfront design? I think so.</p><p>We don't want to spend too much time on a skeleton architecture, because that's just a recipe for bike-shedding. We could, however, set sprint goals for building pieces of the skeleton architecture and reviewing with a larger group. Something like a sprint demo might actually be the ideal forum to decide whether or not we've built enough of the skeleton architecture and whether we're happy with it. Then it's time to start building features in earnest.</p></div><div class="section" title="Maturing a Flux application"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec176"/>Maturing a Flux application</h2></div></div></div><p>Once we've moved <a id="id534" class="indexterm"/>well beyond the skeleton architecture phase, we hopefully have in place a solid product with features that our customers will enjoy using. Ideally, this means that we've hit a sweet spot with our Flux architecture—it scales well, it's easy to maintain, and we're able to keep our customers happy by delivering new features. The application is mature, in other words. So how did we get to this point, and how do we keep it going?</p><p>Let's consider a feature that we've been asked to build. We have a team of all-purpose programmers to build it. How should we go about decomposing the feature into implementation tasks? Flux makes this fairly easy to figure out, because there are a limited number of component types. So if we can get a small team assembled to deliver a feature, then one person can focus on implementing the views, another on the stores and actions, and another to build the back-end data services. Here's an illustration of a team and the Flux components they build to realize a feature of the application:</p><div class="mediaobject"><img src="graphics/B05419_14_01.jpg" alt="Maturing a Flux application"/></div><p>An alternative approach<a id="id535" class="indexterm"/> would be to have teams that focus on the same types of components. For example, a store team would be spread across features but each member would work on a store component at any given time. This approach is inferior because a team of Flux programmers working on the same deliverable have collective insight into how the feature is going to provide maximum customer value.</p></div></div>
<div class="section" title="Borrowing ideas from Flux"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec84"/>Borrowing ideas from Flux</h1></div></div></div><p>Flux forces us to think about<a id="id536" class="indexterm"/> the information architecture of our application in new and interesting ways. Rarely does adopting a new approach like this happen in a vacuum. The ideas tend to spread to other parts of the technology stack. With Flux, it's the architectural principles of data-flow direction and feature-driven information that stand out as having a positive impact. If these things can have a positive impact on the frontend code, why couldn't they influence the design of the system as a whole?</p><div class="section" title="Unidirectional data flow"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec177"/>Unidirectional data flow</h2></div></div></div><p>The unidirectional flow<a id="id537" class="indexterm"/> of data through a Flux architecture is probably the key aspect that enables it to scale. By itself, unidirectional data-flow makes the code we write easy to reason about. In places, this approach can be a little more verbose, but this is a conscious trade-off that we make in order to facilitate predictability. For example, with the two-way data binding capabilities found in some frameworks, we can get away with writing less code. This, however, is a developer convenience that trades off predictability.</p><p>This is the type of lesson from Flux that may in fact be applicable to other areas of our technology stack. For example, are there pieces of code that are difficult to reason about because the data that flows through them moves in several directions? Can we change that?</p><p>It might be hard to enforce<a id="id538" class="indexterm"/> unidirectional data-flows to the extent that Flux does, but we can at least think about the benefits that this brings to the front-end of the application and try to apply the same principles to other code. For instance, maybe we can't get a unidirectional data-flow in place but we can slim down the component by removing flows that are particularly difficult to predict.</p></div><div class="section" title="Information design is king"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec178"/>Information design is king</h2></div></div></div><p>Flux architectures start with<a id="id539" class="indexterm"/> information that the user interacts with, and work their its way backward, toward the API. This approach is different from other front-end architectures where you have the API entities, and you then create front-end models, and the views (or view models) figure out the transformations necessary to create information that's relevant to the user. The challenge with putting information first is that we might come up with something that's just not feasible from the API perspective.</p><p>However, if this is the case then we probably have a dysfunctional team structure to begin with, because it's easy to isolate oneself in one's own technology bubble (back-end, network, front-end, and so on), but this simply does not work in a feature-driven product. All contributing members need to know what's going on in every layer of the stack.</p><p>If we can sort out the teams so that each contributor is fully aware of what's happening in the various parts of the code-base, then we can adopt an <span class="emphasis"><em>information is king</em></span> attitude toward feature development. Flux works well for this, and it turns out that this is actually the best way to serve our customers. If we know what information is needed, we can figure out how to get it.</p><p>On the other hand, we're biased about what can and cannot be done because we already have an API to work with. This, however, should never be the determining factor of when and how we're able to implement a feature. Like Flux, we should design our abstractions around the information required by the feature, and not the other way around.</p></div></div>
<div class="section" title="Packaging Flux components"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec85"/>Packaging Flux components</h1></div></div></div><p>In this last section, we'll think<a id="id540" class="indexterm"/> about the composition of large Flux applications from the point of view of packages. First, we'll make the case for a monolithic distribution of a Flux application, and the point at which this approach becomes untenable. Then we'll talk about packages, and how they help us scale up the Flux application <a id="id541" class="indexterm"/>development effort. Finally, we'll walk through an example of how this might work.</p><div class="section" title="The case for monolithic Flux"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec179"/>The case for monolithic Flux</h2></div></div></div><p>Anyone who has been <a id="id542" class="indexterm"/>caught in dependency hell knows that it's an unpleasant place to be. Generally speaking, we bring these issues on ourselves by relying too heavily on third-party packages. For example, we might use a couple components from a gigantic library, or we might use an exceedingly simple library for something we could have written ourselves. In any case, we end up with more dependencies than what's justified for the size and scope of our project.</p><p>Just because we're implementing a Flux architecture for our application, we don't have to scale it up for scaling's sake. In other words, we can still use Flux for simple applications and acknowledge the fact that there's no need to scale it yet. In this case, we're probably better off avoiding dependencies wherever possible.</p><p>The composition of our simple Flux application can be monolithic as well. By this, I don't mean putting everything into a few modules. A monolithic Flux application would be distributed as a single NPM package. We can probably do this for quite some time. For example, we could successfully ship software for years without this ever being a problem. However, when extensibility becomes an issue, we have to rethink the best way to compose and package our Flux application.</p></div><div class="section" title="Packages enable scale"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec180"/>Packages enable scale</h2></div></div></div><p>Applications will eventually become a victim of their own success. If an application manages to stay around long enough and <a id="id543" class="indexterm"/>gain enough attention from customers, it will eventually have more features than it can feasibly handle. That's not to say that our Flux architecture can't handle a lot of features—it can. But look at things from the customers' viewpoint. They probably don't want or need everything that other customers use.</p><p>This requires that we seriously think about the composition of our Flux architecture, because you can bet that we're going to need more fine-grained management of features. Installable features, in other words. But just how fine-grained do these components, and the packages through which we install them, need to be? Well, I think a top-level feature might be a good unit of measurement.</p><p>For example, we typically model the state of a given top-level feature of our application in a single store. Other features have their own stores, we can depend on them, and so on. This means that our application needs to take into consideration that a given feature component might not be installed on the system. For instance, if we were to create a Flux component that implements user management functionality, our application that loads these components would require this feature as though it were any other third-party package.</p></div><div class="section" title="Installable Flux components"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lvl2sec181"/>Installable Flux components</h2></div></div></div><p>In this section, we'll walk through an example application—albeit a simple one—to illustrate how we can go<a id="id544" class="indexterm"/> about installing the major pieces of our application components. It's beneficial to be able to excise the major parts from our core application, because this decouples them from the application, and it makes it easier to use the package elsewhere.</p><p>Let's start by looking at the main module of the application, which will help set the context for the other two NPM packages that make up two main features:</p><div class="informalexample"><pre class="programlisting">// The React components we need...
import React from 'react';
import { render } from 'react-dom';

// The stores and views from our "feature packages".
import { Users, ListUsers } from 'my-users';
import { Groups, ListGroups } from 'my-groups';

// The components that are core to the application...
import dispatcher from './dispatcher';
import AppData from './stores/app';
import App from './views/app';
import { init } from './actions/init';

// Constructs the Flux stores, passing in the
// dispatcher as an argument. This is how we're
// able to get third-party Flux components to
// talk to our application and vice-versa.
const app = new AppData(dispatcher);
const users = new Users(dispatcher);
const groups = new Groups(dispatcher);

// Re-render the application when the store
// changes state.
app.on('change', renderApp);
users.on('change', renderApp);
groups.on('change', renderApp);

// Renders the "App" React component, and it's
// child components. The dispatcher is passed
// to the "ListUsers" and the "ListGroups"
// components since they come from different
// packages.
function renderApp() {
  render(
    &lt;App {...app.state}&gt;
      &lt;ListUsers
        dispatcher={dispatcher}
        {...users.state}
      /&gt;
      &lt;ListGroups
        dispatcher={dispatcher}
        {...groups.state}
      /&gt;
    &lt;/App&gt;,
    document.getElementById('app')
  );
}

// Dispatches the "INIT" action, so that the
// "App" store will populate it's state.
init();</pre></div><p>We'll start at the top—where we're importing stores and views from the <code class="literal">my-users</code> and the <code class="literal">my-groups</code> packages. This is<a id="id545" class="indexterm"/> the code for our application, but note that we're not using a relative import path. This is because they're installed as NPM packages. This means that another application could easily share these components, and that they can be updated independently of the applications that use them. After these imports, we have the rest of the application components.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>Apple's legal team will be happy to see that I named the store <span class="emphasis"><em>AppData</em></span> instead of <span class="emphasis"><em>AppStore</em></span>.</p></div></div><p>Next, we create the store instances. You can see that each store has a reference to the dispatcher passed to it. This is how we communicate with Flux components that we're dependent on for composing a larger application. We'll look at the stores shortly.</p><p>The <code class="literal">renderApp()</code> function then renders the main <code class="literal">App</code> React component, and the two components from our NPM packages as children. It's this function that we've registered with each of the store instances, so that when any of these stores change state, the UI is re-rendered. Finally, the <code class="literal">init()</code> action creator function is called, which populates the main navigation.</p><p>This main module is key to being able to compose larger applications out of smaller, separately installable Flux packages. We import them and configure them all in one place. The dispatcher is the main communication mechanism—it's passed to both the stores and the views. We<a id="id546" class="indexterm"/> don't have to touch more than one file in order to important and make use of big application features, which is hugely important for scaling up the development effort.</p><p>Now we'll take a look at the app store (not Apple's) to see how the navigation data is driven:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import { INIT } from '../actions/init';

// The initial state of the "App" store has
// some header text and a collection of
// navigation links.
const initialState = {
  header: [ 'Home' ],
  links: [
    { title: 'Users', action: 'LOAD_USERS' },
    { title: 'Groups', action: 'LOAD_GROUPS' }
  ]
};

// The actual state is empty by default, meaning
// that nothing gets rendered.
var state = {
  header: [],
  links:[]
};

export default class App extends EventEmitter{
  constructor(dispatcher) {
    super();

    this.id = dispatcher.register((action) =&gt; {
      switch(action.type) {

        // When the "INIT" action is dispatched,
        // we assign the initial state to the empty
        // state, which triggers a re-render.
        case INIT:
          state = Object.assign({}, initialState);
          break;

        // By default, we empty out the store's state.
        default:
          state = Object.assign({}, state, {
            header: [],
            links: []
          });
          break;
      }

      // We always emit the change event.
      this.emit('change', state);
    });
  }

  get state() {
    return Object.assign({}, state);
  }
}</pre></div><p>Here you can see that this store has two sets of state–one is for the initial state of the store, and one is the actual state that's passed to view components for rendering. The state has empty properties by default so that views using this store don't actually render anything. The <code class="literal">INIT</code> action will cause<a id="id547" class="indexterm"/> the state to be populated from <code class="literal">initialState</code>, and this results in the view being updated.</p><p>Let's take a look at this view now:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import dispatcher from '../dispatcher';

// The "onClick()" click handler will dispatch
// the given action. This argument is bound when
// the link is rendered. Actions that are dispatched
// from this function can be handled by other packages
// that are sharing this same dispatcher.
function onClick(type, e) {
  e.preventDefault();
  dispatcher.dispatch({ type });
}

// Renders the main navigation links, and
// any child elements. Nothing is rendered
// if the store state is empty.
export default ({ header, links, children }) =&gt; (
  &lt;div&gt;
    {header.map(title =&gt; &lt;h1 key={title}&gt;{title}&lt;/h1&gt;)}
    &lt;ul&gt;{
      links.map(({ title, action }) =&gt;
        &lt;li key={action}&gt;
          &lt;a
            href="#"
            onClick={onClick.bind(null, action)}&gt;{title}
          &lt;/a&gt;
        &lt;/li&gt;
      )
    }&lt;/ul&gt;
    {children}
  &lt;/div&gt;
);</pre></div><p>When the store state is empty, as it is by default, all that's rendered is an empty <code class="literal">div</code>, and an empty <code class="literal">ul</code>. This is enough to completely remove the view from the screen. The click event is interesting. It's using the dispatcher to dispatch actions. The action type comes from the store data, and, by<a id="id548" class="indexterm"/> default, this application doesn't actually do anything with the <code class="literal">LOAD_USERS</code> or <code class="literal">LOAD_GROUPS</code> actions. But the two packages we've imported and set up in the main module do listen to these actions. This is a big part of what makes this approach scale–different NPM Flux packages can dispatch or react to actions–but this doesn't mean either will actually happen.</p><p>This is the gist of our application. Now we'll walk through the <code class="literal">my-users</code> package. The <code class="literal">my-groups</code> package is nearly identical, so we won't list that code here. First we have the store:</p><div class="informalexample"><pre class="programlisting">import { EventEmitter } from 'events';
import { LOAD_USERS } from '../actions/load-users';
import { LOAD_USER } from '../actions/load-user';

// The initial state of the store has some header
// text and a collection of user objects.
const initialState = {
  header: [ 'Users' ],
  users: [
    { id: 1, name: 'First User' },
    { id: 2, name: 'Second User' },
    { id: 3, name: 'Third User' }
  ]
};

// The state of the store that gets rendered by
// views. Initially this is empty so nothing is
// rendered by the view.
var state = {
  header: [],
  users: []
};

export default class Users extends EventEmitter{
  constructor(dispatcher) {
    super();

    this.id = dispatcher.register((action) =&gt; {
      switch(action.type) {

        // When the "LOAD_USERS" action is dispatched,
        // we populate the store state using the initial
        // state object. This causes the view to render.
        case LOAD_USERS:
          state = Object.assign({}, initialState);
          break;

        // When the "LOAD_USER" action is dispatched,
        // we update the header text by finding the user
        // that corresponds to the "payload" id, and using
        // it's "name" property.
        case LOAD_USER:
          state = Object.assign({}, state, {
            header: [ state.users.find(
              x =&gt; x.id === action.payload).name ]
          });
          break;

        // By default, we want to empty the store state.
        default:
          state = Object.assign({}, state, {
            header: [],
            users: []
          });
          break;
      }

      // Always emit the change event.
      this.emit('change', state);
    });
  }

  get state() {
    return Object.assign({}, state);
  }
}</pre></div><p>There are two key actions that this store handles. The first is <code class="literal">LOAD_USERS</code>, which takes the initial state and uses it to <a id="id549" class="indexterm"/>populate the store state. The <code class="literal">LOAD_USER</code> action changes the content of the header state, and this action is dispatched when a user link is clicked. By default, the store state is cleared out. Now let's take a look at the React component that renders the store data:</p><div class="informalexample"><pre class="programlisting">import React from 'react';
import { LOAD_USER } from '../actions/load-user';

// The "click" event handler for items in the users
// list. The dispatcher is passed in as an argument
// because this Flux package doesn't have a dispatcher,
// it relies on the one from the application.
//
// The "id" of the user that was clicked is also passed
// in as an argument. Then the "LOAD_USER" action
// is dispatched.
function onClick(dispatcher, id, e) {
  e.preventDefault();

  dispatcher.dispatch({
    type: LOAD_USER,
    payload: id
  });
}

// Renders the component using data from the store
// state that was passed in as props.
export default ({ header, users, dispatcher }) =&gt; (
  &lt;div&gt;
    {header.map(h =&gt; &lt;h1 key={h}&gt;{h}&lt;/h1&gt;)}
    &lt;ul&gt;{users.map(({ id, name }) =&gt;
      &lt;li key={id}&gt;
        &lt;a
          href="#"
          onClick={
            onClick.bind(null, dispatcher, id)
          }&gt;{name}
        &lt;/a&gt;
      &lt;/li&gt;
    )}&lt;/ul&gt;
  &lt;/div&gt;
)</pre></div><p>The key difference between this view and your typical Flux view is that the dispatcher itself is passed in as a prop. Then, as the links are rendered, the dispatcher instance is bound as the first argument to the handler function.</p><p>I strongly recommend downloading<a id="id550" class="indexterm"/> and experimenting with the code from this example. The two packages that are installed are very simple, just enough to illustrate how we can get the basic mechanisms in place that enable us to break major features out of the application and into their own installable packages.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lvl1sec86"/>Summary</h1></div></div></div><p>This chapter looked at Flux in the larger context of the software development life-cycle. Since Flux is a set of architectural patterns for us to follow, they're largely open to interpretation as far as implementation goes. At the beginning of a Flux project, the emphasis is on iteratively delivering pieces of a skeleton architecture. Once we have a mature application with several features, the focus shifts to managing complexity.</p><p>We then discussed the possibility that other areas of our technology stack might want to borrow ideas from Flux. Things like unidirectional data-flows mean that there's less chance of side-effects and that the system as a whole is more predictable. Finally, we closed the chapter with a look at how we could potentially compose larger applications out of separately installable features made out of Flux components.</p><p>I hope this book has been an enlightening read on Flux architecture. The goal wasn't necessarily to nail down the <span class="emphasis"><em>ideal</em></span> Flux implementation–I don't think there is such a thing. Instead, I wanted to impart the style of thinking that goes along with the important principles of Flux. If you find yourself implementing something, and start thinking about unidirectional data-flows and predictability, then I might have succeeded.</p></div></body></html>