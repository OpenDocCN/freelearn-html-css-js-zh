- en: Working with Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and waiting for Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resolving Promise results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rejecting Promise errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a Promise chain with Promise.resolve
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Promise.all to resolve multiple Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors with Promise.catch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating finally with the Promise API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In earlier versions of JavaScript, the callback pattern was the most common
    way to organize asynchronous code. It got the job done, but it didn't scale well.
    With callbacks, as more asynchronous functions are added, the code becomes more
    deeply nested, and it becomes more difficult to add to, refactor, and understand
    the code. This situation is commonly known as **callback hell**.
  prefs: []
  type: TYPE_NORMAL
- en: Promises were introduced to improve on this situation. Promises allow the relationships
    of asynchronous operations to be rearranged and organized with more freedom and
    flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter demonstrate how to use promises to create and organize
    asynchronous functions, as well as how to handle error conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and waiting for Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promises provide a way to compose and combine asynchronous functions in an organized
    and easier to read way. This recipe demonstrates a very basic usage of promises.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `03-01-creating-and-waiting-for-promises`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` file that creates a promise and logs messages before and
    after the promise is created, as well as while the promise is executing and after
    it has been resolved:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7bdb1f62-5603-4bd8-a3dd-15c0de1a0388.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By looking at the order of the log messages, you can clearly see the order of
    operations. First, the initial log is executed. Next, the promise is created with
    an executor method. The executor method takes `resolve` as an argument. The `resolve`
    function fulfills the promise.
  prefs: []
  type: TYPE_NORMAL
- en: Promises adhere to an interface named **thenable**. This means that we can chain
    `then` callbacks. The callback we attached with this method is executed after
    the `resolve` function is called. This function executes asynchronously (not immediately
    after the Promise has been resolved).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is a log after the promise has been created.
  prefs: []
  type: TYPE_NORMAL
- en: The order the logs messages appear reveals the asynchronous nature of the code.
    All of the logs are seen in the order they appear in the code, except the `Finished
    promise` message. That function is executed asynchronously after the `main` function
    has exited!
  prefs: []
  type: TYPE_NORMAL
- en: We'll be looking more at `resolve`, `then`, and other parts of the promise API
    in later recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Resolving Promise results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to use promises to execute asynchronous code.
    However, this code is pretty basic. It just logs a message and then calls `resolve`.
    Often, we want to use asynchronous code to perform some long-running operation,
    then return that value.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how to use `resolve` in order to return the result
    of a long-running operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `3-02-resolving-promise-results.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` file that creates a promise and logs messages before and
    after the promise is created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the promise, resolve a random number after a 5-second timeout:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Chain a `then` call off the promise. Pass a function that logs out the value
    of its only argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ef489ed3-ef1d-4033-818f-ac8ae272c79a.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as in the previous recipe, the promise was not fulfilled until `resolve`
    was executed (this time after 5 seconds). This time however, we passed the called 
    `resolve` immediately with a random number for an argument. When this happens,
    the argument is provided to the callback for the subsequent `then` function. We'll
    see in future recipes how this can be continued to create *promise chains*.
  prefs: []
  type: TYPE_NORMAL
- en: Rejecting Promise errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to use `resolve` to provide a result from
    a successfully fulfilled promise. Unfortunately, the code doesn't always run as
    expected. Network connections can be down, data can be corrupted, and uncountable
    other errors can occur. We need to be able to handle those situations as well.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how to use `reject` when errors arise.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `3-03-rejecting-promise-errors`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` file that creates a promise, and logs messages before and
    after the promise is created and when the promise is fulfilled:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a second argument to the promise callback named `reject`, and call `reject`
    with a new error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Chain a `catch` call off the promise. Pass a function that logs out its only
    argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/71d45fae-07fe-42ff-ae36-1c9e231e02c4.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously we saw how to use `resolve` to return a value in the case of a successful
    fulfillment of a promise. In this case we called `reject` before `resolve`. This
    means that the Promise finished with an error before it could `resolve`.
  prefs: []
  type: TYPE_NORMAL
- en: When the Promise completes in an error state, the `then` callbacks are not executed.
    Instead we have to use `catch` in order to receive the error that the Promise
    rejects. You'll also notice that the `catch` callback is only executed after the
    `main` function has returned. Like successful fulfillment, listeners to unsuccessful
    ones execute asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handle errors with `Promise.catch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating `finally` with `Promise.then`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chaining Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this chapter, we've seen how to use promises to run single asynchronous
    tasks. This is helpful but doesn't provide a significant improvement over the
    callback pattern. The real advantage that promises offer comes when they are composed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll use promises to combine asynchronous functions in series.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that  you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `3-04-chaining-promises.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` file that creates a promise. Resolve a random number from
    the promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Chain a `then` call off of the promise. Return `true` from the callback if
    the random value is greater than or equal to `0.5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Chain a final `then` call after the previous one. Log out a different message
    if the argument is `true` or `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are lucky, you''ll see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fa6229fe-69df-45ab-8719-cbe79bcfc45a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are unlucky, we''ll see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4cc84fb5-4ee0-4b96-ab5e-7c04286e2736.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen how to use `then` to wait for the result of a promise. Here,
    we are doing the same thing multiple times in a row. This is called a promise
    chain. After the promise chain is started with the new promise, all of the subsequent
    links in the promise chain return promises as well. That is, the callback of each
    `then` function is `resolve` like another promise.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using `Promise.all` to resolve multiple Promises
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle errors with `Promise.catch`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating `finally` with a final `Promise.then` call
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting a Promise chain with Promise.resolve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter's preceding recipes, we've been creating new `promise` objects
    with the constructor. This gets the jobs done, but it creates a problem. The first
    callback in the promise chain has a different shape than the subsequent callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: In the first callback, the arguments are the `resolve` and `reject` functions
    that trigger the subsequent `then` or `catch` callbacks. In subsequent callbacks,
    the returned value is propagated down the chain, and thrown errors are captured
    by `catch` callbacks. This difference adds mental overhead. It would be nice to
    have all of the functions in the chain behave in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to use `Promise.resolve` to start a promise chain.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `3-05-starting-with-resolve`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` file that calls `Promise.resolve` with an empty object as
    the first argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Chain a `then` call off of `resolve`, and attach rocket boosters to the passed
    object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a final `then` call to the chain that lets you know when the `boosters`
    have been added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser: `http://localhost:8000/`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98a3cf67-7a70-4730-8851-b09312f9362b.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Promise.resolve` creates a new promise that resolves the value passed to it.
    The subsequent `then` method will receive that resolved value as it''s argument.
    This method can seem a little roundabout but can be very helpful for composing
    asynchronous functions. In effect, the constituents of the promise chain don''t
    need to be aware that they are in the chain (including the first step). This makes
    transitioning from code that doesn''t use promises to code that does much easier.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Promise.all to resolve multiple promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've seen how to use promises to perform asynchronous operations in
    sequence. This is useful when the individual steps are long-running operations.
    However, this might not always be the more efficient configuration. Quite often,
    we can perform multiple asynchronous operations at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how to use `Promise.all` to start multiple asynchronous
    operations, without waiting for the previous one to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `3-06-using-promise-all`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` file that creates an object named `rocket`, and calls `Promise.all`
    with an empty array as the first argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `addBoosters` that creates an object with `boosters`
    to an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `performGuidanceDiagnostic` that returns a promise
    of a successfully completed task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `loadCargo` that adds a payload to the `cargoBay`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `Promise.resolve` to pass the `rocket` object to these functions within
    `Promise.all`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Attach a `then` call to the chain and log that the rocket is ready for launch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b12bfb42-682b-46de-8112-3776f098ffc0.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Promise.all` is similar to `Promise.resolve`; the arguments are resolved as
    promises. The difference is that instead of a single result, `Promise.all` accepts
    an **iterable** argument, each member of which is resolved individually.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you can see that each of the promises is initiated
    immediately. Two of them are able to complete while `performGuidanceDiagnostic`
    continues. The promise returned by `Promise.all` is fulfilled when all the constituent
    promises have been resolved.
  prefs: []
  type: TYPE_NORMAL
- en: The results of the promises are combined into an array and propagated down the
    chain. You can see that three references to `rocket` are packed into the `results`
    argument. And you can see that the operations of each promise have been performed
    on the resulting object.
  prefs: []
  type: TYPE_NORMAL
- en: There's more
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have guessed, the results of the constituent promises don''t have
    to return the same value. This can be useful, for example, when performing multiple
    independent network requests. The index of the result for each promise corresponds
    to the index of the operation within the argument to `Promise.all`. In these cases,
    it can be useful to use array destructuring to name the argument of the `then`
    callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Handling errors with Promise.catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous recipe, we saw how to fulfill a promise with an error state using
    `reject`, and we saw that this triggers the next `catch` callback in the promise
    chain. Because promises are relatively easy to compose, we need to be able to
    handle errors that are reported in different ways. Luckily promises are able to
    handle this seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how `Promises.catch` can handle errors that are reported
    by being thrown or through rejection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `3-07-handle-errors-promise-catch`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` file with a `main` function that creates an object named
    `rocket`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function `addBoosters` that throws an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function `performGuidanceDiagnostic` that returns a promise that rejects
    an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `Promise.resolve` to pass the rocket object to these functions, and chain
    a `catch` off each of them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4b439577-7ac8-4d07-8f84-a3c6163bea50.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw before, when a promise is fulfilled in a rejected state, the callback
    of the `catch` functions is triggered. In the preceding recipe, we see that this
    can happen when the `reject` method is called (as with `performGuidanceDiagnostic`).
    It also happens when a function in the chain throws an error (as will `addBoosters`).
  prefs: []
  type: TYPE_NORMAL
- en: This has similar benefit to how `Promise.resolve` can normalize asynchronous
    functions. This handling allows asynchronous functions to not know about the promise
    chain, and announce error states in a way that is familiar to developers who are
    new to promises.
  prefs: []
  type: TYPE_NORMAL
- en: This makes expanding the use of promises much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Simulating finally with the promise API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous recipe, we saw how `catch` can be used to handle errors, whether
    a promise has rejected, or a callback has thrown an error. Sometimes, it is desirable
    to execute code whether or not an error state has been detected. In the context
    of `try`/`catch` blocks, the `finally` block can be used for this purpose. We
    have to do a little more work to get the same behavior when working with promises
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we'll see how a final `then` call to execute some code in both
    successful and failing fulfillment states.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe assumes that you already have a workspace that allows you to create
    and run ES modules in your browser. If you don't, please see the first two chapters.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open your command-line application and navigate to your workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new folder named `3-08-simulating-finally`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy or create an `index.html` that loads and runs a `main` function from `main.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `main.js` file with a `main` function that logs out messages for before
    and after promise creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a function named `addBoosters` that throws an error if its first parameter
    is `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `Promise.resolve` to pass a Boolean value that is `true` if a random number
    is greater than `0.5` to `addBoosters`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `then` function to the chain that logs a success message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `catch` to the chain and log out the error if thrown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a `then` after the `catch`, and log out that we need to make an announcement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Start your Python web server and open the following link in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8000/`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you are lucky and the boosters are added successfully, you''ll see the following
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8ee3df3b-4965-4107-98e1-3296c2962066.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you are unlucky, you''ll see an error message like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a58e2a09-c5ad-4405-bf52-42ac53443e84.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can see in the preceding output that whether or not the asynchronous function
    completes in an error state, the last `then` callback is executed. This is possible
    because the `catch` method doesn't stop the promise chain. It simply catches any
    error states from the previous links in the chain, and then propagates a new value
    forward.
  prefs: []
  type: TYPE_NORMAL
- en: The final `then` is then protected from being bypassed by an error state by
    this `catch`. And so, regardless of the fulfillment state of prior links in the
    chain, we can be sure that the callback of this final `then` will be executed.
  prefs: []
  type: TYPE_NORMAL
