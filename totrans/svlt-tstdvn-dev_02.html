<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-37"><a id="_idTextAnchor036"/>2</h1>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Introducing the Red-Green-Refactor Workflow</h1>
<p>This chapter introduces the <strong class="bold">Red-Green-Refactor</strong> workflow, which is at the heart of <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>). You’ll use it to write a first Svelte component, including a unit-test suite that specifies the behavior of the component.</p>
<p>This workflow benefits you because it provides a structure for implementing software. It makes it less likely that you’ll implement the wrong thing. It also helps you to avoid overcomplicating solutions.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Understanding the Red-Green-Refactor workflow</li>
<li>Thinking ahead with up-front design</li>
<li>Writing a failing test</li>
<li>Making it pass</li>
<li>Refactoring the tests</li>
<li>Adding styles to the component</li>
</ul>
<p>By the end of the chapter, you’ll have written your first pieces of Svelte functionality using TDD.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start</a>.</p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Understanding the Red-Green-Refactor workflow</h1>
<p>The Red-Green-Refactor workflow (or cycle) is a <a id="_idIndexMarker045"/>process that defines the mechanics of how you write software. It has enduring appeal because it has helped so many developers be more productive by providing structure to their day-to-day jobs.</p>
<p>You do your work by making repeated cycles through the workflow until your software is complete. Red-Green-Refactor also lends itself to pairs and groups of developers working together, because it gives you a way to organize your discussion and decision making.</p>
<p><em class="italic">Figure 2</em><em class="italic">.1</em> shows the workflow. It has three parts:</p>
<ul>
<li><strong class="bold">Red</strong>: To<a id="_idIndexMarker046"/> begin, you write a failing test. This sounds easier than it is, because first you have to know <em class="italic">what</em> you’re intending to build.</li>
<li><strong class="bold">Green</strong>: Once<a id="_idIndexMarker047"/> you have a failing test, you make it pass. You strive to find the <em class="italic">shortest</em> route possible to solve the test.</li>
<li><strong class="bold">Refactor</strong>: Make <a id="_idIndexMarker048"/>it good. Take a step back and think about the design. Even though you took the shortest route there, did you make a mess? Are there any abstractions beginning to appear that can be made real, or are there existing abstractions that need to be adjusted?</li>
</ul>
<div><div><img alt="Figure 2.1 – The Red-Green-Refactor workflow" height="652" src="img/Figure_2.1_B19611.jpg" width="740"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The Red-Green-Refactor workflow</p>
<p>This gives you <a id="_idIndexMarker049"/>a structure for building software. You start from nothing, and by repeating the cycle, you build up your software product, test by test, until it does something useful. (Of course, you need to know your trajectory, but that is part of the first step, as we’ll soon see.)</p>
<p>We’ll look at the Red and Green steps in more detail in the two remaining parts of this chapter. First, we’ll write some code to lend as an example, and then we’ll discuss what we’ve done.</p>
<p>The third part, Refactor, is more easily explained when we have more code to play with, so we’ll focus on that in <a href="B19611_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Saving Form Data</em>, and <a href="B19611_05.xhtml#_idTextAnchor070"><em class="italic">Chapter 5</em></a>, <em class="italic">Validating </em><em class="italic">Form Data</em>.</p>
<p>You’ve now covered the theory behind Red-Green-Refactor. Let’s try it out, shall we?</p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Thinking ahead with some up-front design</h1>
<p>If you imagine<a id="_idIndexMarker050"/> that we are a team of developers embarking on a new project, it would be very unlikely that we’d start a project without a project brief – you can’t just start writing tests with no purpose.</p>
<p>The goal of this section, therefore, is two things:</p>
<ul>
<li>Discuss, at a high level, what we’ll build in the first part of the book</li>
<li>Learn just enough so that we can write our first failing test</li>
</ul>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>The Birthdays application</h2>
<p>We will <a id="_idIndexMarker051"/>build a web application called <em class="italic">Birthdays</em> that manages a list of people and their birthdays.</p>
<p><em class="italic">Figure 2</em><em class="italic">.2</em> shows<a id="_idIndexMarker052"/> this application in action. The main page is a list of birthdays that have been stored. At the bottom there’s a form to add a new birthday, which is stored as a person’s name (just a single text field) and their date of birth.</p>
<div><div><img alt="Figure 2.2 – The Birthdays application" height="738" src="img/Figure_2.2_B19611.jpg" width="1064"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The Birthdays application</p>
<p>The user accesses this application by navigating to the <code>/birthdays</code> URL of our website.</p>
<p>In this chapter, we’ll<a id="_idIndexMarker053"/> focus on building a Svelte component that displays each birthday in a list. It can be used like this:</p>
<pre class="source-code">
&lt;Birthday name={name} dob={dob} /&gt;</pre>
<p>We can start <a id="_idIndexMarker054"/>with a test that specifies what this <code>Birthday</code> component will do with its <code>name</code> prop.</p>
<p class="callout-heading">Up-front design and TDD</p>
<p class="callout">The Red part of the workflow states <em class="italic">write a failing test</em>. Okay, but what test? In fact, every time you start the Red cycle, you should be thinking of your trajectory. What do we need next? What did we learn about our design? This is the <em class="italic">up-front design</em> that you should be doing before each test.</p>
<p class="callout">The trick, however, is doing <em class="italic">just enough</em> to know for certain what test you’re writing. You don’t need to have the whole system mapped out.</p>
<p>This is all the up-front design we need to do at this point. We know what we can make a start on – a check that the component displays the name.</p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Writing a failing test</h1>
<p>In this<a id="_idIndexMarker055"/> section, you’ll write your first unit test for the Vitest test runner.</p>
<p>Create a new file named <code>src/routes/birthdays/Birthday.test.js</code> and start with the following <code>import</code> statements:</p>
<pre class="source-code">
import { describe, it, expect } from 'vitest';
import {
  render,
  screen
} from '@testing-library/svelte';
import Birthday from './Birthday.svelte';</pre>
<p>The <code>describe</code> function is used to group tests into a suite of tests. Every test file (such as <code>Birthday.test.js</code>) will have at least one <code>describe</code> block. These blocks can also be nested; in future chapters, we’ll look at a couple of scenarios where you’ll want to do this. For example, in <a href="B19611_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Saving Form Data</em>, you’ll use them to group tests according to the individual form fields that appear within an HTML form.</p>
<p>The <code>it</code> function<a id="_idIndexMarker056"/> is a basic function for defining unit tests, and it is named this way so that the test description reads like a specification. The function is designed to be fluent, meaning its invocations should be read like plain English. That’s generally something we aim for when writing tests, since it helps them to read like specifications.</p>
<p>The <code>expect</code> function is the one that we use to check our software did what we <em class="italic">expected</em> it to do.</p>
<p>The <code>render</code> and <code>screen</code> functions help us manipulate the <code>render</code> will output the component result into the current DOM document, and following that call, <code>screen</code> gives us a number of locator functions for finding DOM elements.</p>
<p>The final import is for the <code>Birthday</code> component. This component doesn’t exist yet. In fact, the file doesn’t exist yet. This is intentional. Notice how we’ve already made design choices: where the file should reside, what it’s called, and what the component is named.</p>
<p class="callout-heading">Design discussions at the unit level</p>
<p class="callout">If we were working together as a group, we’d have had a discussion about all these decisions. Although it might seem obvious, the TDD workflow gives us space to discuss these issues freely with our teammates.</p>
<p class="callout">Naming things is hard. That’s why it really helps to discuss the naming. One thing I’ve learned about myself is that when I discuss a difficult variable name with others, we always come up with a better name than my own first choice.</p>
<p class="callout">Contrast this with being a solo developer, where you’d have your work reviewed after you’d completed it, perhaps packaged beautifully in a pull request. Imagine having done all the work only to be told later on by your teammates: <em class="italic">I think this name could be improved…</em> Frustrating, right? Having the discussion up front means you save yourself all that emotional turmoil later on.</p>
<p>Let’s continue <a id="_idIndexMarker058"/>with writing the test. The first thing we need is the <code>describe</code> block and the <code>it</code> test description. Add the following just below the <code>import</code> definitions:</p>
<pre class="source-code">
describe('Birthday', () =&gt; {
  it('displays the name of the person', () =&gt; {
  });
});</pre>
<p>See how the descriptions given to the <code>describe</code> and <code>it</code> functions form a plain English sentence? <em class="italic">Birthday displays the name of </em><em class="italic">the person</em>.</p>
<p>Now we can fill out the test:</p>
<pre class="source-code">
describe('Birthday', () =&gt; {
  it('displays the name of the person', () =&gt; {
<strong class="bold">    render(Birthday, { name: 'Hercules' });</strong>
  });
});</pre>
<p>The <code>render</code> call takes our <code>Birthday</code> component together with the <code>name</code> prop passed in. It will mount the <code>Birthday</code> component into the DOM, ready for us to check its result.</p>
<p>Next, it’s time for the assertion. Complete the test with a call to the <code>expect</code> function, shown in the following code block:</p>
<pre class="source-code">
describe('Birthday', () =&gt; {
  it('displays the name of the person', () =&gt; {
    render(Birthday, { name: 'Hercules' });
<strong class="bold">    expect(</strong>
<strong class="bold">      screen.queryByText('Hercules')</strong>
<strong class="bold">    ).toBeVisible();</strong>
  });
});</pre>
<p>There are a<a id="_idIndexMarker059"/> couple of important things to note in this expectation.</p>
<p>First, note the use of the locator, <code>screen.queryByText</code>. The <code>screen</code> object has a whole bunch of query functions like this, all designed to find something individual elements in the DOM. We will uncover the common query functions as the book progresses. The <code>queryByText</code> function searches for the provided text and returns <code>null</code> if it isn’t anywhere to be found.</p>
<p class="callout-heading">queryBy versus getBy query function variants</p>
<p class="callout">If you have experience with Testing Library, you’ll know that each of the query functions has a <code>getBy</code> and <code>queryBy</code> variant. When I’m using TDD, I use <code>queryBy</code> in the first test that introduces a new element. That makes it clear that I don’t expect the element to exist yet. But once that test is green (and passing), subsequent tests can use <code>getBy</code>, which throws an exception if the element isn’t found. This helps make it clear that this test depends on a previous test to prove the existence of the element.</p>
<p>The other important thing<a id="_idIndexMarker060"/> is the <code>toBeVisible</code> function call that’s chained off the <code>expect</code> function call. This checks that whatever we got in the first call is visible in the DOM document.</p>
<p>If you’re familiar with Testing Library, you might be aware that there’s a more functionally appropriate matcher that we could have used here. We could have used <code>not.toBeNull</code>, like this:</p>
<pre class="source-code">
expect(
  screen.queryByText('Hercules')
).not.toBeNull();</pre>
<p>I say this is more <em class="italic">functionally appropriate</em> because the <code>queryByText</code> query function will return <code>null</code> if it doesn’t find the text on the page, and that’s what we’re really interested in here.</p>
<p>The reason I prefer <code>toBeVisible</code> is that it makes the test more readable, continuing with the theme of fluent, plain English matcher statements. Of course, it’s also important to know what the failure messages look like when the test fails, which we’re about to see.</p>
<p>The final step<a id="_idIndexMarker061"/> of the Red stage is watching the test fail. Go ahead and run it now, either in your IDE or on the Terminal. (If you followed the instructions for setting up in <a href="B19611_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting up for Testing</em>, you will be able to run tests with either the <code>v </code>shell command or <code>npm </code><code>run test:unit</code>.)</p>
<p>You should see output like the following:</p>
<pre class="source-code">
 FAIL  src/routes/birthdays/Birthday.test.js [ src/routes/birthdays/Birthday.test.js ]
Error: Failed to load url ./Birthday.svelte (resolved id: ./Birthday.svelte). Does the file exist?</pre>
<p>This isn’t actually a test failure! It’s telling us the file we imported doesn’t exist. This is the time to create it.</p>
<p>Go ahead and simply create a blank file at the <code>src/routes/birthdays/Birthday.svelte</code> location.</p>
<p>Then, rerun the tests. What happens?</p>
<pre class="source-code">
 FAIL  src/routes/birthdays/Birthday.test.js &gt; Birthday &gt; displays the name of the person
Error: expect(received).toBeVisible()
received value must be an HTMLElement or an SVGElement.
 ❯ src/routes/birthdays/Birthday.test.js:13:5
     11|   expect(
     12|    screen.queryByText('Hercules')
     13|   ).toBeVisible();
       |     ^
     14|  });
     15| });</pre>
<p>Perfect – we <a id="_idIndexMarker062"/>have a test failure! Note the cryptic message, <code>received value must be an HTMLElement or an SVGElement</code>. If we had instead used the <code>not.toBeNull</code> matcher, we would have seen something less cryptic. However, I think the test is simple enough that it’s clear what’s going on – especially because of this line:</p>
<pre class="source-code">
Error: expect(received).toBeVisible()</pre>
<p>This section has shown you how you can write a failing test using the basic <code>describe</code>, <code>it</code>, and <code>expect</code> functions. You’ve also seen how you can use the test runner to drive some of the plumbing work, such as creating files.</p>
<p>That completes the Red portion of the cycle. Next up: Green.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Making it pass</h1>
<p>In this <a id="_idIndexMarker063"/>section, we’ll make a very simple change to make the test pass, and then we’ll repeat the cycle again with a second test.</p>
<p>To make this test pass, add the following content to the <code>src/routes/birthdays/Birthday.svelte</code> file:</p>
<pre class="source-code">
&lt;script&gt;
  export let name;
&lt;/script&gt;
&lt;span&gt;&lt;strong&gt;{name}&lt;/strong&gt;&lt;/span&gt;</pre>
<p>Rerun your <a id="_idIndexMarker064"/>tests now, and you should see the following output from the Vitest test runner (you’ll see the tests from <a href="B19611_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Setting up for Testing</em>, are still listed here):</p>
<pre class="source-code">
 ✓ src/routes/birthdays/Birthday.test.js (1)
   ✓ Birthday (1)
     ✓ displays the name of the person
 ✓ src/index.test.js (3)
   ✓ sum test (3)
     ✓ adds 1 + 2 to equal 3
     ✓ renders hello into the document
     ✓ renders hello, svelte
 Test Files  2 passed (2)
      Tests  4 passed (4)
   Start at  11:45:47
   Duration  1.60s (transform 503ms, setup 306ms, collect 272ms, tests 63ms)</pre>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Repeating the process</h2>
<p>Let’s go ahead and add a next step for the <code>dob</code> prop. Back in the <code>src/routes/birthdays/Birthday.test.js</code> file, add this test, just below the original test and still within the <code>describe</code> block:</p>
<pre class="source-code">
it('displays the date of birth', () =&gt; {
  render(Birthday, { dob: '1994-02-02' });
  expect(
    screen.queryByText('1994-02-02')
  ).toBeVisible();
});</pre>
<p>Make sure<a id="_idIndexMarker065"/> to run your test and watch it fail. Then, to make it pass, make the following additions to <code>src/routes/birthdays/Birthday.svelte</code>:</p>
<pre class="source-code">
&lt;script&gt;
  export let name;
<strong class="bold">  export let dob;</strong>
&lt;/script&gt;
&lt;span&gt;&lt;strong&gt;{name}&lt;/strong&gt;&lt;/span&gt;
<strong class="bold">&lt;span&gt;{dob}&lt;/span&gt;</strong></pre>
<p>Run the tests again, and you should see both are now green. However, there are some warnings:</p>
<pre class="source-code">
stderr | src/routes/birthdays/Birthday.test.js &gt; Birthday &gt; displays the name of the person
&lt;Birthday&gt; was created without expected prop 'dob'
stderr | src/routes/birthdays/Birthday.test.js &gt; Birthday &gt; displays the date of birth
&lt;Birthday&gt; was created without expected prop 'name'
 ✓ src/routes/birthdays/Birthday.test.js (2)
   ✓ Birthday (2)
     ✓ displays the name of the person
     ✓ displays the date of birth</pre>
<p>We’ll fix those warnings in the next section, along with addressing a couple of other issues.</p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Refactoring the tests</h1>
<p>In this section, we’ll <a id="_idIndexMarker066"/>look at some of the refactoring work we can do before we start thinking about the next feature. We’ll start by fixing the test warnings from the last section, then we’ll add a third test as a completeness test, and we’ll finish by adding some styles.</p>
<p class="callout-heading">Refactoring and changing behavior</p>
<p class="callout">The usual definition of refactoring is <em class="italic">any internal change that does not affect external behavior</em>. It is a bit of a stretch to include CSS style changes in this, or indeed changes that remove warnings. But I find that early on in a project, there are always little changes such as these ones that need to be made. The key point is that your test suite is <em class="italic">green</em> and remains <em class="italic">green</em> throughout.</p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Cleaning up warnings</h2>
<p>It’s important <a id="_idIndexMarker067"/>to clean up any warnings as they appear. That’s because without doing this, the test runner output becomes full of noise. We want the output to be as short as possible so that it’s quick to decipher any problems that occur.</p>
<p>In the <code>src/routes/birthdays/Birthday.test.js</code> file, add a new definition named <code>exampleBirthday</code> at the top of the <code>describe</code> block:</p>
<pre class="source-code">
describe('Birthday', () =&gt; {
  const exampleBirthday = {
    name: 'Ares',
    dob: '1996-03-03'
  };
  ...
});</pre>
<p>Then, update the first<a id="_idIndexMarker068"/> test to include this variable as the <em class="italic">base</em> props that are passed to the component:</p>
<pre class="source-code">
it('displays the name of the person', () =&gt; {
  render(Birthday, {
    <strong class="bold">...exampleBirthday,</strong>
    name: 'Hercules'
  });
  ...
});</pre>
<p>Now update the second test, like this:</p>
<pre class="source-code">
it('displays the date of birth', () =&gt; {
  render(Birthday, <strong class="bold">{</strong>
    <strong class="bold">...exampleBirthday,</strong>
    dob: '1994-02-02'
  });
  ...
});</pre>
<p>If you run your tests now, you should see the warnings have disappeared and the tests still pass.</p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Adding a third test to triangulate</h2>
<p>What <a id="_idIndexMarker069"/>happens if you update the <code>Birthday.svelte</code> file to have hardcoded values like this?</p>
<pre class="source-code">
&lt;span&gt;&lt;strong&gt;Hercules&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;1994-02-02&lt;/span&gt;</pre>
<p>Go ahead and try it; you’ll find that your tests still pass.</p>
<p>In fact, your tests <a id="_idIndexMarker070"/>do not protect against hardcoding. This highlights an interesting facet of TDD. When we’re building software guided by tests, we always aim to build the simplest thing that could possibly work.</p>
<p>To move beyond hardcoded values, we can add a second test for each individual property. Add this test to the test suite:</p>
<pre class="source-code">
it('displays the name of another person', () =&gt; {
  render(Birthday, {
    ...exampleBirthday,
    name: 'Athena'
  });
  expect(
    screen.queryByText('Athena')
  ).toBeVisible();
});</pre>
<p>You’ll see that the hardcoded version no longer works. The simplest way to get both of these tests working is to simply output the <code>name</code> prop value passed in.</p>
<p>This section has covered a little bit of the Refactor step. There will be plenty more refactoring work as the book progresses.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Adding styles to the component</h1>
<p>Finally, you <a id="_idIndexMarker071"/>can add the following <code>&lt;style&gt;</code> block to the <code>Birthday.svelte</code> file, which completes the <code>Birthday</code> component and means you’ll be ready to display it on a page, which you’ll do in the next chapter:</p>
<pre class="source-code">
&lt;script&gt;
  export let name;
  export let dob;
&lt;/script&gt;
&lt;span&gt;&lt;strong&gt;{name}&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;{dob}&lt;/span&gt;
<strong class="bold">&lt;style&gt;</strong>
<strong class="bold">  span {</strong>
<strong class="bold">    display: inline-block;</strong>
<strong class="bold">    width: 100px;</strong>
<strong class="bold">  }</strong>
<strong class="bold">&lt;/style&gt;</strong></pre>
<p>You can avoid <a id="_idIndexMarker072"/>writing unit tests for CSS since that is static information. Unit tests are specifically about behavior: what happens when this thing or that thing changes, or a different <code>name</code> prop is passed in?</p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Summary</h1>
<p>This chapter has taken a detailed look at the steps involved in the Red-Green-Refactor workflow. You have seen how much thinking is involved in every single step, and how the TDD process provides a scaffold for both solo work and work as a team.</p>
<p>You have also seen how to create a Svelte component using TDD to write a unit test for the Vitest test runner.</p>
<p>The value of this kind of critical thinking is that it will help you map out your intended work from start to finish, removing the fear of going down a wrong path or getting lost. If you take time to practice this workflow, it will soon become second nature.</p>
<p>In the next chapter, we’ll introduce Playwright testing, and you’ll build a page to hold the <code>Birthday</code> component.</p>
</div>
</div></body></html>