<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer014">
<h1 class="chapter-number" id="_idParaDest-37"><a id="_idTextAnchor036"/>2</h1>
<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Introducing the Red-Green-Refactor Workflow</h1>
<p>This chapter introduces the <strong class="bold">Red-Green-Refactor</strong> workflow, which is at the heart of <strong class="bold">Test-Driven Development</strong> (<strong class="bold">TDD</strong>). You’ll use it to write a first Svelte component, including a unit-test suite that specifies the behavior of <span class="No-Break">the component.</span></p>
<p>This workflow benefits you because it provides a structure for implementing software. It makes it less likely that you’ll implement the wrong thing. It also helps you to avoid <span class="No-Break">overcomplicating solutions.</span></p>
<p>This chapter covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding the <span class="No-Break">Red-Green-Refactor workflow</span></li>
<li>Thinking ahead with <span class="No-Break">up-front design</span></li>
<li>Writing a <span class="No-Break">failing test</span></li>
<li>Making <span class="No-Break">it pass</span></li>
<li>Refactoring <span class="No-Break">the tests</span></li>
<li>Adding styles to <span class="No-Break">the component</span></li>
</ul>
<p>By the end of the chapter, you’ll have written your first pieces of Svelte functionality <span class="No-Break">using TDD.</span></p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor038"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter02/Start</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Understanding the Red-Green-Refactor workflow</h1>
<p>The Red-Green-Refactor workflow (or cycle) is a <a id="_idIndexMarker045"/>process that defines the mechanics of how you write software. It has enduring appeal because it has helped so many developers be more productive by providing structure to their <span class="No-Break">day-to-day jobs.</span></p>
<p>You do your work by making repeated cycles through the workflow until your software is complete. Red-Green-Refactor also lends itself to pairs and groups of developers working together, because it gives you a way to organize your discussion and <span class="No-Break">decision making.</span></p>
<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.1</em> shows the workflow. It has <span class="No-Break">three parts:</span></p>
<ul>
<li><strong class="bold">Red</strong>: To<a id="_idIndexMarker046"/> begin, you write a failing test. This sounds easier than it is, because first you have to know <em class="italic">what</em> you’re intending <span class="No-Break">to build.</span></li>
<li><strong class="bold">Green</strong>: Once<a id="_idIndexMarker047"/> you have a failing test, you make it pass. You strive to find the <em class="italic">shortest</em> route possible to solve <span class="No-Break">the test.</span></li>
<li><strong class="bold">Refactor</strong>: Make <a id="_idIndexMarker048"/>it good. Take a step back and think about the design. Even though you took the shortest route there, did you make a mess? Are there any abstractions beginning to appear that can be made real, or are there existing abstractions that need to <span class="No-Break">be adjusted?</span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer012">
<img alt="Figure 2.1 – The Red-Green-Refactor workflow" height="652" src="image/Figure_2.1_B19611.jpg" width="740"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The Red-Green-Refactor workflow</p>
<p>This gives you <a id="_idIndexMarker049"/>a structure for building software. You start from nothing, and by repeating the cycle, you build up your software product, test by test, until it does something useful. (Of course, you need to know your trajectory, but that is part of the first step, as we’ll <span class="No-Break">soon see.)</span></p>
<p>We’ll look at the Red and Green steps in more detail in the two remaining parts of this chapter. First, we’ll write some code to lend as an example, and then we’ll discuss what <span class="No-Break">we’ve done.</span></p>
<p>The third part, Refactor, is more easily explained when we have more code to play with, so we’ll focus on that in <a href="B19611_04.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Saving Form Data</em>, and <a href="B19611_05.xhtml#_idTextAnchor070"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Validating </em><span class="No-Break"><em class="italic">Form Data</em></span><span class="No-Break">.</span></p>
<p>You’ve now covered the theory behind Red-Green-Refactor. Let’s try it out, <span class="No-Break">shall we?</span></p>
<h1 id="_idParaDest-41"><a id="_idTextAnchor040"/>Thinking ahead with some up-front design</h1>
<p>If you imagine<a id="_idIndexMarker050"/> that we are a team of developers embarking on a new project, it would be very unlikely that we’d start a project without a project brief – you can’t just start writing tests with <span class="No-Break">no purpose.</span></p>
<p>The goal of this section, therefore, is <span class="No-Break">two things:</span></p>
<ul>
<li>Discuss, at a high level, what we’ll build in the first part of <span class="No-Break">the book</span></li>
<li>Learn just enough so that we can write our first <span class="No-Break">failing test</span></li>
</ul>
<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>The Birthdays application</h2>
<p>We will <a id="_idIndexMarker051"/>build a web application called <em class="italic">Birthdays</em> that manages a list of people and <span class="No-Break">their birthdays.</span></p>
<p><span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.2</em> shows<a id="_idIndexMarker052"/> this application in action. The main page is a list of birthdays that have been stored. At the bottom there’s a form to add a new birthday, which is stored as a person’s name (just a single text field) and their date <span class="No-Break">of birth.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer013">
<img alt="Figure 2.2 – The Birthdays application" height="738" src="image/Figure_2.2_B19611.jpg" width="1064"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The Birthdays application</p>
<p>The user accesses this application by navigating to the <strong class="source-inline">/birthdays</strong> URL of <span class="No-Break">our website.</span></p>
<p>In this chapter, we’ll<a id="_idIndexMarker053"/> focus on building a Svelte component that displays each birthday in a list. It can be used <span class="No-Break">like this:</span></p>
<pre class="source-code">
&lt;Birthday name={name} dob={dob} /&gt;</pre>
<p>We can start <a id="_idIndexMarker054"/>with a test that specifies what this <strong class="source-inline">Birthday</strong> component will do with its <span class="No-Break"><strong class="source-inline">name</strong></span><span class="No-Break"> prop.</span></p>
<p class="callout-heading">Up-front design and TDD</p>
<p class="callout">The Red part of the workflow states <em class="italic">write a failing test</em>. Okay, but what test? In fact, every time you start the Red cycle, you should be thinking of your trajectory. What do we need next? What did we learn about our design? This is the <em class="italic">up-front design</em> that you should be doing before <span class="No-Break">each test.</span></p>
<p class="callout">The trick, however, is doing <em class="italic">just enough</em> to know for certain what test you’re writing. You don’t need to have the whole system <span class="No-Break">mapped out.</span></p>
<p>This is all the up-front design we need to do at this point. We know what we can make a start on – a check that the component displays <span class="No-Break">the name.</span></p>
<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Writing a failing test</h1>
<p>In this<a id="_idIndexMarker055"/> section, you’ll write your first unit test for the Vitest <span class="No-Break">test runner.</span></p>
<p>Create a new file named <strong class="source-inline">src/routes/birthdays/Birthday.test.js</strong> and start with the following <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> statements:</span></p>
<pre class="source-code">
import { describe, it, expect } from 'vitest';
import {
  render,
  screen
} from '@testing-library/svelte';
import Birthday from './Birthday.svelte';</pre>
<p>The <strong class="source-inline">describe</strong> function is used to group tests into a suite of tests. Every test file (such as <strong class="source-inline">Birthday.test.js</strong>) will have at least one <strong class="source-inline">describe</strong> block. These blocks can also be nested; in future chapters, we’ll look at a couple of scenarios where you’ll want to do this. For example, in <a href="B19611_04.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Saving Form Data</em>, you’ll use them to group tests according to the individual form fields that appear within an <span class="No-Break">HTML form.</span></p>
<p>The <strong class="source-inline">it</strong> function<a id="_idIndexMarker056"/> is a basic function for defining unit tests, and it is named this way so that the test description reads like a specification. The function is designed to be fluent, meaning its invocations should be read like plain English. That’s generally something we aim for when writing tests, since it helps them to read <span class="No-Break">like specifications.</span></p>
<p>The <strong class="source-inline">expect</strong> function is the one that we use to check our software did what we <em class="italic">expected</em> it <span class="No-Break">to do.</span></p>
<p>The <strong class="source-inline">render</strong> and <strong class="source-inline">screen</strong> functions help us manipulate the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) using<a id="_idIndexMarker057"/> our Svelte component: first, a call to <strong class="source-inline">render</strong> will output the component result into the current DOM document, and following that call, <strong class="source-inline">screen</strong> gives us a number of locator functions for finding <span class="No-Break">DOM elements.</span></p>
<p>The final import is for the <strong class="source-inline">Birthday</strong> component. This component doesn’t exist yet. In fact, the file doesn’t exist yet. This is intentional. Notice how we’ve already made design choices: where the file should reside, what it’s called, and what the component <span class="No-Break">is named.</span></p>
<p class="callout-heading">Design discussions at the unit level</p>
<p class="callout">If we were working together as a group, we’d have had a discussion about all these decisions. Although it might seem obvious, the TDD workflow gives us space to discuss these issues freely with <span class="No-Break">our teammates.</span></p>
<p class="callout">Naming things is hard. That’s why it really helps to discuss the naming. One thing I’ve learned about myself is that when I discuss a difficult variable name with others, we always come up with a better name than my own <span class="No-Break">first choice.</span></p>
<p class="callout">Contrast this with being a solo developer, where you’d have your work reviewed after you’d completed it, perhaps packaged beautifully in a pull request. Imagine having done all the work only to be told later on by your teammates: <em class="italic">I think this name could be improved…</em> Frustrating, right? Having the discussion up front means you save yourself all that emotional turmoil <span class="No-Break">later on.</span></p>
<p>Let’s continue <a id="_idIndexMarker058"/>with writing the test. The first thing we need is the <strong class="source-inline">describe</strong> block and the <strong class="source-inline">it</strong> test description. Add the following just below the <span class="No-Break"><strong class="source-inline">import</strong></span><span class="No-Break"> definitions:</span></p>
<pre class="source-code">
describe('Birthday', () =&gt; {
  it('displays the name of the person', () =&gt; {
  });
});</pre>
<p>See how the descriptions given to the <strong class="source-inline">describe</strong> and <strong class="source-inline">it</strong> functions form a plain English sentence? <em class="italic">Birthday displays the name of </em><span class="No-Break"><em class="italic">the person</em></span><span class="No-Break">.</span></p>
<p>Now we can fill out <span class="No-Break">the test:</span></p>
<pre class="source-code">
describe('Birthday', () =&gt; {
  it('displays the name of the person', () =&gt; {
<strong class="bold">    render(Birthday, { name: 'Hercules' });</strong>
  });
});</pre>
<p>The <strong class="source-inline">render</strong> call takes our <strong class="source-inline">Birthday</strong> component together with the <strong class="source-inline">name</strong> prop passed in. It will mount the <strong class="source-inline">Birthday</strong> component into the DOM, ready for us to check <span class="No-Break">its result.</span></p>
<p>Next, it’s time for the assertion. Complete the test with a call to the <strong class="source-inline">expect</strong> function, shown in the following <span class="No-Break">code block:</span></p>
<pre class="source-code">
describe('Birthday', () =&gt; {
  it('displays the name of the person', () =&gt; {
    render(Birthday, { name: 'Hercules' });
<strong class="bold">    expect(</strong>
<strong class="bold">      screen.queryByText('Hercules')</strong>
<strong class="bold">    ).toBeVisible();</strong>
  });
});</pre>
<p>There are a<a id="_idIndexMarker059"/> couple of important things to note in <span class="No-Break">this expectation.</span></p>
<p>First, note the use of the locator, <strong class="source-inline">screen.queryByText</strong>. The <strong class="source-inline">screen</strong> object has a whole bunch of query functions like this, all designed to find something individual elements in the DOM. We will uncover the common query functions as the book progresses. The <strong class="source-inline">queryByText</strong> function searches for the provided text and returns <strong class="source-inline">null</strong> if it isn’t anywhere to <span class="No-Break">be found.</span></p>
<p class="callout-heading">queryBy versus getBy query function variants</p>
<p class="callout">If you have experience with Testing Library, you’ll know that each of the query functions has a <strong class="source-inline">getBy</strong> and <strong class="source-inline">queryBy</strong> variant. When I’m using TDD, I use <strong class="source-inline">queryBy</strong> in the first test that introduces a new element. That makes it clear that I don’t expect the element to exist yet. But once that test is green (and passing), subsequent tests can use <strong class="source-inline">getBy</strong>, which throws an exception if the element isn’t found. This helps make it clear that this test depends on a previous test to prove the existence of <span class="No-Break">the element.</span></p>
<p>The other important thing<a id="_idIndexMarker060"/> is the <strong class="bold">matcher</strong>: the <strong class="source-inline">toBeVisible</strong> function call that’s chained off the <strong class="source-inline">expect</strong> function call. This checks that whatever we got in the first call is visible in the <span class="No-Break">DOM document.</span></p>
<p>If you’re familiar with Testing Library, you might be aware that there’s a more functionally appropriate matcher that we could have used here. We could have used <strong class="source-inline">not.toBeNull</strong>, <span class="No-Break">like this:</span></p>
<pre class="source-code">
expect(
  screen.queryByText('Hercules')
).not.toBeNull();</pre>
<p>I say this is more <em class="italic">functionally appropriate</em> because the <strong class="source-inline">queryByText</strong> query function will return <strong class="source-inline">null</strong> if it doesn’t find the text on the page, and that’s what we’re really interested <span class="No-Break">in here.</span></p>
<p>The reason I prefer <strong class="source-inline">toBeVisible</strong> is that it makes the test more readable, continuing with the theme of fluent, plain English matcher statements. Of course, it’s also important to know what the failure messages look like when the test fails, which we’re about <span class="No-Break">to see.</span></p>
<p>The final step<a id="_idIndexMarker061"/> of the Red stage is watching the test fail. Go ahead and run it now, either in your IDE or on the Terminal. (If you followed the instructions for setting up in <a href="B19611_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Setting up for Testing</em>, you will be able to run tests with either the <strong class="source-inline">v </strong>shell command or <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">run test:unit</strong></span><span class="No-Break">.)</span></p>
<p>You should see output like <span class="No-Break">the following:</span></p>
<pre class="source-code">
 FAIL  src/routes/birthdays/Birthday.test.js [ src/routes/birthdays/Birthday.test.js ]
Error: Failed to load url ./Birthday.svelte (resolved id: ./Birthday.svelte). Does the file exist?</pre>
<p>This isn’t actually a test failure! It’s telling us the file we imported doesn’t exist. This is the time to <span class="No-Break">create it.</span></p>
<p>Go ahead and simply create a blank file at the <span class="No-Break"><strong class="source-inline">src/routes/birthdays/Birthday.svelte</strong></span><span class="No-Break"> location.</span></p>
<p>Then, rerun the tests. <span class="No-Break">What happens?</span></p>
<pre class="source-code">
 FAIL  src/routes/birthdays/Birthday.test.js &gt; Birthday &gt; displays the name of the person
Error: expect(received).toBeVisible()
received value must be an HTMLElement or an SVGElement.
 ❯ src/routes/birthdays/Birthday.test.js:13:5
     11|   expect(
     12|    screen.queryByText('Hercules')
     13|   ).toBeVisible();
       |     ^
     14|  });
     15| });</pre>
<p>Perfect – we <a id="_idIndexMarker062"/>have a test failure! Note the cryptic message, <strong class="source-inline">received value must be an HTMLElement or an SVGElement</strong>. If we had instead used the <strong class="source-inline">not.toBeNull</strong> matcher, we would have seen something less cryptic. However, I think the test is simple enough that it’s clear what’s going on – especially because of <span class="No-Break">this line:</span></p>
<pre class="source-code">
Error: expect(received).toBeVisible()</pre>
<p>This section has shown you how you can write a failing test using the basic <strong class="source-inline">describe</strong>, <strong class="source-inline">it</strong>, and <strong class="source-inline">expect</strong> functions. You’ve also seen how you can use the test runner to drive some of the plumbing work, such as <span class="No-Break">creating files.</span></p>
<p>That completes the Red portion of the cycle. Next <span class="No-Break">up: Green.</span></p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor043"/>Making it pass</h1>
<p>In this <a id="_idIndexMarker063"/>section, we’ll make a very simple change to make the test pass, and then we’ll repeat the cycle again with a <span class="No-Break">second test.</span></p>
<p>To make this test pass, add the following content to the <span class="No-Break"><strong class="source-inline">src/routes/birthdays/Birthday.svelte</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let name;
&lt;/script&gt;
&lt;span&gt;&lt;strong&gt;{name}&lt;/strong&gt;&lt;/span&gt;</pre>
<p>Rerun your <a id="_idIndexMarker064"/>tests now, and you should see the following output from the Vitest test runner (you’ll see the tests from <a href="B19611_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Setting up for Testing</em>, are still <span class="No-Break">listed here):</span></p>
<pre class="source-code">
 ✓ src/routes/birthdays/Birthday.test.js (1)
   ✓ Birthday (1)
     ✓ displays the name of the person
 ✓ src/index.test.js (3)
   ✓ sum test (3)
     ✓ adds 1 + 2 to equal 3
     ✓ renders hello into the document
     ✓ renders hello, svelte
 Test Files  2 passed (2)
      Tests  4 passed (4)
   Start at  11:45:47
   Duration  1.60s (transform 503ms, setup 306ms, collect 272ms, tests 63ms)</pre>
<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Repeating the process</h2>
<p>Let’s go ahead and add a next step for the <strong class="source-inline">dob</strong> prop. Back in the <strong class="source-inline">src/routes/birthdays/Birthday.test.js</strong> file, add this test, just below the original test and still within the <span class="No-Break"><strong class="source-inline">describe</strong></span><span class="No-Break"> block:</span></p>
<pre class="source-code">
it('displays the date of birth', () =&gt; {
  render(Birthday, { dob: '1994-02-02' });
  expect(
    screen.queryByText('1994-02-02')
  ).toBeVisible();
});</pre>
<p>Make sure<a id="_idIndexMarker065"/> to run your test and watch it fail. Then, to make it pass, make the following additions <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">src/routes/birthdays/Birthday.svelte</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let name;
<strong class="bold">  export let dob;</strong>
&lt;/script&gt;
&lt;span&gt;&lt;strong&gt;{name}&lt;/strong&gt;&lt;/span&gt;
<strong class="bold">&lt;span&gt;{dob}&lt;/span&gt;</strong></pre>
<p>Run the tests again, and you should see both are now green. However, there are <span class="No-Break">some warnings:</span></p>
<pre class="source-code">
stderr | src/routes/birthdays/Birthday.test.js &gt; Birthday &gt; displays the name of the person
&lt;Birthday&gt; was created without expected prop 'dob'
stderr | src/routes/birthdays/Birthday.test.js &gt; Birthday &gt; displays the date of birth
&lt;Birthday&gt; was created without expected prop 'name'
 ✓ src/routes/birthdays/Birthday.test.js (2)
   ✓ Birthday (2)
     ✓ displays the name of the person
     ✓ displays the date of birth</pre>
<p>We’ll fix those warnings in the next section, along with addressing a couple of <span class="No-Break">other issues.</span></p>
<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Refactoring the tests</h1>
<p>In this section, we’ll <a id="_idIndexMarker066"/>look at some of the refactoring work we can do before we start thinking about the next feature. We’ll start by fixing the test warnings from the last section, then we’ll add a third test as a completeness test, and we’ll finish by adding <span class="No-Break">some styles.</span></p>
<p class="callout-heading">Refactoring and changing behavior</p>
<p class="callout">The usual definition of refactoring is <em class="italic">any internal change that does not affect external behavior</em>. It is a bit of a stretch to include CSS style changes in this, or indeed changes that remove warnings. But I find that early on in a project, there are always little changes such as these ones that need to be made. The key point is that your test suite is <em class="italic">green</em> and remains <span class="No-Break"><em class="italic">green</em></span><span class="No-Break"> throughout.</span></p>
<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Cleaning up warnings</h2>
<p>It’s important <a id="_idIndexMarker067"/>to clean up any warnings as they appear. That’s because without doing this, the test runner output becomes full of noise. We want the output to be as short as possible so that it’s quick to decipher any problems <span class="No-Break">that occur.</span></p>
<p>In the <strong class="source-inline">src/routes/birthdays/Birthday.test.js</strong> file, add a new definition named <strong class="source-inline">exampleBirthday</strong> at the top of the <span class="No-Break"><strong class="source-inline">describe</strong></span><span class="No-Break"> block:</span></p>
<pre class="source-code">
describe('Birthday', () =&gt; {
  const exampleBirthday = {
    name: 'Ares',
    dob: '1996-03-03'
  };
  ...
});</pre>
<p>Then, update the first<a id="_idIndexMarker068"/> test to include this variable as the <em class="italic">base</em> props that are passed to <span class="No-Break">the component:</span></p>
<pre class="source-code">
it('displays the name of the person', () =&gt; {
  render(Birthday, {
    <strong class="bold">...exampleBirthday,</strong>
    name: 'Hercules'
  });
  ...
});</pre>
<p>Now update the second test, <span class="No-Break">like this:</span></p>
<pre class="source-code">
it('displays the date of birth', () =&gt; {
  render(Birthday, <strong class="bold">{</strong>
    <strong class="bold">...exampleBirthday,</strong>
    dob: '1994-02-02'
  });
  ...
});</pre>
<p>If you run your tests now, you should see the warnings have disappeared and the tests <span class="No-Break">still pass.</span></p>
<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Adding a third test to triangulate</h2>
<p>What <a id="_idIndexMarker069"/>happens if you update the <strong class="source-inline">Birthday.svelte</strong> file to have hardcoded values <span class="No-Break">like this?</span></p>
<pre class="source-code">
&lt;span&gt;&lt;strong&gt;Hercules&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;1994-02-02&lt;/span&gt;</pre>
<p>Go ahead and try it; you’ll find that your tests <span class="No-Break">still pass.</span></p>
<p>In fact, your tests <a id="_idIndexMarker070"/>do not protect against hardcoding. This highlights an interesting facet of TDD. When we’re building software guided by tests, we always aim to build the simplest thing that could <span class="No-Break">possibly work.</span></p>
<p>To move beyond hardcoded values, we can add a second test for each individual property. Add this test to the <span class="No-Break">test suite:</span></p>
<pre class="source-code">
it('displays the name of another person', () =&gt; {
  render(Birthday, {
    ...exampleBirthday,
    name: 'Athena'
  });
  expect(
    screen.queryByText('Athena')
  ).toBeVisible();
});</pre>
<p>You’ll see that the hardcoded version no longer works. The simplest way to get both of these tests working is to simply output the <strong class="source-inline">name</strong> prop value <span class="No-Break">passed in.</span></p>
<p>This section has covered a little bit of the Refactor step. There will be plenty more refactoring work as the <span class="No-Break">book progresses.</span></p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor048"/>Adding styles to the component</h1>
<p>Finally, you <a id="_idIndexMarker071"/>can add the following <strong class="source-inline">&lt;style&gt;</strong> block to the <strong class="source-inline">Birthday.svelte</strong> file, which completes the <strong class="source-inline">Birthday</strong> component and means you’ll be ready to display it on a page, which you’ll do in the <span class="No-Break">next chapter:</span></p>
<pre class="source-code">
&lt;script&gt;
  export let name;
  export let dob;
&lt;/script&gt;
&lt;span&gt;&lt;strong&gt;{name}&lt;/strong&gt;&lt;/span&gt;
&lt;span&gt;{dob}&lt;/span&gt;
<strong class="bold">&lt;style&gt;</strong>
<strong class="bold">  span {</strong>
<strong class="bold">    display: inline-block;</strong>
<strong class="bold">    width: 100px;</strong>
<strong class="bold">  }</strong>
<strong class="bold">&lt;/style&gt;</strong></pre>
<p>You can avoid <a id="_idIndexMarker072"/>writing unit tests for CSS since that is static information. Unit tests are specifically about behavior: what happens when this thing or that thing changes, or a different <strong class="source-inline">name</strong> prop is <span class="No-Break">passed in?</span></p>
<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Summary</h1>
<p>This chapter has taken a detailed look at the steps involved in the Red-Green-Refactor workflow. You have seen how much thinking is involved in every single step, and how the TDD process provides a scaffold for both solo work and work as <span class="No-Break">a team.</span></p>
<p>You have also seen how to create a Svelte component using TDD to write a unit test for the Vitest <span class="No-Break">test runner.</span></p>
<p>The value of this kind of critical thinking is that it will help you map out your intended work from start to finish, removing the fear of going down a wrong path or getting lost. If you take time to practice this workflow, it will soon become <span class="No-Break">second nature.</span></p>
<p>In the next chapter, we’ll introduce Playwright testing, and you’ll build a page to hold the <span class="No-Break"><strong class="source-inline">Birthday</strong></span><span class="No-Break"> component.</span></p>
</div>
</div></body></html>