<html><head></head><body>
        

                            
                    <h1 class="header-title">The Importance of Good Code</h1>
                
            
            
                
<p>One thing that separates a good company from a great company is their processes. In a great company, everyone understands what is expected of them, what they can expect from others, the vision of the company, and the philosophy of the workplace. With that foundation, the staff has the freedom to be creative and innovate, working within the processes and boundaries set by the company.</p>
<p>When there are no processes, there is chaos. Developers wouldn't know what to expect— are the requirements and specifications documented? Where can I find them? They also wouldn't understand what's expected of them—do I need to write tests or is this a <strong>Proof of Concept</strong> (<strong>PoC</strong>)? What edge cases should I test for? Without processes, managers and developers will waste time chasing requirements and clarifications, giving them less time to be creative and innovative, and thus excel at their jobs.</p>
<p>Ultimately, a chaotic environment leads to a product that's lower in quality. On the technical side, there'll be more <strong>technical debt</strong>—bugs and inefficiencies that need to be fixed later. The product team will suffer too, as fewer features would be delivered.</p>
<p>For these companies, the best way to improve is simply to start implementing robust processes on the technical level by implementing <strong>Test-Driven Development</strong> (<strong>TDD</strong>), and on the management level by adopting <strong>Agile</strong> principles and/or implementing the <strong>Scrum</strong> framework. In this chapter, we will focus on the technical aspect—implementing TDD. Specifically, we will cover the following:</p>
<ul>
<li>What is technical debt?</li>
<li>What are the causes and consequences of technical debt?</li>
<li>Reducing technical debt by implementing TDD</li>
</ul>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical debt</h1>
                
            
            
                
<p>One of the most popular questions on the Software Engineering Stack Exchange (<a href="https://softwareengineering.stackexchange.com/" target="_blank">https://softwareengineering.stackexchange.com/</a>) website is this:</p>
<div><em>"</em>I'm doing 90% maintenance and 10% development, is this normal?"</div>
<p>Whilst this should never be regarded as normal, for many developers, it is their reality. So, why do so many projects end up in an unmaintainable state? After all, every project starts off with a blank slate.</p>
<p>Some may say that it's because most programmers are inherently lazy, but most also take pride in their work, and value quality over speed. Others may say it's because the developers are incompetent, but even companies that employ very talented technical teams fall victim to this.</p>
<p>My theory is that during the lengthy development process, it's too easy to make little concessions along the way, where code quality is sacrificed to save other resources, usually time. For instance, you may stop writing tests to meet a deadline, or forgo refactoring because your manager assures you that the project is just a PoC or <strong>Minimum Viable Product</strong> (<strong>MVP</strong>). Little by little, these small concessions build up. Oftentimes, the deadlines become ever more unreasonable, and the MVP becomes the company's flagship product. That's how we end up with so many unmaintainable projects in this world.</p>
<p>"Most software today is very much like an Egyptian pyramid with millions of bricks piled on top of each other, with no structural integrity, but just done by brute force and thousands of slaves."</p>
<p>– Alan Kay, creator of Smalltalk</p>
<p>These compromises, although small at the time, have a knock-on effect on the code that is written afterward. This cumulative effect is described using the metaphor of <em>technical debt</em>, which plays on the analogy of financial debt, where you incur compound interest on your existing debts.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">What is technical debt?</h1>
                
            
            
                
<p>Technical debt is a metaphor created by Ward Cunningham, an American computer programmer:</p>
<p>"A little debt speeds development so long as it is paid back promptly with a rewrite... The danger occurs when the debt is not repaid. Every minute spent on not-quite-right code counts as interest on that debt."</p>
<p>For example, if you want to start your own business, but do not have enough personal savings, you may opt to take out a loan with a bank. In this case, you incur a small debt now in order to acquire a potentially larger reward later, when your business generates a profit.</p>
<p>Likewise, you may decide to incur some technical debt in order to capture the <strong>First-Mover Advantage</strong> (<strong>FMA</strong>) to ship a feature before your competitors go to market. The debt comes in the form of poorly-written code; for instance, you may write everything into a single file (colloquially called a kitchen sink) with no modularization or tests.</p>
<p>In both cases, the debt is incurred with the expectation that it will be repaid, <em>with interest</em>, at a later date.</p>
<p>For development, repayment comes in the form of <strong>refactoring</strong>. This is where time is re-invested to revise the poorly-written code back to an acceptable standard. As this requires time and manpower, by incurring the technical debt, you are, in essence, trading a moderate increase in development speed now for a significant decrease later.</p>
<p>The problem arises when the debt is not repaid sufficiently quickly. At some point, the amount of maintenance done on the project is so great that no more features can be added, and the business may opt for a complete rewrite instead.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Causes of technical debt</h1>
                
            
            
                
<p>Before we discuss how to tackle technical debt, let's first examine some of its most common causes:</p>
<ul>
<li><strong>Lack of talent</strong>: Inexperienced developers may not follow best practices and write unclean code.</li>
<li><strong>Lack of time</strong>: Setting unreasonable deadlines, or adding new features without allotting additional time, means developers do not have enough time to follow proper processes of writing tests, conducting code reviews, and so on.</li>
<li><strong>Lack of morale</strong>: We should not overlook the human aspect of development. If requirements change all the time, or developers are required to work overtime, then they're not likely to produce good work.</li>
</ul>
<p>All of these causes can easily be mitigated. The problem of inexperienced developers can be tackled through mentoring, code reviews, and general training. The problem of morale can be tempered by providing better working environments. The issue of lack of time can be remedied by reducing the scope of the project to something more achievable; this may mean pushing non-essential features to a subsequent phase. Besides this, the business can employ more staff and/or outsource the development of well-defined modules to external contractors.</p>
<p>The real problem lies in the reluctance to tackle technical debt, since the biggest cause of technical debt is the <em>existing technical debt</em>. Any new code that depends on the bad code will very soon become part of the technical debt and incur further debt down the line.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The debt spiral</h1>
                
            
            
                
<p>When you talk with product managers or business owners, most of them understand the concept of technical debt; however, most managers or business owners I've encountered also tend to overestimate the short-term returns and underestimate the long-term consequences. They believe that technical debt works like personal loans issued by banks, with an interest rate of around 3% <strong>Annual Percentage Rate</strong> (<strong>APR</strong>); in reality, it works more like payday loans that charge you 1500% APR.</p>
<p>In fact, the debt metaphor isn't completely accurate. This is because, unlike a formalized loan, when you incur technical debt, you don't actually know the interest rate or repayment period beforehand.</p>
<p>The debt may require one week of refactoring time that you can delay indefinitely, or it may cost you a few months' time just a few days down the line. It is very hard to predict and quantify the effect of technical debt.</p>
<p>Furthermore, there's no guarantee that by incurring the debt, the current set of features are actually going to be finished earlier. Often, the consequences of technical debt are close to immediate; therefore, by rushing, it may actually slow you down within the same development cycle. It is very hard to predict and quantify the short-term benefits of incurring technical debt. In that sense, incurring technical debt resembles more of a gamble than a loan.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consequences of technical debt</h1>
                
            
            
                
<p>Next, let's examine the consequences of technical debt. Some are obvious:</p>
<ul>
<li>Development speed will slow down</li>
<li>More manpower (and thus money) and time will need to be spent to implement the same set of features</li>
<li>More bugs, which consequently means poorer user experience, and more personnel required for customer service</li>
</ul>
<p>On the other hand, the human cost of technical debt is often overlooked; so let's spend some time discussing it here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical debt leads to low morale</h1>
                
            
            
                
<p>Most developers want to work on <strong>greenfield</strong> projects where they can develop new features, rather than to inherit legacy <strong>brownfield</strong> projects riddled with bugs and technical debt. This will likely reduce the morale of the developers.</p>
<p>In some cases, those working on brownfield projects may even show animosity toward their colleagues who work on greenfield projects. This is because newer frameworks, libraries, and paradigms will eventually replace older ones, making them obsolete. Those working on legacy projects know that the skills they develop will be worthless in a few years' time, making them less competitive on the job market. In comparison, their colleagues are gaining valuable experience on more modern frameworks that will increase their market value. I can't imagine a developer being happy knowing their skills are becoming less and less relevant.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Furthermore, having technical debt would likely ignite disagreement between developers and their managers about the best time to repay the debt. Typically, developers demand immediate repayment, while the (inexperienced) managers would try to push it further down the line.</p>
<p>Overall, having technical debt in the project tends to lower the morale of its developers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Consequences of low morale</h1>
                
            
            
                
<p>In turn, low morale leads to the following:</p>
<ul>
<li><strong>Lower productivity</strong>: Unmotivated developers are more likely to work slower, take longer breaks, and be less engaged in the business.</li>
<li><strong>Lower code quality</strong>: Development is a creative process—there is more than one way to implement a feature. Developers with low morale are unlikely to conjure up the willingness to figure out the best approach—they'll simply select for the approach that requires the least effort.</li>
<li><strong>High Turnover</strong>: Unhappy developers are going to be looking for better jobs, leading to a high turnover of staff for the company. This means the time invested to train the developer and integrate him/her into the team is wasted. Furthermore, it may cause other members of staff to lose confidence in the company, creating a snowball effect of people leaving.</li>
</ul>
<p>Some managers may argue that the business is not responsible for the happiness of its developers—they pay them to produce work and value, not to be happy. Whilst this is true, an experienced project manager should remember that a development team is not a machine—it consists of people, each with their individual ambitions and emotions. Thus, the manager would be wise to consider the human costs of technical debt when making a business decision.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Repaying technical debt through refactoring</h1>
                
            
            
                
<p>Despite its negative repercussions, incurring technical debt is often inevitable. In those cases, you must ensure that the decision is an informed and conscious one, and remember to repay the debt as soon as possible. So how do we actually pay back the debt? We do this through <em>refactoring—</em>or making our code <em>cleaner</em> <em>without </em><em>changing the existing behavior</em>.</p>
<p class="mce-root"/>
<p>Whilst there are no formal definitions on what <strong>clean</strong> means, here are some signs of clean code:</p>
<ul>
<li><strong>Well-structured</strong>: Code should consist of modules, separated by domains</li>
<li><strong>Well-documented</strong>: For example, include unit tests, inline comments, automatically generated documentation, and <kbd>README</kbd> files</li>
<li><strong>Succinct</strong>: Be concise, but not to the point of obfuscation</li>
<li><strong>Well-formatted and readable</strong>: Other developers must be able to review and work on the same code base, so it should be easy to understand and not deviate too far from well-established conventions</li>
</ul>
<p>As you gain more experience, you'll be able to detect code that deviates from these signs. In programming, we call these deviations <strong>code smells</strong>. Code smells are weaknesses within the code that violate well-established design principles, paradigms, and patterns. While they are not bugs themselves, they may slow down development and make the code base more prone to errors later.</p>
<p>Therefore, refactoring is simply a process that moves the current code base from having a lot of code smells to one that is cleaner. As we have mentioned before, there is more than one way to achieve the same results, and developers need to be creative and figure out the best solutions to problems that arise.</p>
<p>The important point here is that developers should be given time to refactor; in other words, refactoring should be the core part of a development process, and be included in the time estimates that the developers provide.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preventing technical debt</h1>
                
            
            
                
<p>Prevention is better than cure. Instead of incurring technical debt, how about avoiding it in the first place? Here, we outline some easy tactics that you can adopt to prevent technical debt.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Informing the decision makers</h1>
                
            
            
                
<p>Most decision makers, especially those without a technical background, greatly underestimate the effects of technical debt. Furthermore, in their view, developers do not understand the business costs of repaying technical debt in terms of manpower, salaries, and time.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>That's why it is important for a professional developer to understand the situation from the decision maker's perspective and the constraints that they must work within. One of the most relevant models is the <strong>triple constraint</strong> model.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The triple constraint</h1>
                
            
            
                
<p>The classic project management triangle (also known as triple constraint or the <em>iron triangle</em>) coined the popular saying Time, Quality, Cost. Pick two. The triangle is shown as follows:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/b5a6e054-9385-4486-ae31-aaf41da945f3.jpg" style="width:14.58em;height:10.67em;"/></p>
<p>The triple constraint is a model used in project management to visualize the constraints on any projects, and to consider how optimizing the project for one area would cause another area to suffer:</p>
<ul>
<li><strong>Time and Quality</strong>: You can design and build a high-quality platform in a short time, but you'll need to hire a lot of experienced developers, which will be expensive.</li>
<li><strong>Time and Cost</strong>: You can build a platform quickly with a few inexperienced developers, but the quality will be low.</li>
<li><strong>Quality and Cost</strong>: You can tell a few inexperienced developers to design and plan a platform properly. It'll be of good quality, but it's going to take a long time because they'll need time to learn the principles and apply them.</li>
</ul>
<p>Most businesses are limited largely by their time and cost: by time, because for each day the product is not launched, the greater the chance their competitor delivers a similar product and captures the <strong>first-mover advantage</strong> (<strong>FMA</strong>); by cost, because the company still has to pay their staff salaries while the product is not generating any revenue.</p>
<p>To exacerbate the problem, many managers and business owners are focused more on tangible, immediate results, rather than long-term rewards. For these reasons, when given the choice, most decision-makers pick time and cost over quality.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The fallacy of the triple constraint</h1>
                
            
            
                
<p>The fallacy here is that by neglecting quality and incurring debt, they'll eventually be increasing both the time and cost requirements many times over.</p>
<p>Therefore, it is the duty of the developer to inform the product manager and business owner of the unpredictable effects of incurring technical debt to give them all of the advice they need to make an informed decision. You may want to turn the tables and approach it from a positive perspective—cleaning up technical debt would allow future development of new features to be completed more quickly.</p>
<p>Do this to prevent the worst-case scenario where the effort required to fix the code is greater than rewriting everything from scratch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refuse to develop</h1>
                
            
            
                
<p>If the code base is so bad that it's close to FUBAR (a variation on the military slang that stands for 'Fucked Up Beyond Any Repair'), then a more drastic approach may be to refuse further development until refactoring is done. This may seem extreme, given that the people you're disobeying are paying your salary. While this is an easy way to forgo responsibility, it's not what a professional developer should do.</p>
<p>To paraphrase an analogy from <em>The Clean Code</em> by Robert C. Martin: Let's suppose you are a doctor and a patient asks you to perform open heart surgery on him/her in order to relieve a sore throat, what would you do? Of course, you'd refuse! Patients do not know what are best for them, that's why they must rely on your professional opinion.</p>
<p>Likewise, most business owners do not know what is best for them technically, which is why they hired you to make the best possible technical decisions for their business. They pay you not simply to code; they pay you because they want you to bring value to the business. As a professional, you should think about whether your actions are beneficial or detrimental to the business, in both the short and long term.</p>
<p>Business owners also need to trust the advice of their developers. If they do not respect their professional opinion, they shouldn't hire them in the first place.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Don't be a hero</h1>
                
            
            
                
<p>However, it's not always the business owner's fault for making unreasonable demands; the developer who commits to those demands is equally at fault.</p>
<p class="mce-root"/>
<p>Remember, it is the business owner's, or your manager's, role to get as much out of you as possible. But more importantly, it is your duty to inform them of what is and isn't possible; so, when asked to complete features under a deadline that you cannot meet without sacrificing on quality, <em>do not accept the deadline</em>.</p>
<p>You may think the business would appreciate you for going the extra mile and making the impossible possible, but there are four problems with this line of thinking:</p>
<ol>
<li>You may not actually complete the feature in time, while the business has planned a strategy that depends on that deadline being met.</li>
<li>You've demonstrated to the manager that you're willing to accept these deadlines, so they may set even tighter deadlines next time, even if they don't need to.</li>
<li>Rushing through code will likely incur technical debt.</li>
<li>Your fellow developers may resent you, since they may have to work overtime in order to keep up with your pace; otherwise, their manager may view them as slow. It also means they'll have to develop on top of your rushed code, making everyday work less enjoyable.</li>
</ol>
<p>There's a time to stick your head out to save a business, but by doing it too often, you are actually hurting the team. The danger is that neither you nor the business owner will realize this; in fact, you may even naïvely celebrate the rapid progress being made.</p>
<p>The solution here is to manage your business owner's expectations. If you believe there's a 50% chance of meeting an optimistic deadline, then ask for the scope to be reduced further until you can be more confident in your estimate. Speaking from experience, business owners would rather hear <em>it's not possible</em> a month in advance than a promise of <em>everything will be done</em> that was not delivered.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining processes</h1>
                
            
            
                
<p>This brings me back to the topic of defining and documenting processes. Good code starts with good planning, design, and management, and is maintained by good processes. Many of the problems outlined previously can be mitigated if there are clear guidelines outlining the following issues:</p>
<ul>
<li>Situations where incurring technical debt is appropriate, for example, to meet a legal requirement such as GDPR compliance.</li>
<li>Occasions when developers can expect to receive time to repay these debts, for example, before the next feature is started, or two weeks at the end of each quarter.</li>
<li>The distribution of work on greenfield/brownfield projects within the team, for example, with a rotation system.</li>
<li>The <strong>Definition of Done</strong> – a list of criteria which must be met before a feature is considered "done", for example, code passes all tests and is peer-reviewed, and documentation is updated.</li>
</ul>
<p>Software development paradigms such as <em>Agile</em> and <strong>Waterfall</strong>, as well as their implementations such as <em>Scrum</em> and <strong>Kanban</strong>, provide different ways to define and enforce these processes. For example, in Scrum, development happens in short iterations (typically one and four weeks) called <strong>sprints</strong>. At the beginning of each sprint, a meeting is held to review pending tasks and select features to be tackled in this sprint. At the end of each sprint, a <strong>retrospective</strong> meeting is held to review the progress of the sprint and identify lessons that can be learned and applied to subsequent sprints.</p>
<p>Although these paradigms and methodologies are popular in software development, they are not coupled to any technical processes at all. Instead, they deal with the entire development process, including gathering requirements and specifications, communicating with the client, design, development, and deployment.</p>
<p>Therefore, of more relevance to developers are development techniques, which specify <em>how</em> a developer should develop a feature. The most prominent technique is TDD.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test-Driven Development</h1>
                
            
            
                
<p>Test-Driven Development is a development practice created by Kent Beck, it requires the developer to write tests for a feature before that feature is implemented. This provides some immediate benefits:</p>
<ul>
<li>It allows you to validate that your code works as intended.</li>
<li>It avoids errors in your test suite, if you write your test first, then run it, and it does <em>not</em> fail, that's a prompt for you to check your test again. It might just be that you have inadvertently implemented this feature by chance, but it could also be an error in your test code.</li>
<li>Since existing features would be covered by existing tests, it allows a test runner to notify you when a previously functional piece of code is broken by the new code (in other words, to detecting <strong>regressions</strong>). This is especially important for developers when they inherit old code bases they are not familiar with.</li>
</ul>
<p>So, let's examine the principles of TDD, outline its process, and see how we can incorporate it into our workflow.</p>
<p>There are different flavors of TDD, such as <strong>Acceptance Test-Driven Development</strong> (<strong>ATDD</strong>), where the test cases mirror the acceptance criteria set by the business. Another flavor is <strong>Behavior-Driven Development</strong> (<strong>BDD</strong>), where the test cases are expressed in natural language (that is, the test cases are human readable).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding the TDD process</h1>
                
            
            
                
<p>TDD consists of a rapid repetition of the following steps:</p>
<ol>
<li>Identify the smallest functional unit of your feature that has not yet been implemented.</li>
<li>Identify a test case and write a test for it. You may want to have test cases that cover the <strong>happy path</strong>, which is the default scenario that produces no errors or exceptions, as well as <strong>unhappy paths</strong>, including dealing with <strong>edge cases</strong>.</li>
<li>Run the test and see it fail.</li>
<li>Write the minimum amount of code to make it pass.</li>
<li>Refactor the code.</li>
</ol>
<p>For example, if we want to build a math utility library, then our first iteration of the TDD cycle may look like this:</p>
<p>Here, we are using the <a href="https://nodejs.org/api/assert.html"><kbd>assert</kbd></a> module from Node, as well as the <kbd>describe</kbd> and <kbd>it</kbd> syntax provided by the Mocha testing framework. We will clarify their syntax in detail in <a href="275da6be-376e-45cf-87a5-8032b4526f41.xhtml" target="_blank">Chapter 5</a>, <em>Writing End-to-End Tests</em>. In the meantime, you may simply treat the following test code as pseudocode.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="1">
<li><strong>Pick a feature</strong>: For this example, let's pick the <kbd>sum</kbd> function, which simply adds numbers together.</li>
<li><strong>Define a test case</strong>: When running the <kbd>sum</kbd> function with <kbd>15</kbd> and <kbd>19</kbd> as the arguments, it should return <kbd>34</kbd>:</li>
</ol>
<pre style="color: black;padding-left: 60px">var assert = require('assert');<br/>var sum = require('sum');<br/>describe('sum', function() {<br/> it('should return 34 when 15 and 19 are passed in', function() {<br/>   assert.equal(34, sum(15, 19));<br/> });<br/>});</pre>
<ol start="3">
<li><strong>Run the test</strong>: It fails because we haven't written the <kbd>sum</kbd> function yet.</li>
</ol>
<ol start="4">
<li><strong>Write the code</strong><strong>:</strong> Write the <kbd>sum</kbd> function that will allow us to pass the test:</li>
</ol>
<pre class="mce-root" style="padding-left: 90px">const sum = function(x, y) {<br/>  return x + y;<br/>}</pre>
<ol start="5">
<li><strong>Refactor</strong>: No refactoring needed.</li>
</ol>
<p>This completes one cycle of the TDD process. In the next cycle, we will work on the same function, but define additional test cases:</p>
<ol start="1">
<li><strong>Pick a feature</strong>: we'll continue developing the same <kbd>sum</kbd> function. </li>
<li><strong>Define a test case</strong>: this time, we will test it by supplying three arguments, <kbd>56</kbd>, <kbd>32</kbd> and <kbd>17</kbd>, we expect to receive the result <kbd>105</kbd>:</li>
</ol>
<pre style="padding-left: 90px">describe('sum', function() {<br/> ...<br/> it('should return 105 when 56, 32 and 17 are passed in', function() {<br/>   assert.equal(105, sum(56, 32, 17));<br/> });<br/>});</pre>
<ol start="3">
<li><strong>Run the test</strong>: it fails because our current <kbd>sum</kbd> function only takes into account the first two parameters. </li>
</ol>
<ol start="4">
<li>Write the code: update the <kbd>sum</kbd> function to take into account the first three parameters:</li>
</ol>
<pre class="mce-root" style="padding-left: 90px">const sum = function(x, y, z) {<br/>  return x + y + z;<br/>}</pre>
<ol start="5">
<li class="mce-root"><strong>Refactor</strong>: improve the function by making it work for any number of function parameters:</li>
</ol>
<pre style="color: black;padding-left: 90px">const sum = function(...args) =&gt; [...args].reduce((x, y) =&gt; x + y, 0);</pre>
<p class="mce-root">Note that calling with just two arguments would still work, and so the original behavior is not altered.</p>
<p>Once a sufficient number of test cases have been completed, we can then move on to the next function, such as <kbd>multiply</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fixing bugs</h1>
                
            
            
                
<p>By following TDD, the number of bugs should reduce drastically; however, no process can guarantee error-free code. There will always be edge cases that were overlooked. Previously, we outlined the TDD process for implementing a new feature; now, let's look at how can we can apply the same process to fixing bugs.</p>
<p>In TDD, when a bug is encountered, it is treated the same way as a new feature—you'd first write a (failing) test to reproduce the bug, and then update the code until the test passes. Having the bug documented as a test case ensures the bug stays fixed in the future, preventing regression.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Benefits of TDD</h1>
                
            
            
                
<p>When you first learn to code, no one ever starts with writing tests. This means that for many developers, having tests in the code is an afterthought—a luxury if time permits. But what they don't realize is that <em>everyone tests their code</em>, consciously or otherwise.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>After you've written a function, how do you know it works? You may open the browser console and run the function with some dummy test parameters, and if the output matches your expectations, then you may assume it's working. But what you're doing here is actually <strong>manually testing</strong> a function that has already been implemented.</p>
<p>The advantage of manual testing is that it requires no upfront costs—you just run the function and see if it works. However, the downside is that it cannot be automated, eating up more time in the long run.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding manual tests</h1>
                
            
            
                
<p>Instead, you should formally define these manual tests as code, in the form of <strong>unit</strong>, <strong>integration</strong> and <strong>end-to-end</strong> (<strong>E2E</strong>) tests, among others.</p>
<p>Formally defining tests has a higher initial cost, but the benefit is that the tests can now be automated. As we will cover in <a href="275da6be-376e-45cf-87a5-8032b4526f41.xhtml" target="_blank">Chapter 5</a>, <em>Writing End-to-End Tests</em>, once a test is defined as code, we can use <strong>npm scripts</strong> to run it automatically every time the code changes, making the cost to run the tests in the future virtually zero.</p>
<p>The truth is that you'll need to test your code anyways; it's just a choice of whether you invest time to automate it now, saving time in the future, or save the time now but waste more time repeating each test manually in the future.</p>
<p>Mike Cohn developed the concept of the <strong>Testing Pyramid</strong>, which shows that an application should have a lot of unit tests (as they are fast and cheap to run), fewer integration tests, and even fewer UI tests, which take the most amount of time and are the most expensive to define and run. Needless to say, manual testing should only be done after unit, integration, and UI tests have been thoroughly defined:</p>
<div><img src="img/f7598434-8760-4847-8bfb-eb52ee182114.jpg" style="width:15.83em;height:13.00em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Tests as specification</h1>
                
            
            
                
<p>Whilst avoiding manual testing is a benefit of TDD, it certainly is not the only one. A developer can still write their unit, integration and E2E tests after implementation of the feature. So what are the benefits of writing tests before implementation?</p>
<p>The answer is that it forces you to think about your requirements and break them down into atomic units. You can then write each test case around a specific requirement. The end result is that the test cases form the specification for your feature. Writing tests first helps you structure your code around the requirements, rather than retrofitting requirements around your code.</p>
<p>This also helps you to abide by the <strong>You Aren't Gonna Need It</strong> (<strong>YAGNI</strong>) principle, which prevents you from implementing features that aren't actually needed.</p>
<p>"Always implement things when you <em>actually</em> need them, never when you just <em>foresee</em> that you need them."</p>
<p>– Ron Jeffries, co-founder of Extreme Programming (XP)</p>
<p>Lastly, writing the tests (and thus the specifications) forces you to think about the interface that consumers of your function would have to use to interact with your function—should everything be defined as properties inside a generic <kbd>options</kbd> object, or should it be a plain list of arguments?</p>
<pre>// Using a generic options object<br/>User.search(options) {<br/>  return db.users.find(options.name, {<br/>    limit: options.limit,<br/>    skip: options.skip<br/>  })<br/>}<br/><br/>// A list of arguments<br/>User.search(name, limit, skip) {<br/>  return db.users.find(name, {limit, skip});<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Tests as documentation</h1>
                
            
            
                
<p>When developers want to use a tool or library, they learn by reading the documentation or guides that contain code samples they can try, or by following tutorials to build a basic application.</p>
<p class="mce-root"/>
<p>Test cases can essentially act as code samples and form part of the documentation. In fact, tests are the most comprehensive set of code samples there are, covering every use case that the application cares about.</p>
<p>Although tests provide the best form of documentation, tests alone are not enough. Test cases do not provide context for the code, such as how it fits into the overall business goals, or convey the rationale behind its implementation. Therefore, tests should be supplemented by inline comments and automatically-generated, as well as manually-written, documentation. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Short development cycles</h1>
                
            
            
                
<p>Because TDD focuses on a single functional block at a time, its development cycles are usually very short (minutes to hours). This means small, incremental changes can be made and released rapidly.</p>
<p>When TDD is implemented within the framework of a software development methodology such as Scrum, small development cycles allow the methodology practitioner to capture fine-grained metrics on the progress of the team.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Difficulties with TDD adoption</h1>
                
            
            
                
<p>While TDD is the gold standard amongst development techniques, there are many obstacles preventing its implementation:</p>
<ul>
<li><strong>Inexperienced team</strong>: TDD only works when the whole development team adopts it. Many junior developers, especially self-taught developers, never learned to write tests.<br/>
The good news is that TDD is not hard; given a day or so, a developer can realistically learn about the different types of tests, including how to spy on functions and mock data. It's wise to invest time training a developer so that he/she can write more reliable code for the entire duration of his/her employment.</li>
<li><strong>Slower initial development speed</strong>: TDD requires the product owner to create a specification document and for the developers to write the tests before any functional code is written. This means the end product will likely take more time to complete. This goes back to a recurring theme in this chapter: pay the price now, or pay the interest later. If you've been reading everything so far, it'll be obvious the first option is the better one.</li>
<li><strong>Legacy code</strong>: Many legacy code bases do not have tests, or the tests are incomplete; worse still, there may be insufficient documentation to understand what each function is designed to do. We can write tests to verify functionality that we know, but we cannot be certain that it'll cover all cases. This is a tricky one because TDD means you write your tests first; if you already have all the code, then it can't be TDD. If the code base is large, you may continue to fix bugs (documenting them as unit tests as you do so) while starting on a rewrite.</li>
<li><strong>Slow tests</strong>: TDD is only practical when the tests can be run quickly (within a few seconds). If the test suite takes a few minutes to run, then developers would not receive quick enough feedback for those tests to be useful.<br/>
The simplest way to mitigate this issue is by breaking the code into smaller modules and running tests on them individually. However, some tests, such as large integration and UI tests, are inevitably slow. In these cases, you can run them only when the code is committed and pushed, probably by integrating them into a Continuous Integration (CI) system, which is something we will cover in <a href="38b85b06-d091-4751-a2ac-32ca0f98f26b.xhtml" target="_blank">Chapter 8</a>, <em>Writing Unit/Integration</em> <em>Tests</em>.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">When not to use TDD</h1>
                
            
            
                
<p>Although I encourage you to incorporate TDD into your workflow, I should add a disclaimer that it is <em>not a silver bullet</em>. TDD does not magically make your code performant or modular; it's just one technique that forces you to design your system better, making it more testable and maintainable.</p>
<p>Furthermore, TDD induces a high initial cost, so there are a few cases where this investment is not advisable:</p>
<ul>
<li>Firstly, when the project is a <strong>Proof-of-Concept</strong> (<strong>PoC</strong>). This is where the business and developers are only concerned with whether the idea is possible, not about its implementation. Once the concept is proven to be possible, the business may then agree to approve additional resources for the proper development of this feature.</li>
<li>Secondly, when the product owner has not defined clear requirements (or does not want to), or the requirements change every day. This is more common than you think, since many early startups are constantly pivoting to find the right market fit. Needless to say, this is a bad situation for the developer, but if you do find yourself in this situation, then writing tests would be a waste of time, as they may become obsolete as soon as the requirements change.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we've looked at technical debt, its causes, consequences, and ways to prevent it. Then, we introduced TDD as a process to avoid technical debt; we outlined its benefits, and how to implement it in your workflow. In <a href="275da6be-376e-45cf-87a5-8032b4526f41.xhtml" target="_blank">Chapter 5</a>, <em>Writing End-to-End Tests</em> and <a href="6a407d81-cb0e-4ada-9849-693cba3fabd5.xhtml" target="_blank">Chapter 6</a>, <em>Storing Data in Elasticsearch</em>, we will cover in more depth the different types of tests (unit, integration, and E2E / acceptance tests).</p>
<p>Good code, whatever its definition, takes less time to write than bad code in the long run. It would be wise to realize this fact and have the discipline to build a strong foundation from the get-go. You can build a house on weak foundations, and it may stand for a hundred years, but build a skyscraper on a weak foundation, it'll come tumbling down quicker than you can imagine. </p>
<p>"Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live."</p>
<p>– John F. Woods</p>


            

            
        
    </body></html>