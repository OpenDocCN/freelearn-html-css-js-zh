<html><head></head><body><div class="chapter" title="Chapter&#xA0;11.&#xA0;Application Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Application Testing</h1></div></div></div><p>Our role as architects isn't just to tick the boxes, send the application to the client, and forget about it. We have a responsibility, both from a professional perspective and a business perspective to produce software that tries to exceed expectations. A part of this was mentioned in <a class="link" href="ch10.html" title="Chapter 10. Debugging and Performance">Chapter 10</a>, <span class="emphasis"><em>Debugging and Performance</em></span>, in which we discussed the need to build an application that responded quickly to user actions. Now, we'll talk about building a robust application, one that stands up to scrutiny when it's under intense use.</p><p>What does it mean for an application to be robust? It means that if we click on a button, we see the expected result. If we try and enter an invalid e-mail address, we see a validation message. If we refresh the page, we find ourselves on the same screen as before. If the network connection drops out, remote requests get retried later. If we try and break the application, and so on, can we succeed?</p><p>The core of building a robust application is that the application should always behave as the user expects, even in unexpected circumstances. We must recognize that developers (and architects) are fallible and are unlikely to be able to account for every possible ramification of even a minor code change; this is where bugs arise and why the struggle for robustness is constant and ongoing.</p><p>We need a safety net for the fallible nature of coding. If we rename a particular method in the product list view, can we guarantee that it won't affect the shopping cart? We can use find and replace in our text editor, but we can never be 100 percent certain without refreshing the application and working through the functionality of the product list and the shopping cart to show that the customer requirements are still fulfilled.</p><p>A quality assurance process is a safety net of which automated testing is a key component. When working with Ext JS, there are a multitude of tools that we can use and a range of approaches to ensure that our applications are built in a way that is conducive to automated testing. To this end, in this chapter, we'll look at:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The different types of test and when to use them</li><li class="listitem" style="list-style-type: disc">Keeping Ext JS code concerns separate to promote unit testing</li><li class="listitem" style="list-style-type: disc">Naming and coding conventions to assist with integration testing</li><li class="listitem" style="list-style-type: disc">Testing tools for unit tests and integration tests</li><li class="listitem" style="list-style-type: disc">Ext JS-specific testing tools</li></ul></div><p>The goal in<a id="id647" class="indexterm"/> this chapter is to build an understanding of the advantages of testing, how to write Ext JS applications that are easy to test, and how to select and employ suitable testing tools. When we're done, we'll have covered all of the subjects an Ext JS architect needs to produce exemplary products.</p><div class="section" title="Total testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec123"/>Total testing</h1></div></div></div><p>In this chapter, we'll <a id="id648" class="indexterm"/>cover two types of test, one at the detail level and one at the "big picture" level. The first, unit testing, is great for helping with the algorithms and calculations that often make up business logic; the second, integration testing, helps us make sure that customer requirements are met and the user experience is sound. Let's look at each in turn.</p><div class="section" title="Unit testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec121"/>Unit testing</h2></div></div></div><p>With <a id="id649" class="indexterm"/>unit testing, we<a id="id650" class="indexterm"/> unsurprisingly test a unit, a unit being an individual unit of code. This will generally be a whole class, but will focus on a single method depending on the circumstances. In a unit test, we'd be able to say something like this:</p><div class="informalexample"><pre class="programlisting">Create cart object
Add product #1 to cart
Add product #1 to cart
Assert that there is only one item in the cart</pre></div><p>To set up the test, we add the same product to the cart twice. This should result in one line item with a quantity of two rather than two line items, each with a quantity of one. In the first test, we make the assertion that the cart count is equal to one, assuring us that adding to the cart won't add duplicates. The next test will check whether the quantity is incremented as expected:</p><div class="informalexample"><pre class="programlisting">Create cart object
Add product #1 to cart
Add product #1 to cart
Assert that first cart item has a quantity of two</pre></div><p>It performs the same setup as the previous test, but then picks out the first line item in the cart and makes the assertion that its quantity is equal to two, one for each time the product was added to the cart.</p></div><div class="section" title="Assert yourself"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec122"/>Assert yourself</h2></div></div></div><p>What's all this "assertion" business? It's <a id="id651" class="indexterm"/>simply a way of saying, "if this condition isn't met, something's wrong". In the previous examples, if the actual value and the expected value aren't equal, something's wrong. In most unit testing libraries, there are lots of different assertions, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Equal</li><li class="listitem" style="list-style-type: disc">Less than</li><li class="listitem" style="list-style-type: disc">Greater than</li><li class="listitem" style="list-style-type: disc">Is it numeric?</li><li class="listitem" style="list-style-type: disc">Does it contain the specified value?</li></ul></div><p>Each testing library has its own flavor of assert methods. Some will use slightly different terminology (such as expectations or specifications). The terminology is less important than the principles behind unit testing, which is to put an isolated piece of code under intense scrutiny.</p></div><div class="section" title="Integration testing"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec123"/>Integration testing</h2></div></div></div><p>While<a id="id652" class="indexterm"/> unit testing <a id="id653" class="indexterm"/>focuses on a small piece of functionality, integration testing goes to the opposite extreme. Its purpose is to check whether all of the moving parts of the application work together correctly, replicating some of the actions that a real-world user would take.</p><p>For this reason, integration testing will often be described as UI testing because it acts directly on the interface. Let's say that we want to verify whether the detail window will show when a product is clicked on. We can do something like this:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Find the link for the product in question.</li><li class="listitem">Simulate a click event on the link.</li><li class="listitem">Verify that the DOM element with the product in question appeared as expected.</li></ol></div><p>This is completely different to the kind of focus we had with unit testing in which we were drilling down to a single function or class in the code. Here, the actions we test will span multiple classes in the application, checking whether they're integrated and working together correctly.</p><div class="section" title="Integration and differentiation"><div class="titlepage"><div><div><h3 class="title"><a id="ch11lvl3sec10"/>Integration and differentiation</h3></div></div></div><p>The nature of <a id="id654" class="indexterm"/>integration testing means that it operates on the same application that your users can see; the tests effectively load up a browser and simulate the path a user would take. However, rather than moving the mouse cursor manually in the same way as a user, integration test frameworks generally work by picking out HTML elements on the screen and allowing you to perform actions directly.</p><p>This is both good and bad. When a <a id="id655" class="indexterm"/>user negotiates a web page, they can generally spot the UI components they're interested in fairly quickly, but when the person writing the test comes to pick out this same component, they need a way of referencing it. The usual approach to this is to use CSS or XPath selectors. For example, to reference an element on the page with an ID with CSS and then XPath, use the following code:</p><div class="informalexample"><pre class="programlisting">#someElement
//*[@id="someElement"]</pre></div><p>Also, another slightly more complicated code to get the first button in a container is as follows:</p><div class="informalexample"><pre class="programlisting">#container &gt; button:nth-child(1)
//*[@id="container"]/button[1]</pre></div><p>This goes some way in demonstrating a potential pain point of writing integration tests. What if the ID of <code class="literal">someElement</code> changes? It'll break the test, but it's a fairly simple fix. What if the ID of "container" changes? Well, not only will it break the previous example, but it'll also break any other tests that are looking for buttons or other elements within this <code class="literal">div</code>.</p><p>This is an ongoing problem with integration testing: the fragility of tests. Later in the chapter, we'll look at some methods to address this within Ext JS.</p></div></div></div></div>
<div class="section" title="Testing tool time with Jasmine"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec124"/>Testing tool time with Jasmine</h1></div></div></div><p>Enough<a id="id656" class="indexterm"/> theory! Let's get our hands dirty with some practical <a id="id657" class="indexterm"/>examples using the Alcohology app from <a class="link" href="ch09.html" title="Chapter 9. A Shopping Application">Chapter 9</a>, <span class="emphasis"><em>A Shopping Application</em></span>. First, we'll drill down into the guts of the application and build a unit test for some of the key business functionality. Then, we'll jump up to a high-level view and check whether our building blocks integrate correctly.</p><p>There are a wealth of tools we can use for both. The Ext JS framework has begun to build a set of unit tests to verify its behavior and cut out regressions in core functionality. To do so, Sencha has chosen the Jasmine library.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>Sencha has hinted that there'll be a big announcement surrounding testing alongside SenchaCon 2015. Given that they're already using Jasmine, we can hope that it'll be a good bet for Ext JS application testing in the future.</p></div></div><p>Jasmine<a id="id658" class="indexterm"/> is a <a id="id659" class="indexterm"/>behavior-driven framework, a term that relates to the way tests are described. Rather than using the "assertation" terminology, it uses the "expectation" format that we briefly mentioned earlier in the chapter. It asks us to specify behavior and expect a particular result. Here's the canonical example from Jasmine's documentation:</p><div class="informalexample"><pre class="programlisting">describe('A suite', function() {
    it('contains spec with an expectation', function() {
        expect(true).toBe(true);
    });
});</pre></div><p>The <code class="literal">describe</code> method encloses one or more specifications, themselves declared in an <code class="literal">it</code> method, with expectations declared using the <code class="literal">expect</code> method. To translate the previous code to plain language, use the following command:</p><div class="informalexample"><pre class="programlisting">We have "a suite", which "contains spec with an expectation". This expectation expects "true" to be "true".</pre></div><p>Obviously, this is a contrived suite, as we'd hope that true would always be true! However, it should serve as a useful demonstration of the general syntax of a Jasmine test. Before we can get going and use this on our own application, we need to take a little bit of time to download and set up the Jasmine library.</p><div class="section" title="Jasmine – installation and configuration"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec124"/>Jasmine – installation and configuration</h2></div></div></div><p>The <a id="id660" class="indexterm"/>simplest way of<a id="id661" class="indexterm"/> getting started with Jasmine is to download the latest version from the project's release page. At the time of writing this book, the current version is 2.1.3. Refer to <a class="ulink" href="https://github.com/jasmine/jasmine/releases">https://github.com/jasmine/jasmine/releases</a> for more information.</p><p>Extract the ZIP file and you'll see that the download includes some example specifications that we don't need; let's clear these out from within the new Jasmine directory:</p><div class="informalexample"><pre class="programlisting">rm MIT.LICENSE spec/* src/*</pre></div><p>Now, we can<a id="id662" class="indexterm"/> move the Jasmine library to the root of the Alcohology project, assuming our current directory is now in the Alcohology project:</p><div class="informalexample"><pre class="programlisting">mkdir ./testsmv ~/Downloads/jasmine-2.1.3 ./tests/jasmine</pre></div><p>We can <a id="id663" class="indexterm"/>now fire up our application; if you've downloaded the project files, then the readme file will tell you to run <code class="literal">npm start</code> and it'll start the Ext JS project and the API server. Once this is done, we can open <code class="literal">http://localhost:1841/tests/jasmine/SpecRunner.html</code> in our browser to run the specs, as shown here:</p><div class="mediaobject"><img src="graphics/5308OT_11_01.jpg" alt="Jasmine – installation and configuration"/><div class="caption"><p>The Jasmine spec runner before writing any specifications</p></div></div><p>In this screenshot, we can see the spec runner, but it's got nothing to do. We've got a little bit more configuration to do before we can start writing some specifications. Let's open up the <code class="literal">SpecRunner.html</code> file in an editor and tweak it to look like this:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;title&gt;Jasmine Spec Runner v2.1.3&lt;/title&gt;

  &lt;link rel="stylesheet" href="lib/jasmine-2.1.3/jasmine.css"&gt;

  &lt;script src="lib/jasmine-2.1.3/jasmine.js"&gt;&lt;/script&gt;
  &lt;script src="lib/jasmine-2.1.3/jasmine-html.js"&gt;&lt;/script&gt;
  &lt;script src="lib/jasmine-2.1.3/boot.js"&gt;&lt;/script&gt;
  &lt;script src="../../ext/build/ext-all-debug.js"&gt;&lt;/script&gt;

  &lt;script type="text/javascript"&gt;
    Ext.Loader.setConfig({
      enabled: true,
      paths: {
        'Alcohology': '../../app'
      }
    });
  &lt;/script&gt;

  &lt;script src="spec/Cart.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;&lt;/body&gt;
&lt;/html&gt;</pre></div><p>This<a id="id664" class="indexterm"/> HTML file <a id="id665" class="indexterm"/>is really just a host for the Jasmine library, but it's also where we wire up Ext JS to work outside of the context of an application. By including the <code class="literal">ext-all</code> JavaScript file and reconfiguring <code class="literal">Ext.Loader</code> to grab any Alcohology classes from the correct directory, we can instantiate classes to test and Ext JS will automatically request the files we need from our application directory. All that's left to do is include the actual JavaScript specification files at the bottom of the head element. Here, we've already added a reference to <code class="literal">spec/Cart.js</code>.</p><p>With all of the setup out of the way, we can move on to writing some tests!</p></div><div class="section" title="Make it happen"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec125"/>Make it happen</h2></div></div></div><p>Earlier, we <a id="id666" class="indexterm"/>wrote some pseudocode to illustrate how to test the <code class="literal">addProduct</code> method on the cart store. Now, let's build out the real Jasmine specification that accomplishes this for real. We need to create a test suite with a cart store that'll be used as test subject:</p><div class="informalexample"><pre class="programlisting">describe('Cart store', function() {

  var cart;

  beforeEach(function() {
    cart = Ext.create('Alcohology.store.Cart');
  });
});</pre></div><p>Our first suite is simply called <code class="literal">Cart store</code>. We have a cart variable that gets reassigned <code class="literal">beforeEach</code> specification is run. It's assigned an instance of the cart store via <code class="literal">Ext.create</code>. Thanks to our configuration in the previous section, <code class="literal">Ext.create</code> will use <code class="literal">Ext.Loader</code> to automatically pull in the relevant source code file, including any dependencies. By reinstantiating before every test, we can be sure that a test later in the suite won't be affected by the way an earlier test has manipulated the cart.</p><p>We can now <a id="id667" class="indexterm"/>sketch out the functionality we'd like to test. The following code goes after the <code class="literal">beforeEach</code> call:</p><div class="informalexample"><pre class="programlisting">describe('#addProduct', function() {
    it('should accept a Product model');
    it('should create a new CartItem line');
    it('should increment the quantity when adding an existing Product');
    it('should not create a new CartItem when adding an existing Product');
  });</pre></div><p>If we refresh the <code class="literal">SpecRunner.html</code> page, then we'll actually be able to see something like this:</p><div class="mediaobject"><img src="graphics/5308OT_11_02.jpg" alt="Make it happen"/></div><p>These specifications are just placeholders, but the fact that they show up in the runner is useful for developers practicing test first development. We can write a series of specification statements that describe the functionality we require, then the specs, and finally, the code itself. In this way, we're specifying the behavior we need and the code itself follows, and we can be safe in the knowledge that it meets our requirements. This can be a powerful methodology for an architect to spell out in detail how a class should behave.</p><p>Let's go through each spec one by one:</p><div class="informalexample"><pre class="programlisting">it('should accept a Product model', function() {
    expect(cart.addProduct.bind(cart, {})).toThrow();
});</pre></div><p>We expect that if <code class="literal">addProduct</code> is passed, something that is not a product model, it will throw an exception. We pass the method to the expect call prepopulated with an empty object literal. As<a id="id668" class="indexterm"/> this isn't a product model—as expected—it throws an exception and satisfies the test as follows:</p><div class="informalexample"><pre class="programlisting">it('should create a new CartItem line', function() {
    var product = Ext.create('Alcohology.model.Product');

    cart.addProduct(product);

    expect(cart.count()).toBe(1);
});</pre></div><p>When the product is added to the cart, we expect that it will cause a new line item to be created in the store. We simply check whether the cart count is as expected after adding a product:</p><div class="informalexample"><pre class="programlisting">it('should increment the quantity when adding an existing Product', function() {
    var product = Ext.create('Alcohology.model.Product');

    cart.addProduct(product);
    cart.addProduct(product);

    expect(cart.first().get('quantity')).toBe(2);
});</pre></div><p>After adding a product that's already in the cart, we expect that it will increase the quantity of the corresponding cart line. We pass in the same product twice and check whether the quantity is two, as expected:</p><div class="informalexample"><pre class="programlisting">it('should not create a new CartItem when adding an existing Product', function() {
    var product = Ext.create('Alcohology.model.Product');

    cart.addProduct(product);
    cart.addProduct(product);

    expect(cart.count()).toBe(1);
});</pre></div><p>This is a similar setup as the last test, but we are expecting that there will not be a duplicated cart line, but instead, there will be only one item in the cart.</p><p>With all of the specifications written, we can refresh the spec runner again:</p><div class="mediaobject"><img src="graphics/5308OT_11_03.jpg" alt="Make it happen"/></div><p>As you can see, the<a id="id669" class="indexterm"/> specs are all in green, indicating that they have passed successfully.</p><p>This is just a brief primer on unit testing with Jasmine, but it demonstrates the power available and the utility of testing in this manner. It gives us confidence in the code we've written and ensures that any additions to the <code class="literal">addProduct</code> method won't break the functionality that already exists.</p></div></div>
<div class="section" title="Testing with robots"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec125"/>Testing with robots</h1></div></div></div><p>Now <a id="id670" class="indexterm"/>that we've covered a method of testing the fine <a id="id671" class="indexterm"/>detail of our code, let's look at a completely different<a id="id672" class="indexterm"/> way of running functional checks across the entire application. For this, we'll need a new tool: CasperJS. It <a id="id673" class="indexterm"/>allows you to drive a "headless browser"—one without any user interface—navigate around an application, and run evaluations on what we find. The first step is installation, which varies depending on the<a id="id674" class="indexterm"/> platform. Instructions for the same can be found at <a class="ulink" href="http://docs.casperjs.org/en/latest/installation.html">http://docs.casperjs.org/en/latest/installation.html</a>.</p><p>When complete, we'll have a CasperJS command available to run.</p><p>With Jasmine, we were using the behavior-driven method of testing with expectations to verify the code. In CasperJS, we go back to using the assertion style of testing. Take a look at a minimal test script from the CasperJS documentation:</p><div class="informalexample"><pre class="programlisting">casper.test.begin("Hello, Test!", 1, function(test) {
    test.assert(true);
    test.done();
});</pre></div><p>Pretty straightforward. The real magic comes when we combine this with CasperJS's ability to control<a id="id675" class="indexterm"/> the headless browser and interface with the web page that forms our application. Check this out:</p><div class="informalexample"><pre class="programlisting">casper.test.begin('Google search retrieves 10 or more results', 4, function suite(test) {
    casper.start('http://www.google.com/', function() {
        test.assertTitle('Google', 'google homepage title is the one expected');
        test.assertExists('form[action="/search"]', 'main form is found');
        casper.fill('form[action="/search"]', {
            q: 'casperjs'
        }, true);
    });

    casper.then(function() {
        test.assertUrlMatch(/q=casperjs/, 'search term has been submitted');
        test.assertEval(function() {
            return __utils__.findAll('h3.r').length &gt;= 10;
        }, 'google search for \'casperjs\' retrieves 10 or more results');
    });

    casper.run(function() {
        test.done();
    });
});</pre></div><p>This looks <a id="id676" class="indexterm"/>a bit more exciting! Let's break down what's happening here:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new CasperJS test suite.</li><li class="listitem">Navigate to the Google home page.</li><li class="listitem">Assert that the page title is as expected and that we can find the search box.</li><li class="listitem">Fill in the search box and submit the form.</li><li class="listitem">Then, when the page has loaded, assert that the URL is as expected and contains our search query as a parameter.</li><li class="listitem">Assert that there are at least ten search results on the page.</li></ol></div><p>Fantastic! This example shows how easy it's to use CasperJS to control a web page and how its testing features allow us to evaluate the content of the page and the behavior of an app.</p><p>The next step is <a id="id677" class="indexterm"/>to see how to use these features to test our own application, so let's hook CasperJS into our Alcohology project and get testing.</p><div class="section" title="Up and running with CasperJS"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec126"/>Up and running with CasperJS</h2></div></div></div><p>Let's <a id="id678" class="indexterm"/>create a new subdirectory within our project at <code class="literal">tests/casper</code> and then<a id="id679" class="indexterm"/> create a new file in there called <code class="literal">Sanity.js</code>. We're going to write a couple of simple checks to make sure the application is loading correctly. Here's the starting point for the code:</p><div class="informalexample"><pre class="programlisting">casper.test.begin('Alcohology Sanity Checks', 0, function suite(test) {
    casper.start('http://localhost:1841/', function() {
    });
    casper.run(function() {
        test.done();
    });
});</pre></div><p>We kick off by calling the <code class="literal">casper.test.begin</code> method, which starts off a new test suite and takes three arguments: a description for the suite, the number of tests we expect should be run, and a callback function that is called when the suite is created. The callback gets passed on a test object on which we can call various assert methods.</p><p>We then call CasperJS's <code class="literal">start</code> method with the URL to our application. In order to trigger the test run, we call CasperJS's <code class="literal">run</code> method and when everything's complete, we call the <code class="literal">done</code> method on the test object.</p><p>The first test we're going to write will check whether the category menu on the left-hand side of the application is populated as expected. To do this, we'll look for the first menu item and check whether it contains the text we expect, but it complicates matters slightly when we're loading this content in with Ajax. We need to be able to wait for the page to load, select the relevant element, and check whether it contains the content we'd expect.</p><p>In order to select elements, we're going to use the CSS selector, and so on, but we need a mechanism to find the correct selector to use. Fortunately, Chrome Developer Tools will come to our rescue once more; if we right click on the <span class="strong"><strong>Pilsner</strong></span> text in the top category menu item in Alcohology, then pick <span class="strong"><strong>Inspect Element</strong></span>, the elements panel will display with the menu item's element selected.</p><p>Next, right-click on the element and click on the <span class="strong"><strong>Copy CSS Path</strong></span> option:</p><div class="mediaobject"><img src="graphics/5308OT_11_05.jpg" alt="Up and running with CasperJS"/></div><p>The<a id="id680" class="indexterm"/> CSS <a id="id681" class="indexterm"/>select of this <code class="literal">div</code> tag will be copied to your clipboard and should look like this:</p><div class="informalexample"><pre class="programlisting">#gridview-1014-record-6 &gt; tbody &gt; tr &gt; td &gt; div</pre></div><p>We can now use this with CasperJS:</p><div class="informalexample"><pre class="programlisting">casper.test.begin('Application sanity checks', 0, function suite(test) {
    casper.start('http://localhost:1841/', function() {
        var selector = '#gridview-1014-record-6 &gt; tbody &gt; tr &gt; td &gt; div';

        casper.waitForSelector(selector, function() {
            test.assertSelectorHasText(selector, 'Pilsner');
        });
    });

    casper.run(function() {
        test.done();
    });
});</pre></div><p>After telling CasperJS to start and load the application's web page, we will use the <code class="literal">waitForSelector</code> method to wait until the specified selector appears on the page; by default, it'll wait <a id="id682" class="indexterm"/>for 5 seconds before throwing up<a id="id683" class="indexterm"/> a failure message. When the selector appears, the callback function is triggered and we use the <code class="literal">assertSelectorHasText</code> method to check whether the <code class="literal">div</code> tag has the correct text:</p><div class="mediaobject"><img src="graphics/5308OT_11_06.jpg" alt="Up and running with CasperJS"/><div class="caption"><p>Running our first CasperJS test</p></div></div><p>It's simple, but effective. If we'd broken something due to an amend in the code for the categories store, incorrectly bound the data to the view model, or some other minor change that cascaded to affect this key feature, then this test would immediately flag it up.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note25"/>Note</h3><p>CasperJS relies on another library called PhantomJS to drive the headless browser. There's an issue between the two in the current version that causes the <code class="literal">Unsafe JavaScript attempt…</code> message that you can see in the preceding screenshot; it's fine to ignore it.</p></div></div><p>We can do a lot more. Although the correct text is showing, the menu isn't just for display purposes, and when a user clicks on a menu item, it will load the products with this category. Can we <a id="id684" class="indexterm"/>create a CasperJS test for this?</p><p>Of course we can! Take a look at the<a id="id685" class="indexterm"/> CasperJS API documentation at <a class="ulink" href="http://docs.casperjs.org/en/latest/modules/casper.html#casper-prototype">http://docs.casperjs.org/en/latest/modules/casper.html#casper-prototype</a>.</p><p>Alongside the <code class="literal">start</code> method, we <a id="id686" class="indexterm"/>have ones such as <code class="literal">fill</code> that allows you to complete form fields: <code class="literal">scrollTo</code>, which lets us move to a particular location on the page, and for our current purposes: <code class="literal">click</code>, it provides a means to click on an element specified by a selector. Let's build another test using <code class="literal">click</code> to run a more advanced set of steps, something like this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Load the application</li><li class="listitem" style="list-style-type: disc">Click on the <span class="strong"><strong>IPA</strong></span> category</li><li class="listitem" style="list-style-type: disc">Select the <span class="strong"><strong>Lagunitas IPA</strong></span> product</li><li class="listitem" style="list-style-type: disc">Check whether the product window appear</li><li class="listitem" style="list-style-type: disc">Check whether the correct product name and price appear</li></ul></div><p>This is a much more comprehensive test that goes some way to demonstrating the power of CasperJS to replicate user actions and validate the behavior of our application. Here's the code:</p><div class="informalexample"><pre class="programlisting">casper.test.begin('Product walk through', 2, function suite(test) {
    casper.start('http://localhost:1841/', function() {
        var categorySelector = '.categories-body table:nth-child(2) td',
            productSelector = '.product-list .product:nth-child(2)',
            windowSelector = '.product-detail',
            headerSelector = '.product-detail h1',
            priceSelector = '.product-detail p.price';

        // Wait for the categories to load.
        casper.waitForSelector(categorySelector, function() {
            // Click the specified category.
            casper.click(categorySelector);
        });

        // Wait for the category products to load.
        casper.waitForSelector(productSelector, function() {
            // Click the specified product.
            casper.click(productSelector);
        });

        // Wait for the product window to appear.
        casper.waitForSelector(windowSelector, function() {
            // Assert text for heading and price.
            test.assertSelectorHasText(headerSelector, 'Lagunitas IPA');
            test.assertSelectorHasText(priceSelector, '£12.99');

            // Capture a screenshot.
            casper.capture('products-page.png');
        });
    });

    casper.run(function() {
        test.done();
    });
});</pre></div><p>The comments <a id="id687" class="indexterm"/>in the code should make it pretty self-explanatory. After setting out all of the selectors we need, we wait for the categories and click <a id="id688" class="indexterm"/>on the one that we need. Next, we wait for the product we want and click on it before waiting for the product window to appear and asserting on its contents. For the final trick, we instruct CasperJS to take a screenshot, a feature that can be useful for debugging or further evaluation.</p><p>Running this code gives us the following screenshot:</p><div class="mediaobject"><img src="graphics/5308OT_11_07.jpg" alt="Up and running with CasperJS"/></div><p>Success! We've simulated and validated a small user path through the Alcohology application, checking whether several moving parts of our project work in tandem as expected.</p><p>The<a id="id689" class="indexterm"/> eagle-eyed reader <a id="id690" class="indexterm"/>will notice that the selectors in this example look a little more friendly than the ones in the first example that we grabbed using Google Chrome. There's a very good reason for this and it relates to a set of ideas surrounding making your application easier to test.</p></div></div>
<div class="section" title="Testability"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec126"/>Testability</h1></div></div></div><p>As with<a id="id691" class="indexterm"/> many <a id="id692" class="indexterm"/>aspects of software development, there are many different ways of testing. Some will advocate a test-first methodology, where the tests are created first and the code will be written to satisfy these tests. Whichever method is used, we need to take steps to make sure our code can be tested. While this occasionally means adding in some helpful hooks and tricks that are only used to test, we should generally try to avoid this approach and look to write code that is naturally testable; this will often have the fortunate consequence of being better code too.</p><p>Sometime back, we talked about selectors and their relationship to testability. Let's look at the selector that Chrome Developer Tools gave us:</p><div class="informalexample"><pre class="programlisting">#gridview-1014-record-6 &gt; tbody &gt; tr &gt; td &gt; div </pre></div><p>This is a very specific selector and the first part of it is using an ID that was autogenerated by Ext JS. As soon as we add or alter the component hierarchy of the application or change the records being displayed on the page, this will break and our CasperJS tests will fail.</p><p>We can increase testability of our application by ensuring that our test code is less brittle. In this case, we can leverage the CSS classes that we use to style our application. Back in <a class="link" href="ch09.html" title="Chapter 9. A Shopping Application">Chapter 9</a>, <span class="emphasis"><em>A Shopping Application</em></span>, when we built the category list view, we set the <code class="literal">bodyCls</code> configuration option to <code class="literal">categories-body</code>. This gives us a great way to target the list that we know isn't going to randomly change.</p><p>Using it in addition with the <code class="literal">nth-child</code> pseudo-selector gives us a simpler and more robust version of our original Developer Tools selector:</p><div class="informalexample"><pre class="programlisting">.categories-body table:nth-child(2) td</pre></div><p>In plain language, get the element with a class of <code class="literal">categories-body</code>, find the second child table, which corresponds to the second row, and grab its <code class="literal">td</code> cell element.</p><p>Using<a id="id693" class="indexterm"/> Chrome Developer Tools is still a great way to look at the HTML structure of the page and work out an optimal selector for each case, but it's rarely going to provide the most robust selector.</p><div class="section" title="Should I or shouldn't I?"><div class="titlepage"><div><div><h2 class="title"><a id="ch11lvl2sec127"/>Should I or shouldn't I?</h2></div></div></div><p>There's plenty of lively debate about how testing should inform your code, if at all. In the last example, we had a useful CSS selector that was already being used for styling, but in the event we hadn't already placed it there, should it have been added specifically to support styling?</p><p>In this case, it's a very minor change, so we probably don't have to feel that bad about it. We could even wrap it in a Sencha Cmd directive to ensure that it doesn't get included in production builds:</p><div class="informalexample"><pre class="programlisting">//&lt;debug&gt;
bodyCls: 'categories-body',
//&lt;/debug&gt;</pre></div><p>In general though, anything that adds complexity or maintenance overhead to our main code base just to improve testability should be avoided. Instead, we can look at ways in which the design of an application naturally promotes testability.</p><p>Earlier in the book, we talked about MVC and MVVM and how one of the benefits of such patterns is to promote the separation of code concerns. Throughout, we've used events to ensure that components can "fire-and-forget" and trigger actions without having an awareness of other parts of the system.</p><p>This is a key feature that gives an elegant, clear design combined with a side benefit of separation of components. We can pluck out individual views, render them alone on a simple page, and perform tests on a single component in isolation. As in our Jasmine examples at the start of the chapter, we can take a single model and instantiate it without having to worry about the user interface layers.</p><p>The beauty of good application architecture is that it provides an understandable application that immediately lends itself to testing. Although, integration testing is an important weapon in our arsenal, it's much more important to ensure that the various parts of the machine are well built before trying to fire the whole thing up.</p></div></div>
<div class="section" title="Faking it with mocks"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec127"/>Faking it with mocks</h1></div></div></div><p>When it's up and running, our application still has one giant dependency: the server. During integration testing, this means that the server-side database needs to be primed with test data, and test suite will result in many requests being sent back and forth. In a large test suite, this can be slow and the database setup can be painful.</p><p>A common resolution to this problem is to bypass the server API altogether. When our application makes an Ajax request, we can hijack the <code class="literal">XMLHttpRequest</code> and feed the calling code some static test data instead.</p><p>To<a id="id694" class="indexterm"/> demonstrate this and show the flexibility of the technique, we'll create a small Jasmine test case that shows how to supply a product store with mock JSON data. Although, faking an Ajax request is really useful in integration tests, this will show off the technique in a succinct way that can be used in both unit and integration testing.</p><p>We'll be using a feature of Ext JS that isn't included by default: <code class="literal">Simlets</code>. The classes that implement <code class="literal">Simlets</code> are included in the <code class="literal">examples</code> directory of the Ext JS distribution, so all we have to do is open up the <code class="literal">SpecRunner.html</code> file from earlier in the chapter and amend it to instruct <code class="literal">Ext.Loader</code> to pull in the files from the correct location:</p><div class="informalexample"><pre class="programlisting">Ext.Loader.setConfig({
    enabled: true,
    paths: {
        'Alcohology': '../../app',
        'Ext.ux': '../../ext/examples/ux' // added
    }
});</pre></div><p>All we've <a id="id695" class="indexterm"/>added is the line for the <code class="literal">Ext.ux</code> path. Now, we can build our Jasmine test, so let's dive straight into the code:</p><div class="informalexample"><pre class="programlisting">describe('Mocking Ajax', function() {
    var productStore,
        fakeJsonData = [{
            "id":1,
            "name":"Test Product",
            "price":"19.99",
            "description":"Test Product Description"
        }];

    beforeEach(function() {

        Ext.syncRequire('Ext.ux.ajax.SimManager');
        Ext.syncRequire('Alcohology.model.Product');

        Ext.ux.ajax.SimManager.init().register({
            'http://localhost:3000/product': {
                type: 'json',
                data: fakeJsonData
            }
         });

        productStore = Ext.create('Ext.data.Store', {
            model: 'Alcohology.model.Product'
        });
    });

    it('Uses fake JSON data', function(done) {
        productStore.load({
            callback: function(records) {
                expect(records.length).toBe(1);
                expect(records[0].get('name')).toBe('Test Product');
                done();
            }
        });
    });
});</pre></div><p>Lots going on here! First, we set up a couple of variables, one to contain the <code class="literal">productStore</code> between tests and one containing our fake JSON.</p><p>In the <code class="literal">beforeEach</code> function call, we load in the <code class="literal">SimletManager</code> class and the <code class="literal">Product</code> model from Alcohology; <code class="literal">Ext.Loader</code> will pull in the files for us before allowing execution to proceed to the next lines. Next, we set up <code class="literal">SimletManager</code> by registering the URL to be intercepted and the data that should be returned instead of the normal server response.</p><p>This is <a id="id696" class="indexterm"/>actually all we need to set up a fake request; the rest of the code proceeds as if it were a normal Jasmine test in which we set two expectations after the product store loads, that is, there will be one returned record and its name will be set to <code class="literal">Test Product</code>, just like in the test data.</p><p>Running the test through the spec runner sees everything pass as expected and demonstrates the power of this technique. We can disconnect all of our testing from the backend and run independent of a database; test data is supplied directly in the tests and not in a database row somewhere on a server.</p></div>
<div class="section" title="Continuous coverage"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec128"/>Continuous coverage</h1></div></div></div><p>You've learned how to use a couple of different testing tools in this chapter, but what about when to use these tools?</p><p>When it comes to code testing, there's a metric known as "code coverage" that tells us the percentage of our code that is covered by tests. The first thought of a passionate architect starting a new project is that everything should be covered with tests, tests everywhere!</p><p>Realistically, there are things that we just don't need to test; as always, we should take a pragmatic approach. Configuration of components probably doesn't need to be tested; we don't need to test the return values from third-party code libraries; there are many examples.</p><p>Having said that, code coverage<a id="id697" class="indexterm"/> is a useful way to make sure that a certain level of testing is maintained in a project. For example, we might wish to have 90 percent test coverage of our model code and only 50 percent coverage on our controllers, which contain more boilerplate that doesn't need to be tested. The exact ratios will depend on the project, the developers, and indeed the architect.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note26"/>Note</h3><p>There are many <a id="id698" class="indexterm"/>code coverage tools for JavaScript, one of which is Istanbul. It provides a comprehensive set of features to check code coverage in a variety of ways and reports on the level of coverage in a range of formats. You can<a id="id699" class="indexterm"/> find this on GitHub at <a class="ulink" href="https://github.com/gotwarlost/Istanbul">https://github.com/gotwarlost/Istanbul</a>.</p></div></div><p>When a project is well covered by unit tests and integration tests are in place to make sure the user experience remains consistent, we're left with one part of the puzzle: when to run these tests?</p><p>Of course, a developer should be running the relevant tests for the section of code they're working on, but in reality, a full test suite can take a long time to execute. In such cases, we can make use of something called <a id="id700" class="indexterm"/>
<span class="strong"><strong>continuous integration</strong></span> (<span class="strong"><strong>CI</strong></span>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note27"/>Note</h3><p>Jenkins CI is<a id="id701" class="indexterm"/> an open source CI system (<a class="ulink" href="http://jenkins-ci.org/">http://jenkins-ci.org/</a>) and <a id="id702" class="indexterm"/>Circle CI (<a class="ulink" href="https://circleci.com/">https://circleci.com/</a>) is paid for, but with a free plan.</p></div></div><p>Whenever a developer pushes new code to the source control repository, a CI server grabs that code and runs the tests. This enables us to see when a developer has committed code that breaks the current build; it also gives us peace of mind that a successful CI build will be one that has<a id="id703" class="indexterm"/> passed our automated checks and is well on its way to production.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec129"/>Summary</h1></div></div></div><p>Testing is a huge topic with many different libraries, programs, and techniques vying for the attention of software architects. As with many facets of our role, there's never one correct answer and the most important thing is to settle on something that works for our particular project.</p><p>In this chapter, we've reviewed a range of different ideas and approaches to testing Ext JS and touched on the ways in which we can ensure our architectural decisions trickle down into making testing easier. The different extremes of test—from unit to integration—can always benefit when we isolate certain parts of the system under test, from remote requests through to separation of code concerns.</p><p>Testing is an essential, yet often neglected part of Ext JS application architecture and this chapter is only an overview. This, and the other topics covered in this book, must be used in combination and alongside a constant search for new ideas in order to truly master the concepts we've touched on.</p></div></body></html>