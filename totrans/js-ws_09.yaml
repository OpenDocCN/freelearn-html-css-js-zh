- en: 9\. Working with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to describe the basics of and use
    `Node.js` to build basic web applications; differentiate between synchronous and asynchronous
    processing; use `Node Package Manager (npm)` to add, remove, and update the packages
    with your command-line interface; use built-in and third-party node modules; run
    MySQL and MongoDB databases; and build real-time web applications using `WebSocket`,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have covered the fundamentals and core basics of JavaScript. This
    includes understanding the core syntax of building interactive web-based programs
    using JavaScript code. A strong understanding of the foundation of this programming
    language will enable us to take a look at Node.js, which is beyond the browser.
    It forms the basis for the popularity of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will be introduced to Node.js. Before Node.js, JavaScript
    was used primarily for client-side scripting as part of the browser. In 2009,
    Ryan Dahl developed Node.js, a cross-platform, open-source JavaScript runtime
    environment that executes JavaScript outside the browser. It allows developers
    to use command-line tools and carry out server-side scripting. Basically, it unites
    the entire process of web application development through a single programming
    language as opposed to the developer having to learn different languages and build
    different projects for the server-side and the client-side.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is not just considered a programming language but an environment in
    which you can execute JavaScript. It is a popular programming language with a
    huge repository on GitHub that is sustained by contributions from thousands of
    developers all around the world. In this chapter, you will start with the installation
    of Node.js on all platforms, and then you will go through how it works in the
    background and how it processes requests asynchronously. Furthermore, you will
    study the different types of modules and how to use them. You will also do a lot
    of important exercises to get some practical exposure to Node.js. There are a
    lot of things to learn, so let's begin.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js has an event-driven architecture that is capable of processing requests
    asynchronously. Node.js has a single-threaded architecture. Traditional servers
    had multi-threaded architectures and they spawned a new thread as soon as a new
    request landed, but Node.js handles everything on a single thread. You may wonder
    how a single-threaded Node.js handles millions of requests. Well, the answer is
    the event loop. JavaScript works on a single thread and handles async operations
    thanks to its event-loop architecture. Any request that is taking a long time
    is sent to the background and the next request is addressed and processed. Before
    proceeding, let's understand the difference between synchronous and asynchronous
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: Sync versus Async
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If the execution of a program takes place in a linear sequence, it is synchronous
    processing. For example, in the following code block, an entire line will be read
    and executed before the process moves to the next line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This process works best with only one request. In the case of multiple requests,
    you have to wait for the previous request to finish. This can be as exciting as
    watching grass grow. To overcome this, you can handle the request asynchronously.
    This way, you will push any process that is taking too long from the execution
    stack to the background so that other code can be executed. Once the background
    work is done, the program will be pushed back again to the execution stack and
    processed further:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Background of Request Processing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js uses a library named `llibuv`. It handles asynchronous I/O very well.
    Instead of spawning multiple threads for each request, it manages a thread pool
    very efficiently with the help of the OS kernel. As soon as a new request lands
    on a Node.js server, it delegates most of the work to other system workers. As
    soon as the background workers finish their job, they emit events to Node.js callbacks
    registered on that event. This process is visualized in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1: Node.js event loop architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.1: Node.js event loop architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is much faster than multithreaded systems, even with a single thread.
    Therefore, Node.js uses event loop architecture with thread pool management, which
    makes it powerful and faster than its competitors.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Callbacks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Callbacks are a very important concept when it comes to asynchronous programming.
    A callback is a function that can be executed as soon as its primary function
    finishes. Callbacks are heavily used in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: A typical example of where a callback would be useful is reading text from a
    file. While a file is read, you do not want the server to wait for it to finish
    first. Reading a file can be handled by a background worker and as soon as it
    finishes, it will execute an event, which will be processed by the event loop.
    This event will then execute the callback.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js comes with a virtual terminal shell. It provides a quick way to use
    Node.js. You can execute expressions in the shell. You can also execute loops
    and define functions in the shell. To enter the shell, open your terminal and
    type node.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`REPL` is also a built-in module. You can also import it to your module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.01: Your First Program'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you know about the Node.js environment and its workings, you are ready
    to write your first script and execute it with Node.js. Let''s write our first
    very simple Node.js script in which we will just perform the sum of two numbers
    and will show the output on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `first.js`. Open the terminal in the same directory and
    add the following lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the function to get the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.2: Output of your first program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.2: Output of your first program'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you have written a simple function to add the two numbers, which you will
    pass when you call the function. Then, you will execute this script with Node.js
    and the output will be printed in the console.
  prefs: []
  type: TYPE_NORMAL
- en: How to Import/Require a Module in a Node.js Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Importing/requiring other modules in your program is very easy in Node.js.
    You can use `require` to import other modules into your Node.js application. Let''s
    say we need one of the built-in modules of Node.js in our script. We would use
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will look for the package within Node.js modules along with any globally
    or locally installed packages in the project. If it is found, it will import it;
    otherwise, it will throw an exception. When writing modularized code, you can
    create your own custom packages and import them using `require` with a relative
    path, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Node Package Manager (npm)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the good things about working with Node.js is that you can write highly
    modularized code. There are millions of packages available on the internet that
    can be used in your projects. But as the number of packages used in your projects
    grows, so too does the difficulty of handling them. Node.js comes with its own
    package manager, which is called npm.
  prefs: []
  type: TYPE_NORMAL
- en: npm has thousands of packages, and all are easily available through its web
    portal and through your command-line interface. It is used to manage the packages
    your application needs. You can add, remove, and update packages with your command-line
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`npm` is preconfigured at the time of node installation on all major platforms.
    In the case of Linux, if you are facing issues while accessing `npm` after successfully
    installing Node.js, then you have to add the path of `npm` to the `$PATH` variables.
    Check the Linux installation part in the *Preface* of the book for more details.
    In the case of Windows and Mac, it''s most likely that you will not face any issues.'
  prefs: []
  type: TYPE_NORMAL
- en: Flags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the useful command-line flags are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-g` = Install the package globally, that is, in the system.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-S` = Save the package as a project dependency. Similar to `–save`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-D` = Save the package as a `dev` dependency. Similar to `--save-dev`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v` = Check the currently installed version.'
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the very useful commands of `npm` are given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`i` parameters of `npm`. For instance, say you wanted to add `express.js` to
    your program – you would do that as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`npm`. For instance, you would use this if you wanted to update `express.js`
    in your program:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`rm` parameters of `npm`. For instance, say you wanted to remove the previously
    installed package (`express.js`) from your program – you could do so this way:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`npm` registry. Use the `publish` parameter to push the package to the `npm`
    registry:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`search` parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: package.json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`package.json` is a file that always stays in the root of the project. It is
    a manifest file that almost all `Node.js` projects have. This is the file that
    `npm` uses to manage dependencies. Before starting development in `Node.js`, everybody
    should understand what `package.json` is and what it does. It basically serves
    two main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing the dependencies of your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing scripts that help to generate builds, run tests, and other stuff related
    to your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can define start scripts in this file, which will help you to inject environment
    variables into your project. You can even use this file to configure the production
    and development environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create this file in the project root, execute the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You will be prompted to answer a question. You can simply press *Enter* to
    skip it and a file named `package.json` will be created in your current directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3: Sample output of package.json'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.3: Sample output of package.json'
  prefs: []
  type: TYPE_NORMAL
- en: Publishing a Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `npm` registry is completely open to new packages. You can build and upload
    your own package to the `npm` registry, and to do that, you just need a directory
    with a `package.json` file in it. You can just write your module and update the
    `package.json` parameters. Then, you use the following command to push it to the
    registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can now search for your package at [https://www.npmjs.com](https://www.npmjs.com)
    and anyone can install your package as a dependency in their project.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you were introduced to Node.js and its workings, and you wrote
    and executed your first Node.js program. You learned how to handle Node.js packages
    efficiently. You understood the purpose and importance of `package.json`. This
    was just the introduction. Now that we've introduced you to Node.js, let's dive
    deeper into managing Node.js packages and using them in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Node Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To start with, we can say that Node.js modules can vividly comprehend the dependencies
    of an application. Suppose that you have created an easy-to-use payment application,
    say, for a restaurant. You have developed a payment app. Now, you get the idea
    to implement a QR scanner inside your app to make bill payments even easier. Well,
    you have two choices. Either create the entire feature yourself by spending time
    developing, or you can install the same functionality in your application using
    `npm`'s vast inventory of modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need to do is follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to search for the module name, say, **QR scanner**, to use in your
    Node or Angular application on Google.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The very first link you need is [https://www.npmjs.com/](https://www.npmjs.com/).
    In this inventory, you can see many efficient Node.js modules. You can find a
    vast variety of modules there to use for anything from beautifying your terminal
    to rectifying your code. When you have got the module you need, you will have
    to install and merge it with your application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that you have the module, you just need to implement it in your application.
    Finally, the last step is to install the module in your application by entering
    the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will add your module as a dependency in your `package.json` file. You
    just need to import or require it as per the tech syntax. Just copy and paste
    the functions as per the installed module''s guidelines. Now is the time to run
    your application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You now have some wonderful new features in your application, added in a matter
    of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize this, a Node.js module is a properly bundled magical box consisting
    of one or more JavaScript files destined to fulfill a specific operation in your
    application, in the most efficient and sustainable way, that are maintained by
    its developers consistently.
  prefs: []
  type: TYPE_NORMAL
- en: You can even make your own Node.js modules and publish them. That makes you
    an open source contributor. Before moving onto that, let's jump into an interesting
    discussion about built-in node modules.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are numerous modules included with Node.js that do not require installation.
    One such basic module is the URL module.
  prefs: []
  type: TYPE_NORMAL
- en: '**URL**'
  prefs: []
  type: TYPE_NORMAL
- en: 'URL is a module provided by Node.js that is used to split complicated URL strings
    into a more readable format. It can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some utilities provided by this module that you can use to resolve
    and parse a URL. If you look at any URL closely, you will find that it contains
    some particular components written in a complex format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4: Breakdown of URL into different terms'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.4: Breakdown of URL into different terms'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the URL module to solve any difficulty that you're having. The module
    treats the URL as an object and each component inside the URL is treated as a
    property of the object, meaning you can access each and every part of the URL
    without difficulty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the useful properties of URL are shown in this table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5: URL Properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.5: URL Properties'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.02: Updating URL Information Using the URL Module'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To try and understand the different properties of a URL, let''s do an exercise
    where we will try to update the information of a URL, such as the pathname and
    host. This will help us understand how to manipulate the properties of the URL
    object to alter URLs when we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty file and save it with the `.js` extension. For this exercise,
    let's create `url.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first thing to do is to import the URL module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s use the `parse` function of the URL module and try to process a
    URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After calling the `parse` function, in return, you will get a processable object.
    This object will contain all the metadata of that URL. We can then use this object
    to manipulate the URL. Let''s change the host, pathname, and hash of the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s use the `format` function of the processable URL object to format
    it into a string and print it using the `console.log` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, just execute the script using Node.js. It will print the new URL,
    which you have updated using the properties of the URL object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.6: Output of the URL program'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.6: Output of the URL program'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to manipulate the properties of a URL. We modified
    the different components of a URL by using different functions provided by the
    URL module.
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a Node.js section that you can use to work with the filesystem. You
    can perform various operations on files and directories using this module, such
    as create, update, read, and delete operations. The `try...catch` statement is
    a block of statements that are used to handle the exceptions that occur using
    synchronous operations. These exceptions may also be allowed to bubble up.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Before proceeding further, know that you will perform all of these operations
    on an `intro.txt` file, which contains the introduction of Node.js. So, make sure
    that you have the `intro.txt` file with some content in the root of the project
    where you will write these scripts. You can run and test scripts by simply typing
    `node NameofYourFile.js` in your terminal window, making sure that you have the
    appropriate rights.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various ways in which you can use this module are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`read` is used to read files in the filesystem using the `fs.open()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will print all the data of the file to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`append` adds specific content to files using `fs.appendFile()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will append the line that you passed as the second parameter to the `appendFile`
    function to the file of the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Renaming the files in the filesystem is done using the `fs.rename()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will rename the `intro.txt` file to `introduction.txt` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Files can be deleted using the `fs.unlink()` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You use `unlink` to remove any file from the filesystem. Just pass the relative
    path or filename that you want to remove, and it will unlink that file/path from
    the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Operating System
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section provides a number of operating system-related utility methods.
    It can be imported using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the important functions of this module are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`os.arch()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method will return the operating system's CPU architecture for which the
    Node.js binary was compiled, that is, `arm`, `arm64`, `x32`, `x64`, and so on.
    This module is very helpful if you are designing any architecture-dependent module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`os.cpus()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method will return an array of objects that contains all the information
    about each CPU core.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`os.hostname()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method will return the hostname of the operating system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`os.platform()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method will return the operating system platform for which Node.js is compiled.
    This will be set during the compile time of Node.js. Some of the famous platforms
    are Darwin, freebsd, linux, openbsd, and win32.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`os.networkInterfaces()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This method will give us all the information regarding network interfaces that
    have been assigned a network address. It will return an object, and each key will
    identify a network interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 9.03: Fetching Details about the Operating System'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore this module with a simple exercise. In this exercise, you will
    use Node.js'' `OS` module to get details about the operating system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to import the os module using `require` in your Node.js script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, you can access this `os` object to call its properties and get the information
    necessary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can then change the flow of your code execution based on the architecture
    on which the script is running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The output will be visible as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.7: Some useful methods of the built-in os module in REPL mode of
    node'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_09_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.7: Some useful methods of the built-in os module in REPL mode of node'
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned some useful methods to change the flow of code
    execution based on the architecture of the script and fetch details about the
    operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Path Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `path` module provides utilities for working with file and directory paths.
    It can be imported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the important functions of this module are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path.dirname(pathString)`'
  prefs: []
  type: TYPE_NORMAL
- en: This method will return the directory name of a path. It is similar to Unix's
    `dirname` command.
  prefs: []
  type: TYPE_NORMAL
- en: '`path.extname(pathString)`'
  prefs: []
  type: TYPE_NORMAL
- en: This method will return the extension of the path. It will move from the last
    occurrence of the . (period) character of the entered path to the end of the path.
  prefs: []
  type: TYPE_NORMAL
- en: '`path.format(pathObject)`'
  prefs: []
  type: TYPE_NORMAL
- en: This method will return a path string from an object with specific keys. This
    is the opposite of `path.parse()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`path.join([...pathStrings, pathString... ])`'
  prefs: []
  type: TYPE_NORMAL
- en: This method joins all the given path segments together using a platform-specific
    separator as a delimiter, then normalizes the resulting path. It's very useful
    when you are switching directories programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.04: How to Extract and Join Directories'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s explore the `path` module in detail by working on an exercise. In this
    exercise, you will extract the directory from absolute and relative paths, join
    directories, and extract file extensions from a path:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty file and save it with a `.js` extension. For this exercise,
    let's name it `path.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s take some sample directories and filenames for you to use to observe
    how the `path` module manipulates paths. Note that these paths are related to
    Windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'First, let''s get the directory from a path. Let''s say that you have one path
    of a file (`/Users/YourUserName/Documents/node/modules/myFile.js`) and you want
    to extract the directory where this file exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s extract the file extension from the path string. For that, you
    have to use the ''`extname''` function of the `path` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s try to join multiple directories and files to create a path.
    You can use the `join` method of the `path` module for this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that you have the finished code snippet, run `node path.js` in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The screenshot of this preceding code will be displayed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.8: Output of the path program'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_09_08.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.8: Output of the path program'
  prefs: []
  type: TYPE_NORMAL
- en: We can see the path to the directory in the preceding figure. We also learned
    to extract file extensions from a path.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`http` is the most important module of Node.js. It helps you to spin up a server
    that will listen to one specific port. It will let you transfer information over
    **Hypertext Transfer Protocol** (**HTTP**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createServer` function takes one function as a parameter, which will be
    called when you make any request to the server. That function has two parameters:
    `req` and `res`. The first, the request parameter, is a stream that holds all
    the details of the request. For instance, if you are using a `POST` request to
    submit a form, then this object will hold all the values in it. The response parameter
    is also a stream, and you can use it to update the response header, status, and
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you are updating one key in the header and writing the status code as
    `200`, which is "OK." The difference between a parameter and a query is highlighted
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.9: Difference between a parameter and a query'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.9: Difference between a parameter and a query'
  prefs: []
  type: TYPE_NORMAL
- en: You can also get the parameter and the query from the same `req` object, which
    will help you to process the request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.05: Using a Node.js Server'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start our first Node.js server. This will be a very basic server that
    will just greet all requests with a "Hello World!" response. We will learn how
    to start up a server on a particular port and how to write responses to requests.
    Let''s jump straight into coding:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `http_server.js` and copy the following content into the
    file, then save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It should display as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.10: Node.js server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_09_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.10: Node.js server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the `http_server.js` file using the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then open the browser and go to `http://localhost:3000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11: Output from the Node.js server in Chrome'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.11: Output from the Node.js server in Chrome'
  prefs: []
  type: TYPE_NORMAL
- en: We can see the `Hello World` response in the browser by starting the server.
    We learned how to use a Node.js server and how to write responses to requests.
  prefs: []
  type: TYPE_NORMAL
- en: Third-Party Modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node has a huge library of packages where a lot of developers have written and
    published useful modules for you to use. You can simply download these modules
    using `npm` and use them in your projects. There are thousands of packages available
    in the `npm` repository. Let's look at some of the useful third-party packages
    available for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Express` is one of the most popular frameworks of node.js. It is one of the
    reasons why Node.js is so popular. It is a minimal, open-source, and flexible
    web application framework that provides a robust set of features for web and mobile
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can install it using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting up a web server is extremely simple in `Express`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The server is up and running in just four lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Routing in Express
  prefs: []
  type: TYPE_NORMAL
- en: '`Express` has taken care of routing very well. You can write modularized routes
    in Express. The following code can be used to set up **basic routing**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The bodyParser Module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSON is a very common data sharing format that is used by over 90% of the web
    applications on the internet. Managing JSON is very easy in JavaScript, but when
    it comes to sharing JSON online, it becomes a little more difficult. For this
    purpose, we use the `bodyParser` module. Data is shared as buffer on the internet.
    This module works as a middleware between the request received and your application.
    It converts the buffer to plain JSON and binds it to the request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Morgan Logger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`morgan` is a logging module. Every time a request hits on the server, your
    application logs the request to reveal the real status of your server. A server
    can handle multiple types of requests. So, the application must log all the requests
    to check the health of the server. There are a lot of benefits to using loggers
    on a server. Some of them are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: You can track how many requests the server is processing in a day, week, month,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see how much time each request is taking to process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see the types of requests that are getting hit, such as `GET`, `POST`,
    and `PUT`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see what endpoints are being used frequently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The module will maintain all the error logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`morgan` is very easy to use and is a configured middleware `npm` module for
    node applications. You can install it by entering the following command in your
    terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use it in your application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you just need to add this one line to create a middleware between
    `morgan` and your Node.js application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following log:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.12: Output from the Node.js server in the terminal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.12: Output from the Node.js server in the terminal'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we learned how to use built-in and third-party node packages
    in your project. You learned how to use routing and how to log requests on the
    server. It does not end here, though; you can write your own custom modules as
    well. The only thing you need to do is export one of the entry functions. An example
    is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.13: Example of export and require using Node.js'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.13: Example of export and require using Node.js'
  prefs: []
  type: TYPE_NORMAL
- en: Think of a module export as a variable. A module export is a variable in which
    you will put some value and you can get the same data wherever your application
    requires this file. You can export functions, JSON, strings, or any type of data
    from any JavaScript file to any other JavaScript file in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to the server-side, databases are very important. All the data
    that your applications need to store for future reference have to be stored somewhere.
    In this topic, you will learn how to use two of the most popular databases: MySQL
    and MongoDB.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we will work with two of the major database types present
    today. Before proceeding further, let''s go through different ways in which we
    can connect with databases. There are two ways to connect with databases:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Locally: When a database server is running on your machine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remotely: When a database server is running on some other machine and you are
    accessing it through the internet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have your database server running somewhere in the cloud and you can
    access it using a URL along with credentials. But for this section, let's set
    up both databases locally on the machine and let's connect to them using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: The installation of both databases is pretty straightforward. You can download
    the latest bundles from their official websites and install them as you install
    other applications. For installation guidelines, you can follow their official
    documentation, which is very easy to understand. They have also covered installation
    on all different types of platforms, such as Windows and Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL : [https://packt.live/32ypsRH](https://packt.live/32ypsRH) MongoDB: [https://packt.live/2PY7SDV](https://packt.live/2PY7SDV)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting with Databases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After installing, you have to start both the database servers and configure
    a user. This is the user whose credentials you will use to get access to the database.
    For learning purposes, give this user administrator privileges so that you will
    have all the permissions to perform various types of actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to connect with databases, we require some information about the server
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Host**: The host will be the domain name or the IP address of the server
    where the database is running.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Port**: This will be the port number on which the database server is listening.
    By default, MySQL database runs on port 3306 and MongoDB runs on port 27017\.'
  prefs: []
  type: TYPE_NORMAL
- en: '**User**: Here, we have to specify the username of any active user of the database.
    We always create an administrator user just after finishing the installation.
    It is not recommended to use an administrator account with applications in production,
    but for learning purposes, we can use it. In a production environment, we must
    create a database user that has limited and necessary access only.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Password**: The password of the user will go here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database**: Here, we have to mention the name of the database with which
    we want to initialize the connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to specify this configuration to the database driver that we will use
    when making connection with database. For example, when making a connection with
    MySQL, we have to specify this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If the port is not mentioned, it will pick the default value of the port number.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn more about how to make a connection and how to use this connection
    to fetch and save data for both MySQL and MongoDB in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL is a relational SQL database management system. It is one of the oldest,
    most successful, and most popular open-source databases in the world. It is widely
    used for developing various web-based software applications.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL library is one of the most widely used `npm` libraries. Millions of
    developers use this library worldwide. The best way to learn about configuring
    the database is with practice. Let's go through a very useful exercise that will
    help you to learn about database setup in any Node.js project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.06: Install, Connect, and Process Responses with a MySQL Server'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s do an exercise in which we will install a MySQL driver and connect it
    to a MySQL server. We will also take a look at how to fire MySQL queries to the
    database and how to process the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use this module with node, you can install it into your project
    as a dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After installing it, you can require it in the project using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After importing it into the project, you have to make a connection with the
    database. For that, you can use the `createConnection` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If everything went fine, the connection will be ready. You can fire the MySQL
    query using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Before closing the connection, note that port 3307 is the author's local port.
    The standard MySQL port is 3306.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.14: Passing credentials in MySQL Server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_09_14.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 9.14: Passing credentials in MySQL Server'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Make sure that you pass the credentials of the user you created earlier while
    going through the previous section (*Setting Up Databases*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When done querying the database, you can close the connection using:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To check the connection, use the following query to the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this exercise, we connected to a MySQL server and fired MySQL queries to
    the database to process the responses.
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB is a leading open-source NoSQL database. It is a document-oriented database
    program written in C++. It uses a JSON-like structure to store data, which is
    why it is most popular for use with node apps. It is also a part of the MEAN stack,
    which is one of the most popular tech stacks in the world today. The MEAN stack
    is a combination of the four major technologies of MongoDB, Express.js, AngularJS,
    and Node.js. In MongoDB, tables are referred to as collections, and data rows
    are referred to as documents. Documents are formatted in JSON format and are,
    by default, schema independent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to run the local MongoDB server first, and then get the URI to the
    connection. A URI contains the protocol, authentication, port, and database name
    a single string. You will learn about the format of the URI soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.07: Installing and Configuring a Connection in MongoDB'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s write some code in Node.js to help us connect our application with MongoDB.
    After this exercise, you will be able to install MongoDB and configure a connection
    with MongoDB using Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to install the driver, use the following command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in your application, make it a requirement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then you have to prepare a connection URL. It must be in the following form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can use this URI to connect with MongoDB:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output will be displayed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.15: Successful connection with MongoDB'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.15: Successful connection with MongoDB'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you pass the credentials of the user you created earlier while going
    through the *Setting Up Databases* section.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, you learned about one of the main database that we have in
    the industry today. So far, you have learned about what MySQL and MongoDB are
    and how to use them with node apps.
  prefs: []
  type: TYPE_NORMAL
- en: Making Real-Time Web Apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our world is very dynamic, and we are living in an era where live communication
    is crucial. Whether talking to another person in real life or following cricket
    scores, real-time communication, and data are very important. The best thing about
    Node.js is its support for streams and WebSocket. Node.js is the perfect tool
    for creating a real-time web application.
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WebSocket provides a continuous full-duplex communication channel. This means
    that both the server and the client communicate and exchange data at the same
    time over a single TCP connection. With WebSocket, clients do not have to refresh
    a page to see changes. The server will push the date back to the client. WebSocket
    helps facilitate the dynamic flow of connections, resulting in communication at
    both ends being achieved at considerable speeds. It means that you can now receive
    and send data on one connection only.
  prefs: []
  type: TYPE_NORMAL
- en: 'A server can configure the client in real-time because of the lack of lag in
    communication, and the client can continuously share its data with the server,
    which will allow it to analyze and optimize the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16: Duplex tunnel between client and server with WebSocket connection'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.16: Duplex tunnel between client and server with WebSocket connection'
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket connection is made through a process known as the WebSocket handshake.
    This process starts with the client initiating a regular HTTP request to the server.
    Any additional information will be included in the header of this request, which
    informs the server that the client wishes to establish a WebSocket connection.
    If the server has WebSocket configured, it will accept the request. When the handshake
    is complete, the initial HTTP connection is replaced by a WebSocket connection.
    This connection uses the same underlying TCP/IP connection that HTTP uses. Now,
    either the frontend or backend can start sending data.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.IO
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Socket.IO is a library that enables real-time, bidirectional, and event-based
    communication between the browser and the server. It is built to make the use
    of WebSocket easier. It only requires two things:'
  prefs: []
  type: TYPE_NORMAL
- en: A Node.js server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A JavaScript library for the browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports auto-connect, which means if one client disconnects for any reason,
    it will continuously try to reconnect with the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at how to install it in your project. Use the following command
    in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, configure it with your app server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '`socket.io` is now configured with the app server. You can bind events and
    listeners using the `io` variable. Now, whenever a new client connects with the
    server, it executes a connection event where you can get all the information regarding
    the sockets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That's it. It is really that simple to configure socket.io with your app server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 9.08: Building a Chat Application'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s make a real-time chat application using node and socket.io. In this
    exercise, we will create an app that will allow us to start multiple sessions
    for different users and develop a real-time chat experience between users. This
    will be a very basic and simple chat application where you will be able to create
    a group where:'
  prefs: []
  type: TYPE_NORMAL
- en: You can chat in real-time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More than one person can join the group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each member will be assigned fake names by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change your name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see who is typing at any time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before proceeding further, let''s go through the file structure of our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.17: File structure of this exercise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.17: File structure of this exercise'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`App.js`: This file contains all the server-side configuration. In this file,
    we will configure `socket.io`, write all events and listeners, and perform the
    routing of the requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chat.js`: This file contains all the code required for the client-side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Start the server and configure it to use `socket.io` in `app.js` by adding
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, WebSocket is configured with the server. Let''s create some events and
    listeners that will help us communicate with the client (frontend) and listen
    on every connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The application is listening for two events, `typing` and `change_username`.
    They will be executed whenever a socket emits these events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, you are done with your server-side code. Let's work on the frontend (client).
    First, import the socket.io library to the client-side. After a successful configuration
    of the server, you can open `http://localhost:3000/socket.io/socket.io.js` in
    your browser, which will download a script file. This is the file that you have
    to import on the client-side.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `script` tag inside `index.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The complete file will look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's configure the client-side by connecting the client-side to the server.
    Create a file named `chat.js` and make sure that both `index.html` and `chat.js`
    are in the same directory or folder. If you want to move the files to different
    locations, then you have to reflect this in the `import` link in your `index.html`
    as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You have to declare the link to the server where the request will be forwarded
    to in `chat.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are using `localhost` because the server is running on our local machine.
    It listens for events that are executed by the server. In this case, we need to
    listen for `keyboard typing`. Enter the following code snippet below the declared
    connection in the `chat.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the server file with the following command in your terminal to start
    the server and listen to all requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, open two instances of Chrome and visit `http://localhost:3000`. These
    two instances of Chrome will create two sessions, which will mimic two different
    users. Just start typing and sending messages to have a good conversation in real-time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The code will be available in the GitHub repository for this book at [https://packt.live/36KWlh0](https://packt.live/36KWlh0).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 9.18: Two Chrome sessions conducting a real-time chat'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.18: Two Chrome sessions conducting a real-time chat'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in this figure, there are two sessions of Chrome running. These
    two sessions represent two users. Both can chat in real-time. They can even see
    whether the other person is typing or not.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you were introduced to building real-time web applications
    in node using socket.io and you built a cool chat app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 9.01: Create a Web Application to Upload, Store, and Save Image Details'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A major part of web development is uploading media and referring to it in the
    future. In this activity, you'll create a web application that will allow you
    to upload images to a server and store them in a directory. To make it even more
    challenging, you'll need to save the image details in a database for further use
    and analytics.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This activity requires a MySQL database server to be running on the system.
    Please make sure that a MySQL server is installed and running on your machine
    before executing this script.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the request reaches the server, it will first rename the file and then
    upload the image to the directory, before sending the path of the images as a
    response back to the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.19: Output of the node server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.19: Output of the node server'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get the following log from the server-side:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.20: File is uploaded in the image''s directory on the server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.20: File is uploaded in the image''s directory on the server'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the file is uploaded to the directory successfully, you should see the
    following MySQL output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.21: MySQL output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_09_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 9.21: MySQL output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Details about the image file are also successfully stored in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the steps that will help you complete the activity:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the directory structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import all of the dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Node.js `morgan` module to log each of the request details in
    the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure your application to use the MySQL database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Establish the database connection to configure `Multer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add routing to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send a request to upload the image to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 738.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you have covered nearly all the basics of web development with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: You started with an introduction to Node.js, wrote your first program, and ran
    it. You learned about Node's package manager and the Node.js environments. You
    were guided through some of the useful built-in and third-party Node.js modules
    and discovered how you can import these modules in your application and use common
    modules such as `body parse` and `auth`. You created connections with databases
    using Node.js and learned how to make queries in the databases.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how to make a real-time web application and learned how
    to build a chat application. There are a lot of concepts still to cover because
    node is huge, however, you have the required knowledge to explore node further
    with ease. In the next chapter, you will learn how to use requests to communicate
    with other services. You will look into different types of requests and how to
    process and display data. You will also take a look at **RESTful APIs**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to the next chapter.
  prefs: []
  type: TYPE_NORMAL
