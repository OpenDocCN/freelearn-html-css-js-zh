- en: Chapter 6. Automated Web Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having finished discussing the substantive techniques for testing Backbone.js
    applications, we will now look into various means of automating our test infrastructure.
    The ability to programmatically run our test collection enables new and exciting
    use cases beyond a single developer manually running a test driver page during
    development. In this chapter we will explore the following automation and development
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Surveying scenarios and motivations for automating our test infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating different approaches for programmatically running a Backbone.js
    application test suite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing PhantomJS and adapter tools for frontend testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating our existing test infrastructure into the PhantomJS environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concluding our discussion on the principles and practices of Backbone.js application
    testing with suggestions and resources for the next steps after finishing this
    book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The world of testing beyond humans and browsers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, our test development workflow has comprised writing test suites,
    adding them to a test driver page, and firing up the test page in a web browser
    on a development computer. However, test infrastructures can be used in far more
    scenarios than just manually running web reports. Examining the ensuing use cases,
    we will see how automatically running our test collection in arbitrary environments
    (for example, from a command line or build script, and possibly without a web
    browser) has enormous potential for the application development process.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In collaborative software development, problems can arise when engineers develop
    code separately that they later merge into a common code base. Unforeseen interactions
    between the changes can cause integration errors, breaking the overall application.
  prefs: []
  type: TYPE_NORMAL
- en: One mitigation approach for such errors is continuous integration, which relies
    extensively on automated testing. Continuous integration aggregates and tests
    application code to detect integration errors early and automatically. For an
    in-depth introduction on the topic, see *Continuous Integration* by *Martin Fowler*
    at [http://martinfowler.com/articles/continuousIntegration.html](http://martinfowler.com/articles/continuousIntegration.html).
  prefs: []
  type: TYPE_NORMAL
- en: The process of continuous integration is typically implemented using a dedicated
    server that incrementally gathers code changes, creates a clean application environment,
    runs build commands, and acts on the command outputs. For instance, let's say
    we have a Node.js application stored on GitHub. A continuous integration server
    could download code changes from GitHub, create a new build directory for the
    application, install package dependencies (for example, `npm install`), and run
    the tests (for example, `npm test`). If any of the tests fail, the server will
    notify the developer(s) responsible for the changes. Some prevalent continuous
    integration servers include Jenkins ([http://jenkins-ci.org/](http://jenkins-ci.org/))
    and Travis ([https://travis-ci.org/](https://travis-ci.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A continuous deployment server is an enhancement of a continuous integration
    server that additionally deploys code to a live application environment (for example,
    production) if all the tests pass. It relies on automated tests to validate the
    entire application, so that code changes can be pushed out as fast as possible
    while retaining at least some semblance of quality assurance. The article *Why
    Continuous Deployment?* by *Eric Ries* at [http://www.startuplessonslearned.com/2009/06/why-continuous-deployment.html](http://www.startuplessonslearned.com/2009/06/why-continuous-deployment.html)
    is a good starting point for the motivations and practices behind continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Other scenarios
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test automation enables many other useful applications. For example, development
    utilities called **watchers** or **guards** check code periodically for modifications
    and perform further actions when the files change. Watchers are regularly used
    on a development machine to automatically run tests and display alerts when code
    changes have broken one or more tests, so that developers can discover errors
    quickly and effortlessly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-browser testing** is another area made easier through automation. While
    a programmer can manually run a test collection on many different target browsers,
    this is often time consuming, error prone, and boring. Fortunately, there are
    testing tools that can programmatically run tests on a number of arbitrary web
    browsers without human interaction.'
  prefs: []
  type: TYPE_NORMAL
- en: Automating browser environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having introduced some motivating use cases, we now turn to the nuts and bolts
    of automating our test infrastructure. We will cover the following techniques
    for programmatically driving our Backbone.js tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Remote controlling tests in a real web browser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running tests in a browser simulation library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing tests in a headless web browser environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining the first three approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote controlled web browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most comprehensive automation technique is to remotely control a web browser.
    Remote control means that a program does what a human can do using a *real* web
    browser—opening the browser to a given page, clicking on links, filling in inputs,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular remote control frameworks is **Selenium** ([http://docs.seleniumhq.org/](http://docs.seleniumhq.org/)).
    Selenium provides many **web drivers**, which are programmatic adapters that hook
    into a real web browser and trigger actions through the normal user interface.
    Selenium supports a diverse array of environments, providing web drivers on different
    operating systems for various browsers, including Chrome, Safari, Firefox, and
    Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Selenium project encompasses more features and functionality than just browser
    remote control. Notably, Selenium can use other test execution approaches, including
    headless web tools such as PhantomJS. See the Selenium projects page ([http://docs.seleniumhq.org/projects/](http://docs.seleniumhq.org/projects/))
    and the web driver list ([http://docs.seleniumhq.org/projects/webdriver/](http://docs.seleniumhq.org/projects/webdriver/))
    for starting points and additional information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automating our test infrastructure with a remote control tool such as Selenium
    involves two basic steps: open and run the test driver page and then, infer whether
    or not the tests have passed. As an example, we could write a Selenium script
    that opens a browser window to the Notes application test driver page `notes/test/test.html`
    in the code samples. The Selenium script could then scrape the report page HTML
    to check for a telltale string such as `failures: 0` in the DOM and terminate
    the script with an appropriate success/failure exit code.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, remote-controlled tools such as Selenium are quite powerful because they
    can do anything a real browser can do, just automatically. And, with a cross-platform
    compatible tool such as Selenium, we can run tests on nearly all modern browser/operating
    system combinations from a single script.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Hosted test automation providers**'
  prefs: []
  type: TYPE_NORMAL
- en: Capitalizing on Selenium's broad test environment support, vendors now offer
    services that allow users to upload a Selenium test script, designate a desired
    array of operating system/browser configurations, and have the service run and
    return test reports. One such vendor is Sauce Labs ([https://saucelabs.com/](https://saucelabs.com/)),
    which runs user scripts on virtual machines with various Selenium-supported test
    environments. Hosted services such as these are often the quickest way to get
    broad browser compatibility coverage with minimum developer effort.
  prefs: []
  type: TYPE_NORMAL
- en: The remote controlled approach does have a few downsides, the first of which
    is that the test tools can be relatively slow. Scripts can take seconds or even
    minutes to hook into a target browser and run a test driver page. Additionally,
    these frameworks require a real web browser and a desktop windowing system. This
    can be an issue for build/continuous integrations that are headless, meaning they
    have no graphical user interface or window environment installed by default.
  prefs: []
  type: TYPE_NORMAL
- en: Simulated browser environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative automation approach is to replace the web browser with a test-friendly
    simulation of the browser environment and state. Typically, browser simulation
    libraries provide implementations of the JavaScript API within a browser such
    as DOM objects (for example, `window` and `document`), CSS selectors, and JSON
    interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: '**JSDom** ([https://github.com/tmpvar/jsdom](https://github.com/tmpvar/jsdom))
    is a prevalent simulation library that provides a fairly complete browser environment.
    JSDom is written in JavaScript and packaged as a Node.js module. Because Node.js
    can be easily scripted, JSDom offers us a good starting point for integrating
    and running Backbone.js tests from the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: Test automation is such a common use case that several test-friendly libraries
    have been written around JSDom. One such library is Zombie.js ([http://zombie.labnotes.org/](http://zombie.labnotes.org/)),
    which provides convenient browser abstractions and integration with various test
    frameworks, including Mocha. Using a library such as Zombie.js, we could write
    a Node.js script that creates a fake browser simulation, navigates to our Backbone.js
    test driver page, and scrapes the test result HTML to check if any tests failed.
    For a more in-depth treatment of testing JavaScript web applications with Zombie.js
    and Mocha, see *Using Node.js for UI Testing* by *Pedro Teixeira* ([http://www.packtpub.com/testing-nodejs-web-uis/book](http://www.packtpub.com/testing-nodejs-web-uis/book)).
  prefs: []
  type: TYPE_NORMAL
- en: Browser simulation libraries are fast because they run simulation code in the
    same underlying JavaScript engine as the test code without external dependencies
    (for example, on a real web browser executable). Simulation libraries are often
    quite extensible, as the simulation JavaScript code runs in the same process as
    the application and the tests.
  prefs: []
  type: TYPE_NORMAL
- en: However, simulations suffer from a few key drawbacks. One primary issue is that
    simulations can deviate from the true environment in a real web browser. Complicated
    browser interactions such as heavily chained event triggers or complex DOM manipulations
    can potentially break the simulation or behave differently than a real browser.
    Additionally, a browser simulation library provides only a single browser environment
    implementation and thus cannot test the quirks and differences across various
    real web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Headless web browsers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Between remote controlled browsers and simulation libraries are headless web
    browsers. A headless browser takes a real web browser and gets rid of the user
    interface, leaving only the JavaScript engine and environment. What remains is
    a command line tool that can navigate to web pages, execute JavaScript within
    the browser environment, and communicate through non-graphical interfaces such
    as alerts and console logging.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular headless toolkits is PhantomJS ([http://phantomjs.org/](http://phantomjs.org/)),
    which is based on the **WebKit** open source browser ([http://www.webkit.org/](http://www.webkit.org/))
    that powers browsers such as Safari. PhantomJS enhances WebKit with scripting
    support and a JavaScript API.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Backbone.js application tests with a headless browser is analogous
    to configuring a remote-controlled browser. Conveniently, PhantomJS ships with
    native support for a wide array of test infrastructures and offers third-party
    adapters for many others. See [https://github.com/ariya/phantomjs/wiki/Headless-Testing](https://github.com/ariya/phantomjs/wiki/Headless-Testing)
    for more test support details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Headless web tools have a mix of some of the best features of the previous
    automation approaches, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Headless JavaScript engines are often faster than remote control frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The browser environment is *real*, which avoids some of the API and correctness
    issues potentially found in browser simulations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Headless frameworks are usually easy to install and can be run on servers without
    a windowing environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the same time, headless browsers incur some performance penalties from starting
    up and running the browser engine. They also forgo cross-browser capabilities,
    because headless tools are tied to a specific web browser engine implementation.
    Considering the overall advantages and disadvantages, headless frameworks provide
    a good compromise between the many mutually exclusive automation features.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple environment aggregators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Capitalizing on the benefits of various approaches, many frameworks aggregate
    different automation schemes into a single package. For example, the following
    test frameworks can programmatically drive tests in major web browsers *and* PhantomJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testem** ([https://github.com/airportyh/testem](https://github.com/airportyh/testem))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Karma** ([http://karma-runner.github.io/](http://karma-runner.github.io/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aggregation frameworks are desirable because they allow a single test collection
    to be reused in different automation environments, although some tools are more
    difficult to set up and maintain than a single automation tool.
  prefs: []
  type: TYPE_NORMAL
- en: Headless testing with PhantomJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a concrete automation example, we will adapt our existing Backbone.js test
    infrastructure to use PhantomJS. PhantomJS offers an amenable set of features
    and capabilities for Backbone.js testing—it is fast, relatively easy to set up,
    and provides a real (headless) browser. As a practical matter, larger Backbone.js
    applications often require a real browser engine to function properly, particularly
    applications that exercise the murkier and more complicated parts of the browser
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Installing PhantomJS and the supporting tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get up and running with PhantomJS, let's start by installing the toolkit
    as per the instructions at [http://phantomjs.org/download.html](http://phantomjs.org/download.html).
    Note that the installation procedures are operating system dependent, with packages
    for Windows, Mac OS X, and Linux. Alternatively, PhantomJS can be installed directly
    with NPM using the `phantomjs` Node.js wrapper ([https://github.com/Obvious/phantomjs](https://github.com/Obvious/phantomjs)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We provide command line examples in this section from a UNIX-like operating
    system such as Linux and Mac OS X. At the same time, PhantomJS and Node.js have
    first class support on Windows, so the ensuing examples should be mostly analogous
    to what will work on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installation is complete, you can verify that the PhantomJS binary is
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With PhantomJS in place, we next turn to the Mocha-PhantomJS bridge library.
    Mocha-PhantomJS uses PhantomJS to run a Mocha test driver page and transform the
    test results into formatted command line output. The library throws proper errors
    on test failures, making it quite useful for scripting. See the online documentation
    at [http://metaskills.net/mocha-phantomjs/](http://metaskills.net/mocha-phantomjs/)
    for additional capabilities and details.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Mocha-PhantomJS, you need the Node.js framework, which can be obtained
    by following the instructions at [http://nodejs.org/download/](http://nodejs.org/download/).
    A modern Node.js installation includes the NPM package manager tool used for Mocha-PhantomJS.
    We can confirm that Node.js and the package manager are correctly installed with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install Mocha-PhantomJS with the global NPM flag (`-g`) to make the `mocha-phantomjs`
    binary available anywhere in a shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After NPM finishes the installation, check whether Mocha-PhantomJS is available
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Running Backbone.js tests with PhantomJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the necessary tools installed, we can now adapt our Backbone.js test infrastructure
    to run against PhantomJS. Mocha-PhantomJS provides a replacement proxy object,
    `mochaPhantomJS`, to control Mocha tests and reports. We just need to replace
    the real `mocha` object where `mocha.run()` is normally called in the test driver
    web page. Inserting the following code snippet into the test driver page will
    allow Mocha to run *both* in a real browser and with PhantomJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have modified the test driver page with the `(window.mochaPhantomJS
    || mocha).run()` function call, we can execute the page tests with Mocha-PhantomJS.
    For example, if we modify the Notes application test driver file `chapters/05/test/test.html`
    from the previous chapter with the `mochaPhantomJS` change, we can run the file
    and generate the following command line report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Reviewing this report, we can see that all of our tests passed, and that the
    PhantomJS test run was quite fast, clocking in at 39 milliseconds. With these
    modest test driver web page changes, we can run nearly any test web page from
    the command line or a build script using PhantomJS.
  prefs: []
  type: TYPE_NORMAL
- en: Automating tests in the code samples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Putting these suggested principles into practice, nearly all of the test code
    samples presented in this book are scripted to run from the command line under
    PhantomJS. If you review the downloadable code samples repository, you will notice
    that all of the chapter and application test pages actually use the `(window.mochaPhantomJS
    || mocha).run()` function call instead of a raw `mocha.run()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The integration of PhantomJS into the code samples provides a practical starting
    point for some of the automated testing use cases that we discussed earlier in
    this chapter. Specifically, the examples implement the following automation scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Command line tests**: The code samples contain a Node.js NPM `package.json`
    file with script commands that can run chapter and application test driver pages
    with PhantomJS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous integration server**: The GitHub repository for the code samples
    ([https://github.com/ryan-roemer/backbone-testing/](https://github.com/ryan-roemer/backbone-testing/))
    uses the Travis continuous integration server for automated failure alerts. Travis
    is configured to run all of the example tests with PhantomJS on every code change.
    Travis is a particularly good choice for a test infrastructure such as the one
    presented in this book because its build environment already contains PhantomJS
    and it is quite amenable to Node.js and NPM modules such as Mocha-PhantomJS. To
    see all of this in action, you can navigate a browser to [https://travis-ci.org/ryan-roemer/backbone-testing](https://travis-ci.org/ryan-roemer/backbone-testing)
    at any time to check out the live build status for all of the code we have discussed
    in this book. (Hopefully you will find that all of our tests are passing!)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parting thoughts, next steps, and future ideas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now at the end of our journey through the fundamentals of testing Backbone.js
    applications with Mocha, Chai, and Sinon.JS. We have explored the background,
    configuration, and use of each of these test frameworks and tried out a number
    of complementary tools and helpers. We have reviewed Backbone.js application development,
    specific component testing goals, and written test collections around a full Backbone.js
    application. So, what comes next?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first suggestion is to review the online documentation for the various
    testing technologies. The official APIs and guides for all of the frameworks we
    use in the book are quite good and can provide starting points for more complicated
    test scenarios that may arise in real-world Backbone.js application development.
    As a refresher, the documentation sites for our core test stack include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mocha**: [http://visionmedia.github.io/mocha/](http://visionmedia.github.io/mocha/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chai**: [http://chaijs.com/](http://chaijs.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sinon.JS**: [http://sinonjs.org/](http://sinonjs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the framework documentation, you can review the article, blog, and book
    suggestions that we have provided throughout this book. In particular, the references
    in [Chapter 2](ch02.html "Chapter 2. Creating a Backbone.js Application Test Plan"),
    *Creating a Backbone.js Application Test Plan* on general test methodology and
    Backbone.js testing are great resources for those seeking a broader background
    in the software development and testing techniques appropriate for larger-scale
    Backbone.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we suggest that you download and install the book code samples. These
    samples are essentially the practical application of the principles we have covered
    in this book, with useful applications, tests, and files put together in a single
    package. Additionally, they provide examples of more testing and automation techniques
    for you to explore on your own, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Style checking**: JavaScript style checkers automatically analyze source
    files to find language or convention errors. Checkers are invaluable during software
    development, often finding programming errors early on and in places that tests
    can miss. Additionally, style checkers can enforce consistent coding styles for
    all members of a team working on a single application. The code samples use JSHint
    ([http://www.jshint.com/](http://www.jshint.com/)) to check all of the application
    and test examples that we have discussed in this book. You can inspect the `package.json`
    file in the code samples to see our JSHint usage in the script commands `style`,
    `style-server`, and `style-client`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code coverage**: Code coverage is a technique to quantify how much of an
    application is actually exercised by tests. Coverage tools run behind the scenes
    during tests, recording which application code lines are executed, and provide
    a report that measures the lines covered in each application file. The code samples
    provide a test driver page for the Notes application at `notes/test/coverage.html`
    that uses **Blanket.js** ([http://blanketjs.org/](http://blanketjs.org/)) to provide
    a coverage report. You can run the Notes test and the coverage report online at
    [http://backbone-testing.com/notes/test/coverage.html](http://backbone-testing.com/notes/test/coverage.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest is left up to you. While we are at the end of the road for this book,
    the world of testing will keep pushing forward in new and interesting ways. We
    bid you good luck in your continued learning and discovery of more testing tools,
    methods, and topics for Backbone.js application development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to remove manual browser interaction from
    the test process with an introduction to test automation approaches and use cases.
    We have investigated different tools to drive our tests from the command line
    and worked through a concrete test automation implementation using PhantomJS to
    drive our Backbone.js application tests.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we left with a few final thoughts on the principles that we have developed
    throughout the course of this book and where to turn next. Hopefully, you now
    have the fundamentals and direction to create your own Backbone.js test infrastructures,
    apply good test-driven application development practices, and tackle your frontend
    tests with confidence.
  prefs: []
  type: TYPE_NORMAL
