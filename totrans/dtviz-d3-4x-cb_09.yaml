- en: Chapter 9. Lay Them Out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a pie chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a stacked area chart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a treemap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an enclosure diagram
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The D3 layout is the focus of this chapter-a concept we have not encountered
    before. As expected, D3 layouts are algorithms that calculate and generate placement
    information for a group of elements. However, there are a few critical properties
    worth mentioning before we dive deeper into the specifics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layouts are data**: Layouts are purely data centric and data driven; they
    do not generate any graphical or display-related output directly. This allows
    them to be used and reused with SVG or canvas or even when there is no graphical
    output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstract and reusable**: Layouts are abstract, allowing a high degree of
    flexibility and reusability. You can combine and reuse layouts in various different
    interesting ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layouts are different**: Each layout is different. Every layout provided
    by D3 focuses on a very special graphical requirement and data structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: Layouts are mostly stateless by design to simplify their usage.
    What statelessness means here is that generally layouts are like functions; they
    can be called multiple times with different input data and generate different
    layout output.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Layouts are interesting and powerful concepts in D3\. In this chapter, we will
    explore some of the most commonly used layouts in D3 by creating a fully functional
    visualization leveraging these layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Building a pie chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A pie chart or a circle graph is a circular graph that contains multiple sectors
    used to illustrate numerical proportion. We will explore techniques, involving
    D3 **pie layout**, to build a fully functional pie chart in this recipe. In [Chapter
    7](ch07.html "Chapter 7. Getting into Shape"), *Getting into Shape*, it became
    clear that using the D3 arc generator directly is a very tedious job. Each arc
    generator expects the following data format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This essentially requires the calculation of the angle partition for each slice
    out of an entire circle of `2 * Math.PI`. Obviously, this process can be automated
    by an algorithm, which is exactly what `d3.pie` is designed for. In this recipe,
    we will see how a pie layout can be used to implement a fully functional pie chart.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser: [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pie chart or a circle graph is a circular diagram divided into sectors (slices).
    Pie charts are popular in many fields and widely used to demonstrate relationships
    between different entities, though not without criticism. Let''s take a look at
    how a pie chart is implemented using `d3.layout` first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following pie chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pie chart
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is built over what you have learned in the [Chapter 7](ch07.html
    "Chapter 7. Getting into Shape"), *Getting into Shape*. One major difference is
    that you rely on `d3.pie` to transform the raw data into arcs data for us. The
    pie layout was created on line A with both sort and value accessors specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort` function tells the pie layout to sort slices by its ID field, so
    that we can maintain stable order among slices. Without the sorting, by default,
    the pie layout will order the slices by value, resulting in the swapping of slices
    whenever we update the pie chart. The `value` function is used to provide value
    accessor, which, in our case, returns the `value` field. When rendering slices,
    now with the pie layout, we directly set the output of the `pie` function call
    as data (remember, layouts are data) to generate the arc `svg:path` elements (refer
    to line `B`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you might be wondering what kind of data `d3.pie` generates.
    Here is what the output data looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pie output data
  prefs: []
  type: TYPE_NORMAL
- en: As we can see clearly, this is exactly what the `d3.arc` generator expects.
    This is why we can use this data directly with `d3.arc` without dealing with any
    detailed calculation for angles and partitions. The rest of the rendering logic
    is pretty much the same as what you have learned in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*, with one exception that can be seen on line
    C. On line C, we retrieve the current arc value from the element so the transition
    can start from the current angle instead of zero. Then, on line D, we reset the
    current arc value to the latest one; so, the next time when we update the pie
    chart data, we can repeat the stateful transition.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Technique - stateful visualization** Technique of value injection on a DOM
    element is a common approach to introduce statefulness to your visualization.
    In other words, if you need your visualizations to remember what their previous
    states are, you can save them in DOM elements, as demonstrated on line `C` in
    this recipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we also need to render labels on each slice so our user can understand
    what each slice is representing. This is done by the `renderLabels` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we use the output of the `pie` function call as data to generate
    the `svg:text` elements. The placement of the labels is calculated using `arc.centroid`
    (refer to line `F`). Additionally, the label placement is animated through the
    transition so they can be moved with arcs in unison.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pie charts are very widely used in many different domains. However, they are
    also widely criticized due to the fact that they are difficult for the human eyes
    to compare different sections of a given pie chart as well as for their low information
    density. Therefore, it is highly recommended to limit the number of sections to
    less than three, with two considered to be ideal. Otherwise, you can always use
    a bar chart or a small table to replace a pie chart for better precision and communicative
    power.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using arc generators* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Implementing arc transition* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a stacked area chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the *Creating an area chart* recipe in [Chapter 8](ch08.html "Chapter 8. Chart
    Them Up"), *Chart Them Up*, we explored how a basic layered area chart can be
    implemented using D3\. In this recipe, we will build over what we covered in the
    area chart recipe to implement a stacked area chart. Stacked area chart is a variation
    of the standard area chart in which different areas are stacked on top of each
    other giving your audience the ability to compare not only different data series
    individually but also their relationship to the total in proportion.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser: [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe is built over what we had implemented in [Chapter 8](ch08.html
    "Chapter 8. Chart Them Up"), *Chart Them Up*; therefore, in the following code
    example, only the parts that are particularly relevant to the stacked area chart
    are included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stacked area chart
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main difference between this recipe and the standard area chart is the
    stacking, which is also the focus of this recipe. The stacking effect as illustrated
    in this recipe was achieved through `d3.stack` created on line `A`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in this code snippet, the data points we generated in the `update`
    function has three different series, `value1`, `value2`, and `value3`. This is
    why we need to specify their names to the `d3.stack` on line `B`. The only other
    customization we have done on stack layout is setting its `offset` to `d3.stackOffsetNone`.
    D3 stack layout supports a few different offset modes, which determine the stacking
    algorithm to be used; this is something that we will explore in this and the next
    recipe. In this case, we use the `zero` offset stacking, which generates a zero
    base-lined stacking algorithm, which is exactly what we want in this recipe. Next,
    on line `B`, we invoked the stack layout on the given data array, which generates
    the following layout data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Stacked data
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown, the stack layout automatically calculates a `y` baseline `0` for
    each data in our three different data series as well as the `y` topline `1`. Now,
    with this stacked dataset in hand, we can easily generate stacked lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A `d3.line` generator function was created with its index count value `i` directly
    mapped to the `x` (refer to line `C`) and its `y` topline value mapped to `d[1]`
    (refer to line `D`). This is all you need to do for line stacking. The rest of
    the `renderLines` function is essentially the same as in the basic area chart
    implementation. The area stacking logic is slightly different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the line rendering logic when rendering area, the only place we need
    to change is in the `d3.area` generator setting. For areas, the `x` value is still
    directly mapped to the index count `i` (line E) with its `y0` directly mapped
    with `y` baseline `d[0]` and finally again `y1` is the `y` topline `d[1]` (line
    G).
  prefs: []
  type: TYPE_NORMAL
- en: As we saw so far, the D3 stack layout is nicely designed to be compatible with
    different D3 SVG generator functions. Hence, using it to generate the stacking
    effect is quite straightforward and convenient.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at a couple of variations of the stacked area chart.
  prefs: []
  type: TYPE_NORMAL
- en: Expanded area chart
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have mentioned that `d3.stack` supports different offset modes. In addition
    to the `d3.stackOffsetNone` offset we saw so far, another very useful offset mode
    for the area chart is called `d3.stackOffsetExpand`. With the `d3.stackOffsetExpand`
    mode, stack layout will normalize different layers to fill the range of `[0, 1]`.
    If we change the offset mode in this recipe and the y axis domain to `[0, 1]`,
    we will get the following expanded (normalized) area chart; this visualization
    is very useful when your audience care more about the relative proportion of each
    data series more than their absolution values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Expanded area chart](img/image_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanded area chart
  prefs: []
  type: TYPE_NORMAL
- en: For the complete companion code example, visit [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Streamgraph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another interesting variation of a stacked area chart is called streamgraph.
    Streamgraph is a stacked area chart displayed around a central axis, creating
    a flowing and organic shape. Streamgraph was initially developed by Lee Byron
    and popularized by its use in a New York Times article on movie box office revenues
    in 2008\. The D3 stack layout has built-in support for this kind of stacking algorithm,
    and therefore, changing a zero-based stacked area chart to streamgraph is simple.
    The key difference is that streamgraph uses `d3.stackOffsetWiggle` as its layout
    offset mode. Stream graph is a useful visualization when you want to highlight
    the change of data or its trend over time rather than its absolute values.
  prefs: []
  type: TYPE_NORMAL
- en: '![Streamgraph](img/image_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Streamgraph
  prefs: []
  type: TYPE_NORMAL
- en: For the complete companion code example, please visit [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html)
    .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`d3.stack` function offers several additional functions to customize its behavior;
    for more information on stack layout, visit [https://github.com/d3/d3/blob/master/API.md#stacks](https://github.com/d3/d3/blob/master/API.md#stacks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Creating an area chart recipe in [Chapter 8](ch08.html "Chapter 8. Chart
    Them Up"), *Chart Them Up*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a treemap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Treemaps were introduced by Ben Shneiderman in 1991\. A treemap displays hierarchical
    tree-structured data as a set of recursively subdivided rectangles. In other words,
    it displays each branch of the tree as a large rectangle, which is then tiled
    with smaller rectangles representing subbranches. This process continuously repeats
    itself till it reaches the leaves of the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information on treemaps, refer to treemaps for space-constrained visualization
    of hierarchies by Ben Shneiderman at [http://www.cs.umd.edu/hcil/treemap-history](http://www.cs.umd.edu/hcil/treemap-history)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into the code example, let''s first define what we mean by **hierarchical
    data**. So far, we discussed many types of visualizations capable of representing
    flat data structure usually stored in one or two dimensional arrays. In the rest
    of this chapter, we will switch our focus onto another common type of data structure
    in data visualization-the hierarchical data structure. Instead of using arrays,
    as in the case of flat data structures, hierarchical data is usually structured
    as a rooted tree. The following JSON file shows a typical hierarchical data you
    would expect in a data visualization project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a shortened version of a popular hierarchical dataset used in the D3
    community for demonstration purposes. This data is extracted from a popular flash-based
    data visualization library-`flare`, created by the UC Berkeley Visualization Lab.
    It shows the size and hierarchical relationship among different packages within
    the library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Refer to the official Flare site for more information on the project at [http://flare.prefuse.org/](http://flare.prefuse.org/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: As we can see quite easily, this particular JSON feed is structured as a typical
    singly-linked rooted tree with each node having a single parent and multiple child
    nodes stored in the `children` array. This is a pretty common way to organize
    your hierarchical data in order to be consumed by the D3 hierarchical layouts.
    For the rest of this chapter, we will use this particular dataset for exploring
    different hierarchical data visualization techniques D3 has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser: [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s take a look at how we can use the `d3.treemap` function to visually
    represent this kind of hierarchical data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following `treemap` visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Treemap
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you might be surprised to know how little code is needed to
    implement a complex data visualization like this. This is because most of the
    heavy lifting is done by the `d3.treemap` and `d3.hierarchy` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `d3.treemap` layout was defined on line A with some basic custom settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`round(true)`: When rounding is on, the treemap layout will round to exact
    pixel boundaries. This is great when you want to avoid antialiasing artifacts
    in SVG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size([_width, _height])`: It sets the layout boundary to the size of this
    SVG.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`padding(1)`: We set the padding to 1 so the blocks generated in tree map will
    have some white space padded in between.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `d3.hierarchy` function was used in this recipe on line B to restructure
    the input data into a format that can be consumed by `d3.treemap` and other D3
    hierarchical data functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sum(_valueAccessor)`: One feature this recipe offers is the ability to switch
    the treemap value accessor on the fly. Value accessor is used by a `d3.hierachy`
    function to access value field on each node. In our case, it can be either one
    of the following functions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`sort(function(a, b) { return b.value - a.value; })`: We have also instructed
    `d3.hierarch` to sort each node in the order of their value, effectively making
    the treemap arrange each block in the order of their size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To apply the `d3.hierarchy` transformation on Flare JSON datafeed, we simply
    set the `nodes` on the `d3.hierarchy` function to the root node in our JSON tree
    (refer to line B). Then, we store the data after the `d3.hierarchy` transformation
    using the variable `root`. Here is how the data now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Treemap hierarchy transformation
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see here, after the transformation, each node now has its value calculated
    based on the sum of all their children''s values and also the depth and size computed,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`depth`: It indicates the depth of the node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`height`: It indicates the height of the node in the tree'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`value`: It indicates the sum of all sub-tree values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x0`: It indicates the cell starting *x* coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y0`: It indicates the cell starting *y* coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x1`: It indicates the cell ending *x* coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`y1`: It indicates the cell ending *y* coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After this transformation, now we can pass the `root` variable to the `_treemap`
    function on line C. Now, we are ready to generate the visualization. On line D,
    we generate cells using only the leaf nodes from the treemap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is because firstly d3.selection.data expects flat data array instead of
    hierarchical tree. Secondly, the tree map actually only render leaf nodes anyway;
    the sub-tree grouping is visualized using color. If we look at the visualization
    carefully, it is not hard to see this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `renderCells` function, a set of `svg:g` elements were created for the given
    nodes. The `renderCells` function is then responsible for creating rectangles
    and their labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each rectangle is placed at its location `(x, y)` that''s determined by the
    layout on line E:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `renderRect` function, we set its width and height to `d.x1 -
    d.x0` and `d.y1 - d.y0`, respectively on line F. On line G, we colored every cell
    using its parent''s names, therefore making sure that all children belonging to
    the same parent are colored the same way. The next step is to render labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: From line H onward, we created the label (`svg:text`) element for each rectangle
    and set its text to the node name. One aspect worth mentioning here is that in
    order to avoid displaying label for the cells that are smaller than the label
    itself, the opacity of label is set to 0 if the label is larger than the cell
    width (refer to line I).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Technique - auto-hiding label** What we have seen here on line I is a useful
    technique in visualization to implement auto-hiding labels. This technique can
    be considered generally in the following form: `.style("opacity", function (d)
    {` `width = this.getComputedTextLength();` `return d.dx > width ? 1 : 0;`'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe is inspired by Mike Bostock's treemap layout example, which you
    can find at [http://mbostock.github.io/d3/talk/20111018/treemap.html](http://mbostock.github.io/d3/talk/20111018/treemap.html)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with hierarchical data structures, a tree (tree graph) is probably
    one of the most natural and common visualizations typically used to demonstrate
    structural dependencies between different data elements. Tree is an undirected
    graph in which any two nodes (vertices) are connected by one and only one simple
    path. In this recipe, we will learn how to implement a tree visualization using
    D3 tree layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s see `d3.tree` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following tree visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tree
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have mentioned before, this recipe is built over the D3 tree layout.
    The `d3.tree` function is specifically designed to convert a hierarchical data
    structure into a visual layout data suitable for generating a tree graph. However,
    similar to the *Building a teemap*recipe, the `d3.tree` layout function only accepts
    structured D3 hierarchical data, meaning before we can use the layout function
    we need to use `d3.hierachy` to process and format our data first. Again, in this
    recipe, we are using the same Flare project package data we were using so far
    in this chapter. The raw JSON data source looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This data is loaded and passed into our chart object in the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the data is loaded, we first pass the loaded JSON data to d3.hierachy
    for processing (refer to line A):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In this recipe, this is all we need since `d3.tree` layout only cares about
    the hierarchical relationship between nodes, therefore, there is no need to sum
    or order the data as we did in the *Build a treemap*recipe. Once processed, we
    can now create tree layout using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The only setting we provided here is the size of our visualization, which is
    the size of our SVG image minus the margins. The `d3.tree` function will then
    take care of the rest and calculate every node's position accordingly. To use
    the tree layout, you simply need to invoke the layout function on line C.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you peek into the `nodes` layout data, it contains node data that will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tree layout data
  prefs: []
  type: TYPE_NORMAL
- en: 'Tree nodes are rendered in the `renderNode` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, first we generate a set of `g.node` elements bound to `root.descendents()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `root.descendents` function returns all nodes in the hierarchical data.
    This is different from the `root.leaves` function we used in the *Build a treemap*recipe.
    The `root.leaves` function returns only the leaf nodes as a JavaScript array;
    however, with `d3.tree` layout, we not only care about the leaves but also any
    intermediary nodes in order to visualize the entire tree structure, and thus,
    we need to use `root.descendents` instead. At this point, we also assign an ID
    to each node using an index to obtain object constancy; refer to [Chapter 6](ch06.html
    "Chapter 6. Transition with Style"), *Transition with Style* for more information
    on object constancy in case this is a new concept to you;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'On line F, we created the nodes and moved them to the coordinates of `(d.y,
    d.x)` that the `d3.tree` layout has calculated for us. We switched `x` and `y`
    in this case since by default the `d3.tree` layout calculates coordinates in portrait
    mode while we want to render them in the landscape mode in this recipe. On line
    G, we also created `onClick` event handler to handle user mouse click on tree
    nodes. The `toggle` function consists of the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This function effectively hides the children field on a given data node temporarily.
    Doing this essentially remove all children from that node in visualization and
    hence gives the users the sense of collapsing its subtree when they click on a
    node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: On line H, we created SVG circle element to represent each tree node, and again
    we position them at `(d.y, d.x)`. Finally, on line J, we colored the node with
    different fill based on whether it is collapsed or open by checking the temporary
    `_children` file generated by the `toggle` function. The rest of the node and
    label rendering code are quite simple, so we will not cover them line by line
    here; refer to the source code on GitHub for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important function in this recipe is the `renderLinks` function. This
    function draws all the links that connect all the tree nodes we just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'First, for rendering links, we use `root.descendants().slice(1)` as its data
    instead of `root.descendants()`. This is because for `n` nodes there are `n -
    1` links since there is no link pointing to the root node in a tree. Once again,
    object constancy is used here to make our visualization more stable during re-rendering.
    Then, on line M, we created path elements to represent each link in our visualization.
    Now, the interesting part of this function lies in the `generateLinkPath` function
    on line N:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this function, we use the `d3.path` generator to generate a Bezier curve
    that connects the source and target nodes. You can probably see that the usage
    of the `d3.path` generator is almost like describing how the line should be drawn.
    In this case, we moved the starting point of such line to `(target.y, target.x)`
    and then draw a Bezier curve with the given control points from target to source,
    as shown in the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bezier curve
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Of course, if you are familiar with the SVG path commands, then you can generate
    the d formula without using the `d3.path` generator. In this case, we are essentially
    using M and C commands. However, the `d3.path` generator function is more readable
    and works well with both SVG and Canvas, hence, it yields more maintainable code
    in general. For more information on SVG path command, refer to [https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands](https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands)
    .
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we now have the entire tree graph visualized. As you can see
    with the help of the `d3.tree` layout, drawing this kind of complex visualization
    is relatively straightforward if not easy.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `d3.tree` offers several functions that allow customization. For more details,
    check out its API documentation at [https://github.com/d3/d3-hierarchy/blob/master/README.md#tree](https://github.com/d3/d3-hierarchy/blob/master/README.md#tree)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `d3.path` generator is capable of generating any arbitrary line on canvas
    and SVG; for more information, refer to its API document at [https://github.com/d3/d3-path/blob/master/README.md#path](https://github.com/d3/d3-path/blob/master/README.md#path)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refer to the *Animating multiple elements* recipe in [Chapter 6](ch06.html "Chapter 6. Transition
    with Style"), *Transition with Style*, for explanations on object constancy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe is inspired by Mike Bostock's Tidy Tree example, which you can find
    at [http://bl.ocks.org/mbostock/4339184](http://bl.ocks.org/mbostock/4339184)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an enclosure diagram
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An enclosure diagram is an interesting visualization of hierarchical data structures
    that use the recursive circle packing algorithm. It uses containment (nesting)
    to represent hierarchy. Circles are created for each leaf node in a data tree,
    while its size is proportional to a particular quantitative dimension of each
    data element. In this recipe, you will learn how to implement this kind of visualization
    using the D3 pack layout.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open your local copy of the following file in your web browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html)'
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, let''s see how we can implement an enclosure diagram using
    `d3.pack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This recipe generates the following visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/image_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enclosure diagram
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we continue to use hierarchical JSON data source that describes
    Flare project package relationship. For more information on the data source, refer
    to the *Build a treemap* recipe in this chapter. The JSON data structure looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This data is loaded into the chart object in the `flare` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this visualization, the first thing we need to take care of is to define
    our layout; in this case, we need to use the `d3.pack` layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the size of our visualization on layout so it can calculate accordingly.
    After that, before we can pass our JSON data to the `d3.pack` layout once again,
    we need to first process it using the `d3.hierachy` function (refer to line B),
    which is a prerequisite for any D3 hierarchical visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we `told d3.hierarchy` function to sum up all values using the
    `_valueAccessor` function, which takes `d.size` as the value by default. Additionally,
    we also asked the `d3.hierachy` function to sort the nodes based on the values.
    Finally, we then pass the processed data to the `pack` function on line C. The
    layout data after this process now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/image_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Pack layout data
  prefs: []
  type: TYPE_NORMAL
- en: 'Circle rendering is done in the `renderCircle` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Then, we simply bind the layout data and create the `svg:circle` elements for
    each node. For update, we set `cx`, `cy`, and `radius` to the value that the pack
    layout has calculated for us for each circle (refer to line D). Finally, when removing 
    the circle, we reduce the size of the circle down to zero first, before removing
    them to generate a more smooth transition. Label rendering in this recipe is pretty
    straightforward with some help from the auto-hiding technique we introduced in
    this chapter, so we will not cover the function in detail here.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `d3.pack` function offers several functions that allow customization. For
    more details, please check out its API documentation at [https://github.com/d3/d3-hierarchy/blob/master/README.md#pack](https://github.com/d3/d3-hierarchy/blob/master/README.md#pack)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Building a treemap* recipe for auto label hiding technique.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe is inspired by Mike Bostock's pack layout example, which you can
    find at [http://bl.ocks.org/mbostock/ca5b03a33affa4160321](http://bl.ocks.org/mbostock/ca5b03a33affa4160321)
    .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
