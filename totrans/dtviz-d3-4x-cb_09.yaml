- en: Chapter 9. Lay Them Out
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。布局它们
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Building a pie chart
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立饼图
- en: Building a stacked area chart
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立堆叠面积图
- en: Building a treemap
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立树状图
- en: Building a tree
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立树
- en: Building an enclosure diagram
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立围栏图
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: 'The D3 layout is the focus of this chapter-a concept we have not encountered
    before. As expected, D3 layouts are algorithms that calculate and generate placement
    information for a group of elements. However, there are a few critical properties
    worth mentioning before we dive deeper into the specifics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: D3 布局是本章的重点——一个我们之前未曾遇到的概念。正如预期的那样，D3 布局是计算和生成一组元素放置信息的算法。然而，在我们深入了解具体细节之前，有一些关键属性值得提及：
- en: '**Layouts are data**: Layouts are purely data centric and data driven; they
    do not generate any graphical or display-related output directly. This allows
    them to be used and reused with SVG or canvas or even when there is no graphical
    output.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局是数据**：布局完全是数据驱动的，它们不直接生成任何图形或显示相关的输出。这使得它们可以在 SVG 或 canvas 上使用，甚至在没有图形输出的情况下也可以重复使用。'
- en: '**Abstract and reusable**: Layouts are abstract, allowing a high degree of
    flexibility and reusability. You can combine and reuse layouts in various different
    interesting ways.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象和可重用**：布局是抽象的，允许高度灵活性和可重用性。您可以通过各种有趣的方式组合和重用布局。'
- en: '**Layouts are different**: Each layout is different. Every layout provided
    by D3 focuses on a very special graphical requirement and data structure.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局不同**：每个布局都是不同的。D3 提供的每个布局都专注于一个非常特殊的图形需求和数据结构。'
- en: '**Stateless**: Layouts are mostly stateless by design to simplify their usage.
    What statelessness means here is that generally layouts are like functions; they
    can be called multiple times with different input data and generate different
    layout output.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：布局主要是无状态的，以简化其使用。这里的无状态意味着布局通常像函数一样；它们可以用不同的输入数据多次调用，并生成不同的布局输出。'
- en: Layouts are interesting and powerful concepts in D3\. In this chapter, we will
    explore some of the most commonly used layouts in D3 by creating a fully functional
    visualization leveraging these layouts.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 布局是 D3 中有趣且强大的概念。在本章中，我们将通过创建一个利用这些布局的功能齐全的可视化来探索 D3 中一些最常用的布局。
- en: Building a pie chart
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立饼图
- en: 'A pie chart or a circle graph is a circular graph that contains multiple sectors
    used to illustrate numerical proportion. We will explore techniques, involving
    D3 **pie layout**, to build a fully functional pie chart in this recipe. In [Chapter
    7](ch07.html "Chapter 7. Getting into Shape"), *Getting into Shape*, it became
    clear that using the D3 arc generator directly is a very tedious job. Each arc
    generator expects the following data format:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图或圆形图是一种包含多个扇区的圆形图表，用于说明数值比例。在本食谱中，我们将探讨涉及 D3 **饼布局**的技术，以构建一个功能齐全的饼图。在[第7章](ch07.html
    "第7章。进入形状")“进入形状”中，很明显，直接使用 D3 弧生成器是一项非常繁琐的工作。每个弧生成器都期望以下数据格式：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This essentially requires the calculation of the angle partition for each slice
    out of an entire circle of `2 * Math.PI`. Obviously, this process can be automated
    by an algorithm, which is exactly what `d3.pie` is designed for. In this recipe,
    we will see how a pie layout can be used to implement a fully functional pie chart.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上需要计算整个圆周`2 * Math.PI`中每个切片的角度分区。显然，这个过程可以通过算法自动化，这正是`d3.pie`设计的目的。在本食谱中，我们将看到如何使用饼布局来实现一个功能齐全的饼图。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser: [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pie-chart.html)
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'A pie chart or a circle graph is a circular diagram divided into sectors (slices).
    Pie charts are popular in many fields and widely used to demonstrate relationships
    between different entities, though not without criticism. Let''s take a look at
    how a pie chart is implemented using `d3.layout` first:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图或圆形图是将图表分成扇区（切片）的圆形图表。饼图在许多领域都很受欢迎，广泛用于展示不同实体之间的关系，尽管并非没有批评。让我们先看看如何使用`d3.layout`实现饼图：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This recipe generates the following pie chart:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱生成以下饼图：
- en: '![How to do it...](img/image_09_001.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/image_09_001.jpg)'
- en: Pie chart
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图
- en: How it works...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe is built over what you have learned in the [Chapter 7](ch07.html
    "Chapter 7. Getting into Shape"), *Getting into Shape*. One major difference is
    that you rely on `d3.pie` to transform the raw data into arcs data for us. The
    pie layout was created on line A with both sort and value accessors specified:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱建立在你在[第7章](ch07.html "第7章. 形状塑造")，*形状塑造*中学到的知识之上。一个主要的不同之处在于，你依赖`d3.pie`将原始数据转换成弧数据。饼图布局在行A创建，同时指定了排序和值访问器：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `sort` function tells the pie layout to sort slices by its ID field, so
    that we can maintain stable order among slices. Without the sorting, by default,
    the pie layout will order the slices by value, resulting in the swapping of slices
    whenever we update the pie chart. The `value` function is used to provide value
    accessor, which, in our case, returns the `value` field. When rendering slices,
    now with the pie layout, we directly set the output of the `pie` function call
    as data (remember, layouts are data) to generate the arc `svg:path` elements (refer
    to line `B`):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort`函数告诉饼图布局按其ID字段对切片进行排序，这样我们就可以在切片之间保持稳定的顺序。如果没有排序，默认情况下，饼图布局将按值排序切片，导致每次我们更新饼图时切片都会交换。`value`函数用于提供值访问器，在我们的例子中，它返回`value`字段。在渲染切片时，现在使用饼图布局，我们直接将`pie`函数调用的输出作为数据（记住，布局是数据）来生成`svg:path`元素（参见图`B`）：'
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, you might be wondering what kind of data `d3.pie` generates.
    Here is what the output data looks like:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能想知道`d3.pie`生成什么类型的数据。下面是输出数据的样子：
- en: '![How it works...](img/image_09_002.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/image_09_002.jpg)'
- en: Pie output data
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图输出数据
- en: As we can see clearly, this is exactly what the `d3.arc` generator expects.
    This is why we can use this data directly with `d3.arc` without dealing with any
    detailed calculation for angles and partitions. The rest of the rendering logic
    is pretty much the same as what you have learned in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*, with one exception that can be seen on line
    C. On line C, we retrieve the current arc value from the element so the transition
    can start from the current angle instead of zero. Then, on line D, we reset the
    current arc value to the latest one; so, the next time when we update the pie
    chart data, we can repeat the stateful transition.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所清楚地看到，这正是`d3.arc`生成器所期望的。这就是为什么我们可以直接使用`d3.arc`而不需要处理任何关于角度和分区的详细计算。渲染逻辑的其余部分基本上与你在[第7章](ch07.html
    "第7章. 形状塑造")，*形状塑造*中学到的是一样的，只有一个例外可以在行C中看到。在行C中，我们从元素中检索当前的弧值，以便过渡可以从当前角度而不是零开始。然后，在行D中，我们将当前的弧值重置为最新值；因此，下次我们更新饼图数据时，我们可以重复状态化过渡。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Technique - stateful visualization** Technique of value injection on a DOM
    element is a common approach to introduce statefulness to your visualization.
    In other words, if you need your visualizations to remember what their previous
    states are, you can save them in DOM elements, as demonstrated on line `C` in
    this recipe.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术 - 状态化可视化** 在DOM元素上注入值的技术是引入可视化状态性的常见方法。换句话说，如果你需要你的可视化记住它们之前的状态，你可以在DOM元素中保存它们，就像在这个食谱中行`C`所展示的那样。'
- en: 'Finally, we also need to render labels on each slice so our user can understand
    what each slice is representing. This is done by the `renderLabels` function:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要在每个切片上渲染标签，以便我们的用户可以理解每个切片代表什么。这是通过`renderLabels`函数完成的：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once again, we use the output of the `pie` function call as data to generate
    the `svg:text` elements. The placement of the labels is calculated using `arc.centroid`
    (refer to line `F`). Additionally, the label placement is animated through the
    transition so they can be moved with arcs in unison.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`pie`函数调用的输出作为数据来生成`svg:text`元素。标签的位置是通过`arc.centroid`计算的（参见图`F`）。此外，标签的位置通过过渡进行动画处理，这样它们就可以与弧一起移动。
- en: There's more...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Pie charts are very widely used in many different domains. However, they are
    also widely criticized due to the fact that they are difficult for the human eyes
    to compare different sections of a given pie chart as well as for their low information
    density. Therefore, it is highly recommended to limit the number of sections to
    less than three, with two considered to be ideal. Otherwise, you can always use
    a bar chart or a small table to replace a pie chart for better precision and communicative
    power.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 饼图在许多不同的领域中被广泛使用。然而，由于它们难以用肉眼比较给定饼图的各个部分，以及它们的信息密度低，因此它们也受到了广泛的批评。因此，强烈建议将部分数量限制在三个以下，其中两个被认为是理想的。否则，您始终可以使用条形图或小型表格来替换饼图，以获得更好的精度和沟通能力。
- en: See also
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using arc generators* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第7章 *Getting into Shape* 的 *Using arc generators* 食谱中，[第7章。塑形]
- en: The *Implementing arc transition* recipe in [Chapter 7](ch07.html "Chapter 7. Getting
    into Shape"), *Getting into Shape*
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第7章 *Getting into Shape* 的 *Implementing arc transition* 食谱中，[第7章](ch07.html
    "第7章。塑形")
- en: Building a stacked area chart
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建堆叠面积图
- en: In the *Creating an area chart* recipe in [Chapter 8](ch08.html "Chapter 8. Chart
    Them Up"), *Chart Them Up*, we explored how a basic layered area chart can be
    implemented using D3\. In this recipe, we will build over what we covered in the
    area chart recipe to implement a stacked area chart. Stacked area chart is a variation
    of the standard area chart in which different areas are stacked on top of each
    other giving your audience the ability to compare not only different data series
    individually but also their relationship to the total in proportion.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章 *Chart Them Up* 的 *Creating an area chart* 食谱中，我们探讨了如何使用D3实现基本的分层面积图。在本食谱中，我们将基于面积图食谱中的内容来构建堆叠面积图。堆叠面积图是标准面积图的一种变体，其中不同的区域堆叠在一起，使观众能够比较不同的数据系列，以及它们与总量的比例关系。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser: [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/stacked-area-chart.html)
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'This recipe is built over what we had implemented in [Chapter 8](ch08.html
    "Chapter 8. Chart Them Up"), *Chart Them Up*; therefore, in the following code
    example, only the parts that are particularly relevant to the stacked area chart
    are included:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱是在第8章 *Chart Them Up* 中我们所实现的内容的基础上构建的；因此，在以下代码示例中，仅包括与堆叠面积图特别相关的部分：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This recipe generates the following visualization:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱生成以下可视化效果：
- en: '![How to do it...](img/image_09_003.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_09_003.jpg)'
- en: Stacked area chart
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠面积图
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The main difference between this recipe and the standard area chart is the
    stacking, which is also the focus of this recipe. The stacking effect as illustrated
    in this recipe was achieved through `d3.stack` created on line `A`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准面积图相比，本食谱的主要区别在于堆叠，这也是本食谱的重点。本食谱中展示的堆叠效果是通过在行`A`上创建的`d3.stack`实现的：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see in this code snippet, the data points we generated in the `update`
    function has three different series, `value1`, `value2`, and `value3`. This is
    why we need to specify their names to the `d3.stack` on line `B`. The only other
    customization we have done on stack layout is setting its `offset` to `d3.stackOffsetNone`.
    D3 stack layout supports a few different offset modes, which determine the stacking
    algorithm to be used; this is something that we will explore in this and the next
    recipe. In this case, we use the `zero` offset stacking, which generates a zero
    base-lined stacking algorithm, which is exactly what we want in this recipe. Next,
    on line `B`, we invoked the stack layout on the given data array, which generates
    the following layout data:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码片段所示，我们在`update`函数中生成的数据点有三个不同的系列，`value1`、`value2`和`value3`。这就是为什么我们需要在行`B`上指定它们的名称给`d3.stack`。我们在堆叠布局上所做的唯一其他定制是将其`offset`设置为`d3.stackOffsetNone`。D3堆叠布局支持几种不同的偏移模式，这些模式决定了要使用的堆叠算法；这是我们将在本食谱和下一食谱中探讨的内容。在这种情况下，我们使用`zero`偏移堆叠，它生成一个零基线的堆叠算法，这正是本食谱所想要的。接下来，在行`B`上，我们对给定的数据数组调用了堆叠布局，生成了以下布局数据：
- en: '![How it works...](img/image_09_004.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/image_09_004.jpg)'
- en: Stacked data
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠数据
- en: 'As shown, the stack layout automatically calculates a `y` baseline `0` for
    each data in our three different data series as well as the `y` topline `1`. Now,
    with this stacked dataset in hand, we can easily generate stacked lines:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，堆叠布局自动为我们的三个不同数据系列中的每个数据计算一个`y`基线`0`以及`y`上界`1`。现在，有了这个堆叠数据集，我们可以轻松地生成堆叠线：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'A `d3.line` generator function was created with its index count value `i` directly
    mapped to the `x` (refer to line `C`) and its `y` topline value mapped to `d[1]`
    (refer to line `D`). This is all you need to do for line stacking. The rest of
    the `renderLines` function is essentially the same as in the basic area chart
    implementation. The area stacking logic is slightly different:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`d3.line`生成函数创建了一个索引计数值`i`直接映射到`x`（参考行`C`），其`y`上界值映射到`d[1]`（参考行`D`）。这就是进行线堆叠所需做的所有事情。`renderLines`函数的其余部分基本上与基本区域图实现相同。区域堆叠逻辑略有不同：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Similar to the line rendering logic when rendering area, the only place we need
    to change is in the `d3.area` generator setting. For areas, the `x` value is still
    directly mapped to the index count `i` (line E) with its `y0` directly mapped
    with `y` baseline `d[0]` and finally again `y1` is the `y` topline `d[1]` (line
    G).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与渲染区域时类似的线渲染逻辑，我们唯一需要更改的地方是在`d3.area`生成器设置中。对于区域，`x`值仍然直接映射到索引计数`i`（行E），其`y0`直接映射到`y`基线`d[0]`，最后`y1`是`y`上界`d[1]`（行G）。
- en: As we saw so far, the D3 stack layout is nicely designed to be compatible with
    different D3 SVG generator functions. Hence, using it to generate the stacking
    effect is quite straightforward and convenient.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，D3堆叠布局设计得非常好，可以与不同的D3 SVG生成函数兼容。因此，使用它来生成堆叠效果非常直接和方便。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's take a look at a couple of variations of the stacked area chart.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看堆叠区域图的几个变体。
- en: Expanded area chart
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展区域图
- en: 'We have mentioned that `d3.stack` supports different offset modes. In addition
    to the `d3.stackOffsetNone` offset we saw so far, another very useful offset mode
    for the area chart is called `d3.stackOffsetExpand`. With the `d3.stackOffsetExpand`
    mode, stack layout will normalize different layers to fill the range of `[0, 1]`.
    If we change the offset mode in this recipe and the y axis domain to `[0, 1]`,
    we will get the following expanded (normalized) area chart; this visualization
    is very useful when your audience care more about the relative proportion of each
    data series more than their absolution values:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到`d3.stack`支持不同的偏移模式。除了我们之前看到的`d3.stackOffsetNone`偏移之外，对于区域图来说，另一个非常有用的偏移模式称为`d3.stackOffsetExpand`。使用`d3.stackOffsetExpand`模式，堆叠布局将不同层标准化以填充范围`[0,
    1]`。如果我们更改此食谱中的偏移模式以及y轴域为`[0, 1]`，我们将得到以下扩展（标准化）区域图；这种可视化在观众更关心每个数据系列的相对比例而不是其绝对值时非常有用：
- en: '![Expanded area chart](img/image_09_005.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![扩展区域图](img/image_09_005.jpg)'
- en: Expanded area chart
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展区域图
- en: For the complete companion code example, visit [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html)
    .
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于完整的配套代码示例，请访问[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/expanded-area-chart.html)。
- en: Streamgraph
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流图
- en: Another interesting variation of a stacked area chart is called streamgraph.
    Streamgraph is a stacked area chart displayed around a central axis, creating
    a flowing and organic shape. Streamgraph was initially developed by Lee Byron
    and popularized by its use in a New York Times article on movie box office revenues
    in 2008\. The D3 stack layout has built-in support for this kind of stacking algorithm,
    and therefore, changing a zero-based stacked area chart to streamgraph is simple.
    The key difference is that streamgraph uses `d3.stackOffsetWiggle` as its layout
    offset mode. Stream graph is a useful visualization when you want to highlight
    the change of data or its trend over time rather than its absolute values.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 堆叠区域图的另一个有趣的变体称为流图。流图是一种围绕中心轴显示的堆叠区域图，创建出流动和有机的形状。流图最初由Lee Byron开发，并于2008年在一篇关于电影票房收入的纽约时报文章中普及。D3堆叠布局内置了对这种堆叠算法的支持，因此，将基于零的堆叠区域图转换为流图非常简单。关键区别在于流图使用`d3.stackOffsetWiggle`作为其布局偏移模式。流图在你想强调数据的变化或其随时间的变化趋势而不是其绝对值时非常有用。
- en: '![Streamgraph](img/image_09_006.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![Streamgraph](img/image_09_006.jpg)'
- en: Streamgraph
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 流图
- en: For the complete companion code example, please visit [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html)
    .
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的配套代码示例，请访问 [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/streamgraph.html)
    。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: '`d3.stack` function offers several additional functions to customize its behavior;
    for more information on stack layout, visit [https://github.com/d3/d3/blob/master/API.md#stacks](https://github.com/d3/d3/blob/master/API.md#stacks)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.stack` 函数提供了几个额外的函数来定制其行为；有关堆叠布局的更多信息，请访问 [https://github.com/d3/d3/blob/master/API.md#stacks](https://github.com/d3/d3/blob/master/API.md#stacks)'
- en: The Creating an area chart recipe in [Chapter 8](ch08.html "Chapter 8. Chart
    Them Up"), *Chart Them Up*
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 8 章 [Chart Them Up](ch08.html "第 8 章. 图表化") 中创建区域图
- en: Building a treemap
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建树状图
- en: Treemaps were introduced by Ben Shneiderman in 1991\. A treemap displays hierarchical
    tree-structured data as a set of recursively subdivided rectangles. In other words,
    it displays each branch of the tree as a large rectangle, which is then tiled
    with smaller rectangles representing subbranches. This process continuously repeats
    itself till it reaches the leaves of the tree.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 树状图是由 Ben Shneiderman 在 1991 年提出的。树状图将层次树结构数据显示为一系列递归划分的矩形。换句话说，它将树的每个分支显示为一个大的矩形，然后用表示子分支的小矩形进行平铺。这个过程会一直重复，直到达到树的叶子节点。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on treemaps, refer to treemaps for space-constrained visualization
    of hierarchies by Ben Shneiderman at [http://www.cs.umd.edu/hcil/treemap-history](http://www.cs.umd.edu/hcil/treemap-history)
    .
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关于树状图的更多信息，请参阅 Ben Shneiderman 在 [http://www.cs.umd.edu/hcil/treemap-history](http://www.cs.umd.edu/hcil/treemap-history)
    上关于空间受限层次结构可视化的树状图。
- en: 'Before we dive into the code example, let''s first define what we mean by **hierarchical
    data**. So far, we discussed many types of visualizations capable of representing
    flat data structure usually stored in one or two dimensional arrays. In the rest
    of this chapter, we will switch our focus onto another common type of data structure
    in data visualization-the hierarchical data structure. Instead of using arrays,
    as in the case of flat data structures, hierarchical data is usually structured
    as a rooted tree. The following JSON file shows a typical hierarchical data you
    would expect in a data visualization project:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入代码示例之前，让我们首先定义我们所说的**层次数据**。到目前为止，我们讨论了许多能够表示通常存储在一维或二维数组中的平面数据结构的可视化类型。在本章的剩余部分，我们将把我们的重点转向数据可视化中另一种常见的类型——层次数据结构。与平面数据结构不同，层次数据通常以根树的形式结构化。以下
    JSON 文件显示了数据可视化项目中可能会遇到的典型层次数据：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is a shortened version of a popular hierarchical dataset used in the D3
    community for demonstration purposes. This data is extracted from a popular flash-based
    data visualization library-`flare`, created by the UC Berkeley Visualization Lab.
    It shows the size and hierarchical relationship among different packages within
    the library.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 D3 社区中广泛使用的流行分层数据集的简化版本，用于演示目的。这些数据是从一个流行的基于 Flash 的数据可视化库中提取的，该库由加州大学伯克利分校可视化实验室创建，名为
    `flare`。它显示了库中不同包的大小和层次关系。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Refer to the official Flare site for more information on the project at [http://flare.prefuse.org/](http://flare.prefuse.org/)
    .
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有关项目的更多信息，请参考官方 Flare 网站 [http://flare.prefuse.org/](http://flare.prefuse.org/)
    。
- en: As we can see quite easily, this particular JSON feed is structured as a typical
    singly-linked rooted tree with each node having a single parent and multiple child
    nodes stored in the `children` array. This is a pretty common way to organize
    your hierarchical data in order to be consumed by the D3 hierarchical layouts.
    For the rest of this chapter, we will use this particular dataset for exploring
    different hierarchical data visualization techniques D3 has to offer.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们很容易看到的，这个特定的 JSON 数据流被结构化为一个典型的单链根树，每个节点有一个父节点和存储在 `children` 数组中的多个子节点。这是为了使
    D3 层次布局能够消费你的层次数据的一种相当常见的方式。在本章的剩余部分，我们将使用这个特定的数据集来探索 D3 提供的不同层次数据可视化技术。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser: [https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html)
    .'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的网络浏览器中打开以下文件的本地副本：[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/treemap.html)。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Now let''s take a look at how we can use the `d3.treemap` function to visually
    represent this kind of hierarchical data:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用 `d3.treemap` 函数来直观地表示这种层次数据：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This recipe generates the following `treemap` visualization:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱生成了以下 `treemap` 可视化：
- en: '![How to do it...](img/image_09_007.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/image_09_007.jpg)'
- en: Treemap
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Treemap
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'At this point, you might be surprised to know how little code is needed to
    implement a complex data visualization like this. This is because most of the
    heavy lifting is done by the `d3.treemap` and `d3.hierarchy` functions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会惊讶地发现实现如此复杂的数据可视化所需的代码如此之少。这是因为大部分繁重的工作都是由 `d3.treemap` 和 `d3.hierarchy`
    函数完成的：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `d3.treemap` layout was defined on line A with some basic custom settings:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 A 行定义了 `d3.treemap` 布局，并有一些基本的自定义设置：
- en: '`round(true)`: When rounding is on, the treemap layout will round to exact
    pixel boundaries. This is great when you want to avoid antialiasing artifacts
    in SVG.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`round(true)`: 当启用舍入时，树图布局将舍入到精确的像素边界。当你想要避免 SVG 中的抗锯齿伪影时，这非常好。'
- en: '`size([_width, _height])`: It sets the layout boundary to the size of this
    SVG.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`size([_width, _height])`: 它将布局边界设置为这个 SVG 的大小。'
- en: '`padding(1)`: We set the padding to 1 so the blocks generated in tree map will
    have some white space padded in between.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`padding(1)`: 我们将填充设置为 1，这样在树图中生成的块之间就会有空白填充。'
- en: 'The `d3.hierarchy` function was used in this recipe on line B to restructure
    the input data into a format that can be consumed by `d3.treemap` and other D3
    hierarchical data functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用 `d3.hierarchy` 函数在第 B 行重新结构化输入数据，使其能够被 `d3.treemap` 和其他 D3 层次数据函数消费：
- en: '`sum(_valueAccessor)`: One feature this recipe offers is the ability to switch
    the treemap value accessor on the fly. Value accessor is used by a `d3.hierachy`
    function to access value field on each node. In our case, it can be either one
    of the following functions:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum(_valueAccessor)`: 这个菜谱提供的一个特性是能够动态切换树图值访问器。值访问器由 `d3.hierachy` 函数用于访问每个节点的值字段。在我们的例子中，它可以是以下函数之一：'
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`sort(function(a, b) { return b.value - a.value; })`: We have also instructed
    `d3.hierarch` to sort each node in the order of their value, effectively making
    the treemap arrange each block in the order of their size.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort(function(a, b) { return b.value - a.value; })`: 我们还指示 `d3.hierarch` 按照每个节点的值顺序排序，从而有效地使树图按照块的大小顺序排列。'
- en: 'To apply the `d3.hierarchy` transformation on Flare JSON datafeed, we simply
    set the `nodes` on the `d3.hierarchy` function to the root node in our JSON tree
    (refer to line B). Then, we store the data after the `d3.hierarchy` transformation
    using the variable `root`. Here is how the data now looks like:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Flare JSON 数据源上应用 `d3.hierarchy` 转换，我们只需将 `d3.hierarchy` 函数上的 `nodes` 设置为我们
    JSON 树的根节点（参见图 B）。然后，我们使用变量 `root` 存储经过 `d3.hierarchy` 转换后的数据。现在数据看起来是这样的：
- en: '![How it works...](img/image_09_008.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/image_09_008.jpg)'
- en: Treemap hierarchy transformation
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Treemap 层次结构转换
- en: 'As we can see here, after the transformation, each node now has its value calculated
    based on the sum of all their children''s values and also the depth and size computed,
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在转换之后，每个节点现在都根据其所有子节点的值的总和以及计算出的深度和大小来计算其值，如下所示：
- en: '`depth`: It indicates the depth of the node'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depth`: 它表示节点的深度'
- en: '`height`: It indicates the height of the node in the tree'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`height`: 它表示树中节点的长度'
- en: '`value`: It indicates the sum of all sub-tree values'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value`: 它表示所有子树值的总和'
- en: '`x0`: It indicates the cell starting *x* coordinate'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x0`: 它表示单元格开始的 *x* 坐标'
- en: '`y0`: It indicates the cell starting *y* coordinate'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y0`: 它表示单元格开始的 *y* 坐标'
- en: '`x1`: It indicates the cell ending *x* coordinate'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x1`: 它表示单元格结束的 *x* 坐标'
- en: '`y1`: It indicates the cell ending *y* coordinate'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y1`: 它表示单元格结束的 *y* 坐标'
- en: 'After this transformation, now we can pass the `root` variable to the `_treemap`
    function on line C. Now, we are ready to generate the visualization. On line D,
    we generate cells using only the leaf nodes from the treemap:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这次转换后，现在我们可以将 `root` 变量传递到第 C 行的 `_treemap` 函数。现在，我们准备生成可视化。在第 D 行，我们仅使用树图的叶节点生成单元格：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is because firstly d3.selection.data expects flat data array instead of
    hierarchical tree. Secondly, the tree map actually only render leaf nodes anyway;
    the sub-tree grouping is visualized using color. If we look at the visualization
    carefully, it is not hard to see this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为首先，d3.selection.data期望的是扁平数据数组而不是层次化树。其次，树图实际上只渲染叶节点；子树分组是通过颜色来可视化的。如果我们仔细观察可视化，这一点并不难发现。
- en: 'In `renderCells` function, a set of `svg:g` elements were created for the given
    nodes. The `renderCells` function is then responsible for creating rectangles
    and their labels:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`renderCells`函数中，为给定的节点创建了一组`svg:g`元素。然后`renderCells`函数负责创建矩形及其标签：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each rectangle is placed at its location `(x, y)` that''s determined by the
    layout on line E:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 每个矩形放置在其位置`(x, y)`，该位置由E行上的布局确定：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, in the `renderRect` function, we set its width and height to `d.x1 -
    d.x0` and `d.y1 - d.y0`, respectively on line F. On line G, we colored every cell
    using its parent''s names, therefore making sure that all children belonging to
    the same parent are colored the same way. The next step is to render labels:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`renderRect`函数中，我们在F行将其宽度和高度分别设置为`d.x1 - d.x0`和`d.y1 - d.y0`。在G行，我们使用其父级的名称为每个单元格着色，从而确保属于同一父级的所有子项都以相同的方式着色。下一步是渲染标签：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: From line H onward, we created the label (`svg:text`) element for each rectangle
    and set its text to the node name. One aspect worth mentioning here is that in
    order to avoid displaying label for the cells that are smaller than the label
    itself, the opacity of label is set to 0 if the label is larger than the cell
    width (refer to line I).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 从H行开始，我们为每个矩形创建了标签（`svg:text`）元素，并将其文本设置为节点名称。在这里值得提到的一个方面是，为了避免显示比单元格本身还小的标签，如果标签的宽度大于单元格宽度，则将标签的不透明度设置为0（请参阅I行）。
- en: Tip
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Technique - auto-hiding label** What we have seen here on line I is a useful
    technique in visualization to implement auto-hiding labels. This technique can
    be considered generally in the following form: `.style("opacity", function (d)
    {` `width = this.getComputedTextLength();` `return d.dx > width ? 1 : 0;`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术 - 自动隐藏标签** 在I行我们看到的是可视化中实现自动隐藏标签的有用技术。这个技术可以一般地考虑以下形式：`.style("opacity",
    function (d) {` `width = this.getComputedTextLength();` `return d.dx > width ?
    1 : 0;`'
- en: See also
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: This recipe is inspired by Mike Bostock's treemap layout example, which you
    can find at [http://mbostock.github.io/d3/talk/20111018/treemap.html](http://mbostock.github.io/d3/talk/20111018/treemap.html)
    .
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱灵感来源于Mike Bostock的treemap布局示例，您可以在[http://mbostock.github.io/d3/talk/20111018/treemap.html](http://mbostock.github.io/d3/talk/20111018/treemap.html)找到它。
- en: Building a tree
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建树
- en: When working with hierarchical data structures, a tree (tree graph) is probably
    one of the most natural and common visualizations typically used to demonstrate
    structural dependencies between different data elements. Tree is an undirected
    graph in which any two nodes (vertices) are connected by one and only one simple
    path. In this recipe, we will learn how to implement a tree visualization using
    D3 tree layout.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理层次化数据结构时，树（树图）可能是最自然和常用的可视化之一，通常用于展示不同数据元素之间的结构依赖关系。树是一个无向图，其中任何两个节点（顶点）通过一条且仅有一条简单路径连接。在本菜谱中，我们将学习如何使用D3树布局实现树形可视化。
- en: Getting ready
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html)
    .'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/tree.html)
    .'
- en: How to do it...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now let''s see `d3.tree` in action:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看`d3.tree`的实际应用：
- en: '[PRE17]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This recipe generates the following tree visualization:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱生成了以下树形可视化：
- en: '![How to do it...](img/image_09_009.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/image_09_009.jpg)'
- en: Tree
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 树
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As we have mentioned before, this recipe is built over the D3 tree layout.
    The `d3.tree` function is specifically designed to convert a hierarchical data
    structure into a visual layout data suitable for generating a tree graph. However,
    similar to the *Building a teemap*recipe, the `d3.tree` layout function only accepts
    structured D3 hierarchical data, meaning before we can use the layout function
    we need to use `d3.hierachy` to process and format our data first. Again, in this
    recipe, we are using the same Flare project package data we were using so far
    in this chapter. The raw JSON data source looks like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，这个菜谱是基于 D3 树布局构建的。`d3.tree` 函数专门设计用于将层次数据结构转换为适合生成树图的视觉布局数据。然而，与 *构建一个树状图*
    菜谱类似，`d3.tree` 布局函数只接受结构化的 D3 层次数据，这意味着在我们可以使用布局函数之前，我们需要使用 `d3.hierachy` 首先处理和格式化我们的数据。同样，在这个菜谱中，我们使用的是本章迄今为止使用的相同的
    Flare 项目包数据。原始 JSON 数据源如下所示：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This data is loaded and passed into our chart object in the following function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据被加载并传递到以下函数中的我们的图表对象：
- en: '[PRE19]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once the data is loaded, we first pass the loaded JSON data to d3.hierachy
    for processing (refer to line A):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据加载完成，我们首先将加载的 JSON 数据传递给 d3.hierachy 进行处理（参考行 A）：
- en: '[PRE20]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this recipe, this is all we need since `d3.tree` layout only cares about
    the hierarchical relationship between nodes, therefore, there is no need to sum
    or order the data as we did in the *Build a treemap*recipe. Once processed, we
    can now create tree layout using the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们只需要这些，因为 `d3.tree` 布局只关心节点之间的层次关系，因此，我们不需要像在 *构建一个树状图* 菜谱中那样对数据进行求和或排序。一旦处理完成，我们现在可以使用以下代码创建树布局：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The only setting we provided here is the size of our visualization, which is
    the size of our SVG image minus the margins. The `d3.tree` function will then
    take care of the rest and calculate every node's position accordingly. To use
    the tree layout, you simply need to invoke the layout function on line C.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里提供的唯一设置是我们的可视化大小，即我们的 SVG 图像大小减去边距。`d3.tree` 函数将处理其余部分并相应地计算每个节点的位置。要使用树布局，你只需在行
    C 上调用布局函数即可。
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you peek into the `nodes` layout data, it contains node data that will look
    like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看 `nodes` 布局数据，它包含如下所示的数据：
- en: '![How it works...](img/image_09_010.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/image_09_010.jpg)'
- en: Tree layout data
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 树布局数据
- en: 'Tree nodes are rendered in the `renderNode` function as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 树节点在 `renderNode` 函数中如下渲染：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this function, first we generate a set of `g.node` elements bound to `root.descendents()`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先生成一组与 `root.descendents()` 绑定的 `g.node` 元素：
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `root.descendents` function returns all nodes in the hierarchical data.
    This is different from the `root.leaves` function we used in the *Build a treemap*recipe.
    The `root.leaves` function returns only the leaf nodes as a JavaScript array;
    however, with `d3.tree` layout, we not only care about the leaves but also any
    intermediary nodes in order to visualize the entire tree structure, and thus,
    we need to use `root.descendents` instead. At this point, we also assign an ID
    to each node using an index to obtain object constancy; refer to [Chapter 6](ch06.html
    "Chapter 6. Transition with Style"), *Transition with Style* for more information
    on object constancy in case this is a new concept to you;
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`root.descendents` 函数返回层次数据中的所有节点。这与我们在 *构建一个树状图* 菜单中使用的 `root.leaves` 函数不同。`root.leaves`
    函数只返回作为 JavaScript 数组的叶节点；然而，使用 `d3.tree` 布局时，我们不仅关注叶节点，还关注任何中间节点，以便可视化整个树结构，因此，我们需要使用
    `root.descendents`。在此阶段，我们还使用索引为每个节点分配一个 ID 以获得对象一致性；如对此概念不熟悉，请参考 [第 6 章](ch06.html
    "第 6 章。以风格过渡")，*以风格过渡*，了解更多关于对象一致性的信息；'
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On line F, we created the nodes and moved them to the coordinates of `(d.y,
    d.x)` that the `d3.tree` layout has calculated for us. We switched `x` and `y`
    in this case since by default the `d3.tree` layout calculates coordinates in portrait
    mode while we want to render them in the landscape mode in this recipe. On line
    G, we also created `onClick` event handler to handle user mouse click on tree
    nodes. The `toggle` function consists of the following code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 F 上，我们创建了节点并将它们移动到 `d3.tree` 布局为我们计算的 `(d.y, d.x)` 坐标。在这种情况下，我们交换了 `x` 和
    `y`，因为默认情况下 `d3.tree` 布局以竖直模式计算坐标，而在这个菜谱中我们希望以横幅模式渲染。在行 G 上，我们还创建了 `onClick` 事件处理程序来处理用户对树节点的鼠标点击。`toggle`
    函数由以下代码组成：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This function effectively hides the children field on a given data node temporarily.
    Doing this essentially remove all children from that node in visualization and
    hence gives the users the sense of collapsing its subtree when they click on a
    node:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数有效地暂时隐藏了给定数据节点上的子节点字段。这样做本质上从该节点中移除所有子节点，在可视化中因此给用户一种点击节点时折叠其子树的感觉：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On line H, we created SVG circle element to represent each tree node, and again
    we position them at `(d.y, d.x)`. Finally, on line J, we colored the node with
    different fill based on whether it is collapsed or open by checking the temporary
    `_children` file generated by the `toggle` function. The rest of the node and
    label rendering code are quite simple, so we will not cover them line by line
    here; refer to the source code on GitHub for more details.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在第H行，我们创建了SVG圆形元素来表示每个树节点，并且再次将它们定位在`(d.y, d.x)`。最后，在第J行，我们根据节点是折叠还是打开，通过检查由`toggle`函数生成的临时`_children`文件来用不同的填充色着色节点。其余的节点和标签渲染代码相当简单，所以在这里我们不会逐行介绍；更多详情请参考GitHub上的源代码。
- en: 'The next important function in this recipe is the `renderLinks` function. This
    function draws all the links that connect all the tree nodes we just created:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中下一个重要的函数是`renderLinks`函数。此函数绘制了我们刚刚创建的所有连接树节点的链接：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'First, for rendering links, we use `root.descendants().slice(1)` as its data
    instead of `root.descendants()`. This is because for `n` nodes there are `n -
    1` links since there is no link pointing to the root node in a tree. Once again,
    object constancy is used here to make our visualization more stable during re-rendering.
    Then, on line M, we created path elements to represent each link in our visualization.
    Now, the interesting part of this function lies in the `generateLinkPath` function
    on line N:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了渲染链接，我们使用`root.descendants().slice(1)`作为其数据，而不是`root.descendants()`。这是因为对于`n`个节点，有`n
    - 1`个链接，因为在树中不存在指向根节点的链接。再次使用对象一致性来使我们的可视化在重新渲染期间更加稳定。然后，在第M行，我们创建了路径元素来表示我们可视化中的每个链接。现在，这个函数有趣的部分在于第N行的`generateLinkPath`函数：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this function, we use the `d3.path` generator to generate a Bezier curve
    that connects the source and target nodes. You can probably see that the usage
    of the `d3.path` generator is almost like describing how the line should be drawn.
    In this case, we moved the starting point of such line to `(target.y, target.x)`
    and then draw a Bezier curve with the given control points from target to source,
    as shown in the following illustration:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们使用`d3.path`生成器生成一个连接源节点和目标节点的贝塞尔曲线。你可能注意到，`d3.path`生成器的使用几乎就像描述如何绘制线条。在这种情况下，我们将这条线的起点移动到`(target.y,
    target.x)`，然后从目标到源使用给定的控制点绘制贝塞尔曲线，如下面的插图所示：
- en: '![How it works...](img/image_09_011.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/image_09_011.jpg)'
- en: Bezier curve
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 贝塞尔曲线
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, if you are familiar with the SVG path commands, then you can generate
    the d formula without using the `d3.path` generator. In this case, we are essentially
    using M and C commands. However, the `d3.path` generator function is more readable
    and works well with both SVG and Canvas, hence, it yields more maintainable code
    in general. For more information on SVG path command, refer to [https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands](https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands)
    .
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你熟悉SVG路径命令，那么你可以不使用`d3.path`生成器生成d公式。在这种情况下，我们本质上使用M和C命令。然而，`d3.path`生成器函数更易于阅读，并且与SVG和Canvas都兼容得很好，因此通常产生更易于维护的代码。有关SVG路径命令的更多信息，请参阅
    [https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands](https://www.w3.org/TR/SVG/paths.html#PathDataCubicBezierCommands)。
- en: At this point, we now have the entire tree graph visualized. As you can see
    with the help of the `d3.tree` layout, drawing this kind of complex visualization
    is relatively straightforward if not easy.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们现在已经将整个树形图可视化。正如你所见，借助`d3.tree`布局，绘制这种复杂可视化相对直接，如果不是容易的话。
- en: See also
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `d3.tree` offers several functions that allow customization. For more details,
    check out its API documentation at [https://github.com/d3/d3-hierarchy/blob/master/README.md#tree](https://github.com/d3/d3-hierarchy/blob/master/README.md#tree)
    .
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.tree` 提供了几个函数，允许自定义。更多详情，请查看其API文档，链接为 [https://github.com/d3/d3-hierarchy/blob/master/README.md#tree](https://github.com/d3/d3-hierarchy/blob/master/README.md#tree)。'
- en: The `d3.path` generator is capable of generating any arbitrary line on canvas
    and SVG; for more information, refer to its API document at [https://github.com/d3/d3-path/blob/master/README.md#path](https://github.com/d3/d3-path/blob/master/README.md#path)
    .
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.path`生成器能够在画布和SVG上生成任何任意线条；更多信息，请参考其API文档[https://github.com/d3/d3-path/blob/master/README.md#path](https://github.com/d3/d3-path/blob/master/README.md#path)。'
- en: Refer to the *Animating multiple elements* recipe in [Chapter 6](ch06.html "Chapter 6. Transition
    with Style"), *Transition with Style*, for explanations on object constancy.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第6章](ch06.html "第6章。以风格过渡")中的*动画多个元素*菜谱，*以风格过渡*，以了解对象恒常性的解释。
- en: This recipe is inspired by Mike Bostock's Tidy Tree example, which you can find
    at [http://bl.ocks.org/mbostock/4339184](http://bl.ocks.org/mbostock/4339184)
    .
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此菜谱灵感来源于Mike Bostock的Tidy Tree示例，您可以在[http://bl.ocks.org/mbostock/4339184](http://bl.ocks.org/mbostock/4339184)找到。
- en: Building an enclosure diagram
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建封装图
- en: An enclosure diagram is an interesting visualization of hierarchical data structures
    that use the recursive circle packing algorithm. It uses containment (nesting)
    to represent hierarchy. Circles are created for each leaf node in a data tree,
    while its size is proportional to a particular quantitative dimension of each
    data element. In this recipe, you will learn how to implement this kind of visualization
    using the D3 pack layout.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 封装图是使用递归圆形打包算法的层次数据结构的有趣可视化。它使用包含（嵌套）来表示层次结构。为数据树中的每个叶节点创建圆形，其大小与每个数据元素的一个特定定量维度成比例。在这个菜谱中，您将学习如何使用D3打包布局实现这种可视化。
- en: Getting ready
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Open your local copy of the following file in your web browser:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的网络浏览器中打开以下文件的本地副本：
- en: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html](https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter9/pack.html)'
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, let''s see how we can implement an enclosure diagram using
    `d3.pack`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，让我们看看如何使用`d3.pack`实现一个封装图：
- en: '[PRE30]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This recipe generates the following visualization:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱生成了以下可视化：
- en: '![How to do it...](img/image_09_012.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/image_09_012.jpg)'
- en: Enclosure diagram
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 封装图
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'In this recipe, we continue to use hierarchical JSON data source that describes
    Flare project package relationship. For more information on the data source, refer
    to the *Build a treemap* recipe in this chapter. The JSON data structure looks
    like the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们继续使用描述Flare项目包关系的层次JSON数据源。有关数据源的信息，请参考本章的*构建树状图*菜谱。JSON数据结构如下所示：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This data is loaded into the chart object in the `flare` function:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据在`flare`函数中加载到图表对象中：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In this visualization, the first thing we need to take care of is to define
    our layout; in this case, we need to use the `d3.pack` layout:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个可视化中，我们首先需要关注的是定义我们的布局；在这种情况下，我们需要使用`d3.pack`布局：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We set the size of our visualization on layout so it can calculate accordingly.
    After that, before we can pass our JSON data to the `d3.pack` layout once again,
    we need to first process it using the `d3.hierachy` function (refer to line B),
    which is a prerequisite for any D3 hierarchical visualization:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在布局上设置了可视化的尺寸，以便它可以相应地计算。之后，在我们再次将JSON数据传递给`d3.pack`布局之前，我们需要首先使用`d3.hierarchy`函数（参考B行）对其进行处理，这是任何D3层次可视化必备的先决条件：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this case, we `told d3.hierarchy` function to sum up all values using the
    `_valueAccessor` function, which takes `d.size` as the value by default. Additionally,
    we also asked the `d3.hierachy` function to sort the nodes based on the values.
    Finally, we then pass the processed data to the `pack` function on line C. The
    layout data after this process now look like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过`_valueAccessor`函数告诉`d3.hierarchy`函数将所有值相加，该函数默认以`d.size`作为值。此外，我们还要求`d3.hierachy`函数根据值对节点进行排序。最后，我们将处理后的数据传递给C行上的`pack`函数。经过此过程后的布局数据现在看起来如下：
- en: '![How it works...](img/image_09_013.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/image_09_013.jpg)'
- en: Pack layout data
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 打包布局数据
- en: 'Circle rendering is done in the `renderCircle` function:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形渲染是在`renderCircle`函数中完成的：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then, we simply bind the layout data and create the `svg:circle` elements for
    each node. For update, we set `cx`, `cy`, and `radius` to the value that the pack
    layout has calculated for us for each circle (refer to line D). Finally, when removing 
    the circle, we reduce the size of the circle down to zero first, before removing
    them to generate a more smooth transition. Label rendering in this recipe is pretty
    straightforward with some help from the auto-hiding technique we introduced in
    this chapter, so we will not cover the function in detail here.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们简单地绑定布局数据并为每个节点创建 `svg:circle` 元素。对于更新，我们将 `cx`、`cy` 和 `radius` 设置为打包布局为我们每个圆计算出的值（参见图
    D）。最后，在移除圆之前，我们首先将圆的大小减小到零，然后再移除它们以生成更平滑的过渡。在这个菜谱中，标签渲染相当直接，得益于我们在本章中引入的自动隐藏技术，因此我们不会在这里详细说明该函数。
- en: See also
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The `d3.pack` function offers several functions that allow customization. For
    more details, please check out its API documentation at [https://github.com/d3/d3-hierarchy/blob/master/README.md#pack](https://github.com/d3/d3-hierarchy/blob/master/README.md#pack)
    .
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.pack` 函数提供了几个允许定制的函数。有关更多详细信息，请查看其 API 文档，链接为 [https://github.com/d3/d3-hierarchy/blob/master/README.md#pack](https://github.com/d3/d3-hierarchy/blob/master/README.md#pack)。'
- en: The *Building a treemap* recipe for auto label hiding technique.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建树状图* 菜谱中的自动标签隐藏技术。'
- en: This recipe is inspired by Mike Bostock's pack layout example, which you can
    find at [http://bl.ocks.org/mbostock/ca5b03a33affa4160321](http://bl.ocks.org/mbostock/ca5b03a33affa4160321)
    .
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个菜谱灵感来源于 Mike Bostock 的打包布局示例，您可以在 [http://bl.ocks.org/mbostock/ca5b03a33affa4160321](http://bl.ocks.org/mbostock/ca5b03a33affa4160321)
    找到。
