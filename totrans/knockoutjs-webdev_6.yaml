- en: Chapter 6. Packaged Elegance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First there was HTML and JavaScript, then CSS. Next came AJAX to usher in Web
    2.0, as it is called. After that, templates drove us to a more dynamic, creative
    platform. The next advancement in web development was custom HTML components.
    KnockoutJS allows us to jump right in with some game-changing elegance for designers
    and developers. In this chapter, we will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bring Your Own Tags** (**BYOT**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing attribute handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making your own libraries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous module definition** (**AMD**)—on demand resource loading'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component-based **Single-Page Applications** (**SPA**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This entire chapter is about packaging your code for reuse. Using these techniques,
    you can make your code more approachable and elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We hope you enjoyed learning about templates in the last chapter. Perhaps the
    best explanation of a component is a packaged template with an isolated ViewModel.
    Here is the syntax we would use to declare a `like` component on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are passing no parameters through to the component, this is the correct
    syntax. If you wish to pass parameters through, you would use a JSON style structure
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This would allow us to pass named parameters through to our custom component.
    In this case, we are passing a parameter named `approve`. This would mean we had
    a bound `viewModel` variable by the name of `like`. Look at how this would be
    coded. Create a page called `components.html` using the `_base.html` file to speed
    things up as we have done in all our other chapters. In your `script` section,
    create the following ViewModel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will create our custom component. Here is the basic component we will
    use for this first component. Place the code where the comment is, as we want
    to make sure it is added before our `applyBindings` method is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two sections to our components: the `viewModel` and `template` sections.
    In the previous chapter, we learned how to use Knockout templates. In this chapter,
    we will be using those details inside the component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The standard Knockout component passes variables to the component using the
    `params` structure. We can either use this structure or you could optionally use
    the *self = this* approach if desired. In addition to setting the variable structure,
    it is also possible to create behaviors for our components. If we look in the
    template code, we can see we have data-bound the click event to toggle the approve
    setting in our component. Then, inside the button, by binding to the visible trait
    of the `span` element, either the thumbs up or thumbs down image will be shown
    to the user. Yes, we are using a Bootstrap icon element rather than a graphic
    here. Here is a screenshot of the initial state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to components](img/1028OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we click on the thumb image, it will toggle between the thumbs up and
    the thumbs down version. Since we also passed in the external variable that is
    bound to the page ViewModel, we see that the value in the matched span text will
    also toggle. Here is the markup we would add to the page to produce these results
    in the View section of our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You could build this type of functionality with a jQuery plugin as well, but
    it is likely to take a bit more code to do two-way binding and match the tight
    functionality we have achieved here. This doesn't mean jQuery plugins are bad,
    as this is also a jQuery-related technology. What it does mean is we have ways
    to do things even better. It is this author's opinion that features like this
    would still make great additions to the core jQuery library. Yet, I am not holding
    my breath waiting for them to adopt a Knockout-type project to the wonderful collection
    of projects they have at this point, and do not feel we should hold that against
    them. Keeping focused on what they do best is one of the reasons libraries like
    Knockout can provide a wider array of options. It seems the decisions are working
    on our behalf even if they are taking a different approach than I expected.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic component selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should have noticed when we selected the component that we did so using
    a quoted declaration. While at first it may seem to be more constricting, remember
    that it is actually a power feature. By using a variable instead of a hardcoded
    value, you can dynamically select the component you would like to be inserted.
    Here is the markup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are passing in both `widgetName` as well as `widgetParams`.
    Because we are binding the structure differently, we also need to show the bound
    value differently in our span. Here is the `script` part of our code that needs
    to be added to our `viewModel` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will get the same visible results but notice that each of the like buttons
    is acting independent of the other. What would happen if we put more than one
    of the same elements on the page? If we do that, Knockout components will act
    independent of other components. Well, most of the time they act independent.
    If we bound them to the same variable they would not be independent. In your `viewModel`
    declaration code, add another variable called `like2` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will add another like button to the page by copying our first like
    View code. This time, change the value from `like` to `like2` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This time when the page loads, the other likes display with a thumbs up, but
    this like will display with a thumbs down. The text will also show **false** stored
    in the bound value. Any of the like buttons will act independently because each
    of them is bound to unique values. Here is a screenshot of the third button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic component selection](img/1028OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Bring Your Own Tags (BYOT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What is an element? Basically, an element is a component that you reach using
    the tag syntax. This is the way it is expressed in the official documentation
    at this point and it is likely to stay that way. It is still a component under
    the hood. Depending on the crowd you are in, this distinction will be more or
    less important. Mostly, just be aware of the distinction in case someone feels
    it is important, as that will let you be on the same page in discussions. Custom
    tags are a part of the forthcoming HTML feature called Web Components. Knockout
    allows you to start using them today. Here is the View code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You may want to code some tags with a single tag rather than a double tag, as
    in an opening and closing tag syntax. Well, at this time, there are challenges
    getting each browser to see the custom element tags when declared as a single
    tag. This means custom tags, or elements, will need to be declared as opening
    and closing tags for now.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also need to create our `like3` bound variable for `viewModel` with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Running the code gives us the same wonderful functionality as our `data-bind`
    approach, but now we are creating our own HTML tags. Has there ever been a time
    you wanted a special HTML tag that just didn't exist? There is a chance you could
    create that now using Knockout component element-style coding.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing attribute handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, while custom tags are awesome, there is just something different about
    passing everything in with a single param attribute. The reason for this is that
    this process matches how our tags work when we are using the `data-bind` approach
    to coding. In the following example, we will look at passing things in via individual
    attributes. This is not meant to work as a `data-bind` approach, but it is focused
    completely on the custom tag element component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you want to do is make sure this enhancement doesn''t cause
    any issues with the normal elements. We did this by checking the custom elements
    for a standard prefix. You do not need to work through this code as it is a bit
    more advanced. The easiest thing to do is to include our Knockout components tag
    with the following `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this tag, we have this code segment to convert the tags that start with `kom-`
    to tags that use individual attributes rather than a JSON translation of the attributes.
    Feel free to borrow the code to create libraries of your own. We are going to
    be creating a standard set of libraries on GitHub for these component tags. Since
    the HTML tags are Knockout components, we are calling these libraries "KOmponents".
    The resource can be found at [https://github.com/sosensible/komponents](https://github.com/sosensible/komponents).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, with that library included, we will use our View code to connect to the
    new tag. Here is the code to use in the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that in our HTML markup, the tag starts with the library prefix. This
    will also require `viewModel` to have a binding to pass into this tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the code for the actual "attribute-aware version" of Knockout
    components. Do not place this in the code as it is already included in the library
    in the shared directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The tag in the View changed as we passed the information in via named attributes
    and not as a JSON structure inside a param attribute. We also made sure to manage
    these tags by using a prefix. The reason for this is that we did not want our
    fancy tags to break the standard method of passing params commonly practiced with
    regular Knockout components.
  prefs: []
  type: TYPE_NORMAL
- en: As we see, again we have another functional component with the added advantage
    of being able to pass the values in a style more familiar to those used to coding
    with HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we are calling our custom components KOmponents. We will be creating
    a number of library solutions over time and welcome others to join in. Tags will
    not do everything for us, as there are some limitations yet to be conquered. That
    doesn't mean we wait for all the features before doing the ones we can for now.
    In the previous chapter, we showed a `KOmponent` tag for using templates. That
    is also included in the base KOmponent library.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this segment of the chapter, we will also be showing some tags from our
    Bootstrap `KOmponents` library. First we will need to include the Bootstrap `KOmponents`
    library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Above `viewModel` in our script, we need to add a function to make this section
    of code simpler. At times, when passing items into observables, we can pass in
    richer bound data using a function like this. Again, create this function above
    the `viewModel` declaration of the script, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, inside `viewModel`, we will declare a set of data to pass to a Bootstrap
    style `listGroup` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Each item in our array will have display, students, and type variables. We
    are using a number of features in Bootstrap here but packaging them all up inside
    our Bootstrap smart tag. This tag starts to go beyond the bare basics. It is still
    very implementable, but we don''t want to throw too much at you to absorb at one
    time, so we will not go into the detailed code for this tag. What we do want to
    show is how much power can be wrapped into custom Knockout tags. Here is the markup
    we will use to call this tag and bind the correct part of `viewModel` for display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'That is it. You should take note of a couple of special details. The data is
    passed in as a bound Knockout ViewModel. The badge field is passed in as a string
    name to declare the field on the data collection where the badge count will be
    pulled. The same string approach has been used for the type field. The type will
    set the colors as per standard Bootstrap types. The theme here is that if there
    are not enough students to hold a class, then it shows the danger color in the
    list group custom tag. Here is what it looks like in the browser when we run the
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your own libraries](img/1028OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While this is neat, let''s jump into our browser tools console and change the
    value of one of the items. Let''s say there was a class on some cool web technology
    called jQuery. What if people had not heard of it and didn''t know what it was
    and you really wanted to take the class? Well, it would be nice to encourage a
    few others to check it out. How would you know whether the class was at a danger
    level or not? Well, we could simply use the badge and the numbers, but how awesome
    is it to also use the color coding hint? Type the following code into the console
    and see what changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Because JavaScript starts counting with zero for the first item, we will get
    the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your own libraries](img/1028OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now we know we have the right item, so let''s set the student count to nine
    using the following code in the browser console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the change in the jQuery class. Both the badge and the type value have
    updated. This screenshot of the update shows how much power we can wield with
    very little manual coding:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building your own libraries](img/1028OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We should also take a moment to see how the type was managed. Using the functional
    assignment, we were able to use the Knockout computed binding for that value.
    Here is the code for that part again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: While the code is outside the `viewModel` declaration, it is still able to bind
    properly to make our code run even inside a custom tag created with Knockout's
    component binding.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap component example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is another example of binding with Bootstrap. The general best practice
    for using modal display boxes is to place them higher in the code, perhaps under
    the `body` tag, to make sure there are no conflicts with the rest of the code.
    Place this tag right below the `body` tag as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we will need to make some declarations inside `viewModel` for this to
    work right. Enter this code into the declarations of `viewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also create a button on the page to call our `viewModel`. The button
    will use the binding that is part of Bootstrap. The `data-toggle` and `data-target`
    attributes are not Knockout binding features. Knockout works side-by-side wonderfully
    though. Another point of interest is the standard ID attribute, which tells how
    Bootstrap items, like this button, interact with the modal box. This is another
    reason it may be beneficial to use KOmponents or a library like it. Here is the
    markup code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'When we click on the button, this is the requestor we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap component example](img/1028OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, to understand the power of Knockout working with our requestor, head back
    over to your browser tools console. Enter the following command into the prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot shows the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap component example](img/1028OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Who knows what type of creative modular boxes we can build using this type of
    technology. This brings us closer towards creating what we can imagine. Perhaps
    it may bring us closer to building some of the wild things our customers imagine.
    While that may not be your main motivation for using Knockout, it would be nice
    to have a few less roadblocks when we want to be creative. It would also be nice
    to have this wonderful ability to package and reuse these solutions across a site
    without using copy and paste and searching back through the code when the client
    makes a change to make updates.
  prefs: []
  type: TYPE_NORMAL
- en: Again, feel free to look at the file to see how we made these components work.
    They are not extremely complicated once you get the basics of using Knockout and
    its components. If you are looking to build components of your own, they will
    help you get some insight on how to do things inside as you move your skills to
    the next level.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the AMD approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to look into the concept of what makes an AMD-style website. The
    point of this approach to sites is to pull content on demand. The content, or
    modules as they are defined here, does not need to be loaded in a particular order.
    If there are pieces that depend on other pieces, that is, of course, managed.
    We will be using the *RequireJS* library to manage this part of our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create four files in this example, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`amd.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`amd.config.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pick.js`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pick.html`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In our AMD page, we are going to create a configuration file for our RequireJS
    functionality. That will be the `amd.config.js` file mentioned in the aforementioned
    list. We will start by creating this file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We see here that we are creating some alias names and setting the paths these
    names point to for this page. The file could, of course, be working for more than
    one page, but in this case, it has specifically been created for a single page.
    The configuration in RequireJS does not need the `.js` extension on the file names,
    as you would have noted.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will look at our `amd.html` page where we pull things together. We are
    again using the standard page we have used for this course, which you will notice
    if you preview the `done` file example of the code. There are a couple of differences
    though, because the JavaScript files do not all need to be called at the start.
    RequireJS handles this well for us. We are not saying this is a standard practice
    of AMD, but it is an introduction of the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to include the following three script files in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the configuration settings need to be set before calling the `require.js`
    library. With that set, we can create the code to wire Knockout binding on the
    page. This goes in our `amd.html` script at the bottom of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Most of this code should look very familiar. The difference is that the external
    files are being used to set the content for `viewModel` and `template` in the
    `pick` component. The `require` setting smartly knows to include the `pick.js`
    file for the `pick` setting. It does need to be passed as a string, of course.
    When we include the template, you will see that we use `text!` in front of the
    file we are including. We also declare the extension on the file name in this
    case. The text method actually needs to know where the text is coming from, and
    you will see in our `amd.config.js` file that we created an alias for the inclusion
    of the text function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create the `pick.js` file and place it in the same directory as
    the `amd.html` file. It could have been in another directory, and you would have
    to just set that in the component declaration along with the filename. Here is
    the code for this part of our AMD component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our code starts with the `define` method. This is our AMD functionality
    in place. It is saying that before we try to execute this section of code we need
    to make sure the Knockout library is loaded. This allows us to do on-demand loading
    of code as needed. The code inside the `viewModel` section is the same as the
    other examples we have looked at with one exception. We return `viewModel` as
    you see at the end of the preceding code. We used the shorthand code to set the
    value for `heads` and `tails` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will look at our template file, `pick.html`. This is the code we will
    have in this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This template follows the same concepts as the ones we looked at in the previous
    chapter. There is nothing special other than the code needed to make this example
    work. The goal is to allow a custom tag to offer up heads or tails options on
    the page. We also pass in a bound variable from `viewModel`. We will be passing
    it into three identical tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tags are actually going to load the content instantly in this example.
    The goal is to get familiar with how the code works. We will take it to full practice
    at the end of the chapter. Right now, we will put this code in the View segment
    of our `amd.html` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have included the `pick` tag three times. While we are passing
    in the bound choice item from `viewModel`, each tag will randomly choose heads
    or tails. When we run the code, this is what we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the AMD approach](img/1028OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Since we passed the same bound item into each of the three tags, when we click
    on any heads or tails set, it will immediately pass that value out to `viewModel`,
    which will in turn immediately pass the value back into the other two tag sets.
    They are all wired together through `viewModel` binding being the same variable.
    This is the result we get if we click on **Tails**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the AMD approach](img/1028OS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Well, it is the results we got that time. Actually, the results change pretty
    much every time we refresh the page. Now, we are ready to do something extra special
    by combining our AMD approach with Knockout modules.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based SPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can look at one of the fastest growing trends in web development, the
    concept of single-page applications. The name is fancier than the practice because
    it is wrapped in confusion, but we will help you get over that here.
  prefs: []
  type: TYPE_NORMAL
- en: First, think of your website as a computer or mobile device. You can put multiple
    applications on your system. The apps can work together or independently. While
    we understand this for our computing systems, we seem to get confused when we
    move to web servers. Everything is not one application, or better put, rarely
    should everything be one application. There was a day, before Windows, when your
    spreadsheet and your word processor were shipped as one application. This was
    very popular, but over time we figured out packaging two apps was smarter than
    trying to build cross functionality into one app. Thus, we created office suites.
  prefs: []
  type: TYPE_NORMAL
- en: Today, we are suffering from the effects of mistakes made on most server platforms.
    When our backend server languages were created, many of them created a packaging
    approach that was wrapped around the term "application". So, when you built a
    website with a shopping cart, forum, and blog, they all ran under the same application
    scope. In hindsight, we should have labeled these site scopes and sub-divided
    the shopping "application", the forum "application", and the blog "application"
    as items under the "site".
  prefs: []
  type: TYPE_NORMAL
- en: Single-page applications seem to be having the same folly. The architecture
    and naming conventions tend to cause confusion. As a fellow seasoned developer,
    let me be vain for a moment and give you my permission to think outside the box
    on this. Forget the name SPA for a moment and let's step back and just understand
    what it does. Once you understand what it does, you will be able to smartly figure
    out how to apply it. Good implementation is after all, or it should be, the goal.
  prefs: []
  type: TYPE_NORMAL
- en: Best development strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many goals connected to the best development strategies. The truth
    is that there is no single best strategy. It is similar to the truth commonly
    shared as an answer in tech circles: it depends. This means the first thing you
    need to know is the target needs before you figure out what fits the best. Some
    people get caught up thinking bleeding-edge solutions are the best strategies.
    Sometimes they are, but not universally. It should be a heads-up, wide awake decision.
    The truth is that unless we are getting business done, technology doesn''t add
    anything to the picture.'
  prefs: []
  type: TYPE_NORMAL
- en: Technology is powerful. Technology is about knowing. If we properly understand
    the challenges then we can better choose our technology, our methodologies, and
    our solutions. Sometimes we may choose Knockout and other times just stay with
    jQuery. Sometimes, we bring in other mixes of products such as RequireJS and more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting real
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another thing we should avoid is trying to apply technology we have never actually
    used anywhere. This is a high-stakes gamble, and this is why I hope you have been
    doing the code examples as you go through this book.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to create a solution, by popular name, an SPA, using Knockout
    and its components to drive the views. Because the concept is called SPA, we will
    call these dynamically loaded views "pages". We will be building on the AMD concept
    of dynamically loaded content using a few other SPA concepts as well. The goal
    here is not to teach you all the ins and outs of SPAs, but this will give you
    a pretty good launching point if you have never jumped in before.
  prefs: []
  type: TYPE_NORMAL
- en: Our page content, code if you prefer, will be sectioned off into a pages directory
    with each page having its template and `viewModel` in separate files. Earlier,
    we repeated the template and the ViewModel for on-page components. This time,
    we will be using components for on-page content as well as for declaring the main
    view content using components. For clarity, we have created a `components` folder
    for the non-page components; for instance, the navigation bar will be put in the
    `components` folder.
  prefs: []
  type: TYPE_NORMAL
- en: What makes an SPA fit for the basic description of a single page is that the
    browser only loads a base page at a time. After that, all content is pulled and
    injected into the page. So it is technically correct that there be only one page.
    The display of content on the page is loaded and updated on the fly, but technically
    speaking, it is still on the original page. This will be our `index.html` file.
    If you look in your exercise root folder, you will see a subdirectory called `spa`
    and another called `myspa`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to see a completed SPA, you can peek ahead and look at the SPA
    version. My suggestion is to build it up and take the discovery route. Only then
    compare it to the SPA version if you feel like you made a mistake. Here is a screenshot
    of our starting point with our `myspa` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting real](img/1028OS_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This looks rather plain, but it is actually more complex than you would think.
    Power tools often look unimpressive while sitting on the shelf. It is worth looking
    at the code of the home page. Here is the View or the template file for the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, when we look in Knockout for the binding data, we are looking for
    the base `viewModel` data. In this case, we are looking at the data contained
    in the `viewModel` component. Let''s look at the code of the component and see
    where it comes from by looking for our message variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We see the `define` method here again, which tells us we are taking care of
    dependencies properly using RequireJS. We see in the `myViewModel` section of
    code the `viewModel` attribute message. Remember to use the `this` type scope
    or the attributes will not be properly bound and visible on `viewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: We are just getting exposed to the tools of SPA sites and pages. While it may
    not be amazing yet, the beauty will present itself as you learn to use the tools
    here. It's like looking at the paint brushes of great artists. You would not have
    been able to predict the amazing paintings that came from them. It's time to teach
    you how to use the tools that create powerful SPA solutions and improve your mastery
    over web development.
  prefs: []
  type: TYPE_NORMAL
- en: Coding time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we will look at is our single page where everything is presented.
    Here is the code for the super-duper everything page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We see two JavaScript files here. The first is a configuration file and the
    second is the RequireJS file. That is not all the JavaScript requires, but the
    RequireJS file will manage pulling in the core libraries needed for this site
    to run properly. This is contained in the configuration file. Let''s take a look
    at that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This is the same kind of logic we used in our AMD example previously. You will
    notice that we are using several libraries in our code here. RequireJS handles
    much of the loading on demand, or as needed, if you prefer to state it that way.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also notice that in the `body` section of the `index.html` page there
    is a Knockout bound `div` element like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we pull the page content and drive it to the View for the user.
    If you are new to this kind of app, there is something that will appear to be
    missing. There is another file that is actually being called that is not immediately
    apparent. Look at the `script` tag that calls `require.js` into the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the `data-main` attribute binding. This tells the page to load in the
    `starup.js` file from the `app` folder. Let''s look at that file here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We see the `RequireJS define` method, and there is no return needed as the functionality
    here is to make sure things are bound right with Knockout. You will also see that
    it is declaring all the libraries it needs upfront, based on the array list with
    the settings in our `require.config.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you will see is the dynamic page components being registered.
    We only have one page at this time, so if you look in the `page`/`home` folder,
    you will see `home.js` and `view.html` as the files located there. We will look
    at those shortly, but they are the `viewModel` and `template` items for our page
    component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another aspect common to most SPAs is routing. The other JavaScript libraries
    handle this, and that is what is being bound to our global binding via the `route`
    attribute. All of this working together called that "less-than-awesome" page in
    the previous screenshot. The `router` file is the last piece of core pieces we
    need to work with as we build out, expanding our SPA. Let''s look at its code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Again, we see the `define` method in action here, keeping dependencies properly
    managed. There is also the routing which includes routes, or will include routes.
    At this time, there is only one route, and that is to our home page view. This
    is where we will be handling more page views. The rest of the code here is needed
    for the routes to function, but you don't have to understand it any more than
    you have to understand jQuery core code to use jQuery. So, if you want to explore
    it, you are welcome to do so. Otherwise, just focus on what you need to know,
    which is the routes array segment of this code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to do two things to add the navigation. The component for navigation
    has already been created, so we are just adding it into our SPA solution. First,
    open the `startup.js` file in the `app` folder. Under the general components comment,
    add this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to register components before they are called, and this is where we
    are doing that in our SPA. Now, we will be able to add the `nav-bar` tag to the
    top of the `body` section of our body on the `index.html` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Oh, while that does cover code, there is one more thing needed. To show our
    navigation, we need to take the content and the page view, and move it down enough
    to show the navigation. We put an ID of the page onto the element; so, open the
    `css/style.css` file and enter this code there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Go ahead and save and close that file as we will not need it again in this
    exercise. We now have a basic navigation bar for our SPA. This is how things look
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding navigation](img/1028OS_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s add an **About** page next. The **About** page will be different from
    our **Home** page because it will only contain static content. We will not be
    binding to `viewModel` this time. In the `startup.js` file, under the static page
    components comment, add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice we are only adding in a template, with no `viewModel`. We also need
    to add the link to our navigation. The code here is based on the use of Bootstrap.
    This is the code we would add after the home link in the code in the `components/nav-bar/nav-bar.html`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: I like how easy it is to manage the active setting based on whether this route
    matches this page. If you look at the component we registered and the `route().page`
    comparison, you will see that the values will make the page active when they match.
    There is one more thing we will need to have our `about` page work—the `about`
    page component itself. In the `page` folder, copy the `_base` file as `about`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing to do to create a new page is to add the page to our `Router`
    array, which is in the `app`/`router.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is what our page looks like when we select the `about` navigation item.
    (If you are having problems getting it to show, reload the application to make
    it work once changes have been made.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding pages](img/1028OS_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the highlighting works wonderfully, giving the user feedback to validate
    the page they are actually viewing. The static content on this page and the dynamic
    content on the home page give us the foundation to understand how to build SPA
    sites. Yet, we can do better than that. We are going to add in a page that will
    allow us to update the Bootstrap skin that we are using to view the site.
  prefs: []
  type: TYPE_NORMAL
- en: Time for some custom style
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start off by listing the things we do when we are adding another page
    to this form of Knockout-based SPA site:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a page component registration to the `startup.js` file in the `app` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a menu item in the `nav-bar` tag if desired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the router configuration to the `router.js` file in the `app` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new page in the `page` folder with appropriate files for `viewModel`
    and `template` code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the code for the first three steps. First is the registration code
    for the `startup.js` file. Add this right after the `home-page` component registration,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will add the following code to the `nav-bar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will add the following code to that `router.js` file so our system
    knows how to handle the new routed item.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The final phase, of course, will be creating the actual page component files.
    Again, we will copy the `_base` folder. This time, rename the copy as `boostrap`.
    Inside the folder, rename the `_base.js` file as `bootstrap.js` and you will be
    ready to code. Here is the `template` code to get started. Place this code in
    the `view.html` file under the `page`/`bootstrap` folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'This will be our `viewModel` code to place in the `boostrap.js` file under
    the `page`/`bootstrap` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this code, here is the view we get after clicking on the **Bootstrap**
    nav menu. Ah, wait! Before saving the screenshot, it appeared to me that the header
    of the template was not visible. My CSS had not been saved, so the offset was
    not working right. Now, with the correction made, here is the correct view. You
    should find that the other views will also show correctly now. How many of you
    caught that looking at my screenshots? Here again, we will show the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for some custom style](img/1028OS_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'That certainly looks better. It is also starting to shape up and offer a promising
    site. We need to go in and modify our ViewModel to make this page highly functional.
    Before we do that, we need to actually go back to the main `index.html` file and
    add an `id` attribute to the page style tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This will allow us to use jQuery to target and update the page style for the
    page. Yes, we are using jQuery here and not Knockout. It still happens. Now, in
    the `boostrap.js` file, replace the message variable with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that we have used a slash as a line break to continue coding on the next
    line. Some of us are familiar with that shortcut, but others may appreciate the
    tip if they are not.
  prefs: []
  type: TYPE_NORMAL
- en: We then add the `theme`, `themes`, and `themesVisible` attributes to our ViewModel.
    We will also need a couple of methods added to the page. These will be the `loadThemes`
    and `changeTheme` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `loadThemes` method will be pulling a JSON-based data file, AJAX style.
    Again, we will be using jQuery for this functionality. Here is the content of
    the JSON file. I would suggest just copying the file over from the matching SPA
    if you are not a perfect typist. This will also go into the `page`/`bootstrap`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to add the rest of the code to the `bootstrap.js` file in the
    `page`/`bootstrap` folder. First, we will add the `loadThemes` method. Here is
    the code for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This code will pull the data and push the data right into the data-bound themes
    array. Notice that we also included some code to show a very basic concept of
    exception handling. Now, add the code for the `changeTheme` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to bind these methods in `viewModel` to handle event triggers
    in our template code. There is one extra thing though that we need to handle this
    functionality. Notice `vm.bg(data.bg)` at the end of that method. We are setting
    the value of the incoming item to set a global variable. It tells the system whether
    the background we are using is a light or dark background. We won''t be using
    that yet, but we are creating it now to be used shortly. In order to do that,
    we need to add the following bit of code to our main site `starup.js` file in
    the `app` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can add our template code to the `view.html` file below the existing
    code. Notice that the button visibility is managed to improve user experience.
    When our data is loaded, we make the button invisible. We are also wiring the
    click method of the images to the `changeTheme` method on our `viewModel` component.
    At this time, there is no base variable alias for the component base, so we will
    use the `$parent` alias to target the method on the parent level of this data
    structure. Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we are all wired up now. If you have issues, compare the code to the
    code in the `SPA` folder as that is working and is from where the example code
    for this rebuild practice exercise came. Here is the initial screenshot when reloading
    and selecting the Bootstrap navigation item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for some custom style](img/1028OS_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Oh, if you do not recognize them, these skin styles are open source styles offered
    by [bootswatch.com](http://bootswatch.com) for us to use. They also have commercial
    solutions there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will click on the button to load our themes from the JSON-based data.
    This also could have been a live dynamic server location URL. This is what we
    get after clicking on the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for some custom style](img/1028OS_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we scroll down and click on **Superhero** and move our mouse, this is what
    we will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for some custom style](img/1028OS_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'm not sure why we have to move the mouse, but that will work most of the time;
    we would figure out an instant update if it was a live website, of course.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are able to update the styles by choice on demand. If you move to different
    pages, you will see that the look stays. If this were a live login site, we would
    use AJAX to store the user style choices back on the server. We could also choose
    to store them in cookie variables, but then if the user goes to another machine,
    their choices will not travel with them. This is why we suggest you store them
    on a server when possible.
  prefs: []
  type: TYPE_NORMAL
- en: Bonus item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Oh, we have a bonus for this part of the book. This book is based on Knockout
    3.2, but there is a nice change proposed for Knockout 3.3 that will let us address
    the component code with a component alias. It is very simple to update our code
    to try that out. First, we need to go to the `require.config.js` file in the `app`
    folder and make one change. We have to change the file the Knockout alias is targeting
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Then, we jump back into our `view.html` file in the `bootstrap` folder and change
    the `$parent` variable to `$component`. Next, we run our code again, which should
    work fine. This is more practical code, and if the data structure in a component
    were more complex, this pragmatic alias would just keep the code as simple as
    it should.
  prefs: []
  type: TYPE_NORMAL
- en: Building cross-page interaction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we did our Bootstrap page, we loaded the data on demand. This means it
    did not load till the user clicked and told the themes to load. In this page,
    the data will instantly, automatically load onto the page. It seemed helpful to
    show both approaches to save you from having to figure these options out.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using a jQuery page this time. We choose that for a couple of reasons.
    Firstly, we happen to appreciate all jQuery has done for the community over the
    years. The second reason is we noticed they have dark and light logo styles. We
    borrowed their graphics to show what they would look like on a dark Boostrap theme
    as well as on a light Bootstrap theme.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for our jQuery page. First is the registration code for the
    `startup.js` file. Add this code after the Bootstrap registration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will add the following code to the `nav-bar` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add this code to the `router.js` file so our system knows how
    to handle the new routed item. This is the full router section of code at this
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The final phase, of course, will be creating the actual page component files.
    Again, we will copy the `_base` folder. This time, rename the copy as `jquery`.
    Inside the folder, rename the `_base.js` file as `jquery.js` and you will be ready
    to code. We also have files to pull over from the working version of this SPA.
    We will be pulling the `data.json` file and the `logos` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now edit our `viewmodel` file first. Here is the code for the `jquery.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We again have our `defined` method, which takes the values of the two items
    and passes them into the function as parameters. The declarations are straightforward
    with one difference. This time, we are passing the results of a `jQuery JSON`
    request into the `self.project` binding. We again have a very basic exception
    handling, in case there are exceptions, as they are part of awesome coding. This
    time, the method we are creating in this component is a method to set the logo
    name. Here is our `view.html` code so we can look at how it was integrated. Note
    that inside the method, we are again using the main SPA `viewModel` binding to
    pull the light or dark background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see our template will loop through each project that was returned from
    our AJAX call to the JSON data. Notice that we are using the `$component` item
    for the logo. If you are still not using Knockout 3.3 alpha code, or need to deploy
    with something else, you should change that back to `$parent` to make sure it
    works correctly without that enhancement. Otherwise, this is standard template
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in place, here is what the jQuery page will look like with a fresh
    reload and selection of the jQuery navigation tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building cross-page interaction](img/1028OS_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, the setting for the background is set to light and the logos it
    shows are the lighter logos. Now, we will jump to the Bootstrap page and select
    a darker style. This is what it will look like with the style we select:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building cross-page interaction](img/1028OS_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a very nice looking app to show off. While it may not do everything
    you have seen on any website, what it does will impress many a client or friend.
  prefs: []
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many plugins and ways to package and advance your abilities as a developer
    using Knockout. I will be opening up a resource at [http://knockout.developers.zone](http://knockout.developers.zone)
    where we will be sharing links and tips, and hope to have a meet-up or two over
    the next year for fellow Knockout developers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has pulled together concepts from every chapter and shown the awesome
    power of templates working together with ViewModels within Knockout components.
    You should now have an awesome foundation to do more with less than ever before.
    You should know how to mingle your jQuery code with the Knockout code side by
    side.
  prefs: []
  type: TYPE_NORMAL
- en: To review, in this chapter, we learned what Knockout components are. We learned
    how to use the components to create custom HTML elements that are interactive
    and powerful. We learned how to enhance custom elements to allow variables to
    be managed using the more common attributes approach. We learned how to use an
    AMD-style approach to coding with Knockout. We also learned how to AJAX everything
    and integrate jQuery to enhance Knockout-based solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Many people struggle to understand the concept of SPA or single-page application
    sites. We were able to create a single-page application that provides understanding
    and perspective. In fact, this could be the beginning of your next site.
  prefs: []
  type: TYPE_NORMAL
- en: What's next? That is up to you. One thing is for sure, the possibilities are
    broader using Knockout than they were before. Happy coding and congratulations
    on completing your study of KnockoutJS!
  prefs: []
  type: TYPE_NORMAL
