<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Dealing with Files</h1></div></div></div><p>When you are building a Backbone application you will consume resources from a RESTful web service; however most of the RESTful services use the JSON format to encode information, but JSON is not suitable to send and receive files. How we can send files to a RESTful server?</p><p>If you are developing an application that is not JavaScript–intensive, you can send files through an HTML form, but in <strong>Single Page Applications</strong> (<strong>SPA</strong>) this is not the best way to do it. Another issue is that Backbone does not provide an easy mechanism to send files because it is not compatible with the RESTful specification.</p><p>But web applications need to work with files. There are some approaches to deal with this common issue. For example, you could use a traditional POST form on resources where files may be included; however, that's not a good option. In this chapter you will learn the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Handle file uploads from an Express server</li><li class="listitem" style="list-style-type: disc">Adopt strategies to send files to a RESTful server</li><li class="listitem" style="list-style-type: disc">Upload files</li><li class="listitem" style="list-style-type: disc">Create a resource that includes a file in it</li></ul></div><p>We will start by adding support for uploading files to an Express server because it is important to know how a server can respond to upload requests.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Express server</h1></div></div></div><p>To <a id="id184" class="indexterm"/>demonstrate <a id="id185" class="indexterm"/>how to send files to a server, in this chapter we will work with the latest version of Express (the latest version available at the time of writing is Express 4.x). The server will be responsible for storing the REST resources and handling file uploads. Please consult the GitHub repo for this book to get the implementation of the server for the previous chapters.</p><p>For now, the current server is able to create, get, update, and delete contact resources; we need to add a mechanism to upload an avatar image for a contact. For simplicity the application does <a id="id186" class="indexterm"/>not use a database to store its data, but instead uses a hash table to store all data in memory. For<a id="id187" class="indexterm"/> example, the next snippet demonstrates how to store a contact:</p><div><pre class="programlisting">// Insert a new contact JSON into the contacts array
createContact(req, res) {
var contact = extractContactData(req);

  // Asssign a random id
  contact.id = makeId();
contacts.push(contact);

res.status(201)
.json(contact);
}</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Attaching a file into a resource</h1></div></div></div><p>Before we start <a id="id188" class="indexterm"/>receiving files in the Express server, we need to set up a strategy for that. We still want to use the RESTful services, so changing the format of the transmission data is not an option.</p><p>Respecting the RESTful standard (for more on the REST design for file uploads, see <a class="ulink" href="http://bit.ly/1GXqPNY">http://bit.ly/1GXqPNY</a>), we can attach a subresource endpoint under the target resource to handle the uploads, so that it will not disturb the original resource. However, this approach has a limitation: the resource should exist first, which means that you cannot create a contact and its avatar photo at the same time.</p><p>Following this approach, the endpoint for the avatar file uploading can be located at:</p><div><pre class="programlisting">http://example.com/api/contacts/10/avatar</pre></div><div><img src="img/B01962_05_01.jpg" alt="Attaching a file into a resource"/><div><p>Figure 5.1 File uploading schema</p></div></div><p>The preceding figure<a id="id189" class="indexterm"/> shows the schema for how file uploading should be handled by the server; the avatar endpoint will handle POST requests encoded as <code class="literal">multipart/form-data</code> instead of JSON, because that's the only way to upload files using the HTTP protocol. Note that in the endpoint it's included the contact id; in this way, once the file is uploaded we can associate the file with the resource. Though the endpoint does not accept a JSON as input, it can return a JSON to inform about the process:</p><div><pre class="programlisting">{
  "success": true,
  "avatar": {
    "file": "something.jpg",
    "url": "http://example.com/avatar/something.jpg"
  }
}</pre></div><p>In this example result, the server is telling us that we can access the avatar through the <code class="literal">http://example.com/avatar/something.jpg</code> URL. We need to modify the contact resource to include this new information in it:</p><div><pre class="programlisting">{
  "name": "John Doe",
  "email": "john.doe@example.com",
"avatar": {
    "file": "something.jpg",
    "url": "http://example.com/avatar/something.jpg"
  }

}</pre></div><p>The contact resource <a id="id190" class="indexterm"/>now includes the avatar information so that it can be used to show the avatar wherever it's needed—for example, in the contact list. To display the avatar image, the only thing you need to do is include the avatar URL in an <code class="literal">img</code> tag.</p><p>The server should be able serve these files too. In the simplest workflow, you can put all the avatar images in a common path and serve that path as regular assets; the downside of this approach is that anyone can see the files if they have the name of the file.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Uploading the avatar photo to contacts</h1></div></div></div><p>Let's start by <a id="id191" class="indexterm"/>creating the endpoint to upload avatar photos:</p><div><pre class="programlisting">
<code class="literal">// routes.js</code>
<code class="literal">var controller = require('./controller');</code>

<code class="literal">//...</code>
<code class="literal">server.post('/api/contacts/:contactId/avatar', </code>
<code class="literal">controller.uploadAvatar);</code>
</pre></div><p>Express itself does not <a id="id192" class="indexterm"/>process files automatically; it needs a plug-in that transforms the raw request into a more user-friendly API. This plug-in is named <code class="literal">multer</code>; it processes <code class="literal">multipart/form-data</code>, saving the file into a temporary path or making a buffer object, and then provides a JSON object with metadata information:</p><div><pre class="programlisting">// Avatar endpoints
var upload = multer();
server.post('/api/contacts/:contactId/avatar', upload.single('avatar'),
controller.uploadAvatar
);
server.use('/avatar', express.static(__dirname + '/avatar'));</pre></div><p>With the <a id="id193" class="indexterm"/>default configuration, it will save all the uploaded files<a id="id194" class="indexterm"/> into the temporary path of your operating system, which is <code class="literal">/tmp</code> in Unix systems; <code class="literal">multer</code> will attach a <code class="literal">files</code> attribute in the <code class="literal">req</code> object, which we can inspect to retrieve information about the uploaded files:</p><div><pre class="programlisting">uploadAvatar(req, res, next) {
varcontactId = req.params.contactId;
var filename, fullpath;

  // Ensure that user has sent the file
  if (!_.has(req, 'file')) {
    return res.status(400).json({
      error: 'Please upload a file in the avatar field'
    });
  }

  // File should be in a valid format
var metadata = req.file;
  if (!isValidImage(metadata.mimetype)) {
res.status(400).json({
      error: 'Invalid format, please use jpg, png or gif files'
    });
    return next();
  }

  // Get target contact from database
var contact = _.find(contacts, 'id', contactId);
  if (!contact) {
res.status(404).json({
      error: 'contact not found'
    });
    return next();
  }

  // Ensure that avatar path exists
  if (!fs.existsSync(AVATAR_PATH)) {
fs.mkdirSync(AVATAR_PATH);
  }

  // Ensure unique filename to prevent name colisions
var extension = getExtension(metadata.originalname);
  do {
    filename = generateFilename(25, extension);
fullpath = generateFullPath(filename);
  } while(fs.existsSync(fullpath));

  // Remove previous avatar if any
removeAvatar(contact);

  // Save the file in disk
varwstream = fs.createWriteStream(fullpath);
wstream.write(metadata.buffer);
wstream.end();

  // Update contact by assingn the url of the uploaded file
contact.avatar = {
    file: filename,
url: generateURLForAvatar(filename)
  };

res.json({
    success: true,
    avatar: contact.avatar
  });
}</pre></div><p>In the first steps, we<a id="id195" class="indexterm"/> validate that user has been uploaded a <a id="id196" class="indexterm"/>valid file and then we get the target user from the database and, if doesn't exist, we return an Http <code class="literal">404</code> error. The <code class="literal">multer</code> plug-in stores the uploaded file in memory, and can be processed before saving the file to the final path; for example, maybe we want to generate a thumbnail file or process the image to save space on disk.</p><p>We ensure that the avatar path exists; if doesn't we then create the path. In the next steps, we generate a filename to be assigned to the uploaded file in order to prevent filename collisions; the <code class="literal">generateFilename()</code> function generates that filename and then checks if it already exists; if it does, then we generate another filename and so on.</p><p>Once we have a unique filename for the uploaded file, we store the file from the in-memory buffer to the<a id="id197" class="indexterm"/> generated path. Now that the file is in the <a id="id198" class="indexterm"/>avatar path, we can build the URL where we can get the image from the browser, and finally assign the URL to the <code class="literal">avatar</code> field in the contact resource.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec27"/>Showing the avatar</h2></div></div></div><p>Now that <a id="id199" class="indexterm"/>we can upload images and the contact resource has the information about where the avatar is located, we can show the avatar in our views by pointing an <code class="literal">img</code> tag to the <code class="literal">avatar.url</code> property in the <code class="literal">Contact</code> model:</p><div><pre class="programlisting">&lt;% if (avatar &amp;&amp; avatar.url) { %&gt;
&lt;imgsrc="img/&lt;%= avatar.url %&gt;" alt="Contact photo" /&gt;
&lt;% } else { %&gt;
&lt;imgsrc="img/250x250" alt="Contact photo" /&gt;
&lt;% } %&gt;</pre></div><p>This will show the image, if any; otherwise it will show a default one. We should modify the Contact model to include a default avatar:</p><div><pre class="programlisting">// apps/contacts/models/contact.js
'use strict';

var Backbone = require('backbone');

class Contact extends Backbone.Model {
// ...

  get defaults() {
    return {
      name: '',
      phone: '',
      email: '',
      address1: '',
      address2: '',
facebook: '',
      twitter: '',
      google: '',
github: '',
      avatar: null
    };
  }

// ...
}

module.exports = Contact;</pre></div><p>If no avatar image <a id="id200" class="indexterm"/>is retrieved from the server, then we use a null image. The following screenshot shows how it looks like when you upload an image. This is enough to show an avatar image where it's necessary. It is very easy to show images. In the rest of the chapter, we will see how to perform the upload:</p><div><img src="img/B01962_05_02.jpg" alt="Showing the avatar"/><div><p>Figure 5.2 Showing the Contact avatar</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Uploading images from Backbone</h1></div></div></div><p>To allow us to <a id="id201" class="indexterm"/>upload files from our Backbone application, we should create an input file to be able to show a <strong>Choose</strong> file dialog. This<a id="id202" class="indexterm"/> could be done in the <code class="literal">ContactEditor</code> sub-application by changing the <code class="literal">ContactPreview</code> class to add this functionality. So let's change the current template and add the input:</p><div><pre class="programlisting">&lt;div class="box thumbnail"&gt;
&lt;div class="photo"&gt;
&lt;% if (avatar &amp;&amp; avatar.url) { %&gt;
&lt;imgsrc="img/&lt;%= avatar.url %&gt;" alt="Contact photo" /&gt;
&lt;% } else { %&gt;
&lt;imgsrc="img/250x250" alt="Contact photo" /&gt;
&lt;% } %&gt;
&lt;input id="avatar" name="avatar" type="file" 
style="display: none" /&gt;
&lt;/div&gt;
&lt;!-- ... --&gt;
&lt;/div&gt;</pre></div><p>Note that we <a id="id203" class="indexterm"/>have created a hidden input file field; we <a id="id204" class="indexterm"/>don't want to show the input field, but we want the control to open a <strong>Select File</strong> dialog. As the input is hidden, when the user clicks on the current image, we will show the file chooser:</p><div><pre class="programlisting">// apps/contacts/views/contactPreview.js
class ContactPreview extends ModelView {
// ...

  get events() {
    return {
      'click img': 'showSelectFileDialog'
    };
  }

showSelectFileDialog() {
    $('#avatar').trigger('click');
  }

  // ...
}</pre></div><p>When the user clicks on the image, it triggers a click event on the input; this will open the <strong>Open file </strong>dialog and allow the user to select a file from his/her hard drive. After the user selects the file, the browser triggers a <code class="literal">change</code> event on the file input that we can use to process the selection:</p><div><pre class="programlisting">// apps/contacts/views/contactPreview.js
class ContactPreview extends ModelView {
// ...

  get events() {
    return {
      'click img': 'showSelectFileDialog',
'change #avatar': 'fileSelected'
    };
  }

  // ...
}</pre></div><p>The <code class="literal">change</code> event <a id="id205" class="indexterm"/>will call the <code class="literal">fileSelected()</code>method that is responsible for processing the selected file. As we have seen in <a class="link" href="ch01.html" title="Chapter 1. Architecture of a Backbone application">Chapter 1</a>, <em>Architecture of a Backbone application</em> views should not talk to the server directly; for this reason, the view should not make any <code class="literal">AJAX</code> calls.</p><p>The best place to upload <a id="id206" class="indexterm"/>the image is in the Contact model, so the view should only get the selected file and delegate this process to the controller:</p><div><pre class="programlisting">// apps/contacts/views/contactPreview.js
class ContactPreview extends ModelView {
  // ...

fileSelected(event) {
event.preventDefault();

var $img = this.$('img');

    // Get a blob instance of the file selected
var $fileInput = this.$('#avatar')[0];
varfileBlob = $fileInput.files[0];

    // Render the image selected in the img tag
varfileReader = new FileReader();
fileReader.onload = event =&gt; {
      $img.attr('src', event.target.result);

      // Set the avatar attribute only if the
      // model is new
      if (this.model.isNew()) {
this.model.set({
          avatar: {
url: event.target.result
          }
        });
      }
    };
fileReader.readAsDataURL(fileBlob);

this.trigger('avatar:selected', fileBlob);
  }
}</pre></div><p>When a file is <a id="id207" class="indexterm"/>selected, we create a <code class="literal">blob</code> object and<a id="id208" class="indexterm"/> trigger an event with the object attached to be processed by the controller. Note that we use the HTML 5 API to immediately show the selected image as the avatar preview:</p><div><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
// ...

showEditor(contact) {
    // ...

this.listenTo(contactPreview, 'avatar:selected', blob =&gt; {
this.uploadAvatar(contact, blob);
    });
  }
}</pre></div><p>The <code class="literal">uploadAvatar()</code> method takes a file blob as argument and delegates the server connection to the <code class="literal">Contact</code> model:</p><div><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
// ...

uploadAvatar(contact, blob) {
    // Tell to others that upload will start
this.trigger('avatar:uploading:start');

contact.uploadAvatar(blob, {
      progress: (length, uploaded, percent) =&gt; {
        // Tell to others that upload is in progress
this.trigger('avatar:uploading:progress',
                     length, uploaded, percent);
      },
      success: () =&gt; {
        // Tell to others that upload was done successfully
this.trigger('avatar:uploading:done');
      },
      error: err =&gt; {
        // Tell to others that upload was error
this.trigger('avatar:uploading:error', err);
      }
    });
  }
}</pre></div><p>The <a id="id209" class="indexterm"/>controller will<a id="id210" class="indexterm"/> trigger <code class="literal">'avatar:uploading:*'</code> events to reflect the status of the uploading process. These events can be listened for the view to give visual feedback to the user. Figure 5.3 graphically shows the communication between the controller and the view:</p><div><img src="img/B01962_05_03.jpg" alt="Uploading images from Backbone"/><div><p>Figure 5.3 Event communication between the view and controller</p></div></div><p>The <code class="literal">uploadEvent()</code> method in the Contact model accepts a blob object as the first argument, which is the file that will be uploaded, and an <code class="literal">options</code> object with three possible functions that will be called as the communication with the server proceeds.</p><p>As you <a id="id211" class="indexterm"/>may <a id="id212" class="indexterm"/>guess, <code class="literal">success</code> and <code class="literal">error</code> callbacks will be called if the server accepts the file or if a error happens, respectively. Large files are divided and uploaded to the server in chunks; the <code class="literal">progress()</code>callback is called as the chunks are received in the server. With the information provided in the <code class="literal">progress()</code> handler, we can update a progress bar to show the progress to the user:</p><div><pre class="programlisting">// apps/contacts/views/contactPreview.js
class ContactPreview extends ModelView {
  constructor(options) {
    super(options);
this.template = template;

this.model.on('change', this.render, this);

    if (options.controller) {
this.listenTo(
options.controller, 'avatar:uploading:start',
this.uploadingAvatarStart, this
      );
this.listenTo(
options.controller, 'avatar:uploading:done',
this.uploadingAvatarDone, this
      );
this.listenTo(
options.controller, 'avatar:uploading:error',
this.uploadingAvatarError, this
      );
    }
  }

uploadingAvatarStart() {
this.originalAvatarMessage = this.$('span.info').html();
this.$('span.notice').html('Uploading avatar...');
  }

uploadingAvatarDone() {
this.$('span.notice').html(this.originalAvatarMessage || '');
  }

uploadingAvatarError() {
this.$('span.notice').html(
'Can\'t upload image, try again later'
);
  }
}</pre></div><p>As the events <a id="id213" class="indexterm"/>are triggered by the controller, the view updates <a id="id214" class="indexterm"/>the message displayed to the user, so that the user can see if an error occurs, or supplies an uploading message to show what the application is doing.</p><p>We should pass the controller instance to the view at creation time:</p><div><pre class="programlisting">class ContactEditor {
// ...

showEditor(contact) {
    // ...
varcontactPreview = new ContactPreview({
      controller: this,
      model: contact
    });
  }
}</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec28"/>Uploading a file with AJAX</h2></div></div></div><p>The <code class="literal">Client</code> model<a id="id215" class="indexterm"/> receive the blob object, builds the URL to the<a id="id216" class="indexterm"/> <code class="literal">avatar</code> endpoint, and makes the appropriate calls to the callback objects:</p><div><pre class="programlisting">// apps/contacts/models/contact.js
class Contact extends Backbone.Model {
  // ...

uploadAvatar(imageBlob, options) {
    // Create a form object to emulate a multipart/form-data
varformData = new FormData();
formData.append('avatar', imageBlob);

varajaxOptions = {
url: '/api/contacts/' + this.get('id') + '/avatar',
      type: 'POST',
      data: formData,
      cache: false,
contentType: false,
processData: false
    };

    options = options || {};

    // Copy options to ajaxOptions
_.extend(ajaxOptions, _.pick(options, 'success', 'error'));

    // Attach a progress handler only if is defined
    if (options.progress) {
ajaxOptions.xhr = function() {
varxhr = $.ajaxSettings.xhr();

        if (xhr.upload) {
          // For handling the progress of the upload
xhr.upload.addEventListener('progress', event =&gt; {
            let length = event.total;
            let uploaded = event.loaded;
            let percent = uploaded / length;

options.progress(length, uploaded, percent);
          }, false);
        }

        return xhr;
      };
    }

$.ajax(ajaxOptions);
  }

  // ...
}</pre></div><p>See how the model builds the endpoint from its own data so that the view is decoupled of any server connection. As the <code class="literal">multipart/form-data</code> <code class="literal">POST</code> is not managed natively by the browser, we should create a <code class="literal">FormData</code> object that represents a form data structure, and add an <code class="literal">avatar</code> field (the field name that is expecting the server).</p><p>They key<a id="id217" class="indexterm"/> attribute<a id="id218" class="indexterm"/> in the <code class="literal">$.ajax()</code> call is <code class="literal">processData</code>, which is set to <code class="literal">false</code>; you can read the following in the jQuery documentation:</p><p>
<em>By default, data passed in to the data option as an object (technically, anything other than a string) will be processed and transformed into a query string, fitting to the default content-type "application/x-www-form-urlencoded". If you want to send a DOMDocument, or other non-processed data, set this option to false.</em>
</p><p>If you don't set this attribute to <code class="literal">false</code>, or leave it at the default, jQuery will try transform the <code class="literal">formData</code> object and the file will not be sent.</p><p>If a progress attribute is set in the <code class="literal">options</code> object, we overwrite the original <code class="literal">xhr() </code>function called by jQuery to get an <code class="literal">XMLHttpRequest</code> object instance; this allow us to listen for the <code class="literal">progress</code> event triggered by the browser while uploading the file.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Uploading the avatar image at creation time</h1></div></div></div><p>As we have seen so far, to <a id="id219" class="indexterm"/>upload and attach a file to a resource, it must already exist. How we can create a resource with a file attached? How can we create a contact that includes an avatar image?</p><p>To do so, we will need to create the resource in two steps. In the first step, we create the resource itself, and then in a second step we can upload all files we want to that resource. Yes, it's not possible to do this in a single server connection, at least without encoding the files you want to send:</p><div><img src="img/B01962_05_04.jpg" alt="Uploading the avatar image at creation time"/><div><p>Figure 5.4 Create contact process</p></div></div><p>The preceding figure shows how the process is done. Note that the model is responsible for handling these connections while the controller orchestrates the order of the communication and error handling. As we have seen previously, the <code class="literal">ContactEditor</code> triggers several events that the view can use to show to the user what's happening.</p><p>The views can be<a id="id220" class="indexterm"/> left as is; we should only modify the <code class="literal">ContactEditor</code> controller by changing how the <code class="literal">saveContact()</code> method behaves. However, we want to keep the feature of uploading the image as the user makes the selection. If the Contact model is new, this feature will break the application because no valid endpoint exists to upload the avatar:</p><div><pre class="programlisting">class ContactEditor {
// ...

showEditor(contact) {
    // ...

    // When avatar is selected, we can save it inmediatly if the
    // contact already exists on the server, otherwise just
    // remember the file selected
this.listenTo(contactPreview, 'avatar:selected', blob =&gt; {
this.avatarSelected = blob;

      if (!contact.isNew()) {
this.uploadAvatar(contact);
      }
    });
  }
}</pre></div><p>When an avatar is selected, instead of immediately uploading the file to the server, we check if the contact is new or not. If the model is not new, we can perform the upload by calling the <code class="literal">uploadAvatar()</code>method; otherwise, we keep a reference to the blob object in the <code class="literal">avatarSelected</code> attribute that the <code class="literal">uploadAvatar()</code> method will use when it is called.</p><p>The <code class="literal">saveContact()</code> method is responsible for orchestrating the algorithm described in the previous figure:</p><div><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactEditor {
saveContact(contact) {
varphonesData = this.phones.toJSON();
varemailsData = this.emails.toJSON();

contact.set({
      phones: phonesData,
      emails: emailsData
    });

    if (!contact.isValid(true)) {
      return;
    }

varwasNew = contact.isNew();

    // The avatar attribute is read-only
    if (contact.has('avatar')) {
contact.unset('avatar');
    }

    function notifyAndRedirect() {
      // Redirect user to contact list after save
App.notifySuccess('Contact saved');
App.router.navigate('contacts', true);
    }

contact.save(null, {
      success: () =&gt;{
        // If we are not creating an user it's done
        if (!wasNew) {
notifyAndRedirect();
          return;
        }

        // On user creation send the avatar to the server too
this.uploadAvatar(contact, {
          success: notifyAndRedirect
        });
      },
error() {
        // Show error message if something goes wrong
App.notifyError('Something goes wrong');
      }
    });
  }
  // ...
}</pre></div><p>Before calling the <code class="literal">save()</code> method in the Contact model, it's necessary to save whether the model is new or not; if we call this method after the save, the <code class="literal">isNew()</code> method will always return <code class="literal">true</code>.</p><p>If the model wasn't new, then<a id="id221" class="indexterm"/> any changes in the avatar image were already uploaded by the <code class="literal">'avatar:selected'</code> event handler, so we don't need to upload the image again. But if the image was new, then we should upload the avatar by calling the <code class="literal">uploadAvatar()</code> method; note that the method accepts an <code class="literal">options</code> object to register callbacks. This is necessary to provide feedback to the user; when the upload is done it calls the <code class="literal">notifyAndRedirect()</code> function to show a notification message and returns to the list of contacts.</p><p>We will need to change the implementation of <code class="literal">uploadAvatar()</code> to include the callbacks described earlier and to instead receive the blob as soon as it uses the <code class="literal">avatarSelected</code> attribute:</p><div><pre class="programlisting">// apps/contacts/contactEditor.js
uploadAvatar(contact, options) {
  // Tell to others that upload will start
this.trigger('avatar:uploading:start');

contact.uploadAvatar(this.avatarSelected, {
    progress: (length, uploaded, percent) =&gt; {
      // Tell to others that upload is in progress
this.trigger('avatar:uploading:progress',
                   length, uploaded, percent);
      if (options &amp;&amp;_.isFunction(options.success)) {
options.success();
      }
    },
    success: () =&gt; {
      // Tell to others that upload was done successfully
this.trigger('avatar:uploading:done');
    },
    error: err =&gt; {
      // Tell to others that upload was error
this.trigger('avatar:uploading:error', err);
    }
  });
}</pre></div><p>The method is basically the same; we just add the <code class="literal">options</code> callbacks and change the source of the <a id="id222" class="indexterm"/>blob object.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Encoding the upload file</h1></div></div></div><p>Another approach <a id="id223" class="indexterm"/>to uploading files is to encode the file into <code class="literal">base64</code>. When you encode a binary file to <code class="literal">base64</code>, the result is a string that we can use as an attribute in the request object.</p><p>Though it can be useful to create objects with the file attached in the resource, or to use it as another resource in the server, this is not a recommended approach. This approach has some limitations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the backend server is a node, the thread will be locked until the server decodes the <code class="literal">base64</code> string. This will lead to a low-performance app.</li><li class="listitem" style="list-style-type: disc">You cannot upload large amounts of data.</li><li class="listitem" style="list-style-type: disc">If the file is large, the Backbone application will freeze until the file is encoded to <code class="literal">base64</code>.</li></ul></div><p>If you are uploading very small amounts of data and don't have a huge amount of traffic, you can use this technique; otherwise, I encourage you to avoid it. Instead of uploading the file we can encode it:</p><div><pre class="programlisting">class ContactEditor {
  // ...

showEditor(contact) {
      // ...
this.listenTo(contactPreview, 'avatar:selected', blob =&gt; {
this.setAvatar(contact, blob);
    });
  }

setAvatar(contact, blob) {
varfileReader = new FileReader();

fileReader.onload = event =&gt; {
      let parts = event.target.result.split(',');
contact.set('avatarImage', parts[1]);
    };

fileReader.readAsDataURL(blob);
  }
}</pre></div><p>Of course the server <a id="id224" class="indexterm"/>implementation should be able to decode the <code class="literal">avatarImage</code> and store it as an image file.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we have seen how to upload files to the server; this is not the only way to do it, but is the more extended and flexible approach. Another possible method is to serialize the image into <code class="literal">base64</code> in the browser, then set the output string as an attribute in the model; when ten models are saved, the file encoded in <code class="literal">base64</code> will be part of the payload. The server should decode the string and process the result as a file.</p><p>We saw how to decouple the view from the business logic. The view should only process DOM events and trigger business logic level events; then a controller can deal with blob objects instead of low-level DOM nodes. This approach helped us to move upload processing from the view to the model, which is the ideal way to do it.</p><p>Finally, we dealt with the creation process; we cannot create a resource and attach files at the same time. We should first create the resource and then send all the files to the server as needed.</p><p>In the next chapter, you will learn how to store information directly in the browser. Instead of using a RESTful server, it might be nice to run standalone web applications that don't need a server to run.</p></div></body></html>