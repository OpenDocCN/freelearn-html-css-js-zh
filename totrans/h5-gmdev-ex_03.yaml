- en: Chapter 3. Building a Card-matching Game in CSS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*CSS3 introduces many exciting features. In this chapter, we will explore and
    use some of them to create a card-matching game. CSS3 styles how the game objects
    look and animate, while the jQuery library helps us to define the game logic.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Transform a playing card with animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flip a playing card with new CSS3 properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the whole memory matching game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embed a custom web font to our game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can try the card-matching game at the following URL to have a glimpse of
    what we are going to achieve in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://makzan.net/html5-games/card-matching/](http://makzan.net/html5-games/card-matching/)'
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Moving game objects with CSS3 transition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had a glimpse of the CSS3 transition and transformation modules in [Chapter
    1](ch01.html "Chapter 1. Introducing HTML5 Games"), *Introducing HTML5 Games,*
    when we were overviewing the new CSS3 features. We often want to animate the game
    objects by easing the properties. Transition is the CSS property designed for
    this purpose. Suppose that we have a playing card on the web page and want to
    move it to another position in five seconds. We would have to use JavaScript to
    set up a timer and write our own function to change the position every few milliseconds.
    By using the `transition` property, we just need to specify the start and end
    styles and the duration. The browser optimizes the output and does all the easing
    and in-between animations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at some examples to understand this.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – moving a playing card around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will place two playing cards on a web page and transform
    them to a different position, scale, and rotation. We will tween the transformation
    by setting the transition:'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, create a new project folder with the following hierarchy. The `css3transition.css`
    and `index.html` files are empty now and we will add the code later. The `jquery-2.1.3.min.js`
    file is the jQuery library that we used in the previous chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are using two playing card graphic images in this example. They are `AK.png`
    and `AQ.png`. The images are available in the code bundle or you can download
    them from the book assets website at [http://mak.la/book-assets/](http://mak.la/book-assets/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the two card images inside the `images` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next thing is to code the HTML with two card DIV elements. We will apply
    CSS transition style to these two cards elements when the page is loaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is time to define the visual styles of the playing cards via CSS. This contains
    basic CSS 2.1 properties and CSS3''s new properties. In the following code, the
    new CSS3 properties are highlighted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's save all the files and open the `index.html` file in the browser. The
    two cards should animate as shown in the following screenshot:![Time for action
    – moving a playing card around](img/B04290_03_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created two animation effects by using the CSS3 transition to tween
    the `transform` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage of CSS transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The arguments of the `transform` property are functions. There are two sets
    of functions: the 2D and 3D transform functions. **CSS transform** functions are
    designed to move, scale, rotate, and skew the target DOM elements. The following
    sections show the usage of the transform functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 2D transform functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 2D `rotate` function rotates the element clockwise on a given positive
    argument and counter-clockwise on a given negative argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `translate` function moves the element by the given *x* and *y* displacement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We can translate the *x* or *y* axis independently by calling the `translateX`
    and `translateY` function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `scale` function scales the element by the given `sx` and `sy` vectors.
    If we only pass the first argument, then `sy` will be of the same value as `sx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we can independently scale the *x* and *y* axis as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 3D transform functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The 3D rotation function rotates the element in 3D space by the given [x, y,
    z] unit vector. For example, we can rotate the *y* axis 60 degrees by using `rotate3d(0,`
    `1,` `0,` `60deg)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also rotate one axis only by calling the following handy functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the 2D `translate` function, `translate3d` allows us to move the
    element in all the three axes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `scale3d` scales the element in the 3D spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `transform` functions that we just discussed are common, and we will use
    them many times. There are several other `transform` functions that are not discussed;
    they are `matrix`, `skew`, and `perspective`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to find the latest CSS Transforms working spec, you can visit the
    W3C website of CSS Transforms Modules at: [http://www.w3.org/TR/css3-3d-transforms/](http://www.w3.org/TR/css3-3d-transforms/).'
  prefs: []
  type: TYPE_NORMAL
- en: Tweening the styles using CSS3 transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are tons of new features in CSS3\. Transition module is one among them
    that affects us most in game designing.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is **CSS3 transition**? W3C explains it in one sentence:'
  prefs: []
  type: TYPE_NORMAL
- en: '*CSS transitions allows property changes in CSS values to occur smoothly over
    a specified duration.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Normally, when we change any properties of the element, the properties are updated
    to the new value immediately. Transition slows down the changing process. It creates
    smooth in-between easing from the old value towards the new value in the given
    duration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage of the `transition` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The following table explains each of the parameters used in the `transition`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `property_name` | This is the name of the property where the transition applies.
    It can be set to `all`. |'
  prefs: []
  type: TYPE_TB
- en: '| `duration` | This is the duration that the transition takes. |'
  prefs: []
  type: TYPE_TB
- en: '| `timing_function` | The `timing` function defines the interpolation between
    the start and end values. The default value is `ease`. Normally, we will use `ease`,
    `ease-in`, `ease-out`, and `linear`. |'
  prefs: []
  type: TYPE_TB
- en: '| `delay` | The `delay` argument delays the start of the transition by the
    given seconds. |'
  prefs: []
  type: TYPE_TB
- en: 'We can put several `transition` properties in one line. For example, the following
    code transitions the opacity in 0.3 seconds and background color in 0.5 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also define each transition property individually by using the following
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Modules of CSS3**'
  prefs: []
  type: TYPE_NORMAL
- en: According to W3C, CSS3 is unlike CSS 2.1 in that there is only one CSS 2.1 spec.
    CSS3 is divided into different modules. Each module is reviewed individually.
    For example, there is a transition module, 2D/3D transforms module, and the Flexible
    Box Layout module.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for dividing the spec into modules is because the pace at which the
    work of each part of the CSS3 progresses is not the same. Some CSS3 features are
    rather stable, such as border radius, while some have not yet settled down. Dividing
    the whole spec into different parts allows the browser vendor to support modules
    that are stable. In this scenario, slow-paced features will not slow down the
    whole spec. The aim of the CSS3 spec is to standardize the most common visual
    usage in web designing and this module fits this aim.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have translated, scaled, and rotated the playing cards. How about we try
    to change different values in the example? There are three axes in the `rotate3d`
    function. What will happen if we rotate the other axis? Experiment with the code
    yourself to get familiar with the transform and transition modules.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a card-flipping effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine now that we are not just moving the playing card around, but we also
    want to flip the card element, just like we flip a real playing card. By using
    the `rotation` `transform` function, it is now possible to create the card-flipping
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – flipping a card with CSS3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to start a new project and create a card-flipping effect when
    we click on the playing card:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our previous code example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The card now contains two faces: a front face and a back face. Replace the
    following code in the `body` tag in the HTML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, create a new `css3flip.css` file in the `css` folder to test the flipping
    effect.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `index.html` file, change the CSS external link to the `css3flip.css`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let''s add the styles to the `css3flip.css`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two faces on each card. We are going to slowly rotate the face of
    the card. Therefore, we define how the face transitions by CSS3''s `transition`
    property. We also hide the back face''s visibility. We will look at the detail
    of this property later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, it is time to style each individual face. The front face has a higher
    z-index than the back face:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we flip the card, we rotate the front face to the back and the back face
    to the front. We also swap the z-index of the front and back faces:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add logic after loading the jQuery library to toggle the card-flipped
    status when we click on the card:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The styles and the scripts are now ready. Let's save all the files and preview
    it in our web browser. Click on the playing card to flip it over, and click on
    it again to flip it back.![Time for action – flipping a card with CSS3](img/B04290_03_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a card-flipping effect that can be toggled by a mouse click.
    You can try out the example at [http://makzan.net/html5-games/simple-card-flip/](http://makzan.net/html5-games/simple-card-flip/).
  prefs: []
  type: TYPE_NORMAL
- en: The example made use of several CSS transform properties and JavaScript to handle
    the mouse click event.
  prefs: []
  type: TYPE_NORMAL
- en: Toggling a class with jQuery's toggleClass function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We apply the `card-flipped` class to the card element when the mouse is clicked
    on the card. On the second click, we want to remove the applied card-flipped style
    so that the card flips back again. This is called **toggling a class** style.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery provides us with a handy function named `toggleClass` to add or remove
    classes automatically, depending on whether the class is applied or not.
  prefs: []
  type: TYPE_NORMAL
- en: To use the function, we simply pass the classes that we want to toggle as an
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code adds or removes the `card-flipped` class to
    an element with the ID as `card1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `toggleClass` function accepts the toggle instruction from more than one
    class at the same time. We can pass in several class names and separate them by
    using a space. Here is an example of toggling two classes at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Introducing CSS' perspective property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS3 lets us present elements in 3D, and we have been able to transform the
    elements in the 3D space. The `perspective` property defines how the 3D perspective
    view looks. You can treat the value as far as you are looking at the object. The
    closer you are, the more perspective distortion there is on the viewing object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two 3D cubes demonstrate how different perspective values change
    the perspective view of the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing CSS'' perspective property](img/B04290_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The cube is created by putting six faces together with 3D transforms applied
    to each face. It used the techniques that we've discussed. Try to create a cube
    and experiment with the `perspective` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following web page gives a comprehensive explanation on creating the CSS3
    cube, and it also explains how to control the rotation of the cube with the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://paulrhayes.com/experiments/cube-3d/](http://paulrhayes.com/experiments/cube-3d/)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing backface-visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the `backface-visibility` property was introduced, all the elements on
    the page presented their front face to the visitor. Actually, there was no concept
    of the front face or the back face of the element because presenting the front
    face was the only choice. While CSS3 introduces the rotation in three axes, we
    can rotate an element so that its face is on the back. Try looking at your palm
    and rotating your wrist, your palm turns and you see the back of your palm. This
    happens to the rotated elements too.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS3 introduces a property named `backface-visibility` to define whether or
    not we can see the back face of the element. By default, it is visible. The following
    figure demonstrates the two different behaviors of the `backface-visibility` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing backface-visibility](img/B04290_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can read more detailed information about different properties and functions
    in CSS 3D transforms on its official Webkit blog at [http://webkit.org/blog/386/3d-transforms/](http://webkit.org/blog/386/3d-transforms/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a card-matching memory game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through some basic techniques in CSS. Now, let's make a game using
    the techniques. We are going to make a card game. The card game will make use
    of transform to flip the card, transition to move the card, JavaScript to hold
    the logic, and a new HTML5 feature called **custom data attribute** to store custom
    data. Don't worry, we will discuss each component step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the sprite sheet of playing cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the card-flipping example, we were using the graphics of two different playing
    cards. Now, we will prepare graphics for the whole deck of playing cards. Although
    we will only use six playing cards in the matching game, we will prepare the whole
    deck so that we can reuse these graphics in other card games that we may create.
  prefs: []
  type: TYPE_NORMAL
- en: There are 52 playing cards in a deck and we have one more graphic for the backside.
    Instead of using 53 separate files, it is good practice to put separate graphics
    into one big sprite sheet file. Sprite sheet is a graphics technique that loads
    one graphic's texture into memory and displays part of the graphics for each game
    component.
  prefs: []
  type: TYPE_NORMAL
- en: One benefit of using a big sprite sheet instead of separate image files is that
    we can reduce the amount of **HTTP requests**. When the browser loads the web
    page, it creates a new HTTP request to load each external resource, including
    JavaScript files, CSS files, and images. It takes quite a lot of time to establish
    a new HTTP request for each separated small file. Combining the graphics into
    one file, greatly reduces the amount of requests and thus improves the responsiveness
    of the game when it is loading in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of placing graphics in one file is to avoid the overhead of
    the file format header and reduce the amount of HTTP requests. The time to load
    a sprite sheet with 53 images is faster than loading 53 different images with
    the file header in each file.
  prefs: []
  type: TYPE_NORMAL
- en: The following deck of playing cards' graphics is drawn and aligned in Adobe
    Illustrator. You can download it from [http://mak.la/deck.png](http://mak.la/deck.png).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can create your own sprite sheet with Instant Sprite Generator ([http://instantsprite.com](http://instantsprite.com)).
    The article at [http://css-tricks.com/css-sprites/](http://css-tricks.com/css-sprites/)
    explains in detail why and how we can create and use the CSS sprite sheet.
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading the sprite sheet of playing cards](img/B04290_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the game environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the graphics are ready, we will need to set up a static page with the
    game objects that are prepared and placed on the game area. It is then easier
    to add game logic and interaction later:'
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – preparing the card-matching game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before adding the complicated game logic to our matching game, let''s prepare
    the HTML game structure and all the CSS styles:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our project. Create a new file named `matchgame.js` inside
    the `js` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `index.html` file with the following HTML code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to make the game more appealing, I prepared background images for the
    game table and the page. These graphic assets can be found in the code example
    bundle. The background images are optional, and they will not affect the gameplay
    and the logic of the matching game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will also place the deck's sprite sheet graphics into the images folder.
    Then, we will download the `deck.png` file from [http://mak.la/deck.png](http://mak.la/deck.png)
    and save it within the images folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a dedicated CSS file named `matchgame.css` for our game and put it inside
    the `css` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s add style to the matching game before writing any logic. Open `matchgame.css`
    and add the following body styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue to add the styles to the `game` element. This will be the
    main area of the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will put all card elements into a parent DOM named `cards`. By doing this,
    we can easily center all the cards in the game area:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For each card, we define a `perspective` property to give it a visual depth
    effect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two faces on each card. The back face will be rotated later, and
    we will define the transition properties to animate the style changes. We also
    want to make sure that the back face is hidden:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will set the styles for the front and back faces. They are almost the
    same as the flipping card example, except that we are now giving them background
    images and box shadows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When any card is removed, we want it to fade out. Therefore, we declare a card-removed
    class with 0 opacity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In order to show different playing card graphics from the sprite sheet of the
    card deck, we clip the background of the card into different background positions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have defined a lot of CSS styles. It is now time for JavaScript''s logic.
    We will open the `js/matchgame.js` file and put the following code inside:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we will save all the files and preview the game in the browser. The game
    should be well styled, and 12 cards should appear in the center. However, we cannot
    click on the cards yet because we have not set any interaction logic for the cards.![Time
    for action – preparing the card-matching game](img/B04290_03_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created the game structure in HTML and applied styles to the HTML elements.
    You can find the working example of the game with the current progress at [http://makzan.net/html5-games/card-matching-wip-step1/](http://makzan.net/html5-games/card-matching-wip-step1/).
  prefs: []
  type: TYPE_NORMAL
- en: We also used jQuery to create 12 cards on the game area once the web was loaded
    and ready. The styles to flip and remove the cards were also prepared and will
    be applied to the card by using the game logic later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are using absolute positioning for each card, we need to align the
    cards into 4x3 tiles ourselves. In the JavaScript logic, we loop through each
    card and align it by calculating the position with the looping index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The % character in JavaScript is the **modulus operator** that returns the
    remainder left after division. The remainder is used to get the column count when
    we loop the cards. The following diagram shows the row/column relationship with
    the index number:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The division, on the other hand, is used to get the row count so that we can
    position the card on the corresponding row.
  prefs: []
  type: TYPE_NORMAL
- en: Take index 3 as an example; 3 % 4 is 3\. So, the card at index 3 is on the third
    column. And 3 / 4 is 0, so it is on the first row.
  prefs: []
  type: TYPE_NORMAL
- en: Let's pick another number to see how the formula works. Let's see index 8; 8
    % 4 is 0, and it is on the first column. 8 / 4 is 2 so it is on the third row.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning DOM elements with jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our HTML structure, we only have one card and in the result, we have 12
    cards. This is because we used the `clone` function in jQuery to clone the card
    element. After cloning the target element, we called the `appendTo` function to
    append the cloned card element as a child in the cards element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Selecting the first child of an element in jQuery using child filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we selected the card element and cloned it, we used the following selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `:first-child` filter is a **child filter** that selects the first child
    of the given parent element.
  prefs: []
  type: TYPE_NORMAL
- en: Besides `:first-child`, we can also select the last child by using `:last-child`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also check other child-related selectors on the jQuery document at:
    [http://api.jquery.com/category/selectors/child-filter-selectors/](http://api.jquery.com/category/selectors/child-filter-selectors/).'
  prefs: []
  type: TYPE_NORMAL
- en: Vertically aligning a DOM element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We put the cards DIV in the center of the game element. **CSS3 flexible box
    layout module** introduces an easy method to achieve the **vertical center alignment**,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The flexible box module defines the alignment of the element when there are
    extra spaces in the container. We can set the element to certain behaviors as
    a flexible box container by using the display, a CSS2 property, with the `box`
    value, and a new CSS3 property value.
  prefs: []
  type: TYPE_NORMAL
- en: '`justify-content` and `align-items` are two properties to define how it aligns
    and uses the extra free space horizontally and vertically. We can center the element
    by setting both properties to `center`.'
  prefs: []
  type: TYPE_NORMAL
- en: Vertical alignment is just a small part of the flexible box layout module. It
    is very powerful when you make layouts in web design. You may find further information
    on the W3C page of the module ([http://www.w3.org/TR/css3-flexbox/](http://www.w3.org/TR/css3-flexbox/))
    or the CSS3 tricks website ([http://css-tricks.com/snippets/css/a-guide-to-flexbox/](http://css-tricks.com/snippets/css/a-guide-to-flexbox/)).
  prefs: []
  type: TYPE_NORMAL
- en: Using CSS sprite with a background position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CSS sprite sheet is a big image that contains many individual graphics.
    The big sprite sheet image is applied as the background image for the elements.
    We can clip each graphic out by moving the background position to a fixed width
    and height element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our deck''s image contains a total of 53 graphics. In order to demonstrate
    the background position easily, let''s assume that we have an image that contains
    three card images, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using CSS sprite with a background position](img/B04290_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the CSS style, we set the card element to a width of 80 px and a height
    of 120 px, with the background image set to the big deck image. If we want the
    top-left graphic, we change the values of both the *x* and *y* axes of the background
    position to 0\. If we want the second graphic, we move the background image 80px
    to the left. This means setting the X position to `-80px` and Y to 0\. Since we
    have a fixed width and height, only the clipped 80 x 120 area shows the background
    image. The rectangle in the following screenshot shows the viewable area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using CSS sprite with a background position](img/B04290_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding game logic to the matching game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now imagine holding a real deck in our hand and setting up the matching
    game.
  prefs: []
  type: TYPE_NORMAL
- en: We would first shuffle the cards in our hands and then we would put each card
    on the table with the back facing up. For an easier gameplay, we align the cards
    into a 4 x 3 array. Now, the game is set up and we are going to play it.
  prefs: []
  type: TYPE_NORMAL
- en: We pick up one card and flip it to make it face up. We pick another one and
    face it upwards. Afterwards, we have two possible actions. We take away the two
    cards if they have the same pattern. Otherwise, we put them back facing down,
    as if we had not touched them. The game continues until we pair all of the cards.
  prefs: []
  type: TYPE_NORMAL
- en: The code flow will be much clearer after we have this step-by-step scenario
    in our mind. Actually, the code in this example is exactly the same as the procedure
    we play with a real deck. We just need to replace the human language into the
    JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding game logic to the matching game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have prepared the game environment in the last example and decided the game
    logic should be the same as playing a real deck. It is time to code the JavaScript
    logic now:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's begin from our last matching game example. We have styled the CSS, and
    now, it is time to add the game logic in the `js/matchgame.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The game is to match pairs of playing cards. We have 12 cards now, so we need
    six pairs of playing cards. Put the following code in the `js/matchgame.js` file.
    The array declares six pairs of card patterns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We aligned the cards in jQuery''s `ready` function in the previous chapter.
    Now we need to prepare and initialize more code in the `ready` function. To do
    this, change the `ready` function into the following code. The changed code is
    highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similar to playing a real deck, the first thing we want to do is shuffle the
    deck. To do this, we need to add the following `shuffle` function to the JavaScript
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we click on the card, we flip it and schedule the checking function. So,
    we must append the following codes to the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When two cards are opened, the following function is executed. It controls
    whether we remove the card or flip it back:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is time for the pattern-checking function. The following function accesses
    the custom pattern attribute of the opened cards and compares them to see whether
    they are in the same pattern:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the matched cards fade out, we execute the following function to remove
    the cards:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The game logic is ready now. Let's open the game's HTML file in a browser and
    play. Remember to check the console window in **Developer Tools** to see whether
    there is any error.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the CSS3 Card Matching game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – adding game logic to the matching game](img/B04290_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We coded the game logic of the CSS3 matching game. The logic adds the mouse
    click interaction to the playing cards, and it controls the flow of pattern checking.
    You can try the game and view the full source code at [http://makzan.net/html5-games/card-matching-wip-step2/](http://makzan.net/html5-games/card-matching-wip-step2/).
  prefs: []
  type: TYPE_NORMAL
- en: Executing code after the CSS transition has ended
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We remove the paired cards after playing the fade out transition. We can schedule
    a function to be executed after the transition has ended by using the `transitionend`
    event. The following code snippet from our code example adds a `card-removed`
    class to the paired card to start the transition. Then, it binds the `transitionend`
    event to remove the card complete with the DOM, afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Delaying code execution on flipping cards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game logic flow is designed in the same way as playing a real deck. One
    big difference is that we used several `setTimeout` functions to delay the execution
    of the code. When the second card is clicked, we schedule the `checkPattern` function
    to be executed 0.7 seconds later by using the following code example snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The reason we delay the function call is to give time to the player to memorize
    the card pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Randomizing an array in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no built-in array randomize function in JavaScript. We have to write
    our own. Luckily, we can get help from the built-in array sorting function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage of the `sort` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sort` function takes one optional argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `compare_function` | A function that defines the sort order of the array.
    The `compare_function` requires two arguments. | The `sort` function compares
    two elements in the array by using the `compare` function. Therefore, the `compare`
    function requires two arguments.When the `compare` function returns any value
    that is bigger than 0, it puts the first argument at a lower index than the second
    argument.When the return value is smaller than 0, it puts the second argument
    at a lower index than the first argument. |'
  prefs: []
  type: TYPE_TB
- en: 'The trick here is that we used the `compare` function that returns a random
    number between -0.5 and 0.5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: By returning a random number in the `compare` function, the `sort` function
    sorts the same array in an inconsistent way. In other words, we shuffle the array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following link from the Mozilla Developer Network provides a detailed explanation
    on using the `sort` function with examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/sort)'
  prefs: []
  type: TYPE_NORMAL
- en: Storing internal custom data with an HTML5 custom data attribute
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can store custom data inside the DOM element by using the **custom data attribute**.
    We can create a custom attribute name with the `data-` prefix and assign a value
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can embed custom data to the list elements in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This is a new feature proposed in the HTML5 spec. According to the W3C, the
    custom data attributes are intended to store custom data that is private to a
    page or an application for which there are no more appropriate attributes or elements.
  prefs: []
  type: TYPE_NORMAL
- en: W3C also states that this custom data attribute is "intended for use by the
    site's own script and not a generic extension mechanism for publicly-usable metadata."
  prefs: []
  type: TYPE_NORMAL
- en: We are coding our matching game and embedding our own data to the card elements;
    therefore, custom data attribute fits our usage.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the custom attribute to store the card pattern inside each card so that
    we can check by comparing the pattern value whether the two flipped cards match
    in JavaScript. In addition, the pattern is used to style the playing cards into
    corresponding graphics as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. According to W3C's guidelines about the custom data attribute, which of
    the following statements is true?
  prefs: []
  type: TYPE_NORMAL
- en: We can create a `data-link` attribute to store the link of the `css` tag.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can access the custom data attribute in a third-party game portal website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can store a `data-score` attribute in each player's DOM element to sort the
    ranking in our web page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can create a `ranking` attribute in each player's DOM element to store the
    ranking data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accessing custom data attribute with jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the matching game example, we used the `attr` function from the jQuery library
    to access our custom data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `attr` function returns the value of the given attribute name. For example,
    we can get the links in all the `a` tags by calling the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: For the HTML5 custom data attribute, jQuery provides us with another function
    to access the HTML5 custom data attribute. This is the `data` function.
  prefs: []
  type: TYPE_NORMAL
- en: '`Data` function was designed to embed custom data into the jQuery object of
    the HTML elements. It was designed before the HTML5 custom data attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the usage of the `data` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The `data` function accepts two types of functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function type | Arguments definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.data(key)` | The `key` argument is a string that names the entry of the
    data. | When only the `key` argument is given, the `data` function reads the data
    associated with the jQuery object and returns the corresponding value.In the recent
    jQuery update, this function is extended to support the HTML5 custom data attribute.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `.data(key,` `value)` | `The key` argument is a string that names the entry
    of the data.`The value` argument is the data to be associated with the jQuery
    object. | When both the `key` and `value` arguments are given, the `data` function
    sets a new data entry to the jQuery object.The `value` argument can be any JavaScript
    type, including an array and an object. |'
  prefs: []
  type: TYPE_TB
- en: In order to support the HTML5 custom data attribute, jQuery extends the `data`
    function to let it access the custom data that is defined in the HTML code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we use the `data` function. Consider the following line
    of an HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using the preceding line of code, we can access the `data-custom-name`
    attribute by calling the `data` function in jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This will return "HTML5 Games".
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keep in mind that `attr` would always return a string value. However, the `data`
    method will attempt to convert the HTML string value into a JavaScript value,
    such as a number or a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Given the following HTML code, which jQuery statements read the custom
    score data and return 100 in the integer format?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`$("#game").attr("data-score");`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$("#game").attr("score");`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$("#game").data("data-score");`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$("#game").data("score");`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created the CSS3 matching game. So, what is missing here? The game logic
    does not check whether the game is over. Try adding a "You won!" text when the
    game is over. You can also animate the text by using the techniques that we discussed
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Making other playing card games
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This CSS3 playing card approach is suitable to create card games. There are
    two sides on a card that fit the flipping. The transition feature is suitable
    to move the cards. With both moving and flipping, we can just define the playing
    rule and make the most of the card games.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can you use the playing card graphics and flipping techniques to create another
    game? How about poker?
  prefs: []
  type: TYPE_NORMAL
- en: Embedding web fonts into our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the years, we have been using limited fonts to design web pages. We could
    not use whatever fonts we wanted because the browser loaded the font from the
    visitor's local machine, and we cannot control or ensure that visitors have our
    desired fonts.
  prefs: []
  type: TYPE_NORMAL
- en: Although we can embed **web fonts** to Internet Explorer 5 with a limited type
    format, we have to wait until browser vendors support embedding the most common
    TrueType font format.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we can control the mood of the game by embedding different styles
    of web fonts. We can then design the games with our desired fonts and have more
    control over the appeal of the game. Let's try to embed a web font into our memory
    matching game.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – embedding a font from the Google Fonts directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Google Fonts** directory is a web font service that lists free-to-use web
    fonts. We will embed a web font chosen from the Google Fonts directory:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Google Fonts directory site at [http://google.com/fonts](http://google.com/fonts).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the font directory, there is a list of web fonts that are available under
    an open source license and can be used freely.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose one of them and click on the font name to proceed to the next step. In
    this example, I used **Droid Serif**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you click on a font, the font directory displays detailed information
    about the font. There are several actions that we can carry out here, such as
    preview the font, choose from variants, and most importantly, get the font embedding
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In MAC, click on the **Get the code** tab and you will see the following screenshot;
    this shows a guide on how to embed this font into our web page. Alternatively,
    in Windows, you can click on the **Use** tab and you will find instructions to
    get the code:![Time for action – embedding a font from the Google Fonts directory](img/B04290_03_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the `link` tag provided by Google, and then paste it into the HTML code.
    This should be placed before any other style definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can use the font to style our text. Set the body''s font family property
    as the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all the files and open the `index.html` file. The browser will download
    the font from the Google server and embed it into the web page. Keep an eye on
    the fonts; they should be loaded and rendered as our selected Google font.![Time
    for action – embedding a font from the Google Fonts directory](img/B04290_03_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just styled our game with an uncommon web font. The font is hosted and
    delivered through the Google Fonts directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides using the font directory, we can embed our font file by using `@font
    face`. The following link provides a bulletproof approach to embed a font ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax](http://www.fontspring.com/blog/the-new-bulletproof-font-face-syntax)'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Check the font license before embedding**'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the font license does not cover its usage on web pages. Be sure to
    check the license before embedding the font. All the fonts listed in the Google
    Fonts directory are licensed under the open source license and can be used on
    any website. You can check the license of individual fonts listed in the directory
    at [https://www.google.com/fonts/attribution](https://www.google.com/fonts/attribution).
  prefs: []
  type: TYPE_NORMAL
- en: Choosing different font delivery services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google Fonts directory is just one of the font delivery services. Typekit ([http://typekit.com](http://typekit.com))
    and Fontdeck ([http://fontdeck.com](http://fontdeck.com)) are two other font services
    that provide hundreds of high quality fonts via yearly subscription plans.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about using different new properties of CSS3 to
    create games.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we covered how you can build a card game that is based on CSS3
    styles and animation. You learned how to transform and animate the game object
    by using the transition module. We can flip a card back and forth with perspective
    depth illusion. We also embedded web fonts from an online font delivery service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you've learned about creating DOM-based HTML5 games with the help of
    CSS3 features, we are going to explore another approach—using the new `canvas`
    tag and the drawing API—to create HTML5 games in the next chapter.
  prefs: []
  type: TYPE_NORMAL
