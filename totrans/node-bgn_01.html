<html><head></head><body>
		<div><h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/> Introduction to Node.js</h1>
			<p>Welcome to the first chapter of the book! Node.js is one of the most relevant technologies available and allows you to build any kind of project (web, desktop, CLI tools, microservices, IoT, and so on) within the same stack. The community around the project is very powerful and innovative.</p>
			<p>In this chapter, we will explore the main features of Node.js and why it became so popular over time. Then, we will explore the Node.js architecture and how it works. Finally, we will explore the different versions of Node.js available to us.</p>
			<p>In this chapter, we’re going to cover the following main topics:</p>
			<ul>
				<li>What makes Node.js so special and why it is a revolutionary technology</li>
				<li>The Node.js architecture and how it works</li>
				<li>How to identify the right Node.js version for your projects</li>
			</ul>
			<p>This knowledge will help you to decide when it is a good fit for your projects and will guide you around the complex ecosystem.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>The code files for the chapter can be found at <a href="https://github.com/PacktPublishing/NodeJS-for-Beginners">https://github.com/PacktPublishing/NodeJS-for-Beginners</a>.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Why is Node.js so popular?</h1>
			<p>The <a id="_idIndexMarker000"/>official definition of Node.js is very simple, but it doesn’t explain why Node.js has <a id="_idIndexMarker001"/>become so popular over time:</p>
			<p class="author-quote"><em class="italic">“</em>Node.js® is an open-source, cross-platform JavaScript runtime environment.<em class="italic">”</em></p>
			<p>In <em class="italic">Figure 1</em><em class="italic">.1</em>, we can see how the popularity of Node.js has been increasing over time, and even today, it is<a id="_idIndexMarker002"/> still growing fast.</p>
			<div><div><img src="img/B21678_01_01.jpg" alt="Figure 1.1 – The interest in Node.js, generated using Google Trends"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The interest in Node.js, generated using Google Trends</p>
			<p>Next, let’s explore the main reasons why Node.js is so popular.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Lightweight and fast</h2>
			<p>Node.js is a <a id="_idIndexMarker003"/>lightweight and fast runtime based on the V8 JavaScript engine, which is the same engine that powers Google Chrome and Microsoft Edge, among others. It is based on a single-thread architecture and event-driven model, which means that it doesn’t need to create a new thread for each request, as in other popular tools such as PHP. This is a huge advantage because the memory consumption is very low and the performance is very high.</p>
			<p>We will explore the single-thread architecture in detail in the upcoming sections.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Cross-platform and multi-purpose</h2>
			<p>Node.js is cross-platform, which means that we can run it on any operating system and architecture available in the modern market.</p>
			<p>Node.js is not only used to build web applications but it can also be used to build any kind of <a id="_idIndexMarker004"/>application, from a simple command-line tool to a complex desktop application such as Slack or Visual Studio Code.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Easy learning curve</h2>
			<p>Node.js is based on JavaScript, which is one of the most popular programming languages in the world. This means that millions of developers already know the language and they can easily start using Node.js.</p>
			<p class="author-quote">Any application that can be written in JavaScript, will eventually be written in JavaScript.</p>
			<p class="author-quote">– Jeff Atwood (Atwood’s Law)</p>
			<p>Also, the <a id="_idIndexMarker005"/>Node.js <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) – the methods, libraries, and utilities that Node.js provides for us to use – is very simple and easy to use, so the learning curve is very small. You don’t need to master the Node.js API to start building web applications; you can progressively learn while you are building your application.</p>
			<p>There are a lot of resources available to learn Node.js, from official documentation to online courses and tutorials in many languages and oriented to different profiles.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Ecosystem</h2>
			<p>Node.js has a huge ecosystem of packages, JavaScript libraries, and resources developed by the community that can be used to build any kind of application. There are more than two and a half million packages available in<a id="_idTextAnchor023"/> the<a id="_idIndexMarker006"/> npm Registry (<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>), which is the official package manager for Node.js.</p>
			<p>Also, Node.js has huge support from cloud providers, which means that you can easily deploy your application to the cloud and scale it as much as you need.</p>
			<p>Most of the emerging technologies <a id="_idIndexMarker007"/>provide <strong class="bold">software development kits</strong> (<strong class="bold">SDKs</strong>) for Node.js, so you can easily integrate your application with them. Many companies are using Node.js in production, so you can easily find support and resources to solve any problem that you may have.</p>
			<p>Also, many popular libraries are isomorphic, which means that they can be used in the browser and in the server, so you can reuse your code and avoid duplications.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Community-powered</h2>
			<p>For me, the most <a id="_idIndexMarker008"/>important reason why Node.js is so popular is the community. Node.js has a huge community of developers that are constantly contributing to the project. This means that you can easily find support and resources to solve any problem that you may have and also to include new features or solve specific bugs.</p>
			<p>The Node.js Foundation merged with the JS Foundation in 2019 to create the <a id="_idIndexMarker009"/>OpenJS Foundation <a href="https://openjsf.org/">https://openjsf.org/</a>, which is the current organization that governs the Node.js project and other key projects in the JavaScript ecosystem, such as Appium, jQuery, Electron, Express, and webpack.</p>
			<p class="callout-heading">Important information</p>
			<p class="callout">You can find the governance model of the OpenJS Foundation at <a href="https://openjsf.org/about/governance/">https://openjsf.org/about/governance/</a> and the Node.js project at <a href="https://nodejs.org/en/about/governance">https://nodejs.org/en/about/governance</a>.</p>
			<p>Many companies are members of the OpenJS Foundation, such as Google, IBM, Microsoft, Netflix, Red Hat, GitHub, and many others (<a href="https://openjsf.org/about/members/">https://openjsf.org/about/members/</a>). These provide a lot of support and resources to keep the project alive.</p>
			<p>As you can see, many factors are helping Node.js to become so popular, from a proven community-powered model to a solid ecosystem that brings many capabilities to Node.js. It appears that Node.js will remain popular in the future!</p>
			<p>In the next section, we will explore how the architecture works under the hood.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/>The Node.js single-thread architecture</h1>
			<p>When <a id="_idIndexMarker010"/>Node.js came out in 2009, it was a revolution in the web development world, as Ryan Dahl, the creator of Node.js, decided to use a very unusual approach at that time: a single-thread architecture.</p>
			<p>In his presentation about Node.js at the JSConf (<a href="https://www.youtube.com/watch?v=EeYvFl7li9E">https://www.youtube.com/watch?v=EeYvFl7li9E</a>), Ryan Dahl said he wanted to achieve two key things when building Node.js: server-side JavaScript and non-blocking I/O.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>I/O needs to be done differently</h2>
			<p>The<a id="_idIndexMarker011"/> common approach for I/O operations in web applications is to create a new thread for each request. This is a very expensive operation because the memory consumption is very high and the performance is very low.</p>
			<p>The idea behind this approach is to split the system resources and assign them to each thread. This is a very inefficient approach because, most of the time, the CPUs are idle, just waiting for the resources.</p>
			<p>The other problem is that we are limited in the amount of memory that we can use because each thread needs to have its own memory space.</p>
			<p>Overall, this process was very inefficient, and it was not scalable.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Non-blocking I/O</h2>
			<p>With Node.js, we use a <a id="_idIndexMarker012"/>different approach. We won’t split the resources; we keep a single thread and use a non-blocking I/O model that allows us to free the resources while waiting, so we can continue processing requests.</p>
			<p>To make this<a id="_idIndexMarker013"/> possible, Node.js has two <a id="_idIndexMarker014"/>key dependencies: libuv (<a href="https://libuv.org/">https://libuv.org/</a>) and V8 (<a href="https://v8.dev/">https://v8.dev/</a>).</p>
			<div><div><img src="img/B21678_01_02.jpg" alt="Figure 1.2 – Diagram that showcase the relationship between the user code, v8, Node API and libuv (event queue and worker threads)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Diagram that showcase the relationship between the user code, v8, Node API and libuv (event queue and worker threads)</p>
			<p>As you <a id="_idIndexMarker015"/>can see, the architecture has many pieces and it can be a bit overwhelming at first. This diagram is not the full picture but it is a good starting point to understand how Node.js works in the context of this chapter. There are many pieces to understand from this figure, so let’s go step by step.</p>
			<h3>Node.js application</h3>
			<p>This is<a id="_idIndexMarker016"/> the code that we write to build our application. It will be done in JavaScript and it can use Node.js APIs and third-party libraries.</p>
			<h3>V8</h3>
			<p>This is the <a id="_idIndexMarker017"/>engine encapsulated in Node.js that will execute our JavaScript code. V8 is the same engine that is used in the Chrome browser under the hood.</p>
			<h3>Node.js bindings</h3>
			<p>It is<a id="_idIndexMarker018"/> surprising for many developers to see that Node.js is written mostly in C/C++, but this is one of the reasons why Node.js is so fast. The Node.js bindings are the C/C++ code that will be executed when we use the Node.js APIs<a id="_idTextAnchor028"/> under the hood.</p>
			<h3>libuv</h3>
			<p>This is the<a id="_idIndexMarker019"/> C library that will handle the I/O operations with multi-platform support. It will use the thread pool to execute the blocking operations and it will notify the Node.js bindings when the operation is completed. We will program Node.js defining functions that will be executed when certain async operations are completed. For example, when we try to read the content from a file, we will execute certain code when the content is available. libuv handles the low-level logic for this coordination to happen.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>Going deeper into the event loop</h2>
			<p>The<a id="_idIndexMarker020"/> event loop is the most critical part of the Node.js architecture. Keeping this in mind will help you to understand how Node.js works.</p>
			<p>As we have seen <a id="_idIndexMarker021"/>before, the new I/O operations approach is not magic, just a very smart way to handle and abstract using an asynchronous layer that is easily handled with JavaScript. This introduces the need for us to know how to do asynchronous programming. We will cover this topic in more detail in <a href="B21678_04.xhtml#_idTextAnchor132"><em class="italic">Chapter 4</em></a>, but for now, we need to understand how the event loop works.</p>
			<p>One fantastic resource to understand the event loop in more depth is this talk from Philip Roberts at JSConf EU 2014: <em class="italic">What the heck is the event loop anyway?</em> (<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a>). It also includes a tool called Loupe (<a href="http://latentflip.com/loupe">http://latentflip.com/loupe</a>) to <a id="_idIndexMarker022"/>experiment with the event loop architecture yourself.</p>
			<p>As you can see, Node.js is the product of combining several technologies. The event loop is quite an advanced topic that you will require some time to digest and understand fully, but don’t worry, as you can start working with Node.js even if you are not yet 100% clear on how the event loop and all the pieces work together. You will be able to learn about it better in practice with the exercises from the book. Now, let’s explore how Node.js organizes the versions.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Node.js versions</h1>
			<p>Node.js <a id="_idIndexMarker023"/>follows <strong class="bold">semantic versioning</strong> (<strong class="bold">SemVer</strong>) (<a href="https://semver.org/">https://semver.org/</a>) and it is <a id="_idIndexMarker024"/>important to understand how this versioning works in order to choose the best version for the project.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>Semantic versioning (SemVer)</h2>
			<p>When <a id="_idIndexMarker025"/>considering <a id="_idIndexMarker026"/>semantic versioning, it helps to determine what changes to anticipate as a user, especially whether they might cause disruptions or not. This understanding assists our end users in preparing for potential updates.</p>
			<p>Semantic versioning is one of the most popular ways to version software. In the following figure, we can differentiate the elements used to build the release version.</p>
			<div><div><img src="img/B21678_01_03.jpg" alt="Figure 1.3 – Parts of a semantic version number (source: Devopedia 2020, https://devopedia.org/images/article/279/2766.1593275997.svg)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Parts of a semantic version number (source: Devopedia 2020, <a href="https://devopedia.org/images/article/279/2766.1593275997.svg">https://devopedia.org/images/article/279/2766.1593275997.svg</a>)</p>
			<p>When a new version is released, the version number is incremented following the SemVer rules:</p>
			<ul>
				<li><strong class="bold">Major</strong> versions <a id="_idIndexMarker027"/>add incompatible API changes</li>
				<li><strong class="bold">Minor</strong> versions <a id="_idIndexMarker028"/>add functionality in a backward-compatible manner</li>
				<li><strong class="bold">Patch</strong> versions <a id="_idIndexMarker029"/>add backward-compatible bug fixes</li>
			</ul>
			<p>Following these rules, we can easily upgrade the Node.js version in any project without breaking the code when the changes are cataloged as minor or a patch.</p>
			<p>If we want to upgrade to a new major version, we will need to check whether there are any breaking changes that we need to address before upgrading. In most cases, the breaking changes are not related to our own code but to the dependencies that we are using in the project.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Metadata</strong> is <a id="_idIndexMarker030"/>optional, and it is not used to define the version of the software but provides additional information. In general, we will try to avoid using versions with metadata as they are not stable versions but they can be used for testing purposes.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>Release details</h2>
			<p>Before we move<a id="_idIndexMarker031"/> on to the release schedule, it is important to understand how we can check the details of any release. This is very important if we plan to upgrade to a major version, as it contains breaking changes.</p>
			<p>In this case, we will analyze the Node.js 20.0.0 release, so we can see the details of the latest LTS version through the blog details: <a href="https://nodejs.org/en/blog/release/v20.0.0/">https://nodejs.org/en/blog/release/v20.0.0/</a>.</p>
			<p>Every release has a structured blog post with the following information:</p>
			<ul>
				<li><strong class="bold">Summary</strong>: Here, we can find a brief description of the release.</li>
				<li><strong class="bold">Notable Changes</strong>: Here, we can find the most important changes in the release, including examples and a lot of contexts behind the new features or deprecations. We can also see the more relevant changes in the dependencies that may affect the Node.js APIs.</li>
				<li><strong class="bold">Semver-(*) Commits</strong>: Here, we can find the commits that are related to the SemVer changes (<strong class="bold">Semver-Major Commits</strong>, <strong class="bold">Semver-Minor Commits</strong>, and <strong class="bold">Semver-Patch Commits</strong>) and access the code changes directly using the <em class="italic">commits</em> reference.</li>
			</ul>
			<p class="callout-heading">Information</p>
			<p class="callout">The release information is available directly in the changelog. The changelog version includes references to all the commits and pull requests included in the release, so it is a great source of information when you need to migrate from another Node.js version. You can find the changelog version at <a href="https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V20.md#2023-04-18-version-2000-current-rafaelgss">https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V20.md#2023-04-18-version-2000-current-rafaelgss</a>.</p>
			<p>One of the best ways to explore the change in a release in more detail is to directly use the Node.js documentation – for example, <a href="https://nodejs.org/dist/latest-v20.x/docs/api/">https://nodejs.org/dist/latest-v20.x/docs/api/</a>. The website offers the option to navigate through the different versions so we can<a id="_idIndexMarker032"/> check the changes in the APIs between versions more easily.</p>
			<div><div><img src="img/B21678_01_04.jpg" alt="Figure 1.4 – Node.js official documentation screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Node.js official documentation screenshot</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor033"/>Release schedule</h2>
			<p>The <a id="_idIndexMarker033"/>Node.js project has a release schedule that is published on the official website (<a href="https://nodejs.org/en/about/releases/">https://nodejs.org/en/about/releases/</a>) and it is updated by the Node.js Release Working Group.</p>
			<p class="IMG---Figure"> </p>
			<div><div><img src="img/B21678_01_05.jpg" alt="Figure 1.5 – Official release schedule from the Node.js website"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Official release schedule from the Node.js website</p>
			<p>In Node.js, releases <a id="_idIndexMarker034"/>have three different phases:</p>
			<ul>
				<li><strong class="bold">Current</strong> is the <a id="_idIndexMarker035"/>phase where new features (non-major changes) are added to the project. This phase is very active, and it is not always recommended to use it in production as it is not a stable version.</li>
				<li><strong class="bold">Active Long-Term Support</strong> (<strong class="bold">LTS</strong>) is the phase where the version is stable and has <a id="_idIndexMarker036"/>been updated by the LTS team. This phase still includes new features, bug fixes, and updates. This phase is stable, so it is recommended to use it in production.</li>
				<li><strong class="bold">Maintenance</strong> is the <a id="_idIndexMarker037"/>phase where the version is not receiving any new features, only critical bug fixes and security updates. This phase is recommended for projects that are not able to upgrade yet to the latest active LTS version.</li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">Odd-numbered release lines are not promoted to active LTS, so they are not recommended for production use.</p>
			<p>As of today, for any new project, I will recommend using the latest LTS version, which is 20.11.0. This version will be supported until April 2026, so it is a good choice for any new project.</p>
			<p>For any<a id="_idIndexMarker038"/> existing project using Node.js v18, it is recommended to start migrating to Node.js 20 as v18 is entering the <em class="italic">maintenance</em> phase.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">While releasing a new version seems like an easy task, it is not. The Release Working Group has defined the complete process, which includes more than 20 steps. You can find all the relevant information in the official documentation (<a href="https://github.com/nodejs/node/blob/main/doc/contributing/releases.md">https://github.com/nodejs/node/blob/main/doc/contributing/releases.md</a>) or this talk: <em class="italic">The Life and Times of a Node.js Release</em>, by Danielle Adams at NodeConf EU 2022 (<a href="https://www.youtube.com/watch?v=OiSBodpU174">https://www.youtube.com/watch?v=OiSBodpU174</a>).</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>Summary</h1>
			<p>In this chapter, we explored what makes Node.js so special and how it differs from other backend systems. We also covered the history of Node.js and how it has evolved over the years.</p>
			<p>Additionally, we covered the Node.js architecture and how it works under the hood. We learned about the event loop and how it allows Node.js to handle many concurrent requests efficiently.</p>
			<p>In the next chapter, we will learn how to set up the development environment and start using Node.js.</p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor035"/>Further reading</h1>
			<ul>
				<li>Node.js governance: <a href="https://nodejs.org/en/about/governance">https://nodejs.org/en/about/governance</a></li>
				<li>OpenJS Foundation governance: <a href="https://openjsf.org/about/governance/">https://openjsf.org/about/governance/</a></li>
				<li><em class="italic">The Life and Times of a Node.js Release</em>, by Danielle Adams at NodeConf EU 2022: <a href="https://www.youtube.com/watch?v=OiSBodpU174">https://www.youtube.com/watch?v=OiSBodpU174</a></li>
				<li>Node.js dependencies: <a href="https://github.com/nodejs/node/blob/main/doc/contributing/maintaining/maintaining-dependencies.md">https://github.com/nodejs/node/blob/main/doc/contributing/maintaining/maintaining-dependencies.md</a></li>
				<li>Node.js event loop architecture: <a href="https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4">https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4</a></li>
				<li><em class="italic">How Node.js Bootstraps Itself</em>, 2019 edition, Joyee Cheung, Igalia: <a href="https://www.youtube.com/watch?v=bwiLlcGvFEk">https://www.youtube.com/watch?v=bwiLlcGvFEk</a></li>
				<li><em class="italic">Node.js 12: A Decade of Node.js</em>, Beth Griggs, IBM: <a href="https://www.youtube.com/watch?v=HP4N0u_dEgI">https://www.youtube.com/watch?v=HP4N0u_dEgI</a></li>
				<li><em class="italic">Node.js 2023 Year in An </em><em class="italic">Article</em>: <a href="https://blog.rafaelgss.dev/nodejs-2023-year-in-review">https://blog.rafaelgss.dev/nodejs-2023-year-in-review</a></li>
			</ul>
		</div>
	</body></html>