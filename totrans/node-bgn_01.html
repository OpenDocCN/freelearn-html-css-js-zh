<html><head></head><body>
		<div id="_idContainer012">
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/> Introduction to Node.js</h1>
			<p>Welcome to the first chapter of the book! Node.js is one of the most relevant technologies available and allows you to build any kind of project (web, desktop, CLI tools, microservices, IoT, and so on) within the same stack. The community around the project is very powerful <span class="No-Break">and innovative.</span></p>
			<p>In this chapter, we will explore the main features of Node.js and why it became so popular over time. Then, we will explore the Node.js architecture and how it works. Finally, we will explore the different versions of Node.js available <span class="No-Break">to us.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>What makes Node.js so special and why it is a <span class="No-Break">revolutionary technology</span></li>
				<li>The Node.js architecture and how <span class="No-Break">it works</span></li>
				<li>How to identify the right Node.js version for <span class="No-Break">your projects</span></li>
			</ul>
			<p>This knowledge will help you to decide when it is a good fit for your projects and will guide you around the <span class="No-Break">complex ecosystem.</span></p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>The code files for the chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/NodeJS-for-Beginners"><span class="No-Break">https://github.com/PacktPublishing/NodeJS-for-Beginners</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Why is Node.js so popular?</h1>
			<p>The <a id="_idIndexMarker000"/>official definition of Node.js is very simple, but it doesn’t explain why Node.js has <a id="_idIndexMarker001"/>become so popular <span class="No-Break">over time:</span></p>
			<p class="author-quote"><em class="italic">“</em>Node.js® is an open-source, cross-platform JavaScript runtime environment.<em class="italic">”</em></p>
			<p>In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em>, we can see how the popularity of Node.js has been increasing over time, and even today, it is<a id="_idIndexMarker002"/> still <span class="No-Break">growing fast.</span></p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B21678_01_01.jpg" alt="Figure 1.1 – The interest in Node.js, generated using Google Trends"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – The interest in Node.js, generated using Google Trends</p>
			<p>Next, let’s explore the main reasons why Node.js is <span class="No-Break">so popular.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Lightweight and fast</h2>
			<p>Node.js is a <a id="_idIndexMarker003"/>lightweight and fast runtime based on the V8 JavaScript engine, which is the same engine that powers Google Chrome and Microsoft Edge, among others. It is based on a single-thread architecture and event-driven model, which means that it doesn’t need to create a new thread for each request, as in other popular tools such as PHP. This is a huge advantage because the memory consumption is very low and the performance is <span class="No-Break">very high.</span></p>
			<p>We will explore the single-thread architecture in detail in the <span class="No-Break">upcoming sections.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Cross-platform and multi-purpose</h2>
			<p>Node.js is cross-platform, which means that we can run it on any operating system and architecture available in the <span class="No-Break">modern market.</span></p>
			<p>Node.js is not only used to build web applications but it can also be used to build any kind of <a id="_idIndexMarker004"/>application, from a simple command-line tool to a complex desktop application such as Slack or Visual <span class="No-Break">Studio Code.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Easy learning curve</h2>
			<p>Node.js is based on JavaScript, which is one of the most popular programming languages in the world. This means that millions of developers already know the language and they can easily start <span class="No-Break">using Node.js.</span></p>
			<p class="author-quote">Any application that can be written in JavaScript, will eventually be written in JavaScript.</p>
			<p class="author-quote">– Jeff Atwood (Atwood’s Law)</p>
			<p>Also, the <a id="_idIndexMarker005"/>Node.js <strong class="bold">application programming interface</strong> (<strong class="bold">API</strong>) – the methods, libraries, and utilities that Node.js provides for us to use – is very simple and easy to use, so the learning curve is very small. You don’t need to master the Node.js API to start building web applications; you can progressively learn while you are building <span class="No-Break">your application.</span></p>
			<p>There are a lot of resources available to learn Node.js, from official documentation to online courses and tutorials in many languages and oriented to <span class="No-Break">different profiles.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Ecosystem</h2>
			<p>Node.js has a huge ecosystem of packages, JavaScript libraries, and resources developed by the community that can be used to build any kind of application. There are more than two and a half million packages available in<a id="_idTextAnchor023"/> the<a id="_idIndexMarker006"/> npm Registry (<a href="https://www.npmjs.com/">https://www.npmjs.com/</a>), which is the official package manager <span class="No-Break">for Node.js.</span></p>
			<p>Also, Node.js has huge support from cloud providers, which means that you can easily deploy your application to the cloud and scale it as much as <span class="No-Break">you need.</span></p>
			<p>Most of the emerging technologies <a id="_idIndexMarker007"/>provide <strong class="bold">software development kits</strong> (<strong class="bold">SDKs</strong>) for Node.js, so you can easily integrate your application with them. Many companies are using Node.js in production, so you can easily find support and resources to solve any problem that you <span class="No-Break">may have.</span></p>
			<p>Also, many popular libraries are isomorphic, which means that they can be used in the browser and in the server, so you can reuse your code and <span class="No-Break">avoid duplications.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor024"/>Community-powered</h2>
			<p>For me, the most <a id="_idIndexMarker008"/>important reason why Node.js is so popular is the community. Node.js has a huge community of developers that are constantly contributing to the project. This means that you can easily find support and resources to solve any problem that you may have and also to include new features or solve <span class="No-Break">specific bugs.</span></p>
			<p>The Node.js Foundation merged with the JS Foundation in 2019 to create the <a id="_idIndexMarker009"/>OpenJS Foundation <a href="https://openjsf.org/">https://openjsf.org/</a>, which is the current organization that governs the Node.js project and other key projects in the JavaScript ecosystem, such as Appium, jQuery, Electron, Express, <span class="No-Break">and webpack.</span></p>
			<p class="callout-heading">Important information</p>
			<p class="callout">You can find the governance model of the OpenJS Foundation at <a href="https://openjsf.org/about/governance/">https://openjsf.org/about/governance/</a> and the Node.js project <span class="No-Break">at </span><a href="https://nodejs.org/en/about/governance"><span class="No-Break">https://nodejs.org/en/about/governance</span></a><span class="No-Break">.</span></p>
			<p>Many companies are members of the OpenJS Foundation, such as Google, IBM, Microsoft, Netflix, Red Hat, GitHub, and many others (<a href="https://openjsf.org/about/members/">https://openjsf.org/about/members/</a>). These provide a lot of support and resources to keep the <span class="No-Break">project alive.</span></p>
			<p>As you can see, many factors are helping Node.js to become so popular, from a proven community-powered model to a solid ecosystem that brings many capabilities to Node.js. It appears that Node.js will remain popular in <span class="No-Break">the future!</span></p>
			<p>In the next section, we will explore how the architecture works under <span class="No-Break">the hood.</span></p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/>The Node.js single-thread architecture</h1>
			<p>When <a id="_idIndexMarker010"/>Node.js came out in 2009, it was a revolution in the web development world, as Ryan Dahl, the creator of Node.js, decided to use a very unusual approach at that time: a <span class="No-Break">single-thread architecture.</span></p>
			<p>In his presentation about Node.js at the JSConf (<a href="https://www.youtube.com/watch?v=EeYvFl7li9E">https://www.youtube.com/watch?v=EeYvFl7li9E</a>), Ryan Dahl said he wanted to achieve two key things when building Node.js: server-side JavaScript and <span class="No-Break">non-blocking I/O.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor026"/>I/O needs to be done differently</h2>
			<p>The<a id="_idIndexMarker011"/> common approach for I/O operations in web applications is to create a new thread for each request. This is a very expensive operation because the memory consumption is very high and the performance is <span class="No-Break">very low.</span></p>
			<p>The idea behind this approach is to split the system resources and assign them to each thread. This is a very inefficient approach because, most of the time, the CPUs are idle, just waiting for <span class="No-Break">the resources.</span></p>
			<p>The other problem is that we are limited in the amount of memory that we can use because each thread needs to have its own <span class="No-Break">memory space.</span></p>
			<p>Overall, this process was very inefficient, and it was <span class="No-Break">not scalable.</span></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor027"/>Non-blocking I/O</h2>
			<p>With Node.js, we use a <a id="_idIndexMarker012"/>different approach. We won’t split the resources; we keep a single thread and use a non-blocking I/O model that allows us to free the resources while waiting, so we can continue <span class="No-Break">processing requests.</span></p>
			<p>To make this<a id="_idIndexMarker013"/> possible, Node.js has two <a id="_idIndexMarker014"/>key dependencies: libuv (<a href="https://libuv.org/">https://libuv.org/</a>) and <span class="No-Break">V8 (</span><a href="https://v8.dev/"><span class="No-Break">https://v8.dev/</span></a><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B21678_01_02.jpg" alt="Figure 1.2 – Diagram that showcase the relationship between the user code, v8, Node API and libuv (event queue and worker threads)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Diagram that showcase the relationship between the user code, v8, Node API and libuv (event queue and worker threads)</p>
			<p>As you <a id="_idIndexMarker015"/>can see, the architecture has many pieces and it can be a bit overwhelming at first. This diagram is not the full picture but it is a good starting point to understand how Node.js works in the context of this chapter. There are many pieces to understand from this figure, so let’s go step <span class="No-Break">by step.</span></p>
			<h3>Node.js application</h3>
			<p>This is<a id="_idIndexMarker016"/> the code that we write to build our application. It will be done in JavaScript and it can use Node.js APIs and <span class="No-Break">third-party libraries.</span></p>
			<h3>V8</h3>
			<p>This is the <a id="_idIndexMarker017"/>engine encapsulated in Node.js that will execute our JavaScript code. V8 is the same engine that is used in the Chrome browser under <span class="No-Break">the hood.</span></p>
			<h3>Node.js bindings</h3>
			<p>It is<a id="_idIndexMarker018"/> surprising for many developers to see that Node.js is written mostly in C/C++, but this is one of the reasons why Node.js is so fast. The Node.js bindings are the C/C++ code that will be executed when we use the Node.js APIs<a id="_idTextAnchor028"/> under <span class="No-Break">the hood.</span></p>
			<h3>libuv</h3>
			<p>This is the<a id="_idIndexMarker019"/> C library that will handle the I/O operations with multi-platform support. It will use the thread pool to execute the blocking operations and it will notify the Node.js bindings when the operation is completed. We will program Node.js defining functions that will be executed when certain async operations are completed. For example, when we try to read the content from a file, we will execute certain code when the content is available. libuv handles the low-level logic for this coordination <span class="No-Break">to happen.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor029"/>Going deeper into the event loop</h2>
			<p>The<a id="_idIndexMarker020"/> event loop is the most critical part of the Node.js architecture. Keeping this in mind will help you to understand how <span class="No-Break">Node.js works.</span></p>
			<p>As we have seen <a id="_idIndexMarker021"/>before, the new I/O operations approach is not magic, just a very smart way to handle and abstract using an asynchronous layer that is easily handled with JavaScript. This introduces the need for us to know how to do asynchronous programming. We will cover this topic in more detail in <a href="B21678_04.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, but for now, we need to understand how the event <span class="No-Break">loop works.</span></p>
			<p>One fantastic resource to understand the event loop in more depth is this talk from Philip Roberts at JSConf EU 2014: <em class="italic">What the heck is the event loop anyway?</em> (<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">https://www.youtube.com/watch?v=8aGhZQkoFbQ</a>). It also includes a tool called Loupe (<a href="http://latentflip.com/loupe">http://latentflip.com/loupe</a>) to <a id="_idIndexMarker022"/>experiment with the event loop <span class="No-Break">architecture yourself.</span></p>
			<p>As you can see, Node.js is the product of combining several technologies. The event loop is quite an advanced topic that you will require some time to digest and understand fully, but don’t worry, as you can start working with Node.js even if you are not yet 100% clear on how the event loop and all the pieces work together. You will be able to learn about it better in practice with the exercises from the book. Now, let’s explore how Node.js organizes <span class="No-Break">the versions.</span></p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor030"/>Node.js versions</h1>
			<p>Node.js <a id="_idIndexMarker023"/>follows <strong class="bold">semantic versioning</strong> (<strong class="bold">SemVer</strong>) (<a href="https://semver.org/">https://semver.org/</a>) and it is <a id="_idIndexMarker024"/>important to understand how this versioning works in order to choose the best version for <span class="No-Break">the project.</span></p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor031"/>Semantic versioning (SemVer)</h2>
			<p>When <a id="_idIndexMarker025"/>considering <a id="_idIndexMarker026"/>semantic versioning, it helps to determine what changes to anticipate as a user, especially whether they might cause disruptions or not. This understanding assists our end users in preparing for <span class="No-Break">potential updates.</span></p>
			<p>Semantic versioning is one of the most popular ways to version software. In the following figure, we can differentiate the elements used to build the <span class="No-Break">release version.</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B21678_01_03.jpg" alt="Figure 1.3 – Parts of a semantic version number (source: Devopedia 2020, https://devopedia.org/images/article/279/2766.1593275997.svg)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Parts of a semantic version number (source: Devopedia 2020, <a href="https://devopedia.org/images/article/279/2766.1593275997.svg">https://devopedia.org/images/article/279/2766.1593275997.svg</a>)</p>
			<p>When a new version is released, the version number is incremented following the <span class="No-Break">SemVer rules:</span></p>
			<ul>
				<li><strong class="bold">Major</strong> versions <a id="_idIndexMarker027"/>add incompatible <span class="No-Break">API changes</span></li>
				<li><strong class="bold">Minor</strong> versions <a id="_idIndexMarker028"/>add functionality in a <span class="No-Break">backward-compatible manner</span></li>
				<li><strong class="bold">Patch</strong> versions <a id="_idIndexMarker029"/>add backward-compatible <span class="No-Break">bug fixes</span></li>
			</ul>
			<p>Following these rules, we can easily upgrade the Node.js version in any project without breaking the code when the changes are cataloged as minor or <span class="No-Break">a patch.</span></p>
			<p>If we want to upgrade to a new major version, we will need to check whether there are any breaking changes that we need to address before upgrading. In most cases, the breaking changes are not related to our own code but to the dependencies that we are using in <span class="No-Break">the project.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout"><strong class="bold">Metadata</strong> is <a id="_idIndexMarker030"/>optional, and it is not used to define the version of the software but provides additional information. In general, we will try to avoid using versions with metadata as they are not stable versions but they can be used for <span class="No-Break">testing purposes.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor032"/>Release details</h2>
			<p>Before we move<a id="_idIndexMarker031"/> on to the release schedule, it is important to understand how we can check the details of any release. This is very important if we plan to upgrade to a major version, as it contains <span class="No-Break">breaking changes.</span></p>
			<p>In this case, we will analyze the Node.js 20.0.0 release, so we can see the details of the latest LTS version through the blog <span class="No-Break">details: </span><a href="https://nodejs.org/en/blog/release/v20.0.0/"><span class="No-Break">https://nodejs.org/en/blog/release/v20.0.0/</span></a><span class="No-Break">.</span></p>
			<p>Every release has a structured blog post with the <span class="No-Break">following information:</span></p>
			<ul>
				<li><strong class="bold">Summary</strong>: Here, we can find a brief description of <span class="No-Break">the release.</span></li>
				<li><strong class="bold">Notable Changes</strong>: Here, we can find the most important changes in the release, including examples and a lot of contexts behind the new features or deprecations. We can also see the more relevant changes in the dependencies that may affect the <span class="No-Break">Node.js APIs.</span></li>
				<li><strong class="bold">Semver-(*) Commits</strong>: Here, we can find the commits that are related to the SemVer changes (<strong class="bold">Semver-Major Commits</strong>, <strong class="bold">Semver-Minor Commits</strong>, and <strong class="bold">Semver-Patch Commits</strong>) and access the code changes directly using the <span class="No-Break"><em class="italic">commits</em></span><span class="No-Break"> reference.</span></li>
			</ul>
			<p class="callout-heading">Information</p>
			<p class="callout">The release information is available directly in the changelog. The changelog version includes references to all the commits and pull requests included in the release, so it is a great source of information when you need to migrate from another Node.js version. You can find the changelog version <span class="No-Break">at </span><a href="https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V20.md#2023-04-18-version-2000-current-rafaelgss"><span class="No-Break">https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V20.md#2023-04-18-version-2000-current-rafaelgss</span></a><span class="No-Break">.</span></p>
			<p>One of the best ways to explore the change in a release in more detail is to directly use the Node.js documentation – for example, <a href="https://nodejs.org/dist/latest-v20.x/docs/api/">https://nodejs.org/dist/latest-v20.x/docs/api/</a>. The website offers the option to navigate through the different versions so we can<a id="_idIndexMarker032"/> check the changes in the APIs between versions <span class="No-Break">more easily.</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B21678_01_04.jpg" alt="Figure 1.4 – Node.js official documentation screenshot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Node.js official documentation screenshot</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor033"/>Release schedule</h2>
			<p>The <a id="_idIndexMarker033"/>Node.js project has a release schedule that is published on the official website (<a href="https://nodejs.org/en/about/releases/">https://nodejs.org/en/about/releases/</a>) and it is updated by the Node.js Release <span class="No-Break">Working Group.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B21678_01_05.jpg" alt="Figure 1.5 – Official release schedule from the Node.js website"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Official release schedule from the Node.js website</p>
			<p>In Node.js, releases <a id="_idIndexMarker034"/>have three <span class="No-Break">different phases:</span></p>
			<ul>
				<li><strong class="bold">Current</strong> is the <a id="_idIndexMarker035"/>phase where new features (non-major changes) are added to the project. This phase is very active, and it is not always recommended to use it in production as it is not a <span class="No-Break">stable version.</span></li>
				<li><strong class="bold">Active Long-Term Support</strong> (<strong class="bold">LTS</strong>) is the phase where the version is stable and has <a id="_idIndexMarker036"/>been updated by the LTS team. This phase still includes new features, bug fixes, and updates. This phase is stable, so it is recommended to use it <span class="No-Break">in production.</span></li>
				<li><strong class="bold">Maintenance</strong> is the <a id="_idIndexMarker037"/>phase where the version is not receiving any new features, only critical bug fixes and security updates. This phase is recommended for projects that are not able to upgrade yet to the latest active <span class="No-Break">LTS version.</span></li>
			</ul>
			<p class="callout-heading">Important note</p>
			<p class="callout">Odd-numbered release lines are not promoted to active LTS, so they are not recommended for <span class="No-Break">production use.</span></p>
			<p>As of today, for any new project, I will recommend using the latest LTS version, which is 20.11.0. This version will be supported until April 2026, so it is a good choice for any <span class="No-Break">new project.</span></p>
			<p>For any<a id="_idIndexMarker038"/> existing project using Node.js v18, it is recommended to start migrating to Node.js 20 as v18 is entering the <span class="No-Break"><em class="italic">maintenance</em></span><span class="No-Break"> phase.</span></p>
			<p class="callout-heading">Important note</p>
			<p class="callout">While releasing a new version seems like an easy task, it is not. The Release Working Group has defined the complete process, which includes more than 20 steps. You can find all the relevant information in the official documentation (<a href="https://github.com/nodejs/node/blob/main/doc/contributing/releases.md">https://github.com/nodejs/node/blob/main/doc/contributing/releases.md</a>) or this talk: <em class="italic">The Life and Times of a Node.js Release</em>, by Danielle Adams at NodeConf EU <span class="No-Break">2022 (</span><a href="https://www.youtube.com/watch?v=OiSBodpU174"><span class="No-Break">https://www.youtube.com/watch?v=OiSBodpU174</span></a><span class="No-Break">).</span></p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor034"/>Summary</h1>
			<p>In this chapter, we explored what makes Node.js so special and how it differs from other backend systems. We also covered the history of Node.js and how it has evolved over <span class="No-Break">the years.</span></p>
			<p>Additionally, we covered the Node.js architecture and how it works under the hood. We learned about the event loop and how it allows Node.js to handle many concurrent <span class="No-Break">requests efficiently.</span></p>
			<p>In the next chapter, we will learn how to set up the development environment and start <span class="No-Break">using Node.js.</span></p>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor035"/>Further reading</h1>
			<ul>
				<li>Node.js <span class="No-Break">governance: </span><a href="https://nodejs.org/en/about/governance"><span class="No-Break">https://nodejs.org/en/about/governance</span></a></li>
				<li>OpenJS Foundation <span class="No-Break">governance: </span><a href="https://openjsf.org/about/governance/"><span class="No-Break">https://openjsf.org/about/governance/</span></a></li>
				<li><em class="italic">The Life and Times of a Node.js Release</em>, by Danielle Adams at NodeConf EU <span class="No-Break">2022: </span><a href="https://www.youtube.com/watch?v=OiSBodpU174"><span class="No-Break">https://www.youtube.com/watch?v=OiSBodpU174</span></a></li>
				<li>Node.js <span class="No-Break">dependencies: </span><a href="https://github.com/nodejs/node/blob/main/doc/contributing/maintaining/maintaining-dependencies.md"><span class="No-Break">https://github.com/nodejs/node/blob/main/doc/contributing/maintaining/maintaining-dependencies.md</span></a></li>
				<li>Node.js event loop <span class="No-Break">architecture: </span><a href="https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4"><span class="No-Break">https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4</span></a></li>
				<li><em class="italic">How Node.js Bootstraps Itself</em>, 2019 edition, Joyee Cheung, <span class="No-Break">Igalia: </span><a href="https://www.youtube.com/watch?v=bwiLlcGvFEk"><span class="No-Break">https://www.youtube.com/watch?v=bwiLlcGvFEk</span></a></li>
				<li><em class="italic">Node.js 12: A Decade of Node.js</em>, Beth Griggs, <span class="No-Break">IBM: </span><a href="https://www.youtube.com/watch?v=HP4N0u_dEgI"><span class="No-Break">https://www.youtube.com/watch?v=HP4N0u_dEgI</span></a></li>
				<li><em class="italic">Node.js 2023 Year in An </em><span class="No-Break"><em class="italic">Article</em></span><span class="No-Break">: </span><a href="https://blog.rafaelgss.dev/nodejs-2023-year-in-review"><span class="No-Break">https://blog.rafaelgss.dev/nodejs-2023-year-in-review</span></a></li>
			</ul>
		</div>
	</body></html>