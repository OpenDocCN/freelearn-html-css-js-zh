<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Object-Oriented JavaScript with Backbone Classes</h1></div></div></div><p>In this chapter, we will explore the following topics:</p><div><ul class="itemizedlist"><li class="listitem">The differences between JavaScript's class system and the class systems of traditional object-oriented languages</li><li class="listitem">How new, this, and prototype enable JavaScript's class system</li><li class="listitem">Extend, Backbone's much easier mechanism for creating subclasses</li><li class="listitem">Ways to take advantage of Underscore, which (like jQuery) is one of Backbone's dependencies</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>JavaScript's class system</h1></div></div></div><p>Programmers who<a id="id25" class="indexterm"/> use JavaScript can use classes to encapsulate units <a id="id26" class="indexterm"/>of logic in the same way as programmers of other languages. However, unlike those languages, JavaScript relies on a less popular form of inheritance known as prototype-based inheritance. Since Backbone classes are, at their core, just JavaScript classes, they too rely on the prototype system and can be subclassed in the same way as any other JavaScript class.</p><p>For instance, let's say you wanted to create your own <code class="literal">Book</code> subclass of the Backbone <code class="literal">Model</code> class with additional logic that Model doesn't have, such as book-related properties and methods. Here's how you can create such a class using only JavaScript's native object-oriented capabilities:</p><div><pre class="programlisting">// Define Book's Initializer
var Book = function() {
    // define Book's default properties
    this.currentPage = 1;
    this.totalPages = 1;
}

// Define book's parent class
Book.prototype = new Backbone.Model();

// Define a method of Book
Book.prototype.turnPage = function() {
    this.currentPage += 1;
    return this.currentPage;
}</pre></div><p>If you've never worked with<a id="id27" class="indexterm"/> prototypes in JavaScript, the preceding code<a id="id28" class="indexterm"/> may look a little intimidating. Fortunately, Backbone provides a much easier and easier to read mechanism for creating subclasses. However, since that system is built on top of JavaScript's native system, it's important to first understand how the native system works. This understanding will be helpful later when you want to do more complex class-related tasks, such as calling a method defined on a parent class.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>The new keyword</h1></div></div></div><p>The <code class="literal">new</code> keyword <a id="id29" class="indexterm"/>is a relatively simple but extremely useful part of JavaScript's class system. The first thing that you need to understand about new is that it doesn't create objects in the same way as other languages. In JavaScript, every variable is either a function, object, or primitive, which means that when we refer to a <em>class</em>, what we're really referring to is a specially designed initialization function. Creating this class-like function is as simple as defining a function that modifies this and then using the new keyword to call that function.</p><p>Normally, when you call a function, its this is obvious. For instance, when you call the <code class="literal">turnPage</code> method of a book object, the <code class="literal">this</code> method inside <code class="literal">turnPage</code> will be set to this book object, as shown here:</p><div><pre class="programlisting">var simpleBook = {currentPage: 3, pages: 60};
simpleBook.turnPage = function() {
    this.currentPage += 1;
    return this.currentPage;
}
simpleBook.turnPage(); // == 4</pre></div><p>Calling a function that isn't attached to an object (in other words, a function that is not a method) results in this being set to the global scope. In a web browser, this means the window object:</p><div><pre class="programlisting">var testGlobalThis = function() {
    alert(this);
}
testGlobalThis(); // alerts window</pre></div><p>When we use the <code class="literal">new</code> keyword<a id="id30" class="indexterm"/> before calling an initialization function, three things happen (well, actually four, but we'll wait to explain the fourth one until we explain prototypes):</p><div><ul class="itemizedlist"><li class="listitem">JavaScript creates a brand new object (<code class="literal">{}</code>)for us</li><li class="listitem">JavaScript sets the <code class="literal">this</code> method inside the initialization function to the newly created object</li><li class="listitem">After the function finishes, JavaScript ignores the normal return value and instead returns the object that was created</li></ul></div><p>As you can see, although the <code class="literal">new</code> keyword is simple, it's nevertheless important because it allows you to treat initialization functions as if they really are actual classes. At the same time, it does so without violating the JavaScript principle that all variables must either be a function, object, or primitive.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Prototypal inheritance</h1></div></div></div><p>That's all well and good, but if <a id="id31" class="indexterm"/>JavaScript has no true concept of classes, how can we create subclasses? As it turns out, every object in JavaScript has two special properties to solve this problem: <code class="literal">prototype and __proto__ (hidden)</code>. These two properties are, perhaps, the most commonly misunderstood aspects of JavaScript, but once you learn how they work, they are actually quite simple to use.</p><p>When you call a method on an object or try to retrieve a property JavaScript first checks whether the object has the method or property defined in the object itself. In other words if you define a method such as this one:</p><div><pre class="programlisting">book.turnPage = function() 
    this.currentPage += 1;
};</pre></div><p>JavaScript will use that definition first when you call <code class="literal">turnPage</code>. </p><div><h3 class="title"><a id="tip02"/>Tip</h3><p>In real-world code, however, you will almost never want to put methods directly in your objects for two reasons. First, doing that will result in duplicate copies of those methods, as each instance of your class will have its own separate copy. Second, adding methods in this way requires an extra step, and that step can be easily forgotten when you create new instances. </p></div><p>If the object doesn't have a <code class="literal">turnPage</code> method defined in it, JavaScript will next check the object's <code class="literal">hidden __proto__</code> property. If this <code class="literal">__proto__</code> object doesn't have a <code class="literal">turnPage</code> method, then JavaScript will look at the <code class="literal">__proto__</code> property on the object's <code class="literal">__proto__</code>. If that doesn't have the method, JavaScript continues to check the <code class="literal">__proto__</code> of the <code class="literal">__proto__</code> of the <code class="literal">__proto__</code> and keeps checking each successive <code class="literal">__proto__</code> until it has exhausted the chain.</p><div><img src="img/image00165.jpeg" alt="Prototypal inheritance"/></div><p style="clear:both; height: 1em;"> </p><p>This is similar to single-class <a id="id32" class="indexterm"/>inheritance in more traditional object-oriented languages, except that instead of going through a class chain, JavaScript instead uses a prototype chain. Just as in an object-oriented language we wind up with only a single copy of each method, but instead of the method being defined on the class itself, it's defined on the class's prototype.</p><p>In a future version of JavaScript (ES6), it will be possible to work with the <code class="literal">__proto__</code> object directly, but for now, the only way to actually see the <code class="literal">__proto__</code> property is to use your browser's debugging tool (for instance, the Chrome Developer Tools debugger):</p><div><img src="img/image00166.jpeg" alt="Prototypal inheritance"/></div><p style="clear:both; height: 1em;"> </p><p>This means that you can't use this line of code:</p><div><pre class="programlisting">book.__proto__.turnPage();</pre></div><p>Also, you can't use the following code:</p><div><pre class="programlisting">book.__proto__ = {
    turnPage: function() {
        this.currentPage += 1;
    }
};</pre></div><p>But, if you can't<a id="id33" class="indexterm"/> manipulate <code class="literal">__proto__</code> directly, how can you take advantage of it? Fortunately, it is possible to manipulate <code class="literal">__proto__</code>, but you can only do this indirectly by manipulating <code class="literal">prototype</code>. Do you remember I mentioned that the <code class="literal">new</code> keyword actually does four things? The fourth thing is that it sets the <code class="literal">__proto__</code> property of the new object it creates to the <code class="literal">prototype</code> property of the initialization function. In other words, if you want to add a <code class="literal">turnPage</code> method to every new instance of <code class="literal">Book</code> that you create, you can assign this <code class="literal">turnPage</code> method to the <code class="literal">prototype</code> property of the <code class="literal">Book</code> initialization function, For example:</p><div><pre class="programlisting">var Book = function() {};
Book.prototype.turnPage = function() {
    this.currentPage += 1;
};
var book = new Book();
book.turnPage();// this works because book.__proto__  == Book.prototype</pre></div><p>Since these concepts often cause confusion, let's briefly recap:</p><div><ul class="itemizedlist"><li class="listitem">Every object has a <code class="literal">prototype</code> property and a hidden <code class="literal">__proto__</code> property</li><li class="listitem">An object's <code class="literal">__proto__</code> property is set to the <code class="literal">prototype</code> property of its constructor when it is first created and cannot be changed</li><li class="listitem">Whenever JavaScript can't find a property or method on an object, it checks each step of the <code class="literal">__proto__</code> chain until it finds one or until it runs out of chain</li></ul></div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>
<strong>Downloading the example code</strong>
</p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Extending Backbone classes</h1></div></div></div><p>With that explanation <a id="id34" class="indexterm"/>out of the way, we can finally get down to the workings of Backbone's subclassing system, which revolves around Backbone's extend method. To use extend, you simply call it from the class that your new subclass will be based on, and extend will return the new subclass. This new subclass will have its <code class="literal">__proto__</code> property set to the <code class="literal">prototype</code> property of its parent class, allowing objects created with the new subclass to access all the properties and methods of the parent class. Take an example of the following code snippet:</p><div><pre class="programlisting">var Book = Backbone.Model.extend();
// Book.prototype.__proto__ == Backbone.Model.prototype;
var book = new Book();
book.destroy();</pre></div><p>In the preceding example, the last line works because JavaScript will look up the <code class="literal">__proto__</code> chain, find the <code class="literal">Model</code> method <code class="literal">destroy</code>, and use it. In other words, all the functionality of our original class has been inherited by our new class.</p><p>But of course, <code class="literal">extend</code> <a id="id35" class="indexterm"/>wouldn't be exciting if all it can do is make exact clones of the parent classes, which is why <code class="literal">extend</code> takes a <code class="literal">properties</code> object as its first argument. Any properties or methods on this object will be added to the new class's <code class="literal">prototype</code>. For instance, let's try making our <code class="literal">Book</code> class a little more interesting by adding a property and a method:</p><div><pre class="programlisting">var Book = Backbone.Model.extend({
    currentPage: 1,
    turnPage: function() {
        this.currentPage += 1;
    }
});
var book = new Book();
book.currentPage; // == 1
book.turnPage(); // increments book.currentPage by one</pre></div><p>The <code class="literal">extend</code> method also allows you to create static properties or methods, or in other words, properties or methods that live on the class rather than on objects created from that class. These static properties and methods are passed in as the second <code class="literal">classProperties</code> argument to <code class="literal">extend</code>. Here's a quick example of how to add a static method to our <code class="literal">Book</code> class:</p><div><pre class="programlisting">var Book = Backbone.Model.extend({}, {
    areBooksGreat: function() {
        alert("yes they are!");
    }
});
Book.areBooksGreat(); // alerts "yes they are!"
var book = new Book();
book.areBooksGreat(); // fails because static methods must be called on a class</pre></div><p>As you can see, there are several advantages to Backbone's approach to inheritance over the native JavaScript approach. First, the word <code class="literal">prototype</code> did not appear even once in any of the previously mentioned code; while you still need to understand how <code class="literal">prototype</code> works, you don't have to think about it just to create a class. Another benefit is that the entire class definition is contained within a single <code class="literal">extend</code> call, keeping all of the class's parts together visually. Also, when we use <code class="literal">extend</code>, the various pieces of logic that make up the class are ordered the same way as in most other programming languages, defining the super class first and then the initializer and properties, instead of the other way around.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Applying parent methods</h1></div></div></div><p>In order to realize the full <a id="id36" class="indexterm"/>power of a class system, however, it's not enough to just define new methods on subclasses; sometimes, we need to combine a method of a parent class with additional logic on a subclass. In traditional object-oriented languages, this is often done by referencing a special super object; but in JavaScript, no such object exists, which means that we have to utilize JavaScript's apply or call methods instead.</p><p>For instance, <code class="literal">Backbone.Model</code> has a <code class="literal">destroy</code> method, but what if we want our <code class="literal">Book</code> class to also have its own <code class="literal">destroy</code> method? This method might take a number of pages and destroy them (reduce the total number of pages by that amount), but at the same time, we might want to keep the Backbone version around for its original purpose (which is to destroy the server-side version of the <code class="literal">Book</code>).</p><p>Luckily, because Backbone properly configured our <code class="literal">Book</code> class's prototype for us, calling the parent method from the subclass method is fairly straightforward, as shown here:</p><div><pre class="programlisting">var Book = Backbone.Model.extend({
    destroy: function(optionsOrPagesToDestroy) {
        if (typeof optionsOrPagesToDestroy === 'number') {
            // optionsOrPagesToDestroy is pagesToDestroy: call our version
            this.totalPages -=  optionsOrPagesToDestroy;
        } else {
            // optionsOrPagesToDestroy is an options object: call the Backbone version
            Backbone.Model.prototype.destroy.apply(this, arguments);
        }
    }
});</pre></div><p>The key to making the preceding code work is the <code class="literal">apply</code> method, which is a method of every function in JavaScript (since functions are also objects in JavaScript, it is possible for them to have methods just like any other object). The <code class="literal">apply</code> method allows you to call its function as if it were called from the first argument given to apply. In other words, apply allows you to change a function's <code class="literal">this</code> method when it is invoked.</p><p>As mentioned before, under normal conditions, <code class="literal">this</code> will be set to the object from which the function was called. However, when you use apply, you can instead change this to whatever variable you want, as follows:</p><div><pre class="programlisting">var Book = Backbone.Model.extend({
    currentPage: 1,
    turnPage: function() {
        this.currentPage += 1;
    }
});
var simpleBook = {currentPage: 20};
Book.prototype.turnPage.apply(simpleBook); //  simpleBook.currentPage == 21</pre></div><p>You can also pass regular <a id="id37" class="indexterm"/>arguments to a method using <code class="literal">apply</code>, by providing them as a second (array) argument. In fact, <code class="literal">apply</code> can be used even if this isn't relevant to the function you're trying to call, and in that case, you can simply pass <code class="literal">null</code> as the first argument:</p><div><pre class="programlisting">var Book = Backbone.Model.extend();
var book = new Book();
book.alertMessage = function(message, secondMessage) {
    alert(message + ' ' + secondMessage);
}
book.alertMessage.apply(null, ['hello', 'world']);// alerts "hello world"</pre></div><p>JavaScript functions also have a similar method: <code class="literal">call</code>. The difference between <code class="literal">call</code> and <code class="literal">apply</code> is how they provide arguments to the function they invoke. Unlike <code class="literal">apply</code>, <code class="literal">call</code> expects its arguments to be passed in separately, rather than as a single array argument. Take an example of the following code snippet:</p><div><pre class="programlisting">var book = new Book();
book.alertMessage = function(message, secondMessage) {
    alert(message + ' ' + secondMessage);
}
book.alertMessage.call(null, 'hello', 'world'); // alerts "hello world"</pre></div><p>By using one of these two methods and remembering that every method of a class is available to you on its <code class="literal">prototype</code> property, you can call not just the methods of a parent class but also the methods of a grandparent, great grandparent, or even a completely unrelated class. For readability reasons, you shouldn't utilize this technique too often on unrelated classes, but occasionally it can be quite helpful.</p><div><h3 class="title"><a id="note02"/>Note</h3><p>It's also worth noting that this technique is only possible in a prototype-based inheritance language such as JavaScript; it will be impossible to implement <code class="literal">apply</code> or <code class="literal">call</code> in a true object-oriented language such as Java.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Introducing Underscore</h1></div></div></div><p>In addition to jQuery, Backbone also requires one library called <a id="id38" class="indexterm"/>
<strong>Underscore</strong>. Underscore was written by Jeremy Ashkenas (the creator of Backbone), and many of its functions are relevant to the topics we've discussed so far. Because Underscore is required by Backbone, you'll already have it available to you if you use Backbone. All of these functions can be accessed via the <code class="literal">_</code> character (similar to how jQuery functions are accessed via the <code class="literal">$</code> character).</p><p>As we discussed the <code class="literal">call</code> and <code class="literal">apply</code> methods, you may have realized that this is more fluid in JavaScript than in other languages. While a function that is called normally will preserve the <code class="literal">this</code> method<a id="id39" class="indexterm"/> automatically, when a function is called in an unusual way—such as through <code class="literal">window.setTimeout</code> or as a callback to a jQuery event handler or AJAX call—that won't be the case. The <code class="literal">window.setTimeout</code> will change this to the global window object, while jQuery event callbacks will change <code class="literal">this</code> to the element that triggered the event and jQuery AJAX callbacks will set it to the HTTP request created by the AJAX call. Here's a quick example:</p><div><pre class="programlisting">var exampleObject = {};
exampleObject.alertThis = function() {
     alert(this);
};
window.setTimeout(exampleObject.alertThis); // alerts window</pre></div><p>The solution to this problem is to use extra functions and use <code class="literal">apply</code> to wrap the original function so that we can force JavaScript to preserve our <code class="literal">this</code> method:</p><div><pre class="programlisting">      var exampleObject = {};
exampleObject.alertThisBuilder = function() {
    var alertThis = function() {
        alert(this);
    }
    var correctThis = this;
    return function() {
        alertThis.apply(correctThis);
    }
};
var alertThis = exampleObject.alertThisBuilder();
window.setTimeout(alertThis); // alerts exampleObject</pre></div><p>This works but let's face it: it's ugly. Luckily, Underscore has a two solution for this: <code class="literal">bind</code> and <code class="literal">bindAll</code>.</p><p>Let's start with <code class="literal">bind</code>. The <code class="literal">bind</code> functions allows you to force a function, which you provide as the first argument, to preserve a specific <code class="literal">this</code> value, which you provide as the second argument:</p><div><pre class="programlisting">var simpleBook = {};
simpleBook.alertThis = function() {
     alert(this);
};
simpleBook.alertThis = _.bind(simpleBook.alertThis, simpleBook);
window.setTimeout(simpleBook.alertThis); // now alerts simpleBook, not window</pre></div><p>Underscore also has a related <code class="literal">bindAll</code> function, which can be used to permanently <code class="literal">bind</code> a method:</p><div><pre class="programlisting">var Book = Backbone.Model.extend({
     initialize: function() {
          _.bindAll(this, 'alertThis');
     },
     alertThis: function() {
          alert(this);
     }
});
var  book = new Book();
window.setTimeout(book.alertThis); // alerts book, not window</pre></div><p>As you can see, <code class="literal">bindAll</code> allows you to use your class's methods with <code class="literal">setTimeout</code> or as callbacks to jQuery event handlers or AJAX operations, without losing <code class="literal">this</code>.</p><p>While <code class="literal">bindAll</code> is very<a id="id40" class="indexterm"/> powerful, it is important not to overuse it, because it creates a new copy of every method it binds. If used inside a class, this will result in every instance of that class to have its own separate copy of that method. While this is perfectly fine when you only have a few bound methods and/or only a few instances, you will not want to use it on a large number of methods with a class that will be instantiated many times.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>More Underscore</h1></div></div></div><p>The <code class="literal">bind</code> and <code class="literal">bindAll</code> functions are just the tip of the iceberg of what Underscore has to offer web developers. While a full explanation of everything that Underscore has to offer is outside the scope of this book, it is worth taking a few moments to examine a few of Underscore's most useful functions. If you want to learn more about Underscore beyond what we have covered in this chapter, I strongly recommend that you read its <a id="id41" class="indexterm"/>web page (<a class="ulink" href="http://underscorejs.org/">http://underscorejs.org/</a>), which has well-written documentation for every method in the library.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Each, Map, and Reduce</h2></div></div></div><p>Every JavaScript <a id="id42" class="indexterm"/>developer <a id="id43" class="indexterm"/>knows how to iterate using the <code class="literal">for</code> loops, but <a id="id44" class="indexterm"/>Underscore provides <a id="id45" class="indexterm"/>three powerful alternatives to those native loops: <code class="literal">each</code>, <code class="literal">map</code>, and <code class="literal">reduce</code>. While all three of these methods (along with many of the <a id="id46" class="indexterm"/>other Underscore methods) are included natively in <a id="id47" class="indexterm"/>ES5-supporting browsers, older browsers, unfortunately, do not have support for them. These alternative loops are so convenient that you may find yourself never using the native <code class="literal">for</code> loop again. Thankfully, Underscore provides its version of them, allowing you to bridge the gap until all major browsers support ES5.</p><p>Let's start with an example of the usage of each:</p><div><pre class="programlisting">var mythicalAnimals = ['Unicorn', 'Dragon', 'Honest Politician'];
_.each(mythicalAnimals, function(animalName, index) {
    alert('Animal #' + index + ' is ' + animalName);
});</pre></div><p>This will be the equivalent of the <a id="id48" class="indexterm"/>preceding code using JavaScript's native <code class="literal">for</code> loop:</p><div><pre class="programlisting">      var mythicalAnimals = ['Unicorn', 'Dragon', 'Honest Politician'];
for (var index = 0; index &lt; mythicalAnimals.length; index++) {
    var animalName = mythicAnimals[index];
    alert('Animal #' + index + ' is ' + animalName);
}</pre></div><p>Alternatively, if we <a id="id49" class="indexterm"/>instead use the <code class="literal">for</code>/<code class="literal">in</code> syntax:</p><div><pre class="programlisting">var mythicalAnimals = ['Unicorn', 'Dragon', 'Honest Politician'];
for (var index in mythicalAnimals) {
    var animalName = mythicalAnimals[index];
    alert('Animal #' + index + ' is ' + animalName);
}</pre></div><p>As you can see, both native<a id="id50" class="indexterm"/> implementations require you to extract the value (in this case, <code class="literal">animalName</code>) inside the loop, whereas Underscore's version provides it automatically.</p><p>Underscore's <code class="literal">map</code> and <code class="literal">reduce</code> methods<a id="id51" class="indexterm"/> are even more powerful. The <code class="literal">map</code> method allows you to convert an array of variables into another (different) array of variables, while reduce converts an array of variables into a single variable. For instance, let's say you've used jQuery's <code class="literal">text</code> method to extract a bunch of numbers, but because they came from the DOM, those numbers are actually strings (in other words, <code class="literal">5</code> instead of <code class="literal">5</code>). By using map, which has an almost identical syntax as each, you can easily convert all those strings into actual numbers, as follows:</p><div><pre class="programlisting">var stringNumbers = ["5", "10", "15"];
var BASE = 10; // when we parse strings in to numbers in
               // JavaScript we have to specify which base to use
var actualNumbers = _.map(stringNumbers, function(numberString, index) {
    return parseInt(numberString, BASE);
}); // actualNumbers == [5, 10, 15]</pre></div><p>As you can see from the preceding example, the values returned inside the <code class="literal">map</code> function are added to the array returned by the overall <code class="literal">map</code> operation. This lets you convert any kind of array into another kind of array, as long as you can define a function that sits in the middle and performs the desired conversion.</p><p>However, what if you wanted to combine or sum up all those numbers? In that case, you'd instead want to use <code class="literal">reduce</code>, as shown here:</p><div><pre class="programlisting">var total = _.reduce(actualNumbers, function(total, actualNumber) {
    return total +  actualNumber;
}, 0); // total == 30</pre></div><p>The <code class="literal">reduce</code> function<a id="id52" class="indexterm"/> is slightly more complex than the previous functions <a id="id53" class="indexterm"/>because of its last argument, which is known as the <em>memo</em> argument. This argument serves as the starting value for the object that reduce will eventually return, and then as each value is iterated through that, memo is replaced by whatever value the <code class="literal">reduce</code> function (the function that is passed in to reduce) returns. The <code class="literal">reduce</code> function is also passed the previous memo as its first argument, so each iteration can choose to modify the previous value the way it wants to. This allows reduce to be used for far more complex operations than to simply add two numbers together.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Extend and defaults</h2></div></div></div><p>Another common operation that is made easier with Underscore is copying the properties of one object onto another, which is solved with the Underscore methods <code class="literal">extend</code> (not to be confused with Backbone's <code class="literal">extend</code> class) and <code class="literal">defaults</code>. For instance, let's say you are using a third-party widget, such as a jQuery UI component, that takes a configuration argument when it is created. You might want to keep some configuration options the same for every widget in your site, but at the same time, you might want certain widgets to also have their own unique options.</p><p>Let's imagine that you've defined these two sets of configurations with two objects, one for the common configuration and one for a specific widget's configuration:</p><div><pre class="programlisting">var commonConfiguration = {foo: true, bar: true};
var specificConfiguration = {foo: false, baz: 7};</pre></div><p>The <code class="literal">extend</code> method takes<a id="id54" class="indexterm"/> the <a id="id55" class="indexterm"/>first argument given to it and copies the properties from each successive argument onto it. In this case, it allows you to take a new object, apply the common options to it first, and then apply the specific options, as follows:</p><div><pre class="programlisting">var combined = _.extend({}, commonConfiguration, specificConfiguration);
// combined == {foo: false, bar: true, baz: 7}</pre></div><p>The <code class="literal">defaults</code> <a id="id56" class="indexterm"/>method<a id="id57" class="indexterm"/> works in a similar manner, except that it only copies over values that the object doesn't already have. We can instead rewrite the preceding example with <code class="literal">defaults</code>, simply by changing the argument order:</p><div><pre class="programlisting">var combined = _.defaults({}, specificConfiguration , commonConfiguration);
// combined == {foo: false, bar: true, baz: 7}</pre></div><p>As its name implies, the <code class="literal">defaults</code> method is very handy when you want to specify default values for an object but don't want to replace any values you've already specified.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>Pluck and invoke</h2></div></div></div><p>Two of the most common uses of <code class="literal">map</code> involve getting certain properties from an array of objects or calling a certain method on every object in an array. Underscore provides additional convenience methods to do exactly this: <code class="literal">pluck</code> and <code class="literal">invoke</code>.</p><p>The <code class="literal">pluck</code> method<a id="id58" class="indexterm"/> allows you to extract a single property value from each<a id="id59" class="indexterm"/> member of an array. For example, let's say we have an array of objects representing fake books, as follows:</p><div><pre class="programlisting">var fakeBooks = [
    {title: 'Become English Better At', pages: 50, author: 'Bob'},
    {title: 'You Is Become Even Better at English', pages: 100, author: 'Bob'},
    {title: 'Bob is a Terrible Author', pages: 200, author: 'Fred the Critic'}
];</pre></div><p>If you want to create a list of just the titles of these books, you can use the <code class="literal">pluck</code> method as shown here:</p><div><pre class="programlisting">var fakeTitles = _.pluck(fakeBooks, 'title');// fakeTitles == ['Become English Better At', ...]</pre></div><p>The <code class="literal">invoke</code> method<a id="id60" class="indexterm"/> works in a similar way as <code class="literal">pluck</code> method, except<a id="id61" class="indexterm"/> that it assumes that the the provided property is a method and runs it and then adds the result to the returned array. This can be best demonstrated with the following example:</p><div><pre class="programlisting">var Book = Backbone.Model.extend({
    getAuthor: function() {
        // the "get" method returns an attribute of a Model;
        // we'll learn more about it in the following chapter
        return this.get('author');
    }
});
var books = [new Book(fakeBooks[0]),
                     new Book(fakeBooks[1]),
                     new Book(fakeBooks[2])];
var authors = _.invoke(books, 'getAuthor'); // == ['Bob', 'Bob', 'Fred the Critic']</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Further reading</h2></div></div></div><p>Underscore also has many other useful functions, and as we have mentioned before, all of them are well documented<a id="id62" class="indexterm"/> at <a class="ulink" href="http://underscorejs.org/">http://underscorejs.org/</a>. Since every Backbone programmer is guaranteed to have Underscore available, there's no reason why you shouldn't take advantage of this great library; even spending just a few minutes on the Underscore site will help make you aware of everything that it has to offer.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we explored how JavaScript's native class system works and how the <code class="literal">new</code>, <code class="literal">this</code>, and <code class="literal">prototype</code> keywords/properties form the basis of it. We also learned how Backbone's <code class="literal">extend</code> method makes creating new subclasses much more convenient as well as how to use <code class="literal">apply</code> and <code class="literal">call</code> to invoke parent methods (or when providing callback functions) to preserve the desired <code class="literal">this</code> method. Finally, we looked at a number of ways in which Underscore, one of Backbone's dependencies, can solve common problems. In the next chapter, we'll dive into the first of the four Backbone classes, <code class="literal">Model</code>. We'll learn how to use Model to organize our data on the client side and to exchange this data to and from our remote server.</p></div></body></html>