<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Adding Physics to Your Games Using the Chipmunk2D Engine"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Adding Physics to Your Games Using the Chipmunk2D Engine</h1></div></div></div><p>In the previous chapter, you saw how to add physics to your games using Box2D. However, Box2D isn't the only physics engine supported by Cocos2d-JS; you can also feature physics in your games using the Chipmunk2D engine.</p><p>So the main question is: should you use Box2D or Chipmunk2D to add physics to your games? There isn't a right answer. Just use the one you feel the most comfortable with.</p><p>That's why, in this chapter, I will show you how to create the same Totem Destroyer game using Chipmunk2D, highlighting the similarities and differences between the two physics engines.</p><p>As you saw in the previous chapter, it's time to learn:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring Cocos2d-JS to add Chipmunk2D engine to your games</li><li class="listitem" style="list-style-type: disc">Creating a physics space with gravity</li><li class="listitem" style="list-style-type: disc">Combining bodies and shapes to create a physics object</li><li class="listitem" style="list-style-type: disc">Creating a material</li><li class="listitem" style="list-style-type: disc">Creating static objects</li><li class="listitem" style="list-style-type: disc">Creating dynamic objects</li><li class="listitem" style="list-style-type: disc">Attaching sprites to physics objects</li><li class="listitem" style="list-style-type: disc">Selecting physics objects with the mouse or finger</li><li class="listitem" style="list-style-type: disc">Destroying physics objects</li><li class="listitem" style="list-style-type: disc">Checking for collisions among objects</li><li class="listitem" style="list-style-type: disc">Running the physics simulation</li><li class="listitem" style="list-style-type: disc">Using debug draw to test your projects</li></ul></div><p>I assume you are quite familiar with basic Box2D concepts discussed in the previous chapter, so I will move on rather fast in the creation of the game.</p><div class="section" title="Adding the Chipmunk2D engine to your project"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Adding the Chipmunk2D engine to your project</h1></div></div></div><p>As we will create the same game as the one in the previous chapter, I suggest you copy your project into a new<a id="id298" class="indexterm"/> folder since we will reuse most of the code already written in the previous chapter. All graphic assets will not change, so simply don't touch the <code class="literal">assets</code> folder. The same thing goes for the <code class="literal">loadassets.js</code>, <code class="literal">main.js</code> and <code class="literal">project.json</code> files.</p><p>So basically, the only file we will change is <code class="literal">gamescript.js</code>. Get ready to dive into the Chipmunk2D world.</p><div class="section" title="A physics game, without physics"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec14"/>A physics game, without physics</h2></div></div></div><p>As we already<a id="id299" class="indexterm"/> built the Totem Destroyer game prototype, we can strip all the physics parts out of it and leave just the bare bones, where we will build the new physics engine.</p><p>The physics-stripped version of <code class="literal">gamescript.js</code> is:</p><div class="informalexample"><pre class="programlisting">var gameScene = cc.Scene.extend({
  onEnter:function () {
    this._super();
    gameLayer = new game();
    gameLayer.init();
    this.addChild(gameLayer);
  }
});

var game = cc.Layer.extend({
  init:function () {
    this._super();
    var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
    this.addChild(backgroundLayer);
    // create physics world somehow
    this.addBody(240,10,480,20,false,"assets/ground.png","ground");
    this.addBody(204,32,24,24,true,"assets/brick1x1.png","destroyable");
    this.addBody(276,32,24,24,true,"assets/brick1x1.png","destroyable");
    this.addBody(240,56,96,24,true,"assets/brick4x1.png","destroyable");
    this.addBody(240,80,48,24,true,"assets/brick2x1.png","solid");
    this.addBody(228,104,72,24,true,"assets/brick3x1.png","destroyable");
    this.addBody(240,140,96,48,true,"assets/brick4x2.png","solid");
    this.addBody(240,188,24,48,true,"assets/totem.png","totem");
    this.scheduleUpdate();
    cc.eventManager.addListener(touchListener, this);
  },
  addBody: function(posX,posY,width,height,isDynamic,spriteImage,type){
    // create the physics body somehow
  },
  update:function(dt){
    // update the world somehow
  }
});

var touchListener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  onTouchBegan: function (touch, event) {
    // destroy a physics body somehow
  }
})</pre></div><p>Now, everything is ready<a id="id300" class="indexterm"/> to inject Chimpunk2D physics into the game. Let's start from the beginning and create the physics world.</p></div></div></div>
<div class="section" title="Configuring the physics space"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Configuring the physics space</h1></div></div></div><p>Look at the<a id="id301" class="indexterm"/> heading. It says <span class="strong"><strong>Configuring the physics space</strong></span>. I used <span class="emphasis"><em>space</em></span> rather than <span class="emphasis"><em>world</em></span> because Chipmunk2D calls <span class="emphasis"><em>space</em></span> what Box2D calls <span class="emphasis"><em>world</em></span>.</p><p>Both world and space represent the same thing: the place where physics-driven things happen.</p><p>Although Chipmunk2D calls it <span class="emphasis"><em>space</em></span>, we will continue to use a variable called <span class="emphasis"><em>world</em></span> to keep as much similarity with Box2D code as we can. This is the best way for you to see the similarities and differences between the two engines.</p><p>Change the <code class="literal">init</code> function in game declaration as follows:</p><div class="informalexample"><pre class="programlisting">init:function () {
  this._super();
  var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
  this.addChild(backgroundLayer);
  world = new cp.Space();
  world.gravity = cp.v(0, -100);
  this.addBody(240,10,480,20,false,"assets/ground.png","ground");
  this.addBody(204,32,24,24,true,"assets/brick1x1.png","destroyable");
  this.addBody(276,32,24,24,true,"assets/brick1x1.png","destroyable");
  this.addBody(240,56,96,24,true,"assets/brick4x1.png","destroyable");
  this.addBody(240,80,48,24,true,"assets/brick2x1.png","solid");
  this.addBody(228,104,72,24,true,"assets/brick3x1.png","destroyable");
  this.addBody(240,140,96,48,true,"assets/brick4x2.png","solid");
  this.addBody(240,188,24,48,true,"assets/totem.png","totem");
  this.scheduleUpdate();
  cc.eventManager.addListener(touchListener, this);
}</pre></div><p>Also, create the <code class="literal">world</code> global variable at the very beginning of the script:</p><div class="informalexample"><pre class="programlisting">var world;</pre></div><p>Let's see what <a id="id302" class="indexterm"/>happens when the following line is executed:</p><div class="informalexample"><pre class="programlisting">world = new cp.Space();</pre></div><p>The <code class="literal">cp.Space</code> method creates the Chipmunk2D space; by now, you should know this is the same as the Box2D world:</p><div class="informalexample"><pre class="programlisting">world.gravity = cp.v(0, -100);</pre></div><p>The <code class="literal">gravity</code> property sets <code class="literal">world gravity</code> with a vector. <code class="literal">cp.v</code> is how Chipmunk2D represents vectors, in the same way as Box2D uses <code class="literal">b2Vec2</code>. There's a horizontal and a vertical component and, to simulate earth gravity, you can use <code class="literal">(0,-100)</code>.</p><p>Unlike Box2D, Chipmunk2D<a id="id303" class="indexterm"/> does not use real-world units of measurements, so expect to use pixels rather than meters.</p></div>
<div class="section" title="Adding bodies to the space"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec55"/>Adding bodies to the space</h1></div></div></div><p>We already <a id="id304" class="indexterm"/>have the <code class="literal">addBody</code> function with all required arguments, so it's time to define it:</p><div class="informalexample"><pre class="programlisting">addBody: function(posX,posY,width,height,isDynamic,spriteImage,type){
  if(isDynamic){
    var body = new cp.Body(1,cp.momentForBox(1,width,height));
  }
  else{
    var body = new cp.Body(Infinity,Infinity);
  }
  body.setPos(cp.v(posX,posY));
  if(isDynamic){
    world.addBody(body);
  }
  var shape = new cp.BoxShape(body, width, height);
  shape.setFriction(1);
  shape.setElasticity(0);
  shape.name=type;
  world.addShape(shape);
}</pre></div><p>This is where big differences between Box2D and Chipmunk2D start to show. Thus, we will explain the <code class="literal">addBody</code> function line-by-line:</p><div class="informalexample"><pre class="programlisting">if(isDynamic) {
  var body = new cp.Body(1,cp.momentForBox(1,width,height));
}
else{
  var body = new cp.Body(Infinity,Infinity);
}</pre></div><p>We have two ways to create a body, irrespective of whether it's static or dynamic. Both use the <code class="literal">cp.Body</code> method, whose arguments are the mass and the moment of inertia. The moment of inertia is the mass property of a rigid body that determines the torque needed for a desired angular acceleration about an axis of rotation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>For more information, visit the Wikipedia article at <a class="ulink" href="http://en.wikipedia.org/wiki/Moment_of_inertia">http://en.wikipedia.org/wiki/Moment_of_inertia</a>, which explains it very clearly.</p></div></div><p>When a body is dynamic, I set the mass to <code class="literal">1</code>, but it could be any positive finite number, and the moment of inertia is a result of the calculation of the mass, the width, and the height by the <code class="literal">momentForBox</code> method, which does the hard work for us.</p><p>So, a box with <span class="emphasis"><em>mass = 1</em></span> will be declared this way:</p><div class="informalexample"><pre class="programlisting">var body = new cp.Body(1,cp.momentForBox(1,width,height));</pre></div><p>While a box with mass 15 will be declared, replacing 1 with 15 in this way:</p><div class="informalexample"><pre class="programlisting">var body = new cp.Body(<span class="strong"><strong>15</strong></span>,cp.momentForBox(<span class="strong"><strong>15</strong></span>,width,height));</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Remember, for a dynamic body, the mass can be set to any positive number.</p></div></div><p>On the other hand, when dealing with static bodies, you must set both the mass and the moment of inertia to an<a id="id305" class="indexterm"/> infinite number, which JavaScript represents <a id="id306" class="indexterm"/>with infinity.</p><p>Once the body is created, you need to give it a position in the space:</p><div class="informalexample"><pre class="programlisting">body.setPos(cp.v(posX,posY));</pre></div><p>The <code class="literal">setPos</code> method places it on the space using pixel coordinates. As you can see, <code class="literal">cp.v</code> arguments are the actual pixel coordinates you set when you call the <code class="literal">addBody</code> function with no conversions between units of measurement.</p><p>If you remember, in the Box2D chapter, you needed to convert meters to pixels. However, Chipmunk2D works directly in pixels.</p><p>Now, it's time to add the body to the space:</p><div class="informalexample"><pre class="programlisting">if(isDynamic){
  world.addBody(body);
}</pre></div><p>The <code class="literal">addBody</code> method adds a body to the space. You are probably wondering why I am adding the body to it only if it's dynamic. Once a body has been defined as static with infinite mass and a moment of inertia, there's no need to add it to the space unless you plan to move it manually during the game (think about a moving platform, which is not the case with our solid ground), because you will only add its collision shape.</p><p>What is a body collision shape? You are about to discover it:</p><div class="informalexample"><pre class="programlisting">var shape = new cp.BoxShape(body, width, height);</pre></div><p>Pretty much like Box2D, Chipmunk2D works with bodies and shapes, where bodies represent abstract physics entities, and shapes are actual pieces of physics matter attached to<a id="id307" class="indexterm"/> bodies. In Box2D, we also use fixtures as glue between a body and a shape while, in Chipmunk2D, this is not necessary: we can directly create a shape and attach it to a body.</p><p>Let's create the shape then:</p><div class="informalexample"><pre class="programlisting">var shape = new cp.BoxShape(body, width, height);
shape.setFriction(1);
shape.setElasticity(0);
shape.name=type;
world.addShape(shape);</pre></div><p>The <code class="literal">cp.BoxShape</code> method creates the shape, gives a width, height, and a body to attach the shape to <code class="literal">setFriction</code>, and <code class="literal">setElasticity</code> defines the shape material, which is referred to as elasticity as Box2D's restitution. I am also giving the shape a name; then the <code class="literal">addShape</code> method adds the shape to the space.</p><p>Now, all these shapes and bodies should be ready to be processed by the Chipmunk2D space, so it's time to see how to run the simulation.</p><div class="section" title="Updating Chipmunk2D space and using debug draw"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec15"/>Updating Chipmunk2D space and using debug draw</h2></div></div></div><p>To update the<a id="id308" class="indexterm"/> Chipmunk2D space, just call the <code class="literal">step</code> method in the update function:</p><div class="informalexample"><pre class="programlisting">update:function(dt){
  world.step(dt);
}</pre></div><p>This will make the<a id="id309" class="indexterm"/> simulation advance by the <code class="literal">dt</code> time.</p><p>Okay, now run the project and you will see just the background gradient. Did we miss something?</p><p>Like Box2D, Chipmunk2D does not draw the space; it simply computes it and leaves us the job of rendering it.</p><p>Anyway, to make quick and simple tests, there's a feature called debug draw (also included in Box2D), although I did not show you how to reduce the page count, which allows <a id="id310" class="indexterm"/>you to render the space without having actual graphic assets attached to bodies.</p><p>Change the <code class="literal">init</code> function this way:</p><div class="informalexample"><pre class="programlisting">init:function () {
  this._super();
  var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
  this.addChild(backgroundLayer);
  world = new cp.Space();
  world.gravity = cp.v(0, -100);
  <span class="strong"><strong>var debugDraw = cc.PhysicsDebugNode.create(world);</strong></span>
  <span class="strong"><strong>debugDraw.setVisible(true);</strong></span>
  <span class="strong"><strong>this.addChild(debugDraw);</strong></span>
  this.addBody(240,10,480,20,false,"assets/ground.png","ground");
  this.addBody(204,32,24,24,true,"assets/brick1x1.png","destroyable");
  this.addBody(276,32,24,24,true,"assets/brick1x1.png","destroyable");
  this.addBody(240,56,96,24,true,"assets/brick4x1.png","destroyable");
  this.addBody(240,80,48,24,true,"assets/brick2x1.png","solid");
  this.addBody(228,104,72,24,true,"assets/brick3x1.png","destroyable");
  this.addBody(240,140,96,48,true,"assets/brick4x2.png","solid");
  this.addBody(240,188,24,48,true,"assets/totem.png","totem");
  this.scheduleUpdate();
  cc.eventManager.addListener(touchListener, this);
}</pre></div><p>These three lines<a id="id311" class="indexterm"/> will create a debug draw layer with the <code class="literal">cc.PhysicsDebugNode.create</code> method, which is later added to the stage.</p><p>Run the project now:</p><div class="mediaobject"><img src="graphics/0075SOS_08_01.jpg" alt="Updating Chipmunk2D space and using debug draw"/></div><p>Also, here are our dynamic totem pieces and our static background rendered with debug draw. <code class="literal">PhysicsDebug</code> will iterate through the shapes and constraints in space, and draw them with the default <a id="id312" class="indexterm"/>color. Now, we can continue adding features to the game and add actual graphic assets once the game is completed. This will save developing time because, if <a id="id313" class="indexterm"/>something does not work as it should, then we can use debug draw to see whether Chipmunk2D bodies position-match the graphic assets position.</p></div></div>
<div class="section" title="Selecting and destroying space bodies"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec56"/>Selecting and destroying space bodies</h1></div></div></div><p>The player must be<a id="id314" class="indexterm"/> able to destroy certain bodies: the ones<a id="id315" class="indexterm"/> called with the <code class="literal">destroyable</code> name by clicking or tapping over them. Thus, this is the complete <code class="literal">touchListener</code> declaration:</p><div class="informalexample"><pre class="programlisting">var touchListener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  onTouchBegan: function (touch, event) {
    for(var i=shapeArray.length-1;i&gt;=0;i--){
      if(shapeArray[i].pointQuery(cp.v(touch.getLocation().x,touch.getLocation().y))!=undefined){
        if(shapeArray[i].name=="destroyable"){
          world.removeBody(shapeArray[i].getBody())
          world.removeShape(shapeArray[i])
          shapeArray.splice(i,1);
        }
      }
    }
  }
})</pre></div><p>Before commenting on it, I will explain to you another way to iterate through all these bodies or shapes in the space.</p><p>Do you remember body selection in Box2D? We looped through all world bodies using the <code class="literal">GetBodyList()</code> function. That's one way to do it. However, there are other ways; since I want to show you as<a id="id316" class="indexterm"/> many features as possible, this time we'll loop through shapes without using any Chipmunk2D proprietary <a id="id317" class="indexterm"/>function.</p><p>We can just add another global variable called <code class="literal">shapeArray</code>, an empty array:</p><div class="informalexample"><pre class="programlisting">var world;
<span class="strong"><strong>var shapeArray=[];</strong></span>
</pre></div><p>Then, in the <code class="literal">addBody</code> function, once we add a shape to the space, we append it to <code class="literal">shapeArray</code>:</p><div class="informalexample"><pre class="programlisting">addBody: function(posX,posY,width,height,isDynamic,spriteImage,type){
  if(isDynamic){
    var body = new cp.Body(1,cp.momentForBox(1,width,height));
  }
  else{
    var body = new cp.Body(Infinity,Infinity);
  }
  body.setPos(cp.v(posX,posY));
  if(isDynamic){
    world.addBody(body);
  }
  var shape = new cp.BoxShape(body, width, height);
  shape.setFriction(1);
  shape.setElasticity(0);
  shape.name=type;
  world.addShape(shape);
  <span class="strong"><strong>shapeArray.push(shape);</strong></span>
}</pre></div><p>Once we have all the shapes in <code class="literal">shapeArray</code>, it's easy to loop through them and see whether the clicked or touched point is inside one of them thanks to <code class="literal">pointQuery</code>, whose argument is a vector with stage<a id="id318" class="indexterm"/> coordinates. If it does not return <code class="literal">undefined</code>, it means the point is inside the given shape.</p><p>Then, the <code class="literal">removeBody</code> and <code class="literal">removeShape</code> space's methods delete the shape and the body, respectively. Remember to <a id="id319" class="indexterm"/>manually splice <code class="literal">shapeArray</code> when you remove something.</p><p>Want to see whether this works? Just run the project and click on a destroyable brick:</p><div class="mediaobject"><img src="graphics/0075SOS_08_02.jpg" alt="Selecting and destroying space bodies"/></div><p>Watch out! It's falling bricks!</p><p>This reminds me of two<a id="id320" class="indexterm"/> things. First, this is not the best way to solve the level. Second, we have to detect when the idol <a id="id321" class="indexterm"/>hits the ground.</p></div>
<div class="section" title="Checking for collisions among bodies"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec57"/>Checking for collisions among bodies</h1></div></div></div><p>In the previous<a id="id322" class="indexterm"/> chapter, to check for collision, we iterated through idol contact points to see when it hit the ground.</p><p>Both Box2D and Chipmunk2D have more interesting ways to check for collisions, as they handle collision listeners.</p><p>Add the highlighted line to the <code class="literal">init</code> function:</p><div class="informalexample"><pre class="programlisting">init:function () {
  this._super();
  var backgroundLayer = cc.LayerGradient.create(cc.color(0xdf,0x9f,0x83,255), cc.color(0xfa,0xf7,0x9f,255));
  this.addChild(backgroundLayer);
  world = new cp.Space();
  world.gravity = cp.v(0, -100);
  this._debugNode = cc.PhysicsDebugNode.create(world);
  this._debugNode.setVisible( true );
  this.addChild( this._debugNode );
  this.scheduleUpdate();
  this.addBody(240,10,480,20,false,"assets/ground.png","ground");
  this.addBody(204,32,24,24,true,"assets/brick1x1.png","destroyable");
  this.addBody(276,32,24,24,true,"assets/brick1x1.png","destroyable");
  this.addBody(240,56,96,24,true,"assets/brick4x1.png","destroyable");
  this.addBody(240,80,48,24,true,"assets/brick2x1.png","solid");
  this.addBody(228,104,72,24,true,"assets/brick3x1.png","destroyable");
  this.addBody(240,140,96,48,true,"assets/brick4x2.png","solid");
  this.addBody(240,188,24,48,true,"assets/totem.png","totem");
  cc.eventManager.addListener(touchListener, this);
  <span class="strong"><strong>world.setDefaultCollisionHandler</strong></span>  <span class="strong"><strong>(this.collisionBegin,null,null,null);</strong></span>
}</pre></div><p>With just one single line, we entered the world of collision listeners. The different types of listeners that can be <a id="id323" class="indexterm"/>used are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">setDefaultCollisionHandler</code>: This method will call four functions each time a collision will be updated. In Chipmunk2D as well as in Box2D, a collision has four states:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">begin</code>: This method defines the time the script realizes that two shapes are touching.</li><li class="listitem" style="list-style-type: disc"><code class="literal">preSolve</code>: This method is called just before solving the collision. To solve a collision means to update shapes and bodies according to the collision itself.</li><li class="listitem" style="list-style-type: disc"><code class="literal">postSolve</code>: This method is called just after solving the collision.</li><li class="listitem" style="list-style-type: disc"><code class="literal">separate</code>: This method is called when the collision ceases to exist—that is, these two shapes are no longer in touch.</li></ul></div></li></ul></div><p>We just need to check when the collision begins; that's why I am passing <code class="literal">collisionBegin</code> as the first argument, leaving other arguments to <code class="literal">null</code>. The <code class="literal">collisionBegin</code> function is very simple:</p><div class="informalexample"><pre class="programlisting">collisionBegin : function (arbiter, space ) {
  if((arbiter.a.name=="totem" &amp;&amp; arbiter.b.name=="ground") || (arbiter.b.name=="totem" &amp;&amp; arbiter.a.name=="ground")){
    console.log("Oh no!!!!");
  }
  return true;
}</pre></div><p>I am just checking <a id="id324" class="indexterm"/>whether the first shape: <code class="literal">arbiter.a</code> is called <code class="literal">totem</code>, and the second shape: <code class="literal">arbiter.b </code>is called <code class="literal">ground</code> or vice versa to output a console message.</p><p>You also have to return <code class="literal">true</code>, or the collision will be ignored.</p><p>Run the project, and when the totem touches the ground this way:</p><div class="mediaobject"><img src="graphics/0075SOS_08_03.jpg" alt="Checking for collisions among bodies"/></div><p>You will see this:</p><p>
<span class="strong"><strong>Oh no!!!!</strong></span>
</p><p>Finally, we completed all the game mechanics of our Totem Destroyer prototype. We just have to add our graphic assets to the game.</p><p>Did you notice? We are<a id="id325" class="indexterm"/> completing a project by adding graphic assets whereas, in the previous chapter, we started by adding them. This is one of the things I love about programming. Your choices are unlimited.</p></div>
<div class="section" title="Using your own graphic assets"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec58"/>Using your own graphic assets</h1></div></div></div><p>Just as in the <a id="id326" class="indexterm"/>previous chapter, we will add graphics when we add a body, then update their position and rotation according to its body position and rotation.</p><p>First, update the <code class="literal">addBody</code> function:</p><div class="informalexample"><pre class="programlisting">addBody: function(posX,posY,width,height,isDynamic,spriteImage,type){
  if(isDynamic){
    var body = new cp.Body(1,cp.momentForBox(1,width,height));
  }
  else{
    var body = new cp.Body(Infinity,Infinity);
  }
  body.setPos(cp.v(posX,posY));
  <span class="strong"><strong>var bodySprite = cc.Sprite.create(spriteImage);</strong></span>
  <span class="strong"><strong>gameLayer.addChild(bodySprite,0);</strong></span>
  <span class="strong"><strong>bodySprite.setPosition(posX,posY);</strong></span>
  if(isDynamic){
    world.addBody(body);
  }
  var shape = new cp.BoxShape(body, width, height);
  shape.setFriction(1);
  shape.setElasticity(0);
  shape.name=type;
  <span class="strong"><strong>shape.image=bodySprite;</strong></span>
  world.addShape(shape);
  shapeArray.push(shape);
}</pre></div><p>This works in the same way as we saw with Box2D: a sprite is added to the game and is saved in a custom shape attribute—in this case, <code class="literal">image</code>.</p><p>To update the sprite's position in the <code class="literal">update</code> function, we need to loop through all shapes:</p><div class="informalexample"><pre class="programlisting">update:function(dt){
  <span class="strong"><strong>world.step(dt);</strong></span>
  <span class="strong"><strong>for(var i=shapeArray.length-1;i&gt;=0;i--){</strong></span>
    <span class="strong"><strong>shapeArray[i].image.x=shapeArray[i].body.p.x</strong></span>
    <span class="strong"><strong>shapeArray[i].image.y=shapeArray[i].body.p.y</strong></span>
    <span class="strong"><strong>var angle = Math.atan2(-shapeArray[i].body.rot.y,shapeArray[i].body.rot.x);</strong></span>
    <span class="strong"><strong>shapeArray[i].image.rotation= angle*57.2957795;</strong></span>
  <span class="strong"><strong>}</strong></span>
}</pre></div><p>We loop through our custom variable, <code class="literal">shapeArray</code>, and update each shape image according to its body position and rotation. While it's very easy to get a body position with the <code class="literal">p</code> property, Chipmunk2D does not return a body rotation in degrees or radians, but with a vector; you can get its position with the <code class="literal">rot</code> property. That's why I am using the <code class="literal">atan2</code> method to get an angle from a vector; then I multiply it by <code class="literal">57.2957795</code> to turn radians into degrees.</p><p>Also, don't forget to<a id="id327" class="indexterm"/> manually remove a sprite when you remove its body:</p><div class="informalexample"><pre class="programlisting">var touchListener = cc.EventListener.create({
  event: cc.EventListener.TOUCH_ONE_BY_ONE,
  onTouchBegan: function (touch, event) {
    for(var i=shapeArray.length-1;i&gt;=0;i--){
      if(shapeArray[i].pointQuery(cp.v(touch.getLocation().x,touch.getLocation().y))!=undefined){
        if(shapeArray[i].name=="destroyable"){
          <span class="strong"><strong>gameLayer.removeChild(shapeArray[i].image);</strong></span>
          world.removeBody(shapeArray[i].getBody())
          world.removeShape(shapeArray[i])
          shapeArray.splice(i,1);
        }
      }
    }
  }
})</pre></div><p>Run the project and see your custom graphics in action:</p><div class="mediaobject"><img src="graphics/0075SOS_08_04.jpg" alt="Using your own graphic assets"/></div><p>At this time, you<a id="id328" class="indexterm"/> can remove debug draw graphics; this leaves you with the same game made with two different physics engines.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Summary</h1></div></div></div><p>Let me congratulate you; you not only made a Totem Destroyer game, but you were also able to make it using two different physics engines. Not all developers out there are able to do it. Now, add to the game the same improvement you added to the Box2D game because you improved the game, didn't you? Let's start the last chapter, where you will create a blockbuster game in a matter of minutes.</p></div></body></html>