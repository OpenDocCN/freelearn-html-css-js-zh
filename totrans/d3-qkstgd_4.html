<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Making a Basic Scatter Plot Interactive</h1>
                </header>
            
            <article>
                
<p>In the last chapter, we created a static scatter plot. In this chapter, we'll make it interactive so that we can add, update, and delete runs. You'll learn how to do the following:</p>
<ul>
<li>Create a click handler</li>
<li>Remove data</li>
<li>Drag an element</li>
<li>Update data after a drag</li>
<li>Create a zoom behavior that scales elements</li>
<li>Update axes when zooming/panning</li>
<li>Update click points after a transform</li>
<li>Avoid redrawing the entire screen during rendering</li>
<li>Hide elements beyond axes</li>
</ul>
<p><span>The complete code for this section can be found here: <a href="https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04" target="_blank">https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04</a><a href="https://github.com/PacktPublishing/D3.js-Quick-Start-Guide/tree/master/Chapter04">.</a></span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a click handler</h1>
                </header>
            
            <article>
                
<p>Let's say that we want it so that when the user clicks on the <kbd>&lt;svg&gt;</kbd> element, it creates a new run. Add the following to the bottom of <kbd>app.js</kbd>:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-s"><span class="pl-pds">'</span>svg<span class="pl-pds">'</span></span>).<span class="pl-en">on</span>(<span class="pl-s"><span class="pl-pds">'</span>click<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(){<br/>    //gets the x position of the mouse relative to the svg element
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-c1">event</span>.<span class="pl-smi">offsetX</span>;<br/>    //gets the y position of the mouse relative to the svg element
    <span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-c1">event</span>.<span class="pl-smi">offsetY</span>; </pre>
<pre>    //get a date value from the visual point that we clicked on
    <span class="pl-k">var</span> date <span class="pl-k">=</span> <span class="pl-smi">xScale</span>.<span class="pl-en">invert</span>(x);<br/>    //get a numeric distance value from<br/>    //the visual point that we clicked on
    <span class="pl-k">var</span> distance <span class="pl-k">=</span> <span class="pl-smi">yScale</span>.<span class="pl-en">invert</span>(y); 
<br/>    //create a new "run" object
    <span class="pl-k">var</span> newRun <span class="pl-k">=</span> { <br/>        //generate a new id by adding 1 to the last run's id
        id<span class="pl-k">:</span> runs[<span class="pl-smi">runs</span>.<span class="pl-c1">length</span><span class="pl-k">-</span><span class="pl-c1">1</span>].<span class="pl-c1">id</span><span class="pl-k">+</span><span class="pl-c1">1</span>, <br/>        //format the date object created above to a string
        date<span class="pl-k">:</span> <span class="pl-en">formatTime</span>(date),
        distance<span class="pl-k">:</span> distance <span class="pl-c">//add the distance</span>
    }
    <span class="pl-smi">runs</span>.<span class="pl-c1">push</span>(newRun); <span class="pl-c">//push the new run onto the runs array</span>
    <span class="pl-en">createTable</span>(); <span class="pl-c">//render the table</span>
});</pre></div>
<p>Let's examine what we just wrote. Note that <kbd>d3.select('svg').on('click', function(){</kbd> <span>s</span>ets up a click handler on the <kbd>svg</kbd> element. The anonymous function that gets passed in as the second parameter to <kbd>.on()</kbd> gets called each time the user clicks on the SVG. Once inside that callback function, we use <kbd>d3.event.offsetX</kbd> to get the <em>x</em> position of the mouse inside the SVG, and we use <kbd>d3.event.offsetY</kbd> to get the <em>y</em> position. We then use <kbd>xScale.invert()</kbd> and <kbd>yScale.invert()</kbd> to turn the <em>x</em>/<em>y</em> visual points into data values (date and distance, respectively). We then use those data values to create a new run object. We create an ID for the new run by getting the ID of the last element in the <kbd>runs</kbd> array and adding 1 to it. Lastly, we push the new run on to the <kbd>runs</kbd> array and call <kbd>createTable()</kbd>.</p>
<p>Click on the SVG to create a new run. You might notice that <kbd>createTable()</kbd> just adds on all the run rows again:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-394 image-border" src="assets/1d917d16-62ee-4495-a136-63e1fdb85d06.png" style=""/></div>
<p>Let's alter the <kbd>createTable()</kbd> function so that when it runs, it clears out any rows previously created and re-renders everything. Add <kbd>d3.select('tbody').html('')</kbd> to the top of the <kbd>createTable</kbd> function in <kbd>app.js</kbd>:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-k">var</span> <span class="pl-en">createTable</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){<br/>    //clear out all rows from the table
    <span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-s"><span class="pl-pds">'</span>tbody<span class="pl-pds">'</span></span>).<span class="pl-en">html</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>); 
    <span class="pl-k">for</span> (<span class="pl-k">var</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">runs</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
        <span class="pl-k">var</span> row <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-s"><span class="pl-pds">'</span>tbody<span class="pl-pds">'</span></span>).<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">'</span>tr<span class="pl-pds">'</span></span>);
        <span class="pl-smi">row</span>.<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">'</span>td<span class="pl-pds">'</span></span>).<span class="pl-en">html</span>(runs[i].<span class="pl-c1">id</span>);
        <span class="pl-smi">row</span>.<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">'</span>td<span class="pl-pds">'</span></span>).<span class="pl-en">html</span>(runs[i].<span class="pl-smi">date</span>);
        <span class="pl-smi">row</span>.<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">'</span>td<span class="pl-pds">'</span></span>).<span class="pl-en">html</span>(runs[i].<span class="pl-smi">distance</span>);
    }
}</pre>
<p>Now refresh the page and click on the SVG to create a new run. The table should then look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-395 image-border" src="assets/30c58628-df31-4979-a0d5-602398d939a9.png" style=""/></div>
</div>
<p>The only issue now is that circles aren't being created when you click on the SVG. To fix this, let's wrap the code for creating <kbd>&lt;circle&gt;</kbd> elements in a render function, and call <kbd>render()</kbd> immediately after it's defined:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-k">var</span> <span class="pl-en">render</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){

    <span class="pl-k">var</span> yScale <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">scaleLinear</span>();
    <span class="pl-smi">yScale</span>.<span class="pl-en">range</span>([<span class="pl-c1">HEIGHT</span>, <span class="pl-c1">0</span>]);
    yDomain <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">extent</span>(runs, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){
        <span class="pl-k">return</span> <span class="pl-smi">datum</span>.<span class="pl-smi">distance</span>;
    })
    <span class="pl-smi">yScale</span>.<span class="pl-en">domain</span>(yDomain);

    <span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-s"><span class="pl-pds">'</span>svg<span class="pl-pds">'</span></span>).<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>)
        .<span class="pl-c1">data</span>(runs)
        .<span class="pl-en">enter</span>()
        .<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>);

    <span class="pl-smi">d3</span>.<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>)
        .<span class="pl-en">attr</span>(<span class="pl-s"><span class="pl-pds">'</span>cy<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){
            <span class="pl-k">return</span> <span class="pl-en">yScale</span>(<span class="pl-smi">datum</span>.<span class="pl-smi">distance</span>);
        });

    <span class="pl-k">var</span> parseTime <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">timeParse</span>(<span class="pl-s"><span class="pl-pds">"</span>%B%e, %Y at %-I:%M%p<span class="pl-pds">"</span></span>);
    <span class="pl-k">var</span> formatTime <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">timeFormat</span>(<span class="pl-s"><span class="pl-pds">"</span>%B%e, %Y at %-I:%M%p<span class="pl-pds">"</span></span>);
    <span class="pl-k">var</span> xScale <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">scaleTime</span>();
    <span class="pl-smi">xScale</span>.<span class="pl-en">range</span>([<span class="pl-c1">0</span>,<span class="pl-c1">WIDTH</span>]);
    xDomain <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">extent</span>(runs, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){
        <span class="pl-k">return</span> <span class="pl-en">parseTime</span>(<span class="pl-smi">datum</span>.<span class="pl-smi">date</span>);
    });
    <span class="pl-smi">xScale</span>.<span class="pl-en">domain</span>(xDomain);</pre>
<pre>    <span class="pl-smi">d3</span>.<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>)
        .<span class="pl-en">attr</span>(<span class="pl-s"><span class="pl-pds">'</span>cx<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){
            <span class="pl-k">return</span> <span class="pl-en">xScale</span>(<span class="pl-en">parseTime</span>(<span class="pl-smi">datum</span>.<span class="pl-smi">date</span>));
        });

}
<span class="pl-en">render</span>();</pre></div>
<p>If you refresh the browser, you'll see an error in the console. This is because <kbd>bottomAxis</kbd> and <kbd>leftAxis</kbd> use <kbd>xScale</kbd> and <kbd>yScale</kbd> that are now scoped to exist only inside the <kbd>render()</kbd> function. For future use, let's move <kbd>xScale</kbd> and <kbd>yScale</kbd> out of the render function along with the code for creating the domains/ranges:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-k">var</span> parseTime <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">timeParse</span>(<span class="pl-s"><span class="pl-pds">"</span>%B%e, %Y at %-I:%M%p<span class="pl-pds">"</span></span>);
<span class="pl-k">var</span> formatTime <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">timeFormat</span>(<span class="pl-s"><span class="pl-pds">"</span>%B%e, %Y at %-I:%M%p<span class="pl-pds">"</span></span>);
<span class="pl-k">var</span> xScale <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">scaleTime</span>();
<span class="pl-smi">xScale</span>.<span class="pl-en">range</span>([<span class="pl-c1">0</span>,<span class="pl-c1">WIDTH</span>]);
xDomain <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">extent</span>(runs, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){
    <span class="pl-k">return</span> <span class="pl-en">parseTime</span>(<span class="pl-smi">datum</span>.<span class="pl-smi">date</span>);
});
<span class="pl-smi">xScale</span>.<span class="pl-en">domain</span>(xDomain);

<span class="pl-k">var</span> yScale <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">scaleLinear</span>();
<span class="pl-smi">yScale</span>.<span class="pl-en">range</span>([<span class="pl-c1">HEIGHT</span>, <span class="pl-c1">0</span>]);
yDomain <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">extent</span>(runs, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){
    <span class="pl-k">return</span> <span class="pl-smi">datum</span>.<span class="pl-smi">distance</span>;
})
<span class="pl-smi">yScale</span>.<span class="pl-en">domain</span>(yDomain);
<span class="pl-k">var</span> <span class="pl-en">render</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(){
<br/>    //since no circles exist,<br/>    //we need to select('svg') so that <br/>    //d3 knows where to append the new circles
    <span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-s"><span class="pl-pds">'</span>svg<span class="pl-pds">'</span></span>).<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>) <br/>        //attach the data as before
        .<span class="pl-c1">data</span>(runs) <span class="pl-c"><br/>        //find the data objects that have not yet<br/>        //been attached to visual elements</span>
        .<span class="pl-en">enter</span>()<br/>        //for each data object that hasn't been attached, <br/>        //append a &lt;circle&gt; to the &lt;svg&gt;
        .<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>);</pre>
<pre>    <span class="pl-smi">d3</span>.<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>)
        .<span class="pl-en">attr</span>(<span class="pl-s"><span class="pl-pds">'</span>cy<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){
            <span class="pl-k">return</span> <span class="pl-en">yScale</span>(<span class="pl-smi">datum</span>.<span class="pl-smi">distance</span>);
        });

    <span class="pl-smi">d3</span>.<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>)
        .<span class="pl-en">attr</span>(<span class="pl-s"><span class="pl-pds">'</span>cx<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){<br/>            //use parseTime to convert <br/>            //the date string property on the datum object <br/>            //to a Date object, <br/>            //which xScale then converts to a visual value
            <span class="pl-k">return</span> <span class="pl-en">xScale</span>(<span class="pl-en">parseTime</span>(<span class="pl-smi">datum</span>.<span class="pl-smi">date</span>)); 
        });

}
<span class="pl-en">render</span>();</pre></div>
<p>Now go to the bottom of <kbd>app.js</kbd> and add a line to call <kbd>render()</kbd> inside our <kbd>&lt;svg&gt;</kbd> click handler:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-smi">var newRun = {<br/>    id: runs[runs.length-1].id+1,<br/>    date: formatTime(date),<br/>    distance: distance<br/>}<br/>runs</span>.<span class="pl-c1">push</span>(newRun);
<span class="pl-en">createTable</span>();
<span class="pl-en">render</span>(); <span class="pl-c">//add this line</span></pre>
<p>Now when you click the SVG, a circle will appear:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-396 image-border" src="assets/54e21521-96d3-40be-901a-4b827b55c686.png" style=""/></div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Removing data</h1>
                </header>
            
            <article>
                
<p>Let's set up a click handler on all <kbd>&lt;circle&gt;</kbd> elements so that when the user clicks on <kbd>&lt;circle&gt;</kbd>, D3 will remove that circle and its associated data element from the array. Add the following code at the bottom of the <kbd>render</kbd> function declaration we wrote in the last section. We do this so that the click handlers are attached <em>after</em> the circles are created:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-c">//put this at the bottom of the render function, <br/>//so that click handlers are attached when the circle is created</span>
<span class="pl-smi">d3</span>.<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>).<span class="pl-en">on</span>(<span class="pl-s"><span class="pl-pds">'</span>click<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">datum</span>, <span class="pl-smi">index</span>){<br/>    //stop click event from propagating to <br/>    //the SVG element and creating a run
    <span class="pl-smi">d3</span>.<span class="pl-c1">event</span>.<span class="pl-c1">stopPropagation</span>(); <br/>    //create a new array that has removed the run <br/>    //with the correct id. Set it to the runs var
    runs <span class="pl-k">=</span> <span class="pl-smi">runs</span>.<span class="pl-en">filter</span>(<span class="pl-k">function</span>(<span class="pl-smi">run</span>, <span class="pl-smi">index</span>){ 
        <span class="pl-k">return</span> <span class="pl-smi">run</span>.<span class="pl-c1">id</span> <span class="pl-k">!=</span> <span class="pl-smi">datum</span>.<span class="pl-c1">id</span>;
    });
    <span class="pl-en">render</span>(); <span class="pl-c">//re-render dots</span>
    <span class="pl-en">createTable</span>(); <span class="pl-c">//re-render table</span>
});</pre></div>
<p>Let's examine the previous code. The first line selects all <kbd>&lt;circle&gt;</kbd> elements and creates a click handler on each of them. However, <kbd>d3.event.stopPropagation();</kbd> prevents the click from bubbling up the DOM to the SVG. If we don't add it, the click handler on the SVG will fire as well, when we click on a circle. This would create an additional run every time we try to remove a run. Next, we call the following:</p>
<pre>runs = runs.filter(function(run, index){<br/> return run.id != datum.id;<br/>});</pre>
<p class="mce-root">This loops through the <kbd>runs</kbd> array and filters out any objects that have an <kbd>id</kbd> property that matches the <kbd>id</kbd> property of <kbd>datum</kbd> that is associated with <kbd>&lt;circle&gt;</kbd> that was clicked. Notice that the callback function in <kbd>.on('click', function(datum, index){</kbd> takes two parameters: <kbd>datum</kbd>, the run object associated with that <kbd>&lt;circle&gt;</kbd> , and the <kbd>index</kbd> of the run object in the <kbd>runs</kbd> array.</p>
<p class="mce-root">Once we've filtered out the correct run object from the <kbd>runs</kbd> array, we call <kbd>render()</kbd> and <kbd>createdTable()</kbd> to re-render the graph and the table.</p>
<p class="mce-root">But if we click on the middle circle and examine the <strong>Elements</strong> tab of the Developer Tools, we'll see that the <kbd>&lt;circle&gt;</kbd> element hasn't been removed:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-397 image-border" src="assets/dcd904e5-f644-4f91-9cd4-c1c64c906205.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Elements tab showing the &lt;circle&gt; element</div>
<p>In the previous screenshot, it appears as though there are only two circles, but really the middle one has had its <kbd>cx</kbd> set to 800 and its <kbd>cy</kbd> set to 0. It's overlapping the other circle in the same position. This is because we've removed the second element in the <kbd>runs</kbd> array. When we re-render the graph, the <kbd>runs</kbd> array only has two objects; the second run object used to be the third run object before we removed the middle run. Now that it's the second run object, the second <kbd>&lt;circle&gt;</kbd> is assigned its data. The third circle still has its old data assigned to it, so both the second and the third circle have the same data and are therefore placed in the same location.</p>
<p>Let's put the circles in <kbd>&lt;g&gt;</kbd> so that it's easy to clear out all the circles and re-render them when we remove a run. This way we won't have any extra <kbd>&lt;circle&gt;</kbd> elements lying around when we try to remove them. This approach is similar to what we do when re-rendering the table. Adjust your <kbd>&lt;svg&gt;</kbd> element in <kbd>index.html</kbd> so it looks as follows:</p>
<div class="highlight highlight-text-html-basic">
<pre>&lt;<span class="pl-ent">svg</span>&gt;
    &lt;<span class="pl-ent">g</span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>points<span class="pl-pds">"</span></span>&gt;&lt;/<span class="pl-ent">g</span>&gt;
&lt;/<span class="pl-ent">svg</span>&gt;</pre></div>
<p>Now we can clear out the <kbd>&lt;circle&gt;</kbd> elements each time <kbd>render()</kbd> is called. This is a little crude, but it'll work for now. Later on, we'll do things in a more elegant fashion. At the top of the <kbd>render()</kbd> function declaration, add <kbd>d3.select('#points').html('');</kbd> and adjust the next line from <kbd>d3.select('svg').selectAll('circle')</kbd> to <kbd>d3.select('#points').selectAll('circle')</kbd>:</p>
<pre><span class="pl-c">//adjust the code at the top of your render function<br/> //clear out all circles when rendering</span> <span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-s"><span class="pl-pds">'</span>#points<span class="pl-pds">'</span></span>).<span class="pl-en">html</span>(<span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>);<br/> //add circles to #points group, not svg <span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-s"><span class="pl-pds">'</span>#points<span class="pl-pds">'</span></span>).<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>) .<span class="pl-c1">data</span>(runs) .<span class="pl-en">enter</span>() .<span class="pl-c1">append</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>);</pre>
<p class="mce-root">Now if we click on the middle circle, the element is removed from the DOM:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-398 image-border" src="assets/796556a5-98ca-42f8-9f2b-627515838e15.png" style=""/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Removing the element from the DOM</div>
<p>If you try to delete all the circles and then add a new one, you'll get an error:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-399 image-border" src="assets/c51ac782-30af-4521-9ce7-1294f107a58f.png" style=""/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Displaying the error you get when deleting all the circles and adding a new one</div>
<p>This is because our code for creating <kbd>newRun</kbd> in the SVG click handler needs some work:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-k">var</span> newRun <span class="pl-k">=</span> { <span class="pl-c">//create a new "run" object<br/>    //generate a new id by adding 1 to the last run's id</span>
    id<span class="pl-k">:</span> runs[<span class="pl-smi">runs</span>.<span class="pl-c1">length</span><span class="pl-k">-</span><span class="pl-c1">1</span>].<span class="pl-c1">id</span><span class="pl-k">+</span><span class="pl-c1">1</span>, <br/>    //format the date object created above to a string
    date<span class="pl-k">:</span> <span class="pl-en">formatTime</span>(date), 
    distance<span class="pl-k">:</span> distance <span class="pl-c">//add the distance</span>
}</pre></div>
<p>This is because when there are no run elements in the <kbd>runs</kbd> array, <kbd>runs[runs.length-1]</kbd> tries to access an element at index <kbd>-1</kbd> in the array. Inside the <kbd>&lt;svg&gt;</kbd> click handler, let's put in a little code to handle when the user has deleted all runs and tries to add a new one:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-c">//inside svg click handler</span>
<span class="pl-k">var</span> newRun <span class="pl-k">=</span> {<br/>    //add this line
    id<span class="pl-k">:</span> ( <span class="pl-smi">runs</span>.<span class="pl-c1">length</span> <span class="pl-k">&gt;</span> <span class="pl-c1">0</span> ) <span class="pl-k">?</span> runs[<span class="pl-smi">runs</span>.<span class="pl-c1">length</span><span class="pl-k">-</span><span class="pl-c1">1</span>].<span class="pl-c1">id</span><span class="pl-k">+</span><span class="pl-c1">1</span> <span class="pl-k">:</span> <span class="pl-c1">1</span>, 
    date<span class="pl-k">:</span> <span class="pl-en">formatTime</span>(date),
    distance<span class="pl-k">:</span> distance
}</pre>
<p>Here's what Chrome should look like now if you delete all the runs and then try to add a new one:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-400 image-border" src="assets/b34ae165-9619-4176-9531-19be00a7791c.png" style=""/></div>
</div>
<p>Lastly, let's put in some CSS, so we know we're clicking on a circle. First, add <kbd>transition: r 0.5s linear, fill 0.5s linear;</kbd> to the CSS code you've already written for <kbd>circle</kbd>:</p>
<div class="highlight highlight-source-css">
<pre><span class="pl-ent">circle</span> {
    <span class="pl-c1">r</span>: <span class="pl-c1">5</span>;
    <span class="pl-c1">fill</span>: <span class="pl-c1">black</span>;<br/>    /* add this transition to original code */
    <span class="pl-c1">transition</span>: r <span class="pl-c1">0.5<span class="pl-k">s</span></span> <span class="pl-c1">linear</span>, <span class="pl-c1">fill</span> <span class="pl-c1">0.5<span class="pl-k">s</span></span> <span class="pl-c1">linear</span>; 
}</pre>
<p>Then add this to the bottom of <kbd>app.css</kbd>:</p>
<pre><span class="pl-c">/* add this css for the hover state */</span>
<span class="pl-ent">circle</span><span class="pl-e">:hover</span> {
    <span class="pl-c1">r</span>:<span class="pl-c1">10</span>;
    <span class="pl-c1">fill</span>: <span class="pl-c1">blue</span>;
}</pre>
<p>Here's what a circle should look like when you hover over it:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-401 image-border" src="assets/53a034d3-e802-4b52-af58-a4f573e2cd92.png" style=""/></div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dragging an element</h1>
                </header>
            
            <article>
                
<p>We want to be able to update the data for a run by dragging the associated circle. To do this, we'll use a behavior, which you can think of as a combination of multiple event handlers. For a drag behavior, there are three callbacks:</p>
<ul>
<li class="mce-root">When the user starts to drag</li>
<li class="mce-root">Each time the user moves the cursor before releasing the <em>mouse</em> button</li>
<li class="mce-root">When the user releases the <em>mouse</em> button</li>
</ul>
<p class="mce-root">There are two steps whenever we create a behavior:</p>
<ol>
<li class="mce-root">Create the behavior</li>
<li class="mce-root">Attach the behavior to one or more elements</li>
</ol>
<p class="mce-root">Put the following code at the bottom of the <kbd>render()</kbd> function declaration:</p>
<div class="highlight highlight-source-js">
<pre><span class="pl-c">//put this code at the end of the render function</span>
<span class="pl-k">var</span> <span class="pl-en">drag</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">datum</span>){
    <span class="pl-k">var</span> x <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-c1">event</span>.<span class="pl-c1">x</span>;
    <span class="pl-k">var</span> y <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-c1">event</span>.<span class="pl-c1">y</span>;
    <span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-c1">this</span>).<span class="pl-en">attr</span>(<span class="pl-s"><span class="pl-pds">'</span>cx<span class="pl-pds">'</span></span>, x);
    <span class="pl-smi">d3</span>.<span class="pl-c1">select</span>(<span class="pl-c1">this</span>).<span class="pl-en">attr</span>(<span class="pl-s"><span class="pl-pds">'</span>cy<span class="pl-pds">'</span></span>, y);
}
<span class="pl-k">var</span> dragBehavior <span class="pl-k">=</span> <span class="pl-smi">d3</span>.<span class="pl-en">drag</span>()    
    .<span class="pl-en">on</span>(<span class="pl-s"><span class="pl-pds">'</span>drag<span class="pl-pds">'</span></span>, drag);
<span class="pl-smi">d3</span>.<span class="pl-en">selectAll</span>(<span class="pl-s"><span class="pl-pds">'</span>circle<span class="pl-pds">'</span></span>).<span class="pl-c1">call</span>(dragBehavior);</pre></div>
<p class="mce-root"/>
<p>You can now drag the circles around, but the data doesn't update:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-402 image-border" src="assets/67b77321-bf8a-4288-9d15-d6a4c0b814d2.png" style=""/></div>
<p>Let's examine how this code works:</p>
<pre>var drag = function(datum){<br/> var x = d3.event.x;<br/> var y = d3.event.y;<br/> d3.select(this).attr('cx', x);<br/> d3.select(this).attr('cy', y);<br/>}</pre>
<p>This <kbd>drag</kbd> function will be used as a callback anytime the user moves the cursor before releasing the mouse button. It gets the <em>x</em> and <em>y</em> coordinates of the mouse and sets the <kbd>cx</kbd> and <kbd>cy</kbd> values of the element being dragged (<kbd>d3.select(this)</kbd>) to those coordinates.</p>
<p>Next, we generate a drag behavior that will, at the appropriate time, call the <kbd>drag</kbd> function that was just explained:</p>
<pre class="mce-root">var dragBehavior = d3.drag()<br/> .on('drag', drag);</pre>
<p class="mce-root">Lastly, we attach that behavior to all the <kbd>&lt;circle&gt;</kbd> elements:</p>
<pre class="mce-root">d3.selectAll('circle').call(dragBehavior);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating data after a drag</h1>
                </header>
            
            <article>
                
<p>Now we're going to add functionality so that when the user releases the mouse button, the data for the run object associated with the circle being dragged gets updated.</p>
<p class="mce-root">First, let's create the callback function that will get called when the user releases the mouse button. Toward the bottom of the <kbd>render()</kbd> function declaration, add the following code just above <kbd>var drag = function(datum){</kbd>:</p>
<pre>var dragEnd = function(datum){<br/>    var x = d3.event.x;<br/>    var y = d3.event.y;<br/><br/>    var date = xScale.invert(x);<br/>    var distance = yScale.invert(y);<br/>   <br/>    datum.date = formatTime(date);<br/>    datum.distance = distance;<br/>    createTable();<br/>}</pre>
<p class="mce-root">Now attach that function to <kbd>dragBehavior</kbd> so that it is called when the user stops dragging a circle. Look at the following code:</p>
<pre>var dragBehavior = d3.drag()<br/>    .on('drag', drag);</pre>
<p class="mce-root">Change it to this:</p>
<pre>var dragBehavior = d3.drag()<br/>    .on('drag', drag)<br/>    .on('end', dragEnd);</pre>
<p class="mce-root">Now, once you stop dragging a circle around, you should see the data in the table change:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-404 image-border" src="assets/fb91edec-c98c-4727-831c-cdbbe73901e7.png" style=""/></div>
<p class="mce-root">Let's change the color of a circle while it's being dragged too. Add this to the bottom of <kbd>app.css</kbd>:</p>
<pre>circle:active {<br/>    fill: red;<br/>}</pre>
<p class="mce-root">When you drag a circle, it should turn red.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a zoom behavior that scales elements</h1>
                </header>
            
            <article>
                
<p>Another behavior we can create is the zooming/panning ability. Once this functionality is complete, you will be able to zoom in and out on different parts of the graph by doing one of the following:</p>
<ul>
<li class="mce-root">A two-finger drag on a trackpad</li>
<li class="mce-root">Rotating your mouse wheel</li>
<li class="mce-root">Pinching/spreading on a trackpad</li>
</ul>
<p class="mce-root">You will also be able to pan left, right, up, and down on the graph by clicking and dragging on the SVG element.</p>
<p class="mce-root">Put the following code at the bottom of <kbd>app.js</kbd>:</p>
<pre class="mce-root">var zoomCallback = function(){<br/>    d3.select('#points').attr("transform", d3.event.transform);<br/>}</pre>
<p class="mce-root">This is the callback function that will be called when the user attempts to zoom or pan. All it does is take the zoom or pan action and turn it into a <kbd>transform</kbd> attribute that gets applied to the <kbd>&lt;g id="points"&gt;&lt;/g&gt;</kbd> element that contains the circles. Now add the following code to the bottom of <kbd>app.js</kbd> to create the <kbd>zoom</kbd> behavior and attach it to the <kbd>svg</kbd> element:</p>
<pre class="mce-root">var zoom = d3.zoom()<br/>    .on('zoom', zoomCallback);<br/>d3.select('svg').call(zoom);</pre>
<p class="mce-root">Now, if we zoom out, the graph should look something like this:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-405 image-border" src="assets/4f8339f3-7079-4c6d-b9ca-34c4dd8cd3ee.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating axes when zooming and panning</h1>
                </header>
            
            <article>
                
<p>Now when we zoom, the points move in/out. When we pan, they move vertically/horizontally. Unfortunately, the axes don't update accordingly. Let's first add IDs to the <kbd>&lt;g&gt;</kbd> elements that contain them. Find the following code:</p>
<pre class="mce-root">var bottomAxis = d3.axisBottom(xScale);<br/>d3.select('svg')<br/>    .append('g')<br/>    .call(bottomAxis)<br/>    .attr('transform', 'translate(0,'+HEIGHT+')');<br/>var leftAxis = d3.axisLeft(yScale);<br/>d3.select('svg')<br/>    .append('g')<br/>    .call(leftAxis);</pre>
<p class="mce-root">Add <kbd>.attr('id', 'x-axis')</kbd> after the first <kbd>.append('g')</kbd>, and <kbd>.attr('id', 'y-axis')</kbd> after the second <kbd>.append('g')</kbd>:</p>
<pre class="mce-root">d3.select('svg')<br/>    .append('g')<br/>    .attr('id', 'x-axis') //add an id<br/>    .call(bottomAxis)<br/>    .attr('transform', 'translate(0,'+HEIGHT+')');<br/>var leftAxis = d3.axisLeft(yScale);<br/>d3.select('svg')<br/>    .append('g')<br/>    .attr('id', 'y-axis') //add an id<br/>    .call(leftAxis);</pre>
<p class="mce-root">Now let's use those IDs to adjust the axes when we zoom. Find this code:</p>
<pre class="mce-root">var zoomCallback = function(){<br/>    d3.select('#points').attr("transform", d3.event.transform);<br/>}</pre>
<p class="mce-root">Add the following to the end of the function declaration:</p>
<pre class="mce-root">d3.select('#x-axis')<br/>    .call(bottomAxis.scale(d3.event.transform.rescaleX(xScale)));<br/>d3.select('#y-axis')<br/>    .call(leftAxis.scale(d3.event.transform.rescaleY(yScale)));</pre>
<p class="mce-root">Now <kbd>zoomCallback</kbd> should look as follows:</p>
<pre class="mce-root">var zoomCallback = function(){<br/>    d3.select('#points').attr("transform", d3.event.transform);<br/>    d3.select('#x-axis')<br/>      .call(bottomAxis.scale(d3.event.transform.rescaleX(xScale)));<br/>    d3.select('#y-axis')<br/>      .call(leftAxis.scale(d3.event.transform.rescaleY(yScale)));<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root">There are two things to note about the previous code:</p>
<ul>
<li class="mce-root"><kbd>bottomAxis.scale()</kbd> tells the axis to redraw itself.</li>
<li class="mce-root"><kbd>d3.event.transform.rescaleX(xScale)</kbd> returns a value indicating how the bottom axis should rescale.</li>
</ul>
<p class="mce-root">Now when you zoom out, the axes should redraw themselves:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-683 image-border" src="assets/417da05e-d963-41e8-8051-efaf8fb4776d.png" style=""/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating click points after a transform</h1>
                </header>
            
            <article>
                
<p>Try zooming and panning and then clicking on the SVG to create a new run. You'll notice it's in the wrong place. That's because the SVG click handler has no idea that a zoom or pan has happened. Currently, if you click on the visual point, no matter how much you may have zoomed or panned, the click handler still converts it as if you had never zoomed or panned.</p>
<p class="mce-root">When we zoom, we need to save the transformation information to a variable so that we can use it later to figure out how to properly create circles and runs. Find the <kbd>zoomCallback</kbd> declaration and add <kbd>var lastTransform = null</kbd> right before it. Then add <kbd>lastTransform = d3.event.transform;</kbd> to the beginning of the function declaration. It should look as follows:</p>
<pre class="mce-root">var lastTransform = null; //add this<br/>var zoomCallback = function(){<br/>    lastTransform = d3.event.transform; //add this<br/>    d3.select('#points').attr("transform", d3.event.transform);<br/>    d3.select('#x-axis')<br/>      .call(bottomAxis.scale(d3.event.transform.rescaleX(xScale)));<br/>    d3.select('#y-axis')<br/>      .call(leftAxis.scale(d3.event.transform.rescaleY(yScale)));<br/>}</pre>
<p class="mce-root">Now whenever the user zooms or pans the transformation data that was used to shrink or move the SVG and axes is saved in the <kbd>lastTransform</kbd> variable. Use that variable when clicking on the SVG.</p>
<p class="mce-root">Find these two lines at the beginning of the SVG click handler:</p>
<pre class="mce-root">var x = d3.event.offsetX;<br/>var y = d3.event.offsetY;</pre>
<p class="mce-root">Change them to the following:</p>
<pre class="mce-root">var x = lastTransform.invertX(d3.event.offsetX);<br/>var y = lastTransform.invertY(d3.event.offsetY);</pre>
<p class="mce-root">Your click handler should look like this now:</p>
<pre class="mce-root">d3.select('svg').on('click', function(){<br/>    var x = lastTransform.invertX(d3.event.offsetX); //adjust this<br/>    var y = lastTransform.invertY(d3.event.offsetY); //adjust this<br/><br/>    var date = xScale.invert(x)<br/>    var distance = yScale.invert(y);<br/><br/>    var newRun = {<br/>        id: ( runs.length &gt; 0 ) ? runs[runs.length-1].id+1 : 1,<br/>        date: formatTime(date),<br/>        distance: distance<br/>    }<br/>    runs.push(newRun);<br/>    createTable();<br/>    render();<br/>});</pre>
<p class="mce-root">But now click before any zoom is broken, since <kbd>lastTransform</kbd> will be null:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-684 image-border" src="assets/52d68c60-c500-4915-b9be-520ce67590bc.png" style=""/></div>
<p class="mce-root">Find the code that we just wrote for the SVG click handler:</p>
<pre class="mce-root">var x = lastTransform.invertX(d3.event.offsetX);<br/>var y = lastTransform.invertY(d3.event.offsetY);</pre>
<p class="mce-root">Adjust it so it looks as follows:</p>
<pre class="mce-root">var x = d3.event.offsetX;<br/>var y = d3.event.offsetY;<br/><br/>if(lastTransform !== null){<br/>    x = lastTransform.invertX(d3.event.offsetX);<br/>    y = lastTransform.invertY(d3.event.offsetY);<br/>}</pre>
<p class="mce-root">Now initially, <kbd>x</kbd> and <kbd>y</kbd> are set to <kbd>d3.event.offsetX</kbd> and <kbd>d3.event.offsetY</kbd>, respectively. If a zoom or pan occurs, <kbd>lastTransform</kbd> will not be null, so we overwrite <kbd>x</kbd> and <kbd>y</kbd> with the transformed values.</p>
<p class="mce-root">Add a new run initially:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-408 image-border" src="assets/f608ba1d-85ba-43c6-9a9e-76b30938368e.png" style=""/></div>
<p class="mce-root"/>
<p>Now pan right and add a new point:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-409 image-border" src="assets/d3a91e10-aed0-4c4e-b258-2cd9482d7f41.png" style=""/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Avoiding redrawing the entire screen during rendering</h1>
                </header>
            
            <article>
                
<p>At the moment, every time we call <kbd>render()</kbd>, we wipe all <kbd>&lt;circle&gt;</kbd> elements from <kbd>&lt;svg&gt;</kbd>. This is inefficient. Let's just remove the ones we don't want</p>
<p class="mce-root">At the top of the <kbd>render()</kbd> function, assign <kbd>d3.select('#points').selectAll('circle').data(runs)</kbd> to a variable, so we can use it later. This helps preserve how DOM elements are assigned to data elements in the next sections. Find this at the top of the <kbd>render()</kbd> function declaration:</p>
<pre class="mce-root">d3.select('#points').html('');<br/>d3.select('#points').selectAll('circle')<br/> .data(runs)<br/> .enter()<br/> .append('circle');</pre>
<p class="mce-root">Change it to this:</p>
<pre class="mce-root">d3.select('#points').html('');<br/>var circles = d3.select('#points')<br/> .selectAll('circle')<br/> .data(runs);<br/>circles.enter().append('circle');</pre>
<p class="mce-root">Next, remove the <kbd>d3.select('#points').html('');</kbd> line. We'll use <kbd>.exit()</kbd> to find the selection of circles that haven't been matched with data, and then we'll use <kbd>.remove()</kbd> to remove those circles. Add the following after the last line we just wrote (<kbd>circles.enter().append('circle');</kbd>):</p>
<pre class="mce-root">circles.exit().remove();</pre>
<p class="mce-root">Reload the page, click on the center (second) circle. You'll notice it looks as if the circle disappears, and the circle in the upper-right briefly gains a hover state and then shrinks back down. That's not really what's happening.</p>
<p class="mce-root">If we click on the middle circle (second), it deletes the second run object in the <kbd>runs</kbd> array, and the third run object moves down to replace it in second place. We now only have an array of two run objects: the first and what used to be the third (but is now the second). When <kbd>render()</kbd> gets called again, what was the middle (second) circle gets assigned to what used to be the third run object in the <kbd>runs</kbd> array (but is now the second). This "run" object used to be assigned to the third circle, which was in the upper right. But now, since there are only two runs, that third (upper-right) circle gets deleted when we call <kbd>circles.exit().remove();</kbd>. The second circle's data has changed now, and it jumps to the upperâ€“right corner to match that data. It used to have a hover state, but all of a sudden it's moved out from under the cursor, so it shrinks back down to normal size and becomes black.</p>
<p class="mce-root">To avoid these effects, we need to make sure that each circle stays with the data it used to be assigned to when we call <kbd>render()</kbd>. To do this, we can tell D3 to map <kbd>&lt;circles&gt;</kbd> to datum by ID, rather than index, in the array. At the top of the <kbd>render()</kbd> function, find this code:</p>
<pre class="mce-root">var circles = d3.select('#points')<br/> .selectAll('circle')<br/> .data(runs);</pre>
<p class="mce-root">Change it to this:</p>
<pre class="mce-root">var circles = d3.select('#points')<br/> .selectAll('circle')<br/> .data(runs, function(datum){<br/> return datum.id<br/>});</pre>
<p class="mce-root">This tells D3 to use the <kbd>id</kbd> property of each run object when determining which <kbd>&lt;circle&gt;</kbd> element to assign the data object to. It basically assigns that <kbd>id</kbd> property of the run object to the <kbd>&lt;circle&gt;</kbd> element initially. That way, when the second run object is deleted, <kbd>circles.exit().remove();</kbd> will find the circle that had the corresponding ID (the middle circle) and remove it.</p>
<p class="mce-root">Now clicking on the middle circle should work correctly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hiding elements beyond an axis</h1>
                </header>
            
            <article>
                
<div class="highlight highlight-source-css">
<p>If you pan or zoom extensively, you'll notice that the circles are visible beyond the bounds of the axes:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-410 image-border" src="assets/7e7f4115-4706-447c-81ef-108d3f6384f6.png" style=""/></div>
<p class="mce-root">To hide elements once they get beyond an axis, we can just add an outer SVG with <kbd>id="container"</kbd> around our current <kbd>&lt;svg&gt;</kbd> element in <kbd>index.html</kbd>:</p>
<pre class="mce-root">&lt;svg id="container"&gt;<br/>    &lt;svg&gt;<br/>        &lt;g id="points"&gt;&lt;/g&gt;<br/>    &lt;/svg&gt;<br/>&lt;/svg&gt;</pre>
<p class="mce-root">Now replace all <kbd>d3.select('svg')</kbd> code with <kbd>d3.select('#container')</kbd>. You can perform a find-and-replace. There should be five instances to change:</p>
<pre>d3.select('#container')<br/>    .style('width', WIDTH)<br/>    .style('height', HEIGHT);<br/><br/>//<br/>// lots of code omitted here, including render() declaration...<br/>//<br/><br/>var bottomAxis = d3.axisBottom(xScale);<br/>d3.select('#container')<br/>    .append('g')<br/>    .attr('id', 'x-axis')<br/>    .call(bottomAxis)<br/>    .attr('transform', 'translate(0,'+HEIGHT+')');<br/><br/>var leftAxis = d3.axisLeft(yScale);<br/>d3.select('#container')<br/>    .append('g')<br/>    .attr('id', 'y-axis')<br/>    .call(leftAxis);<br/><br/>//<br/>// code for create table omitted here...<br/>//<br/><br/>d3.select('#container').on('click', function(){<br/>    //<br/>    // click handler functionality omitted<br/>    //<br/>});<br/><br/>//<br/>// zoomCallback code omitted here<br/>//<br/><br/>var zoom = d3.zoom()<br/>    .on('zoom', zoomCallback);<br/>d3.select('#container').call(zoom); </pre>
<p class="mce-root">And, lastly, adjust CSS to replace <kbd>svg {</kbd> with <kbd>#container {</kbd>:</p>
<pre class="mce-root">#container {<br/>    overflow: visible;<br/>    margin-bottom: 50px;<br/>}</pre>
<p class="mce-root">Now circles should be hidden once they move beyond the bounds of the inner <kbd>&lt;svg&gt;</kbd> element:</p>
<div class="CDPAlignCenter CDPAlign"><img class="aligncenter size-full wp-image-411 image-border" src="assets/dcd8d68a-e9c3-46e7-b424-3112e3fa41cc.png" style=""/></div>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we've learned the basics of D3 and have created a fully interactive scatter plot. In the next chapter, we'll learn how to use AJAX to make an asynchronous request that will populate a bar graph.</p>


            </article>

            
        </section>
    </body></html>