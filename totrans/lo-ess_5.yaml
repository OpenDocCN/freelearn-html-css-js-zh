- en: Chapter 5. Assembling Chains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the examples we've looked at in this book used Lo-Dash functions independently
    of one another. That's not to say they're not working together; it's just that
    they could be cleaner, or more condensed. We would call the function to compute
    a value, store that value, call another function to compute a new value using
    the stored value as an argument, and repeat the same process. This is exhausting
    but can be easily remedied.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to streamline this functionality into a chain of calls. This approach
    follows the concept of applicative programming, whereby we have a starting collection
    and at each stage in the chain, that collection is transformed. It's like an assembly
    line where the resulting product is a value that you need in a given context.
  prefs: []
  type: TYPE_NORMAL
- en: Lo-Dash enables this mode of programming through the wrapper concept—a constructor
    function used to wrap primitive values that enable chained function calls. In
    this chapter, we'll see how we can use this approach to simplify complex code
    and even produce reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Lo-Dash wrappers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building filters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing truth conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counting items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transformations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Intermediary results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys and values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning chains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Lo-Dash wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll introduce the concept of wrapping values. Then we'll
    use the wrapper to chain function calls. We'll also look at how call chains are
    terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Chained calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chaining function calls together is a pattern of applicative programming, where
    a collection is transformed into something different. This newly transformed collection
    is then passed to the next call in the chain, and so on. This is where the term
    applicative comes from; you're applying functions to every item in a collection.
    Since this process is repeated over and over, it's easy to package chained calls
    into a reusable component. It's a pipeline that's adding, removing, or modifying
    values along each step of the way, producing a result at the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way, perhaps, is a more practical view of chains, which is just a simpler
    way to make function calls. jQuery popularized this notion. When reading jQuery
    code, you''ll find that there are a lot of chained calls, and yet the code is
    readable. Often, chains can be built as a single statement, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This jQuery chain consists of four calls, expressed as a single statement. The
    first call is to the jQuery constructor, which wraps the specified DOM elements.
    Next, we call `children()` to get the child elements. The `first()` function returns
    the first child element. The chain is terminated with a call to `is()`, which
    returns a simple Boolean value, not a jQuery object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Take note of the code formatting here. If you're going to compose chains of
    functionality, it is important to keep your code readable. The main convention
    that I would recommend to follow is to indent chained calls on the next line.
    This way, you don't have statements that span an obnoxious number of columns,
    and you can tell at a glance that this chunk of code is a chain of function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wrapping values in Lo-Dash works pretty much the same as with jQuery. There's
    a wrapper call that constructs the jQuery/Lo-Dash object. Each **chainable** call
    returns a wrapper object. There's a terminating call that returns a primitive
    type. There are some obvious differences too, with regard to how jQuery and Lo-Dash
    wrap values. For instance, you can't pass a CSS selector string to the Lo-Dash
    wrapper function and expect it to wrap DOM elements. Nor would you want it to—Lo-Dash
    is a low-level utility library, whereas jQuery works at a fundamentally higher
    level of abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s not the whole story of how wrapping values and applying function call
    chains work. There are subtle nuances and edge cases around every corner, all
    of which we''ll address over the course of the chapter. But for now, let''s get
    into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here is our hello-world chain. The `_` object we've been using throughout the
    book to access the Lo-Dash API is also a constructor function. It takes a JavaScript
    primitive as an argument. This is the value that's wrapped and passed to the first
    function call in the chain. Here, we're calling the `at()` function, saying that
    we want the items at indices `1` and `2`. The call to `value()` gets us the result
    we're after.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code obviously doesn''t warrant using a wrapper—there''s only
    one function call. The point, however, isn''t conciseness but rather the basic
    anatomy of a call chain. As we get to more elaborate examples throughout the chapter,
    we''ll see how chains substantially reduce the amount of code written. Here are
    two more Lo-Dash wrapper constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first wrapper uses a plain object as its primitive value. The second wrapper
    uses a string. The chain is terminated immediately in both cases because we're
    calling `contains()`, which itself returns a primitive Boolean value. Again, we
    didn't have to write the preceding code using wrappers and call chains. It's better
    that you don't if you're calling only one function, since you'd only be confusing
    other readers of your code otherwise. The point of the preceding code is to illustrate
    that we can wrap both plain objects and strings and treat them as collections.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit and implicit chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we have a Lo-Dash wrapper instance, we can start making chained function
    calls. However, not all of these functions are chainable. **Non-chainable** functions
    return primitive values such as Booleans or numbers. This is what is referred
    to as implicit chaining. It's implicit because functions that would return a collection
    actually return a Lo-Dash wrapper instance. Other functions don't have collections
    as return values. Calls to these functions will terminate the chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, there''s explicit chaining—this will keep the chain alive
    until it''s explicitly terminated by calling `value()`. For example, if your chain
    is explicit, calling `contains()` will return a wrapper, instead of a Boolean
    as it normally would. The following are examples of implicit and explicit chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first chain uses the default Lo-Dash chaining configuration. The `first()`
    function grabs the first item in an array and returns it. Since this item could
    be anything (in this case, it's a number), the `first()` function isn't chainable.
    We don't need to make an explicit call to `value()` since functions that aren't
    chainable return **unwrapped** values. The second chain, however, uses explicit
    chaining. This is done by constructing the Lo-Dash wrapper instance with the `chain()`
    function. The resulting wrapper is the same in every way, except that we need
    to make an explicit call to `value()` to unwrap the value. With explicit chaining,
    every function is chainable. For example, the call to `first()` now returns a
    wrapper instance instead of a number. This is also done by `isNumber()`.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason you would want to use explicit chains like this is to avoid
    temporary variables and additional statements after the chain is complete. In
    the explicit chain in the preceding code, for instance, we just need to know whether
    the first item in the sorted collection is a number or not. There's no need to
    store the first item in a new variable if we can get exactly what we're after
    from the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Building filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A powerful use of chained function calls is building filters that successively
    filter out unwanted items from a larger collection. Let's say that you already
    have a piece of code that's using the `filter()` function on a collection. But
    now you need to alter that filtering operation, perhaps by adding additional constraints.
    Rather than messing around with the existing `filter()` code that you know works,
    you can build a filter chain.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple filter() calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest approach to assembling filter chains is to join together multiple
    calls to the `filter()` function. Here''s an example of what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first call to `filter()`uses the pluck-style shorthand on the `enabled`
    property, which filters out items with false values for this property. The next
    call to `filter()` uses a callback function that filters out items where the `age`
    property value is less than `21`. We're left with a single item, which is unwrapped
    by calling `value()`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So what's the point of two or more calls to `filter()` when we could just modify
    the callback function? Wouldn't that mean less code and faster execution? The
    real advantage is in reading and modifying this code. Do we want to see what happens
    when we remove the enabled filter? Just comment out the line. Readability and
    maintainability should almost always trump attempts to squeeze performance out
    of complicated callback functions. Of course, there are exceptions to this, but
    don't invent performance issues for the sake of it.
  prefs: []
  type: TYPE_NORMAL
- en: Combining filter() with where()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `where()` function is an expressive means to filter a collection using
    logical `and` conditions. Rather than trying to express all of your query constraints
    in a single `filter()` callback function, why not utilize the `where()` notation
    where it makes sense? Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This filter will include all female items and is a good candidate for the `where()`
    function. Next, we'd like to make sure that all items have an `age` property whose
    value is a finite number. We do this by composing a callback function that's passed
    to `filter()`. We're utilizing a couple of shortcuts here instead of defining
    our own inline callback function. The `flow()` function will construct a function
    for us, letting the result flow to each function argument we give it. We use the
    `property()` function to build a function that gets us the `age` property for
    each item, and gets passed to the `isFinite()` function. There are a couple of
    items in our collection that don't have `age` properties. These undefined values
    don't pass the test and are filtered out.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ordering of chained filter functions can be important. For example, it's
    wise to filter broadly first. That way, your collection shrinks in size faster
    as it flows through the pipeline, which means less work for other functions. Where
    this matters isn't immediately apparent, but as your code matures, you'll start
    to notice ordering tweaks. The nice thing about chained structures in your code
    is that order changes are trivial.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping and taking collection items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lo-Dash has tools that let us filter collections from either the beginning
    or the end of a collection. These tools are especially useful in the context of
    function call chains, since using them usually depends on a prior transformation
    of the collection. For example, consider the sort order in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first call in this chain sorts the collection by the `first` property using
    the `sortBy()` function. Now that the collection is sorted, we can call `dropWhile()`.
    Starting from the left-hand side, this function drops items from the collection
    until the callback returns `true`. Our particular callback gets the first character
    of the name string, and if it is less than `F`, we drop it. This leaves us with
    a collection that only has first names starting with `F` and above.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to dropping items from the left-hand side of the collection, we
    can drop items from the right-hand side. Alternatively, we can combine the two
    approaches using a chain, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're wrapping a string value instead of an array, emulating the functionality
    of `String.trim()`. So the first task for our chain is to use `toArray()` to split
    the string into individual characters. The drop functions expect an array. Next,
    we use the `dropWhile()` function and pass it our `emptyString()` callback function.
    This will drop characters from the string until it finds an actual character.
    It then uses `dropRightWhile()` to perform the same task but from the opposite
    side of the array, moving in the opposite direction. Lastly, we join the array
    back together as a string, minus the empty characters that have been dropped from
    either end.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yes, you can get the same result using a regular expression and condensed code.
    Regular expressions are great, but they're not for everyone, and they only work
    with strings. Weigh your options before going in either direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can perform the inverse of dropping items from either end of an array. We
    can take items, thus dropping everything else. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We're only interested in items with `A` grades. The callback function we're
    using with `takeWhile()` returns `true` for items that have an `A`. Of course,
    this only works because the first step in the chain was to sort the array by the
    `grade` property. Had we not done that first, we would end up missing the items
    we're looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Items can also be taken from the collection in the opposite direction. That
    is, instead of moving from left to right, we move from right to left. This is
    ideal when ordering is important and you don''t want to perform additional steps
    to take what you need from the collection. This ordering is shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The collection used here is a random sampling of 10 integers. The first call
    in our chain is to `sortBy()`, which simply sorts the array with no arguments
    supplied. This is in ascending order and we want the top five items. We could
    have reversed the sort order, but instead, we're skipping that step and jumping
    right into the `takeRightWhile()` function. The callback used here will return
    numbers as long as the number is larger than `min` and as long as we haven't exceeded
    the total.
  prefs: []
  type: TYPE_NORMAL
- en: Rejecting items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rejecting works much in the same way as filtering does. In the case of filtering,
    you know what you want. In the case of rejecting, you know what you don''t want.
    These rejection operations can be chained together to build complex queries, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we're chaining together two `reject()` calls. The wrapped value is an object
    and we're only after those property values that aren't Booleans or strings. These
    functions—`isBoolean()` and `isString()`—already exist as a part of the Lo-Dash
    API, and we can just pass them directly to `reject()`. There's no need to write
    our own callback functions here.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `result()` function to help us reject collection items in a
    chain. The `result()` function works in the same way, whether the specified property
    value is a function or a non-callable value. Here''s an illustration of the differences
    in calling `reject()` using `result()` or just a property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `User` instances have a `disabled` property, and the `enabled()` method
    returns `true` if `disabled` is false. The `collection` variable holds an array
    of these `User` instances. The `enabled()` function is something we construct
    ourselves. We'll use it as a callback with `reject()`. This function uses `result()`
    to get the `enabled()` value from each item in the collection. The `identity()`
    function is used here as a trick to get `partialRight()` to work as a callback
    for `reject()`.
  prefs: []
  type: TYPE_NORMAL
- en: Using initial() and rest()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `initial()` function takes everything but the last element—this can be
    combined with chained operations in interesting ways. For example, let''s say
    we have a simple string we need to clean up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If we know the string is always going to end with something we don't care about,
    this is an easy way to drop that off. The same code works with arrays too; we're
    not limiting ourselves to strings. For example, the `slice()` function is a part
    of the chain and it makes the chain work with strings. If we passed an array,
    `slice()` wouldn't have any impact—the same code would still work. However, we
    might want to remove it later on, along with the `join()` call. Given the way
    our chain code is formatted, this is simple to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inverse of `initial()` is `rest()`—it takes everything in the array but
    the first item. Just like the case in which we don''t care about the last item,
    there could be cases where we don''t care about the first item. An illustration
    of using `rest()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This collection has objects with `task()` methods. The collection is ordered,
    so the first task is always going to be the `init` task, which we don't care about
    because it's a `noop()` function. We test this by chaining `invoke()` to the `rest()`
    function, which if all goes well, we should end up with an array of random numbers,
    and no undefined values.
  prefs: []
  type: TYPE_NORMAL
- en: Testing truth conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond simply filtering collections, you often need to test a condition of a
    collection. This could include filtering a collection, and then answering a simple
    yes/no about the results. In those cases where you need to check a truth condition
    of a collection, it's often easier to perform the test at the end of a chain.
    There's usually no need to write several statements and allocate several variables
    along the way.
  prefs: []
  type: TYPE_NORMAL
- en: Testing if a collection contains an item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perhaps, the most straightforward test we can perform is whether or not a collection
    contains an item we''re looking for. The `contains()` function is handy in cases
    like these because it is easy to attach to the end of a chain that''s performing
    some other operations beforehand. One use of `contains()` is shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There are two collections in the code—a string and an array. Both chains that
    follow are identical, aside from wrapping different values. However, both return
    `true` in this case, since the string has `c` and so does the array.
  prefs: []
  type: TYPE_NORMAL
- en: It's always good practice to use functions such as `contains()` if all you care
    about is testing for the item's existence. These functions will stop looping early,
    or short-circuit, if a value is found, saving valuable CPU cycles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you don''t have the exact value. Instead you have query constraints
    but you''re still only interested in whether they''re satisfied, and not the data
    itself. This can be accomplished using the `find()` and `filter()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The first chain in this code is for a string value. Notice how we've used `chain()`
    here to enable explicit chaining—meaning we'll have to explicitly call `value()`
    at the end to unwrap the result. The `filter()` call here returns items that match
    `A`. We do this so that we can count how many of them there are in the chain.
    In this case, the string passes the test because there are two `A` characters.
    The downside is that we're looking for an exact number—`2`. The `filter()` function
    will keep filtering away long after we've found two items.
  prefs: []
  type: TYPE_NORMAL
- en: The second chain uses a wrapped array. Here we're transforming the result of
    calling `find()` into a Boolean value. Here we're able to use more elaborate query
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Everything or anything is true
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our final look at checking truth conditions in this chapter involves validating
    either one item at least or the collection in its entirety. That is, a collection
    might be considered valid if one or more items pass the test we give it. Or perhaps
    the requirements are more stringent and every item in the collection must pass
    the test in order to be considered valid. Let''s see how these tests can be used
    in chains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This collection contains timestamp numbers, and so the first call in the chain
    is to `map()`, transforming each collection item into a `Date` instance. Now that
    every item is a date, we can use `every()` to validate that in this collection,
    every day is Halloween.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s look at using the `some()` function to terminate a chain. This will
    validate that at least one item passes the test and will stop looping as soon
    as one is found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can see that after rejecting `Ember` and `Angular` enthusiasts, we make
    sure that there's at least one `Backbone` or `Marionette` programmer who is at
    least `25` years old.
  prefs: []
  type: TYPE_NORMAL
- en: Counting items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A variation on the previous topic—*Testing truth conditions*—is counting items
    in a collection after their values have moved through a processing chain. For
    example, we might need to know how many items in a collection meet the given criteria.
    We can get that number using a call chain.
  prefs: []
  type: TYPE_NORMAL
- en: Using length and size()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `size()` function is handy because we can call it directly on a Lo-Dash
    wrapper. This is the preferred way to count the resulting items in our collection
    after our chain runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have `array` and `object`. The first chain uses the `size()` function
    to count the number of properties after omitting the `first` property. The second
    chain wraps the array and, after dropping `5` items, counts what's left.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the `length` property, but we have to call `value()` first. Using
    `size()` is just a shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping using countBy()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also count more than one item. That is, given a collection, we can divide
    it into groups and then count the number of items in each group. Using chains,
    we can write some fairly sophisticated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This chain kicks off by grouping the collection by the `gender` property. Next,
    we use the `pairs()` function to get an array of arrays. We do this so that we
    can sort the groups by the number of items in them. With the collection sorted,
    we can pluck the values we're interested in. In this case, the `f` gender is first
    since that group has a higher count.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code uses two interesting tricks. Firstly, we're passing a numerical
    index to the `sortBy()` function. Since keys are accessed in the same way as indices,
    this works as expected. Secondly, we're passing a numerical index to the `pluck()`
    function and this works for the same reason as the `sortBy()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our final approach to counting items in chaining operations is to reduce the
    collection. This is useful when you want to reduce the entire collection to a
    sum computed using more involved functions that are applied to each item. Collections
    can be reduced with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''re plucking the `skills` property from each item in the collection.
    We''re interested in knowing two things about the `skills` value: does it contain
    the string `grunt`? And does it have more than `2` items? If these criteria are
    met, then we increment the reduced sum value that''s returned by the `reduce()`
    call.'
  prefs: []
  type: TYPE_NORMAL
- en: Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time for us to look at transformations that happen to data as it passes
    through the processing pipelines we construct. What's interesting about Lo-Dash
    and how it transforms data in chains is that the original collection isn't modified—a
    new one is constructed. This reduces side effects and is fundamental to the immutability
    concept in other functional programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Building groups, unions, and unique values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the most powerful transformation tools found in Lo-Dash can be used
    out of the box with very little effort. These include grouping collection items
    by a specific value they contain, joining arrays together while retaining only
    unique values, and removing any duplicates from arrays. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This chain wraps a collection of plain objects, and the first call in the chain
    maps the `item` object to an extended version of it. We're calculating a string
    version of their `experience` property and assigning that to a new property. Next,
    we use the `groupBy()` function to group the collection by this new `experience`
    property. The last step in this chain is to use `map()` again to generate a string
    representation of the various experience groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `union()` to join arrays together can come in handy if you''ve already
    got a wrapped array and you need to ensure it has certain values, but also ensure
    that those values aren''t duplicated. The application of `union()` is shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can see that our wrapped array, a sampling of 10 random numbers, is joined
    with another array using the `union()` function. We then return the sorted result.
    If you examine the output, you'll notice it'll always have `25`, `50`, and `75`.
    You'll also notice that these numbers are never duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you have a collection of values and you just need the duplicates
    removed, the `uniq()` function allows you to do that as a step in your chained
    processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We're seeing three different approaches to extracting the unique values from
    the wrapped collection. The first uses the pluck-style shorthand to filter out
    duplicates. Since we passed it the string `last`, it'll look for unique values
    in this property. The second approach passes in a callback function, which joins
    together the `first` and the `last` name properties. Note that this same function
    is used by the `sortBy()` call in the same chain. The last approach doesn't pass
    any arguments to `uniq()` because the first step in the chain maps our array of
    objects to an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Plucking values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Often, within your chains of functionality, you''ll realize that you don''t
    need the entirety of every object in your collection. This can make what you''re
    doing later on in the chain much simpler. To pluck values, the following code
    can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're plucking the `dob` property values and this simplifies the `map()`
    handler that follows in the chain. Instead of having to look up the `dob` property,
    the item itself is the `dob` property value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating arrays using without()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we need a new array constructed and there are certain values we know should
    not be present as items, we can use the `without()` function. This is typically
    the first action in a chain, since it creates a new array, but it''s not always
    the first. Let''s see an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The wrapped collection in this code includes the numbers `1` through `10`. The
    first call in our chain copies the items out of this array and places them in
    a new array, aside from the argument values passed to the `without()` function.
    These are not included in the new array.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the min and max values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With every collection, there''s a minimum and a maximum value. Finding these
    values with Lo-Dash is easy; you just have to use the respective `min()` and `max()`
    functions. But what if you need to adjust the range for which you''re seeking
    out the minimum values? Let''s use the following code to perform this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we're not concerned with items that have a `win` count of less
    than `5`. So we know that the absolute minimum returned by this code will have
    `5` wins or more. After the invalid `win` counts have been rejected, we use the
    pluck style shorthand to find the minimum value based on the `wins` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `max()` function can be used as a chain operation in a similar fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This collection has objects with the `balance` and `credit` properties. The
    first two chain operations use the `filter()` function to remove objects where
    either of these fields is false. The `max()` function then closes the chain. This
    time, we're using a callback function that allows us to map the values we want
    to compare in order to figure out the maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding the index of a given element has its uses, and we can apply the `index()`
    function as a step in a call chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `rank()` function in this code accepts a `collection` argument and a `name`
    string. The function wraps the collection and uses a call chain to figure out
    the rank of the passed-in name, based on the `score` property. The first step
    is to sort the collection and then to reverse it so that it's in descending order
    based on the `score` property value. Next, we pluck the names from the collection,
    using the `pluck()` function, which maintains the sort order we just created.
    Now we can use `indexOf()` to figure out the rank of the given user.
  prefs: []
  type: TYPE_NORMAL
- en: Using difference() and xor()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last section of the transformations topic is using the `difference()` and
    the `xor()` functions to merge together the contents of two arrays. Both work
    similarly but with subtle differences that are worth noting and paying attention
    to. These functions are useful at the start of chains where you have to make sure
    that the wrapped array has only the necessary values. For example, let''s say
    your array of numbers shouldn''t have any odd values. Then we can use the following
    code for this condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Our collection in this code consists of `50` numbers and the `odds` array contains
    odd numbers from `1` to `100`. Our chain starts off by calling the `difference()`
    function, passing in the `odds` array as an argument. Next, we take the top 10
    items from the resulting array and sort them. The thing to notice about the result
    is that there are no values above 50 present. We''ve removed all odd numbers below
    50, since that is the difference between the wrapped array and the array that
    was supplied as an argument. In other words, it''s not a symmetrical difference.
    For that, we would use the `xor()` function in our chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This time, our collection is an array of numbers from `1` to `25` and the `evens`
    array holds even numbers from `2` to `50`. We're using the `xor()` function in
    our chain to join the collection with the `evens` array. The difference between
    this and the `difference()` function is that it'll include all the values in the
    `evens` array that go beyond `25`, since `xor()` will compute the symmetrical
    difference.
  prefs: []
  type: TYPE_NORMAL
- en: Intermediary results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are times when we don't want to wait until the call chain is terminated
    to have access to values computed at any given step along the way. Think about
    cases where the intermediate value produced by a function in the chain should
    be used by another function later in the chain. On other occasions, we need to
    completely override the value returned by the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Tapping into chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `tap()` function to inject our own callback function into the
    chain. This is different from the callbacks that we''d supply to other Lo-Dash
    functions. It doesn''t alter the value as it flows through the chain of function
    calls. Instead, think of `tap()` as a way of intercepting values as they flow
    through the chain, and possibly reacting to them in some way. Let''s see an example
    of this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This code wraps our collection and filters out items younger than 30\. Next,
    we use a `tap()` callback to set up our `min` and `max` variables. Note the scope
    of these variables; they're defined outside the chain, and are thus accessible
    to any future callbacks in the chain. And that's what we're doing here—we're rejecting
    any items where the `age` property equals the `max` age found. Note that the `max`
    value could turn out differently had we not computed it after the first filter
    in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The only downside to this approach is that our chain is no longer a tightly
    encapsulated unit that can be moved around in our code. However, the trade-off
    is that we can elegantly compute the values needed for our chain on the fly. Something
    to keep in mind anyway, different programming styles may lean closer to one direction
    than others.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other approach to manipulating what chains return at runtime is by using
    the `thru()` function. It behaves just like `tap()` but whatever is returned by
    this function becomes the new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This chain is kicked off using the `thru()` function callback to validate the
    minimum size of the collection. If it is less than `5`, we don't even have to
    bother—we just return an empty array. It's important that we return something
    that'll work with the remaining chained functions, and an empty array fits the
    bill nicely. We're simply using `thru()` to state that any length less than `5`
    should have the same meaning as an empty array. This function is actually an ideal
    place in which to inject these nuanced business rules that often surface well
    after code is written.
  prefs: []
  type: TYPE_NORMAL
- en: Keys and values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to turn our attention to object keys and values and how they can
    be used in function call chains. Often, these involve wrapping a plain object
    in a Lo-Dash instance and then using the `keys()` or `values()` functions to bootstrap
    the processing. There are also times when you have a collection of objects and
    you want to work with certain property values only. For this purpose, there are
    the `pick()` and `omit()` functions that can be exercised in chains.
  prefs: []
  type: TYPE_NORMAL
- en: Filtered keys and values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the result of a filtered array of object keys at a later point in
    the chain. This comes in handy when we''re not exactly sure which keys are available
    and we only have a best guess. Let''s try filtering by keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The object we''re wrapping has two property names that end in `name`. So we
    use the `keys()` function as the first step in the chain to grab all keys, and
    then we filter out the ones that don''t end in `name`. Next, we use the `thru()`
    function to return the object property values that correspond to our key filter
    results. Similar actions can take place with object property values, especially
    when there''s not much need to use keys. Let''s look at an example of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This chain grabs the property values of the wrapped object and filters out anything
    that's not a date. Then the `Date` objects found get mapped to an array of strings.
  prefs: []
  type: TYPE_NORMAL
- en: Omitting and picking properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Picking certain object properties to use, as well as those to omit, has its
    uses in chains, especially when the wrapped value is a plain object and based
    on some criteria, there are certain properties we don''t care to use. For example,
    we might have a collection that we want to transform into an indexed object, but
    along the way, we need to pick or omit values that should or shouldn''t be there,
    respectively, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This code indexes the array of objects by the `last` property value. The next
    step in the chain is to pick only items that have an `age` greater than `34`.
    Finally, since each item is indexed by the last name, we don't need the `last`
    property any more, so the `transform()` function uses `omit()` to get rid of it
    for each item, which is the last step in the chain.
  prefs: []
  type: TYPE_NORMAL
- en: Returning wrappers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Wrappers and the function call chains that follow don''t exist randomly throughout
    our code. The next chapter covers this topic in more depth, so consider this as
    a teaser. So far, we''ve only looked at chains as they''re constructed and executed
    in the same statement. However, if we''re going through all the trouble of designing
    a call chain that serves a general purpose, wouldn''t it be good not to keep assembling
    that chain? Let''s design the chain with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `best()` function defined here returns a Lo-Dash wrapper instance. Notice
    that inside `best()`, we're actually chaining together function calls but none
    of them are actually called, which means that the return value of `best()` is
    a wrapper. This is illustrated by the `bestScrore` variable, which holds a wrapper
    instance. This wrapper can be called again and again without the need to reconstruct
    the function call chain. Nevertheless, if we need to tweak the chain slightly,
    we can build on it. We're doing this with `bestScore` by calling `reverse()` and
    `pluck()`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced the concept of wrapped values and the function call
    chains applied to them. This versatile programming model, fundamental to Lo-Dash,
    assists in building complex chunks of functionality using compact and legible
    code. Chained calls aren't unique to Lo-Dash—they're popular in many other libraries,
    perhaps mostly so in jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: Applications are faced with the tough job of filtering data—lots of data and
    lots of hard constraints. Instead of creating messy code with lots of temporary
    variables, we addressed several ways to construct complex filters using chains.
    After that, we looked at testing truth conditions using chains. These are like
    filters, except they don't return collection results but only truth statements
    expressed as Boolean values. We also looked at how to count items after they've
    moved through a function call chain.
  prefs: []
  type: TYPE_NORMAL
- en: Another fundamental practice we learned was transforming collections into alternative,
    more usable representations that better fit a given context. Like filtering, transforming
    collections is often better done using chains as it reduces the amount of code
    you have to write.
  prefs: []
  type: TYPE_NORMAL
- en: We closed the chapter with a look at how your functions can return wrappers
    that aren't necessarily executed immediately. This is the next step we take in
    building reusable Lo-Dash components, in the next chapter.
  prefs: []
  type: TYPE_NORMAL
