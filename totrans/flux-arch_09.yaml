- en: Chapter 9. Immutable Stores
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we're going to look at immutable data in Flux stores. Immutability
    is a term that often coincides with functional programming. Immutable data is
    data that doesn't change (mutate) once it's been created. The key benefit is that
    you can predict the root cause of data changes in an application because data
    can't inadvertently be changed by side-effects. Immutability and Flux get along
    nicely because they're both about explicitness and predictability.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We'll kick things off by talking about hidden updates or side-effects. Flux
    by itself discourages such things and immutable data helps enforce the idea. Then,
    we'll go over what these side-effects entail for the integrity of our Flux architecture.
    The most severe consequence of side-effects caused by mutating store data are
    disruptions to the unidirectional data flow of Flux. Next, we'll look at the hidden
    costs of immutability—these are mostly related to the additional resources required,
    which can lead to noticeable performance degradation. Finally, we'll look at the
    `Immutable.js` library for help with performing transformations on immutable data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Renouncing hidden updates
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The unidirectional nature of Flux is what sets it apart from other modern frontend
    architectures. The reason that the unidirectional data-flow works is because action
    creators are the only way that new data can enter the system. However, this isn't
    strictly enforced by Flux, and this means that some errant piece of code has the
    potential to completely break our architecture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at how something like this is even possible in Flux.
    Then we'll look at how views typically get their data from stores and whether
    or not there's a better way. Finally, we'll think about other components in our
    Flux architecture and see if anything in addition to store data can be made immutable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: How to break Flux
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The easiest way to break Flux is by mutating the state of a store without going
    through the proper channels. The action dispatcher is the gateway for new data
    entering the system, and it also coordinates the action handlers of our stores.
    For example, one action might trigger the handler of a couple stores, using the
    action payload in different ways. This simply won't happen if the state of stores
    are being mutated directly. We could get lucky and the changes we make don't have
    any side-effects. But isn't the whole premise of being explicit with actions that
    we can't predict complex side-effects?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: If we lower the bar and start directly manipulating state here and there, what's
    to stop us from doing this more frequently? The most likely scenario is a view
    event handler that mutates store data. This is because views typically have direct
    references to stores, whereas other Flux components typically do not. So when
    the user clicks a button and our handler simply changes the state of a store instead
    of dispatching an action, we could find ourselves in trouble.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s walk through an example that highlights just how dangerous operating
    outside of the Flux playing field can be. We''ll check out the button store first:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来了解一下在Flux领域外操作是多么危险。我们首先检查按钮商店：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Seems pretty simple—control the text and the `disabled` status of the buttons.
    This is pretty simple, but only if we''re abiding by the Flux rules and dispatching
    actions to change the state of a store. Now, let''s take a look at a view component
    that uses this store to render itself:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单——控制文本和按钮的`disabled`状态。这很简单，但前提是我们遵守Flux规则并派发动作来改变商店的状态。现在，让我们看看一个使用此商店来渲染自己的视图组件：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What's supposed to happen here is that the button should become disabled when
    it's clicked, because the button store will change the state accordingly when
    the `TOGGLE` action is dispatched. This much works as expected. However, the result
    is that this will never work as expected, due to that one line above the call
    to `toggle()`. Here, we're directly manipulating the state of a store. This prevents
    the expected behavior from taking place when the `TOGGLE` action is dispatched,
    because the state has already been changed, so now it will change back.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这里本应发生的事情是，当按钮被点击时，它应该变为禁用状态，因为当`TOGGLE`动作被派发时，按钮商店将相应地改变状态。这部分工作如预期那样。然而，由于调用`toggle()`之前的这一行，结果将永远不会如预期那样工作。在这里，我们直接操作商店的状态。这阻止了在派发`TOGGLE`动作时预期的行为发生，因为状态已经被改变，所以现在它会恢复原状。
- en: It's these little hacks that can cause big trouble down the road if we're not
    careful. When you look at this view module, the problematic code jumps off the
    screen. Imagine a real project with many more views that are each much bigger
    than this one—would you be able to spot this issue before it's too late?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些小技巧如果不小心，可能会在将来造成大麻烦。当你查看这个视图模块时，有问题的代码会跳出来。想象一下，在一个真实的项目中，有更多这样的视图，每个都比这个大得多——你能在事情变得太晚之前发现这个问题吗？
- en: Getting store data
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取商店数据
- en: 'Given that referencing store state is a dangerous thing, perhaps we could avoid
    it altogether? This would drastically reduce the potential for errors, as we saw
    in the previous section. For example, when two stores depend on one another, they
    use the dispatcher''s `waitFor()` method to ensure that the store we''re dependent
    on is updated first. Then we can just directly access the store, knowing that
    its state has already been updated. The approach is visualized as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于引用商店状态是一件危险的事情，也许我们可以完全避免它？这样会大大减少错误的可能性，正如我们在上一节中看到的。例如，当两个商店相互依赖时，它们使用调度器的`waitFor()`方法来确保我们依赖的商店首先更新。然后我们就可以直接访问商店，知道其状态已经更新。这种方法如图所示：
- en: '![Getting store data](img/B05419_09_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![获取商店数据](img/B05419_09_01.jpg)'
- en: 'The dependent store is directly referencing the state of the store that it
    depends on, which is something that can lead to big problems if we''re not careful.
    An alternative approach would be to have the dependent store listen to the change
    event on the store that it depends on. The callback can then use the new state
    that''s passed to it as an argument. Of course, we would still need to use `waitFor()`
    or something along those lines to ensure that the stores update in the correct
    order. This approach is shown here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖的商店直接引用了它所依赖的商店的状态，如果我们不小心，这可能会导致大问题。另一种方法是有依赖的商店监听它所依赖的商店的更改事件。回调函数可以使用作为参数传递给它的新状态。当然，我们仍然需要使用`waitFor()`或类似的方法来确保商店按正确的顺序更新。这种方法如下所示：
- en: '![Getting store data](img/B05419_09_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![获取商店数据](img/B05419_09_02.jpg)'
- en: This is starting to look like a view component—views listen to the change event
    of stores so that they can render UI updates to reflect the changes in state.
    Views also need to perform an initial rendering of the store data, and this is
    why they typically reference store state. The problem with any of these ideas
    is that none of them actually insulate us from directly accessing store state—who
    knows what kind of reference will be passed in as one of these callback arguments.
    The other problem is that by introducing callback functions where directly reading
    a value is possible is an over-complication in design terms. There has to be a
    better way. Making our store state data immutable is a step in the right direction.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这开始看起来像是一个视图组件——视图会监听存储的变化事件，以便它们可以渲染UI更新来反映状态的变化。视图还需要执行存储数据的初始渲染，这也是为什么它们通常会引用存储状态。这些想法的问题在于，它们实际上并没有阻止我们直接访问存储状态——谁知道这些回调参数中会传递哪种类型的引用。另一个问题是，在可能直接读取值的地方引入回调函数，从设计角度来看是一种过度复杂化。必须有一种更好的方法。使我们的存储状态数据不可变是朝着正确方向迈出的一步。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: In the next chapter, we're going to implement our own dispatcher component.
    While doing so, we'll think about implementing some safeguards against accessing
    state data from a store while an update round is happening, but the store hasn't
    been updated. This will make for easier troubleshooting with dependencies.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将实现自己的分发器组件。在这样做的时候，我们会考虑实现一些防止在更新轮次发生时从存储中访问状态数据的保障措施，但存储尚未更新。这将有助于更容易地处理依赖项的故障排除。
- en: Everything is immutable
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一切都是不可变的
- en: As the last topic before discussing how we might go about enforcing immutability,
    let's talk about the idea of everything in a Flux architecture being immutable.
    Theoretically, this shouldn't be that difficult to do since Flux cordons off state
    from living anywhere other than inside a store. So, let's start with stores.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论如何强制执行不可变性之前，让我们谈谈Flux架构中一切事物都应该是不可变性的观点。从理论上讲，这不应该很难做到，因为Flux将状态限制在存储内部，不允许其存在于其他任何地方。所以，让我们从存储开始。
- en: Should all our stores be immutable, or perhaps just some of them? Having only
    some immutable stores isn't a good idea because it promotes inconsistency. What
    about having immutability in place at all, is it even necessary? Now this is a
    very important question one has to ask about their architecture because there's
    no cut-and-dried answer here. The immutability argument works when we need that
    extra assurance that there will be no surprises with store states later on. The
    counterargument is that we're disciplined enough as programmers that the immutability
    mechanisms just add overhead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的所有存储都应该是不可变的，或者可能只是其中一些？只有一些不可变的存储不是一个好主意，因为它会促进不一致性。那么，在所有地方都实现不可变性，这是否是必要的？这是一个非常重要的问题，我们必须对我们的架构提出这个问题，因为这里没有一刀切的答案。当我们需要额外的保证，即以后不会有存储状态上的惊喜时，不可变性的论点就有效了。反论是，我们作为程序员足够自律，不可变性的机制只是增加了开销。
- en: We'll spend the remainder of this chapter arguing in favor of immutable data,
    simply because the positives outweigh the negatives in almost every case. Regardless
    of how you feel about immutability, it's good to know what its strengths are in
    a Flux architecture—even if you're not going to use it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的剩余部分论证不可变数据的好处，因为几乎在所有情况下，其优点都超过了缺点。无论你对不可变性的看法如何，了解它在Flux架构中的优势都是有益的——即使你不会使用它。
- en: What about view components—can they actually be immutable? Well, it turns out
    that they cannot, because the DOM API doesn't allow this. Our view components
    have to actually manipulate the state of the elements on the page. However, if
    we're using a view technology like React, then we get a veil of immutability because
    the idea is to always re-render components. So it seems as though we're taking
    old elements and replacing them with new ones when, all the while React figures
    out the DOM manipulations for us. This promotes the idea that state has no place
    within a Flux view.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 那么视图组件呢——它们实际上可以是不可变的吗？好吧，实际上它们不能，因为DOM API不允许这样做。我们的视图组件实际上必须操纵页面上的元素状态。然而，如果我们使用像React这样的视图技术，那么我们会得到一层不可变的面纱，因为其理念是始终重新渲染组件。所以，当我们实际上在用React处理DOM操作的同时，我们似乎是在用新元素替换旧元素。这促进了这样一个观点，即状态在Flux视图中没有位置。
- en: Enforcing unidirectional data flow
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制单向数据流
- en: If new data only enters the system via action payloads delivered by the dispatcher
    and our store data is immutable, we have a unidirectional data-flow. This is the
    goal, so the questions is, how do we enforce this? Can we simply say that our
    store data is immutable and be done with it? Well, that's something to shoot for,
    absolutely, but there's more to it than that.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果新数据只通过调度器派发的动作有效载荷进入系统，并且我们的存储数据是不可变的，那么我们就有一个单向数据流。这是我们的目标，所以问题是，我们如何强制执行这一点？我们能否简单地声明我们的存储数据是不可变的，然后就此结束？嗯，那绝对是一个值得追求的目标，但还有更多的事情要做。
- en: In this section, we'll address the concept of data flowing in unintended directions,
    and what causes this to happen. We'll then consider the notion of having too many
    stores and not enough actions as contributors to dysfunctional data-flows. Finally,
    we'll examine some techniques that we can utilize to make our store data immutable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论数据以非预期方向流动的概念，以及是什么导致了这种情况。然后，我们将考虑拥有太多存储和太少动作作为导致数据流功能障碍的贡献因素。最后，我们将检查一些我们可以利用的技术，以使我们的存储数据不可变。
- en: Backwards, sideways, and leaky data flow
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向、横向和泄漏的数据流
- en: 'Flux architectures have a unidirectional data-flow—data enters from the left
    and exits on the right. This is easy to visualize as a flow that moves forward.
    What are some of the ways this can go wrong then? Take backwards flow, for instance.
    If a view instance holds a reference to a store instance and proceeds to mutate
    its state, then the flow is moving from the view to the store. This is the complete
    opposite of the expected flow direction, so it is moving backwards. Here''s an
    illustration of what this looks like:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Flux架构有一个单向数据流——数据从左侧进入，从右侧退出。这很容易想象成一个向前移动的流程。那么，这种流程可能会出错的地方有哪些呢？以反向流为例。如果一个视图实例持有存储实例的引用，并继续修改其状态，那么流程就是从视图流向存储。这与预期的流程方向完全相反，因此它是向后的。以下是这种外观的说明：
- en: '![Backwards, sideways, and leaky data flow](img/B05419_09_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![反向、横向和泄漏的数据流](img/B05419_09_03.jpg)'
- en: This is obviously not what we'd expect when working with a Flux system. But
    it's also a likely scenario unless we rule out the possibility by having the store's
    state return immutable data structures to any other components that want to interact
    with it. What about stores - can they mutate the state of another store? They
    shouldn't, and if they do, that would look like a sideways data-flow.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然不是我们在使用Flux系统时预期的。但除非我们通过让存储的状态返回不可变数据结构给任何想要与之交互的其他组件来排除这种可能性，否则这是一个很可能会发生的情况。那么，存储——它们能否修改另一个存储的状态呢？它们不应该这样做，如果它们这样做，那看起来就像是一个横向数据流。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**ProTip**: Anything that goes sideways is a bad thing.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProTip**: 任何横向移动的东西都是不好的。'
- en: 'Here''s what a sideways data-flow between two Flux stores might look like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个Flux存储之间横向数据流的例子：
- en: '![Backwards, sideways, and leaky data flow](img/B05419_09_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![反向、横向和泄漏的数据流](img/B05419_09_04.jpg)'
- en: This is just as bad as the view component that directly mutates the state of
    a store, because the state we just changed could impact the next state that's
    computed. This is the same situation we saw in the first code example we looked
    at in the chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这和直接修改存储状态的观点组件一样糟糕，因为我们刚刚改变的状态可能会影响下一个计算出的状态。这正是我们在本章第一个代码示例中看到的情况。
- en: 'What about actions—are they capable of directly manipulating the state of a
    store? This is probably the least likely scenario, because action creator functions
    are supposed to just dispatch actions after they coordinate any asynchronous behavior.
    However, an action creator function could incorrectly mutate a store state in
    an AJAX callback handler, for example. This is what we refer to as *leaky flows*
    because they''re going around the dispatcher. So, we''re leaking mutations without
    any traceable actions to show where they originated. Here''s an illustration of
    the idea:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，关于动作，它们能否直接操作存储的状态呢？这可能是最不可能的情况，因为动作创建函数应该在协调任何异步行为后仅仅派发动作。然而，动作创建函数可能在AJAX回调处理程序中错误地修改存储状态，例如。我们称之为*泄漏流*，因为它们绕过了调度器。因此，我们在没有任何可追踪的动作来显示它们来源的情况下泄漏了修改。以下是这个想法的说明：
- en: '![Backwards, sideways, and leaky data flow](img/B05419_09_05.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![反向、横向和泄漏的数据流](img/B05419_09_05.jpg)'
- en: Too many stores?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储太多？
- en: There's always a possibility that there are too many Flux stores in our architecture.
    Perhaps the application has grown beyond what we had originally designed for in
    terms of features. Now, simply mapping a store to a feature won't suffice because
    there are dozens of stores.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有可能我们的架构中存在太多的Flux商店。也许应用的功能已经超出了我们最初的设计。现在，仅仅将商店映射到功能上是不够的，因为已经有几十个商店了。
- en: If we're unable to rein in the store count, a possible outcome is more direct
    state mutations by other components. It's just a matter of convenience, if there's
    a ton of stores to think about, it means that we're going to have to take care
    of several other dispatcher-related development activities any time we want to
    do something. When there's lots of stores, there's the urge to manipulate their
    state directly. Removing stores reduces this urge.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法控制商店的数量，一个可能的结果是其他组件将直接进行状态突变。这仅仅是一个便利性的问题，如果有很多商店需要考虑，那就意味着每次我们想要做些什么时，我们都必须处理几个与调度器相关的开发活动。当有大量商店时，就有直接操作它们状态的冲动。移除商店可以减少这种冲动。
- en: Not enough actions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作不足
- en: Is it possible that our Flux architecture doesn't have enough actions? For example,
    a view that we're working on needs to change the state of a store. There's no
    action to handle this for us, so rather than build a new action creator and update
    the store to handle the logic, we just directly mutate the store. It sounds like
    an easy enough task—building an action creator function and adding the necessary
    store update logic. But if we have to keep implementing these one-off action creator
    functions, eventually we'll just stop caring. There are two ways to fix this issue.
    The first is to implement more generic actions that apply to more than just one
    specific situation and can accept parameters. The second is to build a handful
    of action creator functions that are relevant to the feature that you're working
    on, even before you need them. When you know that the functions are there, in
    the back of your mind, you're more likely to use them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Flux架构可能没有足够的动作吗？例如，我们正在工作的视图需要改变商店的状态。没有动作来处理这个问题，所以我们不是构建一个新的动作创建器并更新商店以处理逻辑，而是直接突变商店。这听起来像是一项足够简单的任务——构建一个动作创建器函数并添加必要的商店更新逻辑。但如果我们必须不断实现这些一次性动作创建器函数，最终我们可能就不再关心了。解决这个问题有两种方法。第一种是实现更通用的动作，这些动作不仅适用于特定的情况，还可以接受参数。第二种是在你需要它们之前，构建一些与你在工作的功能相关的动作创建器函数。当你知道这些函数存在时，在潜意识里，你更有可能使用它们。
- en: Enforcing immutability
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制不可变性
- en: 'Let''s explore some different approaches to keeping store state immutable.
    The goal is that when some external entity references a store''s state, any changes
    that entity makes to the state doesn''t actually affect the store because the
    data is immutable. We''ll start by implementing a store that doesn''t actually
    return a reference to its state—it returns a copy of it using `Object.assign()`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索一些保持商店状态不可变的不同方法。目标是当某个外部实体引用商店的状态时，该实体对状态所做的任何更改实际上都不会影响商店，因为数据是不可变的。我们将首先实现一个不实际返回其状态引用的商店——它使用`Object.assign()`返回状态的副本：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, you can see that the actual store state is in a module-level `state`
    variable. This means that it isn''t accessible directly by the outside world because
    it isn''t exported. We want the state to be encapsulated like this so that it''s
    harder for other components to mutate it. If other components need read access
    to the store''s state properties, they can read the `state` property of the store.
    Since this is a getter method, it can compute the value that will be returned.
    In this case, we''ll create a new object on the fly. Now let''s look at a store
    that stores its state in a constant:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到实际的商店状态位于模块级别的`state`变量中。这意味着它不能被外部世界直接访问，因为它没有被导出。我们希望状态以这种方式封装，这样其他组件就难以突变它。如果其他组件需要读取商店状态属性，它们可以读取商店的`state`属性。由于这是一个getter方法，它可以计算返回的值。在这种情况下，我们将动态创建一个新的对象。现在让我们看看一个将状态存储在常量中的商店：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This store has the same structure and patterns as the `Copy` store. The difference
    is that `state` isn''t a variable—it''s a constant. This means that we shouldn''t
    be able to mutate it, right? Well, not quite—we just can''t assign new values
    to it. So this approach has limited value because the `state()` getter returns
    a direct reference to the constant. We''ll see how this works momentarily, when
    other components use the store. Let''s look at one more approach, which uses `Object.frozen()`
    to make objects immutable:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储结构与`Copy`存储相同，模式也一致。不同之处在于`state`不是一个变量——它是一个常量。这意味着我们不应该能够修改它，对吧？嗯，并不完全是这样——我们只是不能给它赋新值。因此，这种方法的价值有限，因为`state()`获取器返回的是常量的直接引用。我们将在其他组件使用存储时，稍后看到这种方法是如何工作的。让我们再看看另一种方法，它使用`Object.frozen()`使对象不可变：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `state()` getter is actually returning a reference to the frozen `state`
    variable. What's interesting about this approach is that we don't necessarily
    need to make a new copy of the data because our `change()` function has made it
    immutable. And when the store itself needs to update its state, that's when the
    state is refrozen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`state()`获取器实际上返回的是冻结的`state`变量的引用。这个方法有趣的地方在于，我们不一定需要创建数据的新副本，因为我们的`change()`函数已经使其不可变。而当存储本身需要更新其状态时，状态就会被重新冻结。'
- en: 'Let''s see how these approaches compare now. First, we''ll import the stores
    and get references to their states:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些方法现在是如何比较的。首先，我们将导入存储并获取它们状态的引用：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It seems like we were able to successfully change the state of `copyState`.
    This is sort of true—we changed the state of a copy that doesn't actually reflect
    the state of the store. The `constantState` change, on the other hand, does have
    side-effects because any other components that read state from the constant store
    will see this change.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来我们能够成功改变`copyState`的状态。这在某种程度上是正确的——我们改变了一个副本的状态，而这个副本实际上并不反映存储的状态。另一方面，`constantState`的改变确实有副作用，因为任何从常量存储读取状态的组件都会看到这个变化。
- en: 'When we try to change `frozenState`, a `TypeError` is thrown. This might actually
    be the desired outcome, since it''s made explicit that what we''re trying to do
    with `fronzenState` is not allowed. Similar things happen when we add new properties
    to the store states—copy fails silently, constant fails, and frozen fails explicitly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试更改`frozenState`时，会抛出一个`TypeError`。这实际上可能是我们想要的结果，因为它明确指出我们尝试对`fronzenState`所做的事情是不允许的。当我们向存储状态添加新属性时，也会发生类似的事情——复制会静默失败，常量会失败，而冻结会明确失败：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, let''s look at the state data that''s sent when the change event is
    emitted:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看在更改事件发出时发送的状态数据：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `myAction()` function will extend the store state with new data. As we can
    see once again, the constant approach has failed us because it returns the same
    reference that was mutated. Generally speaking, none of these approaches are particularly
    easy to implement in practice. This is another reason why we'll want to seriously
    consider using a library like `Immutable.js`, where immutability is the default
    mode and mostly hidden from our code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`myAction()`函数将使用新数据扩展存储状态。正如我们再次看到的，常量方法失败了，因为它返回了被修改的相同引用。一般来说，这些方法在实践中都不太容易实现。这也是我们想要认真考虑使用像`Immutable.js`这样的库的另一个原因，在那里不可变性是默认模式，并且大部分隐藏在我们的代码中。'
- en: The cost of immutable data
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变数据的成本
- en: By now you are well aware of the advantage immutable data brings to a Flux architecture—a
    level of assurance about our unidirectional data-flow. This safety net comes at
    a cost. In this section, we'll discuss how expensive immutability can be and what
    can be done about it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经非常清楚不可变数据给Flux架构带来的优势——关于我们单向数据流的保证。这个安全网是有代价的。在本节中，我们将讨论不可变性可能带来的高昂成本以及我们可以采取的措施。
- en: We'll start by covering the biggest immutability issue—transient memory allocations
    and garbage collection. These things are big threats to the performance of our
    Flux architecture. Next, we'll think about lessening the amount of memory allocations
    by batching together transformations on immutable data. Finally, we'll think about
    the ways in which immutable data eliminates code that's only needed to handle
    scenarios where data is mutable.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从覆盖最大的不可变性问题——瞬态内存分配和垃圾回收开始。这些因素对我们Flux架构的性能构成了重大威胁。接下来，我们将考虑通过批量处理不可变数据上的转换来减少内存分配的数量。最后，我们将探讨不可变数据消除仅用于处理数据可变场景的代码的方式。
- en: Garbage collection is expensive
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收成本高昂
- en: One good thing about mutable data structures is that once they're allocated,
    they tend to stick around for a while. That is, we don't need to copy the properties
    of an existing structure into a new one, then destroy the old one any time we
    need to make an update. This is software, so we're going to be making a lot of
    updates.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可变数据结构的一个好处是，一旦它们被分配，它们通常会持续一段时间。也就是说，我们不需要将现有结构的属性复制到一个新结构中，然后在需要更新时销毁旧结构。这是软件，所以我们将进行很多更新。
- en: With immutable data, we face a memory consumption challenge. Every time we mutate
    an object, we have to allocate a new copy of that object. Imagine we're in a loop,
    making changes to immutable objects in a collection—this adds up to a lot of memory
    allocations in a short period of time—a spike if you will. Furthermore, the old
    objects that have been superseded by the new ones aren't instantaneously deleted
    from memory. They have to wait for the garbage collector to clean them up.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不可变数据时，我们面临着内存消耗的挑战。每次我们修改一个对象时，都必须为该对象分配一个新的副本。想象一下，我们处于一个循环中，在一个集合中对不可变对象进行修改——这会在短时间内产生大量的内存分配——可以说是峰值。此外，被新对象取代的旧对象并不会立即从内存中删除。它们必须等待垃圾回收器来清理。
- en: When our application uses more memory than it needs to, performance suffers.
    When the garbage collector has to run frequently because of all our memory allocations,
    performance suffers. It's the garbage collector more than anything else that triggers
    laggy user experiences, because our JavaScript code can't respond to any pending
    events while it's running.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序使用的内存超过其需求时，性能会受到影响。当垃圾回收器因为我们的内存分配而频繁运行时，性能会受到影响。正是垃圾回收器，而不是其他任何东西，触发了卡顿的用户体验，因为我们的JavaScript代码在运行时无法响应任何挂起的事件。
- en: Maybe there's an approach to immutable data that's less memory-intensive than
    replacing large objects when all we want is a simple update.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一种处理不可变数据的方法，比在只需要简单更新时替换大型对象更节省内存。
- en: Batched mutations
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量修改
- en: Luckily for us, stores mutate their own state. This means that store dispatcher
    callbacks encapsulate everything that happens during state transformations. So
    if our stores have immutable state data, then the outside world doesn't need to
    know about any shortcuts the store takes internally in order to cut down on the
    number of memory allocations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，存储会修改自己的状态。这意味着存储分发回调封装了状态转换期间发生的所有操作。所以如果我们的存储有不可变状态数据，那么外部世界就不需要知道存储在内部为了减少内存分配数量而采取的任何捷径。
- en: 'Let''s say that a store receives an action and it has to perform three separate
    transformations on its state: make a transformation that results in a new object,
    make another transformation on that new object, and so on. That''s a lot of transient
    memory allocations for intermediary data that no other component will ever touch.
    Here''s an illustration of what''s going on:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个存储接收一个动作，并且它必须在它的状态上执行三个单独的转换：进行一个转换以生成一个新对象，然后在这个新对象上执行另一个转换，依此类推。这是为中间数据进行的许多短暂的内存分配，而这些中间数据其他组件永远不会触及。以下是对正在发生的事情的说明：
- en: '![Batched mutations](img/B05419_09_06.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![批量修改](img/B05419_09_06.jpg)'
- en: 'We want the final result to be a new state reference, but the intermediary
    new state that''s created in between is wasteful. Let''s see if there''s a way
    that we can batch together these state transformations before the final immutable
    value is returned:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望最终结果是新的状态引用，但中间创建的新状态是浪费的。让我们看看我们是否可以在返回最终不可变值之前将这些状态转换批量处理：
- en: '![Batched mutations](img/B05419_09_07.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![批量修改](img/B05419_09_07.jpg)'
- en: Now, we're only allocating one new object, despite making three state transformations.
    The mutations we're making within a Flux store are absolutely inconsequential
    to any other component in the system, yet we're maintaining immutability for anything
    else that wants to access and read this state.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尽管我们进行了三次状态转换，但我们只分配了一个新的对象。我们在Flux存储中进行的修改对系统中的任何其他组件来说都是微不足道的，但我们仍然保持了任何其他想要访问和读取此状态的组件的不变性。
- en: Offsetting the cost
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转移成本
- en: The painful part of mutable data is that components using this data have to
    account for side-effects. They don't necessarily know when or how this data will
    mutate. So they need side-effect handling code. While code that handles unexpected
    side-effects often doesn't utilize more memory, it isn't free to run either. When
    there's code to handle edge cases all over our source, the performance degradation
    can add up. With immutable data, we can remove most, if not all, of this extraneous
    code that checks the state of something, because we can better predict what it's
    going to be. This helps to offset the cost of extra memory allocations and garbage
    collection runs. Even if we're not using immutable data in our stores, Flux architectures
    make the need for side-effect handling code virtually obsolete. A unidirectional
    data-flow makes Flux very predictable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可变数据的痛苦之处在于，使用这些数据的组件必须考虑副作用。它们并不一定知道这些数据何时以及如何会发生变化。因此，它们需要处理副作用的代码。虽然处理意外副作用的代码通常不会占用更多内存，但它也不是免费运行的。当我们的源代码中到处都有处理边缘情况的代码时，性能下降会累积。使用不可变数据，我们可以移除大部分，如果不是全部的话，这些检查状态的额外代码，因为我们能更好地预测它将会是什么。这有助于抵消额外内存分配和垃圾回收运行的代价。即使我们不在我们的商店中使用不可变数据，Flux
    架构也使得副作用处理代码的需求几乎变得过时。单向数据流使得 Flux 非常可预测。
- en: Using Immutable.js
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Immutable.js
- en: The `Immutable.js` library from Facebook provides immutable JavaScript data
    structures. This might sound trivial but there's a lot that goes on behind the
    scenes to make this work, namely creating new instances from transformations as
    efficiently as possible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Facebook 的 `Immutable.js` 库提供了不可变的 JavaScript 数据结构。这听起来可能很平凡，但幕后有很多事情发生以确保这一点，即尽可能高效地从转换中创建新实例。
- en: In this section, we'll look at immutable lists and maps. These are viable substitutes
    for arrays and plain objects, respectively, in our Flux store data. Then, we'll
    look at how `Immutable.js` can compose complex transformations without the need
    for intermediary representations. Finally, we'll see how `Immutable.js` returns
    the same instance when there's no mutations after running through a transformation,
    allowing for efficient change detection.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨不可变列表和映射。这些可以在我们的 Flux 商店数据中分别作为数组和普通对象的可行替代品。然后，我们将看看 `Immutable.js`
    如何在不需要中间表示的情况下组合复杂的转换。最后，我们将看到 `Immutable.js` 在经过转换后没有突变时返回相同的实例，从而允许高效的变更检测。
- en: Immutable lists and maps
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变列表和映射
- en: 'We''ll start by looking at lists and maps, since these are fairly common structures
    that we''ll need to implement in our stores. Lists are kind of like arrays and
    maps are kind of like plain JavaScript objects. Let''s implement a store that
    uses a list:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看列表和映射开始，因为这些都是我们将在商店中实现的一些常见结构。列表有点像数组，映射有点像普通的 JavaScript 对象。让我们实现一个使用列表的商店：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can see that the `state` variable is initialized to an empty `Immutable.List()`
    instance (the `new` keyword isn't necessary because these are functions that return
    new instances). Whenever we call a method on this list instance, a new instance
    is returned. This is why we have to assign the result of calling `push()` and
    `map()` to `state`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，`state` 变量被初始化为一个空的 `Immutable.List()` 实例（`new` 关键字不是必需的，因为这些是返回新实例的函数）。每当我们在列表实例上调用一个方法时，就会返回一个新的实例。这就是为什么我们必须将调用
    `push()` 和 `map()` 的结果赋值给 `state` 的原因。
- en: 'Now let''s implement a map store:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现一个映射商店：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, maps follow the same immutability patterns as lists. The main
    difference is that they''re keyed instead of indexed. Now let''s see how both
    of these stores are used:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，映射遵循与列表相同的不可变模式。主要区别在于它们是按键而不是按索引来组织的。现在让我们看看这两个存储是如何使用的：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Immutable transformations
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变转换
- en: 'Now, it''s time to implement a more involved transformation inside a Flux store.
    This means chaining together operations on `Immutable.js` structures to create
    a new structure. But what about intermediary memory allocations—we''ll want to
    keep an eye on these, right? Here''s a store that attempts to use less memory
    while making transformations to a store''s state:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在 Flux 商店内部实现一个更复杂的转换了。这意味着将 `Immutable.js` 结构上的操作链式化以创建一个新的结构。但是，关于中间内存分配——我们肯定想关注这些，对吧？这里有一个尝试在转换商店状态时使用更少内存的商店：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `SORT_NAMES` action results in some interesting transformations happening
    to our immutable list. The idea is to map it to a list of capitalized user names,
    sorted by user `id`. The technique that's employed here involves converting the
    list into a sequence once it's sorted, using `toSeq()`. This is done to prevent
    the `map()` calls from allocating new structures, because we don't actually need
    a concrete structure till we're done mapping. To do this, we just have to call
    `toList()`, which will call all the mappings we've set up on the sequence and
    create the list. This means that the only structures we're creating here, are
    the new list from `sortBy()`, the new sequence from `toSeq()`, and the new list
    from `toList()`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`SORT_NAMES`动作导致我们对不可变列表进行了一些有趣的转换。想法是将它映射到一个按用户`id`排序的大写用户名列表。这里使用的技术涉及在排序后使用`toSeq()`将列表转换为序列，这样做是为了防止`map()`调用分配新的结构，因为我们实际上不需要一个具体结构直到映射完成。为此，我们只需调用`toList()`，这将调用我们在序列上设置的所有映射并创建列表。这意味着我们在这里创建的唯一结构是来自`sortBy()`的新列表、来自`toSeq()`的新序列和来自`toList()`的新列表。'
- en: 'In this particular example, this might be overkill, simply due to the fact
    that there are three operations done on a three-element list. So, we would just
    remove `toSeq()` and `toList()` from our code to simplify things. However, as
    we scale up to larger collections and more complex transformations on them, it
    doesn''t hurt to know about this technique to reduce the memory footprint of our
    architecture. Let''s see this store in action now:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，这可能是过度杀鸡用牛刀，仅仅是因为我们在一个包含三个元素的列表上执行了三个操作。所以，我们只需从我们的代码中移除`toSeq()`和`toList()`来简化事情。然而，当我们扩展到更大的集合和更复杂的转换时，了解这种技术以减少我们架构的内存占用是有益的。现在让我们看看这个存储的实际应用效果：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Change detection
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变化检测
- en: 'In this final example of the chapter, we''ll see whether we can use `Immutable.js`
    structures to implement efficient change detection in our Flux stores. Actually,
    the detection itself will take place in the React view, but this relies on the
    store state using an `Immutable.js` object. Why would we want to do this—isn''t
    React already efficient enough at computing diffs using its virtual DOM? React
    definitely excels here, but it still has to do a fair amount of work to figure
    out that no re-rendering is needed. We can lend a hand to our React components
    by providing hints that the store''s state hasn''t actually changed. So without
    further ado, here''s the store we''ll use:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一个例子中，我们将看到是否可以使用`Immutable.js`结构在我们的Flux存储中实现高效的变化检测。实际上，检测本身将在React视图中进行，但这依赖于存储状态使用`Immutable.js`对象。我们为什么要这样做——React在计算diff时不是已经足够高效了吗？React在这里确实很出色，但它仍然需要做相当多的工作来确定不需要重新渲染。我们可以通过提供存储状态实际上没有变化的提示来帮助我们的React组件。所以，不拖泥带水，这是我们将会使用的存储：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Nothing fancy is done on our part here; we''re simply using an `Immutable.js
    Map` as our store state. We''re then assigning the new `Map` instance to state
    when `set()` is called, since it returns a new instance. Here''s the heuristic
    we''re interested in—if nothing changes, the same instance is returned. Let''s
    see how we can use this property of `Immutable.js` data in our a view:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这边没有做任何花哨的事情；我们只是使用`Immutable.js Map`作为我们的存储状态。当调用`set()`时，我们将新的`Map`实例分配给状态，因为返回的是一个新实例。这里是我们感兴趣的启发式方法——如果没有变化，返回相同的实例。让我们看看我们如何在我们视图中使用`Immutable.js`数据的这个属性：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The key piece of this component is the `shouldComponentUpdate()` method, which
    makes the determination that the store has changed by doing a strict inequality
    comparison. In cases where this component is being rendered a lot but there''s
    no need to change anything, this will avoid a lot of virtual DOM tree checking.
    Now, let''s see how we would go about using this view:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件的关键部分是`shouldComponentUpdate()`方法，它通过进行严格的不等式比较来确定存储是否已更改。在这种情况下，如果这个组件被渲染很多次但不需要更改任何内容，这将避免大量的虚拟DOM树检查。现在，让我们看看我们如何使用这个视图：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, actions that cause our view to re-render are constantly dispatched.
    However, since the `set()` call in our store is returning the same instance when
    nothing changes, the view itself is doing very little work. Then, once we do change
    the payload value after 5 seconds, the `Immutable.js` map instance changes, and
    the view updates. This view is rendered a grand total of two times—the initial
    rendering and the rendering that takes place when the store data actually changes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，那些导致我们视图重新渲染的操作是持续不断地被派发的。然而，由于我们存储库中的`set()`调用在没有任何变化时返回相同的实例，视图本身实际上并没有做多少工作。然后，一旦我们在5秒后更改了有效载荷值，`Immutable.js`映射实例就会改变，视图也会更新。这个视图总共渲染了两次——初始渲染和存储数据实际发生变化时的渲染。
- en: You may have noticed that this implementation could have gone in another direction,
    one where the store isn't so naive as to emit changes when nothing has changed.
    It's all a matter of taste and tradeoffs. The approach we've chosen does require
    that the views take an active role in optimizing the rendering work-flow. This
    is easy to do with React components, and it simplifies our store logic. On the
    other hand, we might prefer to keep our views completely logic-less, including
    the `shouldComponentUpdate()` checks. If this is the case, we'd simply move this
    logic back into the store, and not have the change event emitted if the two `Immutable.js`
    instances are the same.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，这种实现本可以走向另一个方向，其中一个存储库不会在没有任何变化时发出更改。这完全取决于个人品味和权衡。我们选择的方法确实要求视图在优化渲染工作流程中扮演一个积极的角色。这对于React组件来说很容易做到，并且简化了我们的存储逻辑。另一方面，我们可能更喜欢保持我们的视图完全无逻辑，包括`shouldComponentUpdate()`检查。如果是这样，我们只需将这个逻辑移回存储库，并且如果两个`Immutable.js`实例相同，则不会发出更改事件。
- en: Summary
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced you to immutability—both in the general sense of the
    term and from a Flux architecture viewpoint. We began the chapter with a discussion
    on the various ways that mutable data can break Flux. In particular, this breaks
    the crown jewel of any Flux architecture—unidirectional data-flow. Next, we looked
    at the different types of data-flow that emerge when we start mutating data outside
    of stores, as these are good things to look for when troubleshooting Flux architectures.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你介绍了不可变性——既从术语的一般意义上，也从事务流架构的角度来看。我们本章开始时讨论了可变数据如何破坏Flux的多种方式。特别是，这破坏了任何Flux架构的皇冠宝石——单向数据流。接下来，我们研究了当我们开始在存储之外修改数据时出现的不同类型的数据流，因为这些是在调试Flux架构时值得寻找的好东西。
- en: There are several ways that our code can enforce immutable data in our Flux
    stores, and we explored many of them. Immutable data comes at a cost—because the
    garbage collector constantly needs to run, blocking other JavaScript code from
    running, to collect all these extra copies of objects. We looked at how to minimize
    these extra memory allocations and how to offset the overall cost of using immutable
    data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以在我们的Flux存储中强制执行不可变数据，我们已经探索了许多方法。不可变数据是有代价的——因为垃圾收集器需要不断运行，阻止其他JavaScript代码运行，以收集所有这些额外的对象副本。我们探讨了如何最小化这些额外的内存分配，以及如何抵消使用不可变数据的总体成本。
- en: We closed the chapter by implementing several stores that used `Immutable.js`
    data structures. This library buys us immutability, added functionality, and efficient
    use of intermediary memory allocations by default. In the next chapter, we'll
    implement our own dispatcher component.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现几个使用`Immutable.js`数据结构的存储库来结束本章。这个库默认为我们提供了不可变性、附加功能和高效的中间内存分配。在下一章中，我们将实现我们自己的派发组件。
