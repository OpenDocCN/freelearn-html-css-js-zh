- en: Packaging Types and Values Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ReasonML has fantastic support for the software engineering practice of dividing
    programs into small, modular components that can be swapped out for each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Modules and how they can be used to package types and values together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between file modules and syntactic modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module signatures (both file and syntactic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using signatures to achieve information hiding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using signatures to achieve type abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving zero-cost abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modules** are groups of types and values accessible under a single name.
    This can be incredibly useful when you want to associate some types and operations
    together to make them easier to find and use together. They are kind of like **namespaces**
    in other languages, but more powerful because they can be composed in various
    ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how to make some modules.
  prefs: []
  type: TYPE_NORMAL
- en: File modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It turns out we've already made some modules! Reason treats the `.re` source
    files as modules, so our `src/Ch01/Ch01_Demo.re` and `src/Ch02/Ch02_Demo.re` files
    are automatically available as modules, with the names `Ch01_Demo` and `Ch02_Demo`,
    respectively. In the Reason world, these are called **implementation files***.*
    We will informally refer to them as **file modules***.*
  prefs: []
  type: TYPE_NORMAL
- en: Reason names file modules purely from their file names, ignoring their directory
    nesting. It makes every module automatically available from every other module,
    regardless of where they are physically in the project. This is why we were careful
    to name our modules with chapter prefixes; otherwise, files from different chapters
    but with the same names would confuse the compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take advantage of Reason''s automatic module resolution, by creating
    a new (file) module that refers to something in an existing module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we''re defining a function that knows how to greet people with a name
    and an ID. There are a few things happening in this example (marked by the numbered
    comments):'
  prefs: []
  type: TYPE_NORMAL
- en: 'We assign a type to the `person` function parameter by appending a colon followed
    by the type. You can read this as "*person has type c h 0 2 demo dot person*".
    We can assign types to any function parameters in Reason; they are almost always
    optional though, because of type inference. In this case, we wanted to be explicit
    because of a subtle issue: there are actually two different record types (`person`
    and `company`) with the `name` and `id` fields in the `Ch02_Demo` module, and
    we need to distinguish between them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Function definitions have a body consisting of a single expression; this can
    also be a compound expression delimited by brackets (we'll see examples later).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can have a `person` value and a `person` type–they don't clash because Reason
    stores them separately, in the static and dynamic environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reason is whitespace-insensitive; you can lay out your code any way you want,
    as long as you separate bindings with a semicolon. For most codebases, you would
    actually just use the Reason formatter tool, `refmt`, which would automatically
    take care of all formatting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `++` operator in Reason concatenates two strings (and nothing else!) together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`person.id` is an `int`, so we can''t concatenate it with its surrounding strings–unless
    we convert it to a string with the built-in `string_of_int` function. Reason has
    strict, strong typing, and doesn''t implicitly convert between types (not even
    between `int` and `float` variables).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To understand what Reason is doing for us, let''s look at the relevant part
    of the output JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I've cleaned and rearranged the JavaScript output somewhat, without changing
    its meaning.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we see the types are completely erased, and the output is concerned
    only with values. Based on the types, though, the Reason compiler knew to access
    the person's name at array index 1 and ID at index 0\. Also, it knows to ensure
    that `person[0]` gets converted into a string by using the JavaScript string constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In the JavaScript world, we'd say that such a conversion is unnecessary. But
    in the statically typed Reason world, the compiler keeps a tally of the types
    of all values and ensures they interact only according to the rules of their types.
    Thus we ensure that a number can't accidentally be added to a series of strings.
  prefs: []
  type: TYPE_NORMAL
- en: On a larger scale, notice that the fact that Reason files are modules is not
    directly visible in the JavaScript output code–except that the Reason files are
    directly compiled, with a one-to-one relationship, to JavaScript modules.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at another way of creating modules in Reason: **syntactic modules***.*
    These are modules that are defined using Reason''s module syntax. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we define a `Domain` file module to contain two *nested* modules: `Person`
    and `Company`. These nested modules actually contain types similar to the ones
    we defined in `src/Ch02/Ch02_Demo.re`, but this time with both types named `t`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's digress a little into the type name `t`. This is a standard naming convention
    in the Reason ecosystem to mean the main type in the module. Usually, you refer
    to a module along with its main type, for example, `Person.t` or `Company.t`,
    so it's quite clear exactly which type you mean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactic modules have the following form: `module Name = {...bindings...};`
    and all the bindings are then available to outside consumers under the module
    name, for example, `Name.binding1`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Earlier, we said that modules package types and values together. But in the
    preceding example, you can see that the `Ch03_Domain` file module itself contains
    two modules, `Person` and `Company`. I actually oversimplified before. Modules
    can recursively contain other modules! This is a great code organization and namespacing
    strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the (relevant part of the) JavaScript output to understand what
    the runtime effect of this domain module is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Person` and `Company` modules are represented as JavaScript arrays, and
    their `t` types are completely erased, leaving the arrays almost empty. The arrays
    contain only what file-level module JavaScript output would contain: values. In
    fact, this is almost exactly how Reason represents modules when compiled to bytecode
    or native binary form.'
  prefs: []
  type: TYPE_NORMAL
- en: It is not, however, how you might expect a *nested module* to look in idiomatic
    JavaScript. Indeed, the BuckleScript compiler does not always emit completely
    idiomatic JavaScript output. Some of those cases can be fixed (indeed, some have
    already been); others are compromises that the compiler needs to make to efficiently
    convert Reason code into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Using a syntactic module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, modules are very cheap. They have almost no runtime effect.
    Let''s look at the payoff of arranging our types into their own nested modules.
    We''re going to try greeting a person again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: What's different from `src/Ch03/Ch03_Greet.re`?
  prefs: []
  type: TYPE_NORMAL
- en: We don't need to explicitly annotate the type of `person`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to tell Reason which module the `name` field is coming from, because,
    in order to prevent name clashes between record types that have the same field
    names, Reason doesn't automatically open up modules to look for type details
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might ask, is this really a payoff? We've just traded one kind of annotation
    (the explicit type signature) for another (the field name module prefix). While
    that is true, it's idiomatic for implementation code to have as few type annotations
    as possible and let the compiler infer as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Type annotations do serve another purpose though, which is to document the types.
    In Reason, we have an explicit place to put type annotations that document our
    module types and serve some other useful purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Module signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Module signatures***,* also known as **interfaces***,* are an explicit place
    to put type annotations. But they actually serve several purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Export a module's public API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Document the types of a module's public API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a place to put module documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide non-public elements of a module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hide implementation details of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping in mind the points mentioned earlier, when would you *not* want to use
    a signature for your module? It's not set in stone, but my rule of thumb is to
    not use a signature when my API is experimental and still evolving (in semantic
    versioning terms, less than version 1.0.0.), or when the module is purely an application
    module and is not meant to be published as a library for others to consume (although
    the line between these is somewhat grainy).
  prefs: []
  type: TYPE_NORMAL
- en: Signatures come in two forms–**interface files** and **syntactic signatures***,*
    corresponding to implementations. Interface files are Reason source files that
    contain signatures and nothing else. Syntactic signatures are signatures that
    are defined specifically using Reason's syntax support for signatures.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the previously mentioned points chiefly by using interface files,
    but also show examples of syntactic signatures as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Exporting and documenting the public API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example of exporting and documenting a module''s public API.
    This is an interface file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few interesting things going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: Interface files must have the `.rei` (Reason Interface) file extension, with
    file names corresponding to the implementation file name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are using a new kind of comment, called a **documentation comment** (**doc
    comment**), to write documentation that will be publicly exported along with the
    API. Doc comments start with `/**` and end with `*/`. There are tools in the Reason
    ecosystem that can understand doc comments and format them for readers. Note that
    we usually don't use doc comments in implementation (`.re`) files because it usually
    doesn't make sense to expose implementation-specific documentation to users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any item in a module can be documented with doc comments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use a value declaration to tell Reason to export a value from the module,
    with the given type. In this case, the type of the value is a function type–this
    one reads "*ch 0 3 domain person t arrow string*" meaning *take a chapter 3 domain
    person type as input and return a string as output*. We will cover functions in
    more detail in a future chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, what does this interface file compile to? As it turns out: nothing. Interface
    files are purely compile-time constructs; they don''t exist at all at runtime.
    In fact, they are erased just like types because they are types. *Module interfaces
    are types.* A `.rei` file you write as an interface actually specifies the type
    of its corresponding `.re` implementation file.'
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic module signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Module signatures** are also known as **module types***.* Just like other
    types, module types specify what you can and can''t do with values of their type;
    in other words, they specify the surface area of a module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a syntactic module type and its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A syntactic module type has the `module type Type = {...declarations...};` form
    and specifies exactly what will be exported from a module that conforms to the
    type. Some key points to note in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a function''s (`make`) type with the `let funName: (param1Type,
    ..., paramNType) => returnType;` syntax.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We declare that a module conforms to a module type by appending a colon followed
    by the module type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define a `massage` function to properly case and trim input names, but this
    function is not declared in the module type, so it's never exported (that is,
    users of this module won't be able to access `massage`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We give a record field a specific expression as its value by using the `name:
    expression` syntax. We''ll cover record type syntax more fully in a later chapter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the (relevant part of the) JavaScript output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Reason `String` module name is **damaged slightly** (with a `$$` prefix)
    in the output to avoid a name clash with the existing JavaScript `String` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The returned person array value doesn't call the `massage` function. In fact,
    BuckleScript doesn't even emit a `massage` function, having determined that it
    can be inlined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Module errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fact that modules have types naturally leads to the fact that they can also
    throw type errors. Let's look at a couple of possible type errors related to modules.
  prefs: []
  type: TYPE_NORMAL
- en: Signature mismatch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What happens when we try to assign a module signature to a module that doesn''t
    implement that interface properly? Check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This message means that we forgot to include the `make` function in our implementation.
    The message is slightly strange, but makes sense if you know how Reason typechecks
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: It infers what it thinks should be the module type by examining the structure
    of the actual module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It compares the inferred type to the annotated module type, `PersonType`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not care about items that appear in the actual module but aren't declared
    in `PersonType` (it just hides those from the outside world)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does show errors on items that are declared in `PersonType` but are missing
    from the actual module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In short, you can''t overpromise and under-deliver. Knowing this, you can interpret
    the error message: the inferred module type is on top, and the annotated module
    type is beneath, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3bb0114-0483-4496-ad44-7c0ef9bea50c.png)'
  prefs: []
  type: TYPE_IMG
- en: Module type mismatch error diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'In Reason, modules are *structurally typed*: their types are made up of their
    structure, that is, by combining the types of their contained bindings in a syntactic
    form similar to the modules themselves. That''s why we''re able to write `module
    type Foo = {...declarations...};`–the `{...declarations...}` structural type is
    a first-class type by itself; we are just binding it to a name. A concrete result
    of this is that you can define a module and annotate it with a type directly,
    for example, `module Foo: {...declarations...} = {...bindings...};`. In a later
    chapter, we will examine structural typing further.'
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to understand is that you can't get a signature mismatch
    by implementing types and values in a different order from that in their signatures.
    You are still restricted to declaring or defining things before you use them,
    but the compiler will understand that a module conforms to a signature even if
    their declarations and definitions don't match up in exact order. To see a small
    example of this, look at the code sample in the upcoming *Type abstraction* section.
    The ordering of the `getter` functions is slightly different between the interface
    and the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This ordering flexibility can be a benefit if you're trying to arrange a module
    signature in a way that's easy to understand, that is, one that presents the most
    important items first. Sometimes, you don't need that level of flexibility, but
    you can always take advantage of it later if you find you do.
  prefs: []
  type: TYPE_NORMAL
- en: Value can't be found
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What happens when we try to use something that doesn''t exist in a module?
    Check out the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Reason checks, at compile time, whether the type of the module (`Ch03_Greet`)
    exports the named value (`process`), and it fails the build otherwise. There is
    no way to use a value that does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Type abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Reason, you can hide the implementation of a type and reveal exactly what
    you choose to. This *type abstraction* is one of the best techniques for *preserving
    invariants* (rules that should be obeyed) in your codebase. Type abstraction also
    allows modules to be decoupled from each other's implementation details, and work
    only with the information they have from exported interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: For example, look at the `Ch03_ModuleType.Person` module. It exports a `t` type
    to represent information about a person, and a `make` function to properly create
    values of the `t` type. The `make` function ensures that we properly trim and
    capitalize the names that we're given. We want to enforce the rule that names
    should have the proper casing and should not have surrounding whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is we can do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Because the `Ch03.ModuleType.Person.t` definition is exported, we can bypass
    the `make` function and directly create `t` values, breaking the rules that we
    want to apply for names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this problem by making `t` an abstract type (note that we must
    define both the interface and implementation files, as shown ahead):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now, `Ch03_AbstractPerson.t` is internally a record type just like the others,
    but it is exported as purely an abstract type with no implementation details *except*
    the operations we provide in the interface. These operations allow us to properly
    create `t` values and extract the person's ID and name from the `t` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We introduce two new types here: `id` and `name`, using the `type typeName
    = otherType;` syntax. This direct binding of a new type name to an existing type
    name is called a *type alias* (sometimes also called a *type abbreviation*). Type
    aliases don''t have any influence on typechecking, but they are a useful way to
    document our intentions and sometimes to shorten the names of longer type names.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we aliased `id` and `name`, we can use the shortcut that Reason provides
    when the field and type names are the same in a record type definition, called
    **punning**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we want to export the type aliases as well as the original types and operations,
    we need to repeat the same alias bindings in both the interface and the implementation.
    This bit of duplication allows Reason to double-check its inference against our
    intentions.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-allocation type abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we need to enforce rules over types that already exist. For example,
    in `Ch03_AbstractPerson`, we have a `name` type that is just a `string`, and a `massage` function
    that takes a string and applies some rules to it to turn it into a "well-behaved"
    name. We put this type and function inside another module in a rather adhoc way,
    because we were focusing on the concept of "person" and its operations and not
    so much on "name" and its operations.
  prefs: []
  type: TYPE_NORMAL
- en: However, we don't necessarily want to make a brand-new type for names that will
    allocate values on top of the already-allocated name strings. We'd like to preserve
    our naming rules (casing and trimming) while also being cheap with memory use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s extract the `name` type alias and its *smart constructor* (a `make` function
    that applies the rules we want to enforce when it makes values) into a dedicated
    module (again, note that we must define both the interface and implementation
    files for the module to be complete):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s new here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We declare a nested `Name` module with the given module type. We''re telling
    Reason: *Ch03_Person contains a module Name that exports these items*. Note that
    the `Name` module''s `t` type is abstract.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't make the `id` type abstract because we don't have to enforce any rules
    about how it should be created (we might in future though).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We don't need to make the `Ch03_Person.t` type abstract anymore now, because
    we've moved the name type and creation logic into `Name`. There's no way anyone
    can create the wrong `Ch03_Person.t` values because they must still go through
    `Name.make` to get names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make the `Ch03_Person` module functions use the `Name.t` type now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Name.t` type is implemented as just a `string`. It will not allocate anything
    at runtime.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `make` smart constructor will automatically enforce our rules for correct
    names. Also, we use the `ModuleName.(expression)` syntax here to temporarily *open* the
    `String` module for the scope of this one expression, bringing all its contained
    values into visibility. Opening modules temporarily in small scopes can be very
    handy to save some typing–but opening them for larger scopes can be risky because
    of potential name clashes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because `Name.t` is already just a `string`, *converting it back* to a `string`
    in `toString` entails just returning the input value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This structuring hits a good balance:'
  prefs: []
  type: TYPE_NORMAL
- en: It exposes the `person` record-type definition so that users can examine and
    use their values easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It imposes control over a critical piece of `person` data: the name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preventing type mix-ups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Earlier, I mentioned that we don''t need to make the `id` type abstract because
    we don''t have any rules for it right now. But there''s another good reason to
    make a simple type abstract: preventing mix-ups between the same *physical* types
    (in terms of the implementation) that represent different *logical* concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you had the following function and usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In `Ch02_Demo` we made the ID types, for both `person` and `company`, `int`.
    This can backfire if we accidentally pass function arguments in the wrong order
    and our system tries to *pay a bill* from a company to a person.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can prevent this kind of mix-up using a technique similar to the preceding
    one: make the person ID and company ID types logically distinct, while still physically
    representing them internally with just `int`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, some very interesting things are happening:'
  prefs: []
  type: TYPE_NORMAL
- en: We define an `Id` module signature, which declares an abstract `t` type, and
    a constructor and extractor function for values of `t`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define an `IntId` module, with no explicit signature, which exposes a `t` type
    equal to `int`, and constructor and extractor functions of the same name as in
    the `Id` signature
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We define two module aliases, `PersonId` and `CompanyId`, to `IntId`, and give
    them the explicit `Id` signature
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We make `PersonId.t` and `CompanyId.t` values
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we tried to compare the values, we''d get a type error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, Reason is able to distinguish between the two types, even though they're
    physically the same type, backed by the same module (`IntId`), just because they
    were explicitly annotated with a module type (`Id`) that prevents Reason from
    "seeing" the underlying types. Because of the signature and the abstract `t` type,
    Reason can't prove that `CompanyId.t` and `PersonId.t` are the same, so trying
    to compare them is a type error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that making these modules, even with explicit signatures, is very cheap
    allocation-wise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Reason reuses the same `IntId` module and distinguishes between their types
    purely at compile time. We can thus elegantly separate our concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Id` signature just says that there's a `t` type that can be converted to
    and from `int`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IntId` implements a module that is compatible with the `Id` signature but
    not explicitly annotated with it; thus showing that int-backed ID modules are
    one possible implementation of the `Id` signature'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PersonId` and `CompanyId` modules take advantage of the combination of
    `Id` and `IntId` to achieve type safety by telling the compiler it can't assume
    that the ID types are the same (even though we know they are)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, in Reason we have a level of fine-grained power that takes advantage
    of the compiler to achieve very lightweight code. We will see more techniques
    like this in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to package types and values together with modules,
    how to specify exactly what surface area we want to expose from our modules using
    signatures, and how to keep tight control over our data types using the combination
    of modules and signatures–even to the extent of controlling the memory allocation
    of data in our modules. In Reason, you'll notice this pattern a lot–you design
    the types to ensure that certain rules are enforced, and in a lot of situations,
    they will be enforced at no runtime cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, stay tuned—in the next chapter, we will cover some of the most important
    types that we use on a daily basis in type-driven development: product types that
    group values together for easy access.'
  prefs: []
  type: TYPE_NORMAL
