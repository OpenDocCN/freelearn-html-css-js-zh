- en: Chapter 10. Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of the web applications use some kind of authorization and authentication
    subsystems to allow its users to access private information of the application.
    However, the authentication process can be tricky if you don't have a clear idea
    about how to implement it as Backbone does not provide a hint about how to do
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Backbone is authentication agnostic, which means that its does not provide objects
    or tools to implement an authentication strategy. The advantage is that Backbone
    is not coupled with an authentication mechanism and the disadvantage is that you
    should care about it.
  prefs: []
  type: TYPE_NORMAL
- en: As Backbone was made with REST APIs in mind, you will have to deal with the
    authentication mechanisms that are common in that kind of APIs. That's a good
    reason why Backbone does not impose or provide tools in order to authenticate
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to keep in mind is that REST APIs should be stateless, which means
    that they do not keep track of the requests that you previously made. What it
    means for you is that if you make a login request, you will expect the server
    to recognize you on the subsequent requests; however, in a stateless server, it
    will not remember you.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound crazy if you have not worked with REST web services before; however,
    you have to authenticate each time you make a requests to the server. That's necessary
    and there are many available ways to do it; you should consult the API documentation
    in order to know the exact details of the authentication algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the many options that are available, they are very similar each other
    with changes in just some kind of details; however, in essence, they work in a
    very similar way. Therefore, don't worry about the number of different ways that
    are available to authenticate; learn the basics and change the details.
  prefs: []
  type: TYPE_NORMAL
- en: Stateless API authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authenticate against a stateless API implies that you should authenticate each
    time that you make a request to the server; keep in mind that a stateless server
    does not keep track of the previous requests. This means that each time you make
    a request to the server, it will process the petition as the first one.
  prefs: []
  type: TYPE_NORMAL
- en: As sessions are not stored in the server, you should put that information somewhere
    else. For Backbone applications, the right place to store the session data is
    the browser, you can use `localStorage` to store and retrieve the session data
    and JavaScript to manage the session.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Basic authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The simplest way to authenticate against a RESTFul API is with the HTTP Basic
    Authentication. The idea behind this is simple; you should include an encoded
    version of your username and password for every request you make. It may sound
    risky to send your user and password for each request, and it is. For this reason,
    it''s highly advisable to only use Basic authentication where you have the HTTPS
    connections enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HTTP Basic authentication](img/B01962_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 Basic authentication schema
  prefs: []
  type: TYPE_NORMAL
- en: 'The user and password should be sent under the `Authentication` header of the
    request. Consider the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: 'User: myuser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Password: 123456'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To encode the `Authentication` header, the user and password should be concatenated
    with the `:` character as the separator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the string should be encoded as `base64`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting string should be used for every request made to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The server will decode and authenticate you for each request you make. Remember
    that you should not use this mechanism without HTTPS. It's very easy for someone
    to intercept a request header and decode the string in order to discover your
    user and password.
  prefs: []
  type: TYPE_NORMAL
- en: The OAuth2 authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The OAuth2 protocol was made to share resources among services without the
    use of a user and password. It is possible that you have used an application where
    you can authenticate using a social network account. That''s OAuth2 in action.
    The OAuth2 authentication is an authorization framework described in RFC 6749,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The OAuth2 authentication](img/B01962_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 OAuth2 abstract flow
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, you can see an abstract diagram of authentication
    using the OAuth2 algorithm. You can identify the next entities, as shown in the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Resource Owner** is the entity that owns the protected data. This is normally
    a person.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Web application** is the application that wants to access the private
    data of the Resource Owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Authorization server** identifies and authenticates the users of the Resource
    server, where the protected data lives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **Access token** is the data to be used in the Resource server in order to
    authorize the resource access. The Access tokens normally have an expiration time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Resource server** is the host that serves the protected data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that the Resource server and the Authorization server can be the same
    host. The authentication process is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The application asks for authorization to the resource owner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource owner authorizes and an authorization key is issued.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application uses the authorization key to exchange it for an access token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server validates the authorization key and the applications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The authorization server issues an access token and returns it to the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The application can use the access token to access the protected resources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The issued access token should normally expire from time to time in order to
    prevent an attacker from using it maliciously. When a token expires, the application
    should repeat the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: However, it's not practical to log in each time that a token expires. In order
    to prevent this, the authorization server issues another token named `refresh
    token` that can be used to issue a new access token when the current access token
    expires.
  prefs: []
  type: TYPE_NORMAL
- en: Service applications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you want to access the private data of a service such as Facebook, Twitter,
    Google, and so on, you must register your application with the service first.
    When you register your application with the service, they will ask you for an
    application name, description, website, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the application is registered, the service will give you some tokens to
    identify your application, these tokens include two key data, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClientID**: This univocally identifies your application against the service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ClientSecret**: This is used to authenticate whether the request made with
    a given ClientID is legitimate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the REST server that you are building for your application is accessed only
    by you, you can manually generate a `ClientID` and `ClientSecret` as constant
    values in the application.
  prefs: []
  type: TYPE_NORMAL
- en: If your REST server will expose a public API for anyone who wants to play with
    the application data, you should develop some kind of application registration
    (such as user signup) in order to allow others to register their applications.
  prefs: []
  type: TYPE_NORMAL
- en: OAuth2 grant types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you have seen the OAuth2 protocol as an abstract schema
    of authentication. The RFC 6749 document specification describes four different
    ways to obtain an access token.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization code grant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Authorization code grant is the most complete authorization flow; its main
    usage is to access private resources of the user from another server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Authorization code grant](img/B01962_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 Authorization code grant
  prefs: []
  type: TYPE_NORMAL
- en: Refer to preceding figure. Server App is an application server (such as Node.js,
    Python, and so on), and the API Server is a third-party server, where the private
    resources lives (such as Facebook, Google, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: In the Authorization Code Grant scenario, the Server App wants to access the
    data from the API Server in benefit of the **User**. This is done through the
    Server App; as the user interacts with Backbone App, it makes requests to the
    Server App, then Server App can fetch the data from the API Server, apply some
    processing, and return a response to the Backbone App.
  prefs: []
  type: TYPE_NORMAL
- en: The Backbone App never establishes a single connection to the API Server, it
    is the responsibility of Server App so that Backbone App only sees a single Server
    App.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Grant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a simplification of Authorization Code Grant; the usage of implicit
    grant is for pure frontend applications without server or mobile applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implicit Grant](img/B01962_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 Implicit grant
  prefs: []
  type: TYPE_NORMAL
- en: In the implicit grant, App Server does not exist, therefore, the Backbone App
    should communicate directly with the API Server. Despite the simplicity of the
    implicit grant, you should be warned about the security issues.
  prefs: []
  type: TYPE_NORMAL
- en: To minimize this risk, your applications should be secured with HTTPS and do
    not use this flow type if you don't have it enabled. Another related issue is
    that this grant type does not issue a refresh token, which means that you should
    re-login when the access token expires.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Owner Password Credentials Grant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This grant type is useful when the Backbone App and API Server are the same
    application. In other words, the frontend application and the backend server are
    developed by you, which means that you are not accessing to third-party resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As your application owns all the resources, you will need the user and password
    of the application to authenticate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resource Owner Password Credentials Grant](img/B01962_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 Resource owner password
  prefs: []
  type: TYPE_NORMAL
- en: The preceding diagram is very similar to the Implicit Grant diagram; however,
    in this case, you don't need to use ClientID and ClientSecret tokens, which simplifies
    the authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: When you use this grant type, it feels like the classic way of authentication;
    you should send your user and password to the server and it will then tell you
    whether your credentials are valid or not. If they are valid, you will receive
    a valid access token that you can store and use as you want.
  prefs: []
  type: TYPE_NORMAL
- en: Client credentials grant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Client credentials grant is used when you have a trusted client that accesses
    the server resources. A business partner, for example. In this grant type, you
    are not authenticating an user but an application, therefore, you don't need an
    user or password.
  prefs: []
  type: TYPE_NORMAL
- en: In this grant, you should use ClientID and ClientSecret, if the API Server trusts
    the client, an access token will be issued.
  prefs: []
  type: TYPE_NORMAL
- en: '![Client credentials grant](img/B01962_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 Client credentials
  prefs: []
  type: TYPE_NORMAL
- en: Resume
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous sections, you have seen how to use the OAuth2 framework to authenticate
    against a REST server; in the OAuth2, specifications are described in four ways
    to make authentication and the use of any one of them depends on the requirements
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: However, the goal of the all these grant types is to get an access token that
    can be used for the next server request. Once you have an access token, the interaction
    with the API server should be transparent for Backbone App, the token should be
    send without the knowledge of rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing HTTP Basic Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's implement the Basic Auth protocol in `Contacts App`. As you have learned
    in the previous sections, you will need to add the `Authorization` header for
    every request that you make to the server in order to be authenticated. From the
    server side, you will need to read and parse this header.
  prefs: []
  type: TYPE_NORMAL
- en: 'A useful `npm` package to decode the `Authorization` header has been developed.
    With the `basic-auth` module, you can read the request headers and return an object
    with two fields: `name` and `pass`, these fields can be used to authenticate the
    user. For simplicity, we will use a hardcoded user and password, not a real database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The middleware checks whether the user is `john` and the password is `doe`.
    If not, an HTTP `401` error will be sent to the client. You can use the middleware
    for each resources that you want to protect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `WWW-Authenticate` header that we include in the HTTP 401 response will
    make sure that the browser prompts a dialog box asking you for a user and password.
    You can use the `john` user and the `doe` password in the dialog, then the browser
    will build and send the Authentication header for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing HTTP Basic Authentication](img/B01962_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.7 Basic authentication login
  prefs: []
  type: TYPE_NORMAL
- en: 'To have more control over how to ask for authentication, you can create a `form`
    view and add some routes for authentication purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LoginView` method should handle the authentication process when the user
    clicks the **Login** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A new route should be added to show the `#/login` form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You will need to include this new router when the application bootstraps, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When an unauthenticated user accesses the `#/contacts` route, Backbone Application
    should redirect them to the login form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the server responds with an HTTP 401, it means that the user is not authenticated
    and you then can show the login window. Remember to remove the `WWW-Authenticate`
    response header in order to prevent the browser from showing its login dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Implementing HTTP Basic Authentication](img/B01962_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.8 Login form
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a login form in place, we can put the authentication code
    in it. That''s going to be done in the following three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the Authentication string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test whether the Authentication string is valid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the Authentication string for future requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The authentication string is easy to build, you can use the `btoa()`function
    to convert strings to `base64`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use `authString` to test whether can get the contacts resource
    successfully. If the server answers successfully, then the user is using the right
    credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If the Authentication string is valid, then the user is redirected to the contact
    list; however, the redirection will not work as expected as the `Authorization`
    header in the contact list is not sent. Remember that you should send the Authorization
    header for every request.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to save the `Authentication` string in `sessionStorage` to be
    used in future requests. The `sessionStorage` is similar to `localStorage`; however,
    in `sessionStorage`, the data will be removed when the browser is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `App` object will be responsible for storing the token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After the token is saved in `sessionStorage`, you should include the `Authorization`
    header for every future request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application is bootstrapped, it should look whether there is an active
    session open; if so, it should use the session, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The user should be able to log out. Let''s add a route for the user to log
    out in the App router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The session is removed when the `auth` string is removed from `sessionStorage`
    and the Authentication header is not sent anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That's how you can implement authorization with the HTTP Basic Auth protocol.
    An authorization string is generated and attached for every request made to the
    server, that's done with the help of the `ajaxSetup()`method of jQuery. In the
    following section, we will see how to implement the OAuth2 protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing OAuth authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we did for Basic Auth, we are going to build a server-side implementation
    of the OAuth2 protocol. As the Backbone App and Server App are both built by us,
    the best grant type to choose is *Resource Owner Password Credentials Grant*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A difference from Basic Auth is that OAuth2 needs to add an endpoint that is
    used to issue access and refresh tokens. As described in RFC-6749, the requests
    made to this endpoint should include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*The client makes a request to the token endpoint by adding the following parameters
    using the "application/x-www-form-urlencoded":*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*grant_type: REQUIRED. Value MUST be set to "password".*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*username: REQUIRED. The resource owner username.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Password: REQUIRED. The resource owner password.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A valid request will look as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the server will respond with a valid access token, an optional refresh
    token, and a token type; it could contain additional values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `token_type` value tells the client about the kind of token that was issued,
    in our case, it is `Bearer`. We can start the implementation by creating the necessary
    functions in order to issue authorization tokens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As specified in the RFC document, if the grant type is not supported, then we
    should respond with an `invalid_grant` error; and if a parameter is missing in
    the request, then we should respond with an `invalid_request` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the username and password coincide, then we can issue an authorization token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated tokens are just a random string generated with the `generateToken()`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'These tokens should be stored somewhere in order to be validated for future
    requests. For simplicity, in this book, we will store the tokens in memory objects;
    however, you can use a databases such as Redis for real projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `validTokens` and `refreshTokens`are hash tables store the tokens. The tokens
    in `validTokens` should be removed after the **TTL** (**Time to live**) expires,
    the `setTimeout()` call will ensure that these items are automatically removed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate whether a user is authenticated, we just need to check whether
    the token is active in the `validTokens`hash table, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the function that is described in this section, it is possible to implement
    OAuth2 in our Contacts App project. Let''s add a route in order to generate the
    access tokens and add a middleware to protect the resources, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `oauth2Middleware` module provides the `requireAuthorization()` middleware
    and the `authenticate()`authentication handler as described in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To issue a new token, you need to call the `authorize()` function, which returns
    a valid OAuth2 response as specified in the RFC document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `requireAuthorization()` middleware is used to protect the resources with
    our OAuth2 protocol implementation. The middleware splits the token in two parts:
    the token type and the token itself; it verifies whether the token type and its
    existence in the active access tokens list is valid.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Backbone App, we can reuse the objects that we made for the Basic Auth
    protocol; however, we have to make small changes. In the `LoginView` object, you
    should change the `url` request to `/api/oauth/token` and change the method to
    `POST`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication in Backbone applications can be tricky if you don't have a clear
    vision of how authentication works in REST servers. As Backbone is authentication
    agnostic, it does not force you to use an authentication mechanism. As a developer,
    it's your responsibility to create one or adhere to an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: In Backbone Apps, backed by stateless servers, you should move the session handling
    code to the browser. In the examples shown in this chapter, we used `sessionStorage`
    to store the access tokens; however, you can use another storage solution such
    as `localStorage` and `indexeddb`, or even cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we saw how to combine the theory with the practical implementation of
    the Basic Auth and OAuth2 protocols in Contacts App. The implementation was transparent
    for the rest of the application, therefore, you can switch between the implementations
    easily.
  prefs: []
  type: TYPE_NORMAL
