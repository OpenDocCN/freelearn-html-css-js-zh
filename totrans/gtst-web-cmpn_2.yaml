- en: Web Components Life Cycle Callback Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we talked about how to create a Web Component using vanilla
    JavaScript and HTML5\. We discussed the specifications that are created in order
    to achieve the concept of Web Components. In this chapter, we will talk about
    life cycle events and the callback methods associated with them. A life cycle
    event is an event that occurs during the life cycle of a Web Component. This chapter
    deals with these events and how to access them with the help of callback methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of life cycle callback methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Life cycle callback methods currently available in Web Components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overview of life cycle callback methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life cycle events are events that are triggered inside a web component when
    it reaches a certain stage of execution. These stages reflect the overall process
    of creating a web component and can be controlled with the help of life cycle
    callback methods. Life cycle callback methods are hooks or interfaces that get
    called back whenever a Web Component goes through these life cycle events.
  prefs: []
  type: TYPE_NORMAL
- en: Let me explain this with the help of an example. Suppose you have a shoe that
    you would like to wear. There may be certain events associated with the life cycle
    of this shoe. Let's say you want to wear it. You put your foot in and tie the
    lace. This triggers an event called `lacesTied()`. Now, you as a user who is wearing
    this shoe may choose to act on it. You can write a conditional block to check
    whether `lacesTiedStrength > 100` or whether `shoeSize < requiredShoeSize`. It
    depends on what you want to do. Similarly, there are life cycle callback methods
    associated with a Web Component that help the user capture certain execution states
    and write code effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Types of life cycle callback methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four life cycle callbacks available to Web Components as of now.
    These are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`connectedCallback()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`disconnectedCallback()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`adoptedCallback()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attributeChangedCallback()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: connectedCallback()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This interface/callback gets invoked every time a copy of a Web Component gets
    added to the DOM. This is very useful when it comes to initializing events associated
    with the DOM inside the component, or state management (see [Chapter 5](0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml), *Managing
    States and Props*), or anything that needs any sort of initialization or pre-checks.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a look at an example. In [Chapter 1](a40f739f-c213-4862-a256-a7e76eff4370.xhtml),
    *Web Components Essentials and Specifications*, we talked about a `<student-attendance-table>`
    component, where the Web Component makes a fetch call to the file `student.json`, in
    order to retrieve the attendance data and then display that data in the form of
    a table.
  prefs: []
  type: TYPE_NORMAL
- en: The correct way to write that Web Component would be to add a `connectedCallback()`
    method to the definition of the `StudentAttendenceTable` class and then make the
    fetch call inside this callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what our code would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the code, we are now making a call to fetch the student list
    inside the `connectedCallback()` method. This makes sure that the code gets executed,
    once the Web Component is attached to the web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another example of a place where using the `connectedCallback` is helpful is
    event handling. Let''s say we have a Web Component that shows a custom button.
    And the purpose of this button is to show some text right next to it stating the
    number of times the button was clicked. If we try to use it without `connectedCallback`,
    it would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The associated HTML would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice how an event listener is bound to the DOM in the `connectedCallback()`
    method. We will be talking about event listeners in detail in the [Chapter 5](0330b4ac-5fed-441c-8747-ef9f14f91418.xhtml), *Managing
    States and Props*, but for now; we can use the code as an example. The preceding
    code makes sure that we bind a click event to the button only after the DOM is
    available on the page. This prevents us from creating event-related bugs, which
    I am sure has happened to every one of us.
  prefs: []
  type: TYPE_NORMAL
- en: disconnectedCallback()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like there are certain operations that need to be performed when a Web
    Component is added to the DOM, there are certain operations that need to be performed
    after the component is removed from the DOM. The most common example of this scenario
    is, again, event handlers. Event handlers consume memory, and, when the DOM associated
    with them is removed, the event handler is still on the page, listening to events,
    still consuming memory. The callback, `disconnectedCallback()`, gives Web Components
    a way to write code that can handle these scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `<custom-button>` element and how we can use `disconnectedCallback()`
    to remove the attached event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the `disconnectedCallback()` method, we have a `console.log`
    statement and the code to remove the event. When you are running this Web Component
    on a page, you can manually remove the component and see that `disconnectedCallback()`
    gets called automatically. I prefer going to the dev console and typing the following code
    to see it happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will remove the first instance of `<custom-button>` from the page, thus
    triggering the `disconnectedCallback()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Removing an event handler is only one of the uses. There can be *any* number
    of use cases that need to be performed before removing the Web Component from
    the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: adoptedCallback()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This callback gets triggered when the Web Component is moved from one parent
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like we had `connectedCallback` and `disconnectedCallback`, we can write
    `adoptedCallback` in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: attributeChangedCallback()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since all the custom elements act and behave like any other HTML element, they
    also have the ability to have attributes inside them. We will be discussing attributes
    in the coming chapter, but, for now, let's assume we have a custom element named
    `<my-name>`, whose purpose is to display the text Hello, my name is John Doe.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the definition of this Web Component would become something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s say we want to have a different name. And for every different name,
    we will need to have a different definition of the custom element, making a totally
    different Web Component. In order to fix this problem, we can use attributes.
    We can pass the name in an attribute inside the HTML tag of this element, making
    it look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'But, in order to make a Web Component use the attributes provided, we will
    first ask it to observe certain attributes, which we can provide in an array like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are just going to observe `fullname`. You can add more as per your
    requirement. We will be diving into attributes in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have started observing these attributes, we can then use the `attributeChangedCallback()`
    to make necessary changes to custom elements as per the requirement. I am simply
    updating the name in the following callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `attributeChangedCallback()` takes in three parameters: `name`,
    which is the name of the attribute changed, and `oldValue` and `newValue`, which
    are the values before and after the change, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, we are simply checking whether the name of the attribute
    is `fullname` and updating the text to say the updated name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full component code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `index.html` file associated with it becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are not doing anything different than what we have done in
    the previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we talked about what life cycle callback methods are and what
    purpose they serve. We talked about `connectedCallback()`, `disconnectedCallback()`,
    `adoptedCallback()`, and `attributeChangedCallback()`. We looked into various
    examples of how to use these callbacks and their practical uses.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into styling our Web Components with the help
    of CSS, and then we will talk about the gold standard checklist and its purpose.
  prefs: []
  type: TYPE_NORMAL
