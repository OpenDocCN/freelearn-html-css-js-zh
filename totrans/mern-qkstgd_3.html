<html><head></head><body><div><h1 class="header-title">Building a RESTful API</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>CRUD operations using ExpressJS' route methods</li>
<li>CRUD operations with Mongoose</li>
<li>Using Mongoose query builders</li>
<li>Defining document instance methods</li>
<li>Defining static model methods</li>
<li>Writing middleware functions for Mongoose</li>
<li>Writing custom validators for Mongoose's schemas</li>
<li>Building a RESTful API to manage users with ExpressJS and Mongoose</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>You will be required to have an IDE, Visual Studio Code, Node.js and MongoDB. You will also need to install Git, in order use the Git repository of this book.</p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter03">https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter03</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/73dE6u">https://goo.gl/73dE6u</a></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Introduction</h1>
                
            
            
                
<p><strong>Representation State Transfer</strong> (<strong>REST</strong>) is an architectural style that the web was built on. More specifically, the HTTP 1.1 protocol standards were built using the REST principles. REST provides a representation of a resource. <strong>URLs</strong> (<strong>Uniform Resource Locator</strong>) are used to define the location of a resource and tell the browser where it is located.</p>
<p>A RESTful API is a web service API that adheres to this architectural style.</p>
<p>The most commonly used HTTP verbs or methods are: <kbd>POST, GET, PUT,</kbd> and <kbd>DELETE</kbd>. These methods are the basis for persistent storage and are known as <strong>CRUD</strong> operations (<strong>Create, Read, Update, and Delete</strong>).</p>
<p>In this chapter, the recipes will be focused on building a RESTful API using the REST architectural style with ExpressJS and Mongoose.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">CRUD operations using ExpressJS' route methods</h1>
                
            
            
                
<p>ExpressJS' router has equivalent methods to handle HTTP methods. In other words, the HTTP methods <kbd>POST</kbd>, <kbd>GET</kbd>, <kbd>PUT</kbd>, and <kbd>DELETE</kbd> can be handled by this code:</p>
<pre>      /* Add a new user */ 
      app.post('/users', (request, response, next) =&gt; { }) 
      /* Get user */ 
      app.get('/users/:id', (request, response, next) =&gt; { }) 
      /* Update a user */ 
      app.put('/users/:id', (request, response, next) =&gt; { }) 
      /* Delete a user */ 
      app.delete('/users/:id', (request, response, next) =&gt; { })  </pre>
<p>It's good to think of every URL as a noun and because of that a verb can act on it. In fact, HTTP methods are also known as HTTP verbs. If we think about them as verbs, when a request is made to our RESTful API, they can be understood as:</p>
<ul>
<li>Post a user</li>
<li>Get a user</li>
<li>Update a user</li>
<li>Delete a user.</li>
</ul>
<p>In the <strong>MVC</strong> (<strong>model-view-controller</strong>) architectural pattern, controllers are in charge of transforming input to something a model or view can understand. In other words, they transform input into actions or commands and sends them to the model or view to update accordingly.</p>
<p>ExpressJS' route methods usually act as controllers. They just get input from a client such as a request from the browser, and then converts the input to actions. These actions are then sent to the model, which is the business logic of your application, such as a mongoose model, or to a view (a ReactJS client application) to update.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Keeping in mind that we can invoke an action over a resource using HTTP methods, we will see how to build a RESTful API web service based on those concepts. Before you start, create a new <kbd>package.json</kbd> file with the following code:</p>
<pre>      { 
        "dependencies": { 
          "express": "4.16.3", 
          "node-fetch": "2.1.1", 
          "uuid": "3.2.1" 
        } 
      } </pre>
<p>Then, install the dependencies by opening a terminal and running this line of code:</p>
<pre><strong>      npm install</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Build a RESTful API with an in-memory database or an array of objects that will contain a list of users. We will allow CRUD operations using HTTP methods to add a new user, get a user or list of users, update a user's data, and delete a user:</p>
<ol>
<li>Create a new file named <kbd>restfulapi.js</kbd></li>
<li>Import the packages that we need and create an ExpressJS application:</li>
</ol>
<pre>     const express = require('express') 
      const uuid = require('uuid') 
      const app = express() </pre>
<ol start="3">
<li>Define an in-memory database:</li>
</ol>
<pre>      let data = [ 
          { id: uuid(), name: 'Bob' }, 
          { id: uuid(), name: 'Alice' }, 
      ] </pre>
<ol start="4">
<li>Create a model which will contain functions for making CRUD operations:</li>
</ol>
<pre>      const usr = { 
          create(name) { 
              const user = { id: uuid(), name } 
              data.push(user) 
              return user 
          }, 
          read(id) { 
              if (id === 'all') return data 
              return data.find(user =&gt; user.id === id) 
          }, 
          update(id, name) { 
              const user = data.find(usr =&gt; usr.id === id) 
              if (!user) return { status: 'User not found' } 
              user.name = name 
              return user 
          }, 
          delete(id) { 
              data = data.filter(user =&gt; user.id !== id) 
              return { status: 'deleted', id } 
          } 
      } </pre>
<ol start="5">
<li>Add a request handler for the <kbd>post</kbd> method that will be used as a <kbd>Create</kbd> operation. A new user will be added to the <kbd>data</kbd> array:</li>
</ol>
<pre>      app.post('/users/:name', (req, res) =&gt; { 
          res.status(201).json(usr.create(req.params.name)) 
      }) </pre>
<ol start="6">
<li>Add a request handler for the <kbd>get</kbd> method that will be used as a <kbd>Read</kbd> or <kbd>Retrieve</kbd> operation. If an <kbd>id</kbd> is given, look for the user in the <kbd>data</kbd> array. However, If the given <kbd>id</kbd> is <kbd>"all"</kbd>, it will return the whole list of users:</li>
</ol>
<pre>      app.get('/users/:id', (req, res) =&gt; { 
          res.status(200).json(usr.read(req.params.id)) 
      }) </pre>
<ol start="7">
<li>Add a request handler for the <kbd>put</kbd> method that will be used as an <kbd>Update</kbd> operation. An <kbd>id</kbd> needs to be provided in order to update a specific user in the <kbd>data</kbd> array:</li>
</ol>
<pre>      app.put('/users/:id=:name', (req, res) =&gt; { 
          res.status(200).json(usr.update( 
              req.params.id, 
              req.params.name, 
          )) 
      }) </pre>
<ol start="8">
<li>Add a request handler for the <kbd>delete</kbd> method that will be used as a <kbd>Delete</kbd> operation. It will look for the user in the <kbd>data</kbd> array and remove it:</li>
</ol>
<pre>      app.delete('/users/:id', (req, res) =&gt; { 
          res.status(200).json(usr.delete(req.params.id)) 
      }) </pre>
<ol start="9">
<li>Start your application listening on port <kbd>1337</kbd> for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="10">
<li>Save the file.</li>
<li>Open a Terminal and run this code:</li>
</ol>
<pre><strong>      node restfulapi.js</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Let's test it...</h1>
                
            
            
                
<p>To make it simple, create a script that will request and make CRUD operations on our RESTful API server:</p>
<ol>
<li>Create a new file named <kbd>test-restfulapi.js</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre>      const fetch = require('node-fetch') 
      const r = async (url, method) =&gt; ( 
          await fetch(`http://localhost:1337${url}`, { method }) 
              .then(r =&gt; r.json()) 
      ) 
      const log = (...obj) =&gt; ( 
          obj.forEach(o =&gt; console.dir(o, { colors: true })) 
      ) 
      async function test() { 
          const users = await r('/users/all', 'get') 
          const { id } = users[0] 
          const getById = await r(`/users/${id}`, 'get') 
          const updateById = await r(`/users/${id}=John`, 'put') 
          const deleteById = await r(`/users/${id}`, 'delete') 
          const addUsr = await r(`/users/Smith`, 'post') 
          const getAll = await r('/users/all', 'get') 
          log('[GET] users:', users) 
          log(`[GET] a user with id="${id}":`, getById) 
          log(`[PUT] a user with id="${id}":`, updateById) 
          log(`[POST] a new user:`, addUsr) 
          log(`[DELETE] a user with id="${id}":`, deleteById) 
          log(`[GET] users:`, getAll) 
      } 
      test() </pre>
<ol start="3">
<li>Save the file.</li>
<li>Open a new Terminal and run this code:</li>
</ol>
<pre>    <strong>node test-restfulapi.js</strong>
  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Our RESTful API application will be running locally on port <kbd>1337</kbd>. When running the test code, it will connect to it and make several requests using different HTTP methods to create a user, retrieve a user, update a user, and delete a user. All the operations will be logged in the Terminal.</p>
<p>If you prefer to test it yourself, you can replace all the code inside the <kbd>test</kbd> function, and use the <kbd>r</kbd> function to make custom requests. For instance, to create a new user called <kbd>Smith</kbd>:</p>
<pre><strong>r(`/users/Smith`, 'post')</strong> </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">CRUD operations with Mongoose</h1>
                
            
            
                
<p>One of many reasons why developers opt to use Mongoose instead of the official MongoDB driver for Node.js is that it allows you to create data structures with ease by using schemas and also because of the built-in validation. MongoDB is a document-oriented database, meaning that the structure of the documents varies.</p>
<p>In the MVC architectural pattern, Mongoose is often used for creating models that shape or define data structures.</p>
<p>This is how a typical Mongoose schema would be defined and then compiled into a model:</p>
<pre>      const PersonSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
      }) 
      const Person = connection.model('Person', PersonSchema) </pre>
<p>Model names should be in singular since Mongoose will make them plural and lowercase them when saving the collection to the database. For instance, if the model is named "User", it will be saved as a collection named "users" in MongoDB. Mongoose includes an internal dictionary to pluralize common names. That means if your model's name is a common name, such as "Person", it will be saved in MongoDB as a collection named "people".</p>
<p>Mongoose allows the following types to define a schema's path or document structure:</p>
<ul>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Date</li>
<li>Buffer</li>
<li>Mixed</li>
<li>Objectid</li>
<li>Decimal128</li>
</ul>
<p>A schema type can be declared by using directly the global constructor function for <kbd>String</kbd>, <kbd>Number</kbd>, <kbd>Boolean</kbd>, <kbd>Buffer</kbd>, and <kbd>Date</kbd>:</p>
<pre>      const { Schema} = require('mongoose') 
      const PersonSchema = new Schema({ 
          name: String, 
          age: Number, 
          isSingle: Boolean, 
          birthday: Date, 
          description: Buffer, 
      }) </pre>
<p>These schema types are also available under an object called <kbd>SchemaTypes</kbd> in the exported <kbd>mongoose</kbd> object:</p>
<pre>      const { Schema, SchemaTypes } = require('mongoose') 
      const PersonSchema = new Schema({ 
          name: SchemaTypes.String, 
          age: SchemaTypes.Number, 
          isSingle: SchemaTypes.Boolean, 
          birthday: SchemaTypes.Date, 
          description: SchemaTypes.Buffer, 
      }) </pre>
<p>Schema types can be declared using an object as a property that gives you more control over the specific schema type. Take the following code, for example:</p>
<pre>      const { Schema } = require('mongoose') 
      const PersonSchema = new Schema({ 
          name: { type: String, required: true, default: 'Unknown' }, 
          age: { type: Number, min: 18, max: 80, required: true }, 
          isSingle: { type: Boolean }, 
          birthday: { type: Date, required: true }, 
          description: { type: Buffer }, 
      }) </pre>
<p>Schema types can also be arrays. For instance, if we want a field to define what are the things the user likes in an array of strings, you could use this code:</p>
<pre>      const PersonSchema = new Schema({ 
          name: String, 
          age: Number, 
          likes: [String], 
      }) </pre>
<p>To learn more about schema types, visit the official Mongoose documentation website: <a href="http://mongoosejs.com/docs/schematypes.html">http://mongoosejs.com/docs/schematypes.html</a>.<a href="http://mongoosejs.com/docs/schematypes.html"/></p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, you will see how to define a schema and perform CRUD operation on the database collection. First, ensure that you have MongoDB installed and it's running. As an alternative, if you prefer, a MongoDB <strong>DBaaS</strong> (<strong>Database as a Service</strong>) instance in the cloud will also do. Before you start, create a new <kbd>package.json</kbd> file with the following code:</p>
<pre>      { 
        "dependencies": { 
          "mongoose": "5.0.11" 
       } 
     } </pre>
<p>Then, install the dependencies by opening a Terminal and running this code:</p>
<pre><strong>      npm install</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Define a user schema that will contain user's first name, last name, and an array of strings that define the things the user likes:</p>
<ol>
<li>Create a new file named <kbd>mongoose-models.js</kbd></li>
<li>Include the Mongoose NPM module. Then, create a connection to MongoDB:</li>
</ol>
<pre>      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) </pre>
<ol start="3">
<li>Define a schema:</li>
</ol>
<pre>      const UserSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
          likes: [String], 
      }) </pre>
<ol start="4">
<li>Compile the schema into a model:</li>
</ol>
<pre>      const User = mongoose.model('User', UserSchema) </pre>
<ol start="5">
<li>Define a function that will be used for adding new users:</li>
</ol>
<pre>      const addUser = (firstName, lastName) =&gt; new User({ 
          firstName, 
          lastName, 
      }).save() </pre>
<ol start="6">
<li>Define a function that will be used for retrieving a user from the collection of users by its <kbd>id</kbd>:</li>
</ol>
<pre>      const getUser = (id) =&gt; User.findById(id) </pre>
<ol start="7">
<li>Define a function that will remove the user from the collection of users by its <kbd>id</kbd>:</li>
</ol>
<pre>      const removeUser = (id) =&gt; User.remove({ id }) </pre>
<ol start="8">
<li>Define an event listener that will perform CRUD operations once the there is a connection to the database. First, add a new user and save it. Then, retrieve the same user using its <kbd>id</kbd>. Next, modify the user's properties and save it. Finally, remove the user from the collection by its <kbd>id</kbd>:</li>
</ol>
<pre>      connection.once('connected', async () =&gt; { 
          try { 
              // Create 
              const newUser = await addUser('John', 'Smith') 
              // Read 
              const user = await getUser(newUser.id) 
              // Update 
              user.firstName = 'Jonny' 
              user.lastName = 'Smithy' 
              user.likes = [ 
                  'cooking', 
                  'watching movies', 
                  'ice cream', 
              ] 
              await user.save() 
              console.log(JSON.stringify(user, null, 4)) 
              // Delete 
              await removeUser(user.id) 
          } catch (error) { 
              console.dir(error.message, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) </pre>
<ol start="9">
<li>Save the file.</li>
<li>Open a Terminal and run this code:</li>
</ol>
<pre>    <strong>node mongoose-models.js</strong></pre>
<p>Executing the previous command in the Terminal, if successful, would display something similar to the following, for instance, a code such as this:</p>
<pre>      { 
          "likes": [ 
        "cooking", 
              "watching movies", 
              "ice cream" 
                ], 
          "_id": "[some id]", 
          "firstName": "Jonny", 
          "lastName": "Smithy", 
          "__v": 1 
      } </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing NPM Packages</em></li>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing MongoDB</em></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Using Mongoose query builders</h1>
                
            
            
                
<p>Every Mongoose model has static helper methods to do several kinds of operations, such as retrieving a document. When a callback is passed to these helper methods, the operation is executed immediately:</p>
<pre>      const user = await User.findOne({ 
          firstName: 'Jonh', 
          age: { $lte: 30 }, 
      }, (error, document) =&gt; { 
          if (error) return console.log(error) 
          console.log(document) 
      }) </pre>
<p>Otherwise, if there is no defined callback, a <em>query builder interface</em> is returned, which can be later executed:</p>
<pre>      const user = User.findOne({ 
          firstName: 'Jonh', 
          age: { $lte: 30 }, 
      }) 
      user.exec((error, document) =&gt; { 
          if (error) return console.log(error) 
          console.log(document) 
      }) </pre>
<p>Queries also have a <kbd>.then</kbd> function which can be used as a <kbd>Promise</kbd>. When <kbd>.then</kbd> is called, it first executes the query internally with <kbd>.exec</kbd> which then returns a <kbd>Promise</kbd>. This allows us to use <kbd>async/await</kbd> as well. Inside a <kbd>async</kbd> function, for instance:</p>
<pre>      try { 
          const user = await User.findOne({ 
              firstName: 'Jonh', 
              age: { $lte: 30 }, 
          }) 
          console.log(user) 
      } catch (error) { 
          console.log(error) 
      }  </pre>
<p>There are two ways that we can make a query. One is by providing a JSON object that is used as a condition and the other way allows you to create a query using chaining syntax. The chaining syntax will feel more comfortable to developers who are more familiar with SQL databases. For example:</p>
<pre>      try { 
          const user = await User.findOne() 
        .where('firstName', 'John') 
              .where('age').lte(30) 
          console.log(user) 
      }       catch (error) { 
          console.log(error) 
      }  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, you will build up queries using chaining syntax and using <kbd>async/await</kbd> functions. First, ensure that you have MongoDB installed and it's running. As an alternative, if you prefer, a MongoDB DBaaS instance in the cloud will also do. Before you start, create a new <kbd>package.json</kbd> file with the following code:</p>
<pre>      { 
        "dependencies": { 
          "mongoose": "5.0.11" 
        } 
      } </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>      npm install</strong>  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new file named <kbd>chaining-queries.js</kbd></li>
</ol>
<ol start="2">
<li>Include the Mongoose NPM module. Then, create a new connection:</li>
</ol>
<pre>      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) </pre>
<ol start="3">
<li>Define a schema:</li>
</ol>
<pre>      const UserSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
          age: Number, 
      }) </pre>
<ol start="4">
<li>Compile the schema into a model:</li>
</ol>
<pre>      const User = mongoose.model('User', UserSchema) </pre>
<ol start="5">
<li>Once connected to the database, add a new document to the collection of users. Then, using chaining syntax, query for the recently created user. Additionally, use the <kbd>select</kbd> method to restrict which fields are retrieved from the document:</li>
</ol>
<pre>      connection.once('connected', async () =&gt; { 
          try { 
              const user = await new User({ 
                  firstName: 'John', 
                  lastName: 'Snow', 
                  age: 30, 
              }).save() 
              const findUser = await User.findOne() 
                  .where('firstName').equals('John') 
                  .where('age').lte(30) 
                  .select('lastName age') 
              console.log(JSON.stringify(findUser, null, 4)) 
              await user.remove() 
          } catch (error) { 
              console.dir(error.message, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a Terminal and run:</li>
</ol>
<pre>    <strong>node chaining-queries.js</strong>
  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing NPM Packages</em></li>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing MongoDB</em></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Defining document instance methods</h1>
                
            
            
                
<p>Documents have their own built-in instance methods such as <kbd>save</kbd> and <kbd>remove</kbd>. However, we can write our own instance methods as well.</p>
<p>Documents are instances of models. They can be explicitly created:</p>
<pre>      const instance = new Model() </pre>
<p>Or they can be the result of a query:</p>
<pre>      Model.findOne([conditions]).then((instance) =&gt; {}) </pre>
<p>Document instance methods are defined in the schema. All schemas have a method called <kbd>method</kbd> which allows you to define custom instance methods.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, you will define a schema and custom document instance methods for modifying and reading document properties. First, ensure that you have MongoDB installed and it's running. As an alternative, if you prefer, a MongoDB DBaaS instance in the cloud will also do. Before you start, create a new <kbd>package.json</kbd> file with the following code:</p>
<pre>{ 
  "dependencies": { 
    "mongoose": "5.0.11" 
  } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running this code:</p>
<pre>    <strong>npm install</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Create a new file named <kbd>document-methods.js</kbd></li>
<li>Include the Mongoose NPM module. Then, create a new connection to MongoDB:</li>
</ol>
<pre>      const mongooconst mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) </pre>
<ol start="3">
<li>Define a schema:</li>
</ol>
<pre>      const UserSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
          likes: [String], 
      }) </pre>
<ol start="4">
<li>Define a document instance method for setting a user's first name and last name from a string containing their full name:</li>
</ol>
<pre>      UserSchema.method('setFullName', function setFullName(v) { 
          const fullName = String(v).split(' ') 
          this.lastName = fullName[0] || '' 
          this.firstName = fullName[1] || '' 
      }) </pre>
<ol start="5">
<li>Define a document instance method for getting a user's full name concatenating the <kbd>firstName</kbd> and <kbd>lastName</kbd> properties:</li>
</ol>
<pre>      UserSchema.method('getFullName', function getFullName() { 
          return `${this.lastName} ${this.firstName}` 
      }) </pre>
<ol start="6">
<li>Define a document instance method named <kbd>loves</kbd> that will expect one argument that will add to the <kbd>likes</kbd> array of strings:</li>
</ol>
<pre>      UserSchema.method('loves', function loves(stuff) { 
          this.likes.push(stuff) 
      }) </pre>
<ol start="7">
<li>Define a document instance method named <kbd>dislikes</kbd> which will remove one thing previous liked by the user from the <kbd>likes</kbd> array:</li>
</ol>
<pre>      UserSchema.method('dislikes', function dislikes(stuff) { 
          this.likes = this.likes.filter(str =&gt; str !== stuff) 
      }) </pre>
<ol start="8">
<li>Compile the schema into a model:</li>
</ol>
<pre>      const User = mongoose.model('User', UserSchema) </pre>
<ol start="9">
<li>Once Mongoose is connected to the database, create a new user and use <kbd>setFullName</kbd> method to populate the fields <kbd>firstName</kbd> and <kbd>lastName</kbd>, then use the <kbd>loves</kbd> method to populate the <kbd>likes</kbd> array. Next, use chaining syntax to query for the user in the collection and use the <kbd>dislikes</kbd> method to remove <kbd>"snakes"</kbd> from the <kbd>likes</kbd> array:</li>
</ol>
<pre>      connection.once('connected', async () =&gt; { 
          try { 
              // Create 
              const user = new User() 
              user.setFullName('Huang Jingxuan') 
              user.loves('kitties') 
              user.loves('strawberries') 
              user.loves('snakes') 
              await user.save() 
              // Update 
              const person = await User.findOne() 
                  .where('firstName', 'Jingxuan') 
                  .where('likes').in(['snakes', 'kitties']) 
              person.dislikes('snakes') 
              await person.save() 
              // Display 
              console.log(person.getFullName()) 
              console.log(JSON.stringify(person, null, 4)) 
              // Remove 
              await user.remove() 
          } catch (error) { 
              console.dir(error.message, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) </pre>
<ol start="10">
<li>Save the file.</li>
<li>Open a Terminal and run this code:</li>
</ol>
<pre>       <strong>node document-methods.js</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Document instance methods can also be defined using the <kbd>methods</kbd>, schema property. For instance:</p>
<pre>UserSchema.methods.setFullName = function setFullName(v) { 
    const fullName = String(v).split(' ') 
    this.lastName = fullName[0] || '' 
    this.firstName = fullName[1] || '' 
} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing NPM Packages</em></li>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing MongoDB</em></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Defining static model methods</h1>
                
            
            
                
<p>Models have built-in static methods such as <kbd>find</kbd>, <kbd>findOne</kbd>, and <kbd>findOneAndRemove</kbd>. Mongoose allow us to define custom static model methods as well. Static model methods are defined in the schema in the same way as document instance methods are.</p>
<p>Schemas have a property called <kbd>statics</kbd> which is an object. All the methods defined inside the <kbd>statics</kbd> object are passed to the model. Static model methods can also be defined by calling the <kbd>static</kbd> schema method.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, you will define a schema and custom static model method for expanding your model's capabilities. First, ensure that you have MongoDB installed and it's running. As an alternative, if you prefer, a MongoDB DBaaS instance in the cloud will also do. Before you start, create a new <kbd>package.json</kbd> file with the following code:</p>
<pre>{ 
  "dependencies": { 
    "mongoose": "5.0.11" 
  } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>npm install</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Define a static model method called <kbd>getByFullName</kbd> that will allow you to search for a specific user using their full name:</p>
<ol>
<li>Create a new file named <kbd>static-methods.js</kbd></li>
<li>Include the Mongoose NPM module and create a new connection to your MongoDB:</li>
</ol>
<pre>      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) </pre>
<ol start="3">
<li>Define a schema:</li>
</ol>
<pre>      const UsrSchm = new Schema({ 
          firstName: String, 
          lastName: String, 
          likes: [String], 
      }) </pre>
<ol start="4">
<li>Define <kbd>getByFullName</kbd> static model method:</li>
</ol>
<pre>      UsrSchm.static('getByFullName', function getByFullName(v) { 
          const fullName = String(v).split(' ') 
          const lastName = fullName[0] || '' 
          const firstName = fullName[1] || '' 
          return this.findOne() 
              .where('firstName').equals(firstName) 
              .where('lastName').equals(lastName) 
      }) </pre>
<ol start="5">
<li>Compile the schema into a model:</li>
</ol>
<pre>      const User = mongoose.model('User', UsrSchm) </pre>
<ol start="6">
<li>Once connected, create a new user and save it. Then, use the <kbd>getByFullName</kbd> static model method to look for the user in the collection of users using their full name:</li>
</ol>
<pre>      connection.once('connected', async () =&gt; { 
          try { 
              // Create 
              const user = new User({ 
                  firstName: 'Jingxuan', 
                  lastName: 'Huang', 
                  likes: ['kitties', 'strawberries'], 
              }) 
              await user.save() 
              // Read 
              const person = await User.getByFullName( 
                  'Huang Jingxuan' 
              ) 
              console.log(JSON.stringify(person, null, 4)) 
              await person.remove() 
              await connection.close() 
          } catch (error) { 
              console.log(error.message) 
          } 
      }) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a Terminal and run this code:</li>
</ol>
<pre>    <strong>node static-methods.js</strong>
  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Static model methods can also be defined using the <kbd>statics</kbd> schema property. For instance:</p>
<pre>UsrSchm.statics.getByFullName = function getByFullName(v) { 
    const fullName = String(v).split(' ') 
    const lastName = fullName[0] || '' 
    const firstName = fullName[1] || '' 
    return this.findOne() 
        .where('firstName').equals(firstName) 
        .where('lastName').equals(lastName) 
} </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing NPM Packages</em></li>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing MongoDB</em></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Writing middleware functions for Mongoose</h1>
                
            
            
                
<p>Middleware functions in Mongoose are also called <kbd>hooks</kbd>. There are two types of hooks <kbd>pre hooks</kbd> and <kbd>post hooks</kbd>.</p>
<p>The difference, between <kbd>pre hooks</kbd> and post hooks, is pretty simple. <kbd>pre hooks</kbd> are called before a method is called, and <kbd>post hooks</kbd> are called after. For example:</p>
<pre>      const UserSchema = new Schema({ 
          firstName: String, 
          lastName: String, 
          fullName: String, 
      }) 
      UserSchema.pre('save', async function preSave() { 
          this.fullName = `${this.lastName} ${this.firstName}` 
      }) 
      UserSchema.post('save', async function postSave(doc) { 
          console.log(`New user created: ${doc.fullName}`) 
      }) 
      const User = mongoose.model('User', UserSchema) </pre>
<p>And later on, once the connection is made to the database, within an <kbd>async</kbd> function:</p>
<pre>      const user = new User({ 
          firstName: 'John', 
          lastName: 'Smith', 
      }) 
      await user.save() </pre>
<p>Once the <kbd>save</kbd> method is called, the <kbd>pre hook</kbd> is executed first. After the document is saved, the <kbd>post hook</kbd> is then executed. In the previous example, it will display in the Terminal output the following text:</p>
<pre>    <strong>New user created: Smith John</strong></pre>
<p>There are four different types of middleware functions in Mongoose: document middleware, model middleware, aggregate middleware, and query middleware. All of them are defined on the schema level. The difference is, when the hooks are executed, the context of<kbd>this</kbd> refers to the document, model, the aggregation object, or the query object.</p>
<p>All types of middleware support pre and post hooks</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, we will see how three of these types of middleware functions work in Mongoose:</p>
<ul>
<li>Document middleware</li>
<li>Model middleware</li>
<li>Query middleware</li>
</ul>
<p>First, ensure that you have MongoDB installed and it's running. As an alternative, if you prefer, a MongoDB DBaaS instance in the cloud will also do. Before you start, create a new <kbd>package.json</kbd> file with the following code:</p>
<pre>      { 
        "dependencies": { 
          "mongoose": "5.0.11" 
        } 
      } </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>      npm install</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In document middleware functions, the context of <kbd>this</kbd> refers to the document. A document has the following built-in methods and you can define <kbd>hooks</kbd> for them:</p>
<ul>
<li><kbd>init</kbd>: This is called internally, immediately after a document is returned from MongoDB. Mongoose uses setters for marking the document as modified or which fields of the document were modified. <kbd>init</kbd> initializes the document without setters.</li>
<li><kbd>validate</kbd>: This executes built-in and custom set validation rules for the document.</li>
<li><kbd>save</kbd>: This saves the document in the database.</li>
<li><kbd>remove</kbd>: This removes the document from the database.</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Document middleware functions</h1>
                
            
            
                
<p>Create <kbd>pre</kbd> and <kbd>post</kbd> hooks for the document built-in methods:</p>
<ol>
<li>Create a new file named <kbd>1-document-middleware.js</kbd></li>
<li>Include the Mongoose NPM module and create a new connection to your MongoDB:</li>
</ol>
<pre>      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) </pre>
<ol start="3">
<li>Define a schema:</li>
</ol>
<pre>      const UserSchema = new Schema({ 
          firstName: { type: String, required: true }, 
          lastName: { type: String, required: true }, 
      }) </pre>
<ol start="4">
<li>Add a <kbd>pre</kbd> and <kbd>post</kbd> hook for the <kbd>init</kbd> document method:</li>
</ol>
<pre>      UserSchema.pre('init', async function preInit() { 
          console.log('A document is going to be initialized.') 
      }) 
      UserSchema.post('init', async function postInit() { 
          console.log('A document was initialized.') 
      }) </pre>
<ol start="5">
<li>Add a <kbd>pre</kbd> and <kbd>post</kbd> hook for the <kbd>validate</kbd> document method:</li>
</ol>
<pre>      UserSchema.pre('validate', async function preValidate() { 
          console.log('A document is going to be validated.') 
      }) 
      UserSchema.post('validate', async function postValidate() { 
          console.log('All validation rules were executed.') 
      }) </pre>
<ol start="6">
<li>Add a <kbd>pre</kbd> and <kbd>post</kbd> hook for the <kbd>save</kbd> document method:</li>
</ol>
<pre>      UserSchema.pre('save', async function preSave() { 
          console.log('Preparing to save the document') 
      }) 
      UserSchema.post('save', async function postSave() { 
          console.log(`A doc was saved id=${this.id}`) 
      }) </pre>
<ol start="7">
<li>Add a <kbd>pre</kbd> and <kbd>post</kbd> hook for the <kbd>remove</kbd> document method:</li>
</ol>
<pre>      UserSchema.pre('remove', async function preRemove() { 
          console.log(`Doc with id=${this.id} will be removed`) 
      }) 
      UserSchema.post('remove', async function postRemove() { 
          console.log(`Doc with id=${this.id} was removed`) 
      }) </pre>
<ol start="8">
<li>Compile the schema into a model:</li>
</ol>
<pre>      const User = mongoose.model('User', UserSchema) </pre>
<ol start="9">
<li>Once a new connection is established, create a document and perform some basic operations such as saving, retrieving, and deleting the document:</li>
</ol>
<pre>      connection.once('connected', async () =&gt; { 
          try { 
              const user = new User({ 
                  firstName: 'John', 
                  lastName: 'Smith', 
              }) 
              await user.save() 
              await User.findById(user.id) 
              await user.remove() 
              await connection.close() 
          } catch (error) { 
              await connection.close() 
              console.dir(error.message, { colors: true }) 
          } 
      }) </pre>
<ol start="10">
<li>Save the file</li>
<li>Open a Terminal and run:</li>
</ol>
<pre><strong>      node document-middleware.js</strong></pre>
<ol start="12">
<li>On the terminal, the output should display:</li>
</ol>
<pre>      A document is going to be validated. 
      All validation rules were executed. 
      Preparing to save the document 
      A doc was saved id=[ID] 
      A document is going to be initialized. 
      A document was initialized. 
      Doc with id=[ID] will be removed 
      Doc with id=[ID] was removed </pre>
<p>When you save a document, it first triggers the <kbd>validation</kbd> hooks that ensure that the fields pass the rules set by built-in validation rules or custom rules. In your code, the fields are marked as required. Then it will trigger the <kbd>save</kbd> hooks. After, using a model method to retrieve the recently created user from the database, once the document is retrieved, it triggers the <kbd>init</kbd> hooks. Finally, removing the document from the database triggers the <kbd>remove</kbd> hooks.</p>
<p>Within the hooks, you can interact with the document. For instance, the following <kbd>save</kbd> pre hook will modify the fields <kbd>firstName</kbd> and <kbd>lastName</kbd> to make them upper-cased strings:</p>
<pre>UserSchema.pre('save', async function preSave() { 
    this.firstName = this.firstName.toUpperCase() 
    this.lastName = this.lastName.toUpperCase() 
}) </pre>
<p>The same way, we can throw an error within the hook to prevent the next ones from being executed. For instance:</p>
<pre>UserSchema.pre('save', async function preSave() { 
    throw new Error('Doc was prevented from being saved.') 
}) </pre>
<p>Query middleware functions are defined exactly as document middleware functions are. However, the context of <kbd>this</kbd> doesn't not refer to the document but instead to the query object. Query middleware functions are only supported in the following model and query functions:</p>
<ul>
<li><kbd>count</kbd>: Counts the number of document that match a specific query condition</li>
<li><kbd>find</kbd>: Returns an array of documents that match a specific query condition</li>
<li><kbd>findOne</kbd>: Return a document that matches a specific query condition</li>
<li><kbd>findOneAndRemove</kbd>: Similar to <kbd>findOne</kbd>. However, after a document is found, it is removed</li>
<li><kbd>findOneAndUpdate</kbd>: Similar to <kbd>findOne</kbd> but once a document matching a specific query condition is found, the document can also be updated</li>
<li><kbd>update</kbd>: Update one or more documents that match a certain query condition</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Query middleware functions</h1>
                
            
            
                
<p>Create pre and post hooks for query built-in methods:</p>
<ol>
<li>Create a new file named <kbd>2-query-middleware.js</kbd></li>
<li>Include the Mongoose NPM module and create a new connection to your MongoDB:</li>
</ol>
<pre>      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) </pre>
<ol start="3">
<li>Define a schema:</li>
</ol>
<pre>      const UserSchema = new Schema({ 
          firstName: { type: String, required: true }, 
          lastName: { type: String, required: true }, 
      }) </pre>
<ol start="4">
<li>Define pre and post hooks for the <kbd>count</kbd>, <kbd>find</kbd>, <kbd>findOne</kbd>, and <kbd>update</kbd> methods:</li>
</ol>
<pre>      UserSchema.pre('count', async function preCount() { 
          console.log( 
              `Preparing to count document with this criteria: 
              ${JSON.stringify(this._conditions)}` 
          ) 
      }) 
      UserSchema.post('count', async function postCount(count) { 
          console.log(`Counted ${count} documents that coincide`) 
      }) 
      UserSchema.pre('find', async function preFind() { 
          console.log( 
              `Preparing to find all documents with criteria: 
              ${JSON.stringify(this._conditions)}` 
          ) 
      }) 
      UserSchema.post('find', async function postFind(docs) { 
          console.log(`Found ${docs.length} documents`) 
      }) 
      UserSchema.pre('findOne', async function prefOne() { 
          console.log( 
              `Preparing to find one document with criteria: 
              ${JSON.stringify(this._conditions)}` 
          ) 
      }) 
      UserSchema.post('findOne', async function postfOne(doc) { 
          console.log(`Found 1 document:`, JSON.stringify(doc)) 
      }) 
      UserSchema.pre('update', async function preUpdate() { 
          console.log( 
              `Preparing to update all documents with criteria: 
              ${JSON.stringify(this._conditions)}` 
          ) 
      }) 
      UserSchema.post('update', async function postUpdate(r) { 
          console.log(`${r.result.ok} document(s) were updated`) 
      }) </pre>
<ol start="5">
<li>Compile the schema into a model:</li>
</ol>
<pre>      const User = mongoose.model('User', UserSchema) </pre>
<ol start="6">
<li>Once the connection to the database is successfully made, create a document, save it, and use the methods for which we defined hooks for:</li>
</ol>
<pre>      connection.once('connected', async () =&gt; { 
          try { 
              const user = new User({ 
                  firstName: 'John', 
                  lastName: 'Smith', 
              }) 
              await user.save() 
              await User 
                  .where('firstName').equals('John') 
                  .update({ lastName: 'Anderson' }) 
              await User 
                  .findOne() 
                  .select(['lastName']) 
                  .where('firstName').equals('John') 
              await User 
                  .find() 
                  .where('firstName').equals('John') 
              await User 
                  .where('firstName').equals('Neo') 
                  .count() 
              await user.remove() 
          } catch (error) { 
              console.dir(error, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) </pre>
<ol start="7">
<li>Save the file</li>
<li>Open a Terminal and run:</li>
</ol>
<pre><strong>      node query-middleware.js</strong></pre>
<ol start="9">
<li>On the terminal, the output should display something similar to:</li>
</ol>
<pre>      Preparing to update all documents with criteria: 
                {"firstName":"John"} 
      1 document(s) were updated 
      Preparing to find one document with criteria: 
                {"firstName":"John"} 
      Found 1 document: {"_id":"[ID]","lastName":"Anderson"} 
      Preparing to find all documents with criteria: 
                {"firstName":"John"} 
      Found 1 documents 
      Preparing to count document with this criteria: 
                {"firstName":"Neo"} 
      Counted 0 documents that coincide </pre>
<p>Finally, there is only one model instance method that supports hooks:</p>
<ul>
<li><kbd>insertMany</kbd>: This validates an array of documents and saves them in the database only if all the documents in the array passed validation</li>
</ul>
<p>As you probably guessed, a model middleware function is also defined in the same way as query middleware methods and document middleware methods are.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Model middleware functions</h1>
                
            
            
                
<p>Create a <kbd>pre</kbd> and <kbd>post</kbd> hook for the <kbd>insertMany</kbd> model instance method:</p>
<ol>
<li>Create a new file named <kbd>3-model-middleware.js</kbd></li>
<li>Include the Mongoose NPM module and create a new connection to your MongoDB:</li>
</ol>
<pre>      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) </pre>
<ol start="3">
<li>Define a schema:</li>
</ol>
<pre>      const UserSchema = new Schema({ 
          firstName: { type: String, required: true }, 
          lastName: { type: String, required: true }, 
      }) </pre>
<ol start="4">
<li>Define <kbd>pre</kbd> and <kbd>post</kbd> hooks for the <kbd>insertMany</kbd> model method:</li>
</ol>
<pre>      UserSchema.pre('insertMany', async function prMany() { 
          console.log('Preparing docs...') 
      }) 
      UserSchema.post('insertMany', async function psMany(docs) { 
          console.log('The following docs were created:n', docs) 
      }) </pre>
<ol start="5">
<li>Compile the schema into a model:</li>
</ol>
<pre>      const User = mongoose.model('User', UserSchema) </pre>
<ol start="6">
<li>Once a connection to the database was established, use the <kbd>insertMany</kbd> method to insert two documents at once:</li>
</ol>
<pre>      connection.once('connected', async () =&gt; { 
          try { 
              await User.insertMany([ 
                  { firstName: 'Leo', lastName: 'Smith' }, 
                  { firstName: 'Neo', lastName: 'Jackson' }, 
              ]) 
          } catch (error) { 
              console.dir(error, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) </pre>
<ol start="7">
<li>Save the file</li>
<li>Open a Terminal and run:</li>
</ol>
<pre><strong>      node query-middleware.js</strong></pre>
<ol start="9">
<li>On the Terminal, the output should display:</li>
</ol>
<pre>      Preparing docs... 
      The following documents were created: 
      [ { firstName: 'Leo', lastName: 'Smith', _id: [id] }, 
        { firstName: 'Neo', lastName: 'Jackson', _id: [id] } ] </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It's useful to mark the fields as required to avoid having "null" values being saved in the database. An alternative is to set default values for the fields that are not explicitly defined in the creation time of the document. For instance:</p>
<pre>      const UserSchema = new Schema({ 
          name: { 
              type: string, 
              required: true, 
              default: 'unknown', 
          } 
      }) </pre>
<p>When a new document is created, if no path or property <kbd>name</kbd> is assigned, then it will assign the default value defined in the schema type option <kbd>default</kbd>.</p>
<p>The schema type <kbd>default</kbd> option can also be a function. The value returned by calling this function is assigned as the default value.</p>
<p>Sub-documents or arrays can also be created by just adding brackets when defining the schema type. For instance:</p>
<pre>      const WishBoxSchema = new Schema({ 
          wishes: { 
              type: [String], 
              required: true, 
              default: [ 
                  'To be a snowman', 
                  'To be a string', 
                  'To be an example', 
              ], 
          }, 
      }) </pre>
<p>When a new document is created, it will expect an array of strings in the <kbd>wishes</kbd> property or path. If no array is provided, then the default values will be used to create the document.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing NPM Packages</em></li>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing MongoDB</em></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Writing custom validators for Mongoose's schemas</h1>
                
            
            
                
<p>Mongoose has several built-in validation rules. For instance, if you define a property with a schema type of <kbd>string</kbd> and set it as <kbd>required</kbd>, two validation rules will be executed, one that checks for the property to be a valid <kbd>string</kbd> and another one for checking that the property is not <kbd>null</kbd> or <kbd>undefined</kbd>.</p>
<p>Custom validation rules and custom error validation messages can also be defined in Mongoose for having more control on how and when certain properties are accepted before they can be saved in the database.</p>
<p>Validation rules are defined in the schema. All schema types have a built-in validator <kbd>required</kbd> which means it cannot contain <kbd>undefined</kbd> or <kbd>null</kbd> values. The <kbd>required</kbd> validator can be of type <kbd>boolean</kbd>, a <kbd>function</kbd>, or an <kbd>array</kbd>. For example:</p>
<pre>      path: { type: String, required: true } 
      path: { type: String, required: [true, 'Custom error message'] } 
      path: { type: String, required: () =&gt; true } </pre>
<p>String schema types have the following built-in validators:</p>
<ul>
<li><kbd>enum</kbd>: This states that the string can only have the value specified in the <kbd>enum</kbd> array. For instance:</li>
</ul>
<pre>      gender: { 
      type: SchemaTypes.String, 
      enum: ['male', 'female', 'other'], 
      } </pre>
<ul>
<li><kbd>match</kbd>: This uses <kbd>RegExp</kbd> to test the value. For instance, to allow values that start with <kbd>www</kbd>:</li>
</ul>
<pre>      website: { 
      type: SchemaTypes.String, 
      match: /^www/, 
      } </pre>
<ul>
<li><kbd>maxlength</kbd>: This defines the maximum length that a string can have.</li>
<li><kbd>minlength</kbd>: This defines the minimum length that a string can have. For instance, to allow only strings between <kbd>5</kbd> and <kbd>20</kbd> characters:</li>
</ul>
<pre>      name: { 
      type: SchemaTypes.String, 
      minlength: 5, 
      maxlength: 20, 
      } </pre>
<p>Number schema types have two built-in validators:</p>
<ul>
<li><kbd>min</kbd>: This defines the minimum value that a number can have.</li>
<li><kbd>max</kbd>: This defines the maximum value that a number can have. For instance, to allow only numbers between <kbd>18</kbd> and <kbd>100</kbd>:</li>
</ul>
<pre>      age: { 
      type: String, 
      min: 18, 
      max: 100, 
      } </pre>
<p>Undefined values pass all validators without error. If you want to throw an error if a value is <kbd>undefined</kbd>, do not forget to use the <kbd>required</kbd> validator to <kbd>true</kbd></p>
<p>When built-in validators sometimes do not satisfy your requirements or you wish to perform complex validation rules, you have an option or property called <kbd>validate.</kbd> This accepts an object that has two properties, <kbd>validator</kbd> and <kbd>message,</kbd> that allow us to write custom validators:</p>
<pre>      nickname: { 
      type: String, 
      validate: { 
      validator: function validator(value) { 
      return /^[a-zA-Z-]$/.test(value) 
      }, 
      message: '{VALUE} is not a valid nickname.', 
      }, 
      } </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this recipe, you will see how to use custom validation rules to ensure that a certain field matches or fulfils a defined rule. First, ensure that you have MongoDB installed and it's running. As an alternative, if you prefer, a MongoDB DBaaS instance in the cloud will also do. Before you start, create a new <kbd>package.json</kbd> file with the following code:</p>
<pre>      { 
        "dependencies": { 
          "mongoose": "5.0.11" 
        } 
      } </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>      npm install</strong>  </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Create a user schema and ensure that all user names are of type string, have a minimum length of six characters, have a maximum length of 20 characters, match a regular expression, and are required:</p>
<ol>
<li>Create a new file named <kbd>custom-validation.js</kbd></li>
<li>Include the Mongoose NPM module and create a new connection to the database:</li>
</ol>
<pre>      const mongoose = require('mongoose') 
      const { connection, Schema } = mongoose 
      mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).catch(console.error) </pre>
<ol start="3">
<li>Define a schema including validation rules for the <kbd>username</kbd> field:</li>
</ol>
<pre>      const UserSchema = new Schema({ 
          username: { 
              type: String, 
              minlength: 6, 
              maxlength: 20, 
              required: [true, 'user is required'], 
              validate: { 
                  message: '{VALUE} is not a valid username', 
                  validator: (val) =&gt; /^[a-zA-Z]+$/.test(val), 
              }, 
          }, 
      }) </pre>
<ol start="4">
<li>Compile the schema into a model:</li>
</ol>
<pre>      const User = mongoose.model('User', UserSchema) </pre>
<ol start="5">
<li>Once a connection with the database is established, create a new document with invalid fields and use the <kbd>validateSync</kbd> document method to trigger the validation built-in and custom methods:</li>
</ol>
<pre>      connection.once('connected', async () =&gt; { 
          try { 
              const user = new User() 
              let errors = null 
              // username field is not defined 
              errors = user.validateSync() 
              console.dir(errors.errors['username'].message) 
              // username contains less than 6 characters 
              user.username = 'Smith' 
              errors = user.validateSync() 
              console.dir(errors.errors['username'].message) 
              // RegExp matching 
              user.username = 'Smith_9876' 
              errors = user.validateSync() 
              console.dir(errors.errors['username'].message) 
          } catch (error) { 
              console.dir(error, { colors: true }) 
          } finally { 
              await connection.close() 
          } 
      }) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a Terminal and run:</li>
</ol>
<pre><strong>      node custom-validation.js</strong>  </pre>
<ol start="8">
<li>On the Terminal, the output should display:</li>
</ol>
<pre>      'user is required' 
      'Path `username` (`Smith`) is shorter than the minimum allowed             <br/>       length (6).' 
      'Smith_9876 is not a valid username' </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em>Installing NPM Packages</em></li>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to the MERN Stack</em>, section <em><em>Installing MongoDB</em></em></li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Building a RESTful API to manage users with ExpressJS and Mongoose</h1>
                
            
            
                
<p>In this recipe, you will build a RESTful API that will allow the creation of new users, log in, display user information, and delete a user's profile. Furthermore, you will learn how to build a NodeJS REPL with a client API that you can use to interact with your server's RESTful API.</p>
<p>A <strong>REPL</strong> (<strong>Read-Eval-Print Loop</strong>) is like an interactive shell where you can execute commands one after another. For instance, the Node.js REPL can be opened by running this command in your terminal:</p>
<pre><strong>node -i</strong> </pre>
<p>Here, the <kbd>-i</kbd> flag stands for interactive. Now, you can execute the JavaScript code that gets evaluated piece by piece in a new context.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe will be focused on showing the integration of Mongoose with ExpressJS using what was seen in previous recipes. First, ensure that you have MongoDB installed and it's running. As an alternative, if you prefer, a MongoDB DBaaS instance in the cloud will also do. Before you start, create a new <kbd>package.json</kbd> file with the following code:</p>
<pre>      { 
        "dependencies": { 
          "body-parser": "1.18.2", 
          "connect-mongo": "2.0.1", 
          "express": "4.16.3", 
          "express-session": "1.15.6", 
          "mongoose": "5.0.11", 
          "node-fetch": "2.1.2" 
        } 
      } </pre>
<p>Then, install the dependencies by opening a Terminal and running this code:</p>
<pre><strong>npm install</strong></pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Firstly, create a file named <kbd>server.js</kbd> that will include two middleware functions. One that configures a session and the other that makes sure that there is a connection to the MongoDB before allowing any route to be called. Then, we mount our API routes to a specific path:</p>
<ol>
<li>Create a new file named <kbd>server.js</kbd></li>
<li>Include the required libraries. Then, initialize a new ExpressJS application and create a connection to MongoDB:</li>
</ol>
<pre>      const mongoose = require('mongoose') 
      const express = require('express') 
      const session = require('express-session') 
      const bodyParser = require('body-parser') 
      const MongoStore = require('connect-mongo')(session) 
      const api = require('./api/controller') 
      const app = express() 
      const db = mongoose.connect( 
          'mongodb://localhost:27017/test' 
      ).then(conn =&gt; conn).catch(console.error) </pre>
<ol start="3">
<li>Use the <kbd>body-parser</kbd> middleware to parse the request body as JSON:</li>
</ol>
<pre>      app.use(bodyParser.json()) </pre>
<ol start="4">
<li>Define an ExpressJS middleware function that will ensure your web application is connected to MongoDB first before allowing next route handlers to be executed:</li>
</ol>
<pre>      app.use((request, response, next) =&gt; {<br/>        Promise.resolve(db).then(<br/>        (connection, err) =&gt; (<br/>            typeof connection !== 'undefined'<br/>            ? next()<br/>            : next(new Error('MongoError'))<br/>            )<br/>          )<br/>      })</pre>
<ol start="5">
<li>Configure <kbd>express-session</kbd> middleware to store sessions in the Mongo database instead of storing in memory:</li>
</ol>
<pre>      app.use(session({ 
          secret: 'MERN Cookbook Secrets', 
          resave: false, 
          saveUninitialized: true, 
          store: new MongoStore({ 
              collection: 'sessions', 
              mongooseConnection: mongoose.connection, 
          }), 
      })) </pre>
<ol start="6">
<li>Mount the API controller to the <kbd>"/api"</kbd> route:</li>
</ol>
<pre>      app.use('/users', api) </pre>
<ol start="7">
<li>Listen on port 1773 for new connections:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="8">
<li>Save the file</li>
</ol>
<p>Then, create a new directory named <kbd>api</kbd>. Next, create the model or business logic of your application. Define a schema for users with static and instance methods that will allow a user to signup, login, logout, get profile data, change their password, and remove their profile:</p>
<ol>
<li>Create a new file named <kbd>model.js</kbd> in the <kbd>api</kbd> directory</li>
<li>Include the Mongoose NPM module and also the <kbd>crypto</kbd> NodeJS module that will be used to generate a hash for the user passwords:</li>
</ol>
<pre>      const { connection, Schema } = require('mongoose') 
      const crypto = require('crypto') </pre>
<ol start="3">
<li>Define the schema:</li>
</ol>
<pre>      const UserSchema = new Schema({ 
          username: { 
              type: String, 
              minlength: 4, 
              maxlength: 20, 
              required: [true, 'username field is required.'], 
              validate: { 
                  validator: function (value) { 
                      return /^[a-zA-Z]+$/.test(value) 
                  }, 
                  message: '{VALUE} is not a valid username.', 
              }, 
          }, 
          password: String, 
      }) </pre>
<ol start="4">
<li>Define a static model method for <kbd>login</kbd>:</li>
</ol>
<pre>      UserSchema.static('login', async function(usr, pwd) { 
          const hash = crypto.createHash('sha256') 
              .update(String(pwd)) 
          const user = await this.findOne() 
              .where('username').equals(usr) 
              .where('password').equals(hash.digest('hex')) 
          if (!user) throw new Error('Incorrect credentials.') 
          delete user.password 
          return user 
      }) </pre>
<ol start="5">
<li>Define a static model method for <kbd>signup</kbd>:</li>
</ol>
<pre>      UserSchema.static('signup', async function(usr, pwd) { 
          if (pwd.length &lt; 6) { 
              throw new Error('Pwd must have more than 6 chars') 
          } 
          const hash = crypto.createHash('sha256').update(pwd) 
          const exist = await this.findOne() 
              .where('username') 
              .equals(usr) 
          if (exist) throw new Error('Username already exists.') 
          const user = this.create({ 
              username: usr, 
              password: hash.digest('hex'), 
          }) 
          return user 
      }) </pre>
<ol start="6">
<li>Define a document instance method for <kbd>changePass</kbd>:</li>
</ol>
<pre>      UserSchema.method('changePass', async function(pwd) { 
          if (pwd.length &lt; 6) { 
              throw new Error('Pwd must have more than 6 chars') 
          } 
          const hash = crypto.createHash('sha256').update(pwd) 
          this.password = hash.digest('hex') 
          return this.save() 
      }) </pre>
<ol start="7">
<li>Compile the Mongoose schema into a model and export it:</li>
</ol>
<pre>      module.exports = connection.model('User', UserSchema) </pre>
<ol start="8">
<li>Save the file</li>
</ol>
<p>Finally, define a controller that will transform the request body to actions that our model can understand. Then export it as an ExpressJS router that contains all API paths:</p>
<ol>
<li>Create a new file named <kbd>controller.js</kbd> in the <kbd>api</kbd> folder</li>
<li>Import <kbd>model.js</kbd> and initialize a new ExpressJS Route:</li>
</ol>
<pre>      const express = require('express') 
      const User = require('./model') 
      const api = express.Router() </pre>
<ol start="3">
<li>Define a request handler to check if a user is logged in and another request handler to check if the user is not logged in:</li>
</ol>
<pre>      const isLogged = ({ session }, res, next) =&gt; { 
          if (!session.user) res.status(403).json({ 
              status: 'You are not logged in!', 
          }) 
          else next() 
      } 
      const isNotLogged = ({ session }, res, next) =&gt; { 
          if (session.user) res.status(403).json({ 
              status: 'You are logged in already!', 
          }) 
          else next() 
      } </pre>
<ol start="4">
<li>Define a <kbd>post</kbd> request method to handle requests to <kbd>"/login"</kbd> endpoint:</li>
</ol>
<pre>      api.post('/login', isNotLogged, async (req, res) =&gt; { 
          try { 
              const { session, body } = req 
        const { username, password } = body 
              const user = await User.login(username, password) 
              session.user = { 
                  _id: user._id, 
                  username: user.username, 
              } 
              session.save(() =&gt; { 
                  res.status(200).json({ status: 'Welcome!'}) 
              }) 
          } catch (error) { 
              res.status(403).json({ error: error.message }) 
          } 
      }) </pre>
<ol start="5">
<li>Define a <kbd>post</kbd> request method to handle requests to <kbd>"/logout"</kbd> endpoint:</li>
</ol>
<pre>      api.post('/logout', isLogged, (req, res) =&gt; { 
          req.session.destroy() 
          res.status(200).send({ status: 'Bye bye!' }) 
      }) </pre>
<ol start="6">
<li>Define a <kbd>post</kbd> request method to handle requests to <kbd>"/signup"</kbd> endpoint:</li>
</ol>
<pre>      api.post('/signup', async (req, res) =&gt; { 
          try { 
              const { session, body } = req 
              const { username, password } = body 
              const user = await User.signup(username, password) 
              res.status(201).json({ status: 'Created!'}) 
          } catch (error) { 
              res.status(403).json({ error: error.message }) 
          } 
      }) </pre>
<ol start="7">
<li>Define a <kbd>get</kbd> request method to handle requests to <kbd>"/profile"</kbd> endpoint:</li>
</ol>
<pre>      api.get('/profile', isLogged, (req, res) =&gt; { 
          const { user } = req.session 
          res.status(200).json({ user }) 
      }) </pre>
<ol start="8">
<li>Define a <kbd>put</kbd> request method to handle requests to <kbd>"/changepass"</kbd> endpoint:</li>
</ol>
<pre>      api.put('/changepass', isLogged, async (req, res) =&gt; { 
          try { 
              const { session, body } = req 
              const { password } = body 
              const { _id } = session.user 
              const user = await User.findOne({ _id }) 
              if (user) { 
                  await user.changePass(password) 
                  res.status(200).json({ status: 'Pwd changed' }) 
              } else { 
                  res.status(403).json({ status: user }) 
              } 
          } catch (error) { 
              res.status(403).json({ error: error.message }) 
          } 
      }) </pre>
<ol start="9">
<li>Define a delete request method to handle requests to <kbd>"/delete"</kbd> endpoint:</li>
</ol>
<pre>      api.delete('/delete', isLogged, async (req, res) =&gt; { 
          try { 
              const { _id } = req.session.user 
              const user = await User.findOne({ _id }) 
              await user.remove() 
              req.session.destroy((err) =&gt; { 
                  if (err) throw new Error(err) 
                  res.status(200).json({ status: 'Deleted!'}) 
              }) 
          } catch (error) { 
              res.status(403).json({ error: error.message }) 
          } 
      }) </pre>
<ol start="10">
<li>Export the route:</li>
</ol>
<pre>      module.exports = api </pre>
<ol start="11">
<li>Save the file</li>
</ol>


            

            
        
    </div>



  
<div><h1 class="header-title">Let's test it...</h1>
                
            
            
                
<p>You have built a RESTful API that allows users to subscribe or sign up, log in, log out, get their profile, and delete their profile. These actions can be performed by making HTTP requests to the server. We will build now a small NodeJS REPL and client API that could allow you to interact with your RESTful API server with plain JavaScript functions:</p>
<ol>
<li>Move to the root of your project directory and create a new file named <kbd>client-repl.js</kbd>.</li>
<li>Include the <kbd>node-fetch</kbd> NPM module that will allow making HTTP request to the server. Include as well, the <kbd>repl</kbd> and <kbd>vm</kbd> Node.js modules that will allow you to create an interactive Node.js REPL:</li>
</ol>
<pre>      const repl = require('repl') 
      const util = require('util') 
      const vm = require('vm') 
      const fetch = require('node-fetch') 
      const { Headers } = fetch </pre>
<ol start="3">
<li>Define a variable that will later contain the session ID from the cookie once the user is logged-in. The cookie will be used to allow the server recognize the logged in user for actions such as getting information about your profile or changing password:</li>
</ol>
<pre>      let cookie = null </pre>
<ol start="4">
<li>Define a helper function named <kbd>query</kbd> that will allow to make HTTP requests to the server. The <kbd>credentials</kbd> options, allows to send and receive cookies from and to the server. We define the <kbd>headers</kbd> that will tell the server the content type of the request body that will be sent as JSON content:</li>
</ol>
<pre>      const query = (path, ops) =&gt; { 
          return fetch(`http://localhost:1337/users/${path}`, { 
              method: ops.method, 
              body: ops.body, 
              credentials: 'include', 
              body: JSON.stringify(ops.body), 
              headers: new Headers({ 
                  ...(ops.headers || {}), 
                  cookie, 
                  Accept: 'application/json', 
                  'Content-Type': 'application/json', 
              }), 
          }).then(async (r) =&gt; { 
              cookie = r.headers.get('set-cookie') || cookie 
              return { 
                  data: await r.json(), 
                  status: r.status, 
              } 
          }).catch(error =&gt; error) 
      } </pre>
<ol start="5">
<li>Define a method that will allow users to sign up:</li>
</ol>
<pre>      const signup = (username, password) =&gt; query('/signup', { 
          method: 'POST', 
          body: { username, password }, 
      }) </pre>
<ol start="6">
<li>Define a method that will allow users to log in:</li>
</ol>
<pre>      const login = (username, password) =&gt; query('/login', { 
          method: 'POST', 
          body: { username, password }, 
      }) </pre>
<ol start="7">
<li>Define a method that will allow users to log out:</li>
</ol>
<pre>      const logout = () =&gt; query('/logout', { 
          method: 'POST', 
      }) </pre>
<ol start="8">
<li>Define a method that will allow users to get their profile:</li>
</ol>
<pre>      const getProfile = () =&gt; query('/profile', { 
          method: 'GET', 
      }) </pre>
<ol start="9">
<li>Define a method that will allow users to change their password:</li>
</ol>
<pre>      const changePassword = (password) =&gt; query('/changepass', { 
          method: 'PUT', 
          body: { password }, 
      }) </pre>
<ol start="10">
<li>Define a method that will allow users to delete their profile:</li>
</ol>
<pre>      const deleteProfile = () =&gt; query('/delete', { 
          method: 'DELETE', 
      }) </pre>
<ol start="11">
<li>Use the start method from the REPL exported object to start a new REPL server. We will specify the eval method to execute JavaScript code using the VM module, then, if a Promise is returned, it will wait for the Promise to be resolved before allowing the user to input more commands or type more JavaScript code in the REPL. We will also specify also the writer method that will pretty-print the result of calling the previously defined methods:</li>
</ol>
<pre>      const replServer = repl.start({ 
          prompt: '&gt; ', 
          ignoreUndefined: true, 
          async eval(cmd, context, filename, callback) { 
              const script = new vm.Script(cmd) 
              const is_raw = process.stdin.isRaw 
              process.stdin.setRawMode(false) 
              try { 
                  const res = await Promise.resolve( 
                      script.runInContext(context, { 
                          displayErrors: false, 
                          breakOnSigint: true, 
                      }) 
                  ) 
                  callback(null, res) 
              } catch (error) { 
                  callback(error) 
              } finally { 
                  process.stdin.setRawMode(is_raw) 
              } 
          }, 
          writer(output) { 
              return util.inspect(output, { 
                  breakLength: process.stdout.columns, 
                  colors: true, 
                  compact: false, 
              }) 
          } 
      }) </pre>
<ol start="12">
<li>Add the previously defined methods to the context of the REPL server where the JavaScript code will be executed:</li>
</ol>
<pre>      replServer.context.api = { 
          signup, 
          login, 
          logout, 
          getProfile, 
          changePassword, 
          deleteProfile, 
      } </pre>
<ol start="13">
<li>Save the file</li>
</ol>
<p>Now you can run on a terminal your RESTful API server:</p>
<pre><strong>node server.js</strong> </pre>
<p>And in a different terminal, run the NodeJS REPL application that you just created:</p>
<pre><strong>node client-repl.js</strong></pre>
<p>In the REPL, you can execute JavaScript code and you have also access to the exported methods. For instance, you can execute the following JavaScript code line by line in your REPL:</p>
<pre>      api.signup('John', 'zxcvbnm') 
      api.login('John', 'zxcvbnm') 
      api.getProfile() 
      api.changePassword('newPwd') 
      api.logout() 
      api.login('John', 'incorrectPwd') </pre>


            

            
        
    </div>



  
<div><h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Your RESTful API server will accept requests for the following paths:</p>
<ul>
<li><kbd>POST/users/login</kbd>: If a username does not exist in the <kbd>users</kbd> collection in MongoDB, an error message is sent to the client. Otherwise, it returns a welcome message.</li>
<li><kbd>POST/users/logout</kbd>: This destroys the session ID.</li>
<li><kbd>POST/users/signup</kbd>: This creates a new username with the defined password. However, an error will be sent to the client if the username or password does not pass the validation. It will also send an error message to the client when the username already exists.</li>
<li><kbd>GET/users/profile</kbd>: If the user is logged in, the user information is sent to the client. Otherwise, an error message is sent to the client.</li>
<li><kbd>PUT/users/changepass/</kbd>: This will change the current logged-in user's password. However, if the user is not logged-in, an error message is sent to the client.</li>
<li><kbd>DELETE/users/delete</kbd>: This will remove a logged-in user's profile from the collection <kbd>users</kbd> in MongoDB. The session will be destroyed and a confirmation message is sent to the client. If the user is not logged-in, an error message is sent to the client</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to MERN Stack,</em> section <em>Installing NPM Packages</em></li>
<li><a href="7f71253e-4f39-4126-8428-986edb06f47c.xhtml" target="_blank">Chapter 1</a>, <em>Introduction to MERN Stack</em>, section <em>Installing MongoDB</em></li>
</ul>


            

            
        
    </div>



  </body></html>