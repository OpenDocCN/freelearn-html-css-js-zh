- en: Chapter 2. Knowing Your Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ES6** has added lots of new properties and methods to built-in JavaScript
    objects, so that the programmer can do cumbersome tasks easily. These new functionalities
    aim to help the developers get rid of using hacks and error-prone techniques to
    do various operations related to numbers, strings, and arrays. In this chapter,
    we will look at all the new functionalities added by ES6 to the native objects.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The new properties and methods of the `Number` object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing the numeric constants as binary or octal
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new properties and methods of the `Math` object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the multiline strings and the new methods of the `String` object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new properties and methods of `Array` object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Maps and Sets?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using array buffers and typed arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new properties and methods of `Object` object
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with numbers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 adds new ways of creating numbers and new properties to the `Number` object
    to make working with numbers easier. The `Number` object was enhanced in ES6 to
    make it easier to create mathematically rich applications, and prevent the common
    misconceptions that caused the errors. ES6 also provides new ways to do things
    that were already possible in ES5, such as representing the numeric constants
    as octal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript represents the numbers as base 10 decimals. The numeric constants
    are, by default, interpreted as base 10 decimals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: The binary notation
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ES5, there was no native way to represent the numeric constants as binary.
    But in ES6, you can prefix the numeric constants using the `0b` token to make
    JavaScript interpret them as binary.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `0b00001111` is a binary representation of 15, base 10 decimal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: The octal notation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ES5, to represent a numeric constant as octal, we needed to prefix the numeric
    constant using `0`. For example, take a look at the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But often, programmers new to JavaScript, get confused with the octal representations
    as the decimal number with `0` at the front. For example, they think `017` is
    same as `17`. Therefore, to remove this confusion, ES6 lets us prefix the numeric
    constants using `0o` to make JavaScript interpret them as octal.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Number.isInteger(number) method
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript numbers are stored as the 64-bit, floating-point numbers. So the
    integers in JavaScript are the floating-point numbers without a decimal fraction,
    or a decimal fraction with all 0's.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: In ES5, there was no built-in way to check whether a number is an integer or
    not. ES6 adds a new method to the `Number` object called as `isInteger()`, which
    takes a number and returns `true` or `false,` depending on weather the number
    is an integer or not.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Number.isNaN(value) method
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ES5, there was no way to check whether a variable holds the `NaN` value or
    not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The global `isNaN()` function is used to check whether a value is a number or
    not. If the value is not a number, then it returns `true`, otherwise it returns
    `false`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'So ES6 introduced a new method for the `Number` object called as `isNaN()`
    to check whether a value is `NaN` or not. Here is an example, which demonstrates
    `Number.isNaN()` and also explains how it is different from the global `isNaN()`
    function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here you can see that `Number.isNaN()` method returns `true` only if the passed
    value is exactly `NaN`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might ask, why not use `==` or the `===` operator instead of the `Number.isNaN(value)`
    method? The `NaN` value is the only value that is not equal to itself, that is,
    the expression `NaN==NaN` or `NaN===NaN` will return `false`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The Number.isFinite(number) method
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ES5 there was no built-in way to check whether a value is a finite number.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The global `isFinite()` function takes a value and checks whether it's a finite
    number or not. But unfortunately, it also returns `true` for values that convert
    to a `Number` type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'So ES6 introduced the `Number.isFinite()` method, which resolves the issue
    of the `window.isFinite()` function. Here is an example to demonstrate this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Number.isSafeInteger(number) method
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript numbers are stored as 64-bit floating-point numbers, following
    the international IEEE 754 standard. This format stores numbers in 64 bits, where
    the number (the fraction) is stored in 0 to 51 bits, the exponent in 52 to 62
    bits, and the sign in the last bit.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: So in JavaScript, safe integers are those numbers that are not needed to be
    rounded to some other integer to fit in the IEEE 754 representation. Mathematically,
    the numbers from -(2^(53)-1) to (2^(53)-1) are considered as safe integers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `Number.MAX_SAFE_INTEGER` and `Number.MIN_SAFE_INTEGER` are constant values,
    introduced in ES6, representing (2^(53)-1) and -(2^(53)-1) respectively.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: The Number.EPSILON property
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript uses such binary floating-point representation that the computers
    fail to accurately represent, numbers like 0.1, 0.2, 0.3, and so on. When your
    code is executed, numbers like 0.1 are rounded to the nearest number in that format,
    which results in small rounding error.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Number.EPSILON` property was introduced in ES6, which has a value of approximately
    2^(-52). This value represents a reasonable margin of error when comparing the
    floating-point numbers. Using this number, we can create a custom function to
    compare the floating-point numbers by ignoring the minimal rounding errors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `epsilonEqual()` is the custom function that we build to compare whether
    the two values are equal or not. Now, the output is as expected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about this behavior of JavaScript and the floating-point arithmetic,
    visit [http://floating-point-gui.de/](http://floating-point-gui.de/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 adds a lot of new methods to the `Math` object, related to trigonometry,
    arithmetic, and miscellaneous. This lets the developers use native methods instead
    of external math libraries. Native methods are optimized for performance, and
    have better decimal precision.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometry related operations
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example code, which shows the entire trigonometry-related methods
    that are added to the `Math` object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Arithmetic related operations
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example code, which shows the entire arithmetic related methods
    added to the `Math` object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Miscellaneous methods
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 adds some miscellaneous methods to the `Math` object. These methods are
    used for conversion and extracting information from the numbers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The Math.imul(number1, number2) function
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Math.imul()` takes two numbers as 32-bit integers and multiplies them.
    It returns the lower 32 bits of the result. This is the only native way to do
    32-bit integer multiplication in JavaScript.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Output is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here when multiplication was done it produced a number so large it couldn't
    be stored in 32 bits, therefore the lower bits were lost.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The Math.clz32(number) function
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Math.clz32()` function returns the number of leading zero bits in the 32-bit
    representation of a number.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Output is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Math.sign(number) function
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Math.sign()` function returns the sign of a number, indicating weather
    the number is negative, positive or zero.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Output is:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the preceding code, we can see that the `Math.sign()` function returns
    `1` if the number is positive, `-1` if the number is negative, and `0` if the
    number is zero.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The Math.trunc(number) function
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Math.trunc()` function returns the integer part of a number by removing
    any fractional digit. Here is an example to demonstrate this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Output is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Math.fround(number) function
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Math.fround()` function rounds a number to a 32-bit floating point value.
    Here is an example to demonstrate this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Output is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Working with strings
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 provides new ways of creating strings and adds new properties to global
    String object and to its instances to make working with strings easier. Strings
    in JavaScript lacked features and capabilities when compared with programming
    languages such as Python and **Ruby** therefore ES6 enhanced strings to change
    that.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into new string features lets revise JavaScript's internal character
    encoding and escape sequences. In the Unicode character set every character is
    represented by a base 10 decimal number called a **code point**. A **code unit**
    is a fixed number of bits in memory to store a code point. An encoding schema
    determines the length of code unit. A code unit is 8 bits if the **UTF-8** encoding
    schema is used or 16 bits if the **UTF-16** encoding schema is used. If a code
    point doesn't fit in a code unit it is spilt into multiple code units, that is,
    multiple characters in sequence representing a single character.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interpreters by default interpret JavaScript source code as sequence
    of UTF-16 code units. If source code is written in the UTF-8 encoding schema then
    there are various ways to tell the JavaScript interpreter to interpret it as sequence
    of UTF-8 code units. JavaScript strings are always a sequence of UTF-16 code points.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Any Unicode character with a code point less than 65536 can be escaped in a
    JavaScript string or source code using the hexadecimal value of its code point,
    prefixed with `\u`. Escapes are six characters long. They require exactly four
    characters following `\u`. If the hexadecimal character code is only one, two
    or three characters long, you''ll need to pad it with leading zeroes. Here is
    an example to demonstrate this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Escaping larger code points
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ES5, for escaping a character that requires more than 16 bits for storing,
    we needed two Unicode escapes. For example, to add `\u1F691` to a string we had
    to escape it this way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here `\uD83D` and `\uDE91` are called **surrogate pairs**. A surrogate pair
    is two Unicode characters when written in sequence represent another character.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES6 we can write it without surrogate pairs:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A string stores `\u1F691` as `\uD83D\uDE91`, so length of the above string is
    still `2`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The codePointAt(index) method
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `codePointAt()` method of a string returns a non-negative integer that is
    the code point of the character at the given index.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Output is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The String.fromCodePoint(number1, …, number 2) method
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fromCodePoint()` method of `String` object takes a sequence of code points
    and returns a string. Here is an example to demonstrate this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Output is:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The repeat(count) method
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `repeat()` method of a string, constructs and returns a new string which
    contains the specified number of copies on which it was called, concatenated together.
    Here is an example to demonstrate this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The includes(string, index) method
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `includes()` method is used to find whether one string may be found in
    another string, returning `true` or `false` as appropriate. Here is an example
    to demonstrate this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The startsWith(string, index) method
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `startsWith()` method is used to find whether a string begins with the
    characters of another string, returning `true` or `false` as appropriate. Here
    is an example to demonstrate this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The endsWith(string, index) function
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `endsWith()` method is used to find whether a string ends with the characters
    of another string, returning true or false as appropriate. It also takes an optional
    second parameter representing the position in the string that is assumed as the
    end of the string. Here is an example to demonstrate this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Normalization
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Normalization** is simply the process of searching and standardizing code
    points without changing the meaning of the string.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also different forms of normalization: NFC, NFD, NFKC and NFKD.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand Unicode string normalization by an example use case:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: A case study
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many Unicode characters that can be stored in 16 bits and can also
    be represented using a surrogate pair. For example, ''`é`'' character can be escaped
    two ways:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The problem is when applying the `==` operator, iterating or finding length
    you will get an unexpected result. Here is an example to demonstrate this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Output is:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here both the strings display the same way but when we do various string operations
    on them we get different results.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The length property ignores surrogate pairs and assumes every 16-bit to be single
    character. The `==` operator matches the binary bits therefore it also ignores
    surrogate pairs. The `[]` operator also assumes every 16-bit to be an index therefore
    ignoring surrogate pairs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case to solve the problems we need to convert the surrogate pairs to
    16-bit character representation. This process is called as **normalization**.
    To do this ES6 provides a `normalize()` function. Here is an example to demonstrate
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Output is:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here the output is as expected. `normalize()` returns the normalized version
    of the string. `normalize()` uses NFC form by default.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Normalization is not just done in the case of surrogate pairs; there are many
    other cases.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Normalized version of a string is not made for displaying to the user; it's
    used for comparing and searching in strings.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Unicode string normalization and normalization forms visit
    [http://www.unicode.org/reports/tr15/](http://www.unicode.org/reports/tr15/).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Template strings
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template strings is just a new literal for creating strings that makes various
    things easier. They provide features such as embedded expressions, multi-line
    strings, string interpolation, string formatting, string tagging, and so on. They
    are always processed and converted to a normal JavaScript string on runtime therefore
    they can be used wherever we use normal strings.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'Template strings are written using back ticks instead of single or double quotes.
    Here is an example of a simple template string:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Expressions
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In ES5, to embed expressions within normal strings you would do something like
    this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Output is:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In ES6, template strings make it much easier to embed expressions in strings.
    Template strings can contain expressions in them. The expressions are placed in
    placeholders indicated by dollar sign and curly brackets, that is, `${expressions}`.
    The resolved value of expressions in the placeholders and the text between them
    are passed to a function for resolving the template string to a normal string.
    The default function just concatenates the parts into a single string. If we use
    a custom function to process the string parts then the template string is called
    as a **tagged template string** and the custom function is called as **tag function**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example which shows how to embed expressions in a template strings:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Output is:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s create a tagged template string, that is, process the string using a
    tag function. Let''s implement the tag function to do the same thing as the default
    function. Here is an example to demonstrate this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Output is:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here our tag function's name is `tag` but you can name it anything else. The
    custom function takes two parameters, that is, the first parameter is an array
    of string literals of the template string and the second parameter is an array
    of resolved values of the expressions. The second parameter is passed as multiple
    arguments therefore we use the rest argument.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Multiline strings
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template strings provide a new way to create strings that contain multiple lines
    of text.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES5, we need to use `\n` new line character to add new line breaks. Here
    is an example to demonstrate this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Output is:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In ES6, using **multiline** string we can simply write:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Output is:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the above code we simply included new lines where we needed to place `\n`.
    While converting the template string to normal string the new lines are converted
    to `\n`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Raw strings
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A raw string is a normal string in which escaped characters aren't interpreted.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a raw string using a template string. We can get raw version
    of a template string use `String.raw` tag function. Here is an example to demonstrate
    this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Output is:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here `\n` is not interpreted as new line character instead of its two characters,
    that is, `\` and `n`. Length of variable `s` would be `6`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create a tagged function and you want to return the raw string then
    use `raw` property of the first argument. `raw` property is an array, which holds
    raw versions of the strings of the first argument. Here is an example to demonstrate
    this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Output is:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Arrays
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 adds new properties to the global Array object and to its instances to make
    working with arrays easier. Arrays in JavaScript lacked features and capabilities
    when compared with programming languages such as Python and Ruby therefore ES6
    enhanced arrays to change that.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The Array.from(iterable, mapFunc, this) method
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Array.from()` method creates a new array instance from an iterable object.
    The first argument is a reference to the iterable object. The second argument
    is optional and is a callback (known as **Map function**) that is called for every
    element of the iterable object. The third argument is also optional and is the
    value of `this` inside the Map function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Output is:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The Array.of(values…) method
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Array.of()` method is an alternative to the `Array` constructor for creating
    arrays. When using `Array` constructor if we pass only one argument, that too
    a number, then `Array` constructor constructs an empty array with array `length`
    property equal to the passed number instead of creating an array of one element
    with that number in it. Therefore the `Array.of()` method was introduced to resolve
    this issue.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Output is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You should use `Array.of()` instead of `Array` constructor when you are constructing
    a new array instance dynamically, that is, when you don't know the type of values
    and the number of elements.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: The fill(value, startIndex, endIndex) method
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fill()` method of an array fills all the elements of the array from the
    `startIndex` to an `endIndex` (not including `endIndex`) with a given value. Remember
    that `startIndex` and `endIndex` arguments are optional; therefore if they are
    not provided then the whole array is filled with the given value. If only `startIndex`
    is provided then `endIndex` defaults to length of array minus 1.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: If `startIndex` is negative then it's treated as length of array plus `startIndex`.
    If `endIndex` is negative, it is treated as length of array plus `endIndex`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Output is:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The find(testingFunc, this) method
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `find()` method of an array returns an array element, if it satisfies the
    provided testing function. Otherwise it returns `undefined`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The `find()` method takes two arguments, that is, the first argument is the
    testing function and the second argument is the value of `this` in the testing
    function. The second argument is optional.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing function has three parameters: the first parameter is the array
    element being processed, second parameter is the index of the current element
    being processed and third parameter is the array on which `find()` is called upon.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The testing function needs to return `true` to satisfy a value. The `find()`
    method returns the first element which satisfies the provided testing function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate the `find()` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The findIndex(testingFunc, this) method
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `findIndex()` method is similar to the `find()` method. The `findIndex()`
    method returns the index of the satisfied array element instead of the element
    itself.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The copyWithin(targetIndex, startIndex, endIndex) function
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `copyWithin()` method of an array is used to copy the sequence of values
    of the array to a different position in the array.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copyWithin()` method takes three arguments: first argument represents
    the target index where to copy elements to, second argument represents the index
    position where to start copying from and the third argument represents the index
    , that is, where to actually end copying elements.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The third argument is optional and if not provided then it defaults to `length-1`
    where `length` is the length of the array. If `startIndex` is negative then it's
    calculated as `length+startIndex`. Similarly if `endIndex` is negative then it's
    calculated as `length+endIndex`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Output is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The entries(), keys(), and values() method
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `entries()` method of an array returns an iterable object that contains
    key/value pairs for each index of the array. Similarly the `keys()` method of
    an array returns an iterable object that contains keys for each of the indexes
    in the array. Similarly, the `values()` method of an array returns an iterable
    object that contains values of the array.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The iterable object returned by the `entries()` method stores the key/value
    pairs in the form of arrays.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: The iterable object returned by these functions is not an array.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Output is:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Collections
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collection is any object that stores multiple elements as a single unit. ES6
    introduced various new collection objects to provide better ways of storing and
    organizing data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: The array is the only collection object available in ES5\. ES6 introduces array
    buffers, typed arrays, Sets, and Maps, which are built in collection objects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the different collection objects provided by ES6.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Array buffers
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Elements of arrays can be of any type such as strings, numbers, objects, and
    so on. Arrays can grow dynamically. The problem with arrays is that they are slow
    in terms of execution time, and occupy more memory. This causes issues while developing
    applications that require too much computation and deal with large amount of numbers.
    Therefore array buffers were introduced to tackle this issue.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: An array buffer is a collection of 8-bit blocks in memory. Every block is an
    array buffer element. The size of an array buffer needs to be decided while creating,
    it therefore it cannot grow dynamically. Array buffers can only store numbers.
    All blocks are initialized to number 0 on creation of an array buffer.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: An array buffer object is created using `ArrayBuffer` constructor.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Reading from and writing values into an array buffer object can be done using
    a DateView object. It''s not compulsory that only 8 bits are used to represent
    a number. We can use 8, 16, 32 and 64 bits to represent a number. Here is an example,
    which shows how to create a DateView object and read/write to an `ArrayBuffer`
    object:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here we created a DataView object using `DataView` constructor. A DataView object
    provides several methods to read and write numbers into an array buffer `object`.
    Here we used `setInt32()` method which uses 32 bits to store a provided number.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: All the methods of a DataView object that are used to write data to an array
    buffer object take three arguments. First argument represents the offset, that
    is, the byte we want to write the number to. Second argument is the number to
    be stored. And third argument is a Boolean type, which represents the endian of
    the number, such as `false` represents a big-endian.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Similarly all the methods of a DataView object that are used to read data of
    an array buffer object take two arguments. First argument is the offset and second
    argument represents the endian used.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are other functions for storing numbers provided by a DataView object:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**setInt8**: Uses 8 bits to store a number. It takes a signed integer (-ve
    or +ve).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setUint8**: Uses 8 bits to store a number. It takes an unsigned integer (+ve).'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setInt16**: Uses 16 bits to store a number. It takes a signed integer.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setUint16**: Uses 16 bits to store a number. It takes an unsigned integer.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setInt32**: Uses 32 bits to store a number. It takes a signed integer.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setUint32**: Uses 32 bits to store a number. It takes an unsigned integer.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setFloat32**: Uses 32 bits to store a number. It takes a signed decimal number.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setFloat64**: Uses 64 bits to store a number. It takes a signed decimal number.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are other functions for retrieving stored numbers by a DataView object:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '**getInt8**: Reads 8 bits. Returns signed integer number.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getUint8**: Reads 8 bits. Returns unsigned integer number.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getInt16**: Reads 16 bits. Returns signed integer number.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getUint16**: Reads 16 bits. Returns unsigned integer number.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getInt32**: Reads 32 bits. Returns signed integer number.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getUint32**: Reads 32 bits. Returns unsigned integer number.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getFloat32**: Reads 32 bits. Returns signed decimal number.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getFloat64**: Reads 64 bits. Returns signed decimal number.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed arrays
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw how to read and write numbers in array buffers. But the method was very
    cumbersome because we had to call a function every time. **Typed arrays** let
    us read and write to an array buffer object just like we do for normal arrays.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: A typed array acts like a wrapper for an array buffer object and treats data
    of an array buffer object as a sequence of *n*-bit numbers. The `n` value depends
    on how we created the typed array.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code example that demonstrates how to create an array buffer object
    and read/write to it using a typed array:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Output is:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here we created typed array using the `Float64Array` constructor, it therefore
    treats data in the array buffer as a sequence of 64-bit signed decimal numbers.
    Here the array buffer object size was 640 bits therefore only 10 64-bit numbers
    can be stored.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, there are other typed array constructors to represent data in an
    array buffer as a sequence of different bit numbers. Here is the list:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Int8Array**: Treats as 8-bit signed integers'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint8Array**: Treats as 8-bit unsigned integers'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int16Array**: Treats as 16-bit signed integers'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint16Array**: Treats as 16-bit unsigned integers'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int32Array**: Treats as 32-bit signed integers'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint32Array**: Treats as 32-bit unsigned integers'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float32Array**: Treats as 32-bit signed decimal number'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float64Array**: Treats as 64-bit signed decimal number'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed arrays provide all the methods that are also provided by normal JavaScript
    arrays. They also implement the iterable protocol therefore they can be used as
    an iterable object.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Set
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Set** is a collection of *unique* values of any data type. The values in
    a Set are arranged in insertion order. A Set is created using `Set` constructor.
    Here is an example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here `set1` is an empty Set. Whereas `set2` was created using values of an iterable
    object, that is, characters of a string and the string was not empty therefore
    `set2` is non-empty.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is example code, which demonstrates various operations that can be done
    on a Set:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Output is:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here we added nine items to the `set` object but the `size` was only six because
    Set automatically deletes duplicate values. The characters `l`and `!`were repeated
    multiple times.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: The Set object also implements the iterable protocol so they can be used as
    an iterable object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are used when you want to maintain a collection of values and check if
    a value exists instead of retrieving a value. For example: Sets can be used as
    an alternative to an array if you only use the `indexOf()` method of the array
    in your code to check if an value exists.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: WeakSet
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the differences between Set and WeakSet objects:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: A Set can store primitive types and object references whereas a WeakSet object
    can only store object references
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the important features of the WeakSet object is that if there is no other
    reference to an object stored in a WeakSet object then they are garbage collected
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly a WeakSet object is not enumerable, that is, you cannot find its size;
    it also doesn't implement iterable protocol
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these three differences it behaves exactly the same way as a Set`.`
    Everything else apart from these three differences is same between a Set and WeakSet
    object.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: A WeakSet object is created using `WeakSet` constructor. You cannot pass an
    iterable object as an argument to WeakSet object.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate WeakSet:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Map
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Map is a collection of key/value pairs. Keys and values of a Map can be of
    any data type. The key/value pairs are arranged in the insertion order. A Map
    object is created using the `Map` constructor.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example, which demonstrates how to create a Map object and do various
    operations on it:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Output is:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: While creating a Map object from an iterable object we need to make sure that
    the values returned by the iterable object are arrays, each of length `2` i.e.,
    index 0 is the key and index 1 is the value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: If we try to add a key that already exists then it's overwritten. The Map objects
    also implement the iterable protocol and can therefore also be used as an iterable
    object. While iterating Maps using the iterable protocol, they return arrays with
    key/value pairs as you can see in the preceding example.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: WeakMap
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the differences between the Map and the WeakMap objects:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Keys of a Map object can be of primitive types or object references but keys
    in WeakMap object can only be object references
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the important features of the WeakMap object is that if there is no other
    reference to an object that is referenced by a key then the key is garbage collected.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly the WeakMap object is not enumerable, that is, you cannot find its size
    and it doesn't implement iterable protocol.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else, apart from these three differences is similar between the Map
    and the WeakMap object.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: 'A WeakMap is created using `WeakMap` constructor. Here is an example that demonstrates
    its usage:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Object
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 standardizes the `__proto__` property of an object and adds new properties
    to the global `Object` object.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: The __proto__ property
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript objects have an internal `[[prototype]]` property that references
    the object's prototype, that is, the object it inherits. To read the property
    we had to use `Object.getPrototypeof()` and to create a new object with a given
    prototype we had to use the `Object.create()` method. A `[[prototype]]` property
    cannot be directly read or be modified.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting was cumbersome due to the nature of the `[[prototype]]` property,
    therefore some browsers added a special `__proto__` property in objects, which
    is an accessor property that exposes the internal `[[prototype]]` property and
    makes working with prototypes easier. The `__proto__` property was not standardized
    in ES5 but due to its popularity it was standardized in ES6.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The Object.is(value1, value2) method
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Object.is()` method determines whether two values are equal or not. It
    is similar to the `===` operator but there are some special cases for the `Object.is()`
    method. Here is an example that demonstrates the special cases:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Output is:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The Object.setPrototypeOf(object, prototype) method
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Object.setPrototypeOf()` method is just an another way to assign the `[[prototype]]`
    property of an object. Here is an example to demonstrate this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The Object.assign(targetObj, sourceObjs…) method
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Object.assign()` method is used is used to copy the values of all enumerable
    own properties from one or more source objects to a target object. This method
    will return the `targetObj.`
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example which demonstrates this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Output is:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here is a list of important things to keep in mind while using the `Object.assign()`
    method:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: It invokes getters on the sources and setters on the target.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It just assigns values of the properties of source to the new or existing properties
    of target.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't copy the `[[prototype]]` property of sources.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript property names can be strings or symbols. `Object.assign()` copies
    both.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 属性名可以是字符串或符号。`Object.assign()` 会复制两者。
- en: Property definitions are not copied from sources therefore you need to use `Object.getOwnPropertyDescriptor()Object.defineProperty()`
    instead.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性定义不会从源中复制，因此你需要使用 `Object.getOwnPropertyDescriptor()` 和 `Object.defineProperty()`。
- en: It ignores copying keys with `null` and `undefined` values.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会忽略带有 `null` 和 `undefined` 值的键的复制。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned new features added by ES6 for working with numbers,
    strings, arrays and objects. We saw how arrays impact performance in math-rich
    applications and how the array buffers can be used instead. We also walked through
    the new collection objects provided by ES6.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 ES6 为处理数字、字符串、数组和对象添加的新特性。我们看到了数组如何在数学密集型应用中影响性能，以及如何使用数组缓冲区来替代。我们还了解了
    ES6 提供的新集合对象。
- en: In next chapter, we will learn about Symbols and Iteration protocol, and we
    will discover `yield` keyword and generators also.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于符号和迭代协议的内容，并且我们会发现 `yield` 关键字和生成器。
