- en: Chapter 2. Knowing Your Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 熟悉你的库
- en: '**ES6** has added lots of new properties and methods to built-in JavaScript
    objects, so that the programmer can do cumbersome tasks easily. These new functionalities
    aim to help the developers get rid of using hacks and error-prone techniques to
    do various operations related to numbers, strings, and arrays. In this chapter,
    we will look at all the new functionalities added by ES6 to the native objects.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**ES6** 向内置的 JavaScript 对象添加了许多新的属性和方法，以便程序员可以轻松地完成繁琐的任务。这些新功能旨在帮助开发者摆脱使用黑客和易出错的技巧来完成与数字、字符串和数组相关的各种操作。在本章中，我们将查看
    ES6 添加到原生对象的所有新功能。'
- en: 'In this chapter, we''ll cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍：
- en: The new properties and methods of the `Number` object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Number` 对象的新属性和方法'
- en: Representing the numeric constants as binary or octal
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数字常量表示为二进制或八进制
- en: The new properties and methods of the `Math` object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Math` 对象的新属性和方法'
- en: Creating the multiline strings and the new methods of the `String` object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多行字符串和 `String` 对象的新方法
- en: The new properties and methods of `Array` object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Array` 对象的新属性和方法'
- en: What are Maps and Sets?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 Map 和 Set？
- en: Using array buffers and typed arrays
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组缓冲区和类型化数组
- en: The new properties and methods of `Object` object
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object` 对象的新属性和方法'
- en: Working with numbers
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与数字一起工作
- en: ES6 adds new ways of creating numbers and new properties to the `Number` object
    to make working with numbers easier. The `Number` object was enhanced in ES6 to
    make it easier to create mathematically rich applications, and prevent the common
    misconceptions that caused the errors. ES6 also provides new ways to do things
    that were already possible in ES5, such as representing the numeric constants
    as octal.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 增加了创建数字的新方法以及 `Number` 对象的新属性，以便更容易地处理数字。ES6 通过增强 `Number` 对象来简化创建数学丰富应用的过程，并防止导致错误的常见误解。ES6
    还提供了在 ES5 中已经可能做到的事情的新方法，例如将数字常量表示为八进制。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: JavaScript represents the numbers as base 10 decimals. The numeric constants
    are, by default, interpreted as base 10 decimals.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 将数字表示为十进制。默认情况下，数字常量被解释为十进制。
- en: The binary notation
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二进制表示法
- en: In ES5, there was no native way to represent the numeric constants as binary.
    But in ES6, you can prefix the numeric constants using the `0b` token to make
    JavaScript interpret them as binary.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，没有原生的方法来表示二进制的数字常量。但在 ES6 中，你可以使用 `0b` 符号来前缀数字常量，使 JavaScript 将它们解释为二进制。
- en: 'Here is an example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, `0b00001111` is a binary representation of 15, base 10 decimal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`0b00001111` 是 15 的二进制表示，基于十进制的十进制。
- en: The octal notation
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 八进制表示法
- en: 'In ES5, to represent a numeric constant as octal, we needed to prefix the numeric
    constant using `0`. For example, take a look at the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，要表示八进制的数字常量，我们需要使用 `0` 前缀。例如，看看下面的例子：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output is as the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: But often, programmers new to JavaScript, get confused with the octal representations
    as the decimal number with `0` at the front. For example, they think `017` is
    same as `17`. Therefore, to remove this confusion, ES6 lets us prefix the numeric
    constants using `0o` to make JavaScript interpret them as octal.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于初学者来说，八进制表示法可能会造成混淆，因为他们认为以 `0` 开头的十进制数与 `17` 相同。例如，他们认为 `017` 与 `17` 相同。因此，为了消除这种混淆，ES6
    允许我们使用 `0o` 前缀来使 JavaScript 将这些数字常量解释为八进制。
- en: 'Here is an example to demonstrate this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子来演示这一点：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The Number.isInteger(number) method
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Number.isInteger(number)` 方法'
- en: JavaScript numbers are stored as the 64-bit, floating-point numbers. So the
    integers in JavaScript are the floating-point numbers without a decimal fraction,
    or a decimal fraction with all 0's.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的数字以 64 位浮点数的形式存储。因此，JavaScript 中的整数是没有小数部分的浮点数，或者小数部分全部为 0 的浮点数。
- en: In ES5, there was no built-in way to check whether a number is an integer or
    not. ES6 adds a new method to the `Number` object called as `isInteger()`, which
    takes a number and returns `true` or `false,` depending on weather the number
    is an integer or not.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，没有内置的方法来检查一个数字是否为整数。ES6 向 `Number` 对象添加了一个新方法，称为 `isInteger()`，它接受一个数字并返回
    `true` 或 `false`，这取决于该数字是否为整数。
- en: 'Here is an example code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例代码：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Number.isNaN(value) method
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Number.isNaN(value)` 方法'
- en: In ES5, there was no way to check whether a variable holds the `NaN` value or
    not.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，没有方法可以检查一个变量是否包含 `NaN` 值。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The global `isNaN()` function is used to check whether a value is a number or
    not. If the value is not a number, then it returns `true`, otherwise it returns
    `false`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 `isNaN()` 函数用于检查一个值是否是数字。如果值不是数字，则返回 `true`，否则返回 `false`。
- en: 'So ES6 introduced a new method for the `Number` object called as `isNaN()`
    to check whether a value is `NaN` or not. Here is an example, which demonstrates
    `Number.isNaN()` and also explains how it is different from the global `isNaN()`
    function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ES6 引入了一个新的 `Number` 对象方法，称为 `isNaN()`，用于检查一个值是否是 `NaN`。以下是一个示例，它演示了 `Number.isNaN()`
    并解释了它与全局 `isNaN()` 函数的不同之处：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here you can see that `Number.isNaN()` method returns `true` only if the passed
    value is exactly `NaN`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到，`Number.isNaN()` 方法仅在传入的值正好是 `NaN` 时返回 `true`。
- en: Tip
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might ask, why not use `==` or the `===` operator instead of the `Number.isNaN(value)`
    method? The `NaN` value is the only value that is not equal to itself, that is,
    the expression `NaN==NaN` or `NaN===NaN` will return `false`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，为什么不用 `==` 或 `===` 运算符来代替 `Number.isNaN(value)` 方法？`NaN` 值是唯一一个不等于自身的值，也就是说，表达式
    `NaN==NaN` 或 `NaN===NaN` 将返回 `false`。
- en: The Number.isFinite(number) method
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Number.isFinite(number) 方法
- en: In ES5 there was no built-in way to check whether a value is a finite number.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，没有内置的方法来检查一个值是否是有限数。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The global `isFinite()` function takes a value and checks whether it's a finite
    number or not. But unfortunately, it also returns `true` for values that convert
    to a `Number` type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 全局 `isFinite()` 函数接受一个值并检查它是否是一个有限数。但不幸的是，它也会对转换为 `Number` 类型的值返回 `true`。
- en: 'So ES6 introduced the `Number.isFinite()` method, which resolves the issue
    of the `window.isFinite()` function. Here is an example to demonstrate this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ES6 引入了 `Number.isFinite()` 方法，解决了 `window.isFinite()` 函数的问题。以下是一个演示这个特性的例子：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Number.isSafeInteger(number) method
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Number.isSafeInteger(number) 方法
- en: The JavaScript numbers are stored as 64-bit floating-point numbers, following
    the international IEEE 754 standard. This format stores numbers in 64 bits, where
    the number (the fraction) is stored in 0 to 51 bits, the exponent in 52 to 62
    bits, and the sign in the last bit.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 数字以 64 位浮点数的形式存储，遵循国际 IEEE 754 标准。这种格式使用 64 位存储数字，其中数字（分数）存储在 0 到
    51 位，指数在 52 到 62 位，符号在最后一位。
- en: So in JavaScript, safe integers are those numbers that are not needed to be
    rounded to some other integer to fit in the IEEE 754 representation. Mathematically,
    the numbers from -(2^(53)-1) to (2^(53)-1) are considered as safe integers.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 JavaScript 中，安全的整数是那些不需要四舍五入到其他整数以适应 IEEE 754 表示的数。从数学上讲，从 -(2^(53)-1)
    到 (2^(53)-1) 的数被认为是安全的整数。
- en: 'Here is an example to demonstrate this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示这个特性的例子：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, `Number.MAX_SAFE_INTEGER` and `Number.MIN_SAFE_INTEGER` are constant values,
    introduced in ES6, representing (2^(53)-1) and -(2^(53)-1) respectively.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Number.MAX_SAFE_INTEGER` 和 `Number.MIN_SAFE_INTEGER` 是 ES6 中引入的常量值，分别代表
    (2^(53)-1) 和 -(2^(53)-1)。
- en: The Number.EPSILON property
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Number.EPSILON 属性
- en: JavaScript uses such binary floating-point representation that the computers
    fail to accurately represent, numbers like 0.1, 0.2, 0.3, and so on. When your
    code is executed, numbers like 0.1 are rounded to the nearest number in that format,
    which results in small rounding error.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使用的是计算机无法准确表示的二进制浮点数表示法，例如 0.1、0.2、0.3 等数字。当你的代码执行时，像 0.1 这样的数字会被四舍五入到该格式中最接近的数字，这会导致小的舍入误差。
- en: 'Consider this example:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Number.EPSILON` property was introduced in ES6, which has a value of approximately
    2^(-52). This value represents a reasonable margin of error when comparing the
    floating-point numbers. Using this number, we can create a custom function to
    compare the floating-point numbers by ignoring the minimal rounding errors.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number.EPSILON` 属性是在 ES6 中引入的，其值大约为 2^(-52)。这个值表示在比较浮点数时一个合理的误差范围。使用这个数字，我们可以创建一个自定义函数来比较浮点数，同时忽略最小的舍入误差。'
- en: 'Here is an example code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例代码：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, `epsilonEqual()` is the custom function that we build to compare whether
    the two values are equal or not. Now, the output is as expected.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`epsilonEqual()` 是我们构建的用于比较两个值是否相等的自定义函数。现在，输出结果符合预期。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about this behavior of JavaScript and the floating-point arithmetic,
    visit [http://floating-point-gui.de/](http://floating-point-gui.de/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于JavaScript的这种行为和浮点算术的信息，请访问 [http://floating-point-gui.de/](http://floating-point-gui.de/)。
- en: Doing Math
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行数学运算
- en: ES6 adds a lot of new methods to the `Math` object, related to trigonometry,
    arithmetic, and miscellaneous. This lets the developers use native methods instead
    of external math libraries. Native methods are optimized for performance, and
    have better decimal precision.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ES6向`Math`对象添加了许多新方法，涉及三角学、算术和杂项。这使得开发者可以使用原生方法而不是外部数学库。原生方法针对性能进行了优化，并且具有更好的十进制精度。
- en: Trigonometry related operations
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与三角学相关的操作
- en: 'Here is an example code, which shows the entire trigonometry-related methods
    that are added to the `Math` object:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例代码，展示了添加到`Math`对象中的所有与三角学相关的函数：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output is as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Arithmetic related operations
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与算术相关的操作
- en: 'Here is an example code, which shows the entire arithmetic related methods
    added to the `Math` object:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例代码，展示了添加到`Math`对象中的所有与算术相关的函数：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Miscellaneous methods
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项方法
- en: ES6 adds some miscellaneous methods to the `Math` object. These methods are
    used for conversion and extracting information from the numbers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ES6向`Math`对象添加了一些杂项方法。这些方法用于转换和从数字中提取信息。
- en: The Math.imul(number1, number2) function
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Math.imul(number1, number2)` 函数'
- en: The `Math.imul()` takes two numbers as 32-bit integers and multiplies them.
    It returns the lower 32 bits of the result. This is the only native way to do
    32-bit integer multiplication in JavaScript.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.imul()` 函数将两个数字作为32位整数相乘，并返回结果的下32位。这是JavaScript中进行32位整数乘法的唯一原生方法。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下面有一个示例来演示这一点：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Output is:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here when multiplication was done it produced a number so large it couldn't
    be stored in 32 bits, therefore the lower bits were lost.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当进行乘法运算时，产生了一个如此大的数字，以至于它无法存储在32位中，因此丢失了低位。
- en: The Math.clz32(number) function
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Math.clz32(number)` 函数'
- en: The `Math.clz32()` function returns the number of leading zero bits in the 32-bit
    representation of a number.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.clz32()` 函数返回一个数字在32位表示中的前导零位数。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个演示此功能的示例：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Output is:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Math.sign(number) function
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Math.sign(number)` 函数'
- en: The `Math.sign()` function returns the sign of a number, indicating weather
    the number is negative, positive or zero.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.sign()` 函数返回一个数字的符号，表示该数字是负数、正数还是零。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Output is:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: From the preceding code, we can see that the `Math.sign()` function returns
    `1` if the number is positive, `-1` if the number is negative, and `0` if the
    number is zero.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到，如果数字是正数，`Math.sign()` 函数返回 `1`；如果是负数，返回 `-1`；如果是零，返回 `0`。
- en: The Math.trunc(number) function
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Math.trunc(number)` 函数'
- en: 'The `Math.trunc()` function returns the integer part of a number by removing
    any fractional digit. Here is an example to demonstrate this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.trunc()` 函数通过移除任何小数位来返回一个数字的整数部分。以下是一个演示此功能的示例：'
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Output is:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE29]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The Math.fround(number) function
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Math.fround(number)` 函数'
- en: 'The `Math.fround()` function rounds a number to a 32-bit floating point value.
    Here is an example to demonstrate this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math.fround()` 函数将一个数字四舍五入到32位浮点值。以下是一个演示此功能的示例：'
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Output is:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Working with strings
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作
- en: ES6 provides new ways of creating strings and adds new properties to global
    String object and to its instances to make working with strings easier. Strings
    in JavaScript lacked features and capabilities when compared with programming
    languages such as Python and **Ruby** therefore ES6 enhanced strings to change
    that.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ES6提供了创建字符串的新方法，并为全局String对象及其实例添加了新属性，以使字符串操作更容易。与Python和**Ruby**等编程语言相比，JavaScript中的字符串缺乏功能和能力，因此ES6增强了字符串以改变这一点。
- en: Before we get into new string features lets revise JavaScript's internal character
    encoding and escape sequences. In the Unicode character set every character is
    represented by a base 10 decimal number called a **code point**. A **code unit**
    is a fixed number of bits in memory to store a code point. An encoding schema
    determines the length of code unit. A code unit is 8 bits if the **UTF-8** encoding
    schema is used or 16 bits if the **UTF-16** encoding schema is used. If a code
    point doesn't fit in a code unit it is spilt into multiple code units, that is,
    multiple characters in sequence representing a single character.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解新的字符串功能之前，让我们回顾一下JavaScript的内部字符编码和转义序列。在Unicode字符集中，每个字符都由一个称为**代码点**的十进制基数表示。**代码单元**是在内存中存储代码点的固定位数。编码方案决定了代码单元的长度。如果使用**UTF-8**编码方案，则代码单元是8位，如果使用**UTF-16**编码方案，则代码单元是16位。如果一个代码点不适合代码单元，它将被分割成多个代码单元，即多个字符按顺序表示一个字符。
- en: JavaScript interpreters by default interpret JavaScript source code as sequence
    of UTF-16 code units. If source code is written in the UTF-8 encoding schema then
    there are various ways to tell the JavaScript interpreter to interpret it as sequence
    of UTF-8 code units. JavaScript strings are always a sequence of UTF-16 code points.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript解释器默认将JavaScript源代码解释为UTF-16代码单元的序列。如果源代码是用UTF-8编码方案编写的，那么有各种方法可以告诉JavaScript解释器将其解释为UTF-8代码单元的序列。JavaScript字符串始终是UTF-16代码点的序列。
- en: 'Any Unicode character with a code point less than 65536 can be escaped in a
    JavaScript string or source code using the hexadecimal value of its code point,
    prefixed with `\u`. Escapes are six characters long. They require exactly four
    characters following `\u`. If the hexadecimal character code is only one, two
    or three characters long, you''ll need to pad it with leading zeroes. Here is
    an example to demonstrate this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 任何小于65536的代码点的Unicode字符都可以使用其代码点的十六进制值来转义，并在其前面加上`\u`。转义序列由六个字符组成。它们需要紧跟`\u`后的正好四个字符。如果十六进制字符代码只有一位、两位或三位，则需要用前导零填充。以下是一个演示此点的例子：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Escaping larger code points
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转义更大的代码点
- en: 'In ES5, for escaping a character that requires more than 16 bits for storing,
    we needed two Unicode escapes. For example, to add `\u1F691` to a string we had
    to escape it this way:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，对于需要超过16位存储的字符，我们需要两个Unicode转义序列。例如，要将`\u1F691`添加到字符串中，我们必须这样转义：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here `\uD83D` and `\uDE91` are called **surrogate pairs**. A surrogate pair
    is two Unicode characters when written in sequence represent another character.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`\uD83D`和`\uDE91`被称为**代理对**。代理对是两个Unicode字符，当它们按顺序书写时，代表另一个字符。
- en: 'In ES6 we can write it without surrogate pairs:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6中，我们可以不使用代理对来编写它：
- en: '[PRE34]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A string stores `\u1F691` as `\uD83D\uDE91`, so length of the above string is
    still `2`
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串将`\u1F691`存储为`\uD83D\uDE91`，因此上述字符串的长度仍然是`2`。
- en: The codePointAt(index) method
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`codePointAt(index)`方法'
- en: The `codePointAt()` method of a string returns a non-negative integer that is
    the code point of the character at the given index.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的`codePointAt()`方法返回一个非负整数，表示给定索引处的字符的代码点。
- en: 'Here is an example to demonstrate this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示此点的例子：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Output is:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The String.fromCodePoint(number1, …, number 2) method
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`String.fromCodePoint(number1, …, number 2)`方法'
- en: 'The `fromCodePoint()` method of `String` object takes a sequence of code points
    and returns a string. Here is an example to demonstrate this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象的`fromCodePoint()`方法接受一系列代码点，并返回一个字符串。以下是一个演示此点的例子：'
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Output is:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The repeat(count) method
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`repeat(count)`方法'
- en: 'The `repeat()` method of a string, constructs and returns a new string which
    contains the specified number of copies on which it was called, concatenated together.
    Here is an example to demonstrate this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的`repeat()`方法构建并返回一个新的字符串，该字符串包含调用它的指定次数的副本，并将它们连接在一起。以下是一个演示此点的例子：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The includes(string, index) method
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`includes(string, index)`方法'
- en: 'The `includes()` method is used to find whether one string may be found in
    another string, returning `true` or `false` as appropriate. Here is an example
    to demonstrate this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`includes()`方法用于确定一个字符串是否可以在另一个字符串中找到，根据情况返回`true`或`false`。以下是一个演示此点的例子：'
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个可选的第二个参数，表示在字符串中开始搜索的位置。以下是一个演示此点的例子：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The startsWith(string, index) method
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`startsWith(string, index)`方法'
- en: 'The `startsWith()` method is used to find whether a string begins with the
    characters of another string, returning `true` or `false` as appropriate. Here
    is an example to demonstrate this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`startsWith()` 方法用于确定一个字符串是否以另一个字符串的字符开头，根据情况返回 `true` 或 `false`。以下是一个演示此功能的示例：'
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个可选的第二个参数，表示在字符串中开始搜索的位置。以下是一个演示此功能的示例：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The endsWith(string, index) function
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`endsWith(string, index)` 函数'
- en: 'The `endsWith()` method is used to find whether a string ends with the characters
    of another string, returning true or false as appropriate. It also takes an optional
    second parameter representing the position in the string that is assumed as the
    end of the string. Here is an example to demonstrate this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`endsWith()` 方法用于确定一个字符串是否以另一个字符串的字符结尾，根据情况返回 true 或 false。它还接受一个可选的第二个参数，表示假设为字符串结尾的字符串中的位置。以下是一个演示此功能的示例：'
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Normalization
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规范化
- en: '**Normalization** is simply the process of searching and standardizing code
    points without changing the meaning of the string.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范化**简单地说，是一个在改变字符串意义的情况下搜索和标准化码点的过程。'
- en: 'There are also different forms of normalization: NFC, NFD, NFKC and NFKD.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 还有不同的规范化形式：NFC、NFD、NFKC 和 NFKD。
- en: 'Let''s understand Unicode string normalization by an example use case:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例用例来理解 Unicode 字符串规范化。
- en: A case study
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'There are many Unicode characters that can be stored in 16 bits and can also
    be represented using a surrogate pair. For example, ''`é`'' character can be escaped
    two ways:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多 Unicode 字符可以用 16 位存储，也可以使用代理对表示。例如，"`é`" 字符可以用两种方式转义：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The problem is when applying the `==` operator, iterating or finding length
    you will get an unexpected result. Here is an example to demonstrate this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于当应用 `==` 运算符、迭代或查找长度时，你会得到一个意外的结果。以下是一个演示此功能的示例：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Output is:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Here both the strings display the same way but when we do various string operations
    on them we get different results.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这两个字符串显示方式相同，但当我们对它们进行各种字符串操作时，我们会得到不同的结果。
- en: The length property ignores surrogate pairs and assumes every 16-bit to be single
    character. The `==` operator matches the binary bits therefore it also ignores
    surrogate pairs. The `[]` operator also assumes every 16-bit to be an index therefore
    ignoring surrogate pairs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`length` 属性忽略代理对，并假设每个 16 位是一个单独的字符。`==` 运算符匹配二进制位，因此它也忽略了代理对。`[]` 运算符也假设每个
    16 位是一个索引，因此忽略了代理对。'
- en: 'In this case to solve the problems we need to convert the surrogate pairs to
    16-bit character representation. This process is called as **normalization**.
    To do this ES6 provides a `normalize()` function. Here is an example to demonstrate
    this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为了解决问题，我们需要将代理对转换为 16 位字符表示。这个过程被称为**规范化**。为此，ES6 提供了一个 `normalize()`
    函数。以下是一个演示此功能的示例：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Output is:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here the output is as expected. `normalize()` returns the normalized version
    of the string. `normalize()` uses NFC form by default.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里输出符合预期。`normalize()` 返回字符串的规范化版本。`normalize()` 默认使用 NFC 格式。
- en: Normalization is not just done in the case of surrogate pairs; there are many
    other cases.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 规范化不仅用于代理对的情况；还有许多其他情况。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Normalized version of a string is not made for displaying to the user; it's
    used for comparing and searching in strings.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的规范化版本不是用于向用户显示的；它用于字符串的比较和搜索。
- en: To learn more about Unicode string normalization and normalization forms visit
    [http://www.unicode.org/reports/tr15/](http://www.unicode.org/reports/tr15/).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Unicode 字符串规范化和规范化形式的信息，请访问 [http://www.unicode.org/reports/tr15/](http://www.unicode.org/reports/tr15/).
- en: Template strings
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板字符串
- en: Template strings is just a new literal for creating strings that makes various
    things easier. They provide features such as embedded expressions, multi-line
    strings, string interpolation, string formatting, string tagging, and so on. They
    are always processed and converted to a normal JavaScript string on runtime therefore
    they can be used wherever we use normal strings.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串只是创建字符串的新字面量，这使得许多事情变得更容易。它们提供嵌入表达式、多行字符串、字符串插值、字符串格式化、字符串标记等功能。它们总是在运行时被处理和转换为正常的
    JavaScript 字符串，因此可以在使用正常字符串的任何地方使用。
- en: 'Template strings are written using back ticks instead of single or double quotes.
    Here is an example of a simple template string:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串使用反引号而不是单引号或双引号来编写。以下是一个简单模板字符串的示例：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Expressions
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表达式
- en: 'In ES5, to embed expressions within normal strings you would do something like
    this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，要在普通字符串中嵌入表达式，你会这样做：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Output is:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In ES6, template strings make it much easier to embed expressions in strings.
    Template strings can contain expressions in them. The expressions are placed in
    placeholders indicated by dollar sign and curly brackets, that is, `${expressions}`.
    The resolved value of expressions in the placeholders and the text between them
    are passed to a function for resolving the template string to a normal string.
    The default function just concatenates the parts into a single string. If we use
    a custom function to process the string parts then the template string is called
    as a **tagged template string** and the custom function is called as **tag function**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，模板字符串使得在字符串中嵌入表达式变得更加容易。模板字符串可以包含表达式。这些表达式放置在由美元符号和大括号指示的占位符中，即 `${expressions}`。占位符中的表达式解析值和它们之间的文本被传递给一个函数以解析模板字符串为普通字符串。默认函数只是将部分连接成一个字符串。如果我们使用自定义函数处理字符串部分，则模板字符串被称为
    **标签模板字符串**，自定义函数被称为 **标签函数**。
- en: 'Here is an example which shows how to embed expressions in a template strings:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，展示了如何在模板字符串中嵌入表达式：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Output is:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s create a tagged template string, that is, process the string using a
    tag function. Let''s implement the tag function to do the same thing as the default
    function. Here is an example to demonstrate this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个标签模板字符串，即使用标签函数处理字符串。让我们实现标签函数以执行与默认函数相同的功能。以下是一个演示此功能的示例：
- en: '[PRE55]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Output is:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE56]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here our tag function's name is `tag` but you can name it anything else. The
    custom function takes two parameters, that is, the first parameter is an array
    of string literals of the template string and the second parameter is an array
    of resolved values of the expressions. The second parameter is passed as multiple
    arguments therefore we use the rest argument.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的标签函数的名称是 `tag`，但你可以将其命名为任何其他名称。自定义函数接受两个参数，即第一个参数是模板字符串的字符串字面量数组，第二个参数是表达式的解析值数组。第二个参数作为多个参数传递，因此我们使用剩余参数。
- en: Multiline strings
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多行字符串
- en: Template strings provide a new way to create strings that contain multiple lines
    of text.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串提供了一种创建包含多行文本的新字符串的方法。
- en: 'In ES5, we need to use `\n` new line character to add new line breaks. Here
    is an example to demonstrate this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES5 中，我们需要使用 `\n` 换行符来添加换行符。以下是一个演示此功能的示例：
- en: '[PRE57]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Output is:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE58]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In ES6, using **multiline** string we can simply write:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ES6 中，使用 **多行** 字符串我们可以简单地写：
- en: '[PRE59]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Output is:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the above code we simply included new lines where we needed to place `\n`.
    While converting the template string to normal string the new lines are converted
    to `\n`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们简单地包含了需要放置 `\n` 的换行符。在将模板字符串转换为普通字符串时，换行符被转换为 `\n`。
- en: Raw strings
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始字符串
- en: A raw string is a normal string in which escaped characters aren't interpreted.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 原始字符串是一个普通的字符串，其中转义字符不会被解释。
- en: 'We can create a raw string using a template string. We can get raw version
    of a template string use `String.raw` tag function. Here is an example to demonstrate
    this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模板字符串创建原始字符串。我们可以使用 `String.raw` 标签函数获取模板字符串的原始版本。以下是一个演示此功能的示例：
- en: '[PRE61]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Output is:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE62]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Here `\n` is not interpreted as new line character instead of its two characters,
    that is, `\` and `n`. Length of variable `s` would be `6`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `\n` 不会被解释为换行符，而是其两个字符，即 `\` 和 `n`。变量 `s` 的长度将是 `6`。
- en: 'If you create a tagged function and you want to return the raw string then
    use `raw` property of the first argument. `raw` property is an array, which holds
    raw versions of the strings of the first argument. Here is an example to demonstrate
    this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个标签函数并想返回原始字符串，则使用第一个参数的 `raw` 属性。`raw` 属性是一个数组，它包含第一个参数的字符串的原始版本。以下是一个演示此功能的示例：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Output is:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE64]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Arrays
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: ES6 adds new properties to the global Array object and to its instances to make
    working with arrays easier. Arrays in JavaScript lacked features and capabilities
    when compared with programming languages such as Python and Ruby therefore ES6
    enhanced arrays to change that.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 向全局 Array 对象及其实例添加了新属性，以使处理数组更容易。与 Python 和 Ruby 等编程语言相比，JavaScript 中的数组缺乏功能和能力，因此
    ES6 增强了数组以改变这一点。
- en: The Array.from(iterable, mapFunc, this) method
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Array.from(iterable, mapFunc, this) 方法
- en: The `Array.from()` method creates a new array instance from an iterable object.
    The first argument is a reference to the iterable object. The second argument
    is optional and is a callback (known as **Map function**) that is called for every
    element of the iterable object. The third argument is also optional and is the
    value of `this` inside the Map function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.from()` 方法从一个可迭代对象创建一个新的数组实例。第一个参数是可迭代对象的引用。第二个参数是可选的，是一个回调函数（称为 **映射函数**），它会对可迭代对象的每个元素进行调用。第三个参数也是可选的，是映射函数内部
    `this` 的值。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Output is:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE66]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The Array.of(values…) method
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Array.of(values…)` 方法'
- en: The `Array.of()` method is an alternative to the `Array` constructor for creating
    arrays. When using `Array` constructor if we pass only one argument, that too
    a number, then `Array` constructor constructs an empty array with array `length`
    property equal to the passed number instead of creating an array of one element
    with that number in it. Therefore the `Array.of()` method was introduced to resolve
    this issue.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.of()` 方法是创建数组的 `Array` 构造函数的替代方案。当使用 `Array` 构造函数时，如果我们只传递一个参数，而且这个参数是一个数字，那么
    `Array` 构造函数将创建一个空数组，其 `length` 属性等于传递的数字，而不是创建一个包含该数字的单元素数组。因此，引入了 `Array.of()`
    方法来解决这个问题。'
- en: 'Here is an example to demonstrate this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Output is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You should use `Array.of()` instead of `Array` constructor when you are constructing
    a new array instance dynamically, that is, when you don't know the type of values
    and the number of elements.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当你动态地构造一个新的数组实例时，应该使用 `Array.of()` 而不是 `Array` 构造函数，即当你不知道值的类型和元素数量时。
- en: The fill(value, startIndex, endIndex) method
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`fill(value, startIndex, endIndex)` 方法'
- en: The `fill()` method of an array fills all the elements of the array from the
    `startIndex` to an `endIndex` (not including `endIndex`) with a given value. Remember
    that `startIndex` and `endIndex` arguments are optional; therefore if they are
    not provided then the whole array is filled with the given value. If only `startIndex`
    is provided then `endIndex` defaults to length of array minus 1.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的 `fill()` 方法使用给定的值填充数组从 `startIndex` 到 `endIndex`（不包括 `endIndex`）的所有元素。记住，`startIndex`
    和 `endIndex` 参数是可选的；因此，如果它们没有提供，则整个数组将用给定的值填充。如果只提供了 `startIndex`，则 `endIndex`
    默认为数组的长度减 1。
- en: If `startIndex` is negative then it's treated as length of array plus `startIndex`.
    If `endIndex` is negative, it is treated as length of array plus `endIndex`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `startIndex` 是负数，则它被视为数组长度加上 `startIndex`。如果 `endIndex` 是负数，则它被视为数组长度加上 `endIndex`。
- en: 'Here is an example to demonstrate this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE69]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Output is:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE70]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The find(testingFunc, this) method
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`find(testingFunc, this)` 方法'
- en: The `find()` method of an array returns an array element, if it satisfies the
    provided testing function. Otherwise it returns `undefined`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的 `find()` 方法返回一个数组元素，如果它满足提供的测试函数。否则它返回 `undefined`。
- en: The `find()` method takes two arguments, that is, the first argument is the
    testing function and the second argument is the value of `this` in the testing
    function. The second argument is optional.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`find()` 方法接受两个参数，即第一个参数是测试函数，第二个参数是测试函数中 `this` 的值。第二个参数是可选的。'
- en: 'The testing function has three parameters: the first parameter is the array
    element being processed, second parameter is the index of the current element
    being processed and third parameter is the array on which `find()` is called upon.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数有三个参数：第一个参数是正在处理的数组元素，第二个参数是正在处理的当前元素的索引，第三个参数是调用 `find()` 的数组。
- en: The testing function needs to return `true` to satisfy a value. The `find()`
    method returns the first element which satisfies the provided testing function.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 测试函数需要返回 `true` 来满足一个值。`find()` 方法返回第一个满足提供的测试函数的元素。
- en: 'Here is an example to demonstrate the `find()` method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示 `find()` 方法：
- en: '[PRE71]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The findIndex(testingFunc, this) method
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`findIndex(testingFunc, this)` 方法'
- en: The `findIndex()` method is similar to the `find()` method. The `findIndex()`
    method returns the index of the satisfied array element instead of the element
    itself.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`findIndex()` 方法与 `find()` 方法类似。`findIndex()` 方法返回满足条件的数组元素的索引，而不是元素本身。'
- en: '[PRE72]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The copyWithin(targetIndex, startIndex, endIndex) function
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`copyWithin(targetIndex, startIndex, endIndex)` 函数'
- en: The `copyWithin()` method of an array is used to copy the sequence of values
    of the array to a different position in the array.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的 `copyWithin()` 方法用于将数组的值序列复制到数组中的不同位置。
- en: 'The `copyWithin()` method takes three arguments: first argument represents
    the target index where to copy elements to, second argument represents the index
    position where to start copying from and the third argument represents the index
    , that is, where to actually end copying elements.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`copyWithin()`方法接受三个参数：第一个参数表示目标索引，即要复制元素的位置，第二个参数表示开始复制的索引位置，第三个参数表示索引，即实际结束复制元素的位置。'
- en: The third argument is optional and if not provided then it defaults to `length-1`
    where `length` is the length of the array. If `startIndex` is negative then it's
    calculated as `length+startIndex`. Similarly if `endIndex` is negative then it's
    calculated as `length+endIndex`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是可选的，如果没有提供，则默认为`length-1`，其中`length`是数组的长度。如果`startIndex`是负数，则计算为`length+startIndex`。同样，如果`endIndex`是负数，则计算为`length+endIndex`。
- en: 'Here is an example to demonstrate this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE73]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Output is:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE74]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The entries(), keys(), and values() method
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`entries()`、`keys()`和`values()`方法'
- en: The `entries()` method of an array returns an iterable object that contains
    key/value pairs for each index of the array. Similarly the `keys()` method of
    an array returns an iterable object that contains keys for each of the indexes
    in the array. Similarly, the `values()` method of an array returns an iterable
    object that contains values of the array.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`entries()`方法返回一个包含数组每个索引的键/值对的可迭代对象。同样，数组的`keys()`方法返回一个包含数组中每个索引的键的可迭代对象。同样，数组的`values()`方法返回一个包含数组值的可迭代对象。
- en: The iterable object returned by the `entries()` method stores the key/value
    pairs in the form of arrays.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`entries()`方法返回的可迭代对象以数组的形式存储键/值对。'
- en: The iterable object returned by these functions is not an array.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数返回的可迭代对象不是一个数组。
- en: 'Here is an example to demonstrate this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例来演示这一点：
- en: '[PRE75]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Output is:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE76]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Collections
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: A collection is any object that stores multiple elements as a single unit. ES6
    introduced various new collection objects to provide better ways of storing and
    organizing data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是指任何将多个元素存储为单一单元的对象。ES6引入了各种新的集合对象，以提供更好的存储和组织数据的方式。
- en: The array is the only collection object available in ES5\. ES6 introduces array
    buffers, typed arrays, Sets, and Maps, which are built in collection objects.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES5中，数组是唯一的集合对象。ES6引入了数组缓冲区、类型化数组、集合（Sets）和映射（Maps），这些都是内置的集合对象。
- en: Let's see the different collection objects provided by ES6.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看ES6提供的不同集合对象。
- en: Array buffers
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组缓冲区
- en: Elements of arrays can be of any type such as strings, numbers, objects, and
    so on. Arrays can grow dynamically. The problem with arrays is that they are slow
    in terms of execution time, and occupy more memory. This causes issues while developing
    applications that require too much computation and deal with large amount of numbers.
    Therefore array buffers were introduced to tackle this issue.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的元素可以是任何类型，如字符串、数字、对象等。数组可以动态增长。数组的问题在于它们在执行时间上较慢，并且占用更多内存。这导致在开发需要大量计算和大量处理数字的应用程序时出现问题。因此，引入数组缓冲区来解决这个问题。
- en: An array buffer is a collection of 8-bit blocks in memory. Every block is an
    array buffer element. The size of an array buffer needs to be decided while creating,
    it therefore it cannot grow dynamically. Array buffers can only store numbers.
    All blocks are initialized to number 0 on creation of an array buffer.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 数组缓冲区是内存中8位块的集合。每个块都是一个数组缓冲区元素。数组缓冲区的大小在创建时需要确定，因此它不能动态增长。数组缓冲区只能存储数字。所有块在创建数组缓冲区时都初始化为数字0。
- en: An array buffer object is created using `ArrayBuffer` constructor.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ArrayBuffer`构造函数创建数组缓冲区对象。
- en: '[PRE77]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Reading from and writing values into an array buffer object can be done using
    a DateView object. It''s not compulsory that only 8 bits are used to represent
    a number. We can use 8, 16, 32 and 64 bits to represent a number. Here is an example,
    which shows how to create a DateView object and read/write to an `ArrayBuffer`
    object:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`DataView`对象从数组缓冲区对象中读取值或写入值。不强制使用8位来表示数字。我们可以使用8位、16位、32位和64位来表示数字。以下是一个示例，展示了如何创建`DataView`对象并读取/写入`ArrayBuffer`对象：
- en: '[PRE78]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here we created a DataView object using `DataView` constructor. A DataView object
    provides several methods to read and write numbers into an array buffer `object`.
    Here we used `setInt32()` method which uses 32 bits to store a provided number.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`DataView`构造函数创建了一个`DataView`对象。`DataView`对象提供了几种方法来将数字读入或写入数组缓冲区对象。这里我们使用了`setInt32()`方法，它使用32位来存储提供的数字。
- en: All the methods of a DataView object that are used to write data to an array
    buffer object take three arguments. First argument represents the offset, that
    is, the byte we want to write the number to. Second argument is the number to
    be stored. And third argument is a Boolean type, which represents the endian of
    the number, such as `false` represents a big-endian.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用于将数据写入数组缓冲区对象的DataView对象的方法都接受三个参数。第一个参数表示偏移量，即我们想要写入数字的字节。第二个参数是要存储的数字。第三个参数是一个布尔类型，它表示数字的端序，例如`false`表示大端序。
- en: Similarly all the methods of a DataView object that are used to read data of
    an array buffer object take two arguments. First argument is the offset and second
    argument represents the endian used.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，所有用于读取数组缓冲区对象数据的DataView对象的方法都接受两个参数。第一个参数是偏移量，第二个参数表示使用的端序。
- en: 'Here are other functions for storing numbers provided by a DataView object:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是DataView对象提供的其他用于存储数字的函数：
- en: '**setInt8**: Uses 8 bits to store a number. It takes a signed integer (-ve
    or +ve).'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setInt8**: 使用8位存储一个数字。它接受一个有符号整数（负或正）。'
- en: '**setUint8**: Uses 8 bits to store a number. It takes an unsigned integer (+ve).'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setUint8**: 使用8位存储一个数字。它接受一个无符号整数（正）。'
- en: '**setInt16**: Uses 16 bits to store a number. It takes a signed integer.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setInt16**: 使用16位存储一个数字。它接受一个有符号整数。'
- en: '**setUint16**: Uses 16 bits to store a number. It takes an unsigned integer.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setUint16**: 使用16位存储一个数字。它接受一个无符号整数。'
- en: '**setInt32**: Uses 32 bits to store a number. It takes a signed integer.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setInt32**: 使用32位存储一个数字。它接受一个有符号整数。'
- en: '**setUint32**: Uses 32 bits to store a number. It takes an unsigned integer.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setUint32**: 使用32位存储一个数字。它接受一个无符号整数。'
- en: '**setFloat32**: Uses 32 bits to store a number. It takes a signed decimal number.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setFloat32**: 使用32位存储一个数字。它接受一个有符号十进制数。'
- en: '**setFloat64**: Uses 64 bits to store a number. It takes a signed decimal number.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**setFloat64**: 使用64位存储一个数字。它接受一个有符号十进制数。'
- en: 'Here are other functions for retrieving stored numbers by a DataView object:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是DataView对象提供的其他用于检索存储数字的函数：
- en: '**getInt8**: Reads 8 bits. Returns signed integer number.'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getInt8**: 读取8位。返回有符号整数。'
- en: '**getUint8**: Reads 8 bits. Returns unsigned integer number.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getUint8**: 读取8位。返回无符号整数。'
- en: '**getInt16**: Reads 16 bits. Returns signed integer number.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getInt16**: 读取16位。返回有符号整数。'
- en: '**getUint16**: Reads 16 bits. Returns unsigned integer number.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getUint16**: 读取16位。返回无符号整数。'
- en: '**getInt32**: Reads 32 bits. Returns signed integer number.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getInt32**: 读取32位。返回有符号整数。'
- en: '**getUint32**: Reads 32 bits. Returns unsigned integer number.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getUint32**: 读取32位。返回无符号整数。'
- en: '**getFloat32**: Reads 32 bits. Returns signed decimal number.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getFloat32**: 读取32位。返回有符号十进制数。'
- en: '**getFloat64**: Reads 64 bits. Returns signed decimal number.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**getFloat64**: 读取64位。返回有符号十进制数。'
- en: Typed arrays
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化数组
- en: We saw how to read and write numbers in array buffers. But the method was very
    cumbersome because we had to call a function every time. **Typed arrays** let
    us read and write to an array buffer object just like we do for normal arrays.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何在数组缓冲区中读取和写入数字。但是方法非常繁琐，因为每次都必须调用一个函数。**类型化数组**允许我们像处理普通数组一样读取和写入数组缓冲区对象。
- en: A typed array acts like a wrapper for an array buffer object and treats data
    of an array buffer object as a sequence of *n*-bit numbers. The `n` value depends
    on how we created the typed array.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化数组像一个数组缓冲区对象的包装器，并将数组缓冲区对象的数据视为*n*-位数字的序列。`n`值取决于我们如何创建类型化数组。
- en: 'Here is the code example that demonstrates how to create an array buffer object
    and read/write to it using a typed array:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码示例，演示了如何创建一个数组缓冲区对象，并使用类型化数组对其进行读写：
- en: '[PRE79]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Output is:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE80]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Here we created typed array using the `Float64Array` constructor, it therefore
    treats data in the array buffer as a sequence of 64-bit signed decimal numbers.
    Here the array buffer object size was 640 bits therefore only 10 64-bit numbers
    can be stored.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Float64Array`构造函数创建了类型化数组，因此它将数组缓冲区中的数据视为64位有符号十进制数的序列。这里数组缓冲区对象的大小是640位，因此只能存储10个64位数字。
- en: 'Similarly, there are other typed array constructors to represent data in an
    array buffer as a sequence of different bit numbers. Here is the list:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有其他类型化数组构造函数，用于将数组缓冲区中的数据表示为不同位数的序列。以下是列表：
- en: '**Int8Array**: Treats as 8-bit signed integers'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int8Array**: 将其视为8位有符号整数'
- en: '**Uint8Array**: Treats as 8-bit unsigned integers'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uint8Array**: 将其视为8位无符号整数'
- en: '**Int16Array**: Treats as 16-bit signed integers'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int16Array**: 将其视为16位有符号整数'
- en: '**Uint16Array**: Treats as 16-bit unsigned integers'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uint16Array**：被视为 16 位无符号整数'
- en: '**Int32Array**: Treats as 32-bit signed integers'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Int32Array**：被视为 32 位有符号整数'
- en: '**Uint32Array**: Treats as 32-bit unsigned integers'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Uint32Array**：被视为 32 位无符号整数'
- en: '**Float32Array**: Treats as 32-bit signed decimal number'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Float32Array**：被视为 32 位有符号十进制数'
- en: '**Float64Array**: Treats as 64-bit signed decimal number'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Float64Array**：被视为 64 位有符号十进制数'
- en: Typed arrays provide all the methods that are also provided by normal JavaScript
    arrays. They also implement the iterable protocol therefore they can be used as
    an iterable object.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化数组提供了正常 JavaScript 数组提供的所有方法。它们也实现了可迭代协议，因此可以用作可迭代对象。
- en: Set
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Set
- en: 'A **Set** is a collection of *unique* values of any data type. The values in
    a Set are arranged in insertion order. A Set is created using `Set` constructor.
    Here is an example:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '**Set** 是任何数据类型唯一值的集合。集合中的值按插入顺序排列。集合是通过 `Set` 构造函数创建的。以下是一个示例：'
- en: '[PRE81]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here `set1` is an empty Set. Whereas `set2` was created using values of an iterable
    object, that is, characters of a string and the string was not empty therefore
    `set2` is non-empty.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里 `set1` 是一个空集合。而 `set2` 是使用可迭代对象的值创建的，即字符串的字符，并且字符串不为空，因此 `set2` 不是空的。
- en: 'Here is example code, which demonstrates various operations that can be done
    on a Set:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是示例代码，它演示了可以在集合上执行的各种操作：
- en: '[PRE82]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Output is:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE83]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Here we added nine items to the `set` object but the `size` was only six because
    Set automatically deletes duplicate values. The characters `l`and `!`were repeated
    multiple times.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向 `set` 对象中添加了九个项，但大小只有六，因为集合会自动删除重复的值。字符 `l` 和 `!` 被重复多次。
- en: The Set object also implements the iterable protocol so they can be used as
    an iterable object.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 集合对象也实现了可迭代协议，因此它们可以用作可迭代对象。
- en: 'Sets are used when you want to maintain a collection of values and check if
    a value exists instead of retrieving a value. For example: Sets can be used as
    an alternative to an array if you only use the `indexOf()` method of the array
    in your code to check if an value exists.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想维护一个值的集合并检查一个值是否存在而不是检索一个值时，会使用集合。例如：如果你在代码中只使用数组的 `indexOf()` 方法来检查值是否存在，那么集合可以用作数组的替代。
- en: WeakSet
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WeakSet
- en: 'Here are the differences between Set and WeakSet objects:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Set 和 WeakSet 对象之间的区别：
- en: A Set can store primitive types and object references whereas a WeakSet object
    can only store object references
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合可以存储原始类型和对象引用，而 WeakSet 对象只能存储对象引用。
- en: One of the important features of the WeakSet object is that if there is no other
    reference to an object stored in a WeakSet object then they are garbage collected
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WeakSet 对象的一个重要特性是，如果没有其他引用指向存储在 WeakSet 对象中的对象，则它们会被垃圾回收。
- en: Lastly a WeakSet object is not enumerable, that is, you cannot find its size;
    it also doesn't implement iterable protocol
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，WeakSet 对象是不可枚举的，也就是说，你不能找到它的大小；它也没有实现可迭代协议。
- en: Apart from these three differences it behaves exactly the same way as a Set`.`
    Everything else apart from these three differences is same between a Set and WeakSet
    object.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个区别之外，它的行为与 Set 完全相同。除了这三个区别之外，Set 和 WeakSet 对象之间的一切都是相同的。
- en: A WeakSet object is created using `WeakSet` constructor. You cannot pass an
    iterable object as an argument to WeakSet object.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: WeakSet 对象是通过 `WeakSet` 构造函数创建的。你不能将可迭代对象作为参数传递给 WeakSet 对象。
- en: 'Here is an example to demonstrate WeakSet:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个演示 WeakSet 的示例：
- en: '[PRE84]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Map
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map
- en: A Map is a collection of key/value pairs. Keys and values of a Map can be of
    any data type. The key/value pairs are arranged in the insertion order. A Map
    object is created using the `Map` constructor.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Map 是键/值对的集合。Map 的键和值可以是任何数据类型。键/值对按插入顺序排列。Map 对象是通过 `Map` 构造函数创建的。
- en: 'Here is an example, which demonstrates how to create a Map object and do various
    operations on it:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，演示了如何创建 Map 对象并在其上执行各种操作：
- en: '[PRE85]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Output is:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE86]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: While creating a Map object from an iterable object we need to make sure that
    the values returned by the iterable object are arrays, each of length `2` i.e.,
    index 0 is the key and index 1 is the value.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在从可迭代对象创建 Map 对象时，我们需要确保可迭代对象返回的值是长度为 `2` 的数组，即索引 0 是键，索引 1 是值。
- en: If we try to add a key that already exists then it's overwritten. The Map objects
    also implement the iterable protocol and can therefore also be used as an iterable
    object. While iterating Maps using the iterable protocol, they return arrays with
    key/value pairs as you can see in the preceding example.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试添加一个已经存在的键，那么它将被覆盖。Map对象也实现了可迭代协议，因此也可以用作可迭代对象。在通过可迭代协议迭代Map时，它们返回包含键/值对的数组，正如前一个示例所示。
- en: WeakMap
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WeakMap
- en: 'Here are the differences between the Map and the WeakMap objects:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Map和WeakMap对象之间的差异：
- en: Keys of a Map object can be of primitive types or object references but keys
    in WeakMap object can only be object references
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Map对象的键可以是原始类型或对象引用，但WeakMap对象中的键只能是对象引用
- en: One of the important features of the WeakMap object is that if there is no other
    reference to an object that is referenced by a key then the key is garbage collected.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WeakMap`对象的一个重要特性是，如果没有其他引用指向由键引用的对象，则该键将被垃圾回收。'
- en: Lastly the WeakMap object is not enumerable, that is, you cannot find its size
    and it doesn't implement iterable protocol.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，WeakMap对象不是可枚举的，也就是说，你不能找到它的大小，它也不实现可迭代协议。
- en: Everything else, apart from these three differences is similar between the Map
    and the WeakMap object.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个差异之外，Map和WeakMap对象之间的一切都是相似的。
- en: 'A WeakMap is created using `WeakMap` constructor. Here is an example that demonstrates
    its usage:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WeakMap`构造函数创建`WeakMap`。以下是一个演示其使用的示例：
- en: '[PRE87]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Object
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Object
- en: ES6 standardizes the `__proto__` property of an object and adds new properties
    to the global `Object` object.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: ES6标准化了对象的`__proto__`属性，并向全局`Object`对象添加了新属性。
- en: The __proto__ property
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__proto__`属性'
- en: JavaScript objects have an internal `[[prototype]]` property that references
    the object's prototype, that is, the object it inherits. To read the property
    we had to use `Object.getPrototypeof()` and to create a new object with a given
    prototype we had to use the `Object.create()` method. A `[[prototype]]` property
    cannot be directly read or be modified.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象有一个内部`[[prototype]]`属性，它引用对象的原型，即它继承的对象。为了读取属性，我们必须使用`Object.getPrototypeOf()`，为了创建具有给定原型的新的对象，我们必须使用`Object.create()`方法。`[[prototype]]`属性不能直接读取或修改。
- en: Inheriting was cumbersome due to the nature of the `[[prototype]]` property,
    therefore some browsers added a special `__proto__` property in objects, which
    is an accessor property that exposes the internal `[[prototype]]` property and
    makes working with prototypes easier. The `__proto__` property was not standardized
    in ES5 but due to its popularity it was standardized in ES6.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`[[prototype]]`属性的性质，继承变得繁琐，因此一些浏览器在对象中添加了一个特殊的`__proto__`属性，这是一个访问器属性，它公开了内部的`[[prototype]]`属性，使得与原型的工作更加容易。`__proto__`属性在ES5中并未标准化，但由于其流行，它在ES6中被标准化。
- en: 'Here is an example to demonstrate this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示此点的示例：
- en: '[PRE88]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The Object.is(value1, value2) method
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Object.is(value1, value2)`方法'
- en: 'The `Object.is()` method determines whether two values are equal or not. It
    is similar to the `===` operator but there are some special cases for the `Object.is()`
    method. Here is an example that demonstrates the special cases:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.is()`方法确定两个值是否相等。它与`===`运算符类似，但`Object.is()`方法有一些特殊情况。以下是一个演示这些特殊情况的示例：'
- en: '[PRE89]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Output is:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE90]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The Object.setPrototypeOf(object, prototype) method
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Object.setPrototypeOf(object, prototype)`方法'
- en: 'The `Object.setPrototypeOf()` method is just an another way to assign the `[[prototype]]`
    property of an object. Here is an example to demonstrate this:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.setPrototypeOf()`方法只是分配对象`[[prototype]]`属性的另一种方式。以下是一个演示此点的示例：'
- en: '[PRE91]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The Object.assign(targetObj, sourceObjs…) method
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Object.assign(targetObj, sourceObjs...)`方法'
- en: The `Object.assign()` method is used is used to copy the values of all enumerable
    own properties from one or more source objects to a target object. This method
    will return the `targetObj.`
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign()`方法用于将一个或多个源对象的所有可枚举自有属性的值复制到目标对象。此方法将返回`targetObj`。'
- en: 'Here is an example which demonstrates this:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个演示此点的示例：
- en: '[PRE92]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Output is:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE93]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Here is a list of important things to keep in mind while using the `Object.assign()`
    method:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`Object.assign()`方法时，以下是一些需要记住的重要事项：
- en: It invokes getters on the sources and setters on the target.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在来源上调用getter，在目标上调用setter。
- en: It just assigns values of the properties of source to the new or existing properties
    of target.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只是将源属性的值分配给目标的新或现有属性。
- en: It doesn't copy the `[[prototype]]` property of sources.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会复制来源的`[[prototype]]`属性。
- en: JavaScript property names can be strings or symbols. `Object.assign()` copies
    both.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 属性名可以是字符串或符号。`Object.assign()` 会复制两者。
- en: Property definitions are not copied from sources therefore you need to use `Object.getOwnPropertyDescriptor()Object.defineProperty()`
    instead.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性定义不会从源中复制，因此你需要使用 `Object.getOwnPropertyDescriptor()` 和 `Object.defineProperty()`。
- en: It ignores copying keys with `null` and `undefined` values.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会忽略带有 `null` 和 `undefined` 值的键的复制。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned new features added by ES6 for working with numbers,
    strings, arrays and objects. We saw how arrays impact performance in math-rich
    applications and how the array buffers can be used instead. We also walked through
    the new collection objects provided by ES6.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 ES6 为处理数字、字符串、数组和对象添加的新特性。我们看到了数组如何在数学密集型应用中影响性能，以及如何使用数组缓冲区来替代。我们还了解了
    ES6 提供的新集合对象。
- en: In next chapter, we will learn about Symbols and Iteration protocol, and we
    will discover `yield` keyword and generators also.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习关于符号和迭代协议的内容，并且我们会发现 `yield` 关键字和生成器。
