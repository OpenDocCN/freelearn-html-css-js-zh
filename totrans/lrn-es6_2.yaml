- en: Chapter 2. Knowing Your Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ES6** has added lots of new properties and methods to built-in JavaScript
    objects, so that the programmer can do cumbersome tasks easily. These new functionalities
    aim to help the developers get rid of using hacks and error-prone techniques to
    do various operations related to numbers, strings, and arrays. In this chapter,
    we will look at all the new functionalities added by ES6 to the native objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The new properties and methods of the `Number` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing the numeric constants as binary or octal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new properties and methods of the `Math` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the multiline strings and the new methods of the `String` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new properties and methods of `Array` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Maps and Sets?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using array buffers and typed arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new properties and methods of `Object` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 adds new ways of creating numbers and new properties to the `Number` object
    to make working with numbers easier. The `Number` object was enhanced in ES6 to
    make it easier to create mathematically rich applications, and prevent the common
    misconceptions that caused the errors. ES6 also provides new ways to do things
    that were already possible in ES5, such as representing the numeric constants
    as octal.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JavaScript represents the numbers as base 10 decimals. The numeric constants
    are, by default, interpreted as base 10 decimals.
  prefs: []
  type: TYPE_NORMAL
- en: The binary notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ES5, there was no native way to represent the numeric constants as binary.
    But in ES6, you can prefix the numeric constants using the `0b` token to make
    JavaScript interpret them as binary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, `0b00001111` is a binary representation of 15, base 10 decimal.
  prefs: []
  type: TYPE_NORMAL
- en: The octal notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ES5, to represent a numeric constant as octal, we needed to prefix the numeric
    constant using `0`. For example, take a look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: But often, programmers new to JavaScript, get confused with the octal representations
    as the decimal number with `0` at the front. For example, they think `017` is
    same as `17`. Therefore, to remove this confusion, ES6 lets us prefix the numeric
    constants using `0o` to make JavaScript interpret them as octal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The Number.isInteger(number) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript numbers are stored as the 64-bit, floating-point numbers. So the
    integers in JavaScript are the floating-point numbers without a decimal fraction,
    or a decimal fraction with all 0's.
  prefs: []
  type: TYPE_NORMAL
- en: In ES5, there was no built-in way to check whether a number is an integer or
    not. ES6 adds a new method to the `Number` object called as `isInteger()`, which
    takes a number and returns `true` or `false,` depending on weather the number
    is an integer or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Number.isNaN(value) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ES5, there was no way to check whether a variable holds the `NaN` value or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The global `isNaN()` function is used to check whether a value is a number or
    not. If the value is not a number, then it returns `true`, otherwise it returns
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So ES6 introduced a new method for the `Number` object called as `isNaN()`
    to check whether a value is `NaN` or not. Here is an example, which demonstrates
    `Number.isNaN()` and also explains how it is different from the global `isNaN()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that `Number.isNaN()` method returns `true` only if the passed
    value is exactly `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might ask, why not use `==` or the `===` operator instead of the `Number.isNaN(value)`
    method? The `NaN` value is the only value that is not equal to itself, that is,
    the expression `NaN==NaN` or `NaN===NaN` will return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The Number.isFinite(number) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In ES5 there was no built-in way to check whether a value is a finite number.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The global `isFinite()` function takes a value and checks whether it's a finite
    number or not. But unfortunately, it also returns `true` for values that convert
    to a `Number` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So ES6 introduced the `Number.isFinite()` method, which resolves the issue
    of the `window.isFinite()` function. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Number.isSafeInteger(number) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JavaScript numbers are stored as 64-bit floating-point numbers, following
    the international IEEE 754 standard. This format stores numbers in 64 bits, where
    the number (the fraction) is stored in 0 to 51 bits, the exponent in 52 to 62
    bits, and the sign in the last bit.
  prefs: []
  type: TYPE_NORMAL
- en: So in JavaScript, safe integers are those numbers that are not needed to be
    rounded to some other integer to fit in the IEEE 754 representation. Mathematically,
    the numbers from -(2^(53)-1) to (2^(53)-1) are considered as safe integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Number.MAX_SAFE_INTEGER` and `Number.MIN_SAFE_INTEGER` are constant values,
    introduced in ES6, representing (2^(53)-1) and -(2^(53)-1) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The Number.EPSILON property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript uses such binary floating-point representation that the computers
    fail to accurately represent, numbers like 0.1, 0.2, 0.3, and so on. When your
    code is executed, numbers like 0.1 are rounded to the nearest number in that format,
    which results in small rounding error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Number.EPSILON` property was introduced in ES6, which has a value of approximately
    2^(-52). This value represents a reasonable margin of error when comparing the
    floating-point numbers. Using this number, we can create a custom function to
    compare the floating-point numbers by ignoring the minimal rounding errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Here, `epsilonEqual()` is the custom function that we build to compare whether
    the two values are equal or not. Now, the output is as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about this behavior of JavaScript and the floating-point arithmetic,
    visit [http://floating-point-gui.de/](http://floating-point-gui.de/).
  prefs: []
  type: TYPE_NORMAL
- en: Doing Math
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 adds a lot of new methods to the `Math` object, related to trigonometry,
    arithmetic, and miscellaneous. This lets the developers use native methods instead
    of external math libraries. Native methods are optimized for performance, and
    have better decimal precision.
  prefs: []
  type: TYPE_NORMAL
- en: Trigonometry related operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example code, which shows the entire trigonometry-related methods
    that are added to the `Math` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic related operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is an example code, which shows the entire arithmetic related methods
    added to the `Math` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Miscellaneous methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ES6 adds some miscellaneous methods to the `Math` object. These methods are
    used for conversion and extracting information from the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: The Math.imul(number1, number2) function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Math.imul()` takes two numbers as 32-bit integers and multiplies them.
    It returns the lower 32 bits of the result. This is the only native way to do
    32-bit integer multiplication in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here when multiplication was done it produced a number so large it couldn't
    be stored in 32 bits, therefore the lower bits were lost.
  prefs: []
  type: TYPE_NORMAL
- en: The Math.clz32(number) function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Math.clz32()` function returns the number of leading zero bits in the 32-bit
    representation of a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Math.sign(number) function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Math.sign()` function returns the sign of a number, indicating weather
    the number is negative, positive or zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: From the preceding code, we can see that the `Math.sign()` function returns
    `1` if the number is positive, `-1` if the number is negative, and `0` if the
    number is zero.
  prefs: []
  type: TYPE_NORMAL
- en: The Math.trunc(number) function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Math.trunc()` function returns the integer part of a number by removing
    any fractional digit. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The Math.fround(number) function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Math.fround()` function rounds a number to a 32-bit floating point value.
    Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Working with strings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 provides new ways of creating strings and adds new properties to global
    String object and to its instances to make working with strings easier. Strings
    in JavaScript lacked features and capabilities when compared with programming
    languages such as Python and **Ruby** therefore ES6 enhanced strings to change
    that.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get into new string features lets revise JavaScript's internal character
    encoding and escape sequences. In the Unicode character set every character is
    represented by a base 10 decimal number called a **code point**. A **code unit**
    is a fixed number of bits in memory to store a code point. An encoding schema
    determines the length of code unit. A code unit is 8 bits if the **UTF-8** encoding
    schema is used or 16 bits if the **UTF-16** encoding schema is used. If a code
    point doesn't fit in a code unit it is spilt into multiple code units, that is,
    multiple characters in sequence representing a single character.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript interpreters by default interpret JavaScript source code as sequence
    of UTF-16 code units. If source code is written in the UTF-8 encoding schema then
    there are various ways to tell the JavaScript interpreter to interpret it as sequence
    of UTF-8 code units. JavaScript strings are always a sequence of UTF-16 code points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any Unicode character with a code point less than 65536 can be escaped in a
    JavaScript string or source code using the hexadecimal value of its code point,
    prefixed with `\u`. Escapes are six characters long. They require exactly four
    characters following `\u`. If the hexadecimal character code is only one, two
    or three characters long, you''ll need to pad it with leading zeroes. Here is
    an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Escaping larger code points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In ES5, for escaping a character that requires more than 16 bits for storing,
    we needed two Unicode escapes. For example, to add `\u1F691` to a string we had
    to escape it this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here `\uD83D` and `\uDE91` are called **surrogate pairs**. A surrogate pair
    is two Unicode characters when written in sequence represent another character.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES6 we can write it without surrogate pairs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: A string stores `\u1F691` as `\uD83D\uDE91`, so length of the above string is
    still `2`
  prefs: []
  type: TYPE_NORMAL
- en: The codePointAt(index) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `codePointAt()` method of a string returns a non-negative integer that is
    the code point of the character at the given index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The String.fromCodePoint(number1, …, number 2) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fromCodePoint()` method of `String` object takes a sequence of code points
    and returns a string. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The repeat(count) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `repeat()` method of a string, constructs and returns a new string which
    contains the specified number of copies on which it was called, concatenated together.
    Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The includes(string, index) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `includes()` method is used to find whether one string may be found in
    another string, returning `true` or `false` as appropriate. Here is an example
    to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The startsWith(string, index) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `startsWith()` method is used to find whether a string begins with the
    characters of another string, returning `true` or `false` as appropriate. Here
    is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes an optional second parameter representing the position in the string
    at which to begin searching. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The endsWith(string, index) function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `endsWith()` method is used to find whether a string ends with the characters
    of another string, returning true or false as appropriate. It also takes an optional
    second parameter representing the position in the string that is assumed as the
    end of the string. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Normalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Normalization** is simply the process of searching and standardizing code
    points without changing the meaning of the string.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also different forms of normalization: NFC, NFD, NFKC and NFKD.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand Unicode string normalization by an example use case:'
  prefs: []
  type: TYPE_NORMAL
- en: A case study
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many Unicode characters that can be stored in 16 bits and can also
    be represented using a surrogate pair. For example, ''`é`'' character can be escaped
    two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is when applying the `==` operator, iterating or finding length
    you will get an unexpected result. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here both the strings display the same way but when we do various string operations
    on them we get different results.
  prefs: []
  type: TYPE_NORMAL
- en: The length property ignores surrogate pairs and assumes every 16-bit to be single
    character. The `==` operator matches the binary bits therefore it also ignores
    surrogate pairs. The `[]` operator also assumes every 16-bit to be an index therefore
    ignoring surrogate pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case to solve the problems we need to convert the surrogate pairs to
    16-bit character representation. This process is called as **normalization**.
    To do this ES6 provides a `normalize()` function. Here is an example to demonstrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here the output is as expected. `normalize()` returns the normalized version
    of the string. `normalize()` uses NFC form by default.
  prefs: []
  type: TYPE_NORMAL
- en: Normalization is not just done in the case of surrogate pairs; there are many
    other cases.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Normalized version of a string is not made for displaying to the user; it's
    used for comparing and searching in strings.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Unicode string normalization and normalization forms visit
    [http://www.unicode.org/reports/tr15/](http://www.unicode.org/reports/tr15/).
  prefs: []
  type: TYPE_NORMAL
- en: Template strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template strings is just a new literal for creating strings that makes various
    things easier. They provide features such as embedded expressions, multi-line
    strings, string interpolation, string formatting, string tagging, and so on. They
    are always processed and converted to a normal JavaScript string on runtime therefore
    they can be used wherever we use normal strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Template strings are written using back ticks instead of single or double quotes.
    Here is an example of a simple template string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In ES5, to embed expressions within normal strings you would do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In ES6, template strings make it much easier to embed expressions in strings.
    Template strings can contain expressions in them. The expressions are placed in
    placeholders indicated by dollar sign and curly brackets, that is, `${expressions}`.
    The resolved value of expressions in the placeholders and the text between them
    are passed to a function for resolving the template string to a normal string.
    The default function just concatenates the parts into a single string. If we use
    a custom function to process the string parts then the template string is called
    as a **tagged template string** and the custom function is called as **tag function**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example which shows how to embed expressions in a template strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a tagged template string, that is, process the string using a
    tag function. Let''s implement the tag function to do the same thing as the default
    function. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Here our tag function's name is `tag` but you can name it anything else. The
    custom function takes two parameters, that is, the first parameter is an array
    of string literals of the template string and the second parameter is an array
    of resolved values of the expressions. The second parameter is passed as multiple
    arguments therefore we use the rest argument.
  prefs: []
  type: TYPE_NORMAL
- en: Multiline strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Template strings provide a new way to create strings that contain multiple lines
    of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'In ES5, we need to use `\n` new line character to add new line breaks. Here
    is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'In ES6, using **multiline** string we can simply write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the above code we simply included new lines where we needed to place `\n`.
    While converting the template string to normal string the new lines are converted
    to `\n`.
  prefs: []
  type: TYPE_NORMAL
- en: Raw strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A raw string is a normal string in which escaped characters aren't interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a raw string using a template string. We can get raw version
    of a template string use `String.raw` tag function. Here is an example to demonstrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here `\n` is not interpreted as new line character instead of its two characters,
    that is, `\` and `n`. Length of variable `s` would be `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create a tagged function and you want to return the raw string then
    use `raw` property of the first argument. `raw` property is an array, which holds
    raw versions of the strings of the first argument. Here is an example to demonstrate
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 adds new properties to the global Array object and to its instances to make
    working with arrays easier. Arrays in JavaScript lacked features and capabilities
    when compared with programming languages such as Python and Ruby therefore ES6
    enhanced arrays to change that.
  prefs: []
  type: TYPE_NORMAL
- en: The Array.from(iterable, mapFunc, this) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Array.from()` method creates a new array instance from an iterable object.
    The first argument is a reference to the iterable object. The second argument
    is optional and is a callback (known as **Map function**) that is called for every
    element of the iterable object. The third argument is also optional and is the
    value of `this` inside the Map function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The Array.of(values…) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Array.of()` method is an alternative to the `Array` constructor for creating
    arrays. When using `Array` constructor if we pass only one argument, that too
    a number, then `Array` constructor constructs an empty array with array `length`
    property equal to the passed number instead of creating an array of one element
    with that number in it. Therefore the `Array.of()` method was introduced to resolve
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: You should use `Array.of()` instead of `Array` constructor when you are constructing
    a new array instance dynamically, that is, when you don't know the type of values
    and the number of elements.
  prefs: []
  type: TYPE_NORMAL
- en: The fill(value, startIndex, endIndex) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fill()` method of an array fills all the elements of the array from the
    `startIndex` to an `endIndex` (not including `endIndex`) with a given value. Remember
    that `startIndex` and `endIndex` arguments are optional; therefore if they are
    not provided then the whole array is filled with the given value. If only `startIndex`
    is provided then `endIndex` defaults to length of array minus 1.
  prefs: []
  type: TYPE_NORMAL
- en: If `startIndex` is negative then it's treated as length of array plus `startIndex`.
    If `endIndex` is negative, it is treated as length of array plus `endIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The find(testingFunc, this) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `find()` method of an array returns an array element, if it satisfies the
    provided testing function. Otherwise it returns `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: The `find()` method takes two arguments, that is, the first argument is the
    testing function and the second argument is the value of `this` in the testing
    function. The second argument is optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'The testing function has three parameters: the first parameter is the array
    element being processed, second parameter is the index of the current element
    being processed and third parameter is the array on which `find()` is called upon.'
  prefs: []
  type: TYPE_NORMAL
- en: The testing function needs to return `true` to satisfy a value. The `find()`
    method returns the first element which satisfies the provided testing function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate the `find()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The findIndex(testingFunc, this) method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `findIndex()` method is similar to the `find()` method. The `findIndex()`
    method returns the index of the satisfied array element instead of the element
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The copyWithin(targetIndex, startIndex, endIndex) function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `copyWithin()` method of an array is used to copy the sequence of values
    of the array to a different position in the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copyWithin()` method takes three arguments: first argument represents
    the target index where to copy elements to, second argument represents the index
    position where to start copying from and the third argument represents the index
    , that is, where to actually end copying elements.'
  prefs: []
  type: TYPE_NORMAL
- en: The third argument is optional and if not provided then it defaults to `length-1`
    where `length` is the length of the array. If `startIndex` is negative then it's
    calculated as `length+startIndex`. Similarly if `endIndex` is negative then it's
    calculated as `length+endIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The entries(), keys(), and values() method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `entries()` method of an array returns an iterable object that contains
    key/value pairs for each index of the array. Similarly the `keys()` method of
    an array returns an iterable object that contains keys for each of the indexes
    in the array. Similarly, the `values()` method of an array returns an iterable
    object that contains values of the array.
  prefs: []
  type: TYPE_NORMAL
- en: The iterable object returned by the `entries()` method stores the key/value
    pairs in the form of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The iterable object returned by these functions is not an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A collection is any object that stores multiple elements as a single unit. ES6
    introduced various new collection objects to provide better ways of storing and
    organizing data.
  prefs: []
  type: TYPE_NORMAL
- en: The array is the only collection object available in ES5\. ES6 introduces array
    buffers, typed arrays, Sets, and Maps, which are built in collection objects.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see the different collection objects provided by ES6.
  prefs: []
  type: TYPE_NORMAL
- en: Array buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Elements of arrays can be of any type such as strings, numbers, objects, and
    so on. Arrays can grow dynamically. The problem with arrays is that they are slow
    in terms of execution time, and occupy more memory. This causes issues while developing
    applications that require too much computation and deal with large amount of numbers.
    Therefore array buffers were introduced to tackle this issue.
  prefs: []
  type: TYPE_NORMAL
- en: An array buffer is a collection of 8-bit blocks in memory. Every block is an
    array buffer element. The size of an array buffer needs to be decided while creating,
    it therefore it cannot grow dynamically. Array buffers can only store numbers.
    All blocks are initialized to number 0 on creation of an array buffer.
  prefs: []
  type: TYPE_NORMAL
- en: An array buffer object is created using `ArrayBuffer` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Reading from and writing values into an array buffer object can be done using
    a DateView object. It''s not compulsory that only 8 bits are used to represent
    a number. We can use 8, 16, 32 and 64 bits to represent a number. Here is an example,
    which shows how to create a DateView object and read/write to an `ArrayBuffer`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Here we created a DataView object using `DataView` constructor. A DataView object
    provides several methods to read and write numbers into an array buffer `object`.
    Here we used `setInt32()` method which uses 32 bits to store a provided number.
  prefs: []
  type: TYPE_NORMAL
- en: All the methods of a DataView object that are used to write data to an array
    buffer object take three arguments. First argument represents the offset, that
    is, the byte we want to write the number to. Second argument is the number to
    be stored. And third argument is a Boolean type, which represents the endian of
    the number, such as `false` represents a big-endian.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly all the methods of a DataView object that are used to read data of
    an array buffer object take two arguments. First argument is the offset and second
    argument represents the endian used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are other functions for storing numbers provided by a DataView object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**setInt8**: Uses 8 bits to store a number. It takes a signed integer (-ve
    or +ve).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setUint8**: Uses 8 bits to store a number. It takes an unsigned integer (+ve).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setInt16**: Uses 16 bits to store a number. It takes a signed integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setUint16**: Uses 16 bits to store a number. It takes an unsigned integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setInt32**: Uses 32 bits to store a number. It takes a signed integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setUint32**: Uses 32 bits to store a number. It takes an unsigned integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setFloat32**: Uses 32 bits to store a number. It takes a signed decimal number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**setFloat64**: Uses 64 bits to store a number. It takes a signed decimal number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are other functions for retrieving stored numbers by a DataView object:'
  prefs: []
  type: TYPE_NORMAL
- en: '**getInt8**: Reads 8 bits. Returns signed integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getUint8**: Reads 8 bits. Returns unsigned integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getInt16**: Reads 16 bits. Returns signed integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getUint16**: Reads 16 bits. Returns unsigned integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getInt32**: Reads 32 bits. Returns signed integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getUint32**: Reads 32 bits. Returns unsigned integer number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getFloat32**: Reads 32 bits. Returns signed decimal number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**getFloat64**: Reads 64 bits. Returns signed decimal number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw how to read and write numbers in array buffers. But the method was very
    cumbersome because we had to call a function every time. **Typed arrays** let
    us read and write to an array buffer object just like we do for normal arrays.
  prefs: []
  type: TYPE_NORMAL
- en: A typed array acts like a wrapper for an array buffer object and treats data
    of an array buffer object as a sequence of *n*-bit numbers. The `n` value depends
    on how we created the typed array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code example that demonstrates how to create an array buffer object
    and read/write to it using a typed array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Here we created typed array using the `Float64Array` constructor, it therefore
    treats data in the array buffer as a sequence of 64-bit signed decimal numbers.
    Here the array buffer object size was 640 bits therefore only 10 64-bit numbers
    can be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, there are other typed array constructors to represent data in an
    array buffer as a sequence of different bit numbers. Here is the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Int8Array**: Treats as 8-bit signed integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint8Array**: Treats as 8-bit unsigned integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int16Array**: Treats as 16-bit signed integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint16Array**: Treats as 16-bit unsigned integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Int32Array**: Treats as 32-bit signed integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Uint32Array**: Treats as 32-bit unsigned integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float32Array**: Treats as 32-bit signed decimal number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Float64Array**: Treats as 64-bit signed decimal number'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typed arrays provide all the methods that are also provided by normal JavaScript
    arrays. They also implement the iterable protocol therefore they can be used as
    an iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **Set** is a collection of *unique* values of any data type. The values in
    a Set are arranged in insertion order. A Set is created using `Set` constructor.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Here `set1` is an empty Set. Whereas `set2` was created using values of an iterable
    object, that is, characters of a string and the string was not empty therefore
    `set2` is non-empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is example code, which demonstrates various operations that can be done
    on a Set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Here we added nine items to the `set` object but the `size` was only six because
    Set automatically deletes duplicate values. The characters `l`and `!`were repeated
    multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: The Set object also implements the iterable protocol so they can be used as
    an iterable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets are used when you want to maintain a collection of values and check if
    a value exists instead of retrieving a value. For example: Sets can be used as
    an alternative to an array if you only use the `indexOf()` method of the array
    in your code to check if an value exists.'
  prefs: []
  type: TYPE_NORMAL
- en: WeakSet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the differences between Set and WeakSet objects:'
  prefs: []
  type: TYPE_NORMAL
- en: A Set can store primitive types and object references whereas a WeakSet object
    can only store object references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the important features of the WeakSet object is that if there is no other
    reference to an object stored in a WeakSet object then they are garbage collected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly a WeakSet object is not enumerable, that is, you cannot find its size;
    it also doesn't implement iterable protocol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these three differences it behaves exactly the same way as a Set`.`
    Everything else apart from these three differences is same between a Set and WeakSet
    object.
  prefs: []
  type: TYPE_NORMAL
- en: A WeakSet object is created using `WeakSet` constructor. You cannot pass an
    iterable object as an argument to WeakSet object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate WeakSet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Map
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Map is a collection of key/value pairs. Keys and values of a Map can be of
    any data type. The key/value pairs are arranged in the insertion order. A Map
    object is created using the `Map` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example, which demonstrates how to create a Map object and do various
    operations on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: While creating a Map object from an iterable object we need to make sure that
    the values returned by the iterable object are arrays, each of length `2` i.e.,
    index 0 is the key and index 1 is the value.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to add a key that already exists then it's overwritten. The Map objects
    also implement the iterable protocol and can therefore also be used as an iterable
    object. While iterating Maps using the iterable protocol, they return arrays with
    key/value pairs as you can see in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: WeakMap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are the differences between the Map and the WeakMap objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Keys of a Map object can be of primitive types or object references but keys
    in WeakMap object can only be object references
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the important features of the WeakMap object is that if there is no other
    reference to an object that is referenced by a key then the key is garbage collected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lastly the WeakMap object is not enumerable, that is, you cannot find its size
    and it doesn't implement iterable protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Everything else, apart from these three differences is similar between the Map
    and the WeakMap object.
  prefs: []
  type: TYPE_NORMAL
- en: 'A WeakMap is created using `WeakMap` constructor. Here is an example that demonstrates
    its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ES6 standardizes the `__proto__` property of an object and adds new properties
    to the global `Object` object.
  prefs: []
  type: TYPE_NORMAL
- en: The __proto__ property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript objects have an internal `[[prototype]]` property that references
    the object's prototype, that is, the object it inherits. To read the property
    we had to use `Object.getPrototypeof()` and to create a new object with a given
    prototype we had to use the `Object.create()` method. A `[[prototype]]` property
    cannot be directly read or be modified.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting was cumbersome due to the nature of the `[[prototype]]` property,
    therefore some browsers added a special `__proto__` property in objects, which
    is an accessor property that exposes the internal `[[prototype]]` property and
    makes working with prototypes easier. The `__proto__` property was not standardized
    in ES5 but due to its popularity it was standardized in ES6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The Object.is(value1, value2) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Object.is()` method determines whether two values are equal or not. It
    is similar to the `===` operator but there are some special cases for the `Object.is()`
    method. Here is an example that demonstrates the special cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The Object.setPrototypeOf(object, prototype) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Object.setPrototypeOf()` method is just an another way to assign the `[[prototype]]`
    property of an object. Here is an example to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: The Object.assign(targetObj, sourceObjs…) method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Object.assign()` method is used is used to copy the values of all enumerable
    own properties from one or more source objects to a target object. This method
    will return the `targetObj.`
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example which demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a list of important things to keep in mind while using the `Object.assign()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: It invokes getters on the sources and setters on the target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It just assigns values of the properties of source to the new or existing properties
    of target.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn't copy the `[[prototype]]` property of sources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript property names can be strings or symbols. `Object.assign()` copies
    both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Property definitions are not copied from sources therefore you need to use `Object.getOwnPropertyDescriptor()Object.defineProperty()`
    instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It ignores copying keys with `null` and `undefined` values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we learned new features added by ES6 for working with numbers,
    strings, arrays and objects. We saw how arrays impact performance in math-rich
    applications and how the array buffers can be used instead. We also walked through
    the new collection objects provided by ES6.
  prefs: []
  type: TYPE_NORMAL
- en: In next chapter, we will learn about Symbols and Iteration protocol, and we
    will discover `yield` keyword and generators also.
  prefs: []
  type: TYPE_NORMAL
