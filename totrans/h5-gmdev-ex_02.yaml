- en: Chapter 2. Getting Started with DOM-based Game Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*We''ve got an idea about what we are going to learn in the whole book in [Chapter
    1](ch01.html "Chapter 1. Introducing HTML5 Games"), *Introducing HTML5 Games*.
    From this chapter onwards, we will go through a lot of learning-by-doing sections,
    and we will focus on one topic in each section. Before digging deeply into the
    cutting-edge CSS3 animations and HTML5 Canvas game, let''s start with traditional
    DOM-based game development. We will warm up with some basic techniques in this
    chapter.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our first game—Ping Pong
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning basic positioning with the jQuery JavaScript library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting mouse inputs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Ping Pong game that displays the scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning to separate data and view rendering logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create a Ping Pong game that a player plays against the computer via
    mouse input. You can try the game at [http://makzan.net/html5-games/pingpong/](http://makzan.net/html5-games/pingpong/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the look of the game at the end of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting Started with DOM-based Game Development](img/B04290_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, let's get on with making our Ping Pong game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing the book, the jQuery version is 2.1.3\. The jQuery functions
    that we used in the examples are basic functions that should work in future versions
    too.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the HTML documents for a DOM-based game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every website, web page, and HTML5 game starts with a default HTML document.
    Moreover, the document starts with a basic HTML code. We will start our HTML5
    game development journey with `index.html`.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – installing the jQuery library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will create our HTML5 Ping Pong game from scratch. It may sound as if we
    are going to be preparing all the things ourselves. Luckily, we can use a JavaScript
    library to help us. **jQuery** is the **JavaScript library** that is designed
    to navigate the DOM elements easily, manipulate them, handle events, and create
    an asynchronous remote call. We will be using this library in the book to manipulate
    DOM elements. It will help us to simplify our JavaScript logic:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder named `pingpong` as our project directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the `pingpong` folder, we will create the following file structure,
    with three folders—`js`, `css`, and `images`—and an `index.html` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, it's time to download the jQuery library. Go to [http://jquery.com/](http://jquery.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Download jQuery** and click on **Download the compressed, production
    jQuery 2.1.3**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save `jquery-2.1.3.min.js` within the `js` folder that we created in step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `index.html` in text editor and insert an empty HTML template:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we have to ensure that jQuery is loaded successfully. To do this,
    place the following code into the `js/pingpong.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the `index.html` file and open it in the browser. You should see the following
    alert window showing our text. This means that our jQuery is correctly set up:![Time
    for action – installing the jQuery library](img/B04290_02_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a basic HTML5 page with jQuery and ensured that the jQuery is
    loaded correctly.
  prefs: []
  type: TYPE_NORMAL
- en: New HTML5 doctype
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `DOCTYPE` and `meta` tags are simplified in HTML5.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTML 4.01, we declare doctype using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a long line of code, right? While in HTML5, the doctype declaration
    couldn''t have been more simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We do not even have the HTML version in the declaration. This is because HTML5
    is now a living standard without a version number.
  prefs: []
  type: TYPE_NORMAL
- en: Header and footer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HTML5 comes with many new features and improvements, and one of them is semantics.
    HTML5 adds new elements to improve **semantics**. We just used two of the elements:
    `header` and `footer`. **Header** gives an introduction to the section or the
    entire page. Therefore, we put the `h1` title inside the header. **Footer**, like
    the name suggests, contains the footer information of the section or the page.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A semantic HTML means that the markup itself provides meaningful information
    to the content instead of only defining the visual outlook.
  prefs: []
  type: TYPE_NORMAL
- en: The best practice to place the JavaScript code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We put the JavaScript code right before the closing `</body>` tag and after
    all the content in the page. There is a reason for putting the code there instead
    of putting it inside the `<head></head>` section.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, browsers load content and render them from top to bottom. If the JavaScript
    code is put in the `head` section, then the content of the document will not be
    loaded until all the JavaScript code is loaded. Actually, all rendering and loading
    will be paused if the browsers load a JavaScript code in the middle of the page.
    This is the reason why we want to put the JavaScript code at the bottom, when
    possible. In this way, we can deliver the HTML content to our readers faster.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, the latest jQuery version is 2.1.3\. This
    is why the jQuery file in our code examples is named `jquery-2.1.3.min.js`. The
    version number in the filename ensures that web developers don't get confused
    with different versions of the same filename in different projects. This version
    number will be different, but the usage should be the same, unless there is a
    big change in jQuery without backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that a few JavaScript libraries have to put the `<head>` tag before
    loading any HTML elements. When you're using third-party libraries, please check
    whether they have such a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the jQuery file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the jQuery library, there are currently two major versions; they are **1.x**
    and **2.x**. The 1.x version keeps backward compatibility to older browsers, mainly
    for IE versions 6, 7, and 8\. Since our HTML5 games target modern browsers, we
    chose the 2.x version that has dropped support to IE 8 or the older versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two common ways to include the jQuery library. We can either download
    a **hosted** version or use the **CDN** version. Hosted version means that we
    download the file, and we host the file ourselves. CDN stands for Content Delivery
    Network. The jQuery files are hosted in several central servers to improve the
    file downloading time. For the CDN version, we can find the URL at [http://code.jquery.com](http://code.jquery.com).
    We can directly include the file with the `<script>` tag in HTML as: `<script
    src="img/jquery.min.js"></script>`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise, we can specify the version number in the filename as: `<script src="img/jquery-2.1.3.min.js"></script>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Running jQuery inside a scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to ensure that the page is ready before our JavaScript code is executed.
    Otherwise, we may get an error when we try to access an element that is not yet
    loaded. jQuery provides us with a way to execute the code after the page is ready
    by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of the time, we uses a `$` sign to represent jQuery. This is a shortcut
    that makes calling our jQuery functions much easier. So essentially, we use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When we call `$(something)`, we are actually calling `jQuery(something)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There may be conflicts on the `$` variables if we use multiple JavaScript libraries
    in one project. For best practice, we use an **anonymous function** to pass the
    jQuery object into the function scope where it becomes a `$` sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: An anonymous function is a function definition that has no name. That's why
    it's called anonymous. Since we cannot refer to this function anymore, the anonymous
    function always executes itself. JavaScript's variable scope is bound to the function
    scope. We often use anonymous function to control certain variables' availability.
    For instance, we passed the jQuery into the function as the `$` variable in our
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Running our code after the page is ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`$(function_callback)` is another shortcut for the DOM elements'' `ready` event.
    The reason we need jQuery `ready` function is to prevent the execution of JavaScript
    logic before the HTML DOM elements are loaded. Our function that is defined in
    the jQuery `ready` function is executed after all the HTML elements are loaded.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is identical to the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the jQuery `ready` event fires after the HTML structure (DOM tree)
    is loaded. However, this does not mean that the content, such as the actual image
    content, is loaded. The browser's `onload` event, on the other hands, fires after
    all the content including the images are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Which is the best place to put JavaScript code?
  prefs: []
  type: TYPE_NORMAL
- en: Before the `<head>` tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `<head></head>` elements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right after the `<body>` tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right before the `</body>` tag
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Downloading the image assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need some graphic files in this step. You can download the graphic files
    in the code bundle or from [http://mak.la/book-assets/](http://mak.la/book-assets/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the assets bundle, you will find image files for `Chapter 2`. After downloading
    them, put the files in the `images` folder. There should be four files, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Downloading the image assets](img/B04290_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Setting up the Ping Pong game elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made the preparations, and now it's time to set up the Ping Pong game.
    The following graph shows how we place the game elements. The game element contains
    our playground and later the scoreboard. Inside the playground, we place two decorative
    elements, namely **paddle hand**, which acts as the handle of the soccer machine.
    Then, we have two **paddle** elements—one on the left and one on the right.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the Ping Pong game elements](img/B04290_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Time for action – placing Ping Pong game elements in the DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will continue from our jQuery installation example, and open the `index.html`
    file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we will create the following playground and `game` objects with DIV nodes
    in the body. There are two paddles and one ball inside the playground, and the
    playground is placed inside the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have the structure of the `game` object ready, and it is time to apply
    styles to them. We will add the following styles to the `pingpong.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will define the dimensions and positions of the two paddles by appending
    the following code inside the `pingpong.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will continue with the styles in the `pingpong.css` file and define `paddle-hands`,
    which is the decoration for the paddles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we are done with the CSS styles, let''s move to the `js/pingpong.js`
    file for JavaScript''s logic. We need a function to update the DOM elements of
    the paddles based on the position data. To do this, we will replace the current
    code with the following one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we will test the setup in a browser. Open the `index.html` file in a browser;
    we should see a screen similar to the one shown in the following screenshot:![Time
    for action – placing Ping Pong game elements in the DOM](img/B04290_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at the HTML code that we just used. The HTML page contains
    header, footer information, and a DIV element with the ID, `game`. The `game`
    node contains a child named `playground`, which in turn contains three children—two
    paddles and the ball.
  prefs: []
  type: TYPE_NORMAL
- en: We often start the HTML5 game development by preparing a well-structured HTML
    hierarchy. The HTML hierarchy helps us to group similar game objects (which are
    some DIV elements) together. It is a little like grouping assets into a movie
    clip in Adobe Flash, if you have ever made animations with it. We may also consider
    it as layers of game objects for us to select and style them easily.
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The jQuery command often contains two major parts: **selection** and **modification**.
    Selection uses CSS selector syntax to select all matched elements in the web page.
    Modification actions modify the selected elements, such as adding or removing
    children or style. Using jQuery often means chaining selection and modification
    actions together.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code selects all elements with the `box` class and
    sets the CSS properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Understanding basic jQuery selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'jQuery is about selecting elements and performing actions on them. We need
    a method to select our required elements in the entire DOM tree. jQuery borrows
    the selectors from CSS. The selector provides a set of patterns to match elements.
    The following table lists the most common and useful selectors that we will use
    in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Selector pattern | Meaning | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$("Element")` | Selects all elements with the given tag name | `$("p")`
    selects all the `p` tags.`$("body")` selects the `body` tag. |'
  prefs: []
  type: TYPE_TB
- en: '| `$("#id")` | Selects the element with the given ID of the attribute | Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`$("#box1")` selects the highlighted element. |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `$(".className")` | Selects all elements with the given class attribute |
    Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '`$(".apple")` selects the highlighted elements with `class` set to `apple`.
    |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `$("selector1, selector2, selectorN")` | Selects all elements that match
    the given selector | Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`$(".apple,` `.orange")` selects the highlighted elements that `class` is set
    to, either `apple` or `orange`. |'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the jQuery CSS function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The jQuery `css` function works to get and set the CSS properties of the selected
    elements. This is known as getting and setting pattern where many jQuery functions
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a general definition of how to use the `css` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `css` function accepts several types of arguments as listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function type | Arguments definitions | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `.css(propertyName)` | `propertyName` is a CSS property | The function returns
    the value of the given CSS property of the selected element.For example, the following
    code returns the value of the `background-color` property of the `body` element:`$("body").css("background-color")`It
    will only read the value and not modify the property value. |'
  prefs: []
  type: TYPE_TB
- en: '| `css(propertyName,` `value)` | `propertyName` is a CSS property, and `value`
    is a value to set for the property. | The function modifies the given CSS property
    to the given value.For example, the following code sets the background color of
    all elements with the `box` class to red:`$(".box").css("background-color","#ff0000")`
    |'
  prefs: []
  type: TYPE_TB
- en: Manipulating game elements in DOM with jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We initialized the paddles' game elements with jQuery. We will do an experiment
    on how we should use jQuery to place the game elements.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the behavior of absolute position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a DOM node is set to be at the `absolute` position, the left and top properties
    can be treated as a **coordinate**. We can treat the left/top properties into
    X/Y coordinates with Y positive pointing down. The following graphs show the relationship.
    The left side is the actual CSS value, and the right side is the coordinate system
    in our mind when programming the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the behavior of absolute position](img/B04290_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By default, the left and top properties refer to the top-left edge of the web
    page. This reference point is different when any parent of this DOM node has a
    `position` style set explicitly to `relative` or `absolute`. The reference point
    of the left and top properties becomes the top-left edge of that parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why we need to set the game with a relative position and all game elements
    inside it with an absolute position. The following code snippet from our example
    shows the position values of the elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Declaring global variables in a better way
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Global variables** are variables that can be accessed globally in the entire
    document. Any variable that is declared outside any function is a global variable.
    For instance, in the following example code snippet, `a` and `b` are global variables,
    while `c` is a **local variable** that only exists inside the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since global variables are available in the entire document, they may increase
    the chance of variable name conflicts if we integrate different JavaScript libraries
    into the same web page. As good practice, we should minimize the use of global
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding *Time for action* section, we have an object to store the game
    data. Instead of just putting this object in the global scope, we created an object
    named `pingpong` and put the data inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, when we put all our logic into a self-executing function, as we discussed
    in the last section, we make the game's data object locally inside the function
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Declaring variables without `var` puts the variables in the global scope even
    when they are defined inside a function scope. So, we always declare variables
    with `var`.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. Which jQuery selector is to be used if you want to select all header elements?
  prefs: []
  type: TYPE_NORMAL
- en: '`$("#header")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$(".header")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$("header")`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`$(header)`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting mouse input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned how to display game objects with CSS and jQuery in the previous
    sections. The next thing we need to create in the game is a way to get input from
    the players. We will discuss about the mouse input in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – moving DOM objects by mouse input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a traditional Ping Pong game. There is a paddle on both
    the left and right sides of the playground. A ball is placed in the middle of
    the playground. Players can control the right paddle and move it up and down by
    using the mouse. We will focus on the mouse input and leave the ball movement
    for a later section:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our `pingpong` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add a `playground` object inside the `pingpong` data object in the `js/pingpong.js`
    file. This stores variables that are related to `playground`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create the following function that handles the mouse''s enter, move,
    and leave events, and place it inside the `js/pingpong.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We had the `renderPaddles` function in the previous section. In this section,
    we are defining a `render` function and calling the paddles rendering logic. We
    then call the `render` function on the next browser redraw via the `requestAnimationFrame`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we create an `init` function to execute the initial logic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, you need to call the `init` function that starts our game logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's test the `paddle` control of the game. Open the `index.html` page in the
    web browser. Try moving the mouse up and down within the playground area. The
    right paddle should follow your mouse's movement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We handled the mouse events to move the paddle based on the mouse position.
    You can play the current work-in-progress version of the game at [http://makzan.net/html5-games/pingpong-wip-step3/](http://makzan.net/html5-games/pingpong-wip-step3/).
  prefs: []
  type: TYPE_NORMAL
- en: Getting the mouse event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jQuery provides several handy mouse events, and the most basic ones are click,
    mouse down and mouse up. We track the mouse enter and mouse leave event to start
    and pause the game. We also use the mouse move event to get the mouse position
    and update the paddle position based on the mouse position on the playground section.
  prefs: []
  type: TYPE_NORMAL
- en: We need to get the *y* position of the cursor based on the playground's top
    left edge. The value of `Y` in the mouse event is the mouse cursor from the page's
    top left edge. We then subtract the position of the playground via `$("#playground").offset().top`.
  prefs: []
  type: TYPE_NORMAL
- en: We update the data of paddle's `Y` value by using the mouse's `X` and `Y` values.
    This value will eventually reflect on the screen when the paddle view is updated
    in the `render` function during the browser redraw.
  prefs: []
  type: TYPE_NORMAL
- en: RequestAnimationFrame
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The time interval is used to execute the game loop. The `game` loop calculates
    the game logic, which calculates the movement of the game objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `requestAnimationFrame` feature is used to update the view according to
    the data. We use the `requestAnimationFrame` feature to update the view because
    the view only needs to update in an optimal scenario, where the browser decides.
  prefs: []
  type: TYPE_NORMAL
- en: The interval of `requestAnimationFrame` is not fixed. When the browser is at
    the front end, the `requestAnimationFrame` feature would run often. When the battery
    is low or the browser is in the background, the browser would slow down the frequency
    of execution of the `requestAnimationFrame` feature.
  prefs: []
  type: TYPE_NORMAL
- en: We are using `RequestAnimationFrame` only on view-related logic. In a later
    section, we will need to handle game data calculation. For data calculation, we
    will use `setInterval` because the `setInterval` function always executes in a
    fixed time interval. That's why we use the `setInterval` function for the game
    logic calculation and animation frame for view rendering.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the console window
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are writing more complicated logic code now. It is good practice to keep
    an eye on the console of the **Developers Tools**. You may toggle between the
    developer tools by pressing *F12* in Windows or *command* + *option* + *I* on
    Mac OS. If the code contains any error or warning, the error message will appear
    there. It reports any found error and the line of code that contains the error.
    It is very useful and important to have the console window open when testing HTML5
    games. I have often seen people get stuck and have no idea as to why the code
    is not working. The reason for this is that they have a typo or syntax error,
    and they did not check the console window before fighting with the code for hours.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows that there is an error in the twenty-fifth line
    of the `js/pingpong.js` file. The error message is **Invalid left-hand side in
    assignment**. After inspecting the code, I found that I wrongly used an equal
    sign (`=`) when setting the CSS `top` property in jQuery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The error is displayed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking the console window](img/B04290_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Moving a DOM object with JavaScript Interval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine now we can make the little red ball move around the playground. The
    ball will bounce away when it hits the paddles. The player will win a score when
    the ball passes the opponent's paddle and hits the playground edge behind the
    paddle. All these actions manipulate the position of the DIVs inside the HTML
    page by jQuery. To complete this Ping Pong game, our next step is to move the
    ball.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – Moving the ball with JavaScript Interval
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the function to create a timer. The timer moves the ball a little
    bit every 30 milliseconds. We are going to also change the direction of the ball
    movement once it hits the playground edge. Let''s make the ball move now:'
  prefs: []
  type: TYPE_NORMAL
- en: We will use our last example, listening to multiple keyboard inputs, as the
    starting point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `js/pingpong.js` file in the text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the existing `pingpong.playground` object, we change to the following code
    that adds height and width to the playground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now moving the ball, and we need to store the ball''s status globally.
    We will put the ball-related variable inside the `pingpong` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define a `gameloop` function and move the ball on each game loop iteration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We define the functions to check whether the ball is hitting the four boundary
    walls of the playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we define two functions that reset the game after either player wins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is time to define the `moveBall` function. The function checks the boundaries
    of the playground, changes the direction of the ball when it hits the boundaries,
    and sets the new ball position after all these calculations. Let''s put the following
    `moveBall` function definition in the JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have calculated the ball's movement. Next, we want to render the view to
    update the ball's position based on the data. To do this, define a new `renderBall`
    function with the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to update the `render` function to render the ball''s update based
    on the updated game data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following lines of code is the new `init` function where we added a `gameloop`
    logic with the `setInterval` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have prepared the code to move the ball every 33.3 milliseconds. Save all
    the files and open `index.html` in the web browser to test it. The paddles work
    just as in the last example, and the ball should be moving around the playground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just successfully made the ball move around the playground. We have a loop
    to run routine game logic 30 times per second. Inside that game loop, we moved
    the ball five pixels at a time. You can try the game and view the code in progress
    at [http://makzan.net/html5-games/pingpong-wip-step6/](http://makzan.net/html5-games/pingpong-wip-step6/).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three properties of the ball: speed, and the *x* and *y* directions.
    Speed defines how many pixels the ball moves in each step. The direction X/Y is
    either 1 or -1\. We move the ball using the following equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The direction value is multiplied by the movement. When the direction is 1,
    the ball moves to the positive direction of the axis. When the direction is `-1`,
    the ball moves to the negative direction. By toggling the *x* and *y* directions,
    we can move the ball in four directions.
  prefs: []
  type: TYPE_NORMAL
- en: We compare the ball's `X` and `Y` values with the four edges of the playground
    DIV element. This checks whether the ball's next position is beyond the boundary,
    and then, we toggle the direction between 1 and -1 to create the bouncing effect.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a JavaScript timer with the setInterval function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a timer to loop and move the ball periodically. This can be done by
    the `setInterval` function in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the general definition of the `setInterval` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `setInterval` takes two required arguments. Additional arguments are passed
    into the function as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Definition | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `expression` | The function callback or code expression to be executed |
    The expression can be a reference of a function callback or an inline code expression.
    The inline code expression is quoted and a reference of function callback is not.For
    example, the following code calls the `hello` function every 100 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code calls the `hi` function with parameters every 100 milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `milliseconds` | The duration between every execution of the expression,
    in milliseconds | The unit of the interval is in milliseconds. Therefore, setting
    it to 1000 means running the expression every second. |'
  prefs: []
  type: TYPE_TB
- en: Understanding the game loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a timer to execute some game-related code every 33.3 milliseconds, so
    this code is executed 30 times per second. This frequency is known as frames per
    second, or FPS. In game development, this timer is called the **game loop**.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several common things that we will execute inside a game loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Processing user input, which we just did
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating game objects' status, including position and appearance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking game over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is actually executing in the game loop differs in different types of games,
    but the purpose is the same. The game loop is executed periodically to calculate
    the game data.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the data and the view logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have separated the data and the view logic. We used `setInterval` for data
    and `requestAnimationFrame` for view rendering. The data focuses on all the game
    data calculation, including an object's dimension and position based on the calculation.
    The `view` logic focuses on updating the interface based on the keep-updating
    game data.
  prefs: []
  type: TYPE_NORMAL
- en: In our render function, the view updates the CSS of the DOM elements. Imagine
    later if we are rendering the game in the Canvas, or using any other techniques,
    that our view rendering logic can use a specific method to render the view based
    on the same game data. The game data's calculation is independent to the techniques
    we use to render the game interface.
  prefs: []
  type: TYPE_NORMAL
- en: Beginning collision detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have checked the boundary of the playground when moving the ball in the previous
    section. Now, we can control the paddles with the keyboard and watch the ball
    move around the playground. What is missing now? We cannot interact with the ball.
    We control the paddles but the ball just passes through them as if they are not
    there. This is because we missed the collision detection between the paddles and
    the moving ball.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – hitting the ball with the paddles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use an approach, similar to that of checking the boundary, to check
    the collision:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `js/pingpong.js` file that we used in the previous section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `moveBall` function, we have already reserved the place to put the collision
    detection code there. Find the line with `//` `check` `paddles` `here`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s put the following code there. The code checks whether the ball is overlapping
    with either paddle and bounces the ball away when they overlap:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Test the game in a browser and the ball will now bounce away after hitting the
    left or right paddle. It will also reset to the center of the playground when
    it hits the left or right edge of the playground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have modified the ball by making it bounce away when it overlaps with the
    paddles. Let's see how we check the collision between the ball and the left paddle.
  prefs: []
  type: TYPE_NORMAL
- en: At first, we check whether the ball's *x* position is less than the left paddle's
    right edge. The right edge is the `left` value plus the `width` of the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, we check whether the ball's *y* position is between the top edge and bottom
    edge of the paddle. The top edge is the `top` value and the bottom edge is the
    `top` value plus the `height` of the paddle.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We bounce the ball away if the ball's position passes both the checks. This
    is how we check it, and it is just a basic collision detection.
  prefs: []
  type: TYPE_NORMAL
- en: We determine that the two objects are overlapped by checking their position
    and width/height. This type of collision detection works well in rectangle objects
    but is not good for circles and other shapes. The following screenshot illustrates
    the issue. The collision areas shown in the following graph are false positive.
    Their bounding box collides but the actual shapes do not overlap each other. This
    is a classic and efficient way to check for collisions. It may not be very accurate
    but its calculation is fast.
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For special shapes, we will need more advanced collision detection techniques,
    which we will discuss later.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have placed two paddles on the playground. How about we make the game more
    challenging by having an alternative paddle in the middle field? It's like having
    the goalkeeper and forwards in a soccer machine.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the left paddle movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The computer controls the left paddle. We would like to create a function that
    makes the left paddle chase the ball.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – auto moving the left paddle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perform the following set of actions for automoving our paddle:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with our `pingpong.js` JavaScript file. We create a function
    that follows the ball's *y* position.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, inside the game loop function, we call our `autoMovePaddleA` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a logic that moves the left paddle based on the ball's *y* position.
    You may try the game with its current progress at [http://makzan.net/html5-games/pingpong-wip-step6/](http://makzan.net/html5-games/pingpong-wip-step6/).
  prefs: []
  type: TYPE_NORMAL
- en: Since we have already implemented the view rendering in the `renderPaddles`
    function, in this section, we only need to update the paddle's data and the view
    will get updated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We make the paddle speed slower than the ball's speed. Otherwise, the player
    can never win against the computer, because the computer-controlled paddle can
    always catch the ball and bounce it back if they have the same speed.
  prefs: []
  type: TYPE_NORMAL
- en: Showing text dynamically in HTML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have implemented the basic game mechanics in the previous sections. Our Ping
    Pong game is missing a scoring board that shows both players' scores. We discussed
    how to use jQuery to modify the CSS styles of the selected elements. Can we also
    alter the content of the selected elements with jQuery? Yes, we can.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – Showing the score of both players
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to create a text-based scoreboard and update the scores when either
    player scores a goal:'
  prefs: []
  type: TYPE_NORMAL
- en: We are making improvements on our existing game so that we can use the last
    example as the starting point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `index.html` in the text editor. We are going to add the scoreboard's
    DOM elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the `#scoreboard` HTML structure to our `#game` DIV inside index.html.
    The `#game` DIV becomes the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's move onto the JavaScript part. Open the `js/pingpong.js` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need two more variables to store the players'' scores. Add their score variables
    inside the existing `pingpong` data object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the `playerAWin` function. We increment player A''s score there and update
    the scoreboard with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can add a code similar to that in the previous step to update player B''s
    score when player A is lost in the `playerBWin` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s move onto the `css/pingpong.css` file. Put the following styles in the
    file to make the score board look nicer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is time to test our latest code. Open the `index.html` in a web browser.
    Try playing by controlling both paddles and lose some points. The scoreboard should
    be counting the scores correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What just happened?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just used another common jQuery function: `text()` to alter the content
    of the game on the fly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `text()` function gets or updates the text content of the selected element.
    Here is a general definition of the `text`() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When we use the `text()` function without an argument, it returns the text content
    of the match elements. When we use it with an argument, it sets the text content
    to all the matched elements with the given string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, provide the following HTML structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The following jQuery calls return Makzan:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'However, in the following jQuery call, it sets all matched elements to the
    given HTML content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing the jQuery command gives the following HTML result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero – winning the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Imagine that the game is an advertisement. We set the entire game playground
    with pointer cursor so that the user knows the game is clickable and links to
    some other place. Try to use jQuery's `click` event and handle the advertisement
    that's linked to the `handleMouseInputs` function.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about the basic techniques of creating a simple
    Ping Pong game with HTML5 and JavaScript. Specifically, we created our first HTML5
    game—Ping Pong. In the game, we used jQuery to manipulate DOM objects. We were
    able to use the mouse event to get the cursor position. We used a very simple
    method to detect collisions with the bounding box. In the logic, we separated
    data manipulation and view rendering. We also discussed how to create a game loop
    and move the ball and paddles.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've warmed up by creating a simple DOM-based game, we are ready to
    create more advanced DOM-based games with new features from CSS3\. In the next
    chapter, we will create games with CSS3 transition and transformation.
  prefs: []
  type: TYPE_NORMAL
