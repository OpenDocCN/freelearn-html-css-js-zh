<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11" class="calibre1"/>Chapter 11. Real-Time Web Applications</h1></div></div></div><p class="calibre8">In this chapter, we'll cover the following recipes:</p><div><ul class="itemizedlist"><li class="listitem">Using dependency injection</li><li class="listitem">Working with application initializers</li><li class="listitem">Building a chat application</li><li class="listitem">Creating and working with add-ons</li><li class="listitem">Learning the Ember run loop</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch11lvl1sec82" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">As you level up with Ember, you'll learn how to work with real-time applications. In these types of applications, you'll be dealing with updates from a server. You'll need to be able to handle these events and notify the user as needed.</p><p class="calibre8">In Ember, we can use things such as dependency injection and services with WebSockets to handle real-time events from a server. We'll be looking at these concepts, including add-ons, in this chapter.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec83" class="calibre1"/>Using dependency injection</h1></div></div></div><p class="calibre8">The dependency <a id="id569" class="calibre1"/>injection pattern is used to declare and instantiate classes of objects and handle dependencies between them. In Ember, we can take objects or services and inject them into routes, controllers, or components.</p><p class="calibre8">In this recipe, we'll take a logger object and inject it into our controllers using dependency injection.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec153" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, install the <code class="email">moment</code> library and create a new <code class="email">initializer</code>:<div><pre class="programlisting">
<strong class="calibre9">$ bower install moment –save</strong>
<strong class="calibre9">$ ember g initializer application</strong>
</pre></div><p class="calibre14">This will install the Bower <strong class="calibre9">Moment.js</strong> library. We'll use this for our custom logger.</p></li><li class="listitem" value="2">Import the <a id="id570" class="calibre1"/>Moment library to the Ember project:<div><pre class="programlisting">// ember-cli-build.js
/*jshint node:true*/
/* global require, module */
var EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function(defaults) {
    var app = new EmberApp(defaults, {
      // Add options here
    });

    app.import('bower_components/moment/min/moment.min.js');
      return app.toTree();
};</pre></div><p class="calibre14">The <code class="email">app.import</code> statement adds the <code class="email">moment</code> library to the application.</p></li><li class="listitem" value="3">In the <code class="email">application.js</code> file in the <code class="email">initializers</code> folder, add a new logger:<div><pre class="programlisting">// app/initializers/application.js
/* global moment */
import Ember from 'ember';

export function initialize( application) {
    let MyLogger = Ember.Object.extend({
      log(info){
        let time = moment().format();
        Ember.Logger.debug(`(${time}):`,info);
      }
    });
    application.register('myLogger:zzz', MyLogger);
    application.inject('controller','myLogger','myLogger:zzz');
}

export default {
    name: 'application',
    initialize
};</pre></div><p class="calibre14">This creates a new logger called <code class="email">myLogger</code>. It uses the built-in <code class="email">Ember.Logger</code> and adds a timestamp to it using the <code class="email">moment</code> library that was installed earlier.</p><p class="calibre14">Let's <a id="id571" class="calibre1"/>take a look at this in more detail:</p><div><pre class="programlisting">    application.register('myLogger:zzz', MyLogger);</pre></div><p class="calibre14">The <code class="email">application.register</code> method registers a new factory. The first argument is the registration key. The registration key is always two parts separated by a colon <code class="email">:</code>. The first part is the type of factory and the second part is the name of the factory. The type of factory can be a template, <code class="email">component</code>, <code class="email">controller</code>, or <code class="email">service</code>, or you can create your own. In this example, I called it <code class="email">myLogger</code>. The second argument is the object you want to register, <code class="email">MyLogger</code>:</p><div><pre class="programlisting">    application.inject('controller','myLogger','myLogger:zzz');</pre></div><p class="calibre14">This application inject makes the new <code class="email">myLogger:zzz</code> factory available in all controllers. The value of <code class="email">myLogger</code> comes from the <code class="email">myLogger:zzz</code> factory.</p></li><li class="listitem" value="4">Create a new application controller and add a new action that logs using the new <code class="email">myLogger</code> debugger:<div><pre class="programlisting">// app/controllers/application.js
import Ember from 'ember';

export default Ember.Controller.extend({
    actions: {
      press(){
        this.myLogger.log('Hello World!');

      
    }
});</pre></div><p class="calibre14">When a new <code class="email">press</code> action occurs, it logs to the console, <code class="email">Hello World</code>.</p></li><li class="listitem" value="5">Add <code class="email">action</code> to the application template:<div><pre class="programlisting">&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{outlet}}
&lt;button {{action 'press'}}&gt;Button&lt;/button&gt;</pre></div><p class="calibre14">When the <a id="id572" class="calibre1"/>button is clicked, the <code class="email">press</code> action is triggered.</p></li><li class="listitem" value="6">Run <code class="email">ember server</code> and you'll see the following screen:<div><img src="img/00087.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">Press <strong class="calibre9">Button</strong> and you'll see something as follows in the console:</p><div><img src="img/00088.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">Each time you click the button, it logs a debug statement to the console.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec154" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Dependency injection occurs when we take objects and inject them into other objects during instantiation. Ember can do this with the <code class="email">application.inject</code> method. To accomplish this in Ember, we must create factories. Factories are simply objects that return other objects.</p><p class="calibre8">Ember registers <a id="id573" class="calibre1"/>these factories in <code class="email">Ember.Application</code>. <code class="email">Ember.Application</code> acts as a registry of sorts that holds different factories. After being registered, they can be injected into other parts of the Ember application such as components or controllers.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec84" class="calibre1"/>Working with application initializers</h1></div></div></div><p class="calibre8">Application <a id="id574" class="calibre1"/>initializers can be used to configure your application as it boots. It's the primary place to set up dependency injections in your application.</p><p class="calibre8">In this example, we'll examine when an application initializer is run.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec155" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, create <code class="email">initializer</code>:<div><pre class="programlisting">
<strong class="calibre9">$ ember g initializer application</strong>
</pre></div><p class="calibre14">This will create a new application <code class="email">initializer</code>. This will be run as soon as the application boots.</p></li><li class="listitem" value="2">Add an alert box to the initializer:<div><pre class="programlisting">// app/initializers/application.js
export function initialize( application ) {
    alert('loading application');
}

export default {
    name: 'application',
    initialize
};</pre></div><p class="calibre14">This will load an <code class="email">alert</code> box as soon as the application loads.</p></li><li class="listitem" value="3">Run <code class="email">ember server</code> and you should see an alert box displayed before the application is loaded:<div><img src="img/00089.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">Nothing else has loaded in the application before this alert box is shown.</p></li><li class="listitem" value="4">If <a id="id575" class="calibre1"/>needed, we can also <code class="email">register</code> or <code class="email">inject</code> services in the initializer. It may look as follows:<div><pre class="programlisting">// app/initializer/application.js
export function initialize(app) {
    app.inject('component', 'start', 'service:start');
}

export default {
    name: 'init',
    initialize
};</pre></div><p class="calibre14">This takes the service named start and injects it into all the components. You can see more examples of this in <a class="calibre1" title="Chapter 9. Real-Life Tasks with Ember.js" href="part0075_split_000.html#27GQ61-d21a6ad8148a415181fa52c0043435bb">Chapter 9</a>, <em class="calibre13">Real-Life Tasks with Ember.js</em>.</p><div><h3 class="title2"><a id="tip32" class="calibre1"/>Tip</h3><p class="calibre8"><strong class="calibre9">Application instance initializers</strong></p><p class="calibre8">Application <a id="id576" class="calibre1"/>instance initializers run when the instance is loaded. It was added with Ember's FastBoot to make it easier to run many requests concurrently. During bootup, application initializers are run first, then instance initializers. If needed, you can look up factories you've already registered in the application initializer in the instance initializer.</p><p class="calibre8">For the most part, you'll only be using instance initializers for certain A/B testing configurations, configuring initial states, and when working with the Ember <a id="id577" class="calibre1"/>FastBoot server. To generate an instance initializer, run <code class="email">ember g instance-initializer &lt;name&gt;</code>.</p></div></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec156" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Application initializers are run as soon as the application boots. This is the primary place to configure dependency injections into your application. Try to keep initializers as lightweight as possible. More complexity added to an initializer might cause delay in the application <a id="id578" class="calibre1"/>loading. Things like asynchronous loading conditions will work better in a service or route hook instead.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec85" class="calibre1"/>Building a chat application</h1></div></div></div><p class="calibre8">In this <a id="id579" class="calibre1"/>recipe, we'll combine what you learned with initializers and dependency injection to create a chat room. The chat room will use WebSockets to communicate with the host.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec157" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, generate these files:<div><pre class="programlisting">
<strong class="calibre9">$ ember g service sockjs</strong>
<strong class="calibre9">$ ember g component chat-room</strong>
<strong class="calibre9">$ ember g initializer application</strong>
<strong class="calibre9">$ bower install sockjs --save</strong>
</pre></div><p class="calibre14">These will generate the files needed for the project. The <code class="email">chat-room</code> component will have all the logic for the chat room that we'll create.</p></li><li class="listitem" value="2">Import the <a id="id580" class="calibre1"/><strong class="calibre9">SockJS</strong> library to the application:<div><pre class="programlisting">// ember-cli-build.js
…
app.import('bower_components/sockjs/sockjs.min.js');
…</pre></div><p class="calibre14">This will import the library so that we can use the global variable, <code class="email">sockjs</code>, anywhere in our application.</p></li><li class="listitem" value="3">Create a new service for <code class="email">SockJS</code>:<div><pre class="programlisting">// app/services/sockjs.js
/* global SockJS */
import Ember from 'ember';
const {run} = Ember;

export default Ember.Service.extend(Ember.Evented,{
    socket: null,
    init() {
      this._super();
      let socket = new SockJS('http://localhost:7000');
      socket.addEventListener('message', run.bind(this, (event)=&gt; {
        this.trigger('messageReceived', event.data);
        console.log(event.data);
      }));
      this.set('socket',socket);
    },
    sendInfo(message) {
      this.get('socket').send(message);

    }

});</pre></div><p class="calibre14">Let's take a look at this in more detail:</p><div><pre class="programlisting">/* global SockJS */</pre></div><p class="calibre14">This line <a id="id581" class="calibre1"/>is needed so that <strong class="calibre9">JSHint</strong> won't complain about the SockJS global variable. JSHint is the built-in library for Ember <a id="id582" class="calibre1"/>CLI that detects errors in your program:</p><div><pre class="programlisting">export default Ember.Service.extend(Ember.Evented,{</pre></div><p class="calibre14">This adds the <code class="email">Ember.Evented</code> mixin to the service. This mixin allows Ember objects to subscribe and emit events. This is perfect for what we need to do in this example:</p><div><pre class="programlisting">init() {
    this._super(…arguments);
},</pre></div><p class="calibre14">The <code class="email">init</code> method is where the SockJS socket will be set up and the event listener will be created. This method will fire after the service is initialized. The <code class="email">this._super</code> method guarantees that the <code class="email">init</code> method is set up properly:</p><div><pre class="programlisting">let socket = new SockJS('http://localhost:7000');</pre></div><p class="calibre14">The preceding line creates a new socket server at the localhost port <code class="email">7000</code>:</p><div><pre class="programlisting">socket.addEventListener('message', run.bind(this, (event)=&gt; {
    this.trigger('messageReceived', event.data);
    console.log(event.data);
}));
this.set('socket',socket);</pre></div><p class="calibre14">This creates an event listener that is fired when a message is received. The <code class="email">run.bind</code> method is a part of the Ember <code class="email">run</code> loop that we'll describe later in this chapter. This ensures that all the requests are taken care of properly in the <code class="email">run</code> loop.</p><p class="calibre14">The <code class="email">this.trigger</code> is a part of the <code class="email">Event.Evented</code> class. The <code class="email">trigger</code> method <a id="id583" class="calibre1"/>creates a new event called <code class="email">messageReceived</code>. We can subscribe to this event so that other methods in Ember can be triggered when a message is received. Finally, we <code class="email">log</code> the information in <code class="email">event.data</code> to the console and <code class="email">set</code> the <code class="email">socket</code> property:</p><div><pre class="programlisting">    sendInfo(message) {
      this.get('socket').send(message);
    }</pre></div><p class="calibre14">This method accepts <code class="email">message</code> and sends it the <code class="email">socket</code> server we defined earlier. The <code class="email">socket</code> property is accessed here.</p></li><li class="listitem" value="4">Inject the new service into all the components in the application:<div><pre class="programlisting">// app/initializers/application.js
export function initialize( application ) {
    application.inject('component', 'sockjs', 'service:sockjs');
}

export default {
    name: 'websockets',
    initialize
};</pre></div><p class="calibre14">The initializer takes the service called <code class="email">sockjs</code> and injects it into all the components. This will be run whenever the program first boots. We use this so that we don't have to specifically inject the <code class="email">sockjs</code> service into each component.</p></li><li class="listitem" value="5">Create a new component for the chat room:<div><pre class="programlisting">// app/components/chat-room.js
import Ember from 'ember';
const {$} = Ember;


export default Ember.Component.extend({
    message: '',

    init() {
      this._super(…arguments);
      this.sockjs.on('messageReceived',this, 'messageReceived');
    },

    messageReceived(message){
      $('#chat-content').val((i, text)=&gt;
      `${text}${message}\n`;
      );
      this.set('message',message);
    },
    actions: {
      enter(info,username) {
        this.sockjs.sendInfo(`${username}: ${info}`);

      }
    }

});</pre></div><p class="calibre14">Let's <a id="id584" class="calibre1"/>break this down into smaller parts:</p><div><pre class="programlisting">    init() {
      this._super(…arguments);
      this.sockjs.on('messageReceived',this, 'messageReceived');
    },</pre></div><p class="calibre14">This <code class="email">init</code> method fires on initialization and sets up the component. We can then subscribe to the event that we created earlier in the service using on. The first parameter is the name of the event. The second is the binding. The last is the name of the callback function. Therefore, in this example, whenever a message is received in the service, the <code class="email">messageReceived</code> callback in this component will be fired:</p><div><pre class="programlisting">    messageReceived(message){
      $('#chat-content').val((i, text)=&gt;
      `${text}${message}\n`
      );
      this.set('message',message);</pre></div><p class="calibre14">This is the <code class="email">messageReceived</code> callback. It uses a little bit of jQuery to find the <code class="email">chat-content</code> ID and concatenate the existing message to it using ES6 string interpolation. In addition, the <code class="email">message</code> property is set:</p><div><pre class="programlisting">    actions: {
      enter(info,username) {
        this.sockjs.sendInfo(`${username}: ${info}`);

      }
    }</pre></div><p class="calibre14">This action sends <code class="email">info</code> and <code class="email">username</code> to the socket. This way, any other clients connected will be notified.</p></li><li class="listitem" value="6">Create <a id="id585" class="calibre1"/>the <code class="email">chat-room.hbs</code> template file for the component:<div><pre class="programlisting">// app/templates/components/chat-room.hbs

    &lt;textarea id="chat-content" style="width:500px;height:300px" &gt;&lt;/textarea&gt;&lt;br/&gt;
    {{input type='text' placeholder='User Name' value=uname}}
    {{input type='text' placeholder='Chat Message' value=mess}}
    &lt;button {{action 'enter' mess uname}}&gt;Send&lt;/button&gt;&lt;br&gt;

Message received:{{message}}</pre></div><p class="calibre14">This code displays the messages from the server. The <code class="email">input</code> helpers capture the username and message. Each value is passed to the <code class="email">enter</code> action when the <code class="email">Send</code> button is clicked.</p></li><li class="listitem" value="7">Add the component to the <code class="email">application.hbs</code> file:<div><pre class="programlisting">// app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{outlet}}
{{chat-room}}</pre></div><p class="calibre14">This adds the component to the application.</p></li><li class="listitem" value="8">Start the node server. Then start the Ember application. You'll see the following screen:<div><img src="img/00090.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">As <a id="id586" class="calibre1"/>each client connects they'll be able to send messages to the server. Each client will receive these messages and display them in the chat box.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec158" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">A chat room consists of multiple clients talking to a server. The server's job is to notify all the other clients connected when a messages is received. This is done in this example using SockJS with WebSockets. The SockJS library has message events that we can set up in Ember. When a message is received, it is then sent to a component that updates its template with the message.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec159" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre8">To use the <a id="id587" class="calibre1"/>preceding example, you'll need to set up a WebSocket server. Here are the steps to create a simple Node.js SockJS server. To learn more about SockJS, check <a id="id588" class="calibre1"/>out their GitHub page at <a class="calibre1" href="https://github.com/sockjs/sockjs-node">https://github.com/sockjs/sockjs-node</a>.</p><div><ol class="orderedlist"><li class="listitem" value="1">In a new directory, run the <code class="email">npm init</code> command:<div><pre class="programlisting">
<strong class="calibre9">$ npm init</strong>
<strong class="calibre9">$ npm install sockjs –save</strong>
</pre></div><p class="calibre14">This will generate the <code class="email">package.json</code> file and install the SockJS server in it.</p></li><li class="listitem" value="2">Create a new <code class="email">app.js</code> file for the WebSocket server:<div><pre class="programlisting">// app.js
var http = require('http');
var sockjs = require('sockjs');


var clients = {};

function broadcast(message){
    for (var client in clients){
      clients[client].write(message);
    }
}

var socketServer = sockjs.createServer({ sockjs_url: 'http://cdn.jsdelivr.net/sockjs/1.0.1/sockjs.min.js' });
socketServer.on('connection', (conn)=&gt; {
    clients[conn.id] = conn;

    conn.on('data', (message)=&gt; {
      console.log('received ' + message);
      broadcast(message);
    });
    conn.write("hello from the server thanks for connecting!");
    conn.on('close', ()=&gt; {
      delete clients[conn.id];
    });
    console.log("connected");
});

var server = http.createServer();
socketServer.installHandlers(server);
server.listen(7000, '0.0.0.0');</pre></div><p class="calibre14">This server uses the SockJS library to create a new socket server. When a new client connects, it's added to an array. When it receives data, it broadcasts this data to all the other servers connected using this function:</p><div><pre class="programlisting">function broadcast(message){
    for (var client in clients){
      clients[client].write(message);
    }
}</pre></div><p class="calibre14">This <a id="id589" class="calibre1"/>function sends a <code class="email">broadcast</code> <code class="email">message</code> to every other client connected with the <code class="email">message</code> it just received. When Ember receives this information, it's written to the chat box.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec86" class="calibre1"/>Creating and working with add-ons</h1></div></div></div><p class="calibre8">Ember <a id="id590" class="calibre1"/>has a common way of sharing code using something called Ember <a id="id591" class="calibre1"/>Addons (also known as add-ons). Ember Addons make it easy to distribute reusable libraries with other applications. Anyone can create add-ons. You can publish them to NPM or to your own private Git repository.</p><p class="calibre8">Keep in mind that you can also use Bower to install frontend dependencies. This is done through the Bower package manager. Take a look at <a class="calibre1" title="Chapter 1. Ember CLI Basics" href="part0015_split_000.html#E9OE1-d21a6ad8148a415181fa52c0043435bb">Chapter 1</a>, <em class="calibre13">Ember CLI Basics</em> for more information on how to do this.</p><p class="calibre8">In this recipe, we'll take our chat program from the last section and make it an add-on.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec160" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">Create a new add-on called <code class="email">sockjs-chat</code>. Generate these files:<div><pre class="programlisting">
<strong class="calibre9">$ ember addon sockjs-chat</strong>
<strong class="calibre9">$ cd sockjs-chat</strong>
<strong class="calibre9">$ ember g component sockjs-chat</strong>
<strong class="calibre9">$ ember g service sockjs</strong>
<strong class="calibre9">$ ember g blueprint sockjs-chat</strong>
<strong class="calibre9">$ npm install ember-cli-htmlbars --save</strong>
</pre></div><p class="calibre14">The <code class="email">ember addon</code> command generates the folder structure for the add-on. We'll discuss the folder structure in more detail later. The <code class="email">blueprint</code> command creates a new blueprint called <code class="email">sockjs-chat</code>. Blueprints are used to generate snippets of code. This is needed so that the SockJS library can be installed. If we're doing anything with templates, we'll need to add <code class="email">ember-cli-htmlbars</code>.</p></li><li class="listitem" value="2">Create the <a id="id592" class="calibre1"/><code class="email">sockjs-chat</code> blueprint so that it installs the SockJS library:<div><pre class="programlisting">// blueprints/sockjs-chat/index.js
/*jshint node:true*/
module.exports = {
    normalizeEntityName() {
},

    afterInstall() {
      return this.addBowerPackageToProject('sockjs-client', '~1.0.3');
    }
};</pre></div><p class="calibre14">The <code class="email">afterInstall</code> hook is used to add Bower packages. By default, the blueprint file will be run during the add-on installation. This guarantees that the <code class="email">sockjs-client</code> library is installed via the Bower package manager.</p></li><li class="listitem" value="3">Update the root <code class="email">index.js</code> file so that the SockJS library is imported:<div><pre class="programlisting">// index.js
/* jshint node: true */
'use strict';

module.exports = {
    name: 'sockjs-chat',
      included(app) {
        this._super.included(app);
        app.import(app.bowerDirectory + '/sockjs-client/dist/sockjs.min.js');
      }
};</pre></div><p class="calibre14">The JavaScript SockJS library is installed in the blueprint. However, we still need to import it to Ember. This can be done in the root folder's <code class="email">index.js</code> file. This file is the entry point to the application. The <code class="email">included</code> hook is used to import the Bower components to the application. Imports are added to the application in the order that they appear.</p></li><li class="listitem" value="4">Set the <a id="id593" class="calibre1"/><code class="email">package.json</code> file with the correct information for the project:<div><pre class="programlisting">// package.json
{
    "name": "sockjs-chat",
    "version": "1.0.0",
    "description": "EmberJS Sockjs Chat Addon",
…
"repository": "https://github.com/ErikCH/sockjs-chat",
…
"author": "Erik Hanchett",
…
    "keywords": [
      "ember-addon",
      "sockjs",
      "ember websockets"
…</pre></div><p class="calibre14">It's important to have your <code class="email">package.json</code> file updated with at least your <code class="email">name</code>, <code class="email">description</code>, <code class="email">repository</code>, <code class="email">author</code>, and <code class="email">keywords</code>. This is extremely important if you plan on open sourcing your add-on and publishing it to NPM. Without this information, your add-on will be hard to find.</p></li><li class="listitem" value="5">In the generated service file, add a new <code class="email">setup</code> and <code class="email">send</code> method:<div><pre class="programlisting">// addon/services/sockjs.js
/* global SockJS */
import Ember from 'ember';
var {run} = Ember;

export default Ember.Service.extend(Ember.Evented,{
    socket: null,
    setupSockjs(url) {
      let socket = new SockJS(url);
      socket.addEventListener('message', run.bind(this, (event)=&gt; {
        this.trigger('messageReceived', event.data);
        console.log(event.data);
      }));
      this.set('socket',socket);
    },
    sendInfo(message) {
      let socket= this.get('socket');
      if(socket != null){
        socket.send(message);
      }
    }

});</pre></div><p class="calibre14">This may look familiar. This is almost the same service that we created in the last recipe. However, this time, we have a new <code class="email">setupSockjs</code> method that takes <code class="email">url</code> <a id="id594" class="calibre1"/>as a parameter. The <code class="email">url</code> parameter is used to set the new socket listener:</p><div><pre class="programlisting">      socket.addEventListener('message', run.bind(this,(event)=&gt; {
        this.trigger('messageReceived', event.data);
        console.log(event.data);
      }));</pre></div><p class="calibre14">This <code class="email">event</code> is triggered when a new <code class="email">message</code> is received. After a new <code class="email">message</code> arrives, a new trigger called <code class="email">messageReceived</code> will be called:</p><div><pre class="programlisting">    sendInfo(message) {
      let socket= this.get('socket');
      if(socket != null){
        socket.send(message);
      }</pre></div><p class="calibre14">As long as <code class="email">socket</code> isn't <code class="email">null</code>, <code class="email">message</code> will be sent to the WebSocket server.</p></li><li class="listitem" value="6">Set up the <code class="email">sockjs-chat.js</code> component:<div><pre class="programlisting">// addon/components/sockjs-chat.js
import Ember from 'ember';
import layout from '../templates/components/sockjs-chat';
const {typeOf} = Ember;
export default Ember.Component.extend({

    sockjs: Ember.inject.service('sockjs'),
    layout,
    message:'',

    init() {
      this._super(...arguments);
      this.get('sockjs').setupSockjs(this.attrs.url);
      this.get('sockjs').on('messageReceived',this,(message)=&gt;{
        this.set('message',message);
        this._actionHandler('receiveAction',message);
      });
    },
    _actionHandler(actionName, ...args) {

      if(this.attrs &amp;&amp; typeOf(this.attrs[actionName]) === 'function'){
        this.attrs[actionName](...args);
      } else {
        this.sendAction(actionName,...args);
      
      },

      actions: {
        enter(info,username) {
          this._actionHandler('sendAction',info,username);

        }
      }

});</pre></div><p class="calibre14">The purpose of the component is to make it easy for someone to add a chat feature to their application without having to understand the internals of the <a id="id595" class="calibre1"/>service that we created earlier. To use this component, the template must be in block or non-block form with these properties:</p><div><pre class="programlisting">{{sockjs-chat
url='http://localhost:7000'
receiveAction=(action 'receiveMessage')
sendAction=(action 'sendMessage') }}</pre></div><p class="calibre14">The <code class="email">url</code> property is the location of the WebSocket. The <code class="email">receiveAction</code> method is the parent component's <code class="email">action</code> name. This will be triggered whenever a message is received. The <code class="email">sendAction</code> method is the parent component's name for <code class="email">action</code> that will be sending out messages.</p><p class="calibre14">Let's take a <a id="id596" class="calibre1"/>look at the component in more detail:</p><div><pre class="programlisting">    layout,
    message:'',
    init() {
      this._super(...arguments);
      this.get('sockjs').setupSockjs(this.attrs.url);
      this.get('sockjs').on('messageReceived',this,(message)=&gt;{
        this.set('message',message);
        this._actionHandler('receiveAction',message);
      });
    },</pre></div><p class="calibre14">The <code class="email">layout</code> property is the same as <code class="email">layout: layout</code>. This is a part of ES6. The <code class="email">init</code> hook is run when the component is initialized. Whenever you <code class="email">extend</code> a built-in method, it's always a good idea to run <code class="email">this._super</code>. This makes sure that the component is set up correctly. The <code class="email">…arguments</code> array is a part of the new ES6 syntax. It's known as <code class="email">Rest</code> parameters and represents an indefinite number of arguments in an array. We'll be using this several times in this component.</p><p class="calibre14">After <code class="email">super</code> is run, we pass the <code class="email">url</code> property to the <code class="email">setupSockjs</code> method in our service. The <code class="email">this.attrs.url</code> retrieves the <code class="email">url</code> property that was passed to the component.</p><p class="calibre14">As we are using the <code class="email">Ember.Event</code> mixin, we can subscribe to the service and watch for the <code class="email">messageReceived</code> trigger. When <code class="email">messageReceived</code> is triggered, we set the internal message, <code class="email">this.message</code> property, to the message that was received. We then pass the message to a new method called <code class="email">_actionHandler</code>:</p><div><pre class="programlisting">    _actionHandler(actionName, ...args) {

      if(this.attrs &amp;&amp; typeOf(this.attrs[actionName]) === 'function'){
        this.attrs[actionName](...args);
      } else {
        this.sendAction(actionName,...args);
      }
    },</pre></div><p class="calibre14">The purpose of <code class="email">actionHandler</code> is to take an <code class="email">action</code> passed by the <code class="email">receiveAction</code> or <code class="email">sendAction</code> property and invoke it. However, we need to make sure that we can handle actions passed via closure actions, as described in <a class="calibre1" title="Chapter 6. Ember Components" href="part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb">Chapter 6</a>, <em class="calibre13">Ember Components</em>, or just a named action. If it's a closure action <a id="id597" class="calibre1"/>such as <code class="email">(action 'receiveMessage')</code>, then we simply call it using <code class="email">this.attrs[actionname](…args)</code>. If not, then we use <code class="email">sendAction</code>, which will send the action to the parent component:</p><div><pre class="programlisting">    actions: {
      enter(info,username) {
        this._actionHandler('sendAction',info,username);

      }
    }</pre></div><p class="calibre14">The <code class="email">enter</code> action calls the action handler and passes the <code class="email">info</code> and <code class="email">username</code> over. As we are using <code class="email">Rest</code> parameters in <code class="email">_actionHandler</code>, <code class="email">(…arguments)</code>, we can pass to it as many arguments as we need.</p></li><li class="listitem" value="7">Update the component template for <code class="email">sockjs-chat.hbs</code>:<div><pre class="programlisting">// addon/templates/components/sockjs-chat.hbs
{{#if hasBlock}}
    {{yield this}}
{{else}}

    &lt;textarea id="chat-content" style="width:500px;height:300px" &gt;&lt;/textarea&gt;&lt;br/&gt;
    {{input type='text' placeholder='User Name' value=uname}}
    {{input type='text' placeholder='Chat Message' value=mess}}
    &lt;button {{action 'enter' mess uname}}&gt;Send&lt;/button&gt;&lt;br&gt;

{{/if}}</pre></div><p class="calibre14">This gives the user a couple of choices when using this add-on. They can use the component in block form, which will look similar to the service we created in the last chapter, or they can design their own. The <code class="email">hasBlock</code> helper returns <code class="email">true</code> if the user adds the component in block form. If the component was not added in block form, then it displays the normal chat window.</p><p class="calibre14">One important aspect in this template is <code class="email">{{yield this}}</code>. When in block form, this will give the block access to the component itself. We'll have full access to the components, properties, and methods in the templates block. We'll take <a id="id598" class="calibre1"/>a look at this when we test the add-on.</p></li></ol><div></div><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec53" class="calibre1"/>Testing the sockjs-chat add-on</h3></div></div></div><p class="calibre8">The <code class="email">/tests</code> folder in the add-on is where all the test cases reside. This is very similar to any other Ember <a id="id599" class="calibre1"/>application. However, add-ons also <a id="id600" class="calibre1"/>include a dummy folder in the test folder. This folder is generally where add-on makers create their test applications. The program in this folder will have access to the add-on, although you'll need to install any Bower dependencies manually.</p><div><ol class="orderedlist"><li class="listitem" value="1">Run this command to install <code class="email">sockjs-client</code> for testing purposes in the <code class="email">add-on</code> folder:<div><pre class="programlisting">
<strong class="calibre9">$ bower install sockjs-client –-save-dev</strong>
</pre></div><p class="calibre14">This will install  <code class="email">sockjs-client</code> in the <code class="email">bower.json</code> <code class="email">devDependencies</code> section. The <code class="email">bower.json</code> file is used only for the application in the <code class="email">/tests/dummy/</code> folder.</p></li><li class="listitem" value="2">Update the <code class="email">ember-cli-build.js</code> file with <code class="email">SockJS bower_component</code>:<div><pre class="programlisting">// ember-cli-build.js
/*jshint node:true*/
/* global require, module */
var EmberAddon = require('ember-cli/lib/broccoli/ember-addon');

module.exports = function(defaults) {
    var app = new EmberAddon(defaults, {
      // Add options here
    });

/*
This build file specifes the options for the dummy test app of this
addon, located in `/tests/dummy`
This build file does *not* influence how the addon or the app using it
behave. You most likely want to be modifying `./index.js` or app's build file
*/

    app.import('bower_components/sockjs-client/dist/sockjs-0.3.4.js');
    return app.toTree();
};</pre></div><p class="calibre14">This will add the <code class="email">sockjs-client</code> library to our <code class="email">/tests/dummy</code> app.</p></li><li class="listitem" value="3">In the <code class="email">/tests/dummy</code> folder, add the component from the add-on in a non-block <a id="id601" class="calibre1"/>form:<div><pre class="programlisting">// tests/dummy/app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{sockjs-chat
url='http://localhost:7000'
receiveAction=(action 'receiveMessage')
sendAction=(action 'sendMessage') }}</pre></div><p class="calibre14">This will add our new component add-on to the application. The <code class="email">url</code> property will be passed to the service so that it can connect to the WebSocket server at port <code class="email">7000</code>. The <code class="email">receiveAction</code> and <code class="email">sendAction</code> properties <a id="id602" class="calibre1"/>point to closure actions. This will trigger when we receive a message or want to send a message.</p></li><li class="listitem" value="4">Define the send and receive actions in the application controller:<div><pre class="programlisting">// tests/dummy/app/controllers/application.js

import Ember from 'ember';
const {$} = Ember;
export default Ember.Controller.extend({
    sockjs: Ember.inject.service('sockjs'),
    actions:{
      receiveMessage(message){
        $('#chat-content').val((i, text)=&gt;
        `${text}${message}\n`
        );
        this.set('message',message);

      },
      sendMessage(message, username){
        console.log(username);
        console.log(message);
        var send = this.get('sockjs');
        send.sendInfo(`${username}: ${message}`);

       }
    }
});</pre></div><p class="calibre14">These <code class="email">actions</code> handle the sending and receiving of messages. The <code class="email">receive</code> method uses a little bit of jQuery to append the latest message to the chat window. The <code class="email">send</code> method uses the service from the add-on to send a message.</p></li><li class="listitem" value="5">Run <code class="email">ember server</code> command and test out the add-on:<div><pre class="programlisting">
<strong class="calibre9">$ ember server</strong>
</pre></div><p class="calibre14">You can <a id="id603" class="calibre1"/>run the server command <a id="id604" class="calibre1"/>directly in the <code class="email">add-on</code> folder. This will serve up the files in the <code class="email">/tests/dummy/</code> folder. Make sure to also begin the WebSockets server as well. Check out the last recipe on how to create a WebSocket server in Node.js.</p></li><li class="listitem" value="6">Open a web browser and type in a message:<div><img src="img/00091.jpeg" alt="Testing the sockjs-chat add-on" class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">This chat box is generated from the template in the add-on. The message typed here will be sent using the action created in the controller.</p></li><li class="listitem" value="7">Use the <a id="id605" class="calibre1"/>component in block form and <a id="id606" class="calibre1"/>create your own chat box:<div><pre class="programlisting">// tests/dummy/app/templates/application.hbs
&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{outlet}}

&lt;h2&gt;Alternative&lt;/h2&gt;
{{#sockjs-chat
url='http://localhost:7000'
receiveAction=(action 'receiveMessage')
sendAction=(action 'sendMessage') as |sockjs|}}

    &lt;textarea id="chat-content" style="width:300px;height:300px"&gt;&lt;/textarea&gt;&lt;br/&gt;
    {{input type='text' placeholder='User Name' value=uname}}
    {{input type='text' placeholder='Chat Message' value=mess}}
    &lt;button {{action 'enter' mess uname target=sockjs}}&gt;Send&lt;/button&gt;&lt;br&gt;
    {{sockjs.message}}

{{/sockjs-chat}}</pre></div><p class="calibre14">This template uses the add-on component in block form. This time, we create a smaller chat room instead of using the default one created by the add-on:</p><div><pre class="programlisting">{{#sockjs-chat
url='http://localhost:7000'
receiveAction=(action 'receiveMessage')
sendAction=(action 'sendMessage') as |sockjs|}}</pre></div><p class="calibre14">When a <a id="id607" class="calibre1"/>component begins with hash <code class="email">#</code>, it's considered to be in block form. To get access to the component <a id="id608" class="calibre1"/>itself, we add <code class="email">|sockjs|</code> at the end. Now <code class="email">sockjs</code> has access to all the properties in the component:</p><div><pre class="programlisting">&lt;button {{action 'enter' mess uname target=sockjs}}&gt;Send&lt;/button&gt;&lt;br&gt;</pre></div><p class="calibre14">As we have access to the component in the block, we can set <code class="email">target</code> of this <code class="email">action</code> to <code class="email">sockjs</code>. We can also display the message anywhere we need to:</p><div><pre class="programlisting">    {{sockjs.message}}</pre></div><p class="calibre14">This will display the <code class="email">message</code> property in the component.</p></li><li class="listitem" value="8">Run <code class="email">ember server</code> again in the <code class="email">add-on</code> folder and open a web browser. Type in a message:<div><img src="img/00092.jpeg" alt="Testing the sockjs-chat add-on" class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">As you can see, this new chat window looks a little different. However, it behaves in the same way and uses the same add-on as before.</p></li><li class="listitem" value="9">Create <a id="id609" class="calibre1"/>a new application and link it to <a id="id610" class="calibre1"/>the add-on to test:<div><pre class="programlisting">
<strong class="calibre9">$ cd sockjs-chat</strong>
<strong class="calibre9">$ npm link</strong>
<strong class="calibre9">$ cd ..</strong>
<strong class="calibre9">$ ember new chat </strong>
<strong class="calibre9">$ cd chat</strong>
<strong class="calibre9">$ npm link sockjs-chat</strong>
</pre></div><p class="calibre14">The first thing that we do is navigate to the <code class="email">sockjs-chat</code> folder that has our new add-on in it. We then run the <code class="email">npm link</code> command. This generates a symbolic link from the local NPM cache to the add-on project. To access the add-on, we must then run <code class="email">npm link sockjs-chat</code> in our new application. This creates a link to the add-on.</p></li><li class="listitem" value="10">Add the <a id="id611" class="calibre1"/>add-on to the <code class="email">package.json</code> <a id="id612" class="calibre1"/>file in the chat test application:<div><pre class="programlisting">// chat/package.json
…
    "devDependencies": {
    "sockjs-chat": "*"
…</pre></div><p class="calibre14">This is one of the last steps when linking an add-on to test. Ember must have this code in <code class="email">devDependencies</code> for it to see the add-on.</p></li><li class="listitem" value="11">Run install and add the blueprint:<div><pre class="programlisting">
<strong class="calibre9">$ npm install</strong>
<strong class="calibre9">$ ember g sockjs-chat</strong>
</pre></div><p class="calibre14">After updating the <code class="email">package.json</code> file, we must install the new package using <code class="email">npm install</code>. Finally, running <code class="email">ember g sockjs-chat</code> runs the default blueprint that will install <code class="email">sockjs-client</code> in the application. The blueprint is automatically run when a new Ember add-on is installed. However, we must run it manually if we use the <code class="email">npm link</code> technique.</p><p class="calibre14">We can now use the add-on in the application. Take note that we'll need to implement the same controller as we did in the dummy application to make this add-on work.</p></li></ol><div></div></div><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec54" class="calibre1"/>Publishing the sockjs-chat add-on</h3></div></div></div><p class="calibre8">There are <a id="id613" class="calibre1"/>two ways to publish the new add-on. We can <a id="id614" class="calibre1"/>use either NPM or Git.</p><div><ol class="orderedlist"><li class="listitem" value="1">Publish your add-on to a private Git repository:<div><pre class="programlisting">
<strong class="calibre9">$ cd sockjs-chat</strong>
<strong class="calibre9">$ git add .</strong>
<strong class="calibre9">$ git commit –m "first commit"</strong>
<strong class="calibre9">$ git remote add origin git@yourserver:username/sockjs-chat.git</strong>
<strong class="calibre9">$ git push origin master</strong>
</pre></div><p class="calibre14">To publish privately, you need to set up a private Git repository. Then push the add-on to this repository. In this case, replace <code class="email">yourserver:username</code> with the <code class="email">server</code> and <code class="email">username</code> of your private Git repository.</p></li><li class="listitem" value="2">Install <a id="id615" class="calibre1"/>the add-on from the Git <a id="id616" class="calibre1"/>repository in a new application:<div><pre class="programlisting">
<strong class="calibre9">$ cd my-app</strong>
<strong class="calibre9">$ ember install git+ssh://git@yourserver:username/sockjs-chat.git </strong>
</pre></div><p class="calibre14">This will install the add-on in the application. Make sure that the name of the repository matches the name of the add-on, or you'll get a message that the add-on cannot be found.</p></li><li class="listitem" value="3">Publish your add-on to NPM:<div><pre class="programlisting">
<strong class="calibre9">$ cd sockjs-chat</strong>
<strong class="calibre9">$ npm adduser</strong>
<strong class="calibre9">$ npm publish</strong>
</pre></div><p class="calibre14">This will add you as a new user to the <a class="calibre1" href="http://npm.org">http://npm.org</a> site. You can then publish the <code class="email">npm</code> as <a id="id617" class="calibre1"/>long as the <code class="email">package.json</code> file is set up correctly.  Later, you can use the <code class="email">npm</code> version to bump the add-on version if needed.</p></li><li class="listitem" value="4">Install your add-on in a new application:<div><pre class="programlisting">
<strong class="calibre9">$ cd my-app2</strong>
<strong class="calibre9">$ ember install sockjs-chat</strong>
</pre></div><p class="calibre14">This will install the <code class="email">sockjs-chat</code> application from <code class="email">npm</code> in the <code class="email">my-app2</code> application.</p></li></ol><div></div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec161" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Ember uses an add-on system to share code between applications. Each add-on has its own package that can be added to any application. Unlike the Bower package manager, these libraries can be more complicated and can encapsulate Ember code.</p><p class="calibre8">Ember add-ons can <a id="id618" class="calibre1"/>be accessed via NPM or private <a id="id619" class="calibre1"/>Git server. This can be used to share information between applications.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec162" class="calibre1"/>See also</h2></div></div></div><p class="calibre8">Using Ember Addons can really speed up the development process. There are thousands of add-ons available. Check out the following two websites:</p><div><ul class="itemizedlist"><li class="listitem"><a class="calibre1" href="http://www.emberaddons.com/">http://www.emberaddons.com/</a></li><li class="listitem"><a class="calibre1" href="http://emberobserver.com/">http://emberobserver.com/</a></li></ul></div><p class="calibre8">Both websites list <a id="id620" class="calibre1"/>add-ons and rank them. Use them for your applications. You won't regret it.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch11lvl1sec87" class="calibre1"/>Learning the Ember run loop</h1></div></div></div><p class="calibre8">The Ember <code class="email">run</code> <a id="id621" class="calibre1"/>loop is an extremely important part of Ember's internals. The <code class="email">run</code> loop is used to batch, order, and work in a way that's most efficient for the Ember application. In this recipe, we'll create a simple timer and take a look at how the <code class="email">run</code> loop works.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch11lvl2sec163" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before we move on to our recipe, we'll need to understand some basics of the Ember <code class="email">run</code> loop.</p><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec55" class="calibre1"/>Understanding Ember run queues</h3></div></div></div><p class="calibre8">The Ember <a id="id622" class="calibre1"/>
<code class="email">run</code> loop consists of six queues as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">sync</code>: This <a id="id623" class="calibre1"/>queue consists of binding synchronization jobs.</li><li class="listitem"><code class="email">actions</code>: This queue contains general work and promises.</li><li class="listitem"><code class="email">routerTransitions</code>: This queue contains transition jobs in the router.</li><li class="listitem"><code class="email">render</code>: This queue contains jobs meant to render, usually to update the DOM.</li><li class="listitem"><code class="email">afterRender</code>: This queue is run after all previously scheduled render tasks are completed. This queue is typically used for third-party applications.</li><li class="listitem"><code class="email">destroy</code>: This <a id="id624" class="calibre1"/>last queue tears down objects.</li></ul></div><p class="calibre8">These queues don't <a id="id625" class="calibre1"/>run all the time. They only run in response to certain user and timer events. This way, responsibility is handed back to the user; otherwise, the browser would hang.</p></div><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec56" class="calibre1"/>When should you change the Ember run loop?</h3></div></div></div><p class="calibre8">You should make <a id="id626" class="calibre1"/>changes to the Ember <code class="email">run</code> loop only in certain situations:</p><div><ul class="itemizedlist"><li class="listitem">Asynchronous callbacks</li><li class="listitem">Dealing with timers</li><li class="listitem">Ajax callbacks</li><li class="listitem">Certain types of tests</li><li class="listitem">WebSockets</li><li class="listitem"><code class="email">PostMessage</code> and <code class="email">messageChannel</code> event handlers</li></ul></div><p class="calibre8">Most of the time, Ember's <code class="email">run</code> loop will handle everything and you won't need to touch it.</p></div><div><div><div><div><h3 class="title2"><a id="ch11lvl3sec57" class="calibre1"/>Working with the Ember.run namespace</h3></div></div></div><p class="calibre8">The Ember <a id="id627" class="calibre1"/>run namespace gives us <a id="id628" class="calibre1"/>several methods to use when working with the <code class="email">run</code> loop. The most popular methods are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="email">Ember.run.bind</code>: This <a id="id629" class="calibre1"/>is great for use in third-party libraries, and adds the execution of the function to Ember's <code class="email">run</code> loop</li><li class="listitem"><code class="email">Ember.run.later</code>: This runs the passed target/method after a specified period <a id="id630" class="calibre1"/>of time</li><li class="listitem"><code class="email">Ember.run.schedule</code>: This runs the passed target/method and optional arguments <a id="id631" class="calibre1"/>to the named queue at the end of the loop</li></ul></div><p class="calibre8">There are more methods available, but these are the ones you'll use the most when you need to manipulate the <code class="email">run</code> loop.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch11lvl2sec164" class="calibre1"/>How to do it...</h2></div></div></div><div><ol class="orderedlist"><li class="listitem" value="1">In a new application, generate a new <code class="email">time-checker</code> component:<div><pre class="programlisting">
<strong class="calibre9">$ ember g component time-checker</strong>
<strong class="calibre9">$ bower install moment –save</strong>
</pre></div><p class="calibre14">This will generate a new component called <code class="email">time-checker</code>. In addition, we'll be using the Moment library to keep track of our timer.</p></li><li class="listitem" value="2">Import the <a id="id632" class="calibre1"/>Moment library to the application:<div><pre class="programlisting">// ember-cli-build.js
/*jshint node:true*/
/* global require, module */
var EmberApp = require('ember-cli/lib/broccoli/ember-app');

module.exports = function(defaults) {
    var app = new EmberApp(defaults, {
      // Add options here
    });

    app.import('bower_components/moment/min/moment.min.js');

    return app.toTree();
};</pre></div><p class="calibre14">This adds the Moment library to the application.</p></li><li class="listitem" value="3">Update the new <code class="email">time-checker.js</code> component file. Add two properties to it—one to <a id="id633" class="calibre1"/>show the time when the component started and another to show the current time:<div><pre class="programlisting">// app/components/time-checker.js
/* global moment */
import Ember from 'ember';

export default Ember.Component.extend({
    startTime: null,
    currentTime:null,
    init(){
      this._super(...arguments);
      this.set('startTime',moment());
      this.startWatchingTime();

    },
    startWatchingTime(){
      this.set('currentTime', moment());
      Ember.run.later(()=&gt;{
        this.startWatchingTime();
      }, 1000);
    },
    diff: Ember.computed('startTime','currentTime', function(){
      return this.get('currentTime').diff(this.get('startTime'),'seconds');

    })
});</pre></div><p class="calibre14">The <a id="id634" class="calibre1"/>purpose of this component is to display the time when the component loaded and the current time. It also shows the difference between these two times. Let's take a look at this in more detail:</p><div><pre class="programlisting">    init(){
      this._super(...arguments);
      this.set('startTime',moment());
      this.startWatchingTime();

    },
      startWatchingTime(){
        this.set('currentTime', moment());
        Ember.run.later(()=&gt;{
          this.startWatchingTime();
        }, 1000);</pre></div><p class="calibre14">The <code class="email">init</code> function runs as soon as the component is instantiated. It sets the current time and calls the <code class="email">startWatchingTime</code> method. This method uses <code class="email">Ember.run.later</code> to wait a second before continuing. Each second, it calls itself, and then calculates the new date and time again. It's better to use this method than <code class="email">setTimeout</code>, as it may cause issues in the Ember <code class="email">run</code> loop:</p><div><pre class="programlisting">    diff: Ember.computed('startTime','currentTime', function(){
      return  this.get('currentTime').diff(this.get('startTime'),'seconds');

    })</pre></div><p class="calibre14">The <code class="email">diff</code> computed property updates whenever <code class="email">currentTime</code> changes. It returns the difference in seconds between the two times.</p></li><li class="listitem" value="4">Update the template for the <code class="email">time-checker.hbs</code> component file:<div><pre class="programlisting">// app/templates/components/time-checker.hbs
Startup time: {{startTime}}&lt;br&gt;
Current time: {{currentTime}}&lt;br&gt;
Difference: {{diff}}</pre></div><p class="calibre14">This will display the start, current, and difference times.</p></li><li class="listitem" value="5">Update <a id="id635" class="calibre1"/>the application template and add the component:<div><pre class="programlisting">&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;

{{time-checker}}</pre></div><p class="calibre14">This will add the <code class="email">time-checker</code> component to the application.</p></li><li class="listitem" value="6">Run the application and you'll see two times. The second time will update every second:<div><img src="img/00093.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">The Ember <code class="email">run</code> loop makes this possible.</p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch11lvl2sec165" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">The Ember <code class="email">run</code> loop <a id="id636" class="calibre1"/>helps schedule work in an Ember application. It runs whenever there is user action or certain timing events. It consists of six different queues. Each queue is responsible for different functions in the application.</p><p class="calibre8">In most situations, you don't need to worry about the <code class="email">run</code> loop. However, in some situations such as dealing with asynchronous callbacks or timing events, you'll need to use them. Keep this in mind as you continue to program in the future.</p></div></div></body></html>