- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Introducing Node.js 22
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 Node.js 22
- en: Created in 2009, Node.js is a cross-platform, open source JavaScript runtime
    that allows you to execute JavaScript outside of the browser. Node.js wraps Google
    Chrome’s JavaScript engine, V8, to enable JavaScript to be run outside the browser.
    Node.js brings JavaScript to the server, which enables us to interact with the
    operating system, network, and filesystem with JavaScript. Node.js was built following
    an event loop architecture, which enables it to effectively handle input/output
    and concurrent operations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 于 2009 年创建，是一个跨平台的、开源的 JavaScript 运行时，允许你在浏览器之外执行 JavaScript。Node.js
    使用 Google Chrome 的 JavaScript 引擎 V8，使 JavaScript 能够在浏览器之外运行。Node.js 将 JavaScript
    带到服务器，使我们能够使用 JavaScript 与操作系统、网络和文件系统交互。Node.js 是按照事件循环架构构建的，这使得它能够有效地处理输入/输出和并发操作。
- en: Today, Node.js is a popular technology choice for building many types of applications,
    including HTTP web servers, microservices, real-time applications, and more. Part
    of Node.js’s success is that it enables full-stack development in a common language,
    JavaScript.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，Node.js 是构建许多类型应用程序的流行技术选择，包括 HTTP 网络服务器、微服务、实时应用程序等。Node.js 成功的部分原因在于它使全栈开发在一种通用语言，JavaScript
    中成为可能。
- en: The massive ecosystem of modules has supported Node.js’s success. There are
    over 3 million modules available on the **npm** registry, with many abstracting
    lower-level implementation details to higher-level and more easily consumable
    APIs. Building your applications atop **npm** modules can speed up the development
    process while promoting code sharing and reuse.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的大量生态系统支持了 Node.js 的成功。在 **npm** 注册表中，有超过 300 万个模块可用，其中许多将低级实现细节抽象为更高级、更易于使用的
    API。在 **npm** 模块之上构建您的应用程序可以加快开发过程，同时促进代码共享和重用。
- en: Node.js is now over a decade old and has matured as a technology. Today, it
    is a common technology choice for building applications of all sizes. Many large
    enterprises use Node.js in production. Due to the widespread usage and dependence
    on Node.js, it was moved under the OpenJS Foundation (formerly the Node.js Foundation).
    The OpenJS Foundation offers a neutral environment for JavaScript projects, emphasizing
    a robust commitment to open governance. Open governance facilitates transparency
    and accountability, which, in turn, helps to ensure that no single person or company
    has too much control over the project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 现在已经超过十年历史，作为一项技术已经成熟。如今，它是构建各种规模应用程序的常见技术选择。许多大型企业都在生产中使用 Node.js。由于
    Node.js 的广泛应用和依赖性，它被移至 OpenJS 基金会（之前称为 Node.js 基金会）之下。OpenJS 基金会为 JavaScript 项目提供了一个中立的平台，强调对开放治理的坚定承诺。开放治理促进了透明度和问责制，反过来，这有助于确保没有任何个人或公司对项目有过多控制。
- en: This chapter introduces Node.js – including instructions on how to install the
    runtime and access the necessary documentation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Node.js – 包括如何安装运行时和访问必要文档的说明。
- en: 'This chapter will cover the following recipes:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Installing Node.js 22 with **nvm**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 **nvm** 安装 Node.js 22
- en: Accessing the Node.js API documentation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Node.js API 文档
- en: Adopting new JavaScript syntax in Node.js 22
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 22 中采用新的 JavaScript 语法
- en: Introducing the Node.js event loop
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Node.js 事件循环
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will require access to a terminal, a browser of your choice, and
    the internet.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将需要访问终端、您选择的浏览器和互联网。
- en: Installing Node.js 22 with nvm
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 nvm 安装 Node.js 22
- en: Node.js follows a release schedule and adopts a **long-term support** ( **LTS**
    ) policy. The release schedule is based on the **Semantic Versioning** ( [https://semver.org/](https://semver.org/)
    ) specification.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 遵循发布计划并采用 **长期支持**（**LTS**）策略。发布计划基于 **语义化版本控制**（[https://semver.org/](https://semver.org/)）规范。
- en: According to the Node.js release policy, Node.js undergoes two major updates
    annually, scheduled for April and October. These major releases may introduce
    alterations to the API that could potentially break compatibility. However, the
    Node.js project strives to keep the number and severity of such disruptive changes
    to a minimum, aiming to lessen any inconvenience for end users.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Node.js 发布策略，Node.js 每年进行两次主要更新，分别定于四月和十月。这些主要版本可能引入对 API 的更改，可能会破坏兼容性。然而，Node.js
    项目努力将此类破坏性更改的数量和严重性降到最低，旨在减少对最终用户的任何不便。
- en: Even-numbered major releases of Node.js are promoted to LTS after 6 months.
    Even-numbered releases are always scheduled for release in April and promoted
    to LTS in October. LTS releases are supported for up to 30 months. It is recommended
    to use LTS versions of Node.js in production. The purpose of the LTS schedule
    is to provide stability to end users and also to provide a predictable timeline
    of releases so that users can manage their upgrades appropriately. All LTS versions
    of Node.js are given codenames, named after elements. Node.js 22 will have the
    LTS codename “Jod”.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的偶数主版本发布6个月后升级为LTS版本。偶数版本总是计划在4月发布，并在10月升级为LTS。LTS版本支持长达30个月。建议在生产中使用Node.js的LTS版本。LTS发布计划的目的是为最终用户提供稳定性，同时也为用户提供一个可预测的发布时间表，以便用户可以适当地管理他们的升级。所有Node.js的LTS版本都有代号，以元素命名。Node.js
    22的LTS代号为“Jod”。
- en: Odd-numbered major releases are released in October and are only supported for
    6 months. Odd-numbered releases are mostly recommended to be used to try out new
    features and test the migration path but are not generally recommended for use
    in production applications.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 奇数主版本发布于10月，仅支持6个月。奇数版本主要推荐用于尝试新功能和测试迁移路径，但通常不建议在生产应用中使用。
- en: The Node.js Release Working Group has authority over the Node.js release schedule
    and processes. The Node.js release schedule and policy documentation can be found
    at [https://github.com/nodejs/release](https://github.com/nodejs/release) .
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js发布工作组负责Node.js的发布计划和流程。Node.js发布计划和政策的文档可以在[https://github.com/nodejs/release](https://github.com/nodejs/release)找到。
- en: In this book, we will be using Node.js 22 throughout. Node.js 22 was released
    in April 2024. Node.js 22 was promoted to LTS in October 2024 and is planned to
    be supported until April 2027. This recipe will cover how to install Node.js 22
    using **node version manager** ( **nvm** ). **nvm** is a project of the OpenJS
    Foundation and provides a convenient way to install and update Node.js versions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将全程使用Node.js 22。Node.js 22于2024年4月发布。Node.js 22于2024年10月升级为LTS版本，并计划支持至2027年4月。本食谱将涵盖如何使用**node版本管理器**（**nvm**）安装Node.js
    22。**nvm**是OpenJS基金会的一个项目，提供了一种方便的方式来安装和更新Node.js版本。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You may also need to have the appropriate permissions on your device to install
    **nvm** . This recipe assumes you’re on a Unix-like platform. If you’re on Windows,
    it should be run under Windows WSL.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还需要在您的设备上具有适当的权限来安装**nvm**。本食谱假设您在类Unix平台上。如果您在Windows上，应在Windows WSL下运行。
- en: How to do it…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we’re going to be installing Node.js 22 using **nvm** . Follow
    these steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用**nvm**安装Node.js 22。请按照以下步骤操作：
- en: 'First, we need to install **nvm** . **nvm** provides a script that can download
    and install **nvm** . Enter the following command in your terminal to execute
    the **nvm** installation script:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装**nvm**。**nvm**提供了一个可以下载和安装**nvm**的脚本。在您的终端中输入以下命令以执行**nvm**安装脚本：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**nvm** will automatically attempt to add itself to your path. Close and reopen
    your terminal to ensure the changes have taken place. Then, enter the following
    command to list the **nvm** version we have installed; this will also confirm
    that **nvm** is available in our path:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**nvm**将自动尝试将其自身添加到您的路径中。关闭并重新打开您的终端以确保更改已生效。然后，输入以下命令以列出我们已安装的**nvm**版本；这也会确认**nvm**是否在我们的路径中可用：'
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To install Node.js 22, we can use the **$ nvm install** command. We can supply
    either the specific version we wish to install or the major version number. If
    we specify just the major version number, **nvm** will install the latest release
    of that major release line. Enter the following command to install the latest
    version of Node.js 22:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装Node.js 22，我们可以使用**$ nvm install**命令。我们可以提供我们希望安装的特定版本或主版本号。如果我们只指定主版本号，**nvm**将安装该主版本线的最新版本。输入以下命令以安装Node.js
    22的最新版本：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that this command will install the latest version of Node.js 22, so your
    specific version install is likely to differ from that shown in the preceding
    output.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，此命令将安装Node.js 22的最新版本，因此您特定的版本安装可能与前面输出中显示的不同。
- en: 'The latest Node.js 22 version should now be installed and available in your
    path. You can confirm this by entering the following command:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Node.js 22的最新版本现在应该已安装并可在您的路径中使用。您可以通过输入以下命令来确认：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**nvm** will also install the version of **npm** that is bundled with the Node.js
    version you have installed. Enter the following command to confirm which version
    of **npm** is installed:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**nvm**还会安装与已安装的Node.js版本捆绑的**npm**版本。输入以下命令以确认已安装的**npm**版本：'
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**nvm** makes it easy to install and switch between multiple Node.js versions.
    We can enter the following command to install and switch to the latest Node.js
    20 version:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**nvm**使得安装和切换多个Node.js版本变得容易。我们可以输入以下命令来安装并切换到最新的Node.js 20版本：'
- en: '[PRE5]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we’ve got the versions installed, we can use the **nvm use** command to
    switch between them:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们安装了这些版本，我们可以使用**nvm use**命令在它们之间切换：
- en: '[PRE6]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With that, we’ve installed the latest version of Node.js 22 using **nvm** .
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就使用**nvm**安装了Node.js的最新版本22。
- en: How it works…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '**nvm** is a version manager for Node.js on Unix-like platforms and supports
    **Portable Operating System Interface** ( **POSIX** )-compliant shells. POSIX
    is a set of standards for operating system compatibility, defined by the IEEE
    Computer Society.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**nvm**是Unix-like平台上的Node.js版本管理器，并支持**可移植操作系统接口**（**POSIX**）兼容的shell。POSIX是一组由IEEE计算机协会定义的操作系统兼容性标准。'
- en: 'First, we downloaded and executed the **nvm** installation script. Under the
    hood, the **nvm** install script does the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们下载并执行了**nvm**安装脚本。在底层，**nvm**安装脚本执行以下操作：
- en: Clones the **nvm** GitHub repository ( [https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)
    ) to **~/.nvm/** .
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 克隆**nvm**GitHub仓库（[https://github.com/nvm-sh/nvm](https://github.com/nvm-sh/nvm)）到**~/.nvm/**。
- en: Attempts to add some source lines to import and load **nvm** into the appropriate
    profile file, where the profile file is either **~/.bash_profile** , **~/.bashrc**
    , **~/.profile** , or **~/.zshrc** .
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试向适当的配置文件中添加一些源行以导入和加载**nvm**，其中配置文件是**~/.bash_profile**、**~/.bashrc**、**~/.profile**或**~/.zshrc**。
- en: 'Should you use a profile file other than the ones mentioned previously, you
    may need to manually add the following lines to your profile file to load **nvm**
    . The following lines are specified in the **nvm** installation documentation
    ( [https://github.com/nvm-sh/nvm#install--update-script](https://github.com/nvm-sh/nvm#install--update-script)
    ):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是之前提到的以外的配置文件，你可能需要手动将以下行添加到你的配置文件中以加载**nvm**。以下行在**nvm**安装文档（[https://github.com/nvm-sh/nvm#install--update-script](https://github.com/nvm-sh/nvm#install--update-script)）中指定：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Each time you install a Node.js version using **$ nvm install** , **nvm** downloads
    the appropriate binary for your platform from the official Node.js download server.
    The official Node.js download server can be accessed directly at [https://nodejs.org/dist/](https://nodejs.org/dist/)
    . **nvm** will store all Node.js versions it has installed in the **~/.** **nvm/versions/node/**
    directory.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用**$ nvm install**安装Node.js版本时，**nvm**将从官方Node.js下载服务器下载适合你平台的相应二进制文件。官方Node.js下载服务器可以直接访问[https://nodejs.org/dist/](https://nodejs.org/dist/)。**nvm**将存储它安装的所有Node.js版本在**~/.nvm/versions/node/**目录中。
- en: '**nvm** supports aliases that can be used to install the LTS versions of Node.js.
    For example, you can use the **$ nvm install --lts** command to install the latest
    LTS release.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**nvm**支持别名，可以用来安装Node.js的长版本。例如，你可以使用**$ nvm install --lts**命令来安装最新的LTS版本。'
- en: To uninstall a Node.js version, you can use the **$ nvm uninstall** command.
    To change the default Node.js version, use the **$ nvm alias default <version>**
    command. The default version is the version that will be available when you open
    your terminal.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载一个Node.js版本，你可以使用**$ nvm uninstall**命令。要更改默认的Node.js版本，使用**$ nvm alias default
    <version>**命令。默认版本是在你打开终端时将可用的版本。
- en: If you do not wish to or are unable to use **nvm** , you can install Node.js
    manually. Visit the Node.js **Downloads** page (see [https://nodejs.org/en/download](https://nodejs.org/en/download)
    ) to download the appropriate binary for your platform.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用或无法使用**nvm**，你可以手动安装Node.js。访问Node.js的**下载**页面（见[https://nodejs.org/en/download](https://nodejs.org/en/download)）以下载适合你平台的相应二进制文件。
- en: The Node.js project provides TAR files for installation on many platforms. To
    install via a TAR file, you need to download and extract the TAR file, and then
    add the binary location to your path.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js项目为许多平台提供了安装用的TAR文件。要通过TAR文件安装，你需要下载并解压TAR文件，然后将二进制位置添加到你的路径中。
- en: Alongside TAR files, the Node.js project provides an installer for both macOS
    ( **.pkg** ) and Windows ( **.msi** ). As a result of installing Node.js manually,
    you will need to manually install updated versions of Node.js when you require
    them.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 TAR 文件外，Node.js 项目还为 macOS（**.pkg**）和 Windows（**.msi**）提供了安装程序。由于手动安装 Node.js，当您需要时，您将需要手动安装
    Node.js 的更新版本。
- en: There’s more…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息...
- en: As allowed by the Semantic Versioning specification, when upgrading from Node.js
    major versions, you may experience breaking changes that impact or stop how your
    script or application (including any dependencies) was executing under the prior
    version.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据语义化版本规范允许的情况，当从 Node.js 主版本升级时，您可能会遇到破坏性更改，这些更改可能会影响或停止您的脚本或应用程序（包括任何依赖项）在先前版本下的执行方式。
- en: 'Here are some recommendations for when you’re debugging upgrades:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试升级时，以下是一些建议：
- en: Review the major release’s release notes. These release notes will highlight
    any breaking changes, new or deprecated features, and important updates. Understanding
    what has changed can help you identify issues. Note that if you’re upgrading from/to
    Node.js LTS versions (for example, from Node.js 20 to 22), you should start by
    at least reviewing each of the interim major release changelogs – both 21.0.0
    and 22.0.0 .
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查阅主要版本的发布说明。这些发布说明将突出显示任何破坏性更改、新功能或已弃用功能以及重要更新。了解发生了什么变化可以帮助您识别问题。请注意，如果您是从/to
    Node.js LTS 版本升级（例如，从 Node.js 20 升级到 22），您应该首先至少查阅每个中间主要版本的变更日志——即 21.0.0 和 22.0.0。
- en: If you’re upgrading from a very old Node.js version, it may be wise to perform
    incremental upgrades through intermediate versions. This can make it easier to
    identify and address compatibility issues gradually. This is made easier when
    using a Node.js version manager such as **nvm** as you can run and test your code
    against different versions.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您是从非常旧的 Node.js 版本升级，通过中间版本进行增量升级可能是个明智的选择。这可以使识别和逐步解决兼容性问题变得更加容易。当使用如 **nvm**
    这样的 Node.js 版本管理器时，这会变得更容易，因为您可以在不同的版本上运行和测试您的代码。
- en: Review your project’s dependencies and ensure they are compatible with the new
    Node.js version. Outdated or unmaintained packages may not work correctly with
    the latest Node.js release.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查您项目的依赖项，并确保它们与新的 Node.js 版本兼容。过时或未维护的包可能无法与最新的 Node.js 版本正确工作。
- en: Create comprehensive test suites for your applications. Run your test suite
    before and after upgrading Node.js to ensure that your code behaves as expected.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的应用程序创建全面的测试套件。在升级 Node.js 之前和之后运行您的测试套件，以确保您的代码按预期运行。
- en: Use Node.js debugging tools. Node.js provides various diagnostic tools that
    can help you identify and resolve issues during an upgrade.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node.js 调试工具。Node.js 提供了各种诊断工具，可以帮助您在升级过程中识别和解决问题。
- en: Leverage online communities, forums, and documentation. Others in the Node.js
    community may have encountered similar issues during upgrades and can provide
    valuable insights and solutions. This could include raising a GitHub issue on
    one of the official Node.js repositories ( [https://github.com/nodejs/node](https://github.com/nodejs/node)
    or [https://github.com/nodejs/help](https://github.com/nodejs/help) ).
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用在线社区、论坛和文档。Node.js 社区中的其他人可能在升级过程中遇到过类似问题，并可以提供宝贵的见解和解决方案。这可能包括在官方 Node.js
    存储库之一上提出 GitHub 问题（[https://github.com/nodejs/node](https://github.com/nodejs/node)
    或 [https://github.com/nodejs/help](https://github.com/nodejs/help)）。
- en: Remember that debugging Node.js upgrades may require time and thorough testing.
    It’s essential to be prepared for potential challenges and have a plan in place
    to mitigate any disruptions to your application’s functionality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，调试 Node.js 升级可能需要时间和彻底的测试。为潜在挑战做好准备，并制定计划以减轻对应用程序功能可能造成的任何中断至关重要。
- en: Accessing the Node.js API documentation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 Node.js API 文档
- en: The Node.js project provides comprehensive API reference documentation. The
    Node.js API documentation is a critical resource for understanding which APIs
    are available in the version of Node.js that you’re using. The Node.js documentation
    also describes how to interact with APIs, including which arguments a given method
    accepts and the method’s return value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 项目提供了全面的 API 参考文档。Node.js API 文档是理解您正在使用的 Node.js 版本中哪些 API 可用的关键资源。Node.js
    文档还描述了如何与 API 交互，包括给定方法接受的参数和方法返回值。
- en: This recipe will show how to access and navigate the Node.js API documentation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南将展示如何访问和浏览 Node.js API 文档。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to a browser of your choice and an internet connection
    to access the Node.js API documentation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要访问你选择的浏览器和互联网连接来访问 Node.js API 文档。
- en: How to do it…
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'This recipe is going to demonstrate how to navigate the Node.js API documentation.
    Follow these steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将演示如何浏览 Node.js API 文档。按照以下步骤操作：
- en: First, navigate to [https://nodejs.org/api/](https://nodejs.org/api/) in your
    browser.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的浏览器中导航到 [https://nodejs.org/api/](https://nodejs.org/api/)。
- en: 'You’ll see the Node.js API documentation for the most recent version of Node.js:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到 Node.js API 文档的最新版本：
- en: '![Figure 1.1 – Node.js API documentation home page](img/B19212_01_01.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – Node.js API 文档首页](img/B19212_01_01.jpg)'
- en: Figure 1.1 – Node.js API documentation home page
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Node.js API 文档首页
- en: 'Hover over the **Other versions** dropdown to view the other release lines
    of Node.js. This is how you can change which version of Node.js you’re viewing
    the documentation for:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标悬停在 **Other versions** 下拉菜单上，查看 Node.js 的其他发布版本。这样你可以更改你正在查看文档的 Node.js 版本：
- en: '![Figure 1.2 – Node.js API documentation showing the Other versions dropdown](img/B19212_01_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 显示 Other versions 下拉菜单的 Node.js API 文档](img/B19212_01_02.jpg)'
- en: Figure 1.2 – Node.js API documentation showing the Other versions dropdown
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 显示 Other versions 下拉菜单的 Node.js API 文档
- en: 'Now, let’s suppose we want to find the documentation for the **fs.readFile()**
    method. The **fs.readFile()** method is exposed via the **File system** core module.
    First, we need to locate and click on **File system** in the left-hand navigation
    pane. Clicking **File system** will take us to the table of contents for the **File
    system** core module API documentation:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，假设我们想要找到 **fs.readFile()** 方法的文档。**fs.readFile()** 方法通过 **文件系统** 核心模块暴露。首先，我们需要在左侧导航栏中找到并点击
    **文件系统**。点击 **文件系统** 将带我们到 **文件系统** 核心模块 API 文档的目录：
- en: '![Figure 1.3 – Node.js API documentation for the File system subsystem](img/B19212_01_03.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – Node.js API 文档的文件系统子系统](img/B19212_01_03.jpg)'
- en: Figure 1.3 – Node.js API documentation for the File system subsystem
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – Node.js API 文档的文件系统子系统
- en: 'Scroll down until you find the **fs.readFile()** method listed in the table
    of contents. When looking for a specific API, it may be worthwhile using your
    browser’s search facility to locate the API definition. Click the **fs.readFile()**
    link in the table of contents. This will open the API definition:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动直到你在目录中找到列出的 **fs.readFile()** 方法。在寻找特定的 API 时，使用浏览器搜索功能定位 API 定义可能是有益的。点击目录中的
    **fs.readFile()** 链接。这将打开 API 定义：
- en: '![Figure 1.4 – Node.js API documentation showing the fs.readFile() API definition](img/B19212_01_04.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 显示 fs.readFile() API 定义的 Node.js API 文档](img/B19212_01_04.jpg)'
- en: Figure 1.4 – Node.js API documentation showing the fs.readFile() API definition
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 显示 fs.readFile() API 定义的 Node.js API 文档
- en: 'Now, click **Command-line options** in the left-hand navigation pane. This
    page details all the available command-line options that can be passed to the
    Node.js process:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击左侧导航栏中的 **命令行选项**。此页面详细介绍了可以传递给 Node.js 进程的所有可用命令行选项：
- en: '![Figure 1.5 – Node.js API documentation showing the available command-line
    options](img/B19212_01_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 显示可用命令行选项的 Node.js API 文档](img/B19212_01_05.jpg)'
- en: Figure 1.5 – Node.js API documentation showing the available command-line options
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 显示可用命令行选项的 Node.js API 文档
- en: With that, we’ve learned how to access and navigate the Node.js API documentation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经学会了如何访问和浏览 Node.js API 文档。
- en: How it works…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The Node.js API documentation is a vital reference resource when you’re building
    Node.js applications. The documentation is specific to each version of Node.js.
    In this recipe, we accessed the documentation for the most recent version of Node.js,
    which is the default version of the documentation that is rendered at [https://nodejs.org/api/](https://nodejs.org/api/)
    . The following URL can be used to access the documentation for a specific version
    of Node.js: [https://nodejs.org/docs/v22.0.0/api/index.html](https://nodejs.org/docs/v22.0.0/api/index.html)
    (substitute **v22.0.0** with the specific version you wish to view the documentation
    for).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js API文档是构建Node.js应用程序时的一个重要参考资源。文档针对Node.js的每个版本。在本食谱中，我们访问了Node.js最新版本的文档，这是在[https://nodejs.org/api/](https://nodejs.org/api/)渲染的默认文档版本。以下URL可以用来访问Node.js特定版本的文档：[https://nodejs.org/docs/v22.0.0/api/index.html](https://nodejs.org/docs/v22.0.0/api/index.html)（将**v22.0.0**替换为您希望查看文档的特定版本）。
- en: 'The API documentation details the usage of the Node.js APIs, including the
    following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: API文档详细说明了Node.js API的使用，包括以下内容：
- en: The accepted parameters and their types
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受的参数及其类型
- en: If applicable, the value and type that the API returns
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，API返回的值和类型
- en: In some cases, the documentation will provide further information, including
    a usage example or sample code demonstrating the usage of the API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，文档将提供更多信息，包括使用示例或示例代码来展示API的使用方法。
- en: Note that there are some undocumented APIs. Some Node.js APIs are intentionally
    undocumented as they are considered internal-only and are not intended for use
    outside of the Node.js core runtime.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有一些API没有文档。一些Node.js API有意未记录，因为它们被认为是仅限内部使用，并且不打算在Node.js核心运行时之外使用。
- en: 'The API documentation also details the stability of APIs. The Node.js project
    defines and uses the following four stability indices:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: API文档还详细说明了API的稳定性。Node.js项目定义并使用以下四个稳定性指标：
- en: '**0 – Deprecated** : Usage of these APIs is discouraged. Warnings may be emitted
    upon the usage of these APIs. Deprecated APIs will also be listed at [https://nodejs.org/docs/latest-v22.x/api/deprecations.html](https://nodejs.org/docs/latest-v22.x/api/deprecations.html)
    .'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0 – 已废弃**：不鼓励使用这些API。使用这些API时可能会发出警告。已废弃的API也将列在[https://nodejs.org/docs/latest-v22.x/api/deprecations.html](https://nodejs.org/docs/latest-v22.x/api/deprecations.html)。'
- en: '**1 – Experimental** : These APIs are not considered stable and may be subject
    to some non-backward-compatible changes. Experimental APIs are not subject to
    the Semantic Versioning rules. Usage of these APIs should be done with caution,
    especially in production environments. More recently, the “Experimental” status
    in the Node.js documentation has been broken down into multiple stages in an attempt
    to indicate the maturity of the features:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1 – 实验**：这些API被认为是不稳定的，可能会进行一些非向后兼容的更改。实验性API不受语义版本控制规则的限制。在生产和环境中使用这些API应谨慎进行。最近，Node.js文档中的“实验”状态已被分解为多个阶段，以尝试表明功能的成熟度：'
- en: '**1.0 -** **Early Development**'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1.0 -** **早期开发**'
- en: '**1.1 -** **Active Development**'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1.1 -** **活跃开发**'
- en: '**1.2 -** **Release Candidate**'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1.2 -** **候选发布版**'
- en: '**2 – Stable** : With stable APIs, the Node.js project will try to ensure compatibility.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2 – 稳定**：对于稳定的API，Node.js项目将尝试确保兼容性。'
- en: '**3 – Legacy** : Legacy features may be unmaintained or more modern alternatives
    may be available. However, they are unlikely to be removed and continue to abide
    by Semantic Versioning rules.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3 – 旧版**：旧版功能可能不再维护，或者可能有更现代的替代方案。然而，它们不太可能被移除，并继续遵守语义版本控制规则。'
- en: The Node.js documentation is maintained by the Node.js project in the Node.js
    core repository. Any errors or suggested improvements can be raised at [https://github.com/nodejs/node](https://github.com/nodejs/node)
    .
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js文档由Node.js项目在Node.js核心仓库中维护。任何错误或建议的改进都可以在[https://github.com/nodejs/node](https://github.com/nodejs/node)提出。
- en: There’s more…
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The Node.js project maintains a **.md** file for each release line of Node.js,
    detailing the individual commits that land in each release. The **CHANGELOG.md**
    file for Node.js 22 can be found at [https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V22.md](https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V22.md)
    .
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js项目为Node.js的每个发布分支维护一个**.md**文件，详细说明每个发布中包含的个别提交。Node.js 22的**CHANGELOG.md**文件可以在[https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V22.md](https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V22.md)找到。
- en: 'The following is a snippet from the Node.js 22 **CHANGELOG.md** file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从 Node.js 22 **CHANGELOG.md** 文件中的一个片段：
- en: '![Figure 1.6 – Example Node.js 22.0.0 CHANGELOG.md entry](img/B19212_01_06.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 示例 Node.js 22.0.0 CHANGELOG.md 条目](img/B19212_01_06.jpg)'
- en: Figure 1.6 – Example Node.js 22.0.0 CHANGELOG.md entry
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 示例 Node.js 22.0.0 CHANGELOG.md 条目
- en: The Node.js project highlights the notable changes in each release. The **CHANGELOG.md**
    file denotes which commits were determined to be **SEMVER-MINOR** according to
    the Semantic Versioning standard ( [https://semver.org/](https://semver.org/)
    ). Entries marked as **SEMVER-MINOR** indicate feature additions. The **CHANGELOG.md**
    file will also denote when a release is considered a security release (fixing
    a security issue). In the case of a security release, the **Notable Changes**
    section will start with the sentence **This is a** **security release.**
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 项目突出了每个版本中的显著变化。**CHANGELOG.md** 文件标明了哪些提交根据语义化版本控制标准（[https://semver.org/](https://semver.org/)）被确定为
    **SEMVER-MINOR**。标记为 **SEMVER-MINOR** 的条目表示功能添加。**CHANGELOG.md** 文件还将标明何时一个发布被认为是安全发布（修复了一个安全问题）。在安全发布的情况下，**显著变化**
    部分会以句子 **This is a** **security release.** 开头。
- en: For major releases, the Node.js project releases a release announcement on the
    Node.js website that details the new features and changes. The Node.js 22 release
    announcement is available at [https://nodejs.org/en/blog/announcements/v22-release-announce](https://nodejs.org/en/blog/announcements/v22-release-announce)
    .
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主要版本，Node.js 项目在 Node.js 网站上发布一个发布公告，详细说明新功能和变化。Node.js 22 版本的发布公告可在 [https://nodejs.org/en/blog/announcements/v22-release-announce](https://nodejs.org/en/blog/announcements/v22-release-announce)
    查找。
- en: Node.js **CHANGELOG.md** files can be used as a reference when upgrading Node.js,
    to help you understand what updates and changes are included in the new version.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级 Node.js 时，可以使用 Node.js **CHANGELOG.md** 文件作为参考，帮助你了解新版本中包含哪些更新和变化。
- en: Adopting new JavaScript syntax in Node.js 22
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Node.js 22 中采用新的 JavaScript 语法
- en: The formal specification for the JavaScript language is ECMAScript. New JavaScript
    features make their way into Node.js via updates to the underlying V8 JavaScript
    engine that the Node.js runtime is built on top of. ECMAScript has annual updates
    that provide new JavaScript language features and syntax.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 语言的正式规范是 ECMAScript。新的 JavaScript 功能通过更新 Node.js 所基于的底层 V8 JavaScript
    引擎而进入 Node.js。ECMAScript 每年都会更新，提供新的 JavaScript 语言特性和语法。
- en: New major versions of Node.js tend to include a significant upgrade to the V8
    engine. Node.js version 22.0.0 was released with V8 version 12.4. However, the
    V8 version may be upgraded during the lifetime of Node.js 22.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的新主要版本通常包括对 V8 引擎的重大升级。Node.js 版本 22.0.0 伴随着 V8 版本 12.4 的发布。然而，V8 版本可能会在
    Node.js 22 的生命周期内升级。
- en: Updated versions of V8 bring underlying performance improvements and new JavaScript
    language features and syntax to the Node.js runtime. This recipe will showcase
    a couple of the newer JavaScript language features that have been introduced in
    Node.js 22.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: V8 的更新版本为 Node.js 运行时带来了底层性能改进以及新的 JavaScript 语言特性和语法。本配方将展示 Node.js 22 中引入的一些较新的
    JavaScript 语言特性。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you will need to have Node.js 22 installed. You will also need
    to have access to a terminal.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，你需要安装 Node.js 22。你还需要能够访问终端。
- en: How to do it…
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we will be using the Node.js **Read Eval Print Loop** ( **REPL**
    ) to test out the newer JavaScript features that are available in Node.js 22.
    Follow these steps:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用 Node.js **Read Eval Print Loop** ( **REPL** ) 来测试 Node.js 22 中可用的较新
    JavaScript 功能。按照以下步骤操作：
- en: 'First, let’s open the Node.js REPL. Enter the following command in your terminal:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们打开 Node.js REPL。在你的终端中输入以下命令：
- en: '[PRE8]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This should open the REPL, which is an interface that we can use to execute
    code. Expect to see the following output:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该会打开 REPL，这是一个我们可以用来执行代码的接口。预期会看到以下输出：
- en: '![Figure 1.7 – Node.js REPL](img/B19212_01_07.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.7 – Node.js REPL](img/B19212_01_07.jpg)'
- en: Figure 1.7 – Node.js REPL
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – Node.js REPL
- en: 'Start by entering the following command. This command will return the version
    of V8 that is embedded in the Node.js version you’re using:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先输入以下命令。此命令将返回你使用的 Node.js 版本中嵌入的 V8 版本：
- en: '[PRE9]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Two new JavaScript **String** methods were made available since Node.js 20:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自 Node.js 20 以来，新增了两个 JavaScript **String** 方法：
- en: '**String.prototype.isWellFormed** : This method returns whether the supplied
    **String** is well-formed UTF-16'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**String.prototype.isWellFormed**：此方法返回提供的 **String** 是否是格式良好的 UTF-16'
- en: '**String.prototype.toWellFormed** : This method will replace unpaired surrogates
    with the **replacement character** ( **U+FFFD** ), thus making the UTF-16 String
    well-formed.'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**String.prototype.toWellFormed**：此方法将替换不成对的代理字符为**替换字符**（**U+FFFD**），从而使UTF-16字符串格式良好。'
- en: 'You can demonstrate this in the REPL:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在REPL中演示这一点：
- en: '[PRE10]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another recent feature addition is the **Intl.NumberFormat** built-in object,
    which provides language-based number formatting. Let’s test this out. In the REPL,
    declare a number:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个最近添加的功能是**Intl.NumberFormat**内置对象，它提供基于语言的数字格式化。让我们来测试一下。在REPL中声明一个数字：
- en: '[PRE11]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, let’s format that number as if it were the **Great British** **Pound**
    ( **GBP** ):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将这个数字格式化为**英国英镑**（**GBP**）的形式：
- en: '[PRE12]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In Node.js 22, new **Set** methods like **union** , **intersection** , and
    **difference** were added as part of the V8 12.4 update. These enhancements make
    it easier to perform operations on numeric sets. Here’s an example involving prime
    and odd numbers:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Node.js 22中，作为V8 12.4更新的部分，添加了新的**Set**方法，如**并集**、**交集**和**差集**。这些增强功能使得对数值集合的操作更加容易。以下是一个涉及质数和奇数的示例：
- en: '[PRE13]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using the REPL, we’ve explored a couple of the new JavaScript language features
    that are available in Node.js 22. The main goal of this learning is that new JavaScript
    language features become available through upgrading the underlying Google Chrome
    V8 engine.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用REPL，我们已经探索了Node.js 22中可用的几个新的JavaScript语言特性。这次学习的目标是通过升级底层Google Chrome V8引擎，使新的JavaScript语言特性变得可用。
- en: How it works…
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: New JavaScript language features are introduced into Node.js via updates to
    the underlying Google Chrome V8 JavaScript engine. A JavaScript engine parses
    and executes JavaScript code. The embedding of the Google Chrome V8 engine in
    Node.js is what enabled the execution of JavaScript outside of the browser. Chrome’s
    V8 JavaScript engine is one of many available JavaScript engines, with Mozilla’s
    SpiderMonkey, which is used in the Mozilla Firefox browser, being another leading
    JavaScript engine.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 新的JavaScript语言特性是通过更新底层Google Chrome V8 JavaScript引擎引入到Node.js中的。JavaScript引擎解析并执行JavaScript代码。将Google
    Chrome V8引擎嵌入到Node.js中使得在浏览器之外执行JavaScript成为可能。Chrome的V8 JavaScript引擎是许多可用的JavaScript引擎之一，Mozilla的SpiderMonkey也是另一个主要的JavaScript引擎，它被用于Mozilla
    Firefox浏览器。
- en: Every 6 weeks, a new version of Google Chrome’s V8 engine is released. Node.js
    22 will continue to incorporate updates into V8, provided they can be made **application
    binary interface** ( **ABI** )-compatible. An ABI describes how programs can interact
    with functions and data structures via compiled programs. It can be considered
    similar to a compiled version of an **application programming** **interface**
    ( **API** ).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 每6周，Google Chrome的V8引擎就会发布一个新版本。Node.js 22将继续将更新整合到V8中，前提是它们可以与**应用程序二进制接口**（**ABI**）兼容。ABI描述了程序如何通过编译程序与函数和数据结构交互。它可以被认为是**应用程序编程接口**（**API**）的编译版本。
- en: Once there is a release of V8 that no longer allows ABI compatibility, the specific
    release line of Node.js will be fixed on that version of V8. However, specific
    V8 patches and fixes may continue to be applied directly to that Node.js release
    line. Node.js 20 is now fixed on V8 version 11.3, whereas Node.js 22, at the time
    of writing, is at V8 12.4. The V8 version in Node.js 22 will continue to be updated
    until ABI compatibility of newer versions of V8 can no longer be maintained.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦发布了一个不再允许ABI兼容性的V8版本，Node.js的具体发布线将固定在那个版本的V8上。然而，具体的V8补丁和修复可能继续直接应用于那个Node.js发布线。目前，Node.js
    20已固定在V8版本11.3上，而Node.js 22在撰写本文时处于V8 12.4。Node.js 22中的V8版本将继续更新，直到无法再维护新版本的V8的ABI兼容性。
- en: The V8 JavaScript engine compiles JavaScript internally using **just-in-time**
    ( **JIT** ) compilation. JIT compilation speeds up the execution of JavaScript.
    While V8 is executing JavaScript, it obtains data about the code that is being
    executed. From this data, the V8 engine can make speculative optimizations. Speculative
    optimizations anticipate the upcoming code based on the code that has recently
    been executed. This allows the V8 engine to optimize for the upcoming code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: V8 JavaScript引擎使用**即时编译**（**JIT**）内部编译JavaScript。JIT编译加速了JavaScript的执行。当V8执行JavaScript时，它会获取有关正在执行的代码的数据。从这个数据中，V8引擎可以进行推测性优化。推测性优化根据最近执行的代码预测即将到来的代码。这允许V8引擎为即将到来的代码进行优化。
- en: The V8 blog provides announcements of new V8 releases and details the new features
    and updates to V8. The V8 blog can be accessed at [https://v8.dev/blog](https://v8.dev/blog)
    .
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: V8博客提供了新V8发布的公告，并详细介绍了V8的新功能和更新。V8博客可通过[https://v8.dev/blog](https://v8.dev/blog)访问。
- en: Introducing the Node.js event loop
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Node.js事件循环
- en: The Node.js event loop is a fundamental concept in Node.js that enables it to
    perform asynchronous and non-blocking operations efficiently. It’s a mechanism
    that’s responsible for managing the execution of code in an event-driven environment.
    Understanding the Node.js event loop is crucial for building scalable and responsive
    applications, especially when dealing with input/output-bound tasks such as reading
    files, making network requests, or handling multiple client connections simultaneously.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js事件循环是Node.js中的一个基本概念，它使Node.js能够高效地执行异步和非阻塞操作。这是一个负责在事件驱动环境中管理代码执行机制的机制。理解Node.js事件循环对于构建可扩展和响应式的应用程序至关重要，尤其是在处理如读取文件、发起网络请求或同时处理多个客户端连接等I/O密集型任务时。
- en: Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have Node.js 22 installed. You will also need to have access
    to a terminal.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要安装Node.js 22。你还需要能够访问终端。
- en: How to do it…
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will create two files. One will demonstrate us blocking
    the event loop, while the other will demonstrate not blocking the event loop.
    Follow these steps:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建两个文件。一个将演示如何阻塞事件循环，而另一个将演示如何不阻塞事件循环。按照以下步骤操作：
- en: Create a file named **blocking.js** .
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **blocking.js** 的文件。
- en: 'Add the following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE14]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the script and observe how it waits on the blocking operation:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本并观察它是如何等待阻塞操作的：
- en: '[PRE15]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This script demonstrates a blocking operation by using a synchronous loop that
    keeps the CPU busy. When you run the script, you’ll notice that it logs **Start
    blocking operation** , executes the blocking loop, and finally logs **End blocking
    operation** and **After** **blocking operation** .
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此脚本通过使用保持CPU忙碌的同步循环来演示阻塞操作。当你运行脚本时，你会注意到它记录 **Start blocking operation** ，执行阻塞循环，并最终记录
    **End blocking operation** 和 **After blocking operation** 。
- en: Now, let’s implement a non-blocking script. Create a file named **non-blocking.js**
    .
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个非阻塞脚本。创建一个名为 **non-blocking.js** 的文件。
- en: 'Add the following code:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE16]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the script and observe how it executes:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本并观察其执行情况：
- en: '[PRE17]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This script demonstrates a non-blocking operation using the **setTimeout** function,
    which implements a delay of at least 2 seconds. When you run this script, it logs
    **Before non-blocking operation** , schedules the timeout, immediately logs **After
    non-blocking operation** , and then, after 2 seconds, logs **Non-blocking operation
    completed** . This example demonstrates that during the 2-second delay, Node.js
    remains responsive and can continue with other tasks, showing that this operation
    is non-blocking.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此脚本通过使用 **setTimeout** 函数演示了非阻塞操作，该函数实现了至少2秒的延迟。当你运行此脚本时，它会记录 **Before non-blocking
    operation** ，安排超时，立即记录 **After non-blocking operation** ，然后，在2秒后，记录 **Non-blocking
    operation completed** 。这个例子演示了在2秒的延迟期间，Node.js 保持响应，可以继续执行其他任务，这表明此操作是非阻塞的。
- en: Let’s demonstrate the Node.js event loop with **process.nextTick()** . To do
    so, create a file named **next-tick.js** .
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过 **process.nextTick()** 来演示Node.js事件循环。为此，创建一个名为 **next-tick.js** 的文件。
- en: 'Add the following code to **next-tick.js** :'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 **next-tick.js** 中：
- en: '[PRE18]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the program and observe the order of how they’re executed:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并观察它们的执行顺序：
- en: '[PRE19]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The **Start** and **End** log statements are executed immediately because they
    are part of the main code execution. The two callbacks that are scheduled with
    **process.nextTick()** are executed before any other scheduled callbacks, before
    the **setTimeout** callback. This is because **process.nextTick()** callbacks
    have the highest priority and run at the beginning of the next event loop cycle.
    After the **process.nextTick()** callbacks are executed, the **setTimeout** callback
    is executed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**Start** 和 **End** 记录语句立即执行，因为它们是主代码执行的一部分。使用 **process.nextTick()** 安排的两个回调在所有其他安排的回调之前执行，在
    **setTimeout** 回调之前。这是因为 **process.nextTick()** 回调具有最高优先级，并在下一个事件循环周期的开始处运行。在
    **process.nextTick()** 回调执行后，**setTimeout** 回调才会执行。'
- en: How it works…
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Node.js operates in a single-threaded environment, meaning it uses a single
    main thread of execution for your JavaScript code. However, Node.js can still
    handle many concurrent operations by leveraging asynchronous, non-blocking I/O.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js在单线程环境中运行，这意味着它使用单个主执行线程来执行您的JavaScript代码。然而，Node.js可以通过利用异步、非阻塞I/O来处理许多并发操作。
- en: Node.js is event-driven, which means it relies on events and callbacks to execute
    code in response to various actions or events. Events can be I/O operations (for
    example, reading files or making network requests), timers, or custom events triggered
    by your code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js是事件驱动的，这意味着它依赖于事件和回调来响应各种操作或事件执行代码。事件可以是I/O操作（例如，读取文件或发起网络请求），定时器，或由您的代码触发的自定义事件。
- en: 'There are some key concepts to understand about Node.js’s handling of I/O:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Node.js处理I/O有一些关键概念需要理解：
- en: '**Non-blocking** : Node.js not waiting for each operation to complete before
    moving on is referred to as non-blocking. Node.js can handle multiple tasks concurrently,
    making it highly efficient for I/O-bound operations.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞**：Node.js在操作完成之前不会等待每个操作，这被称为非阻塞。Node.js可以同时处理多个任务，使其在I/O密集型操作中非常高效。'
- en: '**Event queue** : When you perform an asynchronous operation, such as reading
    a file, Node.js doesn’t block the entire program. Instead, it puts these operations
    in a queue known as the **event queue** and continues with other tasks.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件队列**：当您执行异步操作，如读取文件时，Node.js不会阻塞整个程序。相反，它将这些操作放入一个称为**事件队列**的队列中，并继续执行其他任务。'
- en: '**Event loop** : The **event loop** keeps running and checking the event queue.
    If there’s an operation in the queue that has completed (for example, a file has
    finished being read), it will execute a callback function associated with that
    operation.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件循环**：**事件循环**持续运行并检查事件队列。如果队列中有完成的操作（例如，文件读取完成），它将执行与该操作关联的回调函数。'
- en: '**Callback functions** : When an asynchronous operation is initiated, you usually
    provide a callback function. This function gets called when the operation is finished.
    For example, if you’re reading a file, the callback function will handle what
    to do with the file’s contents once it’s available.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回调函数**：当启动异步操作时，您通常会提供一个回调函数。当操作完成时，该函数会被调用。例如，如果您正在读取文件，回调函数将处理文件内容可用时的操作。'
- en: '**libuv** ( [https://libuv.org/](https://libuv.org/) ) serves as the underlying
    library that powers the Node.js event loop by providing a platform-agnostic, efficient,
    and concurrent I/O framework. It enables Node.js to achieve its non-blocking,
    asynchronous nature while maintaining compatibility across various operating systems.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**libuv** ([https://libuv.org/](https://libuv.org/))作为底层库，通过提供跨平台的、高效的、并发的I/O框架来为Node.js事件循环提供动力。它使Node.js能够在各种操作系统上保持兼容性的同时，实现非阻塞、异步的特性。'
- en: There’s more
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容
- en: The Node.js event loop operates a flow of phases. Deeply understanding this
    flow is important when it comes to debugging, performance, and making the most
    of Node.js’ non-blocking approach.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js事件循环操作一系列阶段。深入理解这一流程对于调试、性能优化以及充分利用Node.js的非阻塞方法至关重要。
- en: When the Node.js process starts, the event loop is initialized and the input
    script is processed. The event loop will continue until nothing is pending in
    the event loop or **process.exit()** is explicitly called.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当Node.js进程启动时，事件循环被初始化，并处理输入脚本。事件循环将持续运行，直到事件循环中没有待处理项或显式调用**process.exit()**。
- en: 'The event loop phases are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环阶段如下：
- en: '**Timers phase** : This phase checks for any scheduled timers that need to
    be executed. These timers are typically created using functions such as **setTimeout()**
    or **setInterval()** . If a timer’s specified time has passed, its callback function
    is added to the I/O polling phase.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时器阶段**：此阶段检查是否有需要执行的已计划定时器。这些定时器通常使用如**setTimeout()**或**setInterval()**等函数创建。如果定时器指定的时长已过，其回调函数将被添加到I/O轮询阶段。'
- en: '**Pending callbacks phase** : In this phase, the event loop checks for events
    that have completed (or errored) their I/O operations. This includes, for example,
    filesystem operations, network requests, and user events. If any of these operations
    have been completed, their callback functions are executed during this phase.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**待处理回调阶段**：在此阶段，事件循环检查已完成（或出错）I/O操作的事件。这包括例如文件系统操作、网络请求和用户事件。如果这些操作中的任何一项已完成，它们的回调函数将在这一阶段执行。'
- en: '**Idle and prepare phases** : These phases are rarely used in typical application
    development and are typically reserved for special use cases. The idle phase runs
    callbacks that are scheduled to execute during the idle period, whereas the prepare
    phase is used to prepare for poll events.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空闲和准备阶段**：这些阶段在典型应用开发中很少使用，通常保留用于特殊用例。空闲阶段运行在空闲期间安排执行的回调函数，而准备阶段用于为轮询事件做准备。'
- en: '**Poll phase** : The poll phase is where most of the action happens in the
    event loop. It performs the following tasks:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮询阶段**：轮询阶段是事件循环中大多数动作发生的地方。它执行以下任务：'
- en: Checks for new I/O events (for example incoming data on a socket) and executes
    their callbacks if any are ready.
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查新的 I/O 事件（例如套接字上的传入数据）并执行其回调函数（如果有的话）。
- en: If no I/O events are pending, it checks the callback queue for pending callbacks
    scheduled by timers or **setImmediate()** . If any are found, they are executed.
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有挂起的 I/O 事件，它将检查回调队列，以查找由计时器或 **setImmediate()** 安排的挂起回调。如果找到任何，它们将被执行。
- en: If there are no pending I/O events or callbacks, the event loop may enter a
    blocking state waiting for new events to arrive. This is called “polling.”
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有挂起的 I/O 事件或回调函数，事件循环可能会进入阻塞状态，等待新事件到来。这被称为“轮询”。
- en: '**Check phase** : In this phase, callbacks registered with **setImmediate()**
    are executed. Any callbacks are executed after the current poll phase but before
    any I/O callbacks.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查阶段**：在这个阶段，使用 **setImmediate()** 注册的回调函数将被执行。任何回调函数都会在当前的轮询阶段之后执行，但在任何
    I/O 回调函数之前。'
- en: '**Close callbacks phase** : This phase is responsible for executing close event
    callbacks, such as those registered with the **socket.on(''close'', ...)** event.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭回调阶段**：这个阶段负责执行关闭事件回调，例如使用 **socket.on(''close'', ...)** 事件注册的回调。'
- en: After completing all these phases, the event loop checks if there are any pending
    timers, I/O operations, or other events. If there are, it goes back to the appropriate
    phase to handle them. Otherwise, if there are no further pending events, the Node.js
    process ends.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些阶段后，事件循环检查是否有挂起的计时器、I/O 操作或其他事件。如果有，它将回到适当的阶段来处理它们。如果没有进一步的挂起事件，Node.js
    进程将结束。
- en: '**process.nextTick()** is not detailed in the phases. This is because **process.nextTick()**
    schedules the provided callback function to run on the next tick of the event
    loop. Importantly, this callback function is executed with higher priority than
    other asynchronous operations. The **process.nextTick()** callback is executed
    after the current phase of the event loop is complete but before the event loop
    moves on to the next phase. This allows you to schedule tasks so that they run
    with higher priority, making it useful for ensuring that certain functions run
    immediately after the current operation.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**process.nextTick()** 在阶段中未详细说明。这是因为 **process.nextTick()** 将提供的回调函数安排在事件循环的下一次
    tick 上运行。重要的是，这个回调函数的执行优先级高于其他异步操作。**process.nextTick()** 回调函数在事件循环的当前阶段完成后执行，但在事件循环移动到下一个阶段之前。这允许你安排任务以更高的优先级运行，这使得它在确保某些函数在当前操作之后立即运行时非常有用。'
