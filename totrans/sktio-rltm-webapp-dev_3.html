<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Let's Chat"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Let's Chat</h1></div></div></div><p>Beginning with Yahoo! Chat in the early 2000 and up to today's popular Google Talk or Facebook Chat, chatting has been the most popular form of real-time communication on the Internet. <a id="id89" class="indexterm"/>In this chapter, we will build a chat room using node and express, which we learned in the previous chapter, and the socket.io library that we will learn in this chapter.</p><div class="section" title="Creating the application"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Creating the application</h1></div></div></div><p>Similar to the way we <a id="id90" class="indexterm"/>created our application in the previous chapter, we will create a new <code class="literal">awesome-chat</code> application by executing the following commands in the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ express awesome-chat</strong></span>
<span class="strong"><strong>$ cd awesome-chat</strong></span>
<span class="strong"><strong>$ npm install</strong></span>
</pre></div><p>This will create our application and install the express application dependencies. Open the <code class="literal">package.json</code> file and change the name to <code class="literal">awesome-chat</code>, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">{ 
  "name": "awesome-chat", 
  "version": "0.0.1", 
  "private": true, 
  "scripts": { 
    "start": "node app" 
  }, 
  "dependencies": { 
    "express": "3.0.0rc2express": "3.x", 
    "jade": "*" 
  } 
}</pre></div></div></div>
<div class="section" title="Designing the chat room"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Designing the chat room</h1></div></div></div><p>Let's modify<a id="id91" class="indexterm"/> the view to make it look like a chat room. We will need an area to display the messages, a text input for the user to enter the message, and a button to send the message. We will add some aesthetic elements, such as a header, banner, and footer. When we are done, our chat room user interface should look like the one shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/0786_03_01.jpg" alt="Designing the chat room"/><div class="caption"><p>Awesome chat UI</p></div></div><p>Let's start editing <code class="literal">layout.jade</code> by adding a header and footer to it:</p><div class="informalexample"><pre class="programlisting">doctype 5 
html 
<span class="strong"><strong>  block head </strong></span>
    title= title 
    link(rel='stylesheet', href='/stylesheets/style.css') 
  body 
<span class="strong"><strong>    header#banner </strong></span>
<span class="strong"><strong>      h1 Awesome Chat </strong></span>
    block content 
    footer Hope you enjoy your stay here</pre></div><p>The first change we make is to add the <code class="literal">block</code> keyword before <code class="literal">head</code>. This makes <code class="literal">head</code> a block, to which we can append content from the extending pages.</p><p>The other change is the addition of a new header and footer. Note that we are using the <code class="literal">header</code> and <code class="literal">footer</code> tags from HTML5. This code also introduces us to a new jade syntax. When we write <code class="literal">header#banner</code>, it will generate headers with <code class="literal">banner</code> as the <code class="literal">id</code> value. The generated HTML code will be as follows:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;{TITLE}&lt;/title&gt;
    &lt;link rel="stylesheet" href="/stylesheets/style.css" /&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;header id="banner"&gt;
      &lt;h1&gt;Awesome Chat&lt;/h1&gt;
    &lt;/header&gt;
    {CONTENT}
    &lt;footer&gt;
      Hope you enjoy your stay here
    &lt;/footer&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>Next, we will edit <code class="literal">index.jade</code> to add the message area, message input, and the <span class="strong"><strong>Send</strong></span> button:<a id="id92" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">extends layout 
block content 
  section#chatroom
    div#messages 
    input#message(type='text', placeholder='Enter your message here') 
    input#send(type='button', value='Send')</pre></div><p>Let's run and see what our <code class="literal">awesome-chat</code> application looks like. Execute the application using <code class="literal">npm</code> and open <code class="literal">http://localhost:3</code>
<code class="literal">000/</code> in the browser:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm start</strong></span>
</pre></div><p>Hey, all the elements are there, but it doesn't look right! That's correct; to improve the look and feel of the application, we need to edit the stylesheet, which is located at <code class="literal">public/stylesheets/style.css</code>.</p><p>We can edit it according to our taste. Here is one that works just fine for me:</p><div class="informalexample"><pre class="programlisting">html { 
  height: 100%; 
} 

body { 
  font: 14px "Lucida Grande", Helvetica, Arial, sans-serif; 
  margin: 0px; 
  padding: 0px; 
  height: -moz-calc(100% - 20px); 
  height: -webkit-calc(100% - 20px); 
  height: calc(100% - 20px); 
} 

section#chatroom { 
  height: -moz-calc(100% - 80px); 
  height: -webkit-calc(100% - 80px); 
  height: calc(100% - 80px); 
  background-color: #EFFFEC; 
} 

div#messages { 
  height: -moz-calc(100% - 35px); 
  height: -webkit-calc(100% - 35px); 
  height: calc(100% - 35px); 
  padding: 10px; 
  -moz-box-sizing:border-box; 
  -webkit-box-sizing:border-box; 
  box-sizing:border-box; 
} 

input#message { 
  width: -moz-calc(100% - 80px); 
  width: -webkit-calc(100% - 80px); 
  width: calc(100% - 80px); 
} 

input#send { 
  width: 74px; 
} 

header{ 
  background-color:#4192C1; 
  text-align: right; 
  margin-top: 15px; 
} 

header h1{ 
  padding: 5px; 
  padding-right: 15px; 
  color: #FFFFFF; 
  margin: 0px; 
} 
footer{ 
  padding: 6px; 
  background-color:#4192C1; 
  color: #FFFFFF; 
  bottom: 0; 
  position: absolute; 
  width: 100%; 
  margin: 0px; 
  margin-bottom: 10px; 
  -moz-box-sizing:border-box; 
  -webkit-box-sizing:border-box; 
  box-sizing:border-box; 
} 

a { 
  color: #00B7FF; 
}</pre></div><a id="id93" class="indexterm"/><p>After saving this CSS and refreshing the page, here is what the chat room looks like:</p><div class="mediaobject"><img src="graphics/0786_03_02.jpg" alt="Designing the chat room"/><div class="caption"><p>The awesome chat room</p></div></div></div>
<div class="section" title="Bringing in jQuery"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Bringing in jQuery</h1></div></div></div><p>jQuery is almost ubiquitous when it comes to JavaScript libraries, and we will use it in our application too.<a id="id94" class="indexterm"/> To add jQuery to our application, let's download the latest release from <a class="ulink" href="http://www.jquery.com/">http://www.jquery.com/</a> and save it to <code class="literal">public/javascript/jquery.min.js</code>. Then, we add the script in <code class="literal">layout.jade</code> to pull in jQuery to our application's pages:</p><div class="informalexample"><pre class="programlisting">    script(type='text/javascript', src='/javascripts/jquery.min.js')</pre></div></div>
<div class="section" title="Socket.IO"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Socket.IO</h1></div></div></div><p>Ever since<a id="id95" class="indexterm"/> the onset of web applications, developers have worked towards different ways of getting duplex communication between the server and the browser. Be it using Java, Flash, Comet, or many other workarounds, all aim to do the same. But for the first time, there is a specification to build a full-duplex communication system by using HTML5 WebSockets. <span class="strong"><strong>WebSocket</strong></span> is a revolutionary, new communication feature in the HTML5 specification that defines a full-duplex communication channel operating over the Web through a single socket.</p><p>Although the WebSockets RFC is published, it is not, and will never be, available on older browsers that are still in use. Socket.io is an abstraction layer for WebSockets, with Flash, XHR, JSONP, and HTMLFile fallbacks. Socket.io provides an easy server and client library for making real-time, streaming updates between a web server and a browser client.</p><p>Socket.io is a node module available through the npm, and we will add it to our package dependencies. The current release of socket.io is <code class="literal">0.9.10</code>. To add this to our dependencies, add the following line to the dependencies object in <code class="literal">package.json</code>:</p><div class="informalexample"><pre class="programlisting">    "socket.io": "0.9.10"</pre></div><p>And install it using the npm:</p><div class="informalexample"><pre class="programlisting">$ npm install</pre></div><p>This will bring socket.io in the <code class="literal">node_modules</code> folder. Now let's see how we will use it.</p></div>
<div class="section" title="Handling events"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Handling events</h1></div></div></div><p>Since the socket.io framework has components for both the server and the client, we will use these components to code our communication on both the sides. Events emitted on a socket on one side will be handled by the corresponding event handler on the other side. Socket.io is built so that both the sides can send messages or attach handlers to process the incoming messages.<a id="id96" class="indexterm"/>
</p><p>Let's begin by understanding how the messages will flow. It is important to remember that "messages" here are not the actual messages sent and received by users of the chat system, but the messages used for communication by the client and the server. There will be two types of messages, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The system messages</strong></span><a id="id97" class="indexterm"/>: These messages will be sent by our chat system to the client, like when the user is connected, when others connect, or when users disconnect. Let's identify it with <code class="literal">serverMessage</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The user messages</strong></span><a id="id98" class="indexterm"/>: These messages will be sent by the client to the server and will actually carry the user's message content in the payload. We will probably want to differentiate between the messages we send and the messages other users send. So let's call them <code class="literal">myMessage</code> and <code class="literal">userMessage</code> respectively.</li></ul></div><p>When a user connects for the first time, the server will send a welcome message to the user as a <code class="literal">serverMessage</code> message.</p><p>When a user types in a message and presses the <span class="strong"><strong>Send</strong></span> button, we will send a <code class="literal">userMessage</code> message from the browser to the server.</p><p>On receiving the user message, the server will broadcast this message to all the other users. It will also send back the same message as <code class="literal">myMessage</code> to the user who originally sent the message.<a id="id99" class="indexterm"/>
</p><p>On receiving any message from the server, the browser will display the contents of the message in the message area.</p></div>
<div class="section" title="The server"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec29"/>The server</h1></div></div></div><p>Now we will implement the server, which will perform the task of relaying the messages, as already mentioned. Create a file in the <code class="literal">routes</code> folder called <code class="literal">sockets.js</code> and insert the following code into it:<a id="id100" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var io = require('socket.io'); 

exports.initialize = function(server) { 
  io = io.listen(server); 
  io.sockets.on("connection", function(socket){ 
    socket.send(JSON.stringify(
      {type:'serverMessage', 
        message: 'Welcome to the most interesting chat room on earth!'})); 
    socket.on('message', function(message){ 
      message= JSON.parse(message); 
      if(message.type == "userMessage"){ 
        socket.broadcast.send(JSON.stringify(message)); 
        message.type = "myMessage"; 
        socket.send(JSON.stringify(message)); 
      } 
    }); 
  }); 
};</pre></div><p>In the first line of code (you must be familiar with this by now), we import the <code class="literal">socket.io</code> module; we will identify this module by the <code class="literal">io</code> variable.</p><p>Since socket.io works with the communication layer, we need to set it up to listen to the HTTP server. The HTTP server can only be accessed from the main application module, so we have to pass <code class="literal">server</code> to our module before our module can do anything. Hence, we export a method called <code class="literal">initialize</code> from our module, which will set up the socket.io server and also bind all the message handlers:</p><div class="informalexample"><pre class="programlisting">exports.initialize = function(server) { 
  //work to do
}</pre></div><p>The <code class="literal">initialize</code> method will accept the HTTP <code class="literal">server</code> object as a parameter. This is required by socket.io:</p><div class="informalexample"><pre class="programlisting">  io = io.listen(server);</pre></div><a id="id101" class="indexterm"/><p>On the first line of the method, we will pass the server to the socket.io module's <code class="literal">listen</code> method<a id="id102" class="indexterm"/>. The server is an instance of the node HTTP server module; socket.io will configure various handlers on this server. This is the only boilerplate code required to set up socket.io. Next, we need to set up our message handler for socket.io messages.</p><p>The first event<a id="id103" class="indexterm"/> that our server will receive is a new connection from a new client. This is identified by the <code class="literal">connection</code> event on the <code class="literal">io.sockets</code> object and notifies our application that a new client has opened a new connection and all the protocol negotiation (transparent to us) has been completed and now we have a socket to communicate with this client:</p><div class="informalexample"><pre class="programlisting">  io.sockets.on("connection", function(socket){ 
  //Add other event handlers to the socket
  }); </pre></div><p>The <code class="literal">connection</code> event handler will be triggered, passing along the socket that was just established. The socket is an event emitter that can trigger different events based on the messages it gets, and we will use this socket also to communicate with the client for which it was created. There are several events exposed, such as the <code class="literal">connection</code> event to handle events on the server. Let's take a quick look at these events:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">io.sockets.on('connection', function(socket) {})</code>: Initial connection from a client. The <code class="literal">socket</code> argument should be used in further communication with the client.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('message', function(message, callback) {})</code>: The <code class="literal">message</code> handler is triggered when a message sent with <code class="literal">socket.send</code> is received. The <code class="literal">message</code> parameter is the message sent, and <code class="literal">callback</code> is an optional acknowledgment function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('anything', function(data) {})</code>: The <code class="literal">anything</code> event can be any event except the reserved events.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('disconnect', function() {})</code>: This event is fired when the socket disconnects.</li></ul></div><p>Now that we have seen how to handle the socket events, let's see how we can send messages from the server to the client:</p><div class="informalexample"><pre class="programlisting">    socket.send(JSON.stringify(
      {type:'serverMessage', 
        message: 'Welcome to the most interesting chat room on earth!'})); </pre></div><p>The <code class="literal">socket.send</code> method<a id="id104" class="indexterm"/> will send the message on the socket, which will be triggering the <code class="literal">message</code> event on the client. The message sent has to be a string, so we will use <code class="literal">JSON.stringify</code> to send the data for the message as a string. Here our message has two parts, a type and a message.</p><p>One part of our task is over, we are now able to welcome the user. The next task is to handle the user messages when they come in. For this, we set a <code class="literal">message</code> event handler on the socket:</p><div class="informalexample"><pre class="programlisting">  socket.on('message', function(message){ 
      message= JSON.parse(message); 

      if(message.type == "userMessage"){ 
        socket.broadcast.send(JSON.stringify(message)); 
        message.type = "myMessage"; 
        socket.send(JSON.stringify(message)); 
      } 
    }); </pre></div><p>Just like any other <a id="id105" class="indexterm"/>event connector, <code class="literal">socket.on</code> will take two parameters, namely the event to handle and the event handler for it. In this case, unlike the <code class="literal">io.sockets.on</code> event<a id="id106" class="indexterm"/>, this event handler will receive the message as the parameter and not the socket.</p><p>Since the message is a string, we will parse the message's JSON string to create a <code class="literal">message</code> object. If this is a message sent by the user, this message will be of the type <code class="literal">userMessage</code>, and that is what we check.</p><p>Now, we have to send out this message to all the connected users. For this, socket.io provides us with a <code class="literal">broadcast</code> object. When we send the message using the <code class="literal">broadcast</code> object, it will be sent to all the clients that are connected, except to the one for which this socket was created. The syntax for sending the message here is the same; the difference is that it is called on the <code class="literal">broadcast</code> object, referred to as message flags in socket.io, instead of the socket itself.</p><p>Also, we want to send back the same content to the client that sent this message, but just change the type to <code class="literal">myMessage</code>. For this, we send the message directly on the socket.</p><p>That's it. We have written the code for the server; but now we have to actually initialize this server. To do this, modify the server creation in <code class="literal">app.js</code> to set the <code class="literal">server</code> variable, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var server = http.createServer(app).listen(app.get('port'),</strong></span>
<span class="strong"><strong>  function(){ </strong></span>
    console.log("Express server listening on port " + app.get('port')); 
});</pre></div><a id="id107" class="indexterm"/><p>Now that we have modified the HTTP server, we can call the socket module's <code class="literal">initialize</code> method<a id="id108" class="indexterm"/>, passing this server as a parameter to it. Add the following line to the end of <code class="literal">app.js</code>:</p><div class="informalexample"><pre class="programlisting">require('./routes/sockets.js').initialize(server);</pre></div></div>
<div class="section" title="The client"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec30"/>The client</h1></div></div></div><p>Now that we have seen how the server works, let's see what the client does. The best part of socket.io is that it provides us the same API on the server and the client. For our chat logic on the client, let's create a file called <code class="literal">chat.js</code> in the <code class="literal">public/javascripts</code> folder and add the following code to it:<a id="id109" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">var socket = io.connect('/'); 

socket.on('message', function (data) { 
  data = JSON.parse(data); 
  $('#messages').append('&lt;div class="'+data.type+'"&gt;' + data.message + '&lt;/div&gt;'); 
}); 

$(function(){ 
  $('#send').click(function(){ 
    var data = { 
      message: $('#message').val(), 
      type:'userMessage' 
    }; 
    socket.send(JSON.stringify(data)); 
    $('#message').val(''); 
  }); 
}); </pre></div><p>The first step in starting the chat is to connect to the server:</p><div class="informalexample"><pre class="programlisting">var socket = io.connect('/'); </pre></div><p>This will send a connection request to the server from which the page was loaded. This will also negotiate the actual transport protocol and will finally result in the <code class="literal">connection</code> event being triggered on the server app.</p><p>The following code snippet connects the event handler for the <code class="literal">message</code> event:</p><div class="informalexample"><pre class="programlisting">socket.on('message', function (data) { 
  data = JSON.parse(data); 
  $('#messages').append('&lt;div class="'+data.type+'"&gt;' + data.message + '&lt;/div&gt;'); 
}); </pre></div><p>All we have to do with the incoming message is to append it to the <code class="literal">messages</code> area. We are adding one additional detail here by setting the <code class="literal">class</code> property for the newly appended <code class="literal">div</code> tag to be of the same type as that of the message. We can later use this to give a different look to the different types of messages.</p><p>The <a id="id110" class="indexterm"/>last thing to do on the client side is to send the messages from the user. This will be done when the user writes his/her message in the message box and clicks the <span class="strong"><strong>Send</strong></span> button. So, let's add an event handler to the <span class="strong"><strong>Send</strong></span> button. The important thing about UI elements' event handlers is that they should be attached once the element is added to the document, that is, after it is created and ready. jQuery provides a convenient method to detect when the document is ready and adds a handler function to execute. There are two ways to do this; one is the following:</p><div class="informalexample"><pre class="programlisting">$(document).ready(function(){
  //Execute once the document is ready
});</pre></div><p>The shortcut for the same is as follows:</p><div class="informalexample"><pre class="programlisting">$(function(){
  //Execute once the document is ready
});</pre></div><p>Once the document is ready, we attach the event handler to the <code class="literal">cl</code>
<a id="id111" class="indexterm"/>
<code class="literal">ick</code> event of the <span class="strong"><strong>Send</strong></span> button:</p><div class="informalexample"><pre class="programlisting">$(function(){ 
  $('#send').click(function(){ 
    var data = { 
      message: $('#message').val(), 
      type:'userMessage' 
    }; 
    socket.send(JSON.stringify(data)); 
    $('#message').val(''); 
  }); 
}); </pre></div><p>On clicking the <span class="strong"><strong>Send</strong></span> button, we create our <code class="literal">data</code> object, setting the content of the message box as <code class="literal">message</code>, and <code class="literal">type</code> as <code class="literal">userMessage</code>. We can then use the <code class="literal">socket.send</code> method to send this data to the server. As you can see from the preceding code snippet, the syntax for sending messages from the client is the same as that of the server, and here too the message will be sent as a <a id="id112" class="indexterm"/>sting, which we create using <code class="literal">JSON.stringify(data)</code>.</p><p>Like the <code class="literal">connection</code> event<a id="id113" class="indexterm"/> and other predefined events on the server, we have some predefined events on the client too. These are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('connect', function () {})</code>: The <code class="literal">connect</code> event is emitted when the socket is connected successfully.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('connecting', function () {})</code>:The <code class="literal">connecting</code> event is emitted when the socket is attempting to connect with the server.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('disconnect', function () {})</code>: The <code class="literal">disconnect</code> event is emitted when the socket is disconnected.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('connect_failed', function () {})</code>: The <code class="literal">connect_failed</code> event is emitted when socket.io fails to establish a connection to the server and has no more transports to fall back to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('error', function () {})</code>: The <code class="literal">error</code> event is emitted when an error occurs and it cannot be handled by the other event types.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('message', function (message, callback) {})</code>: The <code class="literal">message</code> event is emitted when a message sent by using <code class="literal">socket.send</code> is received. The <code class="literal">message</code> parameter is the sent message, and <code class="literal">callback</code> is an optional acknowledgment function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('anything', function(data, callback) {})</code>: The <code class="literal">anything</code> event can be any event except the reserved events. The <code class="literal">data</code> parameter represents the data, and <code class="literal">callback</code> can be used to send a reply.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('reconnect_failed', function () {})</code>: The <code class="literal">reconnect_failed</code> event is emitted when socket.io fails to reestablish a working connection after the connection was dropped.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('reconnect', function () {})</code>: The <code class="literal">reconnect</code> event is emitted when socket.io is successfully reconnected to the server.</li><li class="listitem" style="list-style-type: disc"><code class="literal">socket.on('reconnecting', function () {})</code>: The <code class="literal">reconnecting</code> event is emitted when the socket is attempting to reconnect with the server.</li></ul></div><p>The last task to be done on the client side is to add socket.io and the chat scripts to our chat room page. Since these will not be used on every page, instead of adding them to <code class="literal">layout.jade</code>, we will add these to <code class="literal">index.jade</code>.</p><p>Remember the change we had made to <code class="literal">layout.jade</code>, changing the code from <code class="literal">head</code> to <code class="literal">block head</code>? It will allow us to append the content from <code class="literal">index.jade</code> to the <code class="literal">head</code> tag:</p><div class="informalexample"><pre class="programlisting">block append head 
      script(type='text/javascript', src='/socket.io/socket.io.js') 
      script(type='text/javascript', src='/javascripts/chat.js')</pre></div><p>In the following line of code, we are using Jade's functionality to append content to a block in an inherited template from the child element. This is done using the <code class="literal">append</code> keyword. The syntax is as follows:</p><div class="informalexample"><pre class="programlisting">block append &lt;blockname&gt;</pre></div><p>The shorter form is as follows:</p><div class="informalexample"><pre class="programlisting">append &lt;blockname&gt;</pre></div><a id="id114" class="indexterm"/><p>The next two lines of code add the script tags by adding <code class="literal">socket.io.js</code> and <code class="literal">chat.js</code> to our page. You might be wondering where the <code class="literal">/socket.io/socket.io.js</code> file comes from, since we neither add it and nor does it exist on the filesystem. This is part of the magic done by <code class="literal">io.listen</code> on the server. It creates a handler on the server to serve the <code class="literal">socket.io.js</code> script file.</p><p>And we are ready. Restart the node server and browse to <code class="literal">http://localhost:3000</code>
<code class="literal">/</code> to open the chat room. You will see the welcome message, <span class="strong"><strong>Welcome to the most interesting chat room on earth!</strong></span>, being displayed in the message area.</p><p>To see how our chat application works, open it in two separate browser instances. Now you can enter your message in the message box in one of the browsers and click <span class="strong"><strong>Send</strong></span>. You will see it appear on the message area of both the browsers.</p><p>Congratulations! We now have a chat room. If you deploy it to a server or allow access to port <code class="literal">3000</code> on your system, you can invite your friends to chat.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we learned about socket.io and worked through some very basic concepts and APIs provided by socket.io. We also saw how to set up socket.io on the server and the client, and how to send and receive messages. While doing so, we also built a chat room application using all that we have learned up to this point.</p><p>In the next chapter we will build upon the application that we have created to add other features such as session data, multiple chat rooms, namespacing, and authentication while getting acquainted with the related features of socket.io.</p></div></body></html>