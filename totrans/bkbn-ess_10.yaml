- en: Chapter 10. Keeping the Bugs Out – How to Test a Backbone Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at the challenges of testing a Backbone application,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a unit testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deciding between the BDD and the TDD testing styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mocking out related components in tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Selenium to create acceptance-level tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing in JavaScript?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For many years, the idea of testing JavaScript code was laughable. After all,
    who would write a testing suite for a bunch of form validation scripts? Moreover,
    even if you were doing something more interesting that could actually benefit
    from testing, there were no JavaScript libraries that facilitated testing, so
    it had to be done from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: In 2008, all this changed as a wave of new automated JavaScript testing tools
    emerged. All of these libraries focused on unit testing or testing of a specific
    part of the code (usually, a single method or small class). Two of the first unit
    testing libraries, QUnit and Jasmine, offered dueling approaches (TDD versus BDD)
    for testing in the browser, while a third library, JS Test Driver, offered testing
    at the command line. Soon after them came a number of other unit testing libraries,
    including Buster.js and Mocha.js, as well as test support or `mock` libraries
    such as JsMockito, JSMock, and Sinon.JS.
  prefs: []
  type: TYPE_NORMAL
- en: Today, as JavaScript developers create ever more advanced web applications (particularly,
    the kind made possible by Backbone), testing has become absolutely essential.
    Testing can prevent bugs that, because of the code's complexity, would otherwise
    have been difficult or even impossible to find. Further, perhaps, just as importantly,
    a proper suite of tests allows developers to safely refactor their code, which
    is a frequent and necessary task for keeping a code base maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it's no exaggeration to say that if you are a building a serious
    web application using Backbone, a testing suite isn't just a luxury, it's a necessity.
  prefs: []
  type: TYPE_NORMAL
- en: Which library to use
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building proper testing capabilities for a modern web application requires
    the following three main pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A unit-testing framework: a tool to test specific units (usually functions
    or small classes) of code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A mocking library: a tool that facilitates testing by creating fake versions
    of objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An acceptance testing framework: a tool for testing complete user experiences,
    such as logging in to your site or ordering a product'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on which unit-testing library you select, you may also want to download
    additional tools. For instance, many libraries offer alternate styles of test
    reports, which must be downloaded and included separately. Moreover, if you use
    a library that lacks the ability to run tests at the command line, you may wish
    to add this functionality with a headless web browser such as the very popular
    PhantomJS, Doing so will make it easier to automate your tests so that they can,
    for instance, run periodically or in response to code checks-ins. While there
    are several different mocking libraries to choose from (we'll explain why you
    want one in a moment), we recommend using the most popular, Sinon.JS. Sinon is
    both powerful enough and easy enough to use, and thus, it's a great fit for just
    about any project. Similarly, there is really only one main option for acceptance
    testing and that is Selenium. We'll discuss Selenium at the end of the chapter,
    so for now, we will focus on the choice of a unit testing library.
  prefs: []
  type: TYPE_NORMAL
- en: There are far too many high-quality testing libraries, with far too many differences
    in features, to possibly cover them all properly in this book. However, we do
    need to choose a library for the examples in this chapter, and so, we've opted
    to use Mocha.js. Mocha is one of the newer libraries available as well as one
    of the most robust and powerful. Mocha can be used either with the traditional
    xUnit/TDD style used by libraries such as QUnit, or with the BDD style popularized
    (in JavaScript at least) by Jasmine. Further, while it can be run in the browser,
    it can also be run (by using PhantomJS) at the command line as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of all this, Mocha offers its users the choice of four different assertion
    libraries. While other major testing libraries include assertions as part of the
    library itself (which admittedly is more convenient: there is one less file to
    download), Mocha prefers to give developers a choice. Because there are subtle
    differences possible in the way assertions are implemented, Mocha lets you select
    the style so that you can have the style that most appeals to you.'
  prefs: []
  type: TYPE_NORMAL
- en: However, while we will be using Mocha throughout this chapter, much of what
    we'll be demonstrating will in fact be similar (if not identical) to how many
    of the other popular testing libraries work.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To use Mocha, you will first need to download the `mocha.css` and `mocha.js`
    files from the project's GitHub page (which can be found at [https://github.com/mochajs/mocha](https://github.com/mochajs/mocha)).
    You will also need to download an assertion library; for this example, we'll be
    using `Expect.js` (which you can download from [https://github.com/Automattic/expect.js](https://github.com/Automattic/expect.js)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will need to create a new HTML page and add script tags for all of
    your application''s JavaScript files, as well as all library files (for instance,
    Backbone and jQuery). You''ll also need to add a few bits of Mocha boilerplate
    code. All together you should wind up with an HTML file that looks something like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'TDD versus BDD: What''s the difference?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding code, we call `mocha.setup` (bdd), which starts Mocha in the
    BDD mode (as opposed to the TDD mode). But what does this even mean?
  prefs: []
  type: TYPE_NORMAL
- en: '**Test Driven Development** (**TDD**) is a style of development where the developer
    begins all his work by writing a (failing) test case. The developer then adds
    just enough code to his application to make that test pass, but no more than that.
    As soon as the test passes, the developer writes a new (failing) test and repeats
    the cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of TDD are two-fold. First, by always writing a test first, the
    developer guarantees that his code will always be completely covered by tests.
    Second, the TDD style naturally forces developers to write their code in a testable
    fashion, which means adopting practices like writing several short functions instead
    of one long one. As we mentioned in the previous chapter, these practices have
    benefits that go beyond the test environment.
  prefs: []
  type: TYPE_NORMAL
- en: However, TDD also has its downsides. Perhaps, the most significant one is that
    it can result in excessive, useless tests, which require significant time to maintain.
    Also, by its very nature, TDD focuses heavily on *how* the code does instead of
    what it does, but many programmers would argue that *what* the code does is far
    more important to test.
  prefs: []
  type: TYPE_NORMAL
- en: This distinction is particularly important when refactoring. By definition,
    a refactoring operation is required when you change how the code does what it
    does without changing what it does. Because TDD-based tests focus so heavily on
    the how, whenever a refactoring occurs, the tests need to be updated to match
    the new code.
  prefs: []
  type: TYPE_NORMAL
- en: '**Behavior Driven Development** (**BDD**) is very similar to TDD but attempts
    to solve the problems related to TDD by focusing on what the code does. This is
    achieved largely by using a slightly more verbose syntax for organizing tests
    and test suites. Of course, one doesn''t necessarily need a different syntax to
    write tests that focus on what the code does, but the benefit of the BDD syntax
    is that it naturally encourages such behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following imaginary test of the Backbone set method of `Model`,
    written using Mocha''s TDD syntax and the better-assert assertion library. It
    works by creating `testModel`, setting an attribute (`a`) with a value (`1`),
    and then confirming that the attribute/value pair has been added to the test attributes
    of `Model`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in the TDD code, a test is registered using a `test` function
    and groups of tests are organized into suites. Also, the test verifies the validity
    of the code by using an `assert` statement. Now, let''s look at a similar imaginary
    test created using the BDD syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how similar the two tests are: While the first example uses *suite*
    and the second uses *describe*, both functions have the same effect of grouping
    tests. Similarly, in the BDD example, tests are still defined and still contain
    validity checks, but the tests are defined with an `it` function, and instead
    of assertions, we have expectations (expect calls).'
  prefs: []
  type: TYPE_NORMAL
- en: However, there are two important differences that go beyond just the names of
    the functions. First, the latter example reads much more like an English sentence,
    making it easier to read both in the code, and later on, when viewing the test
    results. Second, and more importantly, the first test emphasizes how `set` works,
    while the second one emphasizes what it should do. While there is nothing inherent
    in either the TDD or the BDD style that forces either test to be written in a
    certain way, this example highlights how the syntax can nevertheless influence
    a test's design. This can become important later on if the Backbone developers
    ever change Backbone to use a different name instead of *attributes*, as they
    will then have to rewrite the first test while the second one would continue working
    without adjustment.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately it is possible to test what your code does with either style of test,
    and so, it's really just a question of which style you prefer. However, if you
    have no opinion one way or the other, the BDD syntax is probably a better starting
    point, both for its improved readability and for its natural emphasis on describing
    what the code should do. For these reasons, we'll continue to use the BDD syntax
    in the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Describe, beforeEach, and it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve used testing libraries in other languages before you might already
    understand the preceding code, but if not allow me to explain. The test starts
    with a call to Mocha''s `describe` function. This function creates a *suite* (or
    grouping) of tests, and you optionally nest more `describe` functions to further
    organize your tests. One benefit of using `describe` statements is that when you
    go to run your tests, you can choose to only run a specific suite defined by `describe`,
    rather than running all of them at once. The `describe` function takes two arguments:
    a string indicating what is being described, and a function that is used to wrap
    all of the tests within the `describe` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have a `beforeEach` call that, as you might imagine, defines code that
    will run before each test. This can be a useful place to separate code that is
    common to all of the tests in the `describe` statement (such as the creation of
    a new `Backbone.Model` class in the preceding example). Mocha also has an equivalent
    `afterEach` function that runs similarly after each test completes and can be
    used to clean up the side effects of the tests. Mocha also has `before` and `after`
    functions, which are similar except that they only run once per `describe` statement
    (that is per suite), rather than once per test.
  prefs: []
  type: TYPE_NORMAL
- en: 'After another `describe` (this time to group tests related to `set`), we get
    to the `it` function, which actually defines a specific test. Like `describe`,
    `it` takes two arguments: a string that describes what it (the code being tested)
    should do, and a function that tests whether the indicated behavior is actually
    occurring. If the function passed to the `it` function completes without throwing
    an error, Mocha will consider this test to have passed, whereas if an error is
    thrown, it will instead mark that test as failed (and provide the stack trace
    of the thrown error in the test output so that you can easily debug the relevant
    code).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we have the `expect` function (which could just as easily be called
    `assert` or something else had we chosen a different assertion library). The `expect`
    function takes a single argument and then uses jQuery-like chaining to assert
    something about the first argument. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Expect.js` library has several other forms of assertions as well, all of
    which you can find detailed on their GitHub page.
  prefs: []
  type: TYPE_NORMAL
- en: Running our test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we understand how everything works, let''s try to actually run our
    test. To do this, simply replace the following line in our HTML file with the
    `describe` code provided earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can also choose to put the `describe` code into a separate
    file and replace the insert line with a script tag that references this file.
    Either way, save the file and open it up in your favorite web browser. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running our test](img/image00169.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Our test passes!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As long as the code we're testing remains relatively simple, Mocha and Expect.js
    are all that we need to test it. However, the code rarely remains simple, and
    there are two complications in particular that can make us need another tool,
    known as a `mocking` library, to let us create fake versions or mocks of our objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s imagine we want to test the following method of an imaginary
    `ExampleModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll want to test whether our `foo` method calls the `baz` method. However,
    at the same time, we will (presumably) already have a separate test of the `baz`
    method itself. This leaves us with a dilemma: how can we test that `foo` calls
    `baz` without repeating the test code for `baz` inside the test code for `foo`?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, let''s consider another imaginary method that we might want
    to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we want to test whether `foo` is called after the `fetch` operation
    completes, but to truly test this, we'd need to actually fetch a `Model` class
    from the server by using AJAX. This, in turn, would make our tests require an
    active server, making them significantly slower and opening up the possibility
    of the tests causing side effects on our server.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to both of these problems is to use a mocking library such as `Sinon.js`.
    To do this, simply download sinon.js from [http://sinonjs.org/](http://sinonjs.org/)
    and then include this file (via a `script` tag) on your test running the HTML
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Sinon is available, we can use it to solve our testing problems. First,
    let''s use it to create a special kind of mock called `stub` for a test of our
    `foo` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the preceding code, we were able to use Sinon to create `stub`
    that replaced the normal `baz` method. While this `stub` didn't actually do anything,
    it did keep track of how many times it was called (as well as which arguments
    were used, although we didn't test this), which let us write a test that ensured
    that `foo` would call `baz` without having to repeat any of the test code for
    `baz`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our second problem, that of testing an AJAX method, we could use an AJAX-specific
    mock tool such as MockJax. However, Sinon is so powerful that we really don''t
    need to use anything else; consider the following test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we used two `stub` functions. We used the `fooStub` function
    in a manner similar to how we used the `bazstub` function in the previous example,
    to check whether or not `foo` got called, but our `fetchStub` served a different
    purpose. By chaining a `returns` method call off of our stub''s creation, we created
    a `stub` function that (unlike the previous `stub` functions) actually did something:
    it returned our resolved deferred function. Since jQuery treats a resolved deferred
    function the same way as it treats a completed AJAX call (by invoking any done
    code for the call), we simulated the return of an AJAX call without involving
    an actual server.'
  prefs: []
  type: TYPE_NORMAL
- en: Sinon has many other useful methods related to `stub`, as well as other types
    of mocking functions such as `spy` and `mock`, all of which are very well documented
    on their website. Sinon also has a feature known as `sandbox`, which can allow
    you to eliminate all of the `baz.restore()` code by automatically activating it
    after every test run (when `sandbox` is cleaned up). Again, you can find all the
    details of this feature on Sinon's website.
  prefs: []
  type: TYPE_NORMAL
- en: Selenium
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we've been focusing entirely on unit testing, but it is worth
    mentioning that there are many other forms of tests that can benefit a Backbone
    application, such as load tests, smoke tests, and usability tests. However, a
    detailed discussion of all these tests is outside the scope of this book, and
    in most workplace environments, these tests won't be the purview of the development
    team anyway. Instead, they will be managed by the quality assurance (QA) department.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is one type of testing, acceptance testing, which is worth mentioning.
    In smaller organizations that lack a QA department, acceptance tests will often
    be created and maintained by developers, and even in larger organizations, it's
    not unheard of for developers to assist with the creation and maintenance of these
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance tests test the functionality of your site, by checking whether or
    not a user can perform a specific action. A given acceptance test might check
    whether the user can log in to a site, change his password, or place an order.
    Unlike unit tests, which test a small piece of the larger functionality (such
    as a single `placeOrder` function), acceptance tests validate all of the disparate
    functions that are used to complete a particular user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the web, there is a single tool that almost completely dominates acceptance
    testing: the Selenium web driver ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)).
    The Selenium web driver allows you to create automated tests that perfectly simulate
    the actions of a real user on your site. A Selenium test can click a button, fill
    in a text field, scroll, and do just about anything else that an actual user can
    do.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Selenium is available for many different languages, including JavaScript. It
    can either be used directly via the Selenium web driver ([https://code.google.com/p/selenium/wiki/WebDriverJs](https://code.google.com/p/selenium/wiki/WebDriverJs))
    or be wrapped with a library that offers an alternate syntax such as Nightwatch.js
    ([http://nightwatchjs.org/](http://nightwatchjs.org/)). Here''s an example from
    the Nightwatch.js home page that demonstrates a simple acceptance test written
    with Nightwatch.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding example, Nightwatch.js (and Selenium itself)
    uses the same selectors that you already use for CSS and jQuery, along with special
    methods such as `waitForElementVisibility` to control timing and prevent the automation
    script from moving too quickly through the test. This allows you to simulate any
    user story you want, no matter how simple or how complex it is, and then, repeat
    this story over and over to test your site.
  prefs: []
  type: TYPE_NORMAL
- en: However, Selenium-based tests do have their limits with the biggest being that
    because Selenium operates on the user level, it has no awareness of what's going
    on at the code level. If a Selenium test fails, it won't provide a stack trace
    or point you to a line of failing code; instead, it will simply alert you that
    a particular operation failed, and it will be up to you to debug it manually,
    just as you would with a user-submitted bug. Ideally, you should try and catch
    as many failures as you can in your unit test suite and only rely on Selenium-based
    acceptance tests to find bugs that "slip through the cracks" in your unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to combine a variety of tools to test your Backbone
    applications. We learned the difference between TDD and BDD, as well as the differences
    between major testing libraries such as QUnit and Jasmine. We explored in depth
    how to use the Mocha framework to create a testing suite and how to use the Sinon
    library to mock out parts of your code within that suite.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look into a variety of other third-party tools that
    can help you create Backbone applications. We'll look at general-purpose tools,
    such as the Require.js dependency management system, and Backbone-specific tools,
    such as BackGrid and BackSupport.
  prefs: []
  type: TYPE_NORMAL
