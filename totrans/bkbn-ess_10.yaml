- en: Chapter 10. Keeping the Bugs Out – How to Test a Backbone Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 驱虫之道 – 如何测试Backbone应用程序
- en: 'In this chapter, we''ll look at the challenges of testing a Backbone application,
    including the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨测试Backbone应用程序的挑战，包括以下内容：
- en: Choosing a unit testing framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择单元测试框架
- en: Deciding between the BDD and the TDD testing styles
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在BDD和TDD测试风格之间做出决定
- en: Mocking out related components in tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中模拟相关组件
- en: Using Selenium to create acceptance-level tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Selenium创建验收测试
- en: Testing in JavaScript?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript中的测试？
- en: For many years, the idea of testing JavaScript code was laughable. After all,
    who would write a testing suite for a bunch of form validation scripts? Moreover,
    even if you were doing something more interesting that could actually benefit
    from testing, there were no JavaScript libraries that facilitated testing, so
    it had to be done from scratch.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多年里，测试JavaScript代码的想法是可笑的。毕竟，谁会为一些表单验证脚本编写测试套件呢？此外，即使你正在做一些更有趣的事情，实际上可以从测试中受益，但当时没有JavaScript库简化测试，所以不得不从头开始。
- en: In 2008, all this changed as a wave of new automated JavaScript testing tools
    emerged. All of these libraries focused on unit testing or testing of a specific
    part of the code (usually, a single method or small class). Two of the first unit
    testing libraries, QUnit and Jasmine, offered dueling approaches (TDD versus BDD)
    for testing in the browser, while a third library, JS Test Driver, offered testing
    at the command line. Soon after them came a number of other unit testing libraries,
    including Buster.js and Mocha.js, as well as test support or `mock` libraries
    such as JsMockito, JSMock, and Sinon.JS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 2008年，随着一波新的自动化JavaScript测试工具的出现，所有这些库都专注于单元测试或对代码特定部分的测试（通常是一个单独的方法或小型类）。最早的两个单元测试库QUnit和Jasmine提供了在浏览器中进行测试的对抗性方法（TDD与BDD），而第三个库JS
    Test Driver则提供了命令行测试。紧随其后的是其他一些单元测试库，包括Buster.js和Mocha.js，以及测试支持或`mock`库，如JsMockito、JSMock和Sinon.JS。
- en: Today, as JavaScript developers create ever more advanced web applications (particularly,
    the kind made possible by Backbone), testing has become absolutely essential.
    Testing can prevent bugs that, because of the code's complexity, would otherwise
    have been difficult or even impossible to find. Further, perhaps, just as importantly,
    a proper suite of tests allows developers to safely refactor their code, which
    is a frequent and necessary task for keeping a code base maintainable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着JavaScript开发者创建越来越先进的Web应用程序（尤其是Backbone所可能实现的类型），测试已经成为绝对必要的。测试可以防止由于代码的复杂性而难以甚至无法找到的bug。更重要的是，也许，一个合适的测试套件允许开发者安全地重构他们的代码，这对于保持代码库可维护性是一个频繁且必要的任务。
- en: At this point, it's no exaggeration to say that if you are a building a serious
    web application using Backbone, a testing suite isn't just a luxury, it's a necessity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果你正在使用Backbone构建一个严肃的Web应用程序，那么测试套件不仅仅是一种奢侈，更是一种必需品。
- en: Which library to use
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择哪个库
- en: 'Building proper testing capabilities for a modern web application requires
    the following three main pieces:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为现代Web应用程序构建适当的测试能力需要以下三个主要部分：
- en: 'A unit-testing framework: a tool to test specific units (usually functions
    or small classes) of code'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试框架：一个用于测试代码特定单元（通常是函数或小型类）的工具
- en: 'A mocking library: a tool that facilitates testing by creating fake versions
    of objects'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟库：一个通过创建对象的假版本来简化测试的工具
- en: 'An acceptance testing framework: a tool for testing complete user experiences,
    such as logging in to your site or ordering a product'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受测试框架：一个用于测试完整用户体验的工具，例如登录您的网站或订购产品
- en: Depending on which unit-testing library you select, you may also want to download
    additional tools. For instance, many libraries offer alternate styles of test
    reports, which must be downloaded and included separately. Moreover, if you use
    a library that lacks the ability to run tests at the command line, you may wish
    to add this functionality with a headless web browser such as the very popular
    PhantomJS, Doing so will make it easier to automate your tests so that they can,
    for instance, run periodically or in response to code checks-ins. While there
    are several different mocking libraries to choose from (we'll explain why you
    want one in a moment), we recommend using the most popular, Sinon.JS. Sinon is
    both powerful enough and easy enough to use, and thus, it's a great fit for just
    about any project. Similarly, there is really only one main option for acceptance
    testing and that is Selenium. We'll discuss Selenium at the end of the chapter,
    so for now, we will focus on the choice of a unit testing library.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你选择的单元测试库，你可能还需要下载额外的工具。例如，许多库提供替代的测试报告风格，这些风格必须单独下载并包含在内。此外，如果你使用的是一个无法在命令行中运行测试的库，你可能希望使用无头浏览器（如非常流行的PhantomJS）来添加此功能。这样做将使自动化测试更容易，例如，可以定期运行或在代码提交时运行。虽然可以选择多种不同的模拟库（我们将在稍后解释为什么你需要一个），但我们推荐使用最受欢迎的Sinon.JS。Sinon既强大又易于使用，因此它几乎适合任何项目。同样，接受测试的主要选项只有一个，那就是Selenium。我们将在本章末尾讨论Selenium，所以现在我们将专注于单元测试库的选择。
- en: There are far too many high-quality testing libraries, with far too many differences
    in features, to possibly cover them all properly in this book. However, we do
    need to choose a library for the examples in this chapter, and so, we've opted
    to use Mocha.js. Mocha is one of the newer libraries available as well as one
    of the most robust and powerful. Mocha can be used either with the traditional
    xUnit/TDD style used by libraries such as QUnit, or with the BDD style popularized
    (in JavaScript at least) by Jasmine. Further, while it can be run in the browser,
    it can also be run (by using PhantomJS) at the command line as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试库的质量非常高，功能差异也很多，不可能在这本书中全部正确地涵盖它们。然而，我们确实需要为这一章的示例选择一个库，因此我们选择了Mocha.js。Mocha是可用的较新库之一，也是功能最强大和最稳健的库之一。Mocha可以使用传统的xUnit/TDD风格，这种风格被QUnit等库所使用，也可以使用由Jasmine（至少在JavaScript中）普及的BDD风格。此外，虽然它可以在浏览器中运行，但也可以通过使用PhantomJS在命令行中运行。
- en: 'On top of all this, Mocha offers its users the choice of four different assertion
    libraries. While other major testing libraries include assertions as part of the
    library itself (which admittedly is more convenient: there is one less file to
    download), Mocha prefers to give developers a choice. Because there are subtle
    differences possible in the way assertions are implemented, Mocha lets you select
    the style so that you can have the style that most appeals to you.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之上，Mocha为其用户提供选择四种不同的断言库。虽然其他主要测试库将断言作为库本身的一部分（这确实更方便：需要下载的文件更少），但Mocha更倾向于给开发者选择。因为断言的实现方式可能存在细微的差异，Mocha允许你选择风格，这样你可以选择最吸引你的风格。
- en: However, while we will be using Mocha throughout this chapter, much of what
    we'll be demonstrating will in fact be similar (if not identical) to how many
    of the other popular testing libraries work.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我们将在这章中使用Mocha，但我们将要展示的大部分内容实际上将与许多其他流行的测试库的工作方式相似（如果不是完全相同）。
- en: Getting started with Mocha
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Mocha
- en: To use Mocha, you will first need to download the `mocha.css` and `mocha.js`
    files from the project's GitHub page (which can be found at [https://github.com/mochajs/mocha](https://github.com/mochajs/mocha)).
    You will also need to download an assertion library; for this example, we'll be
    using `Expect.js` (which you can download from [https://github.com/Automattic/expect.js](https://github.com/Automattic/expect.js)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Mocha，你首先需要从项目的GitHub页面（可在[https://github.com/mochajs/mocha](https://github.com/mochajs/mocha)找到）下载`mocha.css`和`mocha.js`文件。你还需要下载一个断言库；在这个例子中，我们将使用`Expect.js`（你可以从[https://github.com/Automattic/expect.js](https://github.com/Automattic/expect.js)下载）。
- en: 'Next, you will need to create a new HTML page and add script tags for all of
    your application''s JavaScript files, as well as all library files (for instance,
    Backbone and jQuery). You''ll also need to add a few bits of Mocha boilerplate
    code. All together you should wind up with an HTML file that looks something like
    the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要创建一个新的HTML页面，并为你的应用程序的所有JavaScript文件以及所有库文件（例如，Backbone和jQuery）添加脚本标签。你还需要添加一些Mocha模板代码。总的来说，你应该得到一个看起来像以下这样的HTML文件：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'TDD versus BDD: What''s the difference?'
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TDD与BDD：有什么区别？
- en: In the preceding code, we call `mocha.setup` (bdd), which starts Mocha in the
    BDD mode (as opposed to the TDD mode). But what does this even mean?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们调用 `mocha.setup`（bdd），这启动Mocha在BDD模式下（而不是TDD模式）。但这究竟是什么意思？
- en: '**Test Driven Development** (**TDD**) is a style of development where the developer
    begins all his work by writing a (failing) test case. The developer then adds
    just enough code to his application to make that test pass, but no more than that.
    As soon as the test passes, the developer writes a new (failing) test and repeats
    the cycle.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种开发风格，其中开发者开始所有工作都是通过编写一个（失败的）测试用例。然后开发者只添加足够多的代码到他的应用程序中，以使该测试通过，但不超过这个程度。一旦测试通过，开发者就会编写一个新的（失败的）测试，并重复这个循环。'
- en: The advantages of TDD are two-fold. First, by always writing a test first, the
    developer guarantees that his code will always be completely covered by tests.
    Second, the TDD style naturally forces developers to write their code in a testable
    fashion, which means adopting practices like writing several short functions instead
    of one long one. As we mentioned in the previous chapter, these practices have
    benefits that go beyond the test environment.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的优势有两个。首先，通过始终先编写测试，开发者保证他的代码总是完全被测试覆盖。其次，TDD风格自然地迫使开发者以可测试的方式编写代码，这意味着采用像写几个短函数而不是一个长函数这样的实践。正如我们在上一章中提到的，这些实践的好处超出了测试环境。
- en: However, TDD also has its downsides. Perhaps, the most significant one is that
    it can result in excessive, useless tests, which require significant time to maintain.
    Also, by its very nature, TDD focuses heavily on *how* the code does instead of
    what it does, but many programmers would argue that *what* the code does is far
    more important to test.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，TDD也有其缺点。也许，最显著的一个是它可能导致过多的、无用的测试，这些测试需要大量的时间来维护。此外，由于其本质，TDD非常重视代码的“如何”而不是“做什么”，但许多程序员会争论代码的“做什么”对测试来说更为重要。
- en: This distinction is particularly important when refactoring. By definition,
    a refactoring operation is required when you change how the code does what it
    does without changing what it does. Because TDD-based tests focus so heavily on
    the how, whenever a refactoring occurs, the tests need to be updated to match
    the new code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别在重构时尤其重要。根据定义，当你改变代码执行的方式而不改变其执行的内容时，就需要进行重构操作。由于基于TDD的测试非常重视“如何”，每当发生重构时，测试都需要更新以匹配新的代码。
- en: '**Behavior Driven Development** (**BDD**) is very similar to TDD but attempts
    to solve the problems related to TDD by focusing on what the code does. This is
    achieved largely by using a slightly more verbose syntax for organizing tests
    and test suites. Of course, one doesn''t necessarily need a different syntax to
    write tests that focus on what the code does, but the benefit of the BDD syntax
    is that it naturally encourages such behavior.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）与TDD非常相似，但试图通过关注代码执行的内容来解决与TDD相关的问题。这主要通过对组织测试和测试套件的语法进行稍微更详细的描述来实现。当然，一个人不一定需要不同的语法来编写关注代码执行内容的测试，但BDD语法的优点是它自然地鼓励这种行为。'
- en: 'Consider the following imaginary test of the Backbone set method of `Model`,
    written using Mocha''s TDD syntax and the better-assert assertion library. It
    works by creating `testModel`, setting an attribute (`a`) with a value (`1`),
    and then confirming that the attribute/value pair has been added to the test attributes
    of `Model`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用Mocha的TDD语法和更好的断言库编写的关于Backbone `Model` 的 `set` 方法的假设测试。它通过创建 `testModel`，设置一个属性（`a`）的值（`1`），然后确认属性/值对已添加到
    `Model` 的测试属性中：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see, in the TDD code, a test is registered using a `test` function
    and groups of tests are organized into suites. Also, the test verifies the validity
    of the code by using an `assert` statement. Now, let''s look at a similar imaginary
    test created using the BDD syntax:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在TDD代码中，测试是通过使用`test`函数来注册的，而测试组则被组织成套件。此外，测试通过使用`assert`语句来验证代码的有效性。现在，让我们看看使用BDD语法创建的类似想象中的测试：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Notice how similar the two tests are: While the first example uses *suite*
    and the second uses *describe*, both functions have the same effect of grouping
    tests. Similarly, in the BDD example, tests are still defined and still contain
    validity checks, but the tests are defined with an `it` function, and instead
    of assertions, we have expectations (expect calls).'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这两个测试是多么相似：虽然第一个例子使用了*suite*，而第二个使用了*describe*，但这两个函数都有分组测试的相同效果。同样，在BDD示例中，测试仍然被定义，并且仍然包含有效性检查，但测试是通过`it`函数定义的，而不是断言，我们有期望（expect调用）。
- en: However, there are two important differences that go beyond just the names of
    the functions. First, the latter example reads much more like an English sentence,
    making it easier to read both in the code, and later on, when viewing the test
    results. Second, and more importantly, the first test emphasizes how `set` works,
    while the second one emphasizes what it should do. While there is nothing inherent
    in either the TDD or the BDD style that forces either test to be written in a
    certain way, this example highlights how the syntax can nevertheless influence
    a test's design. This can become important later on if the Backbone developers
    ever change Backbone to use a different name instead of *attributes*, as they
    will then have to rewrite the first test while the second one would continue working
    without adjustment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有两个重要的区别，不仅仅是函数名称的差异。首先，后者例子读起来更像一个英语句子，这使得在代码中阅读以及稍后查看测试结果都更容易。其次，更重要的是，第一个测试强调了`set`的工作方式，而第二个则强调了它应该做什么。虽然TDD或BDD风格中并没有内在的东西强迫测试以某种特定方式编写，但这个例子突出了语法如何仍然可以影响测试的设计。如果Backbone开发者将来改变Backbone以使用不同于*attributes*的名称，这可能会变得很重要，因为他们将不得不重写第一个测试，而第二个则无需调整即可继续工作。
- en: Ultimately it is possible to test what your code does with either style of test,
    and so, it's really just a question of which style you prefer. However, if you
    have no opinion one way or the other, the BDD syntax is probably a better starting
    point, both for its improved readability and for its natural emphasis on describing
    what the code should do. For these reasons, we'll continue to use the BDD syntax
    in the rest of this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，使用任何一种测试风格都可以测试代码的功能，因此，这实际上只是一个关于你更喜欢哪种风格的问题。然而，如果你对此没有意见，BDD语法可能是一个更好的起点，这不仅因为其改进的可读性，还因为它自然强调描述代码应该做什么。出于这些原因，我们将继续在本章的其余部分使用BDD语法。
- en: Describe, beforeEach, and it
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 描述、beforeEach和it
- en: 'If you''ve used testing libraries in other languages before you might already
    understand the preceding code, but if not allow me to explain. The test starts
    with a call to Mocha''s `describe` function. This function creates a *suite* (or
    grouping) of tests, and you optionally nest more `describe` functions to further
    organize your tests. One benefit of using `describe` statements is that when you
    go to run your tests, you can choose to only run a specific suite defined by `describe`,
    rather than running all of them at once. The `describe` function takes two arguments:
    a string indicating what is being described, and a function that is used to wrap
    all of the tests within the `describe` function.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前在其他语言中使用过测试库，你可能已经理解了前面的代码，如果没有，让我来解释一下。测试从对Mocha的`describe`函数的调用开始。这个函数创建了一个*套件*（或分组）的测试，你可以选择嵌套更多的`describe`函数来进一步组织你的测试。使用`describe`语句的一个好处是，当你运行测试时，你可以选择只运行由`describe`定义的特定套件，而不是一次性运行所有测试。`describe`函数接受两个参数：一个字符串，表示正在描述的内容，以及一个函数，用于包装`describe`函数内的所有测试。
- en: Next, we have a `beforeEach` call that, as you might imagine, defines code that
    will run before each test. This can be a useful place to separate code that is
    common to all of the tests in the `describe` statement (such as the creation of
    a new `Backbone.Model` class in the preceding example). Mocha also has an equivalent
    `afterEach` function that runs similarly after each test completes and can be
    used to clean up the side effects of the tests. Mocha also has `before` and `after`
    functions, which are similar except that they only run once per `describe` statement
    (that is per suite), rather than once per test.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个 `beforeEach` 调用，正如你可能想象的那样，它定义了在每个测试之前运行的代码。这可能是一个有用的地方，用于分离 `describe`
    语句中所有测试的共同代码（例如，在前面的例子中创建一个新的 `Backbone.Model` 类）。Mocha 还有一个等效的 `afterEach` 函数，在每个测试完成后以类似的方式运行，可以用来清理测试的副作用。Mocha
    还有一个 `before` 和 `after` 函数，它们类似，但它们只在每个 `describe` 语句（即每个测试套件）中运行一次，而不是在每个测试中运行一次。
- en: 'After another `describe` (this time to group tests related to `set`), we get
    to the `it` function, which actually defines a specific test. Like `describe`,
    `it` takes two arguments: a string that describes what it (the code being tested)
    should do, and a function that tests whether the indicated behavior is actually
    occurring. If the function passed to the `it` function completes without throwing
    an error, Mocha will consider this test to have passed, whereas if an error is
    thrown, it will instead mark that test as failed (and provide the stack trace
    of the thrown error in the test output so that you can easily debug the relevant
    code).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个 `describe`（这次是为了将相关的 `set` 测试分组），我们来到了 `it` 函数，它实际上定义了一个特定的测试。和 `describe`
    一样，`it` 函数接受两个参数：一个字符串，描述了它（被测试的代码）应该做什么，以及一个函数，用于测试是否发生了指示的行为。如果传递给 `it` 函数的函数在完成时没有抛出错误，Mocha
    会认为这个测试已经通过，而如果抛出了错误，它将标记该测试为失败（并在测试输出中提供抛出错误的堆栈跟踪，以便您可以轻松地调试相关代码）。
- en: 'Finally, we have the `expect` function (which could just as easily be called
    `assert` or something else had we chosen a different assertion library). The `expect`
    function takes a single argument and then uses jQuery-like chaining to assert
    something about the first argument. Here are a few examples:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `expect` 函数（如果选择了不同的断言库，它也可以被称为 `assert` 或其他名称）。`expect` 函数接受一个参数，然后使用类似
    jQuery 的链式调用来断言关于第一个参数的内容。以下是一些示例：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Expect.js` library has several other forms of assertions as well, all of
    which you can find detailed on their GitHub page.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expect.js` 库还有其他几种断言形式，所有这些都可以在它们的 GitHub 页面上找到详细说明。'
- en: Running our test
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的测试
- en: 'Now that we understand how everything works, let''s try to actually run our
    test. To do this, simply replace the following line in our HTML file with the
    `describe` code provided earlier:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了所有的工作原理，让我们尝试实际运行我们的测试。为此，只需将以下行替换为我们之前提供的 `describe` 代码即可：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, you can also choose to put the `describe` code into a separate
    file and replace the insert line with a script tag that references this file.
    Either way, save the file and open it up in your favorite web browser. You should
    see something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以选择将 `describe` 代码放入一个单独的文件中，并用一个引用此文件的脚本标签替换插入行。无论哪种方式，保存文件并在您最喜欢的网络浏览器中打开它。你应该会看到类似以下内容：
- en: '![Running our test](img/image00169.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![运行我们的测试](img/image00169.jpeg)'
- en: Our test passes!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试通过了！
- en: Introducing mocks
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍模拟
- en: As long as the code we're testing remains relatively simple, Mocha and Expect.js
    are all that we need to test it. However, the code rarely remains simple, and
    there are two complications in particular that can make us need another tool,
    known as a `mocking` library, to let us create fake versions or mocks of our objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们正在测试的代码相对简单，Mocha 和 Expect.js 就足够我们测试了。然而，代码很少保持简单，特别是有两个复杂问题可能会让我们需要另一个工具，即所谓的
    `mocking` 库，让我们能够创建对象的假版本或模拟。
- en: 'First, let''s imagine we want to test the following method of an imaginary
    `ExampleModel` class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们想象我们想要测试一个虚构的 `ExampleModel` 类的以下方法：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we''ll want to test whether our `foo` method calls the `baz` method. However,
    at the same time, we will (presumably) already have a separate test of the `baz`
    method itself. This leaves us with a dilemma: how can we test that `foo` calls
    `baz` without repeating the test code for `baz` inside the test code for `foo`?'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将想要测试我们的 `foo` 方法是否调用了 `baz` 方法。然而，与此同时，我们（可能）已经有一个针对 `baz` 方法本身的单独测试。这让我们陷入了两难：如何在
    `foo` 的测试代码中测试 `foo` 调用 `baz` 而不重复 `baz` 的测试代码？
- en: 'Alternatively, let''s consider another imaginary method that we might want
    to test:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，让我们考虑另一个可能想要测试的虚构方法：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this case, we want to test whether `foo` is called after the `fetch` operation
    completes, but to truly test this, we'd need to actually fetch a `Model` class
    from the server by using AJAX. This, in turn, would make our tests require an
    active server, making them significantly slower and opening up the possibility
    of the tests causing side effects on our server.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们想要测试在 `fetch` 操作完成后是否调用了 `foo`，但要真正测试这一点，我们需要通过 AJAX 从服务器实际获取一个 `Model`
    类。这反过来会使我们的测试需要活跃的服务器，从而使测试速度显著减慢，并可能导致测试对服务器产生副作用。
- en: The solution to both of these problems is to use a mocking library such as `Sinon.js`.
    To do this, simply download sinon.js from [http://sinonjs.org/](http://sinonjs.org/)
    and then include this file (via a `script` tag) on your test running the HTML
    page.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这两个问题的方法是使用一个模拟库，如 `Sinon.js`。为此，只需从 [http://sinonjs.org/](http://sinonjs.org/)
    下载 sinon.js，然后通过一个 `script` 标签将此文件包含在运行测试的 HTML 页面上。
- en: 'Once Sinon is available, we can use it to solve our testing problems. First,
    let''s use it to create a special kind of mock called `stub` for a test of our
    `foo` method as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Sinon 可用，我们就可以用它来解决我们的测试问题。首先，让我们用它来为我们的 `foo` 方法创建一个特殊的模拟类型 `stub`，如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding code, we were able to use Sinon to create `stub`
    that replaced the normal `baz` method. While this `stub` didn't actually do anything,
    it did keep track of how many times it was called (as well as which arguments
    were used, although we didn't test this), which let us write a test that ensured
    that `foo` would call `baz` without having to repeat any of the test code for
    `baz`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在前面的代码中所见，我们能够使用 Sinon 创建一个 `stub` 来替换正常的 `baz` 方法。虽然这个 `stub` 实际上没有做什么，但它确实跟踪了它被调用的次数（以及使用了哪些参数，尽管我们没有测试这一点），这使得我们能够编写一个测试，确保
    `foo` 会调用 `baz`，而无需重复任何 `baz` 的测试代码。
- en: 'For our second problem, that of testing an AJAX method, we could use an AJAX-specific
    mock tool such as MockJax. However, Sinon is so powerful that we really don''t
    need to use anything else; consider the following test:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第二个问题，即测试 AJAX 方法，我们可以使用一个特定的 AJAX 模拟工具，如 MockJax。然而，Sinon 的功能如此强大，我们实际上真的不需要使用任何其他工具；考虑以下测试：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this example, we used two `stub` functions. We used the `fooStub` function
    in a manner similar to how we used the `bazstub` function in the previous example,
    to check whether or not `foo` got called, but our `fetchStub` served a different
    purpose. By chaining a `returns` method call off of our stub''s creation, we created
    a `stub` function that (unlike the previous `stub` functions) actually did something:
    it returned our resolved deferred function. Since jQuery treats a resolved deferred
    function the same way as it treats a completed AJAX call (by invoking any done
    code for the call), we simulated the return of an AJAX call without involving
    an actual server.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了两个 `stub` 函数。我们使用 `fooStub` 函数的方式与我们在上一个例子中使用 `bazstub` 函数的方式相似，以检查
    `foo` 是否被调用，但我们的 `fetchStub` 扮演了不同的角色。通过在 `stub` 创建时链式调用 `returns` 方法，我们创建了一个
    `stub` 函数，与之前的 `stub` 函数不同，它实际上做了些事情：它返回了我们的已解析的延迟函数。由于 jQuery 将已解析的延迟函数处理方式与它处理完成的
    AJAX 调用的方式相同（通过调用调用的任何完成代码），我们模拟了 AJAX 调用的返回，而不涉及任何实际的服务器。
- en: Sinon has many other useful methods related to `stub`, as well as other types
    of mocking functions such as `spy` and `mock`, all of which are very well documented
    on their website. Sinon also has a feature known as `sandbox`, which can allow
    you to eliminate all of the `baz.restore()` code by automatically activating it
    after every test run (when `sandbox` is cleaned up). Again, you can find all the
    details of this feature on Sinon's website.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon 还有许多与 `stub` 相关的其他有用方法，以及其他类型的模拟函数，如 `spy` 和 `mock`，所有这些都在他们的网站上得到了很好的文档说明。Sinon
    还有一个名为 `sandbox` 的功能，它可以在每次测试运行后（当 `sandbox` 被清理时）自动激活，从而消除所有的 `baz.restore()`
    代码。同样，你可以在 Sinon 的网站上找到这个功能的所有详细信息。
- en: Selenium
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Selenium
- en: Up to this point, we've been focusing entirely on unit testing, but it is worth
    mentioning that there are many other forms of tests that can benefit a Backbone
    application, such as load tests, smoke tests, and usability tests. However, a
    detailed discussion of all these tests is outside the scope of this book, and
    in most workplace environments, these tests won't be the purview of the development
    team anyway. Instead, they will be managed by the quality assurance (QA) department.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于单元测试，但值得一提的是，还有许多其他形式的测试可以惠及Backbone应用程序，例如负载测试、冒烟测试和可用性测试。然而，对所有这些测试的详细讨论超出了本书的范围，并且在大多数工作环境中，这些测试通常不由开发团队负责。相反，它们将由质量保证（QA）部门管理。
- en: However, there is one type of testing, acceptance testing, which is worth mentioning.
    In smaller organizations that lack a QA department, acceptance tests will often
    be created and maintained by developers, and even in larger organizations, it's
    not unheard of for developers to assist with the creation and maintenance of these
    tests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一种测试类型，即验收测试，值得特别提及。在缺乏质量保证（QA）部门的较小组织中，验收测试通常由开发者创建和维护，即使在较大的组织中，开发者协助创建和维护这些测试的情况也并不少见。
- en: Acceptance tests test the functionality of your site, by checking whether or
    not a user can perform a specific action. A given acceptance test might check
    whether the user can log in to a site, change his password, or place an order.
    Unlike unit tests, which test a small piece of the larger functionality (such
    as a single `placeOrder` function), acceptance tests validate all of the disparate
    functions that are used to complete a particular user interaction.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试通过检查用户是否能够执行特定操作来测试您网站的功能。一个特定的验收测试可能会检查用户是否可以登录网站、更改密码或下订单。与测试较小功能部分（如单个`placeOrder`函数）的单元测试不同，验收测试验证了用于完成特定用户交互的所有不同功能。
- en: 'On the web, there is a single tool that almost completely dominates acceptance
    testing: the Selenium web driver ([http://www.seleniumhq.org/](http://www.seleniumhq.org/)).
    The Selenium web driver allows you to create automated tests that perfectly simulate
    the actions of a real user on your site. A Selenium test can click a button, fill
    in a text field, scroll, and do just about anything else that an actual user can
    do.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络上，有一个工具几乎完全主导了验收测试：Selenium WebDriver ([http://www.seleniumhq.org/](http://www.seleniumhq.org/))。Selenium
    WebDriver允许您创建自动化的测试，这些测试可以完美地模拟真实用户在您网站上的操作。Selenium测试可以点击按钮、填写文本字段、滚动，以及做几乎任何实际用户能做的事情。
- en: 'Selenium is available for many different languages, including JavaScript. It
    can either be used directly via the Selenium web driver ([https://code.google.com/p/selenium/wiki/WebDriverJs](https://code.google.com/p/selenium/wiki/WebDriverJs))
    or be wrapped with a library that offers an alternate syntax such as Nightwatch.js
    ([http://nightwatchjs.org/](http://nightwatchjs.org/)). Here''s an example from
    the Nightwatch.js home page that demonstrates a simple acceptance test written
    with Nightwatch.js:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium支持多种不同的语言，包括JavaScript。它可以直接通过Selenium WebDriver使用（[https://code.google.com/p/selenium/wiki/WebDriverJs](https://code.google.com/p/selenium/wiki/WebDriverJs)）或者被一个提供不同语法的库（如Nightwatch.js
    ([http://nightwatchjs.org/](http://nightwatchjs.org/)))包装。以下是从Nightwatch.js主页上的一个示例，展示了使用Nightwatch.js编写的简单验收测试：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see from the preceding example, Nightwatch.js (and Selenium itself)
    uses the same selectors that you already use for CSS and jQuery, along with special
    methods such as `waitForElementVisibility` to control timing and prevent the automation
    script from moving too quickly through the test. This allows you to simulate any
    user story you want, no matter how simple or how complex it is, and then, repeat
    this story over and over to test your site.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，Nightwatch.js（以及Selenium本身）使用与您已经用于CSS和jQuery相同的选择器，以及如`waitForElementVisibility`之类的特殊方法来控制时间并防止自动化脚本在测试中移动过快。这允许您模拟任何您想要的用户故事，无论它多么简单或复杂，然后，反复重复这个故事来测试您的网站。
- en: However, Selenium-based tests do have their limits with the biggest being that
    because Selenium operates on the user level, it has no awareness of what's going
    on at the code level. If a Selenium test fails, it won't provide a stack trace
    or point you to a line of failing code; instead, it will simply alert you that
    a particular operation failed, and it will be up to you to debug it manually,
    just as you would with a user-submitted bug. Ideally, you should try and catch
    as many failures as you can in your unit test suite and only rely on Selenium-based
    acceptance tests to find bugs that "slip through the cracks" in your unit testing.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于 Selenium 的测试确实有其局限性，最大的局限性在于 Selenium 在用户级别操作，对代码级别发生的事情没有意识。如果一个 Selenium
    测试失败，它不会提供堆栈跟踪或指向失败的代码行；相反，它只会简单地提醒你某个特定操作失败了，而调试工作将取决于你手动完成，就像处理用户提交的缺陷一样。理想情况下，你应该尽量在你的单元测试套件中捕捉尽可能多的失败，并且只依赖基于
    Selenium 的验收测试来发现那些在单元测试中“漏网之鱼”的缺陷。
- en: Summary
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to combine a variety of tools to test your Backbone
    applications. We learned the difference between TDD and BDD, as well as the differences
    between major testing libraries such as QUnit and Jasmine. We explored in depth
    how to use the Mocha framework to create a testing suite and how to use the Sinon
    library to mock out parts of your code within that suite.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何结合各种工具来测试您的 Backbone 应用程序。我们了解了 TDD 和 BDD 之间的区别，以及 QUnit 和 Jasmine
    等主要测试库之间的差异。我们深入探讨了如何使用 Mocha 框架创建测试套件，以及如何使用 Sinon 库在该套件中模拟代码的部分。
- en: In the next chapter, we'll look into a variety of other third-party tools that
    can help you create Backbone applications. We'll look at general-purpose tools,
    such as the Require.js dependency management system, and Backbone-specific tools,
    such as BackGrid and BackSupport.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨各种其他第三方工具，这些工具可以帮助您创建 Backbone 应用程序。我们将查看通用工具，例如 Require.js 依赖管理系统，以及
    Backbone 特定的工具，例如 BackGrid 和 BackSupport。
