<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Working with Advanced Libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Advanced Libraries</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with global APIs</li><li class="listitem" style="list-style-type: disc">Implementing a circuit breaker</li><li class="listitem" style="list-style-type: disc">Implementing a dead letter queue</li><li class="listitem" style="list-style-type: disc">Logging API analytics</li><li class="listitem" style="list-style-type: disc">Working with Google Analytics</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec48"/>Introduction</h1></div></div></div><p>In this chapter, you will be introduced to some of the advanced libraries available to interface with the service worker. These topics will be pragmatic and you will be working with advanced libraries in real-world software development. We will also learn about advanced topics, such as circuit breakers and dead letter queues, which you might not come across in everyday programming, but are something new to learn.</p><p>Let's start off this chapter by looking at which global APIs are available for the service worker to work with.</p></div></div>
<div class="section" title="Working with global APIs"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Working with global APIs</h1></div></div></div><p>Service workers <a id="id292" class="indexterm"/>can access some very useful global API methods. Let's look at a few of these methods; you might them find handy, and they can be used in your own projects. Some of these global API methods include <code class="literal">Cache</code>, <code class="literal">caches</code>, <code class="literal">getAll</code>, <code class="literal">Request</code>, <code class="literal">Response</code>, and <code class="literal">fetch</code>.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec132"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned <a id="id293" class="indexterm"/>on in your browser settings. If you have not done this yet, refer to the first recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up service workers</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec133"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Copy the <code class="literal">index.html</code>, <code class="literal">index.js</code>, <code class="literal">service-worker.js</code>, and <code class="literal">style.css</code> files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/01/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/01/</a>
</p></li><li class="listitem">Open up a browser and go to <code class="literal">index.html</code>:<div class="mediaobject"><img src="graphics/B05381_06_01.jpg" alt="How to do it..."/></div></li><li class="listitem">Open up the Developer Toolbar (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>F12</em></span>). Now refresh the page and look at the message in the console. You will see the global API functions logged into the console:<div class="mediaobject"><img src="graphics/B05381_06_02.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec134"/>How it works...</h2></div></div></div><p>We are simply <a id="id294" class="indexterm"/>printing some of the APIs available to the service worker to the console. Our <code class="literal">service-worker.js</code> file looks like the following:</p><div class="informalexample"><pre class="programlisting">'use strict';

console.log(
  'Cache', this.Cache, '\n',
  'caches', this.caches,'\n',
  'fetch', this.fetch,'\n',
  'getAll', this.getAll,'\n',
  'Request', this.Request,'\n',
  'Response', this.Response
);</pre></div><p>Let's discuss some of these API methods in more detail.</p><div class="section" title="Cache"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec14"/>Cache</h3></div></div></div><p>The <a id="id295" class="indexterm"/>
<code class="literal">Cache</code> interface is available for both service workers and windowed scopes. Its main purpose is to provide a storage mechanism for cached <code class="literal">Request</code> and <code class="literal">Response</code> object pairs.</p></div><div class="section" title="caches"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec15"/>caches</h3></div></div></div><p>The <a id="id296" class="indexterm"/>service worker stores assets offline with the <code class="literal">CacheStorage</code> object, which is enabled by the <code class="literal">window.caches</code> read-only property.</p></div><div class="section" title="fetch"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec16"/>fetch</h3></div></div></div><p>The global <code class="literal">fetch</code>
<a id="id297" class="indexterm"/> performs an asynchronous fetch across the network.</p></div><div class="section" title="getAll"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec17"/>getAll</h3></div></div></div><p>This is <a id="id298" class="indexterm"/>part of Chromium's command API. It gets passed into <code class="literal">Promise.then()</code> as an argument.</p></div></div></div>
<div class="section" title="Implementing a circuit breaker"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Implementing a circuit breaker</h1></div></div></div><p>Imagine<a id="id299" class="indexterm"/> you run an application that polls an API every 5 seconds, but for some reason the service goes down, and you keep polling and getting timeouts. You would need to handle the error quickly and gracefully. The circuit breaker pattern detects failures and prevents your application from performing actions that are doomed to fail.</p><p>In this recipe, we will look at how to implement a circuit breaker library with the service worker.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec135"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the first recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up service workers</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec136"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download all the files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/02/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/02/</a>
</p></li><li class="listitem">Open up a browser and go to the <code class="literal">index.html</code> file:<div class="mediaobject"><img src="graphics/B05381_06_03.jpg" alt="How to do it..."/></div></li><li class="listitem">Now open <a id="id300" class="indexterm"/>up the DevTools (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>F12</em></span>) and make sure the <span class="strong"><strong>Preserve log</strong></span> checkbox is clicked. Now refresh the page and you will see the log messages from the circuit breaker:<p> </p><div class="mediaobject"><img src="graphics/B05381_06_04.jpg" alt="How to do it..."/></div><p>
</p></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec137"/>How it works...</h2></div></div></div><p>Before looking at the implementation, let's try to understand how a circuit breaker goes about its business.</p><p>A circuit breaker monitors for failures. Whenever the failures hit the threshold, the circuit breaker trips and any calls to the circuit breaker will return with an error. After a suitable interval, the circuit breaker resets the breaker if the error no longer occurs.</p><p>As you can see, we need two thresholds for error handling and resetting at a certain time after the circuit breaker trips:</p><div class="mediaobject"><img src="graphics/B05381_06_05.jpg" alt="How it works..."/><div class="caption"><p>Image source: <a class="ulink" href="http://martinfowler.com">http://martinfowler.com</a>
</p></div></div><p>The majority <a id="id301" class="indexterm"/>of our work is going to be in the <code class="literal">circuit-breaker.js</code> file. If you <a id="id302" class="indexterm"/>want to learn more about the circuit breaker, follow this link:</p><p>
<a class="ulink" href="http://martinfowler.com/bliki/CircuitBreaker.html">http://martinfowler.com/bliki/CircuitBreaker.html</a>
</p><p>First, we need to configure the circuit breaker. Let's make 10 blocks with a 3-second timeout and a threshold of five. We also define the error threshold as fifty percent:</p><div class="informalexample"><pre class="programlisting">var TEN_SECONDS = 10000,
    TEN_BLOCKS = 10,
    THREE_SECONDS = 3000,
    FIFTY_PERCENT = 50,
    FIVE = 5;

  var CB = function(opts) {
    opts = opts || {};

    this.errorThreshold = opts.errorThreshold || FIFTY_PERCENT;
    this.numBlocks = opts.numBlocks || TEN_BLOCKS;
    this.timeoutDuration = opts.timeoutDuration || THREE_SECONDS;
    this.volumeThreshold = opts.volumeThreshold || FIVE;
    this.windowDuration = opts.windowDuration || TEN_SECONDS;

    this.hanldeCircuitOpen = opts.hanldeCircuitOpen || function() {};
    this.handleCircuitClose = opts.handleCircuitClose || function() {};

    this.$buckets = [this.$createBlock()];
    this.$state = CB.CLOSED;

    this.$startTicker();
  };</pre></div><p>We then <a id="id303" class="indexterm"/>define a method for <code class="literal">run</code> as follows:</p><div class="informalexample"><pre class="programlisting">CB.prototype.run = function(command, fallback) {
    if (this.isOpen()) {
      this.$executeFallback(fallback || function() {});
    } else {
      this.$execCmd(command);
    }
  };</pre></div><p>This method executes the fallback function passed in as an argument if the circuit is open. Otherwise, it will execute the command. In the <code class="literal">service-worker.js</code> file, we pass in the <code class="literal">fetch</code> request as the fallback function for the <code class="literal">run</code> method:</p><div class="informalexample"><pre class="programlisting">CircuitBreaker.prototype.fetch = function(request) {
    var unavailableRes = Response.error();

    return new Promise(function(resolve, reject) {
        this.run(function(success, fail) {
            fetch(request).then(function(res) {
                if(res.status &lt; 400) {
                    success();
                    console.log('FETCH: successful');
                } else {
                    fail();
                    console.log('FETCH: failed');
                }
                resolve(res);
            }).catch(function(err) {
                fail();
                reject(unavailableRes);
                console.log('FETCH: unavailable');
            });
        }, function() {
            resolve(unavailableRes);
        });
    }.bind(this));
};</pre></div><p>The <code class="literal">forceClose</code>, <code class="literal">forceOpen</code>, and <code class="literal">unforce</code> methods change the state accordingly:</p><div class="informalexample"><pre class="programlisting">  CB.prototype.forceClose = function() {
    this.$forced = this.$state;
    this.$state = CB.CLOSED;
  };

  CB.prototype.forceOpen = function() {
    this.$forced = this.$state;
    this.$state = CB.OPEN;
  };

  CB.prototype.unforce = function() {
    this.$state = this.$forced;
    this.$forced = null;
  };</pre></div><p>The <code class="literal">isOpen</code> function <a id="id304" class="indexterm"/>returns a value indicating whether the circuit is open or closed:</p><div class="informalexample"><pre class="programlisting">    CB.prototype.isOpen = function() {
        return this.$state === CB.OPEN;
    };</pre></div><p>Query the cache first; if the request doesn't match, send the request to the network:</p><div class="informalexample"><pre class="programlisting">self.onfetch = function(evt) {
  evt.respondWith(openCache().then(function(cache) {
    var request = evt.request;

    return cache.match(request).then(function(res) {
      return res || fetch(request);
    });
  }));
};</pre></div><p>We denote our private functions with a <code class="literal">$</code> prefix. The <code class="literal">$startTicker</code> function starts the timer for us:</p><div class="informalexample"><pre class="programlisting">CB.prototype.$startTicker = function() {
    var me = this,
      bucketIndex = 0,
      bucketDuration = this.windowDuration / this.numBlocks;

    var tick = function() {
      if (me.$buckets.length &gt; me.numBlocks) {
        me.$buckets.shift();
      }

      bucketIndex++;

      if (bucketIndex &gt; me.numBlocks) {
        bucketIndex = 0;

        if (me.isOpen()) {
          me.$state = CB.HALF_OPEN;
        }
      }

      me.$buckets.push(me.$createBlock());
    };

    setInterval(tick, bucketDuration);
};</pre></div><p>The <code class="literal">$createBlock</code> function<a id="id305" class="indexterm"/> gives us a fresh block to work with, and the <code class="literal">$lastBlock</code> function gives us the last block, as expected:</p><div class="informalexample"><pre class="programlisting">  CB.prototype.$createBlock = function() {
    return {
      successes: 0,
      failures: 0,
      shortCircuits: 0,
      timeouts: 0
    };
  };

  CB.prototype.$lastBlock = function() {
    var numBlocks = this.$buckets.length,
      lastBlock = this.$buckets[numBlocks - 1];

    return lastBlock;
  };</pre></div><p>The <code class="literal">$execCmd</code> method updates the state by incrementing successes and failures:</p><div class="informalexample"><pre class="programlisting">  CB.prototype.$execCmd = function(command) {
    var me = this,
      increment,
      timeout;

    increment = function(prop) {
      return function() {
        var bucket;

        if (!timeout) {
          return;
        }

        bucket = me.$lastBlock();
        bucket[prop]++;

        if (me.$forced === null) {
          me.$updateState();
        }

        clearTimeout(timeout);
        timeout = null;
      };
    };

    timeout = setTimeout(increment('timeouts'), this.timeoutDuration);

    command(increment('successes'), increment('failures'));
  };</pre></div><p>The <code class="literal">$executeFallback</code> function <a id="id306" class="indexterm"/>runs the fallback method we discussed before:</p><div class="informalexample"><pre class="programlisting">CB.prototype.$executeFallback = function(fallback) {
    var bucket;

    fallback();

    bucket = this.$lastBlock();
    bucket.shortCircuits++;
};</pre></div><p>The <code class="literal">$calcMetrics</code> function returns the total number of errors, as well as the count of successes:</p><div class="informalexample"><pre class="programlisting">CB.prototype.$calcMetrics = function() {
    var totalCount = 0,
      totalErrors = 0,
      errorPerc = 0,
      bucket,
      errors,
      i;

    for (i = 0, len = this.$buckets.length; i &lt; len; i++) {
      bucket = this.$buckets[i];
      errors = (bucket.failures + bucket.timeouts);

      totalErrors += errors;
      totalCount += (errors + bucket.successes);
    }

    errorPerc = (totalErrors / (totalCount &gt; 0 ? totalCount : 1)) * 100;

    return {
      totalErrors: totalErrors,
      errorPerc: errorPerc,
      totalCount: totalCount
    };
};</pre></div><p>The <code class="literal">$updateState</code> method <a id="id307" class="indexterm"/>updates the state after a series of calculations:</p><div class="informalexample"><pre class="programlisting">CB.prototype.$updateState = function() {
    var metrics = this.$calcMetrics();

    if (this.$state == CB.HALF_OPEN) {
      var lastCmdFailed = !this.$lastBlock().successes &amp;&amp; metrics.totalErrors &gt; 0;

      if (lastCmdFailed) {
        this.$state = CB.OPEN;
      } else {
        this.$state = CB.CLOSED;
        this.handleCircuitClose(metrics);
      }
    } else {
      var overErrorThreshold = metrics.errorPerc &gt; this.errorThreshold,
        overVolumeThreshold = metrics.totalCount &gt; this.volumeThreshold,
        overThreshold = overVolumeThreshold &amp;&amp; overErrorThreshold;

      if (overThreshold) {
        this.$state = CB.OPEN;
        this.hanldeCircuitOpen(metrics);
      }
    }
};</pre></div><p>Inside <a id="id308" class="indexterm"/>our <code class="literal">service-worker.js</code> file, we are using our circuit-breaker library by passing the fetch request via a circuitBreaker object:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('fetch', function(evt) {
    var url = evt.request.url;

    if(!circuitBreakers[url]) {
        circuitBreakers[url] = new CircuitBreaker(opt);
    }

    evt.respondWith(circuitBreakers[url].fetch(evt.request));
});</pre></div></div></div>
<div class="section" title="Implementing a dead letter queue"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Implementing a dead letter queue</h1></div></div></div><p>Dead letter queues are <a id="id309" class="indexterm"/>system-generated queues for one or many of the following reasons: for storing messages that could not be delivered, queue length limit exceeded, message length limit exceeded, or a message being rejected by another queue exchange.</p><p>In this recipe, we are implementing a dead letter queue in the service worker.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec138"/>Getting ready</h2></div></div></div><p>To get started with <a id="id310" class="indexterm"/>service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the first recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up service workers</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec139"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download all the files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/03/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/03/</a>
</p></li><li class="listitem">Open up <a id="id311" class="indexterm"/>a browser and go to <code class="literal">index.html</code>:<div class="mediaobject"><img src="graphics/B05381_06_06.jpg" alt="How to do it..."/></div></li><li class="listitem">Now open up the DevTools (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>F12</em></span>) and make sure the <span class="strong"><strong>Preserve log</strong></span> checkbox is clicked.</li><li class="listitem">Select the offline option on the <span class="strong"><strong>Network</strong></span> tab:<div class="mediaobject"><img src="graphics/B05381_06_07.jpg" alt="How to do it..."/></div></li><li class="listitem">Now refresh the page and you will see the failed request messages, which are queued in the dead letter queue we implemented:<div class="mediaobject"><img src="graphics/B05381_06_08.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec140"/>How it works...</h2></div></div></div><p>The install<a id="id312" class="indexterm"/> event handler of the service worker caches the files we are passing into the <code class="literal">addAll</code> method in the <code class="literal">service-worker.js</code> file:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('install', function(evt) {
  evt.waitUntil(
    caches.open(cacheName)
      .then(function(cache) {
        return cache.addAll([
          'style.css',
          'index.html',
          'index.js',
          'style.css'
        ]);
      })
      .then(function() {
        return self.skipWaiting();
      })
  );
});</pre></div><p>When we request files over the wire, the <code class="literal">fetch</code> event handler queries the cache to find out whether the requests are matched, and if so, serves them from the cache:</p><div class="informalexample"><pre class="programlisting">self.addEventListener('fetch', function(evt) {
    evt.respondWith(
        caches.match(evt.request)
          .then(function(res) {
            if(res.status &gt;= 500) {
                console.log('RESPONSE: error');
                return Response.error();
            } else {
                console.log('RESPONSE: success');
                replayQueuedRequests();
                return res;
            }
        }).catch(function() {
            queueFailedRequest(evt.request);
        })
    );
});</pre></div><p>Also, if the <a id="id313" class="indexterm"/>response is successful, then we call <code class="literal">replayQueuedRequests()</code> to run any outstanding requests in the queue:</p><div class="informalexample"><pre class="programlisting">function replayQueuedRequests() {
    Object.keys(queue).forEach(function(evt) {
        fetch(queue[evt]).then(function(){
            if(res.status &gt;= 500) {
                console.log('RESPONSE: error');
                return Response.error();
            }
            console.log('DELETE: queue');
            delete queue[error];
        }).catch(function() {
            if (Date.now() - evt &gt; expiration) {
                delete queue[error];
                console.log('DELETE: queue');
            }
        });
    });
} </pre></div><p>If the fetch fails, we queue the request:</p><div class="informalexample"><pre class="programlisting">function queueFailedRequest(request) {
    queue[Date.now()] = request.url;
    console.log('QUEUED: failed request');
} </pre></div></div></div>
<div class="section" title="Logging API analytics"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Logging API analytics</h1></div></div></div><p>If you were<a id="id314" class="indexterm"/> asked to implement API logging for an existing application, what will your approach be? The most common approaches are to either change the client-side code or the server-side code, or both.</p><p>By using a service worker, we can intercept client requests and gather information, and then send them to a log API.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec141"/>Getting ready</h2></div></div></div><p>To get started with service workers, you will need to have the service worker experiment feature turned <a id="id315" class="indexterm"/>on in your browser settings. If you have not done this yet, refer to the first recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up service workers</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec142"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download all the files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/04/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/04/</a>
</p></li><li class="listitem">Run <code class="literal">npm install</code> on the command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install</strong></span>
</pre></div></li><li class="listitem">Run <code class="literal">npm start</code> on the command line:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm start</strong></span>
</pre></div></li><li class="listitem">Open up a browser and go to the <code class="literal">index.html</code> file:<div class="mediaobject"><img src="graphics/B05381_06_09.jpg" alt="How to do it..."/></div></li><li class="listitem">Add a<a id="id316" class="indexterm"/> task and a priority:<div class="mediaobject"><img src="graphics/B05381_06_10.jpg" alt="How to do it..."/></div></li><li class="listitem">Now go to the reports page by clicking on the <span class="strong"><strong>reports</strong></span> link:<div class="mediaobject"><img src="graphics/B05381_06_11.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec143"/>How it works...</h2></div></div></div><p>In<a id="id317" class="indexterm"/> the <code class="literal">index.html</code> file, we are adding a section with a form:</p><div class="informalexample"><pre class="programlisting">&lt;section id="todo-area"&gt;
    &lt;p&gt;Try to add and delete some todos.&lt;/p&gt;
    &lt;form id="add-form"&gt;
      &lt;input type="text" id="new-todo" placeholder="Add a task here"/&gt;
      &lt;input type="text" id="priority" placeholder="Priority"/&gt;
      &lt;input type="submit" value="Add" /&gt;
    &lt;/form&gt;
    &lt;table id="todos"&gt;
    &lt;/table&gt;
    &lt;p&gt;Go to &lt;a href="https://localhost:3011/report/" target="_blank"&gt;report&lt;/a&gt;&lt;/p&gt;
  &lt;/section&gt;</pre></div><p>In the <code class="literal">service-worker.js</code> file, every time a fetch request is fired, we are logging it:</p><div class="informalexample"><pre class="programlisting">self.onfetch = function(evt) {
  evt.respondWith(
    logRequest(evt.request).then(fetch)
  );
};

function logRequest(req) {
  var retRequest = function() {
    return req;
  };

  var data = {
    method: req.method,
    url: req.url
  };

  return fetch(URL, {
    method: 'POST',
    body: JSON.stringify(data),
    headers: { 'content-type': 'application/json' }
  }).then(retRequest, retRequest);
}</pre></div><p>The <code class="literal">index.js</code> file contains<a id="id318" class="indexterm"/> the logic for adding and deleting to-dos. We first show the list of to-dos at the point of registration:</p><div class="informalexample"><pre class="programlisting">navigator.serviceWorker.oncontrollerchange = function() {
    this.controller.onstatechange = function() {
      if (this.state === 'activated') {
        loadTodos();
      }
    };
};</pre></div><p>By clicking on the add button, a new to-do is created and sent to the server:</p><div class="informalexample"><pre class="programlisting">document.querySelector('#add-form').onsubmit = function(event) {</pre></div><p>If a to-do was provided, skip it. If no priority is given, the default is <code class="literal">Minor</code>:</p><div class="informalexample"><pre class="programlisting">if (!newTodo) {
    return;
   }

priority = document.querySelector('#priority').value.trim()
                    || 'Minor';</pre></div><p>We then send the API request, a <code class="literal">POST</code> request of to-do collection:</p><div class="informalexample"><pre class="programlisting">fetch(URL, {
    method: 'POST',
    body: JSON.stringify(todo),
    headers: headers,
  }).then(function(response) {
      return response.json();
    }).then(function(addedTodo) {
      document.querySelector('#todos').appendChild(getRowFor(addedTodo));
    });
};</pre></div><p>In order to <a id="id319" class="indexterm"/>retrieve the collection of to-dos, we fire a fetch request with the <code class="literal">GET</code> method:</p><div class="informalexample"><pre class="programlisting">function loadTodos() {
  fetch(URL).then(function(res) {
      return res.json();
    }).then(showTodos);
}</pre></div><p>Then we populate the to-dos table:</p><div class="informalexample"><pre class="programlisting">function showTodos(items) {
  var table = document.querySelector('#todos');

  table.innerHTML = '';
  for (var i = 0, len = items.length, todo; i &lt; len; i++) {
    todo = items[i];
    table.appendChild(getRowFor(todo));
  }

  if (window.parent !== window) {
    window.parent.document.body.dispatchEvent(new CustomEvent('iframeresize'));
  }
}</pre></div><p>A function is useful for creating rows for the table:</p><div class="informalexample"><pre class="programlisting">function getRowFor(todo) {
  var tr = document.createElement('TR'),
    id = todo.id;

  tr.id = id;

  tr.appendChild(getCell(todo.todo));
  tr.appendChild(getCell(todo.priority));
  tr.appendChild(todo.isSticky ? getCell('') : getDeleteButton(id));

  return tr;
}</pre></div><p>Build a helper function for the table data:</p><div class="informalexample"><pre class="programlisting">function getCell(todo) {
  var td = document.createElement('TD');

  td.textContent = todo;
  return td;
}</pre></div><p>Build a <a id="id320" class="indexterm"/>delete button:</p><div class="informalexample"><pre class="programlisting">function getDeleteButton(id) {
  var td = document.createElement('TD'),
    btn = document.createElement('BUTTON');

  btn.textContent = 'Delete';
  btn.onclick = function() {
    deleteTodo(id).then(function() {
      var tr = document.getElementById(id);
      tr.parentNode.removeChild(tr);
    });
  };

  td.appendChild(btn);
  return td;
}</pre></div><p>Make a <code class="literal">DELETE</code> request for deleting to-dos:</p><div class="informalexample"><pre class="programlisting">function deleteTodo(id) {
  return fetch(URL + '/' + id, { method: 'DELETE' });
}</pre></div><p>The <code class="literal">server.js</code> file consists of two APIs, of which one is for to-do management and the other is for logs.</p><p>We are providing a set of default to-dos to start with. These to-dos will appear on the top of our list as examples.</p><div class="informalexample"><pre class="programlisting">var todos = [
  {
    todo: 'Buy milk',
    priority: 'Minor'
  },
  {
    todo: 'Refill car',
    priority: 'Medium'
  },
  {
    todo: 'Learn service worker',
    priority: 'Major'
  }
].map(function(todo, index) {
  todo.id = index + 1;
  todo.isSticky = true;

  return todo;
});</pre></div><p>The sticky flag will make sure that these to-dos are not removable.</p><p>The REST API <a id="id321" class="indexterm"/>endpoints will manage the requests for adding and deleting to-dos and the logs:</p><div class="informalexample"><pre class="programlisting">app.get('/report', function(req, res) {
  var stats = getLogSummary();
  var buffer = report({ stats: stats });
  res.send(buffer);
});

app.post('/report/logs', function(req, res) {
  var logEntry = logRequest(req.body);
  res.status(201).json(logEntry);
});

app.get('/api/todos', function(req, res) {
  res.json(todos.filter(function(item) {
    return item !== null;
  }));
});

app.get('/api/todos', function(req, res) {
  res.json(todos.filter(function(item) {
    return item !== null;
  }));
});

app.delete('/api/todos/:id', function(req, res) {
  var id = parseInt(req.params.id, 10) - 1;
  if (!todos[id].isSticky) {
    todos[id] = null;
  }
  res.sendStatus(204);
});

app.post('/api/todos', function(req, res) {
  var todo = req.body;
  todo.id = todos.length + 1;
  todos.push(todo);
  res.status(201).json(todo);
});</pre></div><p>We create <a id="id322" class="indexterm"/>an aggregation function for the log report for <code class="literal">GET</code>, <code class="literal">DELETE</code>, and <code class="literal">POST</code> requests:</p><div class="informalexample"><pre class="programlisting">function getLogSummary() {
  var aggr = requestsLog.reduce(function(subSummary, entry) {
    if (!(entry.url in subSummary)) {
      subSummary[entry.url] = {
        url: entry.url,
        GET: 0,
        POST: 0,
        DELETE: 0,
      };
    }
    subSummary[entry.url][entry.method]++;
    return subSummary;
  }, {});

  return Object.keys(aggr).map(function(url) {
    return aggr[url];
  });
}</pre></div><p>In the <code class="literal">report.html</code> file, we have a template for rendering log data. We use SWIG on the server side to render this template:</p><div class="informalexample"><pre class="programlisting">&lt;table id="todos"&gt;
    &lt;tr&gt;
      &lt;th&gt;url&lt;/th&gt;
      &lt;th&gt;GET&lt;/th&gt;
      &lt;th&gt;POST&lt;/th&gt;
      &lt;th&gt;DELETE&lt;/th&gt;
    &lt;/tr&gt;
    {% for entry in stats %}
    &lt;tr&gt;
      &lt;td&gt;{{ entry.url }}&lt;/td&gt;
      &lt;td class="counter"&gt;{{ entry.GET }}&lt;/td&gt;
      &lt;td class="counter"&gt;{{ entry.POST }}&lt;/td&gt;
      &lt;td class="counter"&gt;{{ entry.DELETE }}&lt;/td&gt;
    &lt;/tr&gt;
    {% endfor %}
  &lt;/table&gt;</pre></div></div></div>
<div class="section" title="Working with Google Analytics"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Working with Google Analytics</h1></div></div></div><p>Google Analytics <a id="id323" class="indexterm"/>is a widely used tool today, and the majority of websites use it to collect various data from visitors. In this recipe, we are going to look at how we can benefit from the service worker when implementing Google Analytics.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec144"/>Getting ready</h2></div></div></div><p>To get started <a id="id324" class="indexterm"/>with service workers, you will need to have the service worker experiment feature turned on in your browser settings. If you have not done this yet, refer to the first recipe of <a class="link" href="ch01.html" title="Chapter 1. Learning Service Worker Basics">Chapter 1</a>, <span class="emphasis"><em>Learning Service Worker Basics</em></span>: <span class="emphasis"><em>Setting up service workers</em></span>. Service workers only run across HTTPS. To find out how to set up a development environment to support this feature, refer to the following recipes: <span class="emphasis"><em>Setting up GitHub pages for SSL</em></span>, <span class="emphasis"><em>Setting up SSL for Windows</em></span>, and <span class="emphasis"><em>Setting up SSL for Mac</em></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec145"/>How to do it...</h2></div></div></div><p>Follow these instructions to set up your file structure:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Download all the files from the following location:<p>
<a class="ulink" href="https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/05/">https://github.com/szaranger/szaranger.github.io/blob/master/service-workers/06/05/</a>
</p></li><li class="listitem">Open up a browser and go to the <code class="literal">index.html</code> file:<div class="mediaobject"><img src="graphics/B05381_06_12.jpg" alt="How to do it..."/></div></li><li class="listitem">Now open up the DevTools (<span class="emphasis"><em>Cmd</em></span> + <span class="emphasis"><em>Alt</em></span> + <span class="emphasis"><em>I</em></span> or <span class="emphasis"><em>F12</em></span>), and go to the <span class="strong"><strong>Network</strong></span> tab. You will see<a id="id325" class="indexterm"/> the /collect requests have a <span class="strong"><strong>Status</strong></span> of 200, which means they've been successful:<div class="mediaobject"><img src="graphics/B05381_06_13.jpg" alt="How to do it..."/></div></li><li class="listitem">Refresh the page. You will see the following screen:<div class="mediaobject"><img src="graphics/B05381_06_14.jpg" alt="How to do it..."/></div></li><li class="listitem">Go to the <a id="id326" class="indexterm"/><span class="strong"><strong>Console</strong></span> tab of the DevTools:<div class="mediaobject"><img src="graphics/B05381_06_15.jpg" alt="How to do it..."/></div></li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec146"/>How it works...</h2></div></div></div><p>In<a id="id327" class="indexterm"/> the <code class="literal">service-worker.js</code> file, at the point of activation, <code class="literal">caches.delete(cacheName)</code> will find and delete redundant out of date caches by checking the cache name:</p><div class="informalexample"><pre class="programlisting">var version = 1,
  currentCaches = {
    'google-analytics': 'google-analytics-v' + version
  };

self.addEventListener('activate', function(event) {
  var cacheNamesExpected = Object.keys(currentCaches).map(function(key) {
    return currentCaches[key];
  });

  event.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(
        cacheNames.map(function(cacheName) {
          if (cacheNamesExpected.indexOf(cacheName) === -1) {
            console.log('DELETE: Out of date cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});</pre></div><p>The service worker <a id="id328" class="indexterm"/>will cache the initial requests; the subsequent requests to the same resource will be handled by the <code class="literal">fetch()</code> event handler of the service worker. The <code class="literal">fetch</code> event handler queries the cache for the requests in the <code class="literal">currentCaches</code> cache and sends back the response to the browser:</p><div class="informalexample"><pre class="programlisting">event.respondWith(
    caches.open(currentCaches['google-analytics']).then(function(cache) {
      return cache.match(event.request).then(function(res) {
        if (res) {
          console.log(
            '%c ✓ RESPONSE: %c Found in cache: %s',
            'color: #5EBD00', 'color: #000000', res
          );

          return res;
        }</pre></div><p>If the response was not found, it will send a fetch request to the network:</p><div class="informalexample"><pre class="programlisting"> return fetch(event.request.clone()).then(function(res) {
          console.log('%c ✓ RESPONSE: %c For %s from network: %O',
            'color: #5EBD00', 'color: #000000',
            event.request.url, res);

          if (res.status &lt; 400) {
            cache.put(event.request, res.clone());
          } </pre></div><p>If the response for the preceding request was successful, the response will be cloned and added to the cache, with the request being the key and the response being the value:</p><div class="informalexample"><pre class="programlisting">promises = promises.map(function(promise) {
      return Promise.resolve(promise);
    });</pre></div><p>Next, we make sure that we resolve the current promise as soon as another on the array gets<a id="id329" class="indexterm"/> resolved:</p><div class="informalexample"><pre class="programlisting">if (res.status &lt; 400) {
    cache.put(event.request, res.clone());
}</pre></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec147"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <span class="emphasis"><em>Implementing read-through caching</em></span> recipe in <a class="link" href="ch04.html" title="Chapter 4. Accessing Offline Content with Advanced Techniques">Chapter 4</a>, <span class="emphasis"><em>Accessing Offline Content with Advanced Techniques</em></span></li></ul></div></div></div></body></html>