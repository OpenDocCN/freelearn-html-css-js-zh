<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Asynchronous Programming</h1>
                </header>
            
            <article>
                
<p class="mce-root">Out of all chapters in this book, this is my favorite, because I've faced the consequences of bad asynchronous programming in the past, with callbacks on event listeners, HTTP requests, and basically everything that requires latency. </p>
<p class="mce-root">JavaScript has evolved from all these cluttered, unreadable, unmaintainable programming practices and that's what we're going to learn in this chapter.</p>
<p class="mce-root">Anyway, let's learn what an asynchronous program is. You can think of an asynchronous program as a program consisting of two lines of code, say L1 and L2. Now, we all know that in a given file, the code always executes from top to bottom. Also, it is intuitive such that the code will wait for each line to complete before executing the next line.</p>
<p class="mce-root">In the case of asynchronous programming, the code will execute L1, but it will not block L2 till L1 is completed. You can think of it as a kind of <em>non-blocking</em> programming.</p>
<p class="mce-root"><br/>
In this chapter, we'll cover:</p>
<ul>
<li class="mce-root">The JavaScript execution model</li>
<li>Event loops</li>
<li class="mce-root">The difficulties faced while writing asynchronous code</li>
<li class="mce-root">What are promises?</li>
<li>Creating and working with promises</li>
<li>How async/await differs from promises</li>
<li>Advanced asynchronous programming with async/await</li>
</ul>
<p>Let's start!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaScript execution model</h1>
                </header>
            
            <article>
                
<p>JavaScript code is executed in a single thread, that is, two pieces of a script cannot run at the same time. Each website opened in the browser gets a single thread for downloading, parsing, and executing the website, called the main thread.</p>
<p>The main thread also maintains a queue, which has asynchronous tasks queued to be executed one by one. These queued tasks can be event handlers, callbacks, or any other kind of task. New tasks are added to the queue as AJAX requests/responses happen, events occur, timers are registered, and more. One long-running queue task can stop the execution of all other queue tasks and the main script. The main thread executes the tasks in this queue whenever possible.</p>
<div class="packt_tip packt_infobox">HTML5 introduced web workers, which are actual threads running parallel to the main thread. When a web worker finishes executing or needs to notify the main thread, it simply adds a new event item to the queue. <span>We'll discuss web workers separately in <a href="">Chapter 9</a>, <em>JavaScript on the Web</em>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The event loop</h1>
                </header>
            
            <article>
                
<p>JavaScript follows an <em>event loop-based</em> model in how it works. This is very different from languages such as Java. Although modern JavaScript compilers implement a very complex and heavily optimized version of the event loop model, we can still basically understand how the event loop works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The call stack</h1>
                </header>
            
            <article>
                
<p>JavaScript is a single-threaded language. That means it can have one call stack at a given time (take one thread = one call stack). Furthermore, it implies that JavaScript cannot do more than two things at a time. Or can it?</p>
<p>When you call a function, you step inside that function. This function is added to the call stack. When the function returns a value, the function is popped from the call stack.</p>
<p>Let's take a look at this example:</p>
<pre>const page1 = $.syncHTTP('http://example.com/page1');<br/>const page2 = $.syncHTTP('http://example.com/page2');<br/>const page3 = $.syncHTTP('http://example.com/page3');<br/>const page4 = $.syncHTTP('http://example.com/page4');<br/><br/>console.log(page1, page2, page3, page4);</pre>
<p>For the sake of simplicity, consider <kbd>$.syncHTTP</kbd> as a predefined method that performs <strong>synchronous</strong> HTTP requests, that is, it'll block the code until completed. Let's assume every request takes ~500 ms to complete. Thus, if all these requests fire on clicking, say, a button, JavaScript immediately blocks the browser from doing anything for two seconds! That kills the user experience by a factor of 100!</p>
<p>Clearly, the call stack will consist of the first request, then after 500ms it'll remove that from the call stack, go to the second request, add that to the call stack, wait for 500ms for the response to receive, remove that from the call stack, and so on.</p>
<p>However, something strange happens when we make use of an asynchronous function such as <kbd>setTimeout()</kbd>.<strong> </strong>Take a look at this example:</p>
<pre>console.log('Start');<br/><br/>setTimeout( () =&gt; {<br/>  console.log('Middle');<br/>}, 1000 )<br/><br/>console.log('End');</pre>
<p>Here, as you expect, we'll first get <kbd>Start</kbd> printed because the call stack adds <kbd>console.log</kbd> to the stack, executes it, and removes it from the stack. Then the JavaScript comes to <kbd>setTimeout()</kbd>, adds it to the call stack, magically removes it without doing anything (more on this later), comes to the final <kbd>console.log</kbd>, adds it to the call stack, executes it to show <kbd>End</kbd>, and removes it from the stack.</p>
<p>Finally, magically, after 1 second, another <kbd>console.log</kbd> appears on the call stack, gets executed to print <kbd>Middle</kbd>, and then gets removed from the call stack.</p>
<p>Let's understand this magic.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Stack, queue, and Web APIs</h1>
                </header>
            
            <article>
                
<p>So what happened when we called <kbd>setTimeout()</kbd> in the previous code? Where did it magically disappear from the call stack, making room for the next function execution?</p>
<p>Well, <kbd>setTimeout()</kbd> is a web API provided by each browser individually. When you call setTimeout, the call stack sends the <kbd>setTimeout()</kbd> function call to the Web API, which then keeps track of the timer (in our case) till it's complete.</p>
<p>Once the Web API realizes the timer is complete, it does not immediately push the contents back to the stack. It pushes a callback of the  <span><kbd>setTimeout()</kbd> </span>function to something known as a queue<strong>.</strong> A Queue, as the name implies, could be a queue of functions to be executed.</p>
<p>This is when the event loop comes into play. The event loop is a simple little tool that looks at the stack and queue all the time and sees if the stack is empty; if the queue has something it takes it from the queue and pushes it to the stack.</p>
<p>So essentially, once you're out of the call stack (async function), your function has to wait for the call stack to get emptied before it gets executed.</p>
<p>Based upon the previous line, guess the output of this code:</p>
<pre>console.log('Hello');<br/>setTimeout( () =&gt; {<br/>  console.log('World')<br/>}, 0 ) // 0 second timeout (executes immediately)<br/>console.log('???')</pre>
<p>Take a moment to think about this. When you're ready, see the answer as follows:</p>
<pre><strong>Hello</strong><br/><strong>???</strong><br/><strong>World</strong></pre>
<p>Now the reason for this is, when you call <kbd>setTimeout()</kbd>, it is cleared off from the call stack and the next function is called. The Web API finds that the timer for <kbd>setTimeout()</kbd> is over and pushes it to a queue. The event loop waits for the final <kbd>console.log</kbd> statement to finish before pushing the callback function of <kbd>setTimeout()</kbd> to the stack. And thus we get the output shown earlier.</p>
<p>The following figure illustrates the previous code:</p>
<div class="CDPAlignCenter CDPAlign"><img height="265" src="assets/35452ed8-c8c9-4066-b0c9-026711589635.png" width="326"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing asynchronous code</h1>
                </header>
            
            <article>
                
<p>Although modern JavaScript brings promises and ES8 brings in async/await (which we'll see soon), still, there will be times when you'll encounter old APIs using callback mechanism/event-based mechanisms for their asynchronous operations.</p>
<p>It is important to understand the working of older asynchronous coding practices. This is because you cannot convert a callback-based asynchronous code piece to shining promises/async-await-based code without actually understanding how it works!</p>
<p>JavaScript, earlier, natively supported two patterns for writing asynchronous code, that is, the event pattern and the callback pattern. While writing asynchronous code, we usually start an asynchronous operation and register the event handlers or pass the callbacks, which will be executed once the operation is finished.</p>
<p>Event handlers or callbacks are used, depending on how the specific asynchronous API is designed. An API that is designed for an event pattern can be wrapped with some custom code to create the callback pattern for the API, and vice-versa. For example, AJAX is designed for the event pattern, but jQuery AJAX exposes it as a callback pattern. Let's consider some examples of writing asynchronous code involving events and callbacks and their difficulties.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous code involving events</h1>
                </header>
            
            <article>
                
<p>For asynchronous JavaScript APIs involving events, you need to register the success and error event handlers that will be executed depending on whether the operation was a success or failure respectively.</p>
<p>For example, while making an AJAX request, we register the event handlers that will be executed depending on whether the AJAX request was made successfully or not. Consider this code snippet, which makes an AJAX request and logs the retrieved information:</p>
<pre>function displayName(json) {<br/>    try {<br/>        //we usally display it using DOM<br/>        console.log(json.Name);<br/>    } catch(e) {<br/>    console.log("Exception: " + e.message);<br/>    }<br/>}<br/><br/>function displayProfession(json) {<br/>    try {<br/>        console.log(json.Profession);<br/>    } catch(e) {<br/>        console.log("Exception: " + e.message);<br/>    }<br/>}<br/><br/>function displayAge(json) {<br/>    try {<br/>        console.log(json.Age);<br/>    } catch(e) {<br/>        console.log("Exception: " + e.message);<br/>    }<br/>}<br/><br/>function displayData(data) {<br/>    try {<br/>        const json = JSON.parse(data);<br/>        displayName(json);<br/>        displayProfession(json);<br/>        displayAge(json);<br/>    } catch(e) {<br/>        console.log("Exception: " + e.message);<br/>    }<br/>}<br/><br/>const request = new XMLHttpRequest();<br/>const url = "data.json";<br/>request.open("GET", url);<br/>request.addEventListener("load", function(){<br/><br/>    if(request.status === 200) {<br/>        displayData(request.responseText);<br/>    } else {<br/>        console.log("Server Error: " + request.status);<br/>    }<br/><br/>}, false);<br/><br/>request.addEventListener("error", function(){<br/>    console.log("Cannot Make AJAX Request");<br/>}, false);<br/><br/>request.send();</pre>
<p>Here, we assume the <kbd>data.json</kbd> file to have this content:</p>
<pre>{<br/>    "Name": "Eden",<br/>    "Profession": "Developer",<br/>    "Age": "25"<br/>}</pre>
<p>The <kbd>send()</kbd> method of the <kbd>XMLHttpRequest()</kbd> object is executed asynchronously, and retrieves the <kbd>data.json</kbd> file and calls the load or error event handler depending on whether the request was made successfully or not.</p>
<p>There is absolutely no issue with how this AJAX works, but the issue is how we write the code involving events. Here are the issues that we faced while writing the previous code:</p>
<ul>
<li>We had to add an exception handler for every block of code that will be executed asynchronously. We can't just wrap the whole code using a single <kbd>try</kbd> and <kbd>catch</kbd> statement. This makes it difficult to catch the exceptions.</li>
<li>The code is harder to read, as it's difficult to follow the code flow due to the nested function calls.</li>
</ul>
<p>If another part of the program wants to know if the asynchronous operation is finished, pending, or being executed then we have to maintain custom variables for that purpose. So we can say it is difficult to find the state of an asynchronous operation. This code can get even more complicated and harder to read if you are nesting multiple AJAX or any other asynchronous operations. For example, after displaying the data, you may want to ask the user to verify if the data is correct or not, and then send the Boolean value back to the server. Here is the code example to demonstrate this:</p>
<pre>function verify() {<br/>    try {<br/>        const result = confirm("Is the data correct?");<br/>        if (result) {<br/>        //make AJAX request to send data to server<br/>        } else {<br/>        //make AJAX request to send data to server<br/>        }<br/>    } catch(e) {<br/>        console.log("Exception: " + e.message);<br/>    }<br/>}<br/><br/>function displayData(data) {<br/>    try {<br/>        const json = JSON.parse(data);<br/>        displayName(json);<br/>        displayProfession(json);<br/>        displayAge(json);<br/>        verify();<br/>    } catch(e) {<br/>        console.log("Exception: " + e.message);<br/>    }<br/>}</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous code involving callbacks</h1>
                </header>
            
            <article>
                
<p>For asynchronous JavaScript APIs involving callbacks, you need to pass success and error callbacks, which will be called depending on whether the operation was a success or failure respectively. For example, while making an AJAX request using jQuery, we need to pass the callbacks, which will be executed depending on whether the AJAX request was made successfully or not. Consider this code snippet that makes an AJAX request using jQuery and logs the retrieved information:</p>
<pre><span>function displayName(json) {</span><br/><span>    try {</span><br/><span>        console.log(json.Name);</span><br/><span>    } </span><span>catch(e) {</span><br/><span>        console.log("Exception: " + e.message);</span><br/><span>    }</span><br/><span>}<br/></span><br/><span>function displayProfession(json) {</span><br/><span>    try {</span><br/><span>        console.log(json.Profession);</span><br/><span>    } catch(e) {</span><br/><span>        console.log("Exception: " + e.message);</span><br/><span>    }</span><br/><span>}<br/></span><br/><span>function displayAge(json) {</span><br/><span>    try {</span><br/><span>        console.log(json.Age);</span><br/><span>    } catch(e) {</span><br/><span>        console.log("Exception: " + e.message);</span><br/><span>    }</span><br/><span>}<br/></span><br/><span>function displayData(data) {</span><br/><span>    try {</span><br/><span>        const json = JSON.parse(data);</span><br/><span>        displayName(json);</span><br/><span>        displayProfession(json);</span><br/><span>        displayAge(json);</span><br/><span>    } catch(e) {</span><br/><span>        console.log("Exception: " + e.message);</span><br/><span>    }</span><br/><span>}<br/></span><br/><span>$.ajax({<br/>url: "data.</span>json<span>", <br/>success: function(result, status, </span>responseObject<span>) {</span><br/><span>    displayData(responseObject.responseText);</span><br/><span>}, <br/>error: function(</span>xhr<span>,status,error) {</span><br/><span>    console.log("Cannot Make AJAX Request. Error is: " + error);</span><br/><span>}<br/>});</span></pre>
<p>Even here, there is absolutely no issue with how this jQuery AJAX works, but the issue is how we write the code involving callbacks. Here are the issues that we faced while writing the preceding code:</p>
<ul>
<li>It is difficult to catch the exceptions, as we have to use multiple <kbd>try</kbd> and <kbd>catch</kbd> statements.</li>
<li>The code is harder to read, as it's difficult to follow the code flow due to the nested function calls.</li>
<li>It's difficult to maintain the state of the asynchronous operation. This code will get even more complicated if we nest multiple jQuery AJAX or any other asynchronous operations.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Promises and async programming</h1>
                </header>
            
            <article>
                
<p>JavaScript now has a new native pattern for writing asynchronous code called the <strong>Promise</strong> pattern. This new pattern removes the common code issues that the event and callback pattern had. It also makes the code look more like synchronous code. A promise (or a <kbd>Promise</kbd> object) represents an asynchronous operation. Existing asynchronous JavaScript APIs are usually wrapped with promises, and the new JavaScript APIs are purely implemented using promises. Promises are new in JavaScript but are already present in many other programming languages. Programming languages, such as C# 5, C++ 11, Swift, Scala, and more are some examples that support promises.<br/>
Let's see how to use promises.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Promise states</h1>
                </header>
            
            <article>
                
<p>A promise is always in one of these states:</p>
<ul>
<li><strong>Fulfilled:</strong> If the resolve callback is invoked with a non-promise object as the argument or no argument, then we say that the promise is fulfilled</li>
<li><strong>Rejected:</strong> If the rejecting callback is invoked or an exception occurs in the executor scope, then we say that the promise is rejected</li>
<li><strong>Pending:</strong> If the resolve or reject callback is yet to be invoked, then we say that the promise is pending</li>
<li><strong>Settled:</strong> A promise is said to be settled if it's either fulfilled or rejected, but not pending</li>
</ul>
<p><span>Once a promise is fulfilled or rejected, it cannot be transitioned back. An attempt to </span><span>transition it will have no effect.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Promises versus callbacks</h1>
                </header>
            
            <article>
                
<p>Suppose you wanted to perform three AJAX requests one after another. Here's a dummy implementation of that in callback-style:</p>
<pre>ajaxCall('http://example.com/page1', response1 =&gt; {<br/>   ajaxCall('http://example.com/page2'+response1, response2 =&gt; {<br/>     ajaxCall('http://example.com/page3'+response2, response3 =&gt; {<br/>       console.log(response3)<br/>     }<br/>   })<br/>})</pre>
<p>You can see how quickly you can enter into something known as <strong>callback-hell</strong>. Multiple nesting makes code not only unreadable but also difficult to maintain. Furthermore, if you start processing data after every call, and the next call is based on a previous call's response data, the complexity of the code will be unmatchable.</p>
<div class="packt_infobox">Callback-hell refers to multiple asynchronous functions nested inside each other's callback functions. This makes code harder to read and maintain.</div>
<p>Promises can be used to flatten this code. Let's take a look:</p>
<pre>ajaxCallPromise('http://example.com/page1')<br/>.then( response1 =&gt; ajaxCallPromise('http://example.com/page2'+response1) )<br/>.then( response2 =&gt; ajaxCallPromise('http://example.com/page3'+response2) )<br/>.then( response3 =&gt; console.log(response3) )</pre>
<p>You can see the code complexity is suddenly reduced and the code looks much cleaner and readable. Let's first see how <kbd>ajaxCallPromise</kbd> would've been implemented.</p>
<p>Please read the following explanation for more clarity of preceding code snippet.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Promise constructor and (resolve, reject) methods</h1>
                </header>
            
            <article>
                
<p>To convert an existing <em>callback type</em> function to <kbd>Promise</kbd>, we have to use the <kbd>Promise</kbd> constructor. In the preceding example, <kbd>ajaxCallPromise</kbd> returns a <kbd>Promise</kbd>, which can be either <strong>resolved</strong> or <strong>rejected</strong> by the developer. Let's see how to implement <kbd>ajaxCallPromise</kbd>:</p>
<pre>const ajaxCallPromise = url =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    // DO YOUR ASYNC STUFF HERE<br/>    $.ajaxAsyncWithNativeAPI(url, function(data) {<br/>      if(data.resCode === 200) {<br/>          resolve(data.message)<br/>      } else {<br/>          reject(data.error)<br/>      }<br/>    })<br/>  })<br/>}</pre>
<p>Hang on! What just happened there? </p>
<ol>
<li>First, we returned <kbd>Promise</kbd> from the <kbd>ajaxCallPromise</kbd> function. That means whatever we do now will be a <kbd>Promise</kbd>.</li>
<li>A <kbd>Promise</kbd> accepts a function argument, with the function itself accepting two very special arguments, that is, resolve and reject.</li>
<li><kbd>resolve</kbd> and <kbd>reject</kbd> are themselves functions.</li>
<li>When, inside a <kbd>Promise</kbd> constructor function body, you call <kbd>resolve</kbd> or <kbd>reject</kbd>, the promise acquires a <em>resolved</em> or <em>rejected</em> value that is unchangeable later on.</li>
<li>We then make use of the native callback-based API and check if everything is OK. If everything is indeed OK, we resolve the <kbd>Promise</kbd> with the value being the message sent by the server (assuming a JSON response).</li>
<li>If there was an error in the response, we reject the promise instead.</li>
</ol>
<div class="packt_tip packt_infobox">You can return a promise in a then call. When you do that, you can flatten the code instead of chaining promises again.</div>
<p>For example, if <kbd>foo()</kbd> and <kbd>bar()</kbd> both return <kbd>Promise</kbd>, <kbd>then</kbd>, instead of:</p>
<pre>foo().then( res =&gt; {<br/>   bar().then( res2 =&gt; {<br/>     console.log('Both done')<br/>   })<br/>})</pre>
<p>We can <span>write it as follows:</span></p>
<pre>foo()<br/>.then( res =&gt; bar() ) // bar() returns a Promise<br/>.then( res =&gt; {<br/>   console.log('Both done')<br/>})</pre>
<p>This flattens the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The then(onFulfilled, onRejected) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>then()</kbd> method of a <kbd>Promise</kbd> object lets us do a task after a <kbd>Promise</kbd> has been fulfilled or rejected. The task can also be another event-driven or callback-based asynchronous operation.</p>
<p>The <kbd>then()</kbd> method of a <kbd>Promise</kbd> object takes two arguments, that is, the <kbd>onFulfilled</kbd> and <kbd>onRejected</kbd> callbacks. The <kbd>onFulfilled</kbd> callback is executed if the <kbd>Promise</kbd> object was fulfilled, and the <kbd>onRejected</kbd> callback is executed if the <kbd>Promise</kbd> was rejected.</p>
<p>The <kbd>onRejected</kbd> callback is also executed if an exception is thrown in the scope of the executor. Therefore, it behaves like an exception handler, that is, it catches the exceptions.<br/>
The <kbd>onFulfilled</kbd> callback takes a parameter, that is, the fulfilment value of the promise. Similarly, the <kbd>onRejected</kbd> callback takes a parameter, that is, the reason for rejection:</p>
<pre>ajaxCallPromise('http://example.com/page1').then( <br/>  successData =&gt; { console.log('Request was successful') },<br/>  failData =&gt; { console.log('Request failed' + failData) } <br/>)</pre>
<p>When we reject the promise inside the <kbd>ajaxCallPromise</kbd> definition, the second function will execute (<kbd>failData</kbd> one) instead of the first function.</p>
<p>Let's <span>take </span>one more example by converting <kbd>setTimeout()</kbd> from a callback to a promise. This is how <kbd>setTimeout()</kbd> looks:</p>
<pre>setTimeout( () =&gt; {<br/>  // code here executes after TIME_DURATION milliseconds<br/>}, TIME_DURATION)</pre>
<p>A promised version will look something like the following:</p>
<pre>const PsetTimeout = duration =&gt; {<br/>   return new Promise((resolve, reject) =&gt; {<br/>      setTimeout( () =&gt; {<br/>         resolve()<br/>      }, duration);<br/>   })<br/>}<br/><br/>// usage:<br/><br/>PsetTimeout(1000)<br/>.then(() =&gt; {<br/>  console.log('Executes after a second')<br/>})</pre>
<p>Here we resolved the promise without a value. If you do that, it gets resolved with a value equal to undefined.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The catch(onRejected) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>catch()</kbd> method of a <kbd>Promise</kbd> object is used instead of the <kbd>then()</kbd> method when we use the <kbd>then()</kbd> method only to handle errors and exceptions. There is nothing special about how the <kbd>catch()</kbd> method works. It's just that it makes the code much easier to read, as the word <em>catch</em> makes it more meaningful.</p>
<p>The <kbd>catch()</kbd> method just takes one argument, that is, the <kbd>onRejected</kbd> callback. The <kbd>onRejected</kbd> callback of the <kbd>catch()</kbd> method is invoked in the same way as the <kbd>onRejected</kbd> callback of the <kbd>then()</kbd> method.<br/>
The <kbd>catch()</kbd> method always returns a promise. Here is how a new <kbd>Promise</kbd> object is returned by the <kbd>catch()</kbd> method:</p>
<ul>
<li>If there is no return statement in the <kbd>onRejected</kbd> callback, then a new fulfilled <kbd>Promise</kbd> is created internally and returned.</li>
<li>If we return a custom <kbd>Promise</kbd>, then it internally creates and returns a new <kbd>Promise</kbd> object. The new promise object resolves the custom promise object.</li>
<li>If we return something else other than a custom <kbd>Promise</kbd> in the <kbd>onRejected</kbd> callback, then a new <kbd>Promise</kbd> object is created internally and returned. The new <kbd>Promise</kbd> object resolves the returned value.</li>
<li>If we pass null instead of the <kbd>onRejected</kbd> callback or omit it, then a callback is created internally and used instead. The internally created <kbd>onRejected</kbd> callback returns a rejected <kbd>Promise</kbd> object. The reason for the rejection of the new <kbd>Promise</kbd> object is the same as the reason for the rejection of a parent <kbd>Promise</kbd> object.</li>
<li>If the <kbd>Promise</kbd> object to which <kbd>catch()</kbd> is called gets fulfilled, then the <kbd>catch()</kbd> method simply returns a new fulfilled promise object and ignores the <kbd>onRejected</kbd> callback. The fulfillment value of the new <kbd>Promise</kbd> object is the same as the fulfillment value of the parent <kbd>Promise</kbd>.</li>
</ul>
<p>To understand the <kbd>catch()</kbd> method, consider this code:</p>
<pre>ajaxPromiseCall('http://invalidURL.com')<br/>.then(success =&gt; { console.log(success) },<br/>failed =&gt; { console.log(failed) });</pre>
<p>This code can be rewritten in this way using the <kbd>catch()</kbd> method:</p>
<pre>ajaxPromiseCall('http://invalidURL.com')<br/>.then(success =&gt; console.log(success))<br/>.catch(failed =&gt; console.log(failed));</pre>
<p>These two code snippets work more or less in the same way.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Promise.resolve(value) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>resolve()</kbd> method of the <kbd>Promise</kbd> object takes a value and returns a <kbd>Promise</kbd> object that resolves the passed value. The <kbd>resolve()</kbd> method is basically used to convert a value to a <kbd>Promise</kbd> object. It is useful when you find yourself with a value that may or may not be a <kbd>Promise</kbd>, but you want to use it as a <kbd>Promise</kbd>. For example, jQuery promises have different interfaces from ES6 promises. Therefore, you can use the <kbd>resolve()</kbd> method to convert jQuery promises into ES6 promises.</p>
<p>Here is an example that demonstrates how to use the <kbd>resolve()</kbd> method:</p>
<pre>const p1 = Promise.resolve(4);<br/>p1.then(function(value){<br/>  console.log(value);<br/>}); //passed a promise object<br/><br/>Promise.resolve(p1).then(function(value){ <br/> console.log(value);<br/>});<br/><br/>Promise.resolve({name: "Eden"})<br/>.then(function(value){ <br/>  console.log(value.name);<br/>});</pre>
<p class="mce-root">The output is as follows:</p>
<pre class="mce-root"><strong>4<br/>4</strong><br/><strong>Eden</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Promise.reject(value) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>reject()</kbd> method of the <kbd>Promise</kbd> object takes a value and returns a rejected <kbd>Promise</kbd> object with the passed value as the reason. Unlike the <kbd>Promise.resolve()</kbd> method, the <kbd>reject()</kbd> method is used for debugging purposes and not for converting values into promises.</p>
<p>Here is an example that demonstrates how to use the <kbd>reject()</kbd> method:</p>
<pre>const p1 = Promise.reject(4);<br/>p1.then(null, function(value){<br/>console.log(value);<br/>});<br/>Promise.reject({name: "Eden"})<br/>.then(null, function(value){<br/>console.log(value.name);<br/>});</pre>
<p>The output is as follows:</p>
<pre><strong>4</strong><br/><strong>Eden</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Promise.all(iterable) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>all()</kbd> method of the <kbd>Promise</kbd> object takes an iterable object as an argument and returns a <kbd>Promise</kbd> that fulfills when all of the promises in the iterable object have been fulfilled.</p>
<p>This can be useful when we want to execute a task after some asynchronous operations have finished. Here is a code example that demonstrates how to use the <kbd>Promise.all()</kbd> method:</p>
<pre>const p1 = new Promise(function(resolve, reject){<br/> setTimeout(function(){<br/>  resolve();<br/> }, 1000);<br/>});<br/><br/>const p2 = new Promise(function(resolve, reject){<br/> setTimeout(function(){<br/>  resolve();<br/> }, 2000);<br/>});<br/><br/>const arr = [p1, p2];<br/>Promise.all(arr).then(function(){<br/>console.log("Done"); //"Done" is logged after 2 seconds<br/>});</pre>
<p>If the iterable object contains a value that is not a <kbd>Promise</kbd> object, then it's converted to the <kbd>Promise</kbd> object using the <kbd>Promise.resolve()</kbd> method.</p>
<p>If any of the passed promises get rejected, then the <kbd>Promise.all()</kbd> method immediately returns a new rejected <kbd>Promise</kbd> for the same reason as the rejected passed <kbd>Promise</kbd>. Here is an example to demonstrate this:</p>
<pre>const p1 = new Promise(function(resolve, reject){<br/> setTimeout(function(){<br/>  reject("Error");<br/> }, 1000);<br/>});<br/><br/>const p2 = new Promise(function(resolve, reject){<br/> setTimeout(function(){<br/>  resolve();<br/> }, 2000);<br/>});<br/><br/>const arr = [p1, p2];<br/>Promise.all(arr).then(null, function(reason){<br/>console.log(reason); //"Error" is logged after 1 second<br/>});</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Promise.race(iterable) method</h1>
                </header>
            
            <article>
                
<p>The <kbd>race()</kbd> method of the <kbd>Promise</kbd> object takes an iterable object as the argument and returns a <kbd>Promise</kbd> that fulfills or rejects as soon as one of the promises in the iterable object is fulfilled or rejected, with the fulfillment value or reason from that <kbd>Promise</kbd>.</p>
<p>As the name suggests, the <kbd>race()</kbd> method is used to race between promises and see which one finishes first. Here is a code example that shows how to use the <kbd>race()</kbd> method:</p>
<pre>var p1 = new Promise(function(resolve, reject){ <br/>setTimeout(function(){ <br/>resolve("Fulfillment Value 1"); <br/>}, 1000);<br/>});<br/>var p2 = new Promise(function(resolve, reject){ <br/>setTimeout(function(){<br/>resolve("fulfillment Value 2"); <br/>}, 2000);<br/>});<br/>var arr = [p1, p2];<br/>Promise.race(arr).then(function(value){ <br/>console.log(value); //Output "Fulfillment value 1"<br/>}, function(reason){ <br/>console.log(reason);<br/>});</pre>
<p>Now at this point, I assume you have a basic understanding of how promises work, what they are, and how to convert a callback-like API into a promised API. Let's take a look at <strong>async/await</strong>, the future of asynchronous programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">async/await – the future of asynchronous programming</h1>
                </header>
            
            <article>
                
<p>To be honest, async/await blows away whatever you read previously about promises. But hey! You obviously need to know how promises work in order to know how to work with async/await. async/await are built on top of promises; however, once you get used to them, there is no going back to promises (unless, again, you need to convert a callback type API to async/await (you need to use promises for that).)</p>
<p>About async/await:</p>
<ul>
<li>It's for asynchronous coding</li>
<li>It makes code look extremely similar to synchronous coding and thus makes it extremely powerful and easy on the eyes</li>
<li>It is built on top of promises</li>
<li>It makes error handling a cake walk. You can finally use <kbd>try</kbd> and <kbd>catch</kbd> with asynchronous coding!</li>
<li>ES8 introduced async/await and, by the time you're reading this, it will have been implemented in all browsers natively (at the time of writing, only IE and Opera don't support async/await)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">async/await versus promises</h1>
                </header>
            
            <article>
                
<p>Although async/await are actually promises under the hood, they help a lot by adding a ton of readability to code. On the surface level, I believe a developer should be aware of minute differences in the usage of async/await versus promises. Here's a glimpse of these:</p>
<table>
<tbody>
<tr>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>async/await</strong></div>
</td>
<td>
<div class="CDPAlignCenter CDPAlign"><strong>promises</strong></div>
</td>
</tr>
<tr>
<td>Extremely clean code base</td>
<td>Uglier codebase with nested promises</td>
</tr>
<tr>
<td>Error handling with native <kbd>try</kbd>-<kbd>catch</kbd> blocks</td>
<td>Separate <kbd>catch()</kbd> method for error handling</td>
</tr>
<tr>
<td>Syntactic sugar for promises (built on promises)</td>
<td>Native implementation in standard</td>
</tr>
<tr>
<td>Introduced in ES8</td>
<td>Introduced in ES6</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The async function and await keyword</h1>
                </header>
            
            <article>
                
<p>In order to use the <kbd>await</kbd> keyword, we need to have an <kbd>async</kbd> function. The difference between a function and an <kbd>async</kbd> function is that the <kbd>async</kbd> function is followed by an <em>async</em> keyword. Let's take a look at an example:</p>
<pre>async function ES8isCool() {<br/>   // asynchronous work<br/>   const information = await getES8Information() // Here getES8Information itself is an async function<br/>}</pre>
<p>This is the crux of the thing. You can only use <kbd>await</kbd> inside an <kbd>async</kbd> function. This is because, when you call an <kbd>async</kbd> function, it returns a <kbd>Promise</kbd>. However, instead of using then with it, which eventually makes it a promise chain, we use the <kbd>await</kbd> keyword in front of it to kind of pause the execution <em>(not really)</em> inside the <kbd>async</kbd> function context.</p>
<p>Let's take a look at a real example:</p>
<pre>function sendAsyncHTTP(url) {<br/> return new Promise((resolve, reject) =&gt; {<br/>  const xhttp = new XMLHttpRequest()<br/>  xhttp.onreadystatechange = function() {<br/>    if (this.readyState == 4) { // success<br/>    if(this.status == 200) {<br/>           resolve(xhttp.responseText)<br/>      } else {<br/>           console.log(this.readyState, this.status)<br/>           reject(xhttp.statusText) // failed<br/>      }<br/>    }<br/>  };<br/>  xhttp.open("GET", url, true);<br/>  xhttp.send();<br/> })<br/>}<br/><br/>async function doSomeTasks() {<br/>   const documentFile1 = await sendAsyncHTTP('http://example.com')<br/>   console.log('Got first document')<br/>   const documentFile2 = await sendAsyncHTTP('http://example.com/?somevar=true')<br/>   console.log('Got second document')<br/>   return documentFile2<br/>}<br/><br/>doSomeTasks() // returns a Promise<br/>.then( res =&gt; console.log("res is a HTML file") ) </pre>
<p>OK! First things first. Remember that an async function returns a <kbd>Promise</kbd>? Why didn't we use the <kbd>async</kbd> keyword with <kbd>sendAsyncHTTP</kbd>? Why did we return a <kbd>Promise</kbd> from <kbd>sendAsyncHTTP</kbd>? Why won't the code below work?</p>
<pre>async function sendAsyncHTTP(url) {<br/>  const xhttp = new XMLHttpRequest()<br/>  xhttp.onreadystatechange = function() { // &lt;-- hint<br/>    if(this.status == 200) {<br/>          resolve(xhttp.responseText)<br/>     } else {<br/>          console.log(this.readyState, this.status)<br/>          reject(xhttp.statusText) // failed<br/>     }<br/>  };<br/>  xhttp.open("GET", url, true);<br/>  xhttp.send();<br/>}</pre>
<p>Carefully take a look at the hint comment line. Since we're using a function in <kbd>onreadystatechange</kbd>, returning inside that function does not return the parent function. So essentially, you return <kbd>undefined</kbd> from the <kbd>sendAsyncHTTP</kbd> function instead of a valid response. Had there been other async functions used with the <kbd>await</kbd> keyword, we could've returned a value without making use of the <kbd>new Promise()</kbd> declaration.</p>
<p>Confused? Stay with me. If you didn't really get what happened previously, continue reading. You will. Take a look at the next function:</p>
<pre>async function doSomeTasks() {<br/>   const documentFile1 = await sendAsyncHTTP('http://example.com')<br/>   console.log('Got first document')<br/>   const documentFile2 = await sendAsyncHTTP('http://example.com/?somevar=true')<br/>   console.log('Got second document')<br/>   return documentFile2<br/>}</pre>
<p>Look carefully! We didn't return a <kbd>Promise</kbd> here by using <kbd>return new Promise</kbd>. Why does this work then? This is because this function actually waits for an <kbd>async</kbd> function using the <kbd>await</kbd> keyword. See, when the code comes to <kbd>Line 1</kbd>, it halts before executing the next line <kbd>(console.log('Got first document'))</kbd>.</p>
<p>Whenever JavaScript finds await followed by a function that returns a <kbd>Promise</kbd>, it will wait for that promise to either resolve or reject. In our case, <kbd>sendAsyncHTTP</kbd> resolves with the source code of the website, so we get that back in the <kbd>documentFile2</kbd> variable.</p>
<p>We do a similar thing again but with a slightly different URL this time. And once we're done with both, we return  <kbd>documentFile2</kbd>. Hang on here. Remember again, the <kbd>async function</kbd> returns a <kbd>Promise</kbd>. That means, whatever value you return from an <kbd>async</kbd> function, it is actually the resolved value of that returned <kbd>Promise</kbd>.<strong> </strong>And whatever value you <kbd>throw</kbd> inside the <kbd>async</kbd> function, it goes as the rejected value of that returned <kbd>Promise</kbd>. This is important!</p>
<p>Finally, we called <kbd>doSomeTasks()</kbd>, and as mentioned it returned a <kbd>Promise</kbd>. Therefore, you can use a then chain with it to just log to the console that everything was done. The <kbd>res</kbd> variable consists of whatever value you returned. The <kbd>catch()</kbd> method will catch any error you throw inside the <kbd>async</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Making asynchronous code look synchronous</h1>
                </header>
            
            <article>
                
<p>Try to convert the following <kbd>Promise</kbd> code to async/await:</p>
<pre>const doSomething = () =&gt; {<br/>  return p1().then(res1 =&gt; {<br/>      return p2().then(res2 =&gt; {<br/>          // finally we need both res1 and res2 <br/>          return p3(res1, res2)<br/>        })<br/>    })<br/>}</pre>
<p>You see? Even with promises, you cannot avoid nesting if you need to make use of the first promise's value somewhere down the chain. This is because, if you flatten out the promise chain, you eventually lose the previous promise's returned values.</p>
<p>Ready for the answer? Here you go:</p>
<pre>const doSomething = async () =&gt; {<br/>  const res1 = await p1()<br/>  const res2 = await p2()<br/>  return p3(res1, res2)<br/>}</pre>
<p>Can you see the code clarity in the latter code? It is remarkable! Try to use async/await wherever you can, instead of callbacks or promises.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned how JavaScript executes asynchronous code. We learned about event loops, and basically how JavaScript manages all asynchronous and multiple tasks without using any additional threads. We learned about different patterns for writing asynchronous code.</p>
<p>We saw how promises make it easier to read and write asynchronous code, and how async/await blows away promises in practice. In the next chapter, we'll take a look at how to organize your JavaScript code with a modular programming approach.</p>


            </article>

            
        </section>
    </body></html>