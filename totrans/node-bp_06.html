<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;6.&#xA0;Using Node.js as a Command-line Tool"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06" class="calibre1"/>Chapter 6. Using Node.js as a Command-line Tool</h1></div></div></div><p class="calibre7">In the previous chapters, we learned how to use Node.js with client-side frameworks, such as AngularJS and Backbone.js. Each time, we ran the backend from the command line. Node.js is suitable not only for web applications, but also for developing command-line tools. The access to the filesystem, the various built-in modules, and the great community makes Node.js an attractive environment for such kind of programs.</p><p class="calibre7">In this chapter, we will detail the process of developing a command-line tool to upload pictures on <a id="id238" class="calibre1"/>
<span class="strong"><strong class="calibre8">Flickr</strong></span>. By the end of this chapter, we will have created a program that finds images in a particular directory and uploads them on Internet portals.</p></div>

<div class="book" title="Chapter&#xA0;6.&#xA0;Using Node.js as a Command-line Tool">
<div class="book" title="Exploring the required modules"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch06lvl1sec40" class="calibre1"/>Exploring the required modules</h1></div></div></div><p class="calibre7">We will use several modules to <a id="id239" class="calibre1"/>make our life easier, which are listed as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">fs</code>: This gives us <a id="id240" class="calibre1"/>access to the filesystem, and is a built-in feature of the Node.js module.</li><li class="listitem"><code class="email">optimist</code>: This is a <a id="id241" class="calibre1"/>module that parses the parameters passed to our Node.js script.</li><li class="listitem"><code class="email">readline</code>: This <a id="id242" class="calibre1"/>allows the reading of a stream (such as <code class="email">process.stdin</code>) on a line-by-line basis. We will use it for getting input from the user while our application is still running. The module is added in Node.js by default.</li><li class="listitem"><code class="email">glob</code>: This <a id="id243" class="calibre1"/>module reads a directory and returns all the existing files that match a predefined specific pattern.</li><li class="listitem"><code class="email">open</code>: At some <a id="id244" class="calibre1"/>point, we will need to open a page in the user's default browser. Node.js runs on different operating systems that have different commands to open the default browser. This module helps us by providing one API.</li><li class="listitem"><code class="email">flapi</code>: This is the <a id="id245" class="calibre1"/>Flickr API wrapper used to communicate with Flickr's services.</li></ul></div><p class="calibre7">Based on the preceding list, we can<a id="id246" class="calibre1"/> write <a id="id247" class="calibre1"/>and use the following <code class="email">package</code>.<code class="email">json</code> file:</p><div class="informalexample"><pre class="programlisting">{
  "name": "FlickrUploader",
  "description": "Command line tool",
  "version": "0.0.1",
  "dependencies": {
    "flapi": "*",
    "open": "*",
    "optimist": "*",
    "glob": "*"
  },
  "main": "index.js",
  "bin": {
    "flickruploader": "./index.js"
  }
}</pre></div><p class="calibre7">The entry point of our script is the <code class="email">index.js</code> file. Thus, we set it as a value of the <code class="email">main</code> property. There is another feature which we haven't used so far—the <code class="email">bin</code> property. This is the key/pair mapping of the binary script names and the Node.js script paths. In other words, when our module is published in the Node.js package manager's register and later installed, our console will automatically have the <code class="email">flickruploader</code> command available. During the installation, the <code class="email">npm</code> command checks whether we have passed something to the <code class="email">bin</code> property. If yes, then it creates our script's <code class="email">symlink</code>. It is also important that we add the <code class="email">#!/usr/bin/env </code>node at the top of our <code class="email">index.js</code> file. This is how the system will know that the script should be processed with Node.js. At the end, if we type the command and press <span class="strong"><em class="calibre9">Enter</em></span>, our script will be run.</p></div></div>
<div class="book" title="Planning the application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec41" class="calibre1"/>Planning the application</h1></div></div></div><p class="calibre7">We can split the <a id="id248" class="calibre1"/>command-line tool into two parts: the first one reads a directory and returns all the files in it and the second one sends the images to Flickr. It's a good idea to form these two functionalities in different modules. The following diagram shows how our project will appear:</p><div class="mediaobject"><img src="../images/00011.jpeg" alt="Planning the application" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The <code class="email">images</code> directory <a id="id249" class="calibre1"/>will be used as a test folder, that is, our script will do its job in that directory. Of course, we can have another one if we want. The two modules mentioned previously are saved in the <code class="email">lib</code> directory. So, we should first get the files (<code class="email">Files.js</code>) and then upload them (<code class="email">Flickr.js</code>) to the portal. The two operations are asynchronous, so both the modules should accept <a id="id250" class="calibre1"/>
<span class="strong"><strong class="calibre8">callbacks</strong></span>. The following is the content of the <code class="email">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var flickr = require('./lib/Flickr');
var files = require('./lib/Files');
var flickrOptions = {};

files(function(images) {
  flickr(flickrOptions, images, function() {
    console.log("All the images uploaded.");
    process.exit(1);
  })
});</pre></div><p class="calibre7">The <code class="email">Files</code> module will look into the specified folder and scan it for subfolders and images. All the files that are pictures are returned as a parameter of the passed callback. These pictures are sent to the <code class="email">Flickr</code> module. Along with the files, we will also pass few settings needed to access Flickr's services. Eventually, once everything goes well, we will call <code class="email">process.exit(1)</code> to terminate the program and return the user to the terminal.</p></div>
<div class="book" title="Obtaining images from a folder"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec42" class="calibre1"/>Obtaining images from a folder</h1></div></div></div><p class="calibre7">The <code class="email">Files.js</code> file starts <a id="id251" class="calibre1"/>with the <a id="id252" class="calibre1"/>definition of the required modules:</p><div class="informalexample"><pre class="programlisting">var fs = require('fs');
var argv = require('optimist').argv;
var readline = require('readline');
var glob = require('glob');</pre></div><p class="calibre7">Immediately after, we need to define two variables. The <code class="email">currentDirectory</code> variable stores the path to the current working directory and <code class="email">rl</code> is an instance of the <code class="email">readline</code> module.</p><div class="informalexample"><pre class="programlisting">var currentDirectory = process.cwd() + '/';
var rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});</pre></div><p class="calibre7">The <code class="email">createInterface</code> function accepts an object. The two required fields are <code class="email">input</code> and <code class="email">output</code>. The <code class="email">input</code> field will point to the incoming readable stream and <code class="email">output</code> to the writable stream. In our case, the user will type data directly into the terminal/console, so we will pass <code class="email">process.stdin</code>.</p><p class="calibre7">At the beginning of the chapter, we mentioned the <code class="email">optimist</code> module. We will use it to get the parameter from the command line. In our case, this will be the directory used to parse. It's always good to provide an alternative way to apply settings, that is, in addition to asking the user, accept a command-line argument. Every Node.js script has a global object, <code class="email">process</code>, which has the <code class="email">argv</code> property. This property is an array of arguments passed from the terminal. The <code class="email">optimist</code> module simplifies the parsing and provides an effective API to access these arguments.</p><p class="calibre7">Let's add the following code immediately after the definition of the <code class="email">rl</code> variable:</p><div class="informalexample"><pre class="programlisting">module.exports = function(callback) {
  if(argv.s) {
    readDirectory(currentDirectory + argv.s, callback);
  } else {
    getPath(function(path) {
      readDirectory(path, callback);
    });
  }
};</pre></div><p class="calibre7">When navigating to the project's directory to run our Node.js program, type <code class="email">node ./index.js</code>. This will run the script without arguments and will ask the user for the folder that contains the pictures. However, we can also pass this information at an early stage directly from the terminal by running <code class="email">node ./index.js -s images</code>. In the previous code snippet, <code class="email">argv.s</code> will be equal to <code class="email">images</code>. So, we should check whether such a parameter is passed, and if yes, we continue with searching the image files. If not, ask the user via the <code class="email">readline</code> module, the <code class="email">getPath</code> function, as in the following code:</p><div class="informalexample"><pre class="programlisting">var getPath = function(callback) {
  rl.question('Please type a path to directory: ', function(answer) {
    callback(currentDirectory + answer);
  });
}</pre></div><p class="calibre7">The <a id="id253" class="calibre1"/>callback of the<a id="id254" class="calibre1"/> question method returns the text typed by the user. All we have to do is pass it to the <code class="email">readDirectory</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">var readDirectory = function(path, callback) {
  if(fs.existsSync(path)) {
    glob(path + "/**/*.+(jpg|jpeg|gif|png)", function(err, files){
      if(err) {
          throw new Error('Can\'t read the directory.');
      }
      console.log("Found images:");
      files.forEach(function(file) {
        console.log(file.replace(/\//g, '\\').replace(process.cwd(), ''));
      });
      rl.question('Are you sure (y/n)? ', function(answer) {
        if(answer == 'y') {
          callback(files);
        }
        rl.close();
      });
    });    
  } else {
    getPath(function(path) {
      readDirectory(path, callback);
      });
  }
}</pre></div><p class="calibre7">Of course, we should check whether the path is valid. For this, we will use the<code class="email"> fs.existsSync</code> method. If the directory exists, we get the files that match the following pattern:</p><div class="informalexample"><pre class="programlisting">/**/*.+(jpg|jpeg|gif|png)</pre></div><p class="calibre7">This means parse the directory and all its subdirectories and search for the files ending with <code class="email">jpg</code>, <code class="email">jpeg</code>, <code class="email">gif</code>, or <code class="email">png</code>. The <code class="email">glob</code> module helps a lot in such cases.</p><p class="calibre7">Before <a id="id255" class="calibre1"/>sending the files back to <code class="email">index.js</code>, we display them and ask the user for a<a id="id256" class="calibre1"/> confirmation. This is again done with the <code class="email">readline</code> module included at the beginning. It is important to use <code class="email">rl.close()</code>. This method relinquishes the control over the input and output streams.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Authorizing the Flickr protocol"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec43" class="calibre1"/>Authorizing the Flickr protocol</h1></div></div></div><p class="calibre7">We will use the <code class="email">flapi</code> module to <a id="id257" class="calibre1"/>communicate with Flickr. It provides access to the API methods. Most large-scale companies implement some level of authorization. In other words, we can't just make a request and upload/retrieve data. We need to sign in our requests with access tokens or provide credentials during the process. Flickr uses <span class="strong"><strong class="calibre8">OAuth</strong></span><a id="id258" class="calibre1"/> (1.0 specification), a type of standard for such operations. OAuth is an open standard for authorization and defines a method for clients to access server resources. Let's check the following diagram and see how Flickr's OAuth mechanism works:</p><div class="mediaobject"><img src="../images/00012.jpeg" alt="Authorizing the Flickr protocol" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Almost the entire process is wrapped in the <code class="email">flapi</code> module. What we should remember here is that we need a <span class="strong"><strong class="calibre8">Key</strong></span><a id="id259" class="calibre1"/> and <span class="strong"><strong class="calibre8">Secret</strong></span><a id="id260" class="calibre1"/> to retrieve an access token. The same token will be used later when uploading the images.</p></div>

<div class="book" title="Authorizing the Flickr protocol">
<div class="book" title="Obtaining your application's Key and Secret"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch06lvl2sec38" class="calibre1"/>Obtaining your application's Key and Secret</h2></div></div></div><p class="calibre7">To create our own <a id="id261" class="calibre1"/>application's <span class="strong"><em class="calibre9">Key</em></span> and <span class="strong"><em class="calibre9">Secret</em></span>, we must have a valid <a id="id262" class="calibre1"/>Flickr <a id="id263" class="calibre1"/>account <a id="id264" class="calibre1"/>first. Next, log in and navigate to <a class="calibre1" href="http://www.flickr.com/services/apps/create/apply/">http://www.flickr.com/services/apps/create/apply/</a>. On this page, click on <span class="strong"><strong class="calibre8">APPLY FOR A NON-COMMERCIAL KEY</strong></span>, which is the blue button.</p><div class="mediaobject"><img src="../images/00013.jpeg" alt="Obtaining your application's Key and Secret" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We are building a non-commercial application; however, if you plan to use the key for commercial purposes, go with the second option on the right. After that, you will see a form with few fields. Fill them and click on the <span class="strong"><strong class="calibre8">SUBMIT </strong></span>button, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Obtaining your application's Key and Secret" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The next<a id="id265" class="calibre1"/> screen, <a id="id266" class="calibre1"/>which will be<a id="id267" class="calibre1"/> shown, contains our <span class="strong"><strong class="calibre8">Key</strong></span> and <span class="strong"><strong class="calibre8">Secret</strong></span>. It should look like the<a id="id268" class="calibre1"/> following screenshot:</p><div class="mediaobject"><img src="../images/00015.jpeg" alt="Obtaining your application's Key and Secret" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Authorizing the Flickr protocol">
<div class="book" title="Writing into the Flickr.js module"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch06lvl2sec39" class="calibre1"/>Writing into the Flickr.js module</h2></div></div></div><p class="calibre7">Once we get the <span class="strong"><strong class="calibre8">Key</strong></span> and <span class="strong"><strong class="calibre8">Secret</strong></span> values, we can <a id="id269" class="calibre1"/>continue and start writing our <code class="email">lib/Flickr.js</code> module. Here is the initial code of the file:</p><div class="informalexample"><pre class="programlisting">var open = require('open');
var http = require('http');
var url = require('url');
var Flapi = require('flapi');

var flapiClient;
var filesToOpen;
var done;
var options;

module.exports = function(opts, files, callback) {
  options = opts;
  filesToOpen = files;
  done = callback;
  createFlapiClient();
}</pre></div><p class="calibre7">The required dependencies are at the beginning of the previous code. We mentioned the <code class="email">open</code> module; here, <code class="email">http</code> is used to run a Node.js HTTP server and <code class="email">url</code> is used to parse parameters from an incoming request. The module exports a function that accepts three arguments. The first one contains the Flickr's API settings such as <span class="strong"><strong class="calibre8">Key</strong></span> and <span class="strong"><strong class="calibre8">Secret</strong></span>. The second argument is an array of the files that need to be uploaded. At the end, we accept a <code class="email">callback</code> function, which will be called once the uploading is complete. We save everything in a few global variables and call <code class="email">createFlapiClient</code>, which will initialize the <code class="email">flapi</code> object. Before we see what exactly happens in <code class="email">createFlapiClient</code>, let's edit <code class="email">index.js</code> and pass the needed options, as follows:</p><div class="informalexample"><pre class="programlisting">var flickr = require('./lib/Flickr');
var files = require('./lib/Files');
var flickrOptions = {
  oauth_consumer_key: "ebce9c7a68eb009f8db5bcc41d139320",
  oauth_consumer_secret: "a9277a76c947c0b3",
    // oauth_token: '',
    // oauth_token_secret: '',
  perms: 'write'
};</pre></div><p class="calibre7">We left <code class="email">flickrOptions</code> empty, but now is the time to fill it. Set <span class="strong"><strong class="calibre8">Key</strong></span> as the value of <code class="email">oauth_consumer_key</code> and <span class="strong"><strong class="calibre8">Secret</strong></span> as the value of <code class="email">oauth_consumer_secret</code>. The tokens <code class="email">oauth_token</code> and <code class="email">oauth_token_secret</code> are commented by default, but once we perform the initial authorizing, we will set their values. At the end, there is also a permissions property, which should be set to <code class="email">write</code> because we will upload the photos.</p><p class="calibre7">When the right options are configured in <code class="email">Flickr.js</code>, we can create our <code class="email">flapi</code> client and start querying Flickr's servers, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var createFlapiClient = function(){
  flapiClient = new Flapi(options);
  if(!options.oauth_token) {
    flapiClient.authApp('http://127.0.0.1:3000', function(oauthResults){
      runServer(function() {
        open(flapiClient.getUserAuthURL());
      })
    });
  } else {
      uploadPhotos();
  }
};</pre></div><p class="calibre7">We pass the settings, currently <code class="email">oauth_consumer_key</code>, <code class="email">oauth_consumer_secret</code>, and <code class="email">perms</code>. Note that <code class="email">oauth_token</code> is <code class="email">undefined</code> and we need to authorize our application. This happens in the<a id="id270" class="calibre1"/> browser. The mechanism defined by Flickr requires the opening of a specific URL and the passing of a callback address, where the user will be redirected to after being granted the permissions. We are developing a command-line tool, so we can't really provide that address because our script is in the terminal. Therefore, we run our own HTTP server, which will accept requests from Flickr. Of course, this server will be available only on our machine and during the script execution. But that should be enough because we need it only during the first time. If everything goes well, we will get the <code class="email">oauth_token</code> and <code class="email">oauth_token_secret</code> values, as shown in the following code. We will set them in <code class="email">flickrOptions</code> and the HTTP server will not be run next time. When the server is started, we open a new page in the user's default browser, passing the correct URL returned by <code class="email">flapiClient.getUserAuthURL</code>.</p><p class="calibre7">The code underlying <code class="email">runServer</code> is as follows:</p><div class="informalexample"><pre class="programlisting">var runServer = function(callback) {
    http.createServer(function (req, res) {
    res.writeHead(200, {'Content-Type': 'text/html'});
    var urlParts = url.parse(req.url, true);
    var query = urlParts.query;
    if(query.oauth_token) {
    flapiClient.getUserAccessToken(query.oauth_verifier, function(result) {
        options.oauth_token = result.oauth_token;
        options.oauth_token_secret = result.oauth_token_secret;
        var message = '';
        for(var prop in result) {
          message += prop + ' = ' + result[prop] + '&lt;br /&gt;';
        }
        res.end(message);
        uploadPhotos();
      });
    } else {
      res.end('Missing oauth_token parameter.');
    }
  }).listen(3000, '127.0.0.1');
  console.log('Server running at http://127.0.0.1:3000/');
  callback();
}</pre></div><p class="calibre7">The server listens on port 3000, and it has only one handler. The request we are waiting for contains the <span class="strong"><em class="calibre9">GET</em></span> parameter <code class="email">oauth_verifier</code>. We will get access to it by using the <code class="email">url</code> module and its <code class="email">parse</code> method. It's also important that we send <code class="email">true</code> as the second parameter so <a id="id271" class="calibre1"/>that Node.js parses the query string of the request. By passing <code class="email">oauth_verifier</code> to <code class="email">flapi</code>, the client's <code class="email">getUserAccessToken</code> method, we will get the needed token and secret. There is an <code class="email">uploadPhotos</code> function called at the end, but we will leave its body empty for now. This will be filled in the next section of the chapter. </p></div></div>

<div class="book" title="Authorizing the Flickr protocol">
<div class="book" title="Running our application tool"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch06lvl2sec40" class="calibre1"/>Running our application tool</h2></div></div></div><p class="calibre7">Now, let's run <a id="id272" class="calibre1"/>our tool. Type <code class="email">node ./index.js</code> into your terminal and you will see what is shown in the following screenshot: </p><div class="mediaobject"><img src="../images/00016.jpeg" alt="Running our application tool" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Our test directory is <code class="email">images</code>, so we type this string and click on <span class="strong"><em class="calibre9">Enter</em></span>. The code in <code class="email">Files.js</code> will scan the directory for images and will ask us for a confirmation, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00017.jpeg" alt="Running our application tool" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Type <span class="strong"><strong class="calibre8">y</strong></span> and <a id="id273" class="calibre1"/>press <span class="strong"><em class="calibre9">Enter</em></span>. A message will be displayed that the server is running and a new page will open in our default browser. It will ask us to grant the application permission to perform several actions, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00018.jpeg" alt="Running our application tool" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Click on the blue button with text <span class="strong"><strong class="calibre8">OK, I'LL AUTHORIZE IT</strong></span>. There are two things happening at the moment. The browser sends a request with the <code class="email">oauth_verifier</code> parameter to our Node.js server. We use the value, pass it to the <code class="email">getUserAccessToken</code> method, and fetch the needed <code class="email">oauth_token</code> and <code class="email">oauth_token_secret</code> values. At the same time, the browser gets a response, and we see something similar to the following screenshot:</p><div class="mediaobject"><img src="../images/00019.jpeg" alt="Running our application tool" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We will get the <a id="id274" class="calibre1"/>information from the second and third lines and put it in the <code class="email">flickrOptions</code> object, which is initialized in the <code class="email">index.js</code> file. By doing this, we will avoid the steps performed with the Node.js server next time. The script will be able to upload the photos directly without asking for the token and secret.</p></div></div>
<div class="book" title="Uploading the images"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec44" class="calibre1"/>Uploading the images</h1></div></div></div><p class="calibre7">The last function <a id="id275" class="calibre1"/>that we will write is the <code class="email">uploadPhotos</code> method for the <code class="email">Flickr.js</code> module. It will use the global <code class="email">filesToOpen</code> array and upload the files one by one. Since the operation is asynchronous, we will continuously execute the function till the array is empty. We can see the code for this as follows:</p><div class="informalexample"><pre class="programlisting">var uploadPhotos = function() {
  if(filesToOpen.length === 0) {
    done();
  } else {
    var file = filesToOpen.shift();
    console.log("Uploading " + file.replace(/\//g, '\\').replace(process.cwd(), ''));
    flapiClient.api({
      method: 'upload',
      params:  { photo : file },
      accessToken : { 
        oauth_token: options.oauth_token,
        oauth_token_secret: options.oauth_token_secret
      },
      next: function(data){
          uploadPhotos();
      }
  });
  }
}</pre></div><p class="calibre7">The <code class="email">done</code> callback returns the application flow to <code class="email">index.js</code>, where the script is terminated. The result of the entire process will look like the following screenshot:</p><div class="mediaobject"><img src="../images/00020.jpeg" alt="Uploading the images" class="calibre10"/></div><p class="calibre11"> </p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch06lvl1sec45" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we learned how to use Node.js as a command-line tool. We successfully got arguments from the terminal, searched directories for image files, and uploaded them to Flickr. Most of the raw operations such as access to the filesystem or the Flickr OAuth implementation were delegated to different modules, which we added as dependencies to the project. More and more instruments are emerging everyday which transform Node.js into an attractive environment to develop not only web-based applications, but also command-line scripts.</p><p class="calibre7">In the next chapter, we will learn how to use Node.js and Ember.js together. We will get a Twitter social feed and display it on the browser.</p></div></body></html>