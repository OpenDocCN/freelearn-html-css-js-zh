- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Basic Components that Make up a Three.js Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构成Three.js应用程序的基本组件
- en: In the previous chapter, you learned about the basics of Three.js. We looked
    at a couple of examples, and you created your first complete Three.js application.
    In this chapter, we’ll dive a bit deeper into Three.js and explain the basic components
    that make up a Three.js application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了Three.js的基础知识。我们查看了一些示例，并创建了您的第一个完整的Three.js应用程序。在本章中，我们将更深入地探讨Three.js，并解释构成Three.js应用程序的基本组件。
- en: By the end of this chapter, you’ll have learned how to use the basic components
    that are used in every Three.js application and should be able to create simple
    scenes using these standard components. You should also feel comfortable working
    with Three.js applications that use the more advanced objects, since the approach
    used by Three.js for simple and advanced components is the same.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将学会如何使用每个Three.js应用程序中使用的标准组件，并应该能够使用这些标准组件创建简单的场景。您还应该能够舒适地使用使用更高级对象的Three.js应用程序，因为Three.js对简单和高级组件使用的方法是相同的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating a scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建场景
- en: How geometries and meshes are related
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何形状和网格之间的关系
- en: Using different cameras for different scenes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同摄像机渲染不同场景
- en: We’ll start by looking at how you can create a scene and add objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将探讨如何创建场景并添加对象。
- en: Creating a scene
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建场景
- en: 'In [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D
    Scene with Three.js*, you created a `THREE.Scene`, so you already know some of
    the basics of Three.js. We saw that for a scene to show anything, we need four
    different types of objects:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第1章*](B18726_01.xhtml#_idTextAnchor014)，“使用Three.js创建您的第一个3D场景”，您创建了`THREE.Scene`，因此您已经了解了一些Three.js的基本知识。我们了解到，为了让场景显示任何内容，我们需要四种不同类型的对象：
- en: '`THREE.Scene` is rendered onscreen.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`THREE.Scene`在屏幕上渲染。'
- en: '**Lights**: These have an effect on how materials are shown and are used when
    creating shadow effects (discussed in detail in [*Chapter 3*](B18726_03.xhtml#_idTextAnchor040),
    *Working with Light Sources* *in Three.js*).'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灯光**：这些对材料的外观有影响，并在创建阴影效果时使用（在[*第3章*](B18726_03.xhtml#_idTextAnchor040)，“在Three.js中处理光源”中详细讨论）。'
- en: '**Meshes**: These are the main objects that are rendered from the perspective
    of the camera. These objects contain the vertices and faces that make up the geometry
    (for example, a sphere or a cube) and contain a material, which defines what the
    geometry looks like.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格**：这些是从摄像机视角渲染的主要对象。这些对象包含构成几何形状（例如，球体或立方体）的顶点和面，并包含一个材料，该材料定义了几何形状的外观。'
- en: '**Renderer**: This uses the camera and the information in the scene to draw
    (render) the output on the screen.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染器**：它使用摄像机和场景中的信息在屏幕上绘制（渲染）输出。'
- en: '`THREE.Scene` serves as the main container for the lights and the meshes you
    want to render. `THREE.Scene` itself doesn’t have that many options and functions.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Scene`是您想要渲染的灯光和网格的主要容器。`THREE.Scene`本身并没有太多选项和功能。'
- en: '`THREE.Scene` is a structure that is sometimes also called a scene graph. A
    scene graph can hold all the necessary information of a graphical scene. In Three.js,
    this means that a `THREE.Scene` contains all the objects necessary for rendering.
    It is interesting to note that a scene graph, as the name implies, isn’t just
    an array of objects; a scene graph consists of a set of nodes in a tree structure.
    As we’ll see in [*Chapter 8*](B18726_08.xhtml#_idTextAnchor132), *Creating and
    Loading Advanced Meshes and Geometries*, Three.js provides objects you can use
    to create groups of different meshes or lights. The main object you use for that,
    which you can use to create a scene graph, is the `THREE.Group`. As the name implies,
    this object allows you to group objects together. A `THREE.Group` extends from
    another base class in Three.js called `THREE.Object3D`, which provides a set of
    standard functions to add and modify children. `THREE.Mesh` and `THREE.Scene`
    both also extend from a `THREE.Object3D` so you could also use those to create
    a nested structure. But it’s convention, and also more semantically correct, to
    use `THREE.Group` to build up the scene graph.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Scene` 是一种结构，有时也被称为场景图。场景图可以包含图形场景所需的所有必要信息。在 Three.js 中，这意味着一个 `THREE.Scene`
    包含了所有必要的渲染对象。值得注意的是，场景图，正如其名称所暗示的，不仅仅是一个对象的数组；场景图由树结构中的一组节点组成。正如我们将在 [*第 8 章*](B18726_08.xhtml#_idTextAnchor132)
    中看到，*创建和加载高级网格和几何体*，Three.js 提供了你可以用来创建不同网格或灯光组的对象。你主要使用的对象，你可以用它来创建场景图，是 `THREE.Group`。正如其名称所暗示的，这个对象允许你将对象分组在一起。`THREE.Mesh`
    和 `THREE.Scene` 也都扩展自 Three.js 中的另一个基类 `THREE.Object3D`，它提供了一套标准函数来添加和修改子对象。`THREE.Mesh`
    和 `THREE.Scene` 都也扩展自 `THREE.Object3D`，因此你也可以使用它们来创建嵌套结构。但按照惯例，并且从语义上讲更正确，使用 `THREE.Group`
    来构建场景图。'
- en: The basic functionality of a scene
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景的基本功能
- en: 'The best way to explore the functionality of a scene is by looking at an example.
    In the source code for this chapter, you can find the `chapter-2/basic-scene.html`
    example. We’ll use this example to explain the various functions and options a
    scene has. When we open this example in the browser, the output will look similar
    to what’s shown in the next screenshot (remember that you can use the mouse to
    move, zoom, and pan around the rendered scene):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 探索场景功能最好的方式是查看一个例子。在本章的源代码中，你可以找到 `chapter-2/basic-scene.html` 示例。我们将使用这个例子来解释场景具有的各种功能和选项。当我们在这个例子中打开浏览器时，输出将类似于下一张截图所示（请记住，你可以使用鼠标移动、缩放和绕渲染场景平移）：
- en: '![Figure 2.1 – Basic scene setup](img/Figure_2.1_B18726.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – 基本场景设置](img/Figure_2.1_B18726.jpg)'
- en: Figure 2.1 – Basic scene setup
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – 基本场景设置
- en: 'The preceding figure looks like the examples we saw in [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014),
    *Creating Your First 3D Scene with Three.js*. Even though the scene looks pretty
    empty, it already contains a few objects:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图看起来像我们在 [*第 1 章*](B18726_01.xhtml#_idTextAnchor014) 中看到的例子，*使用 Three.js
    创建您的第一个 3D 场景*。尽管场景看起来相当空旷，但它已经包含了一些对象：
- en: We’ve got `THREE.Mesh`, which represents the floor area you can see
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有 `THREE.Mesh`，它代表你可以看到的地面区域
- en: We’re using `THREE.PerspectiveCamera` to determine what we’re looking at
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `THREE.PerspectiveCamera` 来确定我们正在看什么
- en: We’ve added `THREE.AmbientLight` and `THREE.DirectionalLight` to provide lighting
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们添加了 `THREE.AmbientLight` 和 `THREE.DirectionalLight` 来提供照明
- en: 'The source code for this example can be found in `basic-scene.js`, and we can
    use code from `bootstrap/bootstrap.js`, `bootstrap/floor.js`, and `bootstrap/lighting.js`
    since this is a generic scene setup we use throughout this book. What happens
    in all these files can be simplified as in the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的源代码可以在 `basic-scene.js` 中找到，并且我们可以使用来自 `bootstrap/bootstrap.js`、`bootstrap/floor.js`
    和 `bootstrap/lighting.js` 的代码，因为这是一个我们在整本书中使用的通用场景设置。所有这些文件中发生的事情可以简化如下代码：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the preceding code, we create `THREE.WebGLRenderer` and `THREE.PerspectiveCamera`,
    since we always need those. Next, we create a `THREE.Scene` and just add all the
    objects that we want to use. In this case, we add two lights and a single mesh.
    Now, we have all the components to start up a render loop, as we’ve already seen
    in [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D Scene*
    *with Three.js*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们创建了 `THREE.WebGLRenderer` 和 `THREE.PerspectiveCamera`，因为我们始终需要这些。接下来，我们创建了一个
    `THREE.Scene` 并添加了我们想要使用的所有对象。在这种情况下，我们添加了两个灯光和一个网格。现在，我们已经拥有了启动渲染循环的所有组件，正如我们在
    [*第 1 章*](B18726_01.xhtml#_idTextAnchor014) 中看到的，*使用 Three.js 创建您的第一个 3D 场景*。
- en: 'Before we look at the `THREE.Scene` object in more depth, we’ll first explain
    what you can do in the demo, and after that, look at the code. Open the `chapter-2/basic-scene.html`
    example in your browser and look at the **Controls** menu in the upper-right corner,
    which you can see in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更深入地查看`THREE.Scene`对象之前，我们首先解释一下在演示中你可以做什么，然后看看代码。在浏览器中打开`chapter-2/basic-scene.html`示例，查看右上角的**Controls**菜单，如下截图所示：
- en: '![Figure 2.2 – Basic scene setup with Cubemap background](img/Figure_2.2_B18726.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 基本场景设置，使用Cubemap背景](img/Figure_2.2_B18726.jpg)'
- en: Figure 2.2 – Basic scene setup with Cubemap background
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 基本场景设置，使用Cubemap背景
- en: Adding and removing objects
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和移除对象
- en: 'With these `THREE.Scene`. We’ll start by looking at how you can add and remove
    `THREE.Mesh` objects to and from a scene. The following code shows the function
    we call when you click on the **addCube** button:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些`THREE.Scene`。我们将首先看看你如何向场景中添加和移除`THREE.Mesh`对象。以下代码显示了当你点击**addCube**按钮时调用的函数：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let us understand the preceding code in detail:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细理解前面的代码：
- en: 'First, we have determined some random settings for the cube that will be added:
    a random color (by calling the `randomColor()` helper function), a random position,
    and a random rotation. These last two are randomly generated by calling `randomVector()`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们为即将添加的立方体确定了一些随机设置：一个随机颜色（通过调用`randomColor()`辅助函数）、一个随机位置和一个随机旋转。后两个是通过调用`randomVector()`随机生成的。
- en: 'Next, we create the geometry we want to add to the scene: a cube. We just create
    a new `THREE.BoxGeometry` for this, define a material (`THREE.MeshStandardMaterial`
    in this example), and combine these two into `THREE.Mesh`. We use random variables
    to set the cube’s position and rotation.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们想要添加到场景中的几何体：一个立方体。我们只需为这个立方体创建一个新的`THREE.BoxGeometry`，定义一个材质（在这个例子中是`THREE.MeshStandardMaterial`），然后将这两个结合起来形成`THREE.Mesh`。我们使用随机变量来设置立方体的位置和旋转。
- en: Finally, this `THREE.Mesh` can then be added to the scene by calling `scene.add(cube)`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，通过调用`scene.add(cube)`，这个`THREE.Mesh`可以被添加到场景中。
- en: A new element that we have introduced in the preceding code is that we also
    give the cube a name using the `name` attribute. The name is set to `cube-`, appended
    with the number of objects currently in the scene (`scene.children.length`). A
    name is very useful for debugging purposes but can also be used to directly access
    an object from your scene. If you use the `THREE.Scene.getObjectByName(name)`
    function, you can directly retrieve a specific object and, for instance, change
    its location without having to make the JavaScript object a global variable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们引入了一个新元素，那就是我们使用`name`属性也给立方体起了一个名字。名称设置为`cube-`，后面加上场景中当前对象的数量（`scene.children.length`）。名称对于调试非常有用，也可以用来直接从你的场景中访问对象。如果你使用`THREE.Scene.getObjectByName(name)`函数，你可以直接检索一个特定的对象，例如，改变它的位置，而不必将JavaScript对象设置为全局变量。
- en: 'There might also be situations where you want to remove an existing object
    from a `THREE.Scene`. Since a `THREE.Scene` exposes all its children through the
    `children` property, we can just use the following simple code to remove the last
    child added:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能存在这样的情况，你想要从一个`THREE.Scene`中移除一个现有的对象。由于`THREE.Scene`通过`children`属性公开了其所有子对象，我们可以使用以下简单的代码来移除最后添加的子对象：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Three.js provides other helpful functions for the `THREE.Scene` too, related
    to working with the children of the scene:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js还为`THREE.Scene`提供了其他有用的函数，这些函数与处理场景的子对象相关：
- en: '`add`: We’ve already seen this function, which adds the provided object to
    the scene. If it was previously added to a different `THREE.Object3D`, it’ll be
    removed from that object.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`：我们已经看到了这个函数，它将提供的对象添加到场景中。如果它之前被添加到不同的`THREE.Object3D`中，它将从那个对象中移除。'
- en: '`Attach`: This is similar to `add`, but if you use it, any rotations or translations
    applied to this object will be kept.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Attach`：这与`add`类似，但如果你使用它，应用到此对象的任何旋转或平移都将被保留。'
- en: '`getObjectById`: When you add an object to a scene, it gets an ID. The first
    one gets `1`, the second one `2`, and so on. With this function, you can get a
    child based on this ID.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getObjectById`：当你将对象添加到场景中时，它会获得一个ID。第一个获得`1`，第二个获得`2`，依此类推。使用这个函数，你可以根据这个ID获取一个子对象。'
- en: '`getObjectByName`: This returns an object based on its `name` property. The
    name is something you can set on an object – this is in contrast with the `id`
    property, which is assigned by Three.js.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getObjectByName`：这个函数根据对象的`name`属性返回一个对象。你可以为对象设置一个名称——这与由Three.js分配的`id`属性形成对比。'
- en: '`Remove`: This removes this object from the scene.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Remove`：这将从这个场景中移除此对象。'
- en: '`Clear`: This removes all the children from the scene.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Clear`：这将从场景中移除所有子对象。'
- en: 'Note that the preceding functions are actually from the base object that the
    `THREE.Scene` extends from: the `THREE.Object3D`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的函数实际上是从 `THREE.Scene` 扩展的基对象：`THREE.Object3D`。
- en: Throughout the book, we’ll use these functions if we want to manipulate the
    children of a scene (or in `THREE.Group`, as we’ll explore later on.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，如果我们想要操作场景的子对象（或者在 `THREE.Group` 中，我们将在后面探讨），我们会使用这些函数。
- en: Besides the functionality to add and remove objects, a `THREE.Scene` also provides
    a couple of other settings. The first one we’ll look at is adding fog.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加和删除对象的功能外，`THREE.Scene` 还提供了一些其他设置。我们将首先查看的是添加雾效。
- en: Adding fog
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加雾效
- en: 'The `fog` property lets you add a fog effect to the complete scene; the farther
    an object is from the camera, the more it will be hidden from sight. This is shown
    in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`fog` 属性允许您为整个场景添加雾效；物体离相机越远，就越会被隐藏在视线之外。这可以在下面的屏幕截图中看到：'
- en: '![Figure 2.3 – Using fog to hide objects](img/Figure_2.3_B18726.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 使用雾隐藏对象](img/Figure_2.3_B18726.jpg)'
- en: Figure 2.3 – Using fog to hide objects
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 使用雾隐藏对象
- en: 'To best see the effect of the added fog, use the mouse to zoom in and out,
    and you’ll see the cubes being affected by the fog. Enabling fog is really easy
    in Three.js. Just add the following line of code after you’ve defined your scene:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要最好地看到添加的雾效，请使用鼠标进行缩放，您将看到立方体受到雾效的影响。在 Three.js 中启用雾效非常简单。只需在定义了您的场景之后添加以下代码行：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we define white fog (`0xffffff`). The other two properties can be used
    to tune how the mist appears. The `1` value sets the `near` property, and the
    `20` value sets the `far` property. With these properties, you can determine where
    the mist starts and how fast it gets denser. With the `THREE.Fog` object, the
    fog increases linearly. In the `chapter-02/basic-scene.html` sample, you can modify
    these properties by using the menu on the right of the screen to see how these
    settings affect what you see onscreen.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了白色雾 (`0xffffff`)。其他两个属性可以用来调整雾的出现方式。`1` 值设置了 `near` 属性，而 `20` 值设置了
    `far` 属性。有了这些属性，您可以确定雾开始的位置以及它变得多密集。使用 `THREE.Fog` 对象，雾是线性增加的。在 `chapter-02/basic-scene.html`
    示例中，您可以通过使用屏幕右侧的菜单来修改这些属性，以查看这些设置如何影响您在屏幕上看到的内容。
- en: 'There is also an alternative fog implementation provided by Three.js, `THREE.FogExp2`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js 还提供了一个替代的雾实现，`THREE.FogExp2`：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This time, we don’t specify near and far, but just the color (`0xffffff`) and
    the mist’s density (`0.01`). Usually, it’s best to experiment a bit with these
    properties to get the effect you want.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们没有指定近点和远点，只是颜色 (`0xffffff`) 和雾的密度 (`0.01`)。通常，最好对这些属性进行一些实验，以获得您想要的效果。
- en: Another interesting feature of a scene is that you can configure a background.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 场景的另一个有趣特性是您可以配置背景。
- en: Changing the background
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变背景
- en: 'We’ve already seen that we can change the background color by setting `clearColor`
    of `WebGLRenderer` like this: `renderer.setClearColor(backgroundColor)`. You can
    also use the `THREE.Scene` object to change the background. For this, you’ve got
    three options:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，我们可以通过设置 `WebGLRenderer` 的 `clearColor` 来改变背景颜色，如下所示：`renderer.setClearColor(backgroundColor)`。您也可以使用
    `THREE.Scene` 对象来改变背景。为此，您有三个选项：
- en: '*Option 1*: You can use a solid color.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选项 1*：您可以使用纯色。'
- en: '*Option 2*: You can use a texture, which is basically an image, stretched out
    to fill the complete screen. (More on textures in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    *Loading and Working* *with Textures*.)'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选项 2*：您可以使用一个纹理，这基本上是一个图像，被拉伸以填充整个屏幕。（关于纹理的更多信息，请参阅 [*第 10 章*](B18726_10.xhtml#_idTextAnchor171)，*加载和操作纹理*。）'
- en: '*Option 3*: You can use an environment map. This is also a kind of texture,
    but one that completely encompasses the camera, and moves around when you change
    the camera orientation.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选项 3*：您可以使用环境贴图。这也是一种纹理，但它完全包围了相机，并在您改变相机方向时移动。'
- en: 'Note that this sets the background color of the HTML canvas we’re rendering
    to and not the background color of the HTML page. If you want to have a transparent
    canvas, you need to set the `alpha` property of the renderer to `true`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这设置了我们要渲染的 HTML 画布的背景颜色，而不是 HTML 页面的背景颜色。如果您想要一个透明的画布，需要将渲染器的 `alpha` 属性设置为
    `true`：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `chapter-02/basic-scene.html` menu on the right, there is a dropdown
    that shows all these different settings. If you select the **Texture** option
    from the **backGround** dropdown, you’ll see the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的`chapter-02/basic-scene.html`菜单中，有一个下拉菜单显示了所有这些不同的设置。如果你从**backGround**下拉菜单中选择**Texture**选项，你会看到以下内容：
- en: '![Figure 2.4 – Background using a texture](img/Figure_2.4_B18726.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – 使用纹理作为背景](img/Figure_2.4_B18726.jpg)'
- en: Figure 2.4 – Background using a texture
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 使用纹理作为背景
- en: 'We’ll cover textures and cubemaps in much more detail in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    *Loading and Working with Textures*. But we’ll have a quick look now at how to
    configure these and a simple background color for the scene (the source for this
    can be found in `controls/scene-controls.js`):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第10章*](B18726_10.xhtml#_idTextAnchor171)，*加载和使用纹理*中更详细地介绍纹理和立方体贴图。但现在，我们将快速查看如何配置这些以及场景的简单背景颜色（此代码的来源可以在`controls/scene-controls.js`中找到）：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see from the preceding code, you can assign either `null`, `THREE.Color`,
    or `THREE.Texture` to the `background` property of the scene. Loading a texture
    or a cubemap is done asynchronously, so, we have to wait for `THREE.TextureLoader`
    to load the image data before we can assign it to the background. In the case
    of the cubemap, we need to take an extra step and tell Three.js what kind of texture
    we’ve loaded. We will go into more detail in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171),
    *Loading and Working with Textures*, when we dive into the details of how textures
    work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，你可以将`null`、`THREE.Color`或`THREE.Texture`分配给场景的`background`属性。加载纹理或立方体贴图是异步进行的，因此，我们必须等待`THREE.TextureLoader`加载图像数据后，才能将其分配给背景。在立方体贴图的情况下，我们需要额外一步，并告诉Three.js我们加载了什么类型的纹理。当我们将深入探讨纹理的工作原理时，我们将在[*第10章*](B18726_10.xhtml#_idTextAnchor171)，*加载和使用纹理*中详细介绍。
- en: 'If you look back at the beginning of the following code section, you will see
    how we created the cubes that we added to the scene:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下下面代码段的开头，你会看到我们是如何创建添加到场景中的立方体的：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we have created a geometry and specified a material.
    The `THREE.Scene` object also provides a way to force the meshes in the scene
    to use the same material. In the following section, we’ll explore how that works.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个几何体并指定了一个材质。`THREE.Scene`对象还提供了一种强制场景中网格使用相同材质的方法。在下一节中，我们将探讨这是如何工作的。
- en: Updating all the materials in the scene
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新场景中所有材料
- en: 'A `THREE.Scene` has two properties that affect the material of the meshes in
    the scene. The first one is the `overrideMaterial` property. First, let’s demonstrate
    how this works. On the `chapter-02/basic-scene.html` page, you can click on the
    `THREE.MeshNormalNormal` material:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.Scene`有两个属性会影响场景中网格的材质。第一个是`overrideMaterial`属性。首先，让我们演示一下它是如何工作的。在`chapter-02/basic-scene.html`页面上，你可以点击`THREE.MeshNormalNormal`材质：'
- en: '![Figure 2.5 – Override mesh materials with MeshNormalMaterial](img/Figure_2.5_B18726.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – 使用MeshNormalMaterial覆盖网格材料](img/Figure_2.5_B18726.jpg)'
- en: Figure 2.5 – Override mesh materials with MeshNormalMaterial
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – 使用MeshNormalMaterial覆盖网格材料
- en: As you can see in the preceding figure, all the objects (including the ground
    floor) now use the same material – in this case, `THREE.MeshNormalMaterial`. This
    material colors each face of the mesh based on its orientation (its *normal* vector)
    to the camera. This can be very easily done in code by just calling `scene.overrideMaterial
    =` `new THREE.MeshNormalMaterial();`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，现在所有对象（包括地面）现在都使用相同的材质 – 在这种情况下，`THREE.MeshNormalMaterial`。这种材质根据网格相对于相机的方向（其*法线*向量）为网格的每个面着色。这可以通过在代码中简单地调用`scene.overrideMaterial
    = new THREE.MeshNormalMaterial();`来实现。
- en: Besides applying a complete material to the scene, Three.js also provides a
    way to set the environment map property of each mesh’s material to the same value.
    An environment map simulates the environment (for instance, a room, outdoors,
    or a cave) the meshes are in. The environment map can be used to create reflections
    on the meshes to make them feel more real.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将完整的材质应用到场景中，Three.js还提供了一种方法来设置每个网格材质的环境贴图属性为相同的值。环境贴图模拟网格所在的环境（例如，一个房间、户外或洞穴）。环境贴图可用于在网格上创建反射，使其看起来更真实。
- en: 'We’ve already seen how we can load an environment map in the previous section
    on backgrounds. If we want all our materials to use an environment map for more
    dynamic reflections and shading, we can assign that loaded environment map to
    the `environment` property of a scene:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节关于背景的章节中，我们已经看到了如何加载环境贴图。如果我们想让所有材料都使用环境贴图以获得更动态的反射和阴影，我们可以将加载的环境贴图分配给场景的
    `environment` 属性：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The best way to demonstrate the preceding code is by toggling the `chapter-02/basic-scene.html`
    example. If you now zoom in close to the cubes, you can see that their faces reflect
    part of the environment and aren’t a solid color anymore:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方式是通过切换 `chapter-02/basic-scene.html` 示例来演示前面的代码。如果您现在将镜头拉近到立方体上，您可以看到它们的表面反射了部分环境，并且不再是纯色：
- en: '![Figure 2.6 – Set the environment map to all the meshes in the scene](img/Figure_2.6_B18726.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 将环境贴图设置到场景中的所有网格上](img/Figure_2.6_B18726.jpg)'
- en: Figure 2.6 – Set the environment map to all the meshes in the scene
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 将环境贴图设置到场景中的所有网格上
- en: Now that we’ve discussed the basic container for all the objects we want to
    render, in the next section, we’ll take a closer look at the objects (`THREE.Mesh`
    combining `THREE.Geometry` and a material) that you can add to the scene.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了所有要渲染的对象的基本容器，在下一节中，我们将更详细地探讨可以添加到场景中的对象（`THREE.Mesh` 结合 `THREE.Geometry`
    和材质）。
- en: How geometries and meshes are related
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 几何形状和网格之间的关系
- en: 'In each of the examples so far, you’ve seen geometries and meshes being used.
    For instance, to create a sphere and add it to the scene, we used the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在迄今为止的每个示例中，您都看到了几何形状和网格的使用。例如，为了创建一个球体并将其添加到场景中，我们使用了以下代码：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We defined the geometry (`THREE.SphereGeometry`), which is the shape of an object,
    and its material (`THREE.MeshBasicMaterial`), and we combined these two in a mesh
    (`THREE.Mesh`) that can be added to a scene. In this section, we’ll take a closer
    look at geometries and meshes. We’ll start with geometries.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了几何形状（`THREE.SphereGeometry`），这是物体的形状，以及其材质（`THREE.MeshBasicMaterial`），然后我们将这两个结合在一个网格（`THREE.Mesh`）中，可以将其添加到场景中。在本节中，我们将更详细地探讨几何形状和网格。我们将从几何形状开始。
- en: The properties and functions of a geometry
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 几何形状的属性和函数
- en: 'Three.js comes with a large set of geometries out of the box that you can use
    in your 3D scene. Just add a material, create a mesh, and you’re pretty much done.
    The following screenshot, from the `chapter-2/geometries` example, shows a couple
    of the standard geometries available in Three.js:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js自带一套大量的几何形状，您可以直接在3D场景中使用。只需添加一个材质，创建一个网格，您就基本完成了。以下截图来自 `chapter-2/geometries`
    示例，展示了Three.js中可用的几个标准几何形状：
- en: '![Figure 2.7 – Some of the basic geometries available in the scene](img/Figure_2.7_B18726.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 场景中可用的一些基本几何形状](img/Figure_2.7_B18726.jpg)'
- en: Figure 2.7 – Some of the basic geometries available in the scene
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 场景中可用的一些基本几何形状
- en: In [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), *Learning to Work with Geometries*,
    and [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101), *Exploring Advanced Geometries*,
    we’ll explore all the basic and advanced geometries that Three.js has to offer.
    For now, we’ll look in greater detail at what a geometry actually is.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B18726_05.xhtml#_idTextAnchor081)，*学习与几何形状一起工作*，和 [*第 6 章*](B18726_06.xhtml#_idTextAnchor101)，*探索高级几何形状*
    中，我们将探索Three.js提供的所有基本和高级几何形状。现在，我们将更详细地看看几何形状实际上是什么。
- en: 'A geometry in Three.js, and in most other 3D libraries, is basically a collection
    of points in a 3D space, also called vertices (where a single point is called
    a vertex), and a number of faces connecting those points together. Take, for example,
    a cube:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中，以及在大多数其他3D库中，几何形状基本上是在三维空间中点的集合，也称为顶点（一个单独的点称为顶点），以及连接这些点的多个面。以立方体为例：
- en: A cube has eight corners. Each of these corners can be defined as an `x-, y-,
    and z-` coordinate. So, each cube has eight points in a 3D space.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个立方体有八个角。每个角都可以定义为 `x-`、`y-` 和 `z-` 坐标。因此，每个立方体在三维空间中有八个点。
- en: A cube has six sides, with a vertex at each corner. In Three.js, a face always
    consists of three vertices that make a triangle (which has three edges). So, in
    the case of a cube, each side consists of two triangles to make the complete side.
    An example of how that looks can be seen in *Figure 2**.7* by looking at the red
    cube.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个立方体有六个面，每个角都有一个顶点。在Three.js中，一个面始终由三个顶点组成，这三个顶点形成一个三角形（三角形有三个边）。因此，在立方体的例子中，每个面由两个三角形组成，以形成一个完整的面。这种外观的例子可以在
    *图 2**.7 中看到，通过观察红色的立方体。
- en: 'When you use one of the geometries provided by Three.js, you don’t have to
    define all the vertices and faces yourself. For a cube, you only need to define
    the width, height, and depth. Three.js uses that information and creates a geometry
    with eight vertices in the correct position and with the correct number of faces
    (12 in the case of a cube – 2 triangles per side). Even though you’d normally
    use the geometries provided by Three.js or generate them automatically, you can
    still create geometries completely by hand using vertices and faces, although
    this can quickly become complex, as you can see in the following lines of code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Three.js提供的几何体之一时，你不必自己定义所有的顶点和面。对于一个立方体，你只需要定义宽度、高度和深度。Three.js使用这些信息并创建一个具有八个顶点且位置正确的几何体，并且具有正确的面数（立方体的情况下是12个面——每边两个三角形）。尽管你通常使用Three.js提供的几何体或自动生成它们，但你仍然可以使用顶点和面完全手动创建几何体，尽管这可能会很快变得复杂，如以下代码行所示：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code shows how to create a simple cube. We define the points
    (the vertices) that make up this cube in the `v` array. From these vertices, we
    can create the faces next. In Three.js, we need to provide all the `faces` information
    in one large `Float32Array`. As we mentioned, a face consists of three vertices.
    So, for each face, we need to define nine values: the `x`, `y`, and `z` of each
    vertex. Since we’ve got three vertices per face, we have nine values. To make
    it a little bit easier to read, we use the `...` (spread) operator from JavaScript
    to add the individual values of each vertex to the array. So, `...v[0], ...v[2],
    ...v[1]` will result in the following values in the array: `1, 3, 1, 1, -1, 1,
    1,` `3, 1`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了如何创建一个简单的立方体。我们在`v`数组中定义了组成这个立方体的点（即顶点）。从这些顶点中，我们可以创建下一个面。在Three.js中，我们需要在一个大的`Float32Array`中提供所有的`faces`信息。正如我们提到的，一个面由三个顶点组成。因此，对于每个面，我们需要定义九个值：每个顶点的`x`、`y`和`z`。由于每个面有三个顶点，所以我们有九个值。为了使阅读更简单，我们使用JavaScript中的`...`（展开）操作符将每个顶点的单独值添加到数组中。因此，`...v[0],
    ...v[2], ...v[1]`将在数组中产生以下值：`1, 3, 1, 1, -1, 1, 1,` `3, 1`。
- en: Note that you have to take care of the sequence of the vertices used to define
    the faces. The order in which they are defined determines whether Three.js thinks
    it is a front-facing face (a face facing the camera) or a back-facing face. If
    you create faces, you should use a clockwise sequence for front-facing faces and
    a counter-clockwise sequence if you want to create a back-facing face.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须注意用于定义面的顶点的顺序。它们定义的顺序决定了Three.js认为它是一个正面面（面向摄像机的面）还是一个背面面。如果你创建面，你应该使用顺时针顺序来创建正面面，如果你想创建背面面，则应使用逆时针顺序。
- en: In our example, we have used a number of vertices to define the six sides of
    the cube, with two triangles for each face. In previous versions of Three.js,
    you could also use a quad instead of a triangle. A quad uses four vertices instead
    of three to define the face. Whether using quads or triangles is better is a heated
    debate raging in the 3D modeling world. Basically though, using quads is often
    preferred during modeling since they can be more easily enhanced and smoothed
    than triangles. For rendering and game engines though, working with triangles
    is often easier since every shape can be rendered very efficiently using triangles.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们使用了一些顶点来定义立方体的六个面，每个面有两个三角形。在Three.js的早期版本中，你也可以使用四边形而不是三角形。四边形使用四个顶点而不是三个来定义面。使用四边形或三角形哪个更好，在3D建模世界中是一个热烈的争论。基本上，在建模期间，通常更倾向于使用四边形，因为它们比三角形更容易增强和光滑。然而，对于渲染和游戏引擎来说，处理三角形通常更容易，因为每个形状都可以非常高效地使用三角形进行渲染。
- en: Using these vertices and faces, we can now create a new instance of `THREE.BufferGeometry`
    and assign the vertices to the `position` attribute. The last step is to call
    `computeVertexNormals()` on the geometry we have created. When we call this function,
    Three.js determines the normal vector for each of the vertices and for the faces.
    This is the information Three.js uses to determine how to color the faces based
    on the various lights in the scene (which you can easily visualize if you use
    `THREE.MeshNormalMaterial`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些顶点和面，我们现在可以创建一个新的`THREE.BufferGeometry`实例，并将顶点分配给`position`属性。最后一步是在我们创建的几何体上调用`computeVertexNormals()`。当我们调用这个函数时，Three.js会确定每个顶点和面的法向量。这是Three.js用来根据场景中的各种灯光（如果你使用`THREE.MeshNormalMaterial`，可以很容易地可视化）来确定如何着色面的信息。
- en: 'With this geometry, we can now create a mesh, just like we saw earlier. We’ve
    created an example that you can use to play around with the position of the vertices,
    which also shows the individual faces. In our `chapter-2/custom-geometry` example,
    you can change the position of all the vertices of a cube and see how the faces
    react. This is shown in the following screenshot:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此几何形状，我们现在可以创建一个网格，就像我们之前看到的那样。我们创建了一个示例，你可以用它来调整顶点的位置，这同时也显示了单个面。在我们的`chapter-2/custom-geometry`示例中，你可以改变立方体的所有顶点的位置，并查看面如何反应。这如下面的截图所示：
- en: '![Figure 2.8 – Move vertices around to change the shape](img/Figure_2.8_B18726.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图2.8 – 移动顶点以改变形状](img/Figure_2.8_B18726.jpg)'
- en: Figure 2.8 – Move vertices around to change the shape
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 – 移动顶点以改变形状
- en: 'This example, which uses the same setup as all our other examples, has a render
    loop. Whenever you change one of the properties in the drop-down control box,
    the cube is rendered based on the changed position of one of the vertices. This
    isn’t something that works out of the box. For performance reasons, Three.js assumes
    that the geometry of a mesh won’t change during its lifetime. For most geometries
    and use cases, this is a very valid assumption. If you, however, change the backing
    array (in this case, the `const faces = new Float32Array([...])` array), we need
    to tell Three.js that something has changed. You can do that by setting the `needsUpdate`
    property of the relevant attribute to `true`. This will look something like the
    following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例，与我们的所有其他示例具有相同的设置，有一个渲染循环。每次你更改下拉控制框中的一个属性时，立方体都会根据一个顶点的更改位置进行渲染。这不是一件现成就能做到的事情。出于性能考虑，Three.js假设网格的几何形状在其生命周期内不会改变。对于大多数几何形状和用例，这是一个非常合理的假设。然而，如果你更改了底层数组（在这种情况下，是`const
    faces = new Float32Array([...])`数组），我们需要告诉Three.js有变化。你可以通过将相关属性的`needsUpdate`属性设置为`true`来实现这一点。这看起来可能如下所示：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that in the case of updated vertices, it is also a good idea to recalculate
    the normal vectors, to make sure the materials are also rendered correctly. More
    information on what a normal vector is and why it is important will be explained
    in [*Chapter 10*](B18726_10.xhtml#_idTextAnchor171), *Loading and Working* *with
    Textures*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在更新顶点的情况下，重新计算法向量也是一个好主意，以确保材料也能正确渲染。关于法向量是什么以及为什么它很重要的更多信息将在[*第10章*](B18726_10.xhtml#_idTextAnchor171)，*加载和操作*
    *纹理*中解释。
- en: 'There is one button from the `chapter-2/custom-geometry` menu that we haven’t
    addressed yet. In the menu on the right, there is a `clone()` function, as the
    name implies, we can make a copy of the geometry and, for instance, use it to
    create a different mesh with a different material. In the same example, `chapter-2/custom-geometry`,
    you can see a **clone** button at the top of the control GUI, as in the following
    screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从`chapter-2/custom-geometry`菜单中有一个按钮我们尚未处理。在右侧的菜单中，有一个`clone()`函数，正如其名所示，我们可以复制几何形状，例如，用它来创建具有不同材料的不同网格。在相同的示例`chapter-2/custom-geometry`中，你可以在控制GUI的顶部看到一个**clone**按钮，如下面的截图所示：
- en: '![Figure 2.9 – Make a clone of the geometry](img/Figure_2.9_B18726.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 复制几何形状](img/Figure_2.9_B18726.jpg)'
- en: Figure 2.9 – Make a clone of the geometry
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 复制几何形状
- en: 'If you click on this button, a clone (copy) will be made of the geometry as
    it currently is; then, a new object will be created with a different material,
    and finally, the object will be added to the scene. The code for this is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击此按钮，将根据当前几何形状创建一个副本；然后，将创建一个新的具有不同材料的新对象，最后将该对象添加到场景中。此代码如下：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see in the preceding code, we use the `clone()` function to clone
    `bufferGeometry`. Once cloned, we make sure to update the `x` value of each vertex
    so the clone is put in a different position than the original one (we could also
    have used `translateX`, which we explain in the following section of this chapter).
    Next, we create a `THREE.Mesh`, remove the cloned mesh if it is there, and add
    the new clone. To create the new mesh, we use a custom function called `meshFromGeometry`.
    As a quick sidestep, let’s look at how that is implemented as well:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，我们使用`clone()`函数来复制`bufferGeometry`。一旦复制，我们确保更新每个顶点的`x`值，以便副本位于与原始不同的位置（我们也可以使用`translateX`，我们将在本章下一节中解释）。接下来，我们创建一个`THREE.Mesh`，如果存在则移除复制的网格，并添加新的副本。为了创建新的网格，我们使用一个名为`meshFromGeometry`的自定义函数。作为一个快速旁白，让我们看看它是如何实现的：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you look back at this example, you can see a transparent cube and the lines
    (the edges) that make up our geometry. To do this, we create a multi-material
    mesh. This means that we tell Three.js to use two different materials in a single
    mesh. For this, Three.js provides a nice helper function called `createMultiMaterialObject`,
    which does what the name implies. Based on a geometry and a list of materials,
    it creates an object that we can add to the scene. There is one thing you need
    to know though when working with the results from a `createMultiMaterialObject`
    call. What you get back isn’t a single mesh; it is a `THREE.Group`, a container
    object that, in this case, contains a separate `THREE.Mesh` for each of the materials
    we provide. So, when rendering the mesh, it looks like a single object, but it
    actually comprises multiple `THREE.Mesh` objects rendered on top of one another.
    This also means that if we want to have shadows, we need to enable this for each
    of the meshes inside the group (which is what we did in the preceding code fragment).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下这个例子，你可以看到一个透明的立方体和组成我们几何体的线条（边）。为了做到这一点，我们创建了一个多材质网格。这意味着我们告诉Three.js在单个网格中使用两种不同的材质。为此，Three.js提供了一个名为`createMultiMaterialObject`的便捷辅助函数，它做了名字暗示的事情。根据一个几何体和一组材质列表，它创建了一个我们可以添加到场景中的对象。但是，当你使用`createMultiMaterialObject`的返回结果时，有一件事你需要知道。你得到的不只是一个网格；它是一个`THREE.Group`，一个容器对象，在这个例子中，它包含我们提供的每个材质的单独的`THREE.Mesh`。因此，当渲染网格时，它看起来像一个单一的对象，但实际上是由多个`THREE.Mesh`对象叠加渲染而成的。这也意味着，如果我们想要有阴影，我们需要为组内的每个网格启用阴影（这正是我们在前面的代码片段中所做的）。
- en: 'In the preceding code, we used `createMultiMaterialObject` from the `THREE.SceneUtils`
    object to add a wireframe to the geometry we created. Three.js also provides an
    alternative way of adding a wireframe using `THREE.WireframeGeometry`. Assuming
    you have a geometry called `geom`, you can create a wireframe geometry from that:
    `const wireframe = new THREE.WireframeGeometry(geom);`. Next, you can draw the
    lines of this geometry, using the `Three.LineSegments` object, by first creating
    a `const line = new THREE.LineSegments(wireframe)` object, and then adding it
    to the scene: `scene.add(line)`. Since this helper internally is just a `THREE.Line`
    object, you can style how the wireframe appears. For instance, to set the width
    of the wireframe lines, use `line.material.linewidth =` `2;`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了`THREE.SceneUtils`对象的`createMultiMaterialObject`来为我们创建的几何体添加一个线框。Three.js还提供了一个使用`THREE.WireframeGeometry`添加线框的替代方法。假设你有一个名为`geom`的几何体，你可以从它创建一个线框几何体：`const
    wireframe = new THREE.WireframeGeometry(geom);`。接下来，你可以使用`Three.LineSegments`对象绘制这个几何体的线条，首先创建一个`const
    line = new THREE.LineSegments(wireframe)`对象，然后将其添加到场景中：`scene.add(line)`。由于这个辅助函数内部只是一个`THREE.Line`对象，你可以设置线框的外观。例如，要设置线框线的宽度，使用`line.material.linewidth
    = 2;`。
- en: We’ve already looked a bit at the `THREE.Mesh` object. In the next section,
    we’ll dive a bit deeper into what you can do with it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对`THREE.Mesh`对象进行了一些了解。在下一节中，我们将更深入地探讨你可以用它做什么。
- en: Functions and attributes for meshes
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网格的函数和属性
- en: 'We’ve already learned that to create a mesh, we need a geometry and one or
    more materials. Once we have a mesh, we add it to the scene and it’s rendered.
    There are a couple of properties you can use to change where and how this mesh
    appears on the scene. In our first example, we’ll look at the following set of
    properties and functions:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，要创建一个网格，我们需要一个几何体和一个或多个材质。一旦我们有了网格，我们将其添加到场景中，它就会被渲染。有一些属性可以帮助我们改变网格在场景中的位置和显示方式。在我们的第一个例子中，我们将查看以下属性和函数：
- en: '`position`: This determines the position of the object relative to the position
    of its parent. Most often, the parent of an object is a `THREE.Scene` object or
    a `THREE.Group` object.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`position`：这个属性决定了对象相对于其父对象的位置。通常，对象的父对象是一个`THREE.Scene`对象或一个`THREE.Group`对象。'
- en: '`rotation`: With this property, you can set the rotation of an object around
    any of its own axes. Three.js also provides specific functions for rotations around
    a single axis: `rotateX()`, `rotateY()`, and `rotateZ()`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotation`：使用这个属性，你可以设置对象围绕其自身的任何轴的旋转。Three.js还提供了围绕单个轴旋转的特定函数：`rotateX()`、`rotateY()`和`rotateZ()`。'
- en: '`scale`: This property allows you to scale the object around its `x-`, `y-`,
    and `z-a`xes.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`：这个属性允许你围绕对象的`x-`、`y-`和`z-`轴进行缩放。'
- en: '`translateX()` / `translateY()` and `translateZ()`: This property moves the
    object by a specified amount along the corresponding axis.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateX()` / `translateY()` 和 `translateZ()`：这个属性通过指定量沿着相应的轴移动对象。'
- en: '`lookAt()`: This property points the object to a specific vector in space.
    This is an alternative to setting the rotation manually.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lookAt()`：此属性将对象指向空间中的特定向量。这是手动设置旋转的替代方法。'
- en: '`visible`: This property determines whether this mesh should be rendered or
    not.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`visible`：此属性确定此网格是否应该被渲染。'
- en: '`castShadow`: This property determines whether this mesh casts shadows when
    it is hit by light. By default, meshes don’t cast shadows.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`castShadow`：此属性确定当网格被光线击中时是否投射阴影。默认情况下，网格不投射阴影。'
- en: When we’re rotating an object, we’re rotating around an axis. In a 3D scene,
    there are multiple spaces that have an axis you can rotate around. The `rotateN()`
    functions rotate the object around the axis in *local* space. This means the object
    rotates around the axis of its parent. So, when you add an object to the scene,
    the `rotateN()` functions will rotate that object around the main axis of the
    scene. When it is part of a nested group, these functions will rotate the object
    around the axis of its parent, which is normally the behavior you’re looking for.
    Three.js also has a specific `rotateOnWorldAxis`, which allows you to rotate an
    object around the axis of the main `THREE.Scene` regardless of the actual parent
    of the object. Finally, you can also force the object to rotate around its own
    axis (this is called *object* space) by calling the `rotateOnAxis` function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们旋转一个对象时，我们是在围绕一个轴旋转。在 3D 场景中，有多个空间，你可以围绕其轴旋转。`rotateN()` 函数在 *局部* 空间中旋转对象。这意味着对象围绕其父对象的轴旋转。因此，当您将对象添加到场景中时，`rotateN()`
    函数将围绕场景的主轴旋转该对象。当它是嵌套组的一部分时，这些函数将围绕其父对象的轴旋转对象，这通常是您所期望的行为。Three.js 还有一个特定的 `rotateOnWorldAxis`，它允许您无论对象的实际父对象是什么，都可以围绕主
    `THREE.Scene` 的轴旋转对象。最后，您还可以通过调用 `rotateOnAxis` 函数强制对象围绕其自身的轴（这称为 *对象* 空间）旋转。
- en: 'As always, we have an example ready for you that will allow you to play around
    with these properties. If you open `chapter-2/mesh-properties` in your browser,
    you get a drop-down menu where you can alter all these properties and directly
    see the result, as shown in the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们为您准备了一个示例，让您可以对这些属性进行操作。如果您在浏览器中打开 `chapter-2/mesh-properties`，您会看到一个下拉菜单，您可以在其中更改所有这些属性，并直接看到以下截图所示的结果：
- en: '![Figure 2.10 – Mesh properties](img/Figure_2.10_B18726.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 网格属性](img/Figure_2.10_B18726.jpg)'
- en: Figure 2.10 – Mesh properties
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 网格属性
- en: Let me walk you through the properties; I’ll start with the `position` property.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我带您了解这些属性；我将从 `position` 属性开始。
- en: Setting the location of the mesh with the position property
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用位置属性设置网格的位置
- en: 'We’ve already seen this property a couple of times, so let’s quickly address
    it. With this property, you set the `x-`, `y-`, and `z-c`oordinates of the object
    relative to its parent. We’ll get back to this in [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081),
    *Learning to Work with Geometries*, when we look at grouping objects. We can set
    an object’s position property in three different ways. We can set each coordinate
    directly:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到这个属性，所以让我们快速了解一下。使用此属性，您设置对象相对于其父对象的 `x-`、`y-` 和 `z-` 坐标。我们将在 [*第 5
    章*](B18726_05.xhtml#_idTextAnchor081) *学习与几何体一起工作* 中回到这一点，当我们查看分组对象时。我们可以以三种不同的方式设置对象的位置属性。我们可以直接设置每个坐标：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, we can also set all of them at once, as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也可以一次性设置所有这些属性，如下所示：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is also a third option. The `position` property is a `THREE.Vector3`
    object. That means we can also do the following to set this object:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三个选项。`position` 属性是一个 `THREE.Vector3` 对象。这意味着我们也可以这样做来设置此对象：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next on the list is the `rotation` property. You’ve already seen this property
    being used a couple of times here and in [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014),
    *Creating Your First 3D Scene* *with Three.js*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是列表中的 `rotation` 属性。您已经在这里和 [*第 1 章*](B18726_01.xhtml#_idTextAnchor014) *使用
    Three.js 创建您的第一个 3D 场景* 中看到过这个属性被使用过几次。
- en: Defining the rotation of the mesh with the rotation property
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用旋转属性定义网格的旋转
- en: 'With this property, you set the rotation of the object around one of its axes.
    You can set this value in the same manner as we did the position. A complete rotation,
    as you might remember from math class, is `2π`. You can configure this in Three.js
    in a couple of different ways:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此属性，您可以为对象设置围绕其轴之一的旋转。您可以以与我们设置位置相同的方式设置此值。完整的旋转，如您可能从数学课中记得的，是 `2π`。您可以在
    Three.js 中以几种不同的方式配置此属性：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you want to use degrees (from 0 to 360) instead, we’ll have to convert those
    to radians. This can be easily done as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用度数（从0到360），我们必须将这些转换为弧度。这可以很容易地按照以下方式完成：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the preceding code block, we’ve done the conversion ourselves. Three.js also
    provides the `MathUtils` class, which provides a lot of helpful conversions, including
    one that does the same thing as we did in the preceding code block. You can play
    around with this property using the `chapter-2/mesh-properties` example.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们亲自进行了转换。Three.js还提供了`MathUtils`类，它提供了很多有用的转换，包括一个与前面代码块中做同样事情的转换。你可以使用`chapter-2/mesh-properties`示例来玩转这个属性。
- en: 'The next property on our list is one we haven’t talked about: `scale`. The
    name pretty much sums up what you can do with this property. You can scale the
    object along a specific axis. If you set the scale to a value less than one, the
    object will shrink, as shown in the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个属性是我们之前没有讨论过的：`scale`。这个名字基本上概括了你可以用这个属性做什么。你可以沿着特定的轴缩放对象。如果你将缩放设置为小于一的值，对象将会缩小，如下面的截图所示：
- en: '![Figure 2.11 – Use scale to shrink a mesh](img/Figure_2.11_B18726.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 使用缩放缩小网格](img/Figure_2.11_B18726.jpg)'
- en: Figure 2.11 – Use scale to shrink a mesh
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 使用缩放缩小网格
- en: 'When you use values greater than one, the object will become larger, as shown
    in the following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用大于一的值时，对象将会变大，如下面的截图所示：
- en: '![Figure 2.12 – Use scale to grow a mesh](img/Figure_2.12_B18726.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 使用缩放放大网格](img/Figure_2.12_B18726.jpg)'
- en: Figure 2.12 – Use scale to grow a mesh
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 使用缩放来放大网格
- en: The next part of the mesh that we’ll look at is the `translate` property.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的网格的下一个部分是`translate`属性。
- en: Changing the position using the translate property
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`translate`属性改变位置
- en: 'With `translate`, you can also change the position of an object, but instead
    of defining the absolute position where you want the object to be, you define
    the distance the object should move, relative to its current position. For instance,
    we have a sphere that is added to a scene, and its position has been set to `(1,
    2, 3)`. Next, we translate the object along its `x-a`xis: `translateX(4)`. Its
    position will now be `(5, 2, 3)`. If we want to restore the object to its original
    position, we use `translateX(-4)`. In the `chapter-2/mesh-properties` example,
    there is a menu tab called `translate` values for `x`, `y`, and `z` and hit the
    **translate** button. You’ll see the object being moved to a new position based
    on these three values.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`translate`，你还可以改变对象的位置，但不是定义你想要对象所在的绝对位置，而是定义对象相对于当前位置应该移动的距离。例如，我们有一个添加到场景中的球体，其位置已被设置为`(1,
    2, 3)`。接下来，我们沿着对象的`x`轴进行平移：`translateX(4)`。它的位置现在将是`(5, 2, 3)`。如果我们想将对象恢复到原始位置，我们使用`translateX(-4)`。在`chapter-2/mesh-properties`示例中，有一个名为`translate`的菜单标签，用于`x`、`y`和`z`的值，并点击**translate**按钮。你会看到对象根据这三个值移动到新的位置。
- en: The last two properties we’ll look at are used to remove the object completely,
    by setting the `visible` property to `false`, and disabling whether this object
    casts shadows by setting the `castShadow` property to `false`. When you click
    on these buttons, you’ll see the cube becomes invisible and visible, and you can
    disable it from casting shadows.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的最后两个属性是用来完全移除对象的，通过将`visible`属性设置为`false`，并禁用该对象是否投射阴影，通过将`castShadow`属性设置为`false`。当你点击这些按钮时，你会看到立方体变得不可见和可见，并且你可以禁用它投射阴影。
- en: For more information on meshes, geometries, and what you can do with these objects,
    check out [*Chapter 5*](B18726_05.xhtml#_idTextAnchor081), *Learning to Work with
    Geometries*, and [*Chapter 7*](B18726_07.xhtml#_idTextAnchor122), *Points* *and
    Sprites*.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网格、几何体以及你可以用这些对象做什么的更多信息，请查看[*第5章*](B18726_05.xhtml#_idTextAnchor081)，*学习与几何体一起工作*，以及[*第7章*](B18726_07.xhtml#_idTextAnchor122)，*点和精灵*。
- en: So far, we’ve looked at `THREE.Scene`, the main object that holds all the objects
    that we want to render, and we’ve looked in detail at what a `THREE.Mesh` is,
    and how you can create a `THREE.Mesh` and position it in a scene. In previous
    sections, we’ve already used a camera to determine what part of `THREE.Scene`
    you wanted to render but haven't explained in detail yet how you can configure
    a camera. In the next section, we’ll dive into those details.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了 `THREE.Scene`，这是包含我们想要渲染的所有对象的主要对象，并且我们已经详细探讨了 `THREE.Mesh` 是什么，以及如何创建一个
    `THREE.Mesh` 并将其放置在场景中。在之前的章节中，我们已经使用摄像机来确定你想要渲染的 `THREE.Scene` 的哪一部分，但还没有详细解释如何配置摄像机。在下一节中，我们将深入探讨这些细节。
- en: Using different cameras for different scenes
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同摄像机渲染不同场景
- en: 'There are two different camera types in Three.js: the orthographic camera and
    the perspective camera. Note that Three.js also provides a couple of very specific
    cameras for creating scenes that can be viewed using 3D glasses or VR gear. We
    won’t go into detail about those cameras in this book, since they work exactly
    the same as the cameras explained in this chapter. If you’re interested in these
    cameras, Three.js provides a few standard examples:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中有两种不同的摄像机类型：正交摄像机和透视摄像机。请注意，Three.js 还提供了一些非常具体的摄像机，用于创建可以使用 3D
    眼镜或 VR 设备查看的场景。在这本书中，我们不会详细介绍这些摄像机，因为它们的工作方式与本章中解释的摄像机完全相同。如果你对这些摄像机感兴趣，Three.js
    提供了一些标准示例：
- en: '**Anaglyph** **effect**: [https://threejs.org/examples/#webgl_effects_anaglyph](https://threejs.org/examples/#webgl_effects_anaglyph'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全息** **效果**：[https://threejs.org/examples/#webgl_effects_anaglyph](https://threejs.org/examples/#webgl_effects_anaglyph)'
- en: )
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Parallax** **barrier**: [https://threejs.org/examples/#webgl_effects_parallaxbarrier](https://threejs.org/examples/#webgl_effects_parallaxbarrier'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视差** **屏障**：[https://threejs.org/examples/#webgl_effects_parallaxbarrier](https://threejs.org/examples/#webgl_effects_parallaxbarrier)'
- en: )
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Stereo** **effect**: [https://threejs.org/examples/#webgl_effects_stereo](https://threejs.org/examples/#webgl_effects_stereo'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**立体** **效果**：[https://threejs.org/examples/#webgl_effects_stereo](https://threejs.org/examples/#webgl_effects_stereo)'
- en: )
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'If you’re looking for simple VR cameras, you can use `THREE.StereoCamera` to
    create 3D scenes that are rendered side to side (standard stereo effect), use
    a parallel barrier (as 3DS provides), or provide an anaglyph effect where the
    different views are rendered in different colors. Alternatively, Three.js has
    some experimental support for the WebVR standard, which is supported by a number
    of browsers (for more info, see [https://webvr.info/developers/](https://webvr.info/developers/)).
    To use this, not that much needs to change. You just set `renderer.vr.enabled
    = true`, and Three.js will handle the rest. The Three.js website has a couple
    of examples where this property and some other features of Three.js''s support
    for WebVR are demonstrated: [https://threejs.org/examples/](https://threejs.org/examples/).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找简单的 VR 摄像机，可以使用 `THREE.StereoCamera` 创建渲染为左右并排的 3D 场景（标准立体效果），使用平行屏障（如
    3DS 提供），或者提供一种将不同视图渲染为不同颜色的立体效果。或者，Three.js 对 WebVR 标准有一些实验性支持，该标准被许多浏览器支持（更多信息，请参阅
    [https://webvr.info/developers/](https://webvr.info/developers/)）。要使用此功能，不需要做太多改变。你只需设置
    `renderer.vr.enabled = true`，Three.js 将处理其余部分。Three.js 网站上有几个示例演示了此属性以及 Three.js
    对 WebVR 的其他一些支持功能：[https://threejs.org/examples/](https://threejs.org/examples/)。
- en: For now, we’ll focus on the standard perspective and orthographic cameras. The
    best way to explain the differences between these cameras is by looking at a couple
    of examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将专注于标准透视和正交摄像机。解释这些摄像机之间差异的最好方法是通过查看一些示例。
- en: An orthographic camera versus a perspective camera
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正交摄像机与透视摄像机的比较
- en: 'In the examples for this chapter, you can find a demo called `chapter2/cameras`.
    When you open this example, you’ll see something like the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的示例中，你可以找到一个名为 `chapter2/cameras` 的演示。当你打开这个示例时，你会看到以下内容：
- en: '![Figure 2.13 – Perspective camera view](img/Figure_2.13_B18726.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 透视摄像机视图](img/Figure_2.13_B18726.jpg)'
- en: Figure 2.13 – Perspective camera view
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 透视摄像机视图
- en: 'This preceding screenshot is called a perspective view and is the most natural
    view. As you can see from this figure, the farther away the cubes are from the
    camera, the smaller they are rendered. If we change the camera to the other type
    supported by Three.js, the orthographic camera, you’ll see the following view
    of the same scene:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图被称为透视视图，是最自然的视图。如图所示，立方体离摄像机越远，渲染得越小。如果我们将摄像机更改为Three.js支持的另一种类型，即正射摄像机，你会看到相同场景的以下视图：
- en: '![Figure 2.14 – Orthographic camera view](img/Figure_2.14_B18726.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 正射摄像机视图](img/Figure_2.14_B18726.jpg)'
- en: Figure 2.14 – Orthographic camera view
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 正射摄像机视图
- en: 'With the orthographic camera, all the cubes are rendered the same size; the
    distance between an object and the camera doesn’t matter. This is often used in
    2D games, such as old versions of *Civilization* and *SimCity 4*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正射摄像机时，所有立方体都以相同的大小渲染；物体与摄像机之间的距离无关。这通常用于2D游戏，例如 *Civilization* 和 *SimCity
    4* 的旧版本：
- en: "![Figure 2.15 – Orthographic usage in Si\uFEFFmCity 4](img/Figure_2.15_B18726.jpg)"
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – SimCity 4中的正射投影使用](img/Figure_2.15_B18726.jpg)'
- en: Figure 2.15 – Orthographic usage in SimCity 4
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – SimCity 4中的正射投影使用
- en: Perspective camera properties
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透视摄像机属性
- en: 'Let’s first look a bit closer at `THREE.PerspectiveCamera`. In the example,
    you can set a number of properties that define what is shown through the lens
    of the camera:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先更仔细地看看 `THREE.PerspectiveCamera`。在示例中，你可以设置一些属性，这些属性定义了通过摄像机镜头可以看到的内容：
- en: '`fov`: The **Field of View** (**FOV**) is the part of the scene that can be
    seen from the position of the camera. Humans, for instance, have an almost 180-degree
    FOV, while some birds even have a complete 360-degree FOV. But since a normal
    computer screen doesn’t completely fill our vision, a smaller value is often chosen.
    Generally, for games, a FOV of between 60 and 90 degrees is chosen. *Good* *default*:
    50'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fov`: **视场角**（**FOV**）是从摄像机位置可以看到的场景部分。例如，人类几乎有180度的视场角，而一些鸟甚至有完整的360度视场角。但由于正常的计算机屏幕并没有完全填满我们的视野，因此通常选择较小的值。一般来说，对于游戏，选择60到90度的视场角。*良好*
    *默认值*: 50'
- en: '`aspect`: This is the aspect ratio between the horizontal and vertical sizes
    of the area where we’re rendering the output. In our case, since we use the entire
    window, we just use that ratio. The aspect ratio determines the difference between
    the horizontal FOV and the vertical FOV. *Good default*: `window.innerWidth /`
    `window.innerHeight`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aspect`: 这是我们在渲染输出区域中渲染的区域的水平尺寸和垂直尺寸之间的宽高比。在我们的例子中，因为我们使用整个窗口，所以我们只使用那个比例。宽高比决定了水平视场角（FOV）和垂直视场角之间的差异。*良好*
    *默认值*: `window.innerWidth / window.innerHeight`'
- en: '`near`: The `near` property defines how close to the camera Three.js should
    render the scene. Normally, we set this to a very small value to directly render
    everything from the position of the camera. *Good* *default*: 0.1'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`near`: `near` 属性定义了 Three.js 应该将场景渲染得多靠近摄像机。通常，我们将此设置为一个非常小的值，以便直接从摄像机的位置渲染一切。*良好*
    *默认值*: 0.1'
- en: '`far`: The `far` property defines how far the camera can see from the position
    of the camera. If we set this too low, part of our scene might not be rendered,
    and if we set it too high, in some cases, it might affect the rendering performance.
    *Good* *default*: 100'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`far`: `far` 属性定义了摄像机可以从其位置看到多远。如果我们设置得太低，场景的一部分可能不会被渲染，如果我们设置得太高，在某些情况下，它可能会影响渲染性能。*良好*
    *默认值*: 100'
- en: '`zoom`: The `zoom` property allows you to zoom in and out of the scene. When
    you use a number lower than 1, you zoom out of the scene, and if you use a number
    higher than 1, you zoom in. Note that if you specify a negative value, the scene
    will be rendered upside down. *Good* *default*: 1'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoom`: `zoom` 属性允许你放大和缩小场景。当你使用小于1的数字时，你将场景缩小，如果你使用大于1的数字，你将场景放大。注意，如果你指定一个负值，场景将被渲染为颠倒的。*良好*
    *默认值*: 1'
- en: 'The following diagram gives a good overview of how these properties work together
    to determine what you see:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表给出了这些属性如何共同工作以确定你所看到的内容的概述：
- en: '![Figure 2.16 – Properties of the perspective camera](img/Figure_2.16_B18726.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16 – 透视摄像机的属性](img/Figure_2.16_B18726.jpg)'
- en: Figure 2.16 – Properties of the perspective camera
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – 透视摄像机的属性
- en: 'The `fov` property of the camera determines the horizontal FOV. Based on the
    `aspect` property, the vertical FOV is determined. The `near` property is used
    to determine the position of the near plane, and the `far` property determines
    the position of the far plane. The area between the near plane and the far plane
    will be rendered as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 相机的`fov`属性决定了水平视野。基于`aspect`属性，垂直视野被确定。`near`属性用于确定近平面的位置，而`far`属性则决定了远平面的位置。近平面和远平面之间的区域将被渲染如下：
- en: '![Figure 2.17 – Far and near clip the rendered mesh](img/Figure_2.17_B18726.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17 – 远近裁剪渲染网格](img/Figure_2.17_B18726.jpg)'
- en: Figure 2.17 – Far and near clip the rendered mesh
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – 远近裁剪渲染网格
- en: Orthographic camera properties
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正射投影相机属性
- en: 'To configure the orthographic camera, we need to use other properties. The
    orthographic projection isn’t interested in which aspect ratio to use or what
    FOV we have of the scene, since all the objects are rendered at the same size.
    When you define an orthographic camera, you define the cuboid area that needs
    to be rendered. The properties of the orthographic camera reflect this, as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置正射投影相机，我们需要使用其他属性。正射投影对使用何种宽高比或场景的视野范围不感兴趣，因为所有对象都以相同的大小渲染。当你定义一个正射投影相机时，你定义了需要渲染的立方体区域。正射投影相机的属性反映了这一点，如下所示：
- en: '`left`: This is described in the Three.js documentation as the camera frustum
    left plane. You should see this as the left-hand border of what will be rendered.
    If you set this value to `-100`, you won’t see any objects that are positioned
    farther than that on the left-hand side.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left`：在Three.js文档中，`left`属性被描述为相机的视锥体左平面。你应该将其视为将要渲染的左侧边界。如果你将此值设置为`-100`，你将看不到任何在左侧位置超过这个值的对象。'
- en: '`right`: The `right` property works in a way similar to the `left` property,
    but this time, on the other side of the screen. Anything farther to the right
    won’t be rendered.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`right`：`right`属性的工作方式与`left`属性类似，但这次是在屏幕的另一侧。任何在右侧更远的位置都不会被渲染。'
- en: '`top`: This is the top position to be rendered.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`：这是要渲染的顶部位置。'
- en: '`bottom`: This is the bottom position to be rendered.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bottom`：这是要渲染的底部位置。'
- en: '`near`: From this point, based on the position of the camera, the scene will
    be rendered.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`near`：从这个点开始，根据相机的位置，场景将被渲染。'
- en: '`far`: To this point, based on the position of the camera, the scene will be
    rendered.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`far`：到这个点，根据相机的位置，场景将被渲染。'
- en: '`zoom`: This allows you to zoom in and out of the scene. When you use a number
    lower than `1`, you’ll zoom out of the scene; if you use a number higher than
    `1`, you’ll zoom in. Note that if you specify a negative value, the scene will
    be rendered upside down. The default value is `1`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zoom`：这个属性允许你放大或缩小场景。当你使用小于`1`的数字时，你会缩小场景；如果你使用大于`1`的数字，你会放大场景。注意，如果你指定一个负值，场景将被渲染为颠倒的。默认值是`1`。'
- en: 'And all these properties can be summarized in the following diagram:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些属性可以总结如下图所示：
- en: '![Figure 2.18 – Properties of the orthographic camera](img/Figure_2.18_B18726.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18 – 正射投影相机的属性](img/Figure_2.18_B18726.jpg)'
- en: Figure 2.18 – Properties of the orthographic camera
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 – 正射投影相机的属性
- en: 'And just like with the perspective camera, you can exactly define the area
    of the scene you want to render:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像透视相机一样，你可以精确地定义你想要渲染的场景区域：
- en: '![Figure 2.19 – Clipped area with an orthographic camera](img/Figure_2.19_B18726.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19 – 使用正射投影相机的裁剪区域](img/Figure_2.19_B18726.jpg)'
- en: Figure 2.19 – Clipped area with an orthographic camera
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 – 使用正射投影相机的裁剪区域
- en: In the previous section, we explained the different cameras supported by Three.js.
    You’ve learned how to configure them, and how you can use their properties to
    render different parts of the scene. What we didn’t show yet is how you can control
    what part of the scene a camera is looking at. We’ll explain that in the next
    section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们解释了Three.js支持的不同类型的相机。你已经学习了如何配置它们，以及如何使用它们的属性来渲染场景的不同部分。我们还没有展示的是如何控制相机观察场景的哪个部分。我们将在下一节中解释这一点。
- en: Looking at specific points
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察特定点
- en: 'So far, you’ve seen how to create a camera and what the various arguments mean.
    In [*Chapter 1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D Scene
    with Three.js*, you also saw that you need to position your camera somewhere in
    the scene and that the view from that camera is rendered. Normally, the camera
    is pointed to the center of the scene: position `(0, 0, 0)`. We can, however,
    easily change what the camera is looking at, as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了如何创建相机以及各种参数的含义。在[*第 1 章*](B18726_01.xhtml#_idTextAnchor014) *使用
    Three.js 创建您的第一个 3D 场景* 中，你也看到了你需要将相机放置在场景中的某个位置，并且从该相机看到的视图会被渲染。通常，相机指向场景的中心：位置
    `(0, 0, 0)`。然而，我们可以很容易地更改相机所看的方向，如下所示：
- en: '[PRE19]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `chapter2/cameras` example, you can also specify the coordinates you
    want the camera to look at. Note that when you change `lookAt` in the `OrthographicCamera`
    settings, the cubes still stay the same size.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`chapter2/cameras`示例中，你也可以指定相机要看的坐标。请注意，当你更改`OrthographicCamera`设置中的`lookAt`时，立方体仍然保持相同的大小。
- en: '![Figure 2.20 – Changed lookAt property for the orthographic camera](img/Figure_2.20_B18726.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 更改了正交相机的`lookAt`属性](img/Figure_2.20_B18726.jpg)'
- en: Figure 2.20 – Changed lookAt property for the orthographic camera
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 更改了正交相机的`lookAt`属性
- en: 'When you use the `lookAt` function, you point the camera at a specific position.
    You can also use this to make the camera follow an object around a scene. Since
    every `THREE.Mesh` object has a position that is a `THREE.Vector3` object, you
    can use the `lookAt` function to point to a specific mesh in the scene. All you
    need to use is this: `camera.lookAt(mesh.position)`. If you call this in the render
    loop, you’ll make the camera follow an object as it moves through a scene.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`lookAt`函数时，你将相机指向一个特定的位置。你也可以使用这个函数使相机围绕场景中的物体移动。由于每个`THREE.Mesh`对象都有一个位置，它是一个`THREE.Vector3`对象，因此你可以使用`lookAt`函数指向场景中的特定网格。你需要做的只是使用这个：`camera.lookAt(mesh.position)`。如果你在渲染循环中调用这个函数，你将使相机跟随物体在场景中移动。
- en: Debugging what a camera looks at
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试相机所看的对象
- en: 'When looking at configuring the camera, having a menu where you can play around
    with the different settings can help a lot. Sometimes, though, you might want
    to exactly see the area that will be rendered by the camera. Three.js allows you
    to do this, by visualizing the frustum of the camera (the area that is shown by
    the camera). To do this, we simply add an additional camera to the scene and add
    a camera helper. To see this in action, open the `chapter-2/debug-camera.html`
    example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置相机时，有一个可以让你尝试不同设置的菜单会非常有帮助。有时，你可能想确切地看到相机将要渲染的区域。Three.js 允许你通过可视化相机的视锥体（相机所显示的区域）来实现这一点。为此，我们只需在场景中添加一个额外的相机并添加一个相机辅助器。要看到这个效果，请打开`chapter-2/debug-camera.html`示例：
- en: '![Figure 2.21 – Show the frustum of the camera](img/Figure_2.21_B18726.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.21 – 显示相机的视锥体](img/Figure_2.21_B18726.jpg)'
- en: Figure 2.21 – Show the frustum of the camera
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.21 – 显示相机的视锥体
- en: 'In the preceding figure, you can see the outline of the frustum of a perspective
    camera. If you change the properties in the menu, you can see that the frustum
    changes as well. This frustum is visualized by adding the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以看到透视相机的视锥体的轮廓。如果你在菜单中更改属性，你会看到视锥体也会随之改变。这个视锥体是通过添加以下内容可视化的：
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We’ve also added a **switchCamera** button, which allows you to switch between
    the external camera looking in at the scene and the main camera in the scene.
    This provides a great way to get the correct settings for your camera:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个**switchCamera**按钮，允许你在场景外部观察的相机和场景中的主相机之间切换。这为获取正确的相机设置提供了一种很好的方法：
- en: '![Figure 2.22 – Switch between cameras](img/Figure_2.22_B18726.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.22 – 切换相机](img/Figure_2.22_B18726.jpg)'
- en: Figure 2.22 – Switch between cameras
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.22 – 切换相机
- en: Switching cameras is really easy in Three.js. The only thing you need to do
    is tell Three.js you want to render the scene through a different camera.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Three.js 中切换相机非常简单。你需要做的只是告诉 Three.js 你想要通过不同的相机渲染场景。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We discussed a lot in this second introductory chapter. We showed the functions
    and properties of `THREE.Scene` and explained how you can use these properties
    to configure your main scene. We also showed you how to create geometries. You
    can either create them from scratch using a `THREE.Buffergeometry` object or use
    any of the built-in geometries Three.js provides. Finally, we showed you how to
    configure the two main cameras Three.js provides. `THREE.PerspectiveCamera` renders
    a scene using a real-world perspective, and `THREE.OrthographicCamera` provides
    the fake 3D effect often seen in games. We’ve also covered how geometries work
    in Three.js and you can now easily create your own geometries from the standard
    geometries provided by Three.js or by crafting them by hand.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的第二部分介绍了许多内容。我们展示了 `THREE.Scene` 的功能和属性，并解释了如何使用这些属性来配置你的主场景。我们还向你展示了如何创建几何体。你可以从零开始使用
    `THREE.Buffergeometry` 对象创建它们，或者使用 Three.js 提供的任何内置几何体。最后，我们向你展示了如何配置 Three.js
    提供的两个主要摄像机。`THREE.PerspectiveCamera` 使用现实世界的透视来渲染场景，而 `THREE.OrthographicCamera`
    提供了在游戏中经常看到的假3D效果。我们还涵盖了在 Three.js 中几何体是如何工作的，你现在可以轻松地创建自己的几何体，无论是从 Three.js 提供的标准几何体中创建，还是通过手工制作。
- en: In the next chapter, we’ll look at the various light sources that are available
    in Three.js. You’ll learn how the various light sources behave, how to create
    and configure them, and how they affect different materials.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Three.js 中可用的各种光源。你将学习不同光源的行为方式，如何创建和配置它们，以及它们如何影响不同的材质。
