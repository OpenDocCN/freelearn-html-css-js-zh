<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer030">
<h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor093"/>7</h1>
<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Tidying up Test Suites</h1>
<p>Have you ever felt frustrated when working with your test suites? They can easily become messy and overgrown, unless you’re actively tending to them. In this chapter, we’ll look at some of the ways you can keep your test <span class="No-Break">suites tidy.</span></p>
<p>The techniques you’ll use to tidy test suites differ from the techniques you’d use in your application code. Application code requires building abstractions and encapsulating details, with deep layers of connecting objects. However, tests benefit from being shallow, with each test statement having a <span class="No-Break">clear effect.</span></p>
<p>Another way to think of it is that normal program flow can take many different paths through the code, but test suites have just one flow – they are scripts that run from top to bottom. There is an absence of control logic, such as conditional expressions and <span class="No-Break">loop constructs.</span></p>
<p>The primary mechanism you have to control complexity in test suites is abstracting functions that <span class="No-Break">hide detail.</span></p>
<p>This chapter covers the <span class="No-Break">following techniques:</span></p>
<ul>
<li>Using page object models in <span class="No-Break">Playwright tests</span></li>
<li>Extracting an <span class="No-Break">action helper</span></li>
<li>Extracting a factory method for creating <span class="No-Break">data objects</span></li>
</ul>
<p>By the end of the chapter, you’ll have learned an array of strategies to cut down on the size of your <span class="No-Break">test suites.</span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Technical requirements</h1>
<p>The code for the chapter can be found online <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter07/Start"><span class="No-Break">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter07/Start</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Using page object models in Playwright tests</h1>
<p>A <strong class="bold">page object model</strong> is simply a plain JavaScript<a id="_idIndexMarker222"/> class that groups up the mechanical<a id="_idIndexMarker223"/> actions of navigating<a id="_idIndexMarker224"/> a page (locating a field, clicking a button, or filling in a text field) into methods that describe high-level operations that occur within your application (completing a <span class="No-Break">birthday form).</span></p>
<p>In this section, you’ll build a page object model named <strong class="source-inline">BirthdayListPage</strong> that will allow you to rewrite your existing Playwright tests <span class="No-Break">more simply.</span></p>
<p>Let’s get started by adding the <span class="No-Break">new class:</span></p>
<ol>
<li>Create a new file named <strong class="source-inline">tests/BirthdayListPage.js</strong> and give it the following content. It creates the basic class along with a single method, <strong class="source-inline">goto</strong>, which is used to navigate to the <strong class="source-inline">/birthdays</strong> <span class="No-Break">application URL:</span><pre class="source-code">
export class BirthdayListPage {
  constructor(page) {
    this.page = page;
  }
  async goto() {
    await this.page.goto('/birthdays');
  }
}</pre></li>
<li>We can already make use of this class in our tests. In <strong class="source-inline">tests/birthdays.test.js</strong>, add the following import at the top of <span class="No-Break">the file:</span><pre class="source-code">
import {
  BirthdayListPage
} from './BirthdayListPage.js';</pre></li>
<li>Now, update all the tests to use this class, by replacing the direct call to <strong class="source-inline">page.goto</strong> with the indirect call via the <strong class="source-inline">BirthdayListPage</strong> object. For example, consider the following <span class="No-Break">existing test:</span><pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  await page.goto('/birthdays');
  ...
});</pre></li>
</ol>
<p>It should be modified to <span class="No-Break">become this:</span></p>
<pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
<strong class="bold">  const birthdayListPage = new BirthdayListPage(page);</strong>
<strong class="bold">  await birthdayListPage.goto();</strong>
  ...
});</pre>
<ol>
<li value="4">Now, we’ll move on to creating<a id="_idIndexMarker225"/> helpers for each of the individual<a id="_idIndexMarker226"/> files. Take a look at this original code from the <span class="No-Break">editing test:</span><pre class="source-code">
// add a birthday using the form
await page.getByLabel('Name').fill('Ares');
await page
  .getByLabel('Date of birth')
  .fill('1985-01-01');
await page
  .getByRole('button', { name: 'Save' })
  .click();</pre></li>
</ol>
<p>From this, we can pull helpers called <strong class="source-inline">nameField</strong>, <strong class="source-inline">dateOfBirthField</strong>, and <strong class="source-inline">saveButton</strong>. Now, add them to <strong class="source-inline">BirthdayListPage</strong>, <span class="No-Break">like this:</span></p>
<pre class="source-code">
export class BirthdayListPage {
  ...
<strong class="bold">  dateOfBirthField = () =&gt;</strong>
<strong class="bold">    this.page.getByLabel('Date of birth');</strong>
<strong class="bold">  </strong><strong class="bold">nameField = () =&gt; this.page.getByLabel('Name');</strong>
<strong class="bold">  saveButton = () =&gt;</strong>
<strong class="bold">    this.page.getByRole('button', { name: 'Save' });</strong>
}</pre>
<ol>
<li value="5">Still in <strong class="source-inline">BirthdayLastPage</strong>, you can now roll up these helper<a id="_idIndexMarker227"/> methods into a single helper method<a id="_idIndexMarker228"/> that performs the whole <span class="No-Break">action, </span><span class="No-Break"><strong class="source-inline">saveNameAndDateOfBirth</strong></span><span class="No-Break">:</span><pre class="source-code">
export class BirthdayListPage {
  ...
<strong class="bold">  saveNameAndDateOfBirth = async (name, dob) =&gt; {</strong>
<strong class="bold">    await this.nameField().fill(name);</strong>
<strong class="bold">    await this.dateOfBirthField().fill(dob);</strong>
<strong class="bold">    await this.saveButton().click();</strong>
};</pre></li>
<li>The section of code in <em class="italic">step 4</em> from the original test, which was eight lines of code including the explanatory comment, can now be done in a single function call. The comment is no longer necessary because the method name basically says the same thing. Go ahead and update the test now, as <span class="No-Break">shown here:</span><pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  const birthdayListPage = new BirthdayListPage(page);
  await birthdayListPage.goto();
<strong class="bold">  await birthdayListPage.saveNameAndDateOfBirth(</strong>
<strong class="bold">    'Ares',</strong>
<strong class="bold">    '1985-01-01'</strong>
<strong class="bold">  );</strong>
  ...
);</pre></li>
</ol>
<p>That completes this section<a id="_idIndexMarker229"/> of the test. Now for the next bit, which looks<a id="_idIndexMarker230"/> <span class="No-Break">like this:</span></p>
<pre class="source-code">
// find the Edit button for that person
await page
  .getByRole('listitem')
  .filter({ hasText: 'Ares' })
  .getByRole('button', { name: 'Edit' })
  .click();</pre>
<p>For this section, we can repeat the earlier steps to extract an internal helper to locate the desired field, and then extract a second external helper to perform the action. Start by adding a new helper in the <strong class="source-inline">BirthdayListPage</strong> page object model, named <strong class="source-inline">entryFor</strong>, that finds the entry for a <span class="No-Break">person’s name:</span></p>
<pre class="source-code">
entryFor = (name) =&gt;
  this.page
    .getByRole('listitem')
    .filter({ hasText: name });</pre>
<ol>
<li value="7">Now, use the <strong class="source-inline">entryFor</strong> method to build another helper, <strong class="source-inline">beginEditingFor</strong>, which clicks the <strong class="bold">Edit</strong> button for <span class="No-Break">that birthday:</span><pre class="source-code">
beginEditingFor = (name) =&gt;
  this.entryFor(name)
    .getByRole('button', { name: 'Edit' })
    .click();</pre></li>
<li>It’s time to remove the original code<a id="_idIndexMarker231"/> shown in <em class="italic">step 6</em> with a single call to this new helper <a id="_idIndexMarker232"/>in the page object model. Make the updates shown in the following code block, again getting rid of the comment and reducing six lines down <span class="No-Break">to one:</span><pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  const birthdayListPage = new BirthdayListPage(page);
  await birthdayListPage.goto();
  await birthdayListPage.saveNameAndDateOfBirth(
    'Ares',
    '1985-01-01'
  );
<strong class="bold">  await birthdayListPage.beginEditingFor('Ares');</strong>
  ...
});</pre></li>
<li>There’s one final action within the test that can be updated, which is the action to modify the form values after beginning editing. We don’t need to create any new helpers for this action. We simply need to reuse the <strong class="source-inline">saveNameAndDateOfBirth</strong> helper. Go ahead and do that now, <span class="No-Break">like this:</span><pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  ...
  await birthdayListPage.beginEditingFor('Ares');
<strong class="bold">  await birthdayListPage.saveNameAndDateOfBirth(</strong>
<strong class="bold">    'Ares',</strong>
<strong class="bold">    '1995-01-01'</strong>
<strong class="bold">  );</strong>
  ...
});</pre></li>
<li>The last change to make is a change to the expectations. They can be updated to use the <strong class="source-inline">entryFor</strong> helper. Since this is the last change in this section, the listing shows the fully complete test. Make the changes to the expectations as <span class="No-Break">shown here:</span><pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  const birthdayListPage = new BirthdayListPage(page);
  await birthdayListPage.goto();
  await birthdayListPage.saveNameAndDateOfBirth(
    'Ares',
    '1985-01-01'
  );
  await birthdayListPage.beginEditingFor('Ares');
  await birthdayListPage.saveNameAndDateOfBirth(
    'Ares',
    '1995-01-01'
  );
  await expect(
    <strong class="bold">birthdayListPage.entryFor('Ares')</strong>
  ).not.toContainText('1985-01-01');
  await expect(
    <strong class="bold">birthdayListPage.entryFor('Ares')</strong>
  ).toContainText('1995-01-01');
});</pre></li>
</ol>
<p>The benefits of introducing the <strong class="source-inline">BirthdayListPage</strong> page object model are clear: the test is more readable, the test data is more prominent (the two changing date of births are now more visible), and any future changes<a id="_idIndexMarker233"/> will be quicker to make, simply because<a id="_idIndexMarker234"/> the test <span class="No-Break">is shorter.</span></p>
<p class="callout-heading">Continuing with the remaining tests</p>
<p class="callout">The other Playwright tests in the repository can also be rewritten using the exact same helpers. These changes aren’t shown in this book but are available in the <span class="No-Break">companion repository.</span></p>
<p>In this section, you saw how to create a Playwright page object model. Next, we’ll do something similar with the Vitest <span class="No-Break">unit tests.</span></p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Extracting an action helper</h1>
<p>This section covers<a id="_idIndexMarker235"/> the use of a helper to simplify the <em class="italic">Act</em> phase of <span class="No-Break">a test.</span></p>
<p class="callout-heading">Understanding the Arrange-Act-Assert pattern</p>
<p class="callout">The <em class="italic">Arrange-Act-Assert</em> pattern is a standard way to describe<a id="_idIndexMarker236"/> the order in which unit tests <span class="No-Break">are written.</span></p>
<p class="callout">They start with the <em class="italic">Arrange</em> phase, which is when the structure under test is primed for work. Any input data is constructed, and any preparatory methods are called that get the system into the <span class="No-Break">right state.</span></p>
<p class="callout">Then, we have the <em class="italic">Act</em> phase, which invokes the operation that is being checked. Finally, the test ends with the <em class="italic">Assert</em> phase, which can be one or more expectations (or <em class="italic">assertions</em>) that verify that the operation did what it was <span class="No-Break">meant to.</span></p>
<p class="callout">Each of these three phases benefits from different strategies to <span class="No-Break">remove duplication.</span></p>
<p>The <em class="italic">Act</em> phase is the one that I think benefits least from the removal of duplication. That’s because the majority of unit tests you’ll write – and all the unit tests in this book – have an action that is triggered by a single method call. It’s rare to find a scenario where the action that is being observed requires anything more than a <span class="No-Break">single instruction.</span></p>
<p>And because of this, I like to ensure the method call is called directly within the unit tests, and not mixed up with any of the <em class="italic">Arrange</em> phase statements. That being said, there are some occasions when it helps to build an <em class="italic">Act</em> helper. The call to invoke a SvelteKit form action via the <strong class="source-inline">actions.default</strong> import, is one of <span class="No-Break">these occasions.</span></p>
<p>There are a couple<a id="_idIndexMarker237"/> of reasons why. First, the name <strong class="source-inline">actions.default</strong> is non-descriptive in the context of a unit test suite. Second, the form action’s parameter is not trivial – it uses the Form API’s <strong class="source-inline">request</strong> object to wrap the form data, which is then packaged into a SvelteKit <strong class="source-inline">RequestEvent</strong>-like object. This needs to be done in every single test. What we care about are the values within the form data, not the plumbing <span class="No-Break">around it.</span></p>
<p>In the <strong class="source-inline">src/routes/birthdays/page.server.test.js</strong> file, you’ll see the following pattern repeated <span class="No-Break">many times:</span></p>
<pre class="source-code">
const request = createFormDataRequest({
 // ... the form data object ...
});
await actions.default({ request });</pre>
<p>You can consider the request statement part of the setup. It is required every single time the form action is called. There is no way to call the form action without doing the form <span class="No-Break">data dance.</span></p>
<p>So, let’s create a helper<a id="_idIndexMarker238"/> that wraps this behavior. We’ll call it <strong class="source-inline">performFormAction</strong>, which makes it clear what’s happening in <span class="No-Break">the test.</span></p>
<p><span class="No-Break">Let’s begin:</span></p>
<ol>
<li>In <strong class="source-inline">src/routes/birthdays/page.server.test.js</strong>, add the following function definition to the top of the <strong class="source-inline">/birthdays - default </strong><span class="No-Break"><strong class="source-inline">action</strong></span><span class="No-Break"> context:</span><pre class="source-code">
const performFormAction = (formData) =&gt;
  actions.default({
    request: createFormDataRequest(formData)
  });</pre></li>
<li>In each test, look for the pattern described in the preceding code snippet – calling <strong class="source-inline">createFormDataRequest</strong> and then the imported <strong class="source-inline">actions.default</strong> function – and replace each instance with a call to <strong class="source-inline">performFormAction</strong>. The following is an example from one of <span class="No-Break">the tests:</span><pre class="source-code">
it('adds a new birthday into the list', async () =&gt; {
<strong class="bold">  await performFormAction({</strong>
    name: 'Zeus',
    dob: '2009-02-02'
<strong class="bold">  });</strong>
  expect(birthdayStore.getAll()).toContainEqual(
    expect.objectContaining({
      name: 'Zeus',
      dob: '2009-02-02'
    });
  });
});</pre></li>
</ol>
<p>Make sure you rerun<a id="_idIndexMarker239"/> all your tests once you’ve made that change in all of them in the test suite. In the next section, we’ll continue with a look at simplifying the <em class="italic">Arrange</em> section of the <span class="No-Break">test suite.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Extracting a factory method for creating data objects</h1>
<p>It’s time to simplify the <em class="italic">Arrange</em> phase of the tests<a id="_idIndexMarker240"/> using a factory<a id="_idIndexMarker241"/> method <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">createBirthday</strong></span><span class="No-Break">.</span></p>
<p>The last section mentioned how each of the <em class="italic">Arrange-Act-Assert</em> phases needs a different treatment for simplification. A key method for the <em class="italic">Arrange</em> phase is the use of factories. You already created one of those in <a href="B19611_04.xhtml#_idTextAnchor060"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Saving Form Data</em>. That was the <strong class="source-inline">createFormDataRequest</strong> method that you used in the <span class="No-Break">preceding section.</span></p>
<p class="callout-heading">Using test factories to hide irrelevant data</p>
<p class="callout">Factory methods help you generate supporting<a id="_idIndexMarker242"/> objects in the shortest amount of code possible. One way they do that is by setting default values for object properties so that you don’t need to specify them. You’re then free to override those defaults in each <span class="No-Break">individual test.</span></p>
<p class="callout">Hiding necessary but irrelevant data is a key method for keeping unit tests succinct <span class="No-Break">and clear.</span></p>
<p>Our birthday objects have a very simple structure, with just three fields – <strong class="source-inline">name</strong>, <strong class="source-inline">dob</strong>, and <strong class="source-inline">id</strong>. Of these three, <strong class="source-inline">name</strong> and <strong class="source-inline">dob</strong> are set frequently and the <strong class="source-inline">id</strong> field infrequently. Also, each of the individual fields has a unique shape of data – a name looks<a id="_idIndexMarker243"/> very different from a date, and very different from a <strong class="bold">universally unique </strong><span class="No-Break"><strong class="bold">identifier</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">UUID</strong></span><span class="No-Break">).</span></p>
<p>With that in mind, the upcoming <strong class="source-inline">createBirthday</strong> helper requires both <strong class="source-inline">name</strong> and <strong class="source-inline">dob</strong> but leaves <strong class="source-inline">id</strong> as an extra field that can sometimes be specified. Those <strong class="source-inline">name</strong> and <strong class="source-inline">dob</strong> values are given as positional parameters – meaning they are identified by position and not by name – because it’s obvious which is which. That saves space on <span class="No-Break">the page.</span></p>
<p>It might not seem important, but when you are writing software for maintainability, every single word must prove <span class="No-Break">its worth.</span></p>
<p>Here’s an example<a id="_idIndexMarker244"/> of how this looks. Note how <strong class="source-inline">id</strong> is specified <a id="_idIndexMarker245"/>differently, due to being <span class="No-Break">rarely used:</span></p>
<pre class="source-code">
createBirthday('Zeus Ex', '2007-02-02', { id: storedId() })</pre>
<p><span class="No-Break">Let’s begin:</span></p>
<ol>
<li>Create a new file named <strong class="source-inline">src/factories/birthday.js</strong> and give it the <span class="No-Break">following content:</span><pre class="source-code">
export const createBirthday = (
  name,
  dob,
  extra = {}
) =&gt; ({ name, dob, ...extra });</pre></li>
<li>Open the <strong class="source-inline">src/routes/birthdays/Birthday.test.js</strong> file and import the <span class="No-Break">new helper:</span><pre class="source-code">
import {
  createBirthday
} from src/factories/birthday.js';</pre></li>
<li>Next, find all the <strong class="source-inline">render</strong> calls that use the <strong class="source-inline">exampleBirthday</strong> object. They look <span class="No-Break">like this:</span><pre class="source-code">
render(Birthday, {
  ...exampleBirthday,
  name: 'Hercules'
});</pre></li>
</ol>
<p>Update them to use the new helper, <span class="No-Break">like this:</span></p>
<pre class="source-code">
render(
  Birthday,
  <strong class="bold">createBirthday('Hercules', '1996-03-03')</strong>
);</pre>
<ol>
<li value="4">Then, in <strong class="source-inline">src/routes/birthdays/page.server.test.js</strong>, add the <span class="No-Break"><strong class="source-inline">createBirthday</strong></span><span class="No-Break"> import:</span><pre class="source-code">
import {
  createBirthday
} from 'src/factories/birthday.js';</pre></li>
<li>Find all the calls to <strong class="source-inline">performFormAction</strong> that you updated<a id="_idIndexMarker246"/> in the previous<a id="_idIndexMarker247"/> section. They’ll look something <span class="No-Break">like this:</span><pre class="source-code">
await performFormAction({
  name: 'Zeus',
  dob: '2009-02-02'
});</pre></li>
</ol>
<p>Update them to use the <strong class="source-inline">createBirthday</strong> helper, <span class="No-Break">shown here:</span></p>
<pre class="source-code">
await performFormAction(
  <strong class="bold">createBirthday('Zeus', '2009-02-02')</strong>
);</pre>
<p>There are a couple of tests where the preceding change isn’t straightforward. In the <em class="italic">saves unique ids one each new birthday </em>test, you can save the created birthday in the <strong class="source-inline">request</strong> object, and then pass that into <strong class="source-inline">performFormAction</strong> twice, as shown in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
it('saves unique ids onto each new birthday', async () =&gt; {
  const request = createBirthday(
    'Zeus',
    '2009-02-02'
  );
  await performFormAction(request);
  await performFormAction(request);
  expect(birthdayStore.getAll()[0].id).not.toEqual(
    birthdayStore.getAll()[1].id
  );
});</pre>
<p>The <em class="italic">updates an entrythat shares the same id</em> test<a id="_idIndexMarker248"/> needs a specific <strong class="source-inline">id</strong> passed<a id="_idIndexMarker249"/> into the second invocation. Note how the factory method is structured in such a way that uncommon information needs to be named, such as the <span class="No-Break"><strong class="source-inline">id</strong></span><span class="No-Break"> field:</span></p>
<pre class="source-code">
it('updates an entry that shares the same id', async () =&gt; {
  await performFormAction(
    <strong class="bold">createBirthday('Zeus', '2009-02-02')</strong>
  );
  await performFormAction(
    <strong class="bold">createBirthday('Zeus Ex', '2007-02-02', { id:</strong>
<strong class="bold">      storedId() })</strong>
  );
  expect(birthdayStore.getAll()).toHaveLength(1);
  expect(birthdayStore.getAll()).toContainEqual({
    id,
    name: 'Zeus Ex',
    dob: '2007-02-02'
  });
});</pre>
<ol>
<li value="6">For the final test<a id="_idIndexMarker250"/> suite, in <strong class="source-inline">src/routes/birthdays/page.test.js</strong>, the <strong class="source-inline">birthdays</strong> array can be updated<a id="_idIndexMarker251"/> to use two calls to <strong class="source-inline">createBirthday</strong>, as <span class="No-Break">shown here:</span><pre class="source-code">
const birthdays = [
<strong class="bold">  createBirthday('Hercules', '1994-02-02', {</strong>
<strong class="bold">    id: '123'</strong>
<strong class="bold">  })</strong>,
<strong class="bold">  createBirthday('Athena', '1989-01-01', {</strong>
<strong class="bold">    id: '234'</strong>
<strong class="bold">  })</strong>
];</pre></li>
<li>Finally, update the test shown here so that it uses the <strong class="source-inline">createBirthday</strong> helper directly in the <strong class="source-inline">render</strong> call for both the <strong class="source-inline">birthdays</strong> prop value and the <strong class="source-inline">form</strong> <span class="No-Break">prop value:</span><pre class="source-code">
it('displays all the birthdays passed to it', () =&gt; {
  render(Page, {
    data: {
      birthdays: [
        <strong class="bold">createBirthday('Hercules', '1994-02-02', {</strong>
        <strong class="bold">id: '123'</strong>
        <strong class="bold">})</strong>
      ]
    },
    form: {
      <strong class="bold">...createBirthday('Hercules', 'bad dob', {</strong>
        <strong class="bold">id: '123'</strong>
        <strong class="bold">}),</strong>
      error: 'An error'
    }
  });
});</pre></li>
</ol>
<p>That completes the use of <strong class="source-inline">createBirthday</strong>. Make sure to rerun<a id="_idIndexMarker252"/> your tests to ensure<a id="_idIndexMarker253"/> that everything is <span class="No-Break">still green.</span></p>
<p>You’ve now learned how a test factory method can be used to simplify and bring clarity to your <span class="No-Break">unit tests.</span></p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Summary</h1>
<p>This chapter has shown you three techniques to shorten your test suites: page object models for Playwright end-to-end tests, action helpers for Vitest unit tests, and factory methods. Keeping test suites clear and meaningful is key to keeping them <span class="No-Break">easily maintainable.</span></p>
<p>In this next chapter, we’ll look at a more involved way of reducing unit test code – writing your own <span class="No-Break">custom matchers.</span></p>
</div>
</div></body></html>