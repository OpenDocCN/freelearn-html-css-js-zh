<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-94"><a id="_idTextAnchor093"/>7</h1>
<h1 id="_idParaDest-95"><a id="_idTextAnchor094"/>Tidying up Test Suites</h1>
<p>Have you ever felt frustrated when working with your test suites? They can easily become messy and overgrown, unless you’re actively tending to them. In this chapter, we’ll look at some of the ways you can keep your test suites tidy.</p>
<p>The techniques you’ll use to tidy test suites differ from the techniques you’d use in your application code. Application code requires building abstractions and encapsulating details, with deep layers of connecting objects. However, tests benefit from being shallow, with each test statement having a clear effect.</p>
<p>Another way to think of it is that normal program flow can take many different paths through the code, but test suites have just one flow – they are scripts that run from top to bottom. There is an absence of control logic, such as conditional expressions and loop constructs.</p>
<p>The primary mechanism you have to control complexity in test suites is abstracting functions that hide detail.</p>
<p>This chapter covers the following techniques:</p>
<ul>
<li>Using page object models in Playwright tests</li>
<li>Extracting an action helper</li>
<li>Extracting a factory method for creating data objects</li>
</ul>
<p>By the end of the chapter, you’ll have learned an array of strategies to cut down on the size of your test suites.</p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter07/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter07/Start</a>.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Using page object models in Playwright tests</h1>
<p>A <strong class="bold">page object model</strong> is simply a plain JavaScript<a id="_idIndexMarker222"/> class that groups up the mechanical<a id="_idIndexMarker223"/> actions of navigating<a id="_idIndexMarker224"/> a page (locating a field, clicking a button, or filling in a text field) into methods that describe high-level operations that occur within your application (completing a birthday form).</p>
<p>In this section, you’ll build a page object model named <code>BirthdayListPage</code> that will allow you to rewrite your existing Playwright tests more simply.</p>
<p>Let’s get started by adding the new class:</p>
<ol>
<li>Create a new file named <code>tests/BirthdayListPage.js</code> and give it the following content. It creates the basic class along with a single method, <code>goto</code>, which is used to navigate to the <code>/birthdays</code> application URL:<pre class="source-code">
export class BirthdayListPage {
  constructor(page) {
    this.page = page;
  }
  async goto() {
    await this.page.goto('/birthdays');
  }
}</pre></li>
<li>We can already make use of this class in our tests. In <code>tests/birthdays.test.js</code>, add the following import at the top of the file:<pre class="source-code">
import {
  BirthdayListPage
} from './BirthdayListPage.js';</pre></li>
<li>Now, update all the tests to use this class, by replacing the direct call to <code>page.goto</code> with the indirect call via the <code>BirthdayListPage</code> object. For example, consider the following existing test:<pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  await page.goto('/birthdays');
  ...
});</pre></li>
</ol>
<p>It should be modified to become this:</p>
<pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
<strong class="bold">  const birthdayListPage = new BirthdayListPage(page);</strong>
<strong class="bold">  await birthdayListPage.goto();</strong>
  ...
});</pre>
<ol>
<li value="4">Now, we’ll move on to creating<a id="_idIndexMarker225"/> helpers for each of the individual<a id="_idIndexMarker226"/> files. Take a look at this original code from the editing test:<pre class="source-code">
// add a birthday using the form
await page.getByLabel('Name').fill('Ares');
await page
  .getByLabel('Date of birth')
  .fill('1985-01-01');
await page
  .getByRole('button', { name: 'Save' })
  .click();</pre></li>
</ol>
<p>From this, we can pull helpers called <code>nameField</code>, <code>dateOfBirthField</code>, and <code>saveButton</code>. Now, add them to <code>BirthdayListPage</code>, like this:</p>
<pre class="source-code">
export class BirthdayListPage {
  ...
<strong class="bold">  dateOfBirthField = () =&gt;</strong>
<strong class="bold">    this.page.getByLabel('Date of birth');</strong>
<strong class="bold">  </strong><strong class="bold">nameField = () =&gt; this.page.getByLabel('Name');</strong>
<strong class="bold">  saveButton = () =&gt;</strong>
<strong class="bold">    this.page.getByRole('button', { name: 'Save' });</strong>
}</pre>
<ol>
<li value="5">Still in <code>BirthdayLastPage</code>, you can now roll up these helper<a id="_idIndexMarker227"/> methods into a single helper method<a id="_idIndexMarker228"/> that performs the whole action, <code>saveNameAndDateOfBirth</code>:<pre class="source-code">
export class BirthdayListPage {
  ...
<strong class="bold">  saveNameAndDateOfBirth = async (name, dob) =&gt; {</strong>
<strong class="bold">    await this.nameField().fill(name);</strong>
<strong class="bold">    await this.dateOfBirthField().fill(dob);</strong>
<strong class="bold">    await this.saveButton().click();</strong>
};</pre></li>
<li>The section of code in <em class="italic">step 4</em> from the original test, which was eight lines of code including the explanatory comment, can now be done in a single function call. The comment is no longer necessary because the method name basically says the same thing. Go ahead and update the test now, as shown here:<pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  const birthdayListPage = new BirthdayListPage(page);
  await birthdayListPage.goto();
<strong class="bold">  await birthdayListPage.saveNameAndDateOfBirth(</strong>
<strong class="bold">    'Ares',</strong>
<strong class="bold">    '1985-01-01'</strong>
<strong class="bold">  );</strong>
  ...
);</pre></li>
</ol>
<p>That completes this section<a id="_idIndexMarker229"/> of the test. Now for the next bit, which looks<a id="_idIndexMarker230"/> like this:</p>
<pre class="source-code">
// find the Edit button for that person
await page
  .getByRole('listitem')
  .filter({ hasText: 'Ares' })
  .getByRole('button', { name: 'Edit' })
  .click();</pre>
<p>For this section, we can repeat the earlier steps to extract an internal helper to locate the desired field, and then extract a second external helper to perform the action. Start by adding a new helper in the <code>BirthdayListPage</code> page object model, named <code>entryFor</code>, that finds the entry for a person’s name:</p>
<pre class="source-code">
entryFor = (name) =&gt;
  this.page
    .getByRole('listitem')
    .filter({ hasText: name });</pre>
<ol>
<li value="7">Now, use the <code>entryFor</code> method to build another helper, <code>beginEditingFor</code>, which clicks the <strong class="bold">Edit</strong> button for that birthday:<pre class="source-code">
beginEditingFor = (name) =&gt;
  this.entryFor(name)
    .getByRole('button', { name: 'Edit' })
    .click();</pre></li>
<li>It’s time to remove the original code<a id="_idIndexMarker231"/> shown in <em class="italic">step 6</em> with a single call to this new helper <a id="_idIndexMarker232"/>in the page object model. Make the updates shown in the following code block, again getting rid of the comment and reducing six lines down to one:<pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  const birthdayListPage = new BirthdayListPage(page);
  await birthdayListPage.goto();
  await birthdayListPage.saveNameAndDateOfBirth(
    'Ares',
    '1985-01-01'
  );
<strong class="bold">  await birthdayListPage.beginEditingFor('Ares');</strong>
  ...
});</pre></li>
<li>There’s one final action within the test that can be updated, which is the action to modify the form values after beginning editing. We don’t need to create any new helpers for this action. We simply need to reuse the <code>saveNameAndDateOfBirth</code> helper. Go ahead and do that now, like this:<pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  ...
  await birthdayListPage.beginEditingFor('Ares');
<strong class="bold">  await birthdayListPage.saveNameAndDateOfBirth(</strong>
<strong class="bold">    'Ares',</strong>
<strong class="bold">    '1995-01-01'</strong>
<strong class="bold">  );</strong>
  ...
});</pre></li>
<li>The last change to make is a change to the expectations. They can be updated to use the <code>entryFor</code> helper. Since this is the last change in this section, the listing shows the fully complete test. Make the changes to the expectations as shown here:<pre class="source-code">
test('edits a birthday', async ({ page }) =&gt; {
  const birthdayListPage = new BirthdayListPage(page);
  await birthdayListPage.goto();
  await birthdayListPage.saveNameAndDateOfBirth(
    'Ares',
    '1985-01-01'
  );
  await birthdayListPage.beginEditingFor('Ares');
  await birthdayListPage.saveNameAndDateOfBirth(
    'Ares',
    '1995-01-01'
  );
  await expect(
    <strong class="bold">birthdayListPage.entryFor('Ares')</strong>
  ).not.toContainText('1985-01-01');
  await expect(
    <strong class="bold">birthdayListPage.entryFor('Ares')</strong>
  ).toContainText('1995-01-01');
});</pre></li>
</ol>
<p>The benefits of introducing the <code>BirthdayListPage</code> page object model are clear: the test is more readable, the test data is more prominent (the two changing date of births are now more visible), and any future changes<a id="_idIndexMarker233"/> will be quicker to make, simply because<a id="_idIndexMarker234"/> the test is shorter.</p>
<p class="callout-heading">Continuing with the remaining tests</p>
<p class="callout">The other Playwright tests in the repository can also be rewritten using the exact same helpers. These changes aren’t shown in this book but are available in the companion repository.</p>
<p>In this section, you saw how to create a Playwright page object model. Next, we’ll do something similar with the Vitest unit tests.</p>
<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Extracting an action helper</h1>
<p>This section covers<a id="_idIndexMarker235"/> the use of a helper to simplify the <em class="italic">Act</em> phase of a test.</p>
<p class="callout-heading">Understanding the Arrange-Act-Assert pattern</p>
<p class="callout">The <em class="italic">Arrange-Act-Assert</em> pattern is a standard way to describe<a id="_idIndexMarker236"/> the order in which unit tests are written.</p>
<p class="callout">They start with the <em class="italic">Arrange</em> phase, which is when the structure under test is primed for work. Any input data is constructed, and any preparatory methods are called that get the system into the right state.</p>
<p class="callout">Then, we have the <em class="italic">Act</em> phase, which invokes the operation that is being checked. Finally, the test ends with the <em class="italic">Assert</em> phase, which can be one or more expectations (or <em class="italic">assertions</em>) that verify that the operation did what it was meant to.</p>
<p class="callout">Each of these three phases benefits from different strategies to remove duplication.</p>
<p>The <em class="italic">Act</em> phase is the one that I think benefits least from the removal of duplication. That’s because the majority of unit tests you’ll write – and all the unit tests in this book – have an action that is triggered by a single method call. It’s rare to find a scenario where the action that is being observed requires anything more than a single instruction.</p>
<p>And because of this, I like to ensure the method call is called directly within the unit tests, and not mixed up with any of the <em class="italic">Arrange</em> phase statements. That being said, there are some occasions when it helps to build an <em class="italic">Act</em> helper. The call to invoke a SvelteKit form action via the <code>actions.default</code> import, is one of these occasions.</p>
<p>There are a couple<a id="_idIndexMarker237"/> of reasons why. First, the name <code>actions.default</code> is non-descriptive in the context of a unit test suite. Second, the form action’s parameter is not trivial – it uses the Form API’s <code>request</code> object to wrap the form data, which is then packaged into a SvelteKit <code>RequestEvent</code>-like object. This needs to be done in every single test. What we care about are the values within the form data, not the plumbing around it.</p>
<p>In the <code>src/routes/birthdays/page.server.test.js</code> file, you’ll see the following pattern repeated many times:</p>
<pre class="source-code">
const request = createFormDataRequest({
 // ... the form data object ...
});
await actions.default({ request });</pre>
<p>You can consider the request statement part of the setup. It is required every single time the form action is called. There is no way to call the form action without doing the form data dance.</p>
<p>So, let’s create a helper<a id="_idIndexMarker238"/> that wraps this behavior. We’ll call it <code>performFormAction</code>, which makes it clear what’s happening in the test.</p>
<p>Let’s begin:</p>
<ol>
<li>In <code>src/routes/birthdays/page.server.test.js</code>, add the following function definition to the top of the <code>/birthdays - default </code><code>action</code> context:<pre class="source-code">
const performFormAction = (formData) =&gt;
  actions.default({
    request: createFormDataRequest(formData)
  });</pre></li>
<li>In each test, look for the pattern described in the preceding code snippet – calling <code>createFormDataRequest</code> and then the imported <code>actions.default</code> function – and replace each instance with a call to <code>performFormAction</code>. The following is an example from one of the tests:<pre class="source-code">
it('adds a new birthday into the list', async () =&gt; {
<strong class="bold">  await performFormAction({</strong>
    name: 'Zeus',
    dob: '2009-02-02'
<strong class="bold">  });</strong>
  expect(birthdayStore.getAll()).toContainEqual(
    expect.objectContaining({
      name: 'Zeus',
      dob: '2009-02-02'
    });
  });
});</pre></li>
</ol>
<p>Make sure you rerun<a id="_idIndexMarker239"/> all your tests once you’ve made that change in all of them in the test suite. In the next section, we’ll continue with a look at simplifying the <em class="italic">Arrange</em> section of the test suite.</p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor098"/>Extracting a factory method for creating data objects</h1>
<p>It’s time to simplify the <em class="italic">Arrange</em> phase of the tests<a id="_idIndexMarker240"/> using a factory<a id="_idIndexMarker241"/> method named <code>createBirthday</code>.</p>
<p>The last section mentioned how each of the <em class="italic">Arrange-Act-Assert</em> phases needs a different treatment for simplification. A key method for the <em class="italic">Arrange</em> phase is the use of factories. You already created one of those in <a href="B19611_04.xhtml#_idTextAnchor060"><em class="italic">Chapter 4</em></a>, <em class="italic">Saving Form Data</em>. That was the <code>createFormDataRequest</code> method that you used in the preceding section.</p>
<p class="callout-heading">Using test factories to hide irrelevant data</p>
<p class="callout">Factory methods help you generate supporting<a id="_idIndexMarker242"/> objects in the shortest amount of code possible. One way they do that is by setting default values for object properties so that you don’t need to specify them. You’re then free to override those defaults in each individual test.</p>
<p class="callout">Hiding necessary but irrelevant data is a key method for keeping unit tests succinct and clear.</p>
<p>Our birthday objects have a very simple structure, with just three fields – <code>name</code>, <code>dob</code>, and <code>id</code>. Of these three, <code>name</code> and <code>dob</code> are set frequently and the <code>id</code> field infrequently. Also, each of the individual fields has a unique shape of data – a name looks<a id="_idIndexMarker243"/> very different from a date, and very different from a <strong class="bold">universally unique </strong><strong class="bold">identifier</strong> (<strong class="bold">UUID</strong>).</p>
<p>With that in mind, the upcoming <code>createBirthday</code> helper requires both <code>name</code> and <code>dob</code> but leaves <code>id</code> as an extra field that can sometimes be specified. Those <code>name</code> and <code>dob</code> values are given as positional parameters – meaning they are identified by position and not by name – because it’s obvious which is which. That saves space on the page.</p>
<p>It might not seem important, but when you are writing software for maintainability, every single word must prove its worth.</p>
<p>Here’s an example<a id="_idIndexMarker244"/> of how this looks. Note how <code>id</code> is specified <a id="_idIndexMarker245"/>differently, due to being rarely used:</p>
<pre class="source-code">
createBirthday('Zeus Ex', '2007-02-02', { id: storedId() })</pre>
<p>Let’s begin:</p>
<ol>
<li>Create a new file named <code>src/factories/birthday.js</code> and give it the following content:<pre class="source-code">
export const createBirthday = (
  name,
  dob,
  extra = {}
) =&gt; ({ name, dob, ...extra });</pre></li>
<li>Open the <code>src/routes/birthdays/Birthday.test.js</code> file and import the new helper:<pre class="source-code">
import {
  createBirthday
} from src/factories/birthday.js';</pre></li>
<li>Next, find all the <code>render</code> calls that use the <code>exampleBirthday</code> object. They look like this:<pre class="source-code">
render(Birthday, {
  ...exampleBirthday,
  name: 'Hercules'
});</pre></li>
</ol>
<p>Update them to use the new helper, like this:</p>
<pre class="source-code">
render(
  Birthday,
  <strong class="bold">createBirthday('Hercules', '1996-03-03')</strong>
);</pre>
<ol>
<li value="4">Then, in <code>src/routes/birthdays/page.server.test.js</code>, add the <code>createBirthday</code> import:<pre class="source-code">
import {
  createBirthday
} from 'src/factories/birthday.js';</pre></li>
<li>Find all the calls to <code>performFormAction</code> that you updated<a id="_idIndexMarker246"/> in the previous<a id="_idIndexMarker247"/> section. They’ll look something like this:<pre class="source-code">
await performFormAction({
  name: 'Zeus',
  dob: '2009-02-02'
});</pre></li>
</ol>
<p>Update them to use the <code>createBirthday</code> helper, shown here:</p>
<pre class="source-code">
await performFormAction(
  <strong class="bold">createBirthday('Zeus', '2009-02-02')</strong>
);</pre>
<p>There are a couple of tests where the preceding change isn’t straightforward. In the <em class="italic">saves unique ids one each new birthday </em>test, you can save the created birthday in the <code>request</code> object, and then pass that into <code>performFormAction</code> twice, as shown in the following code:</p>
<pre class="source-code">
it('saves unique ids onto each new birthday', async () =&gt; {
  const request = createBirthday(
    'Zeus',
    '2009-02-02'
  );
  await performFormAction(request);
  await performFormAction(request);
  expect(birthdayStore.getAll()[0].id).not.toEqual(
    birthdayStore.getAll()[1].id
  );
});</pre>
<p>The <em class="italic">updates an entrythat shares the same id</em> test<a id="_idIndexMarker248"/> needs a specific <code>id</code> passed<a id="_idIndexMarker249"/> into the second invocation. Note how the factory method is structured in such a way that uncommon information needs to be named, such as the <code>id</code> field:</p>
<pre class="source-code">
it('updates an entry that shares the same id', async () =&gt; {
  await performFormAction(
    <strong class="bold">createBirthday('Zeus', '2009-02-02')</strong>
  );
  await performFormAction(
    <strong class="bold">createBirthday('Zeus Ex', '2007-02-02', { id:</strong>
<strong class="bold">      storedId() })</strong>
  );
  expect(birthdayStore.getAll()).toHaveLength(1);
  expect(birthdayStore.getAll()).toContainEqual({
    id,
    name: 'Zeus Ex',
    dob: '2007-02-02'
  });
});</pre>
<ol>
<li value="6">For the final test<a id="_idIndexMarker250"/> suite, in <code>src/routes/birthdays/page.test.js</code>, the <code>birthdays</code> array can be updated<a id="_idIndexMarker251"/> to use two calls to <code>createBirthday</code>, as shown here:<pre class="source-code">
const birthdays = [
<strong class="bold">  createBirthday('Hercules', '1994-02-02', {</strong>
<strong class="bold">    id: '123'</strong>
<strong class="bold">  })</strong>,
<strong class="bold">  createBirthday('Athena', '1989-01-01', {</strong>
<strong class="bold">    id: '234'</strong>
<strong class="bold">  })</strong>
];</pre></li>
<li>Finally, update the test shown here so that it uses the <code>createBirthday</code> helper directly in the <code>render</code> call for both the <code>birthdays</code> prop value and the <code>form</code> prop value:<pre class="source-code">
it('displays all the birthdays passed to it', () =&gt; {
  render(Page, {
    data: {
      birthdays: [
        <strong class="bold">createBirthday('Hercules', '1994-02-02', {</strong>
        <strong class="bold">id: '123'</strong>
        <strong class="bold">})</strong>
      ]
    },
    form: {
      <strong class="bold">...createBirthday('Hercules', 'bad dob', {</strong>
        <strong class="bold">id: '123'</strong>
        <strong class="bold">}),</strong>
      error: 'An error'
    }
  });
});</pre></li>
</ol>
<p>That completes the use of <code>createBirthday</code>. Make sure to rerun<a id="_idIndexMarker252"/> your tests to ensure<a id="_idIndexMarker253"/> that everything is still green.</p>
<p>You’ve now learned how a test factory method can be used to simplify and bring clarity to your unit tests.</p>
<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Summary</h1>
<p>This chapter has shown you three techniques to shorten your test suites: page object models for Playwright end-to-end tests, action helpers for Vitest unit tests, and factory methods. Keeping test suites clear and meaningful is key to keeping them easily maintainable.</p>
<p>In this next chapter, we’ll look at a more involved way of reducing unit test code – writing your own custom matchers.</p>
</div>
</div></body></html>