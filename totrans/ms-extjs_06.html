<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. User Management</h1></div></div></div><p>In the previous chapters, we developed mechanisms to provide login and logout capabilities and client-side session monitoring, and we also implemented a dynamic menu based on the user permissions. However, all the users, groups, and permissions were added manually to the database until now. We cannot do this every time we need to grant access to the application to a new user or change the user permissions. For this reason, we will implement a screen where we can create new users and grant or change the permissions. So in this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Listing all the users from the system</li><li class="listitem" style="list-style-type: disc">Creating, editing and deleting users</li><li class="listitem" style="list-style-type: disc">Picture preview of a file upload (user's picture)</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec30"/>Managing users</h1></div></div></div><p>So the first <a id="id484" class="indexterm"/>module we are going to develop is user management. In this module, we will be able to see all the users that are registered on the system, add new users, edit, and delete current users.</p><p>When the user clicks on the <strong>Users</strong> menu option, a new tab will open with the list of all users from the system as shown in the following screenshot:</p><div><img src="img/0457OT_06_01.jpg" alt="Managing users"/></div><p>When the user clicks <a id="id485" class="indexterm"/>on the <strong>Add</strong> or <strong>Edit</strong> button, the system will display a window so that the user can create a new user or edit a current user (based on the record selected on the GridPanel). The <strong>Edit</strong> window will look like the following screenshot:</p><div><img src="img/0457OT_06_02.jpg" alt="Managing users"/></div><p>Some capabilities of creating or editing a user: we can edit the <strong>User Information</strong> such as <strong>Name</strong>, <strong>Username</strong>, and <a id="id486" class="indexterm"/>so on and we can also upload a <strong>Photo</strong> representing the user. But there is an extra feature; using the HTML5 API, we are going to display a preview of the <strong>Photo</strong> right after the user selects the picture from the computer and before the user uploads to the server.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec60"/>Listing all the users using a simple GridPanel</h2></div></div></div><p>We need to implement a<a id="id487" class="indexterm"/> screen similar to the first screenshot present in this chapter. It is a simple GridPanel. So to implement a<a id="id488" class="indexterm"/> simple GridPanel<strong>,</strong> we need the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A Model to represent the information that is stored on the <code class="literal">user</code> table</li><li class="listitem" style="list-style-type: disc">A Store to load the information and a Proxy to tell Ext JS to read the information from the server</li><li class="listitem" style="list-style-type: disc">A GridPanel component representing the View</li><li class="listitem" style="list-style-type: disc">A ViewController to listen to the events, as we are going to develop this module using MVVM</li></ul></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec27"/>Creating a User Model</h3></div></div></div><p>So the<a id="id489" class="indexterm"/> first step is to create a Model <a id="id490" class="indexterm"/>to represent the <code class="literal">user</code> table. We are going to create a new file named <code class="literal">User.js</code> under the <code class="literal">app/model/security</code> directory. This Model is going to represent all the fields from the <code class="literal">user</code> table, except the <code class="literal">password</code> field, because as the password is something very personal to the user, we cannot display the user's password to any other user, including the administrator. So the User Model is going to look like the following:</p><div><pre class="programlisting">Ext.define('Packt.model.security.User', {
    extend: 'Packt.model.security.Base', //#1
 
 fields: [
        { name: 'name' },
        { name: 'userName' },
        { name: 'email' },
        { name: 'picture' },
        { name: 'groups_id' , type: 'int'}
});</pre></div><p>And as we mentioned before, all the fields from the <code class="literal">user</code> table are mapped into this Model, except the <code class="literal">password</code> field.</p><p>In line <code class="literal">#1</code> we are not extending the default <code class="literal">Ext.data.Model</code> class. We are extending a class that we <a id="id491" class="indexterm"/>created. Let's see its <a id="id492" class="indexterm"/>declaration next.</p><div><div><div><div><h4 class="title"><a id="ch06lvl4sec10"/>Working with schemas</h4></div></div></div><p>When<a id="id493" class="indexterm"/> we designed the database tables, we also added a foreign key to the <code class="literal">user</code> table. This means the <code class="literal">user</code> table has a relationship with the <code class="literal">groups</code> table. Ext JS 5 introduced the concept of schemas. A schema (<code class="literal">Ext.data.schema.Schema</code>) is a collection of related entities and their respective associations. We know that the <code class="literal">User</code> and <code class="literal">Group</code> Model classes are related entities, so we can create a schema to represent them.</p><p>So let's see what's inside the <code class="literal">Packt.model.security.Base</code> class:</p><div><pre class="programlisting">Ext.define('Packt.model.security.Base', {
    extend: 'Ext.data.Model',

    requires: [
        'Packt.util.Util'
    ],

    idProperty: 'id',

    fields: [
        { name: 'id', type: 'int' } //#1
    ],

    schema: {
        namespace: 'Packt.model.security', //#2
        urlPrefix: 'php',                  //#3
        proxy: {
            //proxy code here
        }
    }
});</pre></div><p>The <code class="literal">security.Base</code> model will work as a super Model that the <code class="literal">User</code> and <code class="literal">Group</code> (which will be defined later in this chapter in the section <em>Declaring the User ViewModel</em>) classes and contains the common code for both models.</p><p>The first thing the <code class="literal">User</code> and <code class="literal">Group</code> Model classes have in common is the <code class="literal">id</code> field (<code class="literal">#1</code>). So to reuse this field in both classes, we can declare it here.</p><p>Next, <code class="literal">config</code> is the <code class="literal">schema</code>. Inside the <code class="literal">schema</code>, we can configure some options. The first one is <code class="literal">namespace</code> (<code class="literal">#2</code>). In some cases, we want to use a short name for the Model entities. We will use the short name of the <code class="literal">User</code> and <code class="literal">Group</code> classes when declaring associations and in the <a id="id494" class="indexterm"/>
<strong>ViewController</strong> later. The short name is also known in Ext JS as <code class="literal">entityName</code> of the Model (we can declare this <code class="literal">config</code> in the Model as well). By default, <code class="literal">entityName</code> is the full class name, but this is exactly what we are trying to avoid. However, if <code class="literal">namespace</code> is used (in a <code class="literal">schema</code> declaration), the common portion can be discarded, and we can derive a shorter name. For example, the full name of the <code class="literal">User</code> class is <code class="literal">Packt.model.security.User</code>, and its schema namespace is <code class="literal">Packt.model.security</code>, so <code class="literal">entityName</code> will result in <code class="literal">User</code>. Using only <code class="literal">User</code> instead of <code class="literal">Packt.model.security.User</code> is much better.</p><p>We also have<a id="id495" class="indexterm"/> the <code class="literal">urlPrefix</code> (<code class="literal">#3</code>), which is the URL prefix used for all requests to the server. We are going to use this information when configuring <code class="literal">proxy</code> (in <a class="link" href="ch05.html" title="Chapter 5. Advanced Dynamic Menu">Chapter 5</a>, <em>Advanced Dynamic Menu</em>, we used <code class="literal">proxy</code> inside the Store; now we are going to use it inside the Model).</p><p>Next, we are going to configure <code class="literal">proxy</code> as follows. As we are using <code class="literal">proxy</code> inside the <code class="literal">schema</code> declaration, the configuration will be available for all classes extending the <code class="literal">Packt.model.security.Base</code> class:</p><div><pre class="programlisting">type: 'ajax',
api :{
    read : '{prefix}/{entityName:lowercase}/list.php', //#4
    create: '{prefix}/{entityName:lowercase}/create.php',
    update: '{prefix}/{entityName:lowercase}/update.php',
    destroy: '{prefix}/{entityName:lowercase}/destroy.php'
},
reader: {
    type: 'json',
    rootProperty: 'data'
},
writer: { //#5
    type: 'json',
    writeAllFields: true,
    encode: true,
    rootProperty: 'data',
    allowSingle: false
},
listeners: { //#6
    exception: function(proxy, response, operation){
        Packt.util.Util.showErrorMsg(response.responseText);
    }
}</pre></div><p>When we want to specify a different <code class="literal">url</code> for each of the CRUD operations, instead of using the <code class="literal">url</code> config we use the <code class="literal">api</code> config. Inside the <code class="literal">api</code> config, we define a <code class="literal">url</code> config for each CRUD action. When using schemas, we can use a template in the <code class="literal">proxy</code> to configure the URLs. For example, we use <code class="literal">prefix</code>, which refers to <code class="literal">urlPrefix</code> that we configured before. The <code class="literal">entityName</code> attribute refers to the Model <code class="literal">entityName</code> (and in this example, we also ask to transform the <code class="literal">entityName</code> to lowercase). In line <code class="literal">#4</code>, for the <code class="literal">User</code> Model class, the read <code class="literal">url</code> will be <code class="literal">php/user/list.php</code>. This is very useful when we want to follow a pattern and share (reuse) the <code class="literal">schema</code> configuration between different models.</p><p>We learned how<a id="id496" class="indexterm"/> to configure <code class="literal">reader</code> already. We can also specify <code class="literal">writer</code> (<code class="literal">#5</code>) when we want to send information to the server (create, update, or delete records). In this case, we are telling Ext JS we want to send a JSON back to the server. The <code class="literal">writeAllFields</code> configuration specifies whether we want the Model (and all its fields) to be sent to the server or only the fields that were modified (plus the <code class="literal">id</code> field). To make our life easier on the server-side code, we set <code class="literal">writeAllFields</code> as true. Just as with <code class="literal">reader</code>, we are also going to configure <code class="literal">rootProperty</code> to be a wrapper of the records. Then, we have the <code class="literal">encode</code> configuration set to <code class="literal">true</code> to send record data (all record fields if <code class="literal">writeAllFields</code> is <code class="literal">true</code>) as a JSON-encoded HTTP parameter named by the <code class="literal">rootProperty</code> configuration. The encode option should only be set to <code class="literal">true</code> when <code class="literal">rootProperty</code> is defined, because the values will be sent as part of the request parameters as opposed to a raw post. And at last, we have <code class="literal">allowSingle</code> set to <code class="literal">false</code>. This will force <code class="literal">proxy</code> to get all the modified records (to be created, updated, or deleted) and send them in an array (wrapped by <code class="literal">rootProperty</code> if configured). This will make <code class="literal">proxy</code> send only one request to the server (one request for creating, updating, or deleting records) instead of one request for each modification.</p><p>At last, we have the proxy <code class="literal">exception</code> <code class="literal">listener</code> (<code class="literal">#6</code>), which we are already familiar with from previous chapters.</p></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec28"/>Defining store-less grids with Users GridPanel</h3></div></div></div><p>The <a id="id497" class="indexterm"/>next step is to create the views we are going to use to manage the users of our application. But before we get our hands on the code, we need to keep one thing in mind; when we<a id="id498" class="indexterm"/> implement the <strong>Manage Groups</strong> module and on the <strong>Edit Group</strong> screen, we want to display all the users that belong to that group. And for that, we will need to use a <strong>Users</strong> grid as well. So that being said, we need to create a component that will list the users (in this case all the users from the application) that we can reuse later. For this reason, the component that we are going to create will only contain the list of users and will not contain the <strong>Add</strong>/<strong>Edit</strong>/<strong>Delete</strong> buttons. We will add a toolbar with these buttons and also wrap the <strong>Users</strong> grid in another component.</p><p>So we are going to create a GridPanel. To do so, let's create a new class named <code class="literal">Packt.view.security.UsersGrid</code>. To create this class, we will create a new file named <code class="literal">UsersGrid.js</code> under the <code class="literal">app/view/security</code> directory:</p><div><pre class="programlisting">Ext.define('Packt.view.security.UsersGrid', {
    extend: 'Ext.grid.Panel',
    alias: 'widget.users-grid',  //#1

    reference: 'usersGrid', //#2

    columns: [  //#3
        {
            width: 150,
            dataIndex: 'userName',  //#4
            text: 'Username'
        },
        {
            width: 200,
            dataIndex: 'name',
            flex: 1,             //#5
            text: 'Name'
        },
        {
            width: 250,
            dataIndex: 'email',
            text: 'Email'
        },
        {
            width: 150,
            dataIndex: 'groups_id', //#6
            text: 'Group'
        }
    ]
});</pre></div><p>As usual, we<a id="id499" class="indexterm"/> are going to start with <code class="literal">xtype</code>. An alternative to <code class="literal">xtype</code> is using the <code class="literal">alias</code> (<code class="literal">#1</code>). When using <code class="literal">xtype</code>, we <a id="id500" class="indexterm"/>can declare it directly (for example <code class="literal">xtype: 'user-grid'</code>). When using <code class="literal">alias</code>, we need to specify what type of alias we are creating. For components we use "<code class="literal">widget.</code>" and for plugins, we use "<code class="literal">plugin.</code>", followed by the <code class="literal">xtype</code>.</p><p>Let's go ahead and also create <code class="literal">reference</code> so that we can refer to this component later in the ViewModel (<code class="literal">#2</code>).</p><p>Whenever we declare a grid, there are two mandatory configurations we need to specify. The first one is the <code class="literal">columns</code> (<code class="literal">#3</code>) configuration, and the second one is the <code class="literal">store</code> configuration.</p><p>The <code class="literal">columns</code> (<code class="literal">#3</code>) configuration is an array of column definition objects that define all columns that appear in the grid. Each column definition provides the header <code class="literal">text</code> (<code class="literal">text</code> configuration) for the column, and a definition of where the data for that column comes from ((<code class="literal">dataIndex</code>) <code class="literal">#4</code>).</p><p>As a Grid<a id="id501" class="indexterm"/> is going to display a collection of data represented by a Model, each column needs to have the <code class="literal">dataIndex</code> (<code class="literal">#4</code>) configured matching the Model field that it represents.</p><p>We can define a <code class="literal">width</code> for<a id="id502" class="indexterm"/> each column. But we do not know the monitor resolution the user will be using, and we might end up with some extra space. We can choose a column to use all the available space by specifying the <code class="literal">flex</code> configuration (<code class="literal">#5</code>).</p><p>At last, on line <code class="literal">#6</code>, we have a column with <code class="literal">dataIndex</code> <code class="literal">groups_id</code> (<code class="literal">#6</code>), which will render the <code class="literal">groups_id</code> foreign key from the <code class="literal">groups</code> table. When we display associated data in a grid, we do not want to display the foreign key, but the description or name of the information. For now, we will leave the <code class="literal">groups_id</code> configured, but we will come back here and change this.</p><p>The <code class="literal">store</code> configuration is also required when declaring a Grid. But this configuration is missing in this class. Ext JS 5 introduced the ViewModel, and because of this new architecture and the data-binding concept, we can declare a store-less Grid and configure this later.</p><div><div><div><div><h4 class="title"><a id="ch06lvl4sec11"/>The Users screen</h4></div></div></div><p>Now<a id="id503" class="indexterm"/> that we have the <strong>Users</strong> GridPanel ready, we still need to create another component that is going to wrap the <strong>User</strong> GridPanel and will also contain the toolbar with the <strong>Add</strong>/<strong>Edit</strong>/<strong>Delete</strong> buttons. The simplest component that supports Docked Items is the panel.</p><p>We are going to create a new class named <code class="literal">Packt.view.security.User</code> that is going to extend from the <code class="literal">Ext.panel.Panel</code> class. To do so, we need to create a new file named <code class="literal">User.js</code> under the <code class="literal">app/view/security</code> directory, as follows:</p><div><pre class="programlisting">Ext.define('Packt.view.security.User', {
    extend: 'Ext.panel.Panel',
    xtype: 'user',

    requires: [
        'Packt.view.security.UsersGrid' //#1
    ],

    controller: 'user', //#2
    viewModel: {        //#3
        type: 'user'
    },

    frame: true,        //#4

    layout: {           //#5
        type: 'vbox',
        align: 'stretch'
    },

    items: [
        {
            xtype: 'users-grid', //#6
            flex: 1              //#7
        }
    ]
});</pre></div><p>In this class, we<a id="id504" class="indexterm"/> will have only one component being rendered in the panel's body for now. It is the <code class="literal">users-grid</code> (<code class="literal">#6</code>). And as we are using its <code class="literal">xtype</code> to instantiate it, we need to make sure the <code class="literal">UsersGrid </code>class is already loaded, and that is why we need to add the class in the <code class="literal">requires</code> declaration (<code class="literal">#1</code>).</p><p>Later, we are going to create a window (popup) with a form that is going to allow us to create or edit a user. Because of some ViewModel concepts and limitations, we will add the window as an item of this class. For this reason, we are not going to use the Fit Layout (renders a single child), but we are going to use the <code class="literal">VBox</code> layout (<code class="literal">#5</code>).</p><p>The <code class="literal">VBox</code> layout aligns the child items vertically. It divides the available vertical space between the child items using the <code class="literal">flex</code> configuration (<code class="literal">#7</code>). In this example, the window will be displayed as a popup, so the Grid will continue being the only child component.</p><p>When using the <code class="literal">VBox</code> layout, we can also define the alignment of the items. We are going to use <code class="literal">align: 'stretch'</code>. According to Ext JS documentation, the possible options are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">begin</code>: Child<a id="id505" class="indexterm"/> items are aligned vertically at the top of the container</li><li class="listitem" style="list-style-type: disc"><code class="literal">middle</code>: Child<a id="id506" class="indexterm"/> items are vertically centered in the container</li><li class="listitem" style="list-style-type: disc"><code class="literal">end</code>: Child<a id="id507" class="indexterm"/> items are aligned vertically at the bottom of the container</li><li class="listitem" style="list-style-type: disc"><code class="literal">stretch</code>: Child <a id="id508" class="indexterm"/>items are stretched vertically to fill the height of the container</li><li class="listitem" style="list-style-type: disc"><code class="literal">stretchmax</code>: Child <a id="id509" class="indexterm"/>items are stretched vertically to the height of the largest item</li></ul></div><p>To add a border<a id="id510" class="indexterm"/> around the screen, we are going to set <code class="literal">frame:true</code> (<code class="literal">#4</code>). We are also specifying a <code class="literal">controller</code> (<code class="literal">#2</code>) and a <code class="literal">ViewModel</code> (<code class="literal">#3</code>) for this <code class="literal">View</code> that we are going to create later in this chapter.</p><div><div><h3 class="title"><a id="tip27"/>Tip</h3><p>There is also the <code class="literal">border</code> configuration that we can set for any panel subclass. The <code class="literal">border</code> configuration when specified as <code class="literal">false</code> (default value) renders the panel with zero width borders. The <code class="literal">frame</code> configuration when specified as <code class="literal">true</code> applies a frame to the panel.</p></div></div><div><div><div><div><h5 class="title"><a id="ch06lvl5sec01"/>Working with docked items</h5></div></div></div><p>The next <a id="id511" class="indexterm"/>step is to add the toolbar with the <strong>Add</strong>, <strong>Edit</strong>, and <strong>Delete</strong> buttons, so we are going to <code class="literal">dock</code> this toolbar on the <code class="literal">top</code>, and we are going to declare it inside the <code class="literal">dockedItems</code> declaration of the <code class="literal">Packt.view.security.User</code> class:</p><div><pre class="programlisting">dockedItems: [
    {
        xtype: 'toolbar',
        dock: 'top', //#1
        items: [
            {
                xtype: 'button',
                text: 'Add',
                glyph: Packt.util.Glyphs.getIcon('add'), //#2
                listeners: {
                    click: 'onAdd' //#3
                }
            },
            {
                xtype: 'button',
                text: 'Edit',
                glyph: Packt.util.Glyphs.getIcon('edit'),
                listeners: {
                    click: 'onEdit'
                }
            },
            {
                xtype: 'button',
                text: 'Delete',
                glyph: Packt.util.Glyphs.getIcon('destroy'),
                listeners: {
                    click: 'onDelete'
                }
            }
        ]
    }
]</pre></div><p>Inside the <code class="literal">dockedItems</code> configuration, we<a id="id512" class="indexterm"/> can add a component or a collection of components to be added as docked items to the panel or any of its subclasses. The docked items can be docked to either the <code class="literal">top</code>, <code class="literal">right</code>, <code class="literal">left</code>, or <code class="literal">bottom</code> of a panel. We can have as many as needed, and it is usually used to declare toolbar inside a panel (or any of its subclasses).</p><p>In this example, we are adding a toolbar at the <code class="literal">top</code> (<code class="literal">#1</code>) of the panel. The toolbar has three buttons. For each button, we are going to configure an icon with the help of a <code class="literal">glyph</code> (<code class="literal">#2</code>) and also the event listener we are going to create inside the ViewController (<code class="literal">#3</code>).</p><p>If we take another look at line <code class="literal">#2</code>, we can see that we have not implemented the <code class="literal">Packt.util.Glyphs</code> class yet. Let's work on it before we dive into the ViewModel and ViewController code.</p></div></div><div><div><div><div><h4 class="title"><a id="ch06lvl4sec12"/>Working with singletons – Ext JS class system</h4></div></div></div><p>Let's enjoy the<a id="id513" class="indexterm"/> opportunity to create a new utility class for our project and dive into some class system concepts of Ext JS.</p><p>We already <a id="id514" class="indexterm"/>know we can use the Font Awesome CSS in the <code class="literal">iconCls</code> configuration of a button (or any other component that supports it), and we also learned we can use the <code class="literal">glyph</code> configuration as an alternative. The con of using <code class="literal">glyph</code> is declaring code as value (<code class="literal">xf067</code>), and if we decide to read this code in the future or another developer decides to maintain it, it is not very helpful; after all, what does <code class="literal">'xf067'</code> mean?</p><p>We can take advantage of the Ext JS class system—most specifically the <code class="literal">singleton</code> classes—to create a utility class that will take care of this for us. Let's take a look at the code of the <code class="literal">Packt.util.Glyphs</code> class:</p><div><pre class="programlisting">Ext.define('Packt.util.Glyphs', {
    singleton: true, //#1

    config: { //#2
        webFont: 'FontAwesome',
        add: 'xf067',
        edit: 'xf040',
        destroy: 'xf1f8',
        save: 'xf00c',
        cancel: 'xf0e2'
    },

    constructor: function(config) { //#3
        this.initConfig(config);
    },

    getGlyph : function(glyph) { //#4
        var me = this,
            font = me.getWebFont(); //#5
        if (typeof me.config[glyph] === 'undefined') {
            return false;
        }
        return me.config[glyph] + '@' + font;
    }
});</pre></div><p>The idea is to<a id="id515" class="indexterm"/> declare the glyph code inside configurations of the class (<code class="literal">#2</code>) and use them as a key to retrieve a <code class="literal">glyph</code> code. <code class="literal">Packt.util.Glyphs.getIcon('add')</code> is easier to understand than <code class="literal">'xf067'</code>. We can reuse it throughout the application, and if we want to change the code for the <strong>Add</strong> button, we can change the <code class="literal">Glyphs</code> class, and the code is changed for the entire application.</p><p>Let's understand the previous code. We started declaring a class, but in line <code class="literal">#1</code>, we have <code class="literal">singleton:true</code>. This means the class will be instantiated as a singleton, which means only one instance of this class can be created.</p><div><div><h3 class="title"><a id="note55"/>Note</h3><p>To learn more about singletons, please visit <a class="ulink" href="http://en.wikipedia.org/wiki/Singleton_pattern">http://en.wikipedia.org/wiki/Singleton_pattern</a>.</p></div></div><p>Next, we have the <code class="literal">config</code> of the class (<code class="literal">#2</code>). Inside <code class="literal">config</code>, we can declare the attributes of the class. For each attribute, Ext JS is going to generate a getter method and a setter method. For example, the <code class="literal">webFont</code> attribute can be retrieved as <code class="literal">this.getWebFont()</code> as showed in line <code class="literal">#5</code>.</p><p>The method <code class="literal">getGlyph</code> (<code class="literal">#4</code>) will be the responsible for returning a string with the <code class="literal">glyph</code> code + <code class="literal">'@'</code> + name of the font. If the <code class="literal">glyphFontFamily</code> is set, we do not need to specify the font.</p><p>In line <code class="literal">#3</code>, we have <code class="literal">constructor</code>. A class constructor is the class method that gets invoked immediately when a new instance of that class is created. Inside the constructor, we call the <code class="literal">initConfig</code> method. Calling <code class="literal">initConfig</code> inside the constructor initializes the configuration for the class.</p><p>This class can be modified if we need to work with different font icons.</p><p>We cannot forget to add the <code class="literal">requires</code> in the classes where we are going to use this class:</p><div><pre class="programlisting">requires: [
    //other requires
    'Packt.util.Glyphs'
],</pre></div></div><div><div><div><div><h4 class="title"><a id="ch06lvl4sec13"/>Panel versus Container versus Component</h4></div></div></div><p>Before we continue, let's take a look back on what we have learned so far. We have created a few views. In some of them we used the component class, in others we used container, and in others, still we used panel. Can you tell the difference between them? When do you use component, container, or panel?</p><p>The component<a id="id516" class="indexterm"/> is the base class for all Ext JS components (widgets). It has built-in support for basic hide/show, enable/disable, and size control behavior. Visually speaking, there is no style. We can set HTML content and set styles using one or more <code class="literal">'cls'</code> configurations.</p><p>The container<a id="id517" class="indexterm"/> is the base class that can contain other components (<code class="literal">items</code> configuration). It is also the base class that uses the layouts we are covering in this book (border, fit, VBox, anchor, accordion, and so on).</p><p>The <a id="id518" class="indexterm"/>panel class is a container with more capabilities. The panel has a header that we can set a title and add tools (useful buttons, such as collapse and expand, among others) to and it also support docked items (toolbars).</p><p>So, whenever you want to create a new Ext JS widget, you need to ask yourself, "What do I need to have in this widget?". If it is HTML content, we use a component. If we need to have items, or if we need a container to organize the layout of the children items, we can use a container. If we need to set a <code class="literal">title</code> or have a toolbar inside it, then we use a panel. Because the panel class has more capabilities, it is also a heavier component.</p><div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>Using the right widget can also help to boost the application performance.</p></div></div><p>In this example, we could <code class="literal">move</code> the toolbar inside the <code class="literal">UserGrid</code> class. To organize the layout, we could transform the <code class="literal">User</code> class in a container. If we only wanted to display the <code class="literal">UserGrid</code> class, we would not need the <code class="literal">User</code> class at all. This could avoid a bad practice called over-nesting. Over-nesting is using an additional container that does not do anything besides containing another component.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec61"/>Declaring the User ViewModel</h2></div></div></div><p>As we<a id="id519" class="indexterm"/> use the <a id="id520" class="indexterm"/>MVVM architecture, we declare the Model, and then we declare the View. The next step would be declaring the ViewModel. To do so, we are going to create the class <code class="literal">Packt.view.security.UserModel</code>, which is the ViewModel for the <code class="literal">Packt.view.security.User</code> class.</p><div><div><h3 class="title"><a id="note56"/>Note</h3><p>Note the naming convention we are using. The View name is <code class="literal">User</code>, so the ViewModel will be the name of the View + '<code class="literal">Model</code>'.</p></div></div><p>Let's take a <a id="id521" class="indexterm"/>look at the <code class="literal">ViewModel</code> class:</p><div><pre class="programlisting">Ext.define('Packt.view.security.UserModel', {
    extend: 'Ext.app.ViewModel',

    alias: 'viewmodel.user',

    stores: { //#1
        users: { //#2
            model: 'Packt.model.security.User',
            autoLoad: true //#3
        }
    }
});</pre></div><p>You learned that we can set the predefined data in the <code class="literal">ViewModel</code> class in <a class="link" href="ch03.html" title="Chapter 3. The Login Page">Chapter 3</a>, <em>The Login Page</em>. Now we <a id="id522" class="indexterm"/>are configuring ViewModel to load data from a <code class="literal">store</code> (<code class="literal">#1</code>) that we are declaring and creating (<code class="literal">#2</code>) at the same time. The Store <code class="literal">users</code> (this would be the Store ID) is a collection of the Model User, and we are also asking the Store to load automatically (<code class="literal">#3</code>) (we do not need to call the method load manually).</p><div><div><h3 class="title"><a id="note57"/>Note</h3><p>As the ViewModel will be created when the View is created, the Store will be loaded when the View is created as well. It is a different approach than declaring the Store as a standalone Store with <code class="literal">autoLoad true</code>—in this case, the Store will be created when the application is loaded and will retrieve the information from the server as well.</p></div></div><p>Instead of creating the Store inside the ViewModel, we could create the file representing the Store inside the store package and make a reference here. This Store also does not have a proxy since we declared it inside the Model (specifically inside the schema for reuse purposes).</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec29"/>Working with ViewModel data binding</h3></div></div></div><p>Let's go back<a id="id523" class="indexterm"/> to the <code class="literal">UsersGrid</code> class. We have not declared a store, which is required. We will do it using data binding and referencing the user's Store created in the ViewModel.</p><p>Inside the <code class="literal">UsersGrid</code> class, we are going to add the following code:</p><div><pre class="programlisting">bind : '{users}',</pre></div><p>This means<a id="id524" class="indexterm"/> the <code class="literal">UsersGrid</code> will be bound to the users Store. As the <code class="literal">UsersGrid</code> is a child component of the <code class="literal">User</code> class that refers the User ViewModel, the <code class="literal">UsersGrid</code> class will also have access to the ViewModel.</p><p>Next, we will go back to the <code class="literal">User</code> view class to add another data binding. We will add the following code to the <strong>Edit</strong> and <strong>Delete</strong> buttons:</p><div><pre class="programlisting">bind: {
    disabled: '{!usersGrid.selection}'
}</pre></div><p>We want the <strong>Edit</strong> and <strong>Delete</strong> buttons to be enabled only when the user selects a row from the Grid. If no row is selected, there is no point in clicking on the <strong>Edit</strong> or <strong>Delete</strong> buttons. So we are going to enable or disable the button according to this constraint. It is bound with the <code class="literal">usersGrid</code> (<code class="literal">reference</code> of the <code class="literal">UsersGrid</code> class) and the attribute selection of the Grid.</p><p>We also cannot forget to add the ViewModel to the <code class="literal">requires</code> from the <code class="literal">User</code> class:</p><div><pre class="programlisting">requires: [
    //other requires
    'Packt.view.security.UserModel'd
],</pre></div><p>Our code is complete so far. Time to listen to some events!</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec62"/>Creating the User ViewController</h2></div></div></div><p>The <a id="id525" class="indexterm"/>next step<a id="id526" class="indexterm"/> is creating the ViewController for the <code class="literal">User</code> class, so we are going to create the <code class="literal">Packt.view.security.UserController</code> class.</p><div><div><h3 class="title"><a id="note58"/>Note</h3><p>Note the naming convention we are using. The View name is <code class="literal">User</code>, so the ViewController will be the name of the View + '<code class="literal">Controller</code>'.</p></div></div><p>Let's add the following code to the ViewController class. It contains the method signature of all events and internal methods we are going to create:</p><div><pre class="programlisting">Ext.define('Packt.view.security.UserController', {
    extend: 'Ext.app.ViewController',

    alias: 'controller.user',

    requires: [
        'Packt.util.Util'
    ],

    onAdd: function(button, e, options){},

    onEdit: function(button, e, options){},

    createDialog: function(record){},

    getRecordsSelected: function(){},

    onDelete: function(button, e, options){},

    onSave: function(button, e, options){},

    onSaveSuccess: function(form, action) {},

    onSaveFailure: function(form, action) {},

    onCancel: function(button, e, options){},

    refresh: function(button, e, options){},

    onFileFieldChange: function(fileField, value, options) {}
});</pre></div><p>Before we dive <a id="id527" class="indexterm"/>into each method, go back to the <code class="literal">User</code> View, and add the ViewController to the <code class="literal">requires</code> declaration as well so that we can run and test what we coded so far:</p><div><pre class="programlisting">requires: [
    //other requires
    'Packt.view.security.UserController'
],</pre></div><p>To be able to execute<a id="id528" class="indexterm"/> the code, we also need to execute <code class="literal">UPDATE</code> on the database:</p><div><pre class="programlisting">UPDATE `sakila`.`menu` SET `className`='user' WHERE `id`='3';</pre></div><p>This will update the <code class="literal">className</code> column from <code class="literal">menu table</code> to match the <code class="literal">xtype</code> configuration we created for the <code class="literal">User</code> class, which is the View we want to be opened when a user clicks on the <strong>Users</strong> option from the menu.</p><p>Reloading the project, we will be able to see the list of all users from the application:</p><div><img src="img/0457OT_06_03.jpg" alt="Creating the User ViewController"/></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec30"/>Adding and editing a new user</h3></div></div></div><p>Now <a id="id529" class="indexterm"/>that we are capable of listing all the users of the application, we<a id="id530" class="indexterm"/> can implement the <strong>Add</strong> and <strong>Edit</strong> buttons capability. But before we start adding new event listeners to the controller, we need to create the new view that we are going to display to the user to edit or add a new user.</p><div><div><div><div><h4 class="title"><a id="ch06lvl4sec14"/>Creating the Edit View – form within a window</h4></div></div></div><p>This <a id="id531" class="indexterm"/>new view is going to be a window since we want to display it as a popup, and inside this window, we will have a form with the user's information, and then, we will have a toolbar at the bottom with two buttons: <strong>Cancel</strong> and <strong>Save</strong>. It is very similar to the Login window that we developed in <a class="link" href="ch03.html" title="Chapter 3. The Login Page">Chapter 3</a>, <em>The Login Page</em>, but we will add new capabilities to this new form, such as file upload and also a preview file using HTML5 features.</p><p>The view we are going to create looks like the following screenshot:</p><div><img src="img/0457OT_06_04.jpg" alt="Creating the Edit View – form within a window"/></div><p>So, let's get <a id="id532" class="indexterm"/>started and create a new class named <code class="literal">Packt.view.security.UserForm</code> that is going to <code class="literal">extend</code> from the window class:</p><div><pre class="programlisting">Ext.define('Packt.view.security.UserForm', {
    extend: 'Ext.window.Window',
    alias: 'widget.user-form',

    height: 270,
    width: 600,

    requires: [
        'Packt.util.Util',
        'Packt.util.Glyphs'
    ],

    layout: {
        type: 'fit'
    },

    bind: {
        title: '{title}' //#1
    },

    closable: false,
    modal: true,

    items: [
        {
            xtype: 'form',
            reference: 'form',
            bodyPadding: 5,
            modelValidation: true, //#2
            layout: {
                type: 'hbox',      //#3
                align: 'stretch'
            },
            items: [
                //add form items here
            ]
        }
    ]
});</pre></div><p>There are three<a id="id533" class="indexterm"/> very important things that we need to notice in this class: the first one is that we are not using the <code class="literal">autoShow</code> attribute. And the purpose is that we can create the window, and then we display it calling the method <code class="literal">show()</code> manually.</p><p>The second one is the data binding in line <code class="literal">#1</code>. We want to use data binding to automatically set the <code class="literal">title</code> of the window (Add new user or Edit: name of user). This is one of the advantages of the MVVM architecture.</p><p>The third thing is the <code class="literal">layout</code> that we are using on the form. It is not the default <code class="literal">layout</code> used by the form component (which is the Anchor layout). We are going to use the <code class="literal">hbox</code> layout (<code class="literal">#3</code>) because we want to organize the form's items horizontally. And we want the items to occupy all the available vertical space, so we will use the <code class="literal">align: 'stretch'</code>—we do not want to set <code class="literal">height</code> for each form <code class="literal">items</code>.</p><p>And at last, we learned in <a class="link" href="ch03.html" title="Chapter 3. The Login Page">Chapter 3</a>, <em>The Login Page</em>, how to validate the form using form validations. In this chapter, we will validate the form using <code class="literal">modelvalidations</code> (<code class="literal">#2</code>).</p><p>Let's add the first item to our form. If we take a look at the window screenshot at the beginning of this topic, we will notice that we are going to use two fieldsets to organize the form <code class="literal">items</code>. So the first one will be a <code class="literal">fieldset</code> to organize all the "<code class="literal">User Information</code>", as follows:</p><div><pre class="programlisting">{
    xtype: 'fieldset',
    flex: 1,                   //#4
    title: 'User Information',
    layout: 'anchor',          //#5
    defaults: {
        afterLabelTextTpl: Packt.util.Util.required, //#6
        anchor: '100%',                              //#7
        xtype: 'textfield',
        msgTarget: 'side',
        labelWidth: 75
    },
    items: [
        //add items here
    ]
},</pre></div><p>As the form is <a id="id534" class="indexterm"/>using the <code class="literal">hbox</code> layout, we need to specify how much space this component will occupy (<code class="literal">#4</code>). When working with the HBox or VBox layouts, the space occupied by the child component is calculated based on the proportional space configured. If we have five items with <code class="literal">flex: 1</code> each, then the total sum will be five; each item will occupy one-fifth of the available space. Or, we can also set <code class="literal">width</code> (HBox) or <code class="literal">height</code> (VBox) for some items, and the remaining space will be divided among the items with the <code class="literal">flex</code> configuration. In this example, we will use <code class="literal">flex: 1</code> for this <code class="literal">fieldset</code>, and for the next one we are going declare, we will use a fix width, so this <code class="literal">fieldset</code> will occupy all the remaining available space.</p><p>The <code class="literal">fieldset</code> will also use the <code class="literal">anchor</code> layout (<code class="literal">#5</code>), which allows you to anchor the items relative to the container's dimensions. The <code class="literal">anchor</code> layout is the default layout for forms, but as we are using a fieldset, we need to specify the layout as well. For each item, we can specify the <code class="literal">anchor</code> configuration (<code class="literal">#7</code>). As we want the child items occupying all the available width within the fieldset, we set the <code class="literal">anchor</code> configuration to <code class="literal">100%</code>.</p><p>For all required items, we will add a red asterisk (<code class="literal">#6</code>). Instead of adding the HTML for each form we use, we can add this value to our <code class="literal">Util</code> class and reuse it among other forms as well. Inside the <code class="literal">Packt.Util.util</code> class, add the following code:</p><div><pre class="programlisting">required: '&lt;span style="color:red;font-weight:bold" data-qtip="Required"&gt; *&lt;/span&gt;',</pre></div><p>We are also telling the fieldset that the default <code class="literal">xtype</code> of the items will be <code class="literal">textfield</code>. If any of the declared fields does not need these default configurations, we will override them with other values. So, let's declare the fields that will be part of the <code class="literal">items</code> configuration of the "<code class="literal">User Information</code>" fieldset:</p><div><pre class="programlisting">{
    xtype: 'hiddenfield',
    name: 'id',               //#8
    fieldLabel: 'Label',
    bind : '{currentUser.id}' //#9
},
{
    fieldLabel: 'Username',
    name: 'userName',
    bind : '{currentUser.userName}'
},
{
    fieldLabel: 'Name',
    name: 'name',
    bind : '{currentUser.name}'
},
{
    fieldLabel: 'Email',
    name: 'email',
    bind : '{currentUser.email}'
},
{
    xtype: 'combo',
    fieldLabel: 'Group',
    displayField: 'name',  //#10
    valueField: 'id',      //#11
    queryMode: 'local',    //#12
    forceSelection: true,  //#13
    editable: false,       //#14
    name: 'groups_id',
    bind: {
        value: '{currentUser.groups_id}', //#15
        store: '{groups}',                //#16
        selection: '{currentUser.group}'  //#17
    }
},
{
    xtype: 'filefield',
    fieldLabel: 'Photo',
    name: 'picture',
    buttonText: 'Select Photo...',
    afterLabelTextTpl: '',          //#18
    listeners: {
        change: 'onFileFieldChange' //#19
    }
}</pre></div><p>The <code class="literal">id</code> field will<a id="id535" class="indexterm"/> be <code class="literal">hidden</code> because we do not want the user to see it (we will use it only internally), and the <code class="literal">userName</code>, <code class="literal">name</code>, and <code class="literal">email</code> are simple textfields. Note that for each field, we declared a <code class="literal">name</code> (<code class="literal">#8</code>) and the <code class="literal">bind</code> (<code class="literal">#9</code>) configuration. As we are going to use a file upload capability, we will need to send the form information using the Ajax submit, and that is why we need to set a <code class="literal">name</code> configuration for each field. To avoid having to set the values of the form manually, we are going to use data binding from the ViewModel. We will set a variable named <code class="literal">currentUser</code> in the ViewModel that will refer to the current selected row of the <code class="literal">UsersGrid</code>.</p><p>Then, we have a<a id="id536" class="indexterm"/> combobox. When working with comboboxes, we need to set a Store to feed the information to it. In this case, we will bind (<code class="literal">#16</code>), the <code class="literal">store</code> of this combobox, with Store <code class="literal">groups</code> from the ViewModel. We will create the Store in a minute. The Store can represent a Model that has different fields. We can specify which field from the Model will be used as an internal value (<code class="literal">#11</code>) and which field will be displayed to the user (<code class="literal">#10</code>).</p><p>We can also specify other options such as forcing the user to select a value from the combobox (<code class="literal">#13</code>) and not allowing the user to write anything on it (<code class="literal">#14</code>)—as writing is autocomplete. As we will have the Store already loaded for this combobox, we can set the query mode to be <code class="literal">local</code> (<code class="literal">#15</code>). The default behavior is that whenever the user clicks on the combobox trigger, the Store is loaded.</p><p>Note that the binding for this field is more complex than for the other ones. We have three values bound; the store that we already mentioned (<code class="literal">#16</code>); the value, which refers to the <code class="literal">groups_id</code> foreign key (<code class="literal">#15</code>) of the <code class="literal">User</code> Model and the <code class="literal">selection</code> (<code class="literal">#17</code>), which will refer to the <code class="literal">group</code> object from the <code class="literal">User</code> Model (referring to the <code class="literal">Group</code> selected).</p><p>Then we have the file upload field. This field will not be mandatory, so we do not want it to display that red asterisk (<code class="literal">#18</code>) by overriding the <code class="literal">defaults</code> configuration. We also want to use a preview capability, so we are also going to add a <code class="literal">listener</code> declaration to this field (<code class="literal">#19</code>). Whenever the user selects a new picture, we will display it in the fieldset we are going to declare next (we are going to talk about the preview capability later in this chapter).</p><p>This is the first <code class="literal">fieldset</code> that will be displayed on the left-hand side of the form. Next, we need to declare the other <code class="literal">fieldset</code> that is going to wrap the <code class="literal">Photo</code> and will be displayed on the right-hand side of the form:</p><div><pre class="programlisting">{
    xtype: 'fieldset',
    title: 'Photo',
    width: 170,  //#19
    items: [
        {
            xtype: 'image',
            reference: 'userPicture', //#20
            height: 150,
            width: 150,
            bind:{
                src: 'resources/profileImages/{currentUser.picture}' //#21
            }
        }
    ]
}</pre></div><p>In this <code class="literal">fieldset</code>, we will declare a fixed <code class="literal">width</code> (<code class="literal">#19</code>). As the form uses the HBox layout, when a component <a id="id537" class="indexterm"/>has a fixed <code class="literal">width</code>, the layout will respect and apply the specified <code class="literal">width</code>. Then, the first <code class="literal">fieldset</code>, which has the <code class="literal">flex</code> configuration, will occupy all the remaining horizontal space.</p><p>Inside the picture fieldset, we will use an <code class="literal">Ext.Image Component</code>. The <code class="literal">Ext.Image</code> (<code class="literal">#20</code>) class helps us to create and render images. It also creates an <code class="literal">&lt;image&gt;</code> tag on the DOM with <code class="literal">src</code> (<code class="literal">#21</code>) specified. The <code class="literal">src</code> attribute is also bound to the picture field of the <code class="literal">User</code> Model. We also declared a reference to work with the preview capability later (<code class="literal">#20</code>).</p><p>When we load an existing <code class="literal">User</code> and try to edit the form, we will display the user's image on this component (if any). Also, if the user uploads a new image, the preview will also be rendered in this component.</p><p>And now, the last step is to declare the bottom toolbar with the <strong>Save</strong> and <strong>Cancel</strong> buttons, as follows:</p><div><pre class="programlisting">dockedItems: [
    {
        xtype: 'toolbar',
        dock: 'bottom',
        ui: 'footer', 
        layout: {
            pack: 'end', //#22
            type: 'hbox'
        },
        items: [
            {
                xtype: 'button',
                text: 'Save',
                glyph: Packt.util.Glyphs.getGlyph('save'),
                listeners: {
                    click: 'onSave'
                }
            },
            {
                xtype: 'button',
                text: 'Cancel',
                glyph: Packt.util.Glyphs.getGlyph('cancel'),
                listeners: {
                    click: 'onCancel'
                }
            }
        ]
    }
]</pre></div><p>As we want to align the buttons on the right-hand side of the toolbar, we will use the <code class="literal">hbox</code> layout as well <a id="id538" class="indexterm"/>and organize (<code class="literal">#22</code>) the buttons to the right toolbar. The Edit/Add window is now ready. However, there are a few other details that we still need to take care of before implementing the Add and Edit listeners on the Controller.</p></div><div><div><div><div><h4 class="title"><a id="ch06lvl4sec15"/>Creating the Group Model</h4></div></div></div><p>On the <a id="id539" class="indexterm"/>
<code class="literal">Group</code> combobox, we declared a <code class="literal">groups</code> Store used to load all the <code class="literal">Groups</code> from the database. Now, we need to implement this missing Store, and the first step to do so is create the Model that is going to represent a Group record from the <code class="literal">group</code> table. So we are going to create a new Model named <code class="literal">Packt.model.security.Group</code>, as follows:</p><div><pre class="programlisting">Ext.define('Packt.model.security.Group', {
    extend: 'Packt.model.security.Base',

    fields: [
        { name: 'name' }
    ]
});</pre></div><p>As the <code class="literal">group</code> table is very simple, it only contains two columns, <code class="literal">id</code> and <code class="literal">name</code>; our <code class="literal">Group</code> Model is also simple with only these two fields. As the <code class="literal">Group</code> Model is extending from the <code class="literal">Base</code> Model we created in the beginning of this chapter, the <code class="literal">id</code> column will come from the <code class="literal">Base</code>, <code class="literal">schema</code>, and <code class="literal">proxy</code> configurations.</p></div><div><div><div><div><h4 class="title"><a id="ch06lvl4sec16"/>The Groups Store</h4></div></div></div><p>As <a id="id540" class="indexterm"/>we already created the <code class="literal">Group</code> Model, now we need to create the <code class="literal">groups</code> Store.</p><div><div><h3 class="title"><a id="note59"/>Note</h3><p>Always remember the naming convention: the Model name is the singular name of the entity you want to represent and the Store is the plural of the name of the Model/entity.</p></div></div><p>So we will create a new <code class="literal">Store</code> inside the <code class="literal">UserModel</code> class, as follows:</p><div><pre class="programlisting">stores: {
    users: {
        model: 'Packt.model.security.User',
        autoLoad: true
    },
    <strong>groups: {        model: 'Packt.model.security.Group',        autoLoad: true    }</strong>
}</pre></div><p>Following the same pattern as the other stores, the <code class="literal">groups</code> information will be sent by the server within a data attribute in the JSON as follows:</p><div><pre class="programlisting">{
    "success": true,
    "data": [{
        "id": "1",
        "name": "admin"
    }]
}</pre></div><p>Now all the<a id="id541" class="indexterm"/> views, models, and stores needed for our user management module are created. We can focus on the ViewController to handle all the events we are interested in listening to and implementing all the magic!</p><div><div><h3 class="title"><a id="note60"/>Note</h3><p>For all the server-side code of this chapter, and the group management code, please download the source code bundle of this book or go to <a class="ulink" href="https://github.com/loiane/masteringextjs">https://github.com/loiane/masteringextjs</a>.</p></div></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec31"/>Controller – listening to the Add button</h3></div></div></div><p>The first event that <a id="id542" class="indexterm"/>we will implement for the Edit or Add Window is the Add event. When the user clicks on the <strong>Add</strong> button, we want to display the <strong>Edit</strong> user window (the <code class="literal">Packt.view.security.UserForm</code> class).</p><p>The button <strong>Add</strong> already has a listener. So all we need to do is add the code in the ViewController:</p><div><pre class="programlisting">onAdd: function(button, e, options){
    this.createDialog(null);
},</pre></div><p>If the user clicks on the <strong>Add</strong> button, we want to open a blank popup so that user can enter the new record information and save it. If the user clicks on the <strong>Edit</strong> button, we want to open the same popup with the data from the selected row from the Grid. So, for the <strong>Add</strong> button, we will open the popup passing null (no row selected). The <code class="literal">createDialog</code> method is listed in the following code:</p><div><pre class="programlisting">createDialog: function(record){

    var me = this,           
        view = me.getView(); //#1

    me.dialog = view.add({
        xtype: 'user-form',  //#2
        viewModel: {         //#3
            data: {
                title: record ? 'Edit: ' + record.get('name') : 'Add User' //#4
            },
            links: { //#5
                currentUser: record || { //#6
                    type: 'User',        //#7
                    create: true
                }
            }
        }
    });

    me.dialog.show(); //#7
},</pre></div><p>We start getting <a id="id543" class="indexterm"/>a reference (<code class="literal">#1</code>) to the <code class="literal">User</code> View class reference, since the ModelView was declared inside it.</p><p>Next, we are going to create the <code class="literal">UserForm</code> window (<code class="literal">#2</code>) and assign it to a variable dialog that belongs to the ViewModel scope (the method add returns the instance of the component created). We are also adding the <code class="literal">UserForm</code> window to the <code class="literal">User</code> View (you might remember that we used the VBox layout instead of the Fit layout; this is the reason). When adding the <code class="literal">UserForm</code> window as an item of the <code class="literal">User</code> View, this item will also have access to the ViewModel associated to its parent. In this case, we want to add more details to the Window's ViewModel (as a child ViewModel—(<code class="literal">#3</code>)). We are going to add a predefined field named <code class="literal">title</code> (that we used to set the window's title—(<code class="literal">#4</code>)). And we are also going to create a <code class="literal">link</code> (<code class="literal">#5</code>). Links provide a way to assign a simple name to a more complex bind. The primary use for this is to assign names to records in the data model. If there is an existing <code class="literal">record</code> (from <code class="literal">Edit</code>—(<code class="literal">#6</code>)), it uses a copy of it, and if not, it creates a new phantom record (<code class="literal">#7</code>).</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec32"/>Controller – listening to the Edit button</h3></div></div></div><p>If we <a id="id544" class="indexterm"/>want to edit an existing user, the <strong>Edit</strong> button will fire the click event, and the ViewController will listen to it through the following method:</p><div><pre class="programlisting">onEdit: function(button, e, options){

    var me = this,
        records = me.getRecordsSelected(); //#1

    if(records[0]){ //#2
        me.createDialog(records[0]); //#3
    }
},</pre></div><p>First, we are going to get the selected <code class="literal">records</code> from the Grid (<code class="literal">#1</code>). If a record (<code class="literal">#2</code>) was selected, we are going to create the window passing the record (<code class="literal">#3</code>).</p><p>The<a id="id545" class="indexterm"/> method <code class="literal">getRecordSelected</code> is listed as follows:</p><div><pre class="programlisting">getRecordsSelected: function(){
    var grid = this.lookupReference('usersGrid'); //#4
    return grid.getSelection(); //#5
},</pre></div><p>We are going to get a reference of the <code class="literal">UsersGrid</code> (<code class="literal">#4</code>), and by accessing its <code class="literal">getSelection</code> method, we can get the rows selected (<code class="literal">#5</code>).</p><p>The <code class="literal">getSelection</code> method returns an array of the selected records. That is why we are using <code class="literal">records[0]</code> to access the selected row. By default, a Grid allows you to select only one row at a time. This can be changed by setting the following configuration in the Grid:</p><div><pre class="programlisting">selModel: {
    mode: 'MULTI'
},</pre></div><p>By default, a Grid allows you to select only one row at a time; this can be changed using the <code class="literal">selType: 'checkboxmodel'</code> (<code class="literal">Ext.selection.CheckboxModel</code>).</p><p>The validation in <code class="literal">#2</code> is an extra step as we are binding the <strong>Edit</strong> button directly to the <code class="literal">selection</code> configuration of the Grid, but to be careful and avoid exceptions in the code is never too much!</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec33"/>Controller – listening to the Cancel button</h3></div></div></div><p>If the user <a id="id546" class="indexterm"/>decides not to save the user information, it is possible to click on the <strong>Cancel</strong> button that is going to fire the click event to execute the following method:</p><div><pre class="programlisting">onCancel: function(button, e, options){
    var me = this;
    me.dialog = Ext.destroy(me.dialog);
},</pre></div><p>What we want to do is very simple: if the user wants to cancel all the changes made to an existing user or wants to cancel the creation of a user, the system will <code class="literal">destroy</code> the window. We can use <code class="literal">Ext.destroy</code> to destroy it or call the method <code class="literal">destroy</code> as well. At the same time, <code class="literal">me.dialog</code> will lose the reference as well.</p><div><div><h3 class="title"><a id="note61"/>Note</h3><p>To learn more about JavaScript memory leaks, go to <a class="ulink" href="http://javascript.info/tutorial/memory-leaks">http://javascript.info/tutorial/memory-leaks</a>. To learn more about the importance of the garbage collector (freeing up memory) go to <a class="ulink" href="http://goo.gl/qDdwwt">http://goo.gl/qDdwwt</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec34"/>Controller – saving a user</h3></div></div></div><p>Now that<a id="id547" class="indexterm"/> the user is able to open the window to create or edit a <code class="literal">User</code>, we need to implement the <strong>Save</strong> button logic. No matter if the user is creating a new user or editing an existing user, we will use the same logic to save the user. We will let the server side handle this if it needs to use an <code class="literal">UPDATE</code> or <code class="literal">INSERT</code> query.</p><p>The ViewController will execute the following method to save the information:</p><div><pre class="programlisting">onSave: function(button, e, options){

    var me = this,
        form = me.lookupReference('form'); //#1

    if (form &amp;&amp; form.isValid()) { //#2
        form.submit({     //#3
            clientValidation: true, //#4
            url: 'php/user/save.php', //#5
            scope: me,                //#6
            success: 'onSaveSuccess',
            failure: 'onSaveFailure'
        });
    }
},</pre></div><p>The first step is to get the form reference (<code class="literal">#1</code>). Then, we will verify that the form is valid ((<code class="literal">#2</code>) the user filled the form with valid values following all the rules of the model validations (<code class="literal">#4</code>) that we are going to implement), after which we will submit the form to the given <code class="literal">url</code> (<code class="literal">#5</code>).</p><p>We could use the Store features to create and edit the User (as we will see later in this book). However, we are using a different approach, which is the form submit method to directly send the values to the server, because we are also uploading a document to the server. When uploading a document to the server, it is not possible to use the Store capabilities.</p><p>Before we list the success and failure callbacks, take a look at the code again at the line <code class="literal">var me = this</code>. Whenever we have more than one reference to this or we work with callbacks, we do this assignment.</p><div><div><h3 class="title"><a id="note62"/>Note</h3><p>There are two reasons to use <code class="literal">me</code> instead of <code class="literal">this</code> (or you can create other variable names according to your preference (<code class="literal">that</code>, <code class="literal">self</code>)). The first one is when "<code class="literal">this</code>" is used a lot in a method, using "<code class="literal">me</code>" can save 16 bits each reference. After we do the production build, Sencha Cmd will replace <code class="literal">me</code> with <code class="literal">a</code>, <code class="literal">b</code>, or any other letter. The keyword <code class="literal">this</code> cannot be replaced with <code class="literal">a</code>, <code class="literal">b</code>, or any other value, therefore it will use four characters instead of only one.</p><p>The second reason is that we can keep a reference to <code class="literal">this</code> inside a scope in which <code class="literal">this</code> refers to something else (like a callback function, for example, the form <code class="literal">submit</code>—if we used <code class="literal">this</code> inside the <code class="literal">submit</code>, it would make a reference to the <code class="literal">submit</code> method itself and not the ViewController).</p><p>This way a callback function can refer to a function or variable that was declared in the outer function (ViewController in this example). This is called closure.</p></div></div><p>You can learn<a id="id548" class="indexterm"/> about how to handle file upload in PHP by downloading the source code from this book. If you are using another language or for some reason a form submit is not working, always inspect the request in the <em>Developer Tools</em> of the browser you are using to see what is being sent to the server. The following screenshot exemplifies what is being sent while creating a new user:</p><div><img src="img/0457OT_06_05.jpg" alt="Controller – saving a user"/></div><p>The next steps now are to implement the <code class="literal">success</code> and <code class="literal">failure</code> callbacks. Let's implement the <code class="literal">success</code> callback first:</p><div><pre class="programlisting">onSaveSuccess: function(form, action) {
    var me = this;
    me.onCancel(); //#7
    me.refresh();  //#8
    Packt.util.Util.showToast('Success! User saved.'); //#9
},</pre></div><p>If the server returns success as <code class="literal">true</code>, we will call the method <code class="literal">onCancel</code> that is responsible for closing and destroying the window (<code class="literal">#7</code>) that we implemented in the previous topic. As we are using a form submit to send the information to the server, we need to refresh (<code class="literal">#8</code>) the Store to get the<a id="id549" class="indexterm"/> new information from the server. And at last, we will display a toast (introduced in Ext JS 5) with a success message (<code class="literal">#9</code>) as shown by the following image:</p><div><img src="img/0457OT_06_06.jpg" alt="Controller – saving a user"/></div><p>The refresh method is listed as follows:</p><div><pre class="programlisting">refresh: function(button, e, options){
    var me = this,
        store = me.getStore('users');

    store.load();
},</pre></div><p>Inside the <code class="literal">refresh</code> method, we get the reference to the <code class="literal">users</code> Store and call its method <code class="literal">load</code> to get the information from the server again.</p><p>The following is the <code class="literal">showToast</code> static method from the <code class="literal">Packt.util.Util</code> class:</p><div><pre class="programlisting">showToast: function(text) {
    Ext.toast({
        html: text,
        closable: false,
        align: 't',
        slideInDuration: 400,
        minWidth: 400
    });
}</pre></div><p>The <code class="literal">Ext.Toast</code> class provides lightweight, auto-dismissing pop-up notifications called toasts. We can set its content (<code class="literal">html</code>), a title, a <strong>close</strong> button, the alignment (in our example, it will be displayed at the top), how many seconds it will be displayed (4 seconds) and its width, among other options that we can check in the Ext JS documentation.</p><p>Next, let's implement the <code class="literal">failure</code> callback:</p><div><pre class="programlisting">onSaveFailure: function(form, action) {
    Packt.util.Util.handleFormFailure(action);
},</pre></div><p>In <a class="link" href="ch03.html" title="Chapter 3. The Login Page">Chapter 3</a>, <em>The Login Page</em>, we <a id="id550" class="indexterm"/>also handled a form failure callback. The code we are going to use here is exactly the same. As we are starting to repeat code, we can create another static function in the <code class="literal">Util</code> class so that we can reuse it:</p><div><pre class="programlisting">handleFormFailure: function(action){
    var me = this,
    result = Packt.util.Util.decodeJSON(action.response.responseText);

    switch (action.failureType) {
        case Ext.form.action.Action.CLIENT_INVALID:
            me.showErrorMsg('Form fields may not be submitted with invalid values'); //#1
            break;
        case Ext.form.action.Action.CONNECT_FAILURE:
            me.showErrorMsg(action.response.responseText);
            break;
        case Ext.form.action.Action.SERVER_INVALID:
            me.showErrorMsg(result.msg);
    }
}</pre></div><p>The difference is now that this code is inside the <code class="literal">Packt.util.Util</code> class, we can refer to it to call the <code class="literal">showErrorMsg</code> method (<code class="literal">#1</code>).</p><p>We can also go back to <code class="literal">LoginController</code> and replace the failure callback code with the call of the <code class="literal">handleFormFailure</code> function.</p><p>Our save code is now ready.</p><div><div><div><div><h4 class="title"><a id="ch06lvl4sec17"/>Using Model validators</h4></div></div></div><p>As we <a id="id551" class="indexterm"/>implemented the save method, let's use the opportunity to complete the code to validate the form with Model validators.</p><p>We are going to add the following code to the <code class="literal">User</code> Model:</p><div><pre class="programlisting">validators: {
    name: [
        { type: 'presence', message: 'This field is mandatory'},
        { type: 'length', min: 3, max: 100}
    ],
    userName: [
        { type: 'exclusion', list: ['Admin', 'Operator'] },
        { type: 'format', matcher: /([a-z]+)/i },
        { type: 'presence', message: 'This field is mandatory'},
        { type: 'length', min: 3, max: 25}
    ],
    email: [
        { type: 'presence', message: 'This field is mandatory'},
        { type: 'length', min: 5, max: 100},
        { type: 'email' }
    ],
    groups_id: 'presence'
},</pre></div><p>We can have the following types of Model validators:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">presence</code>: This <a id="id552" class="indexterm"/>ensures that the field has a value. Zero counts as a valid value, but empty strings do not.</li><li class="listitem" style="list-style-type: disc"><code class="literal">length</code>: This <a id="id553" class="indexterm"/>ensures that a string is between <code class="literal">min</code> length and <code class="literal">max</code> length. Both constraints are optional.</li><li class="listitem" style="list-style-type: disc"><code class="literal">format</code>: This <a id="id554" class="indexterm"/>ensures that a string matches a regular expression format.</li><li class="listitem" style="list-style-type: disc"><code class="literal">inclusion</code>: This <a id="id555" class="indexterm"/>ensures that a value is within a specific set of values (for example, ensuring gender is either male or female).</li><li class="listitem" style="list-style-type: disc"><code class="literal">exclusion</code>: This <a id="id556" class="indexterm"/>ensures that a value is not one of the specific set of values (for example, blacklisting usernames like "admin").</li><li class="listitem" style="list-style-type: disc"><code class="literal">email</code>: This <a id="id557" class="indexterm"/>ensures that the value is a valid e-mail.</li><li class="listitem" style="list-style-type: disc"><code class="literal">range</code>: This<a id="id558" class="indexterm"/> ensures that the value is between a <code class="literal">min</code> and a <code class="literal">max</code>. Both constraints are optional.</li></ul></div><p>Each validator has a default <code class="literal">message</code> just in case the validation is not met. We can also override it.</p></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec35"/>Previewing a file before uploading</h3></div></div></div><p>One last thing <a id="id559" class="indexterm"/>that we will implement related to the window: the file upload preview. This is something that is not that hard to implement, and it will bring a sparkle to the application user's eyes!</p><p>So what we want to do when the user selects a new file using the file upload component is read the file using the HTML5 FileReader API. Unfortunately, not every browser supports the FileReader API; only the following versions do: Chrome 6+, Firefox 4+, Safari 6+, Opera 12+, Explorer 10+, iOS Safari 6+, Android 3+, and Opera Mobile 12+. But do not worry, we will verify that the browser supports it first, and if it does not, we will not use it, which means that the file preview will not happen.</p><div><div><h3 class="title"><a id="note63"/>Note</h3><p>To learn more about the <a id="id560" class="indexterm"/>FileReader API, please read its specification at <a class="ulink" href="http://www.w3.org/TR/file-upload/">http://www.w3.org/TR/file-upload/</a>, and to learn more about this and other HTML5 features, go to <a class="ulink" href="http://www.html5rocks.com/">http://www.html5rocks.com/</a>.</p></div></div><p>When the user <a id="id561" class="indexterm"/>selects a new file using the Ext JS file upload component, the change event is fired, so we need to listen to it in our ViewController. The following code exemplifies what was discussed in this paragraph:</p><div><pre class="programlisting">onFileFieldChange: function(fileField, value, options) {

    var me = this,
        file = fileField.fileInputEl.dom.files[0], //#1
        picture = this.lookupReference('userPicture'); //#2

    if (typeof FileReader !== 'undefined' &amp;&amp; (/image/i).test(file.type)) { //#3
        var reader = new FileReader();       //#4
        reader.onload = function(e){         //#5
            picture.setSrc(e.target.result); //#6
        };
        reader.readAsDataURL(file);          //#7
    } else if (!(/image/i).test(file.type)){ //#8
        Ext.Msg.alert('Warning', 'You can only upload image files!');
        fileField.reset();                   //#9
    }
}</pre></div><p>So first, we need to get the file (<code class="literal">#1</code>) object that is stored inside the file input element of the Ext JS File field component (also passed as a parameter to our method). Then, we will get a reference of the <code class="literal">Ext.Image</code> component that is inside our form so that we can update its <code class="literal">source</code> to the file preview.</p><p>We will also test whether the FileReader API is available on the browser and also whether the file that the user chose is an image (<code class="literal">#3</code>). If positive, we will instantiate a <code class="literal">FileReader</code> method (<code class="literal">#4</code>); we will add a listener to it (<code class="literal">#4</code>), so when the FileReader is done reading the file, we can set its contents to the <code class="literal">Ext.Image</code> source (<code class="literal">#6</code>). And of course, to fire the <code class="literal">onload</code> event, the FileReader instance needs to read the contents of the file (<code class="literal">#7</code>). One very important note: we are displaying the contents of the file before we upload to the server. If the user saves the changes made to the form, the new user information will be sent to the server (including the file upload), and the next time we open the window, the picture will be displayed.</p><div><div><h3 class="title"><a id="note64"/>Note</h3><p>How do you get the full path of the file that is being uploaded? For example, the Ext JS file upload component displays <code class="literal">C:\fakepath\nameOfTheFile.jpg</code>, and we want to get its real path, such as <code class="literal">C:\Program Files\nameOfTheFile.jpg</code>. The answer is: it is not possible to do it with JavaScript (and Ext JS is a JavaScript framework).</p><p>This is not a restriction from Ext JS; if we try it with any other JavaScript framework or library, such as jQuery, it is not going to be possible because this is a browser security restriction. Imagine if it was possible. Someone could develop a malicious JavaScript file and run it while you are navigating on the web and get all the information that you have on your computer.</p></div></div><p>Another really <a id="id562" class="indexterm"/>nice thing: if the file that the user chose is not an image (<code class="literal">#8</code>), we will display a message saying that only images can be uploaded, and we will reset the file upload component. Unfortunately, it is not possible to filter the file types on the browse window (the one that opens so we can choose a file from the computer), and this is a wayaround, so we can do this validation on the Ext JS side and not leave it to the server.</p><p>And if the FileReader is not available, nothing is going to happen. The file preview is simply not going to work. The user will select the file and that's it.</p><div><div><h3 class="title"><a id="tip29"/>Tip</h3><p>The file size limit that you can upload depends on the upload limit that is set on the web server that you are going to deploy the Ext JS application in. For example, Apache supports a limit of 2GB. IIS has a default value of 4MB, but you can increase it to 2GB as well. Likewise for Apache Tomcat and other web servers. So the size limit is not on Ext JS; it is on the web server, and you just need to configure it.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec36"/>Deleting a user</h3></div></div></div><p>The last CRUD operation<a id="id563" class="indexterm"/> that we need to implement is the delete user. So let's add the delete listener to the ViewController, as follows:</p><div><pre class="programlisting">onDelete: function(button, e, options){
    var me = this,
        view = me.getView(),
        records = me.getRecordsSelected(), //#1
        store = me.getStore('users');      //#2

    if (store.getCount() &gt;= 2 &amp;&amp; records.length){ //#3
        Ext.Msg.show({
            title:'Delete?', //#4
            msg: 'Are you sure you want to delete?',
            buttons: Ext.Msg.YESNO,
            icon: Ext.Msg.QUESTION,
            fn: function (buttonId){
                if (buttonId == 'yes'){ //#5
                    store.remove(records); //#6
                    store.sync();          //#7
                }
            }
        });
    } else if (store.getCount() === 1) { //#8
        Ext.Msg.show({
            title:'Warning',
            msg: 'You cannot delete all the users from the application.',
            buttons: Ext.Msg.OK,
            icon: Ext.Msg.WARNING
        });
    }
},</pre></div><p>The idea of this method <a id="id564" class="indexterm"/>is to verify that the user selected any row from the grid to be deleted (<code class="literal">record[0]</code> exists—(<code class="literal">#1</code>)) and also, we will only delete a user if there are more than two users on the application (<code class="literal">#3</code>). If yes, we will delete the user. If not, this means there is only one user in the application (<code class="literal">#8</code>), and we cannot delete the only user that exists.</p><p>If it is possible to delete the user, the system will display a question asking whether we really want to delete the selected user (<code class="literal">#4</code>). If the answer is <code class="literal">yes</code> (<code class="literal">#5</code>), we will get the <code class="literal">store</code> reference (<code class="literal">#2</code>) and use its <code class="literal">remove</code> method (<code class="literal">#6</code>) passing the records to be deleted, and will send this request to the server (<code class="literal">#7</code>). The <code class="literal">proxy</code> will call the <code class="literal">destroy</code> URL when the <code class="literal">sync</code> method is called.</p><div><div><h3 class="title"><a id="note65"/>Note</h3><p>Just remember that on the server, you can execute a <code class="literal">DELETE</code> query on the database, but in most cases we do a logical deletion, which means we will perform an <code class="literal">UPDATE</code> on a column active (in this case update the user to inactive).</p></div></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec63"/>Displaying the group name in the Grid</h2></div></div></div><p>There are a few <a id="id565" class="indexterm"/>ways we can display<a id="id566" class="indexterm"/> associated data in the Grid. We will use one approach in this example, and in other chapters, we will use different ones.</p><p>The approach we are going to use is to add a <code class="literal">hasOne</code> association to the <code class="literal">User</code> Model as follows:</p><div><pre class="programlisting">hasOne: [
    {
        model: 'Group',         //#1
        name: 'group',          //#2
        foreignKey:'groups_id', //#3
        associationKey: 'group'
    }
]</pre></div><p>As we are using the same schema in the <code class="literal">User</code> and <code class="literal">Group</code> models, we can refer to the <code class="literal">Group</code> Model only by its <code class="literal">entityName</code> (<code class="literal">#1</code>). We can also give a name of the object that is going to come from the server with the <code class="literal">Group</code> information (<code class="literal">#2</code>). And at last, Ext JS also needs to know which field contains the foreign key to the <code class="literal">Group</code> Model (<code class="literal">#3</code>).</p><p>Then, we are going to add a new field in the user Model as well, as follows:</p><div><pre class="programlisting">{ name:'groupName', type:'string', persist:false,
    convert:function(v, rec){
        var data = rec.data;
        if (data.group &amp;&amp; data.group.name){
            return data.group.name;
        }
        return data.groups_id;
    }
}</pre></div><p>This field will be created in runtime when a <code class="literal">User</code> Model is created. We are not going to persist this information, which means that whenever the Store sends a create, update, or destroy request to the<a id="id567" class="indexterm"/> server, this field will not be included. For this field, we are also going to declare a <code class="literal">convert</code> function, which means that the information for this field will be created from another existing field. If there is <code class="literal">group</code> information available, we will return its <code class="literal">name</code>; otherwise, we return the <code class="literal">groups_id</code> anyway.</p><p>Then, in the <code class="literal">UsersGrid </code>class, we will replace the current <code class="literal">dataIndex</code> of the <code class="literal">groups_id</code> column with the following code:</p><div><pre class="programlisting">dataIndex: 'groupName',</pre></div><p>And the Grid will display the name of the group instead of its ID.</p><p>We can refresh the <a id="id568" class="indexterm"/>application and test all functionalities from this chapter!</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, we covered how to create, update, delete, and list all the users from our application.</p><p>While we developed this module, we covered some important Ext JS concepts and some features introduced in Ext JS 5. We developed this module using MVVM, and we covered some other ModelView capabilities, such as data binding. We learned how to use a schema in the Model and validate a form using Model validation. We also explored a new HTML5 feature for the file upload preview capability, which is another example of how we can use other technologies along with Ext JS.</p><p>In this next chapter, we will implement the MySQL table management module, which means we will implement a screen very similar to the <strong>Edit</strong> table data screen that we find in the MySQL Workbench application.</p></div></body></html>