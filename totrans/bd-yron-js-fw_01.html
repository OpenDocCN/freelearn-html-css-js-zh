<html><head></head><body>
<div id="_idContainer019">
<h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/><span class="koboSpan" id="kobo.1.1">1</span></h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/><span class="koboSpan" id="kobo.2.1">The Benefits of Different JavaScript Frameworks</span></h1>
<p><span class="koboSpan" id="kobo.3.1">It has been over 25 years since JavaScript was first introduced into our web browsers. </span><span class="koboSpan" id="kobo.3.2">Since then, this technology has vastly changed how we interact with websites and applications, how we build APIs for backend systems, and even how we communicate with hardware platforms. </span><span class="koboSpan" id="kobo.3.3">JavaScript has become one of the most popular programming languages on the planet. </span><span class="koboSpan" id="kobo.3.4">To this day, JavaScript’s pace of evolution and rapid change is a popular topic of conversation among developers – it is a source of excitement and innovation. </span><span class="koboSpan" id="kobo.3.5">As a programming language, JavaScript has been ranked as the most popular among developers in the last 10 consecutive years and has been the key to client-side scripting for 98% of all websites. </span><span class="koboSpan" id="kobo.3.6">We cannot underestimate how much JavaScript and its closely related ECMAScript standardization have enabled the web to become the platform to host the next generation of software that can be accessed by billions of people. </span><span class="koboSpan" id="kobo.3.7">With these technologies, millions of businesses and individuals can easily build great applications, creative experiences, and complex software solutions. </span><span class="koboSpan" id="kobo.3.8">In many ways, the web platform has the potential to be the most vibrant and friendly developer ecosystem in the </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">whole world.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">JavaScript frameworks are the straightforward way millions of web developers build projects today. </span><span class="koboSpan" id="kobo.5.2">Due to their popularity and ease of use, frameworks allow developers to quickly make product ideas come to life without unnecessary overheads. </span><span class="koboSpan" id="kobo.5.3">Without the framework systems that we have at our disposal today, the web would not have been able to compete with other </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">development platforms.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">In this book, we will study the vast ecosystem and expand our knowledge to become confident in creating and maintaining our own self-developed frameworks. </span><span class="koboSpan" id="kobo.7.2">Developing the skill to build a framework or extend existing ones comes with the benefit of becoming an impactful domain expert in frontend and </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">backend projects.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">As part of becoming experts in JavaScript frameworks, we need to get a sense of the core components and tools of the web development workflow. </span><span class="koboSpan" id="kobo.9.2">In this first chapter of the book, we will take a look at how web development evolved, how frameworks changed the landscape of working with JavaScript, and what the ecosystem currently has </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">to offer.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">We will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">The emergence of </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">JavaScript frameworks</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">The evolution of </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">code bases</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Types of frameworks in JavaScript and </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">their benefits</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">My experiences </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">with frameworks</span></span></li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/><span class="koboSpan" id="kobo.21.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.22.1">This book has an accompanying GitHub repository at </span><a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework"><span class="koboSpan" id="kobo.23.1">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</span></a><span class="koboSpan" id="kobo.24.1">. </span><span class="koboSpan" id="kobo.24.2">In each chapter, we will point to the relevant directories in this repository. </span><span class="koboSpan" id="kobo.24.3">Feel free to clone or download the repository as a </span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">ZIP file.</span></span></p>
<p><span class="koboSpan" id="kobo.26.1">You need a desktop or a laptop computer with internet access and a terminal application to install and run the code from this repository. </span><span class="koboSpan" id="kobo.26.2">We shall also be utilizing Node.js to run some of the parts of the repository. </span><span class="koboSpan" id="kobo.26.3">Node.js is an open source, cross-platform, backend JavaScript runtime environment that runs JavaScript code outside a web browser. </span><span class="koboSpan" id="kobo.26.4">The installation for Node.js can be found at </span><a href="https://nodejs.org"><span class="koboSpan" id="kobo.27.1">nodejs.org</span></a><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">For the code from the repository, you can use any environment that supports a terminal and runs Node.js, such as Windows, macOS, and most varieties </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">of Linux.</span></span></p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/><span class="koboSpan" id="kobo.30.1">The emergence of JavaScript frameworks</span></h1>
<p><span class="koboSpan" id="kobo.31.1">As JavaScript</span><a id="_idIndexMarker000"/><span class="koboSpan" id="kobo.32.1"> progressed and evolved, the innovators who were heavily involved in the language, both companies and individuals, started writing software libraries to help solve the everyday burdens of web application architectures. </span><span class="koboSpan" id="kobo.32.2">The initial focus of the most basic JavaScript libraries was to provide singular features, interactivity, and add-ons, which progressively enhanced the web page. </span><span class="koboSpan" id="kobo.32.3">At that time, JavaScript gave life to a static page with its interactive components – simple examples that always come to mind are tiny scripts, which enabled creative button effects and mouse cursor effects. </span><span class="koboSpan" id="kobo.32.4">In many cases, these scripts were separate from the site’s core functionality and were not essential to allow users to interact with the content. </span><span class="koboSpan" id="kobo.32.5">Since the inception of small libraries, these have paved the way for the complex framework systems that we have today. </span><span class="koboSpan" id="kobo.32.6">The frontend technology quickly evolved, and now, developers are much more accustomed to megabytes of scripts powering the </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">frontend code.</span></span></p>
<p><span class="koboSpan" id="kobo.34.1">JavaScript libraries were the next step in the web development evolution, assisting with cross-browser quirks, complex visual effects, network requests, and web page layout. </span><span class="koboSpan" id="kobo.34.2">With the use of these libraries, developers were able to have the cross-browser development challenges under control. </span><span class="koboSpan" id="kobo.34.3">CSS started to catch up with its focus on layout features and cross-browser standards, improving the web’s styling features. </span><span class="koboSpan" id="kobo.34.4">Developers finally began introducing structure and well-crafted systems into </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">web development.</span></span></p>
<p><span class="koboSpan" id="kobo.36.1">The time has come to finally focus on building scalable and opinionated software on the web, and this is where we began to see glimpses of complex software paradigms introduced into large websites and web applications. </span><span class="koboSpan" id="kobo.36.2">Companies and larger enterprises started treating the web as a serious application platform, which led to a few prominent projects written in JavaScript and compiled to JavaScript</span><a id="_idIndexMarker001"/><span class="koboSpan" id="kobo.37.1"> from languages such as Java. </span><span class="koboSpan" id="kobo.37.2">Tracing back to late 2009, we see the first iterations of </span><strong class="bold"><span class="koboSpan" id="kobo.38.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.39.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.40.1">MVC</span></strong><span class="koboSpan" id="kobo.41.1">) frameworks built entirely with HTML, CSS, and JavaScript. </span><span class="koboSpan" id="kobo.41.2">This MVC model allows more extensive projects to stay organized, enriches the development workflow, and opens up the world of frontend development to developers who expect a much more structured approach when writing software. </span><span class="koboSpan" id="kobo.41.3">The MVC model fit web applications well enough to spawn a renaissance in </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">framework development.</span></span></p>
<p><span class="koboSpan" id="kobo.43.1">Many development</span><a id="_idIndexMarker002"/><span class="koboSpan" id="kobo.44.1"> hours were invested into connecting the mechanisms between the JavaScript engines and the browser web APIs. </span><span class="koboSpan" id="kobo.44.2">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.45.1">Figure 1</span></em></span><em class="italic"><span class="koboSpan" id="kobo.46.1">.1</span></em><span class="koboSpan" id="kobo.47.1">, we see a simplified view of how this </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">interaction happens:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer016">
<span class="koboSpan" id="kobo.49.1"><img alt="Figure 1.1: Interaction between the JavaScript engine and web APIs" src="image/Figure_1.1_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.50.1">Figure 1.1: Interaction between the JavaScript engine and web APIs</span></p>
<p><span class="koboSpan" id="kobo.51.1">The framework</span><a id="_idIndexMarker003"/><span class="koboSpan" id="kobo.52.1"> code and its internal technologies, such as the virtual DOM, use the DOM and its components to make the web application experience possible. </span><span class="koboSpan" id="kobo.52.2">The web has its own approach to the MVC architecture, with DOM and web API events interacting with Controllers defined in JavaScript. </span><span class="koboSpan" id="kobo.52.3">The Controllers interface with Views written in HTML or templated HTML. </span><span class="koboSpan" id="kobo.52.4">Furthermore, in this paradigm, the components of the applications utilize a Model to model the data within them. </span><span class="koboSpan" id="kobo.52.5">Using this approach, we can later communicate with backend services to retrieve the data in a </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">particular manner.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">Each new JavaScript MVC framework tried to perfect its implementation or approach in various ways. </span><span class="koboSpan" id="kobo.54.2">About five years after the first MVC frameworks appeared and gained popularity, several new paradigms that focused on the </span><strong class="bold"><span class="koboSpan" id="kobo.55.1">observer</span></strong><span class="koboSpan" id="kobo.56.1"> software design pattern started gaining traction in the JavaScript community. </span><span class="koboSpan" id="kobo.56.2">This observer approach is a software design</span><a id="_idIndexMarker004"/><span class="koboSpan" id="kobo.57.1"> pattern in which an object maintains a list of its dependants, called observers. </span><span class="koboSpan" id="kobo.57.2">The object notifies</span><a id="_idIndexMarker005"/><span class="koboSpan" id="kobo.58.1"> the observers automatically of the state changes within it. </span><span class="koboSpan" id="kobo.58.2">At that time, </span><strong class="bold"><span class="koboSpan" id="kobo.59.1">Flux</span></strong><span class="koboSpan" id="kobo.60.1"> came about, which is an application architecture that concentrates on simplifying the hurdles faced within MVC. </span><span class="koboSpan" id="kobo.60.2">The burdens included dealing with views constantly needing to interact with the models, hard-to-debug, deeply nested logic, and the need for adequate testing solutions of </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">complex applications.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">In the observer pattern, we define subjects that include a collection of observers informing about state changes. </span><span class="koboSpan" id="kobo.62.2">The Flux architecture expanded this existing pattern to fit better with applications</span><a id="_idIndexMarker006"/><span class="koboSpan" id="kobo.63.1"> built on the web. </span><span class="koboSpan" id="kobo.63.2">In the case of the Flux pattern, it consists of </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">stores</span></strong><span class="koboSpan" id="kobo.65.1"> interacting with the state of a component. </span><span class="koboSpan" id="kobo.65.2">These stores get notified by a </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">dispatcher</span></strong><span class="koboSpan" id="kobo.67.1"> based on data coming from </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">actions</span></strong><span class="koboSpan" id="kobo.69.1"> that a user in the </span><strong class="bold"><span class="koboSpan" id="kobo.70.1">view</span></strong><span class="koboSpan" id="kobo.71.1"> took. </span><span class="koboSpan" id="kobo.71.2">Many JavaScript frameworks</span><a id="_idIndexMarker007"/><span class="koboSpan" id="kobo.72.1"> started adapting this pattern, ultimately simplifying how engineers structured their applications while still enforcing a set of applicable rules to keep the separation of concerns intact. </span><span class="koboSpan" id="kobo.72.2">The software patterns in all of these frameworks provide a clear separation of concerns between the interface, data model, and the application logic that integrates them. </span><span class="koboSpan" id="kobo.72.3">The Flux-based JavaScript frameworks introduced new concepts that emerged from the known MVC patterns. </span><span class="koboSpan" id="kobo.72.4">Still, both the MVC and Flux approaches focused on the principle of the separation of concerns in </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">application development.</span></span></p>
<p><span class="koboSpan" id="kobo.74.1">Furthermore, while simplifying</span><a id="_idIndexMarker008"/><span class="koboSpan" id="kobo.75.1"> ideas brought to light by Flux, a library called Redux inspired the next generation of frameworks to switch their approach to application state management. </span><span class="koboSpan" id="kobo.75.2">Instead</span><a id="_idIndexMarker009"/><span class="koboSpan" id="kobo.76.1"> of the Flux dispatchers, Redux frameworks rely on a single store with pure </span><strong class="bold"><span class="koboSpan" id="kobo.77.1">reducer</span></strong><span class="koboSpan" id="kobo.78.1"> functions, taking the current state and returning an updated state. </span><span class="koboSpan" id="kobo.78.2">Even today, frontend patterns are still maturing, and building for the web platform is becoming </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">increasingly easier.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">While there’s a lot to mention</span><a id="_idIndexMarker010"/><span class="koboSpan" id="kobo.81.1"> with regard to frontend technologies, JavaScript has also made a great impact in places outside of web browsers. </span><span class="koboSpan" id="kobo.81.2">We cover those areas in the </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">next section.</span></span></p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/><span class="koboSpan" id="kobo.83.1">Frameworks outside the web browser</span></h1>
<p><span class="koboSpan" id="kobo.84.1">Another monumental</span><a id="_idIndexMarker011"/><span class="koboSpan" id="kobo.85.1"> event during</span><a id="_idIndexMarker012"/><span class="koboSpan" id="kobo.86.1"> the appearance of the first</span><a id="_idIndexMarker013"/><span class="koboSpan" id="kobo.87.1"> frontend frameworks was the emergence of a new open source runtime called Node.js. </span><span class="koboSpan" id="kobo.87.2">Node.js allowed developers to use JavaScript to produce server-side scripts, deploy backend systems, build developer tools, and, more importantly, write frameworks using the same language as the one from the web browser. </span><span class="koboSpan" id="kobo.87.3">The unique combination of having JavaScript on both sides of the software stack created immense possibilities for software developers. </span><span class="koboSpan" id="kobo.87.4">This runtime has since spread into many directions beyond software applications, with frameworks for desktop application development, hardware I/O solutions, and </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">much more.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">JavaScript-built frameworks enabled the web platform to become one of the most important technologies within reach of billions of people. </span><span class="koboSpan" id="kobo.89.2">It’s almost impossible to imagine starting a new project without relying on the consistency and amiability of using a framework, and even the smallest tasks benefit significantly from using a cohesive and opinionated structure. </span><span class="koboSpan" id="kobo.89.3">However, even with the fast-paced evolution of the language and how we build web projects, it took quite a bit of time for JavaScript frameworks to emerge as fully encapsulated platforms that can aid developers in producing </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">efficient applications.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">JavaScript prevailed through the rise of mobile platforms, with multiple frameworks being created for mobile and existing systems integrating mobile benchmarks into their release process. </span><span class="koboSpan" id="kobo.91.2">The optimizations</span><a id="_idIndexMarker014"/><span class="koboSpan" id="kobo.92.1"> got to the hardware level, having the </span><strong class="bold"><span class="koboSpan" id="kobo.93.1">ARM </span></strong><span class="koboSpan" id="kobo.94.1">(</span><a href="https://arm.com"><span class="koboSpan" id="kobo.95.1">arm.com</span></a><span class="koboSpan" id="kobo.96.1">) processor architecture</span><a id="_idIndexMarker015"/><span class="koboSpan" id="kobo.97.1"> introduce optimizations to improve JavaScript performance in data type conversion, resulting in performance boosts for many JavaScript applications. </span><span class="koboSpan" id="kobo.97.2">That is quite a journey for a scripting language that started with small scripts on plain </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">web pages.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">Today, we can create fully fledged applications and services using the web platform by combining the power of web APIs, the JavaScript language, and technologies such as progressive web apps, using the frameworks that bring it all together. </span><span class="koboSpan" id="kobo.99.2">It is a fantastic time to start traversing the world of these JavaScript systems and using them to </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">our advantage.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">Now that we have an overview</span><a id="_idIndexMarker016"/><span class="koboSpan" id="kobo.102.1"> of how web development</span><a id="_idIndexMarker017"/><span class="koboSpan" id="kobo.103.1"> evolved, let’s take a look at how the code bases have changed </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">over time.</span></span></p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/><span class="koboSpan" id="kobo.105.1">The evolution of code bases</span></h1>
<p><span class="koboSpan" id="kobo.106.1">While learning</span><a id="_idIndexMarker018"/><span class="koboSpan" id="kobo.107.1"> about frameworks, it is fascinating to reflect on how building for the web has changed over time. </span><span class="koboSpan" id="kobo.107.2">This exploration helps us understand why we build web applications the way we do today and helps us learn from historical shifts. </span><span class="koboSpan" id="kobo.107.3">It also allows us to be more mindful concerning framework usability and development decisions when we take on large projects. </span><span class="koboSpan" id="kobo.107.4">As technology pushes forward, the requirements and expectations around how websites and web applications are built drastically change. </span><span class="koboSpan" id="kobo.107.5">Depending on how long someone has been involved in web development, they either experienced many rapidly evolving shifts to how the code bases are structured or were lucky enough to avoid the times when the tooling and the process were </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">highly tedious.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">Initially, the code bases</span><a id="_idIndexMarker019"/><span class="koboSpan" id="kobo.110.1"> comprised isolated frontend components stitched together, consisting of code repetition and mixes of coding patterns. </span><span class="koboSpan" id="kobo.110.2">Code organization, usage of software development patterns, and performance optimizations were not a primary focus for developers. </span><span class="koboSpan" id="kobo.110.3">The web application deployment process used to be rudimentary as well. </span><span class="koboSpan" id="kobo.110.4">In many cases, the websites were manually updated and did not use source control or version tracking. </span><span class="koboSpan" id="kobo.110.5">Testing was also highly manual and would only exist in a few projects that were large enough to enable it. </span><span class="koboSpan" id="kobo.110.6">This was before deployment pipelines with continuous integration, deployment automation, and advanced testing infrastructure, rigorously verified every change. </span><span class="koboSpan" id="kobo.110.7">There used to be a time when developers had to optimize their CSS selectors for </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">performance reasons.</span></span></p>
<p><span class="koboSpan" id="kobo.112.1">Luckily, productivity and workflows rapidly started to improve once the industry started focusing more on building complex applications. </span><span class="koboSpan" id="kobo.112.2">Today we have source control, we have a myriad of testing and deployment tools to choose from, and we have established software paradigms that considerably improve our lives as developers and vastly improve the quality of the projects we build. </span><span class="koboSpan" id="kobo.112.3">Improvements to JavaScript engines unlocked new pathways</span><a id="_idIndexMarker020"/><span class="koboSpan" id="kobo.113.1"> for frameworks, and enhancements</span><a id="_idIndexMarker021"/><span class="koboSpan" id="kobo.114.1"> to web browsers</span><a id="_idIndexMarker022"/><span class="koboSpan" id="kobo.115.1"> fixed slow DOM interactivity with techniques such as the </span><strong class="bold"><span class="koboSpan" id="kobo.116.1">virtual DOM</span></strong><span class="koboSpan" id="kobo.117.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.118.1">Shadow DOM</span></strong><span class="koboSpan" id="kobo.119.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.120.1">Web Components</span></strong><span class="koboSpan" id="kobo.121.1">. </span><span class="koboSpan" id="kobo.121.2">These days, frontend frameworks have a better client platform to target as well, and the more established and improved web standards make it possible to perform much more complex operations. </span><span class="koboSpan" id="kobo.121.3">For example, with</span><a id="_idIndexMarker023"/><span class="koboSpan" id="kobo.122.1"> the help of WebAssembly (</span><a href="https://webassembly.org"><span class="koboSpan" id="kobo.123.1">webassembly.org</span></a><span class="koboSpan" id="kobo.124.1">) standards, we can now run low-level code with improved performance, all within </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">the browser.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">As part of all these developments and growth in popularity, the web application development workflow got a lot more complex in many ways. </span><span class="koboSpan" id="kobo.126.2">Almost at every point of interaction with a web application project, there is a tooling set designed to improve our workflow. </span><span class="koboSpan" id="kobo.126.3">Some examples of this would be Git source control, various pre- and post-processors of our files, code editors with plugins, browser extensions, and many more. </span><span class="koboSpan" id="kobo.126.4">Here we have an example that illustrates the key components</span><a id="_idIndexMarker024"/><span class="koboSpan" id="kobo.127.1"> of a modern web application code base structure, in this case, generated </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">by </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.129.1">SvelteKit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer017">
<span class="koboSpan" id="kobo.131.1"><img alt="Figure 1.2: SvelteKit code base structure" src="image/Figure_1.2_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.132.1">Figure 1.2: SvelteKit code base structure</span></p>
<p><span class="koboSpan" id="kobo.133.1">We will go over SvelteKit later</span><a id="_idIndexMarker025"/><span class="koboSpan" id="kobo.134.1"> in the </span><em class="italic"><span class="koboSpan" id="kobo.135.1">Frameworks that use React</span></em><span class="koboSpan" id="kobo.136.1"> section of this chapter, and even if you have never used Svelte, this project file tree will look very familiar if you work with other frameworks. </span><span class="koboSpan" id="kobo.136.2">This dynamic structure of tools enables flexibility when it comes to switching out certain functionality. </span><span class="koboSpan" id="kobo.136.3">For example, </span><em class="italic"><span class="koboSpan" id="kobo.137.1">Prettier</span></em><span class="koboSpan" id="kobo.138.1"> can be substituted for another code formatting tool if need be, while the rest of the project structure remains the same and functions as </span><span class="No-Break"><span class="koboSpan" id="kobo.139.1">it was.</span></span></p>
<p><span class="koboSpan" id="kobo.140.1">With the establishment of the first frameworks in JavaScript, we experienced the introduction of a build step into our projects, which meant that either external or bundled tooling would</span><a id="_idIndexMarker026"/><span class="koboSpan" id="kobo.141.1"> help run or build</span><a id="_idIndexMarker027"/><span class="koboSpan" id="kobo.142.1"> the application. </span><span class="koboSpan" id="kobo.142.2">Today, this build step, popularized by </span><strong class="bold"><span class="koboSpan" id="kobo.143.1">Webpack</span></strong><span class="koboSpan" id="kobo.144.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">esbuild</span></strong><span class="koboSpan" id="kobo.146.1">, is almost impossible to avoid. </span><span class="koboSpan" id="kobo.146.2">As part of this build step, we fetch application dependencies using package managers, process CSS, create</span><a id="_idIndexMarker028"/><span class="koboSpan" id="kobo.147.1"> code bundles, and run various optimization steps to make our app run fast and consume the least bandwidth. </span><span class="koboSpan" id="kobo.147.2">The ecosystem also introduced JavaScript transpilers, which are a type of source-to-source code compiler. </span><span class="koboSpan" id="kobo.147.3">They are used to take one particular syntax, which could consist of more modern features or include additional features, and convert them</span><a id="_idIndexMarker029"/><span class="koboSpan" id="kobo.148.1"> to be compatible with broadly accepted JavaScript syntax. </span><span class="koboSpan" id="kobo.148.2">Transpilers, such as </span><strong class="bold"><span class="koboSpan" id="kobo.149.1">Babel</span></strong><span class="koboSpan" id="kobo.150.1">, began to see everyday use, integrated with the build step in many projects; this pattern generally motivated the use of the latest language features while also supporting old browser engines. </span><span class="koboSpan" id="kobo.150.2">These days, transpilation and build steps apply to files beyond JavaScript, as well as files such as CSS and specific </span><span class="No-Break"><span class="koboSpan" id="kobo.151.1">templating formats.</span></span></p>
<p><span class="koboSpan" id="kobo.152.1">Integrating with the build step are the package managers, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">npm</span></strong><span class="koboSpan" id="kobo.154.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">yarn</span></strong><span class="koboSpan" id="kobo.156.1">, which play an essential role in resolving project dependencies. </span><span class="koboSpan" id="kobo.156.2">If you want to bootstrap a workflow with a framework, you will likely rely on the package manager to initialize the framework structure and its dependencies. </span><span class="koboSpan" id="kobo.156.3">For new projects, it is almost impossible to have a sensible framework workflow without using a package manager or some form of dependency resolution. </span><span class="koboSpan" id="kobo.156.4">As the project grows, the package manager facilitates the organization of newer dependencies while keeping track of updates to modules that are already in use. </span><span class="koboSpan" id="kobo.156.5">These days text editors, such as Visual Studio Code and IntelliJ WebStorm, adapt to our code bases and provide excellent tooling to enable source control of our code. </span><span class="koboSpan" id="kobo.156.6">The editors rely on built-in features and external plugins that encourage better formatting, easier debugging, and </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">framework-specific improvements.</span></span></p>
<p><span class="koboSpan" id="kobo.158.1">The code bases will keep changing as technology develops further, and the tools will keep improving to enable us to develop applications more quickly. </span><span class="koboSpan" id="kobo.158.2">Regarding the framework organization, we can expect higher levels of abstractions that simplify the way we do web development. </span><span class="koboSpan" id="kobo.158.3">Many programming languages, such as Java and Swift, have pre-defined development workflows encapsulating all aspects of development. </span><span class="koboSpan" id="kobo.158.4">JavaScript code bases so far have been an exception to these rules and allowed for high levels of flexibility. </span><span class="koboSpan" id="kobo.158.5">This trend is going to continue for many more years as the rapid pace of tooling and innovation in web development is not slowing down </span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">at all.</span></span></p>
<p><span class="koboSpan" id="kobo.160.1">Now that we understand how the JavaScript ecosystem</span><a id="_idIndexMarker030"/><span class="koboSpan" id="kobo.161.1"> has evolved and how codebases have changed over time, let us explore what JavaScript frameworks offer in terms of frontend, backend, testing, </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">and beyond.</span></span></p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/><span class="koboSpan" id="kobo.163.1">Types of JavaScript frameworks and their benefits</span></h1>
<p><span class="koboSpan" id="kobo.164.1">Though it is challenging</span><a id="_idIndexMarker031"/><span class="koboSpan" id="kobo.165.1"> to compare all the subtle differences of every framework</span><a id="_idIndexMarker032"/><span class="koboSpan" id="kobo.166.1"> out there in the ecosystem, we can cover several frameworks that significantly impact the developer community or offer a unique approach to solving a particular problem. </span><span class="koboSpan" id="kobo.166.2">The expanded knowledge of the tools helps us notice specific patterns in these frameworks regarding the different strategies for developer experience and </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">feature sets.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">There are still ways to build apps and websites without frameworks, but many developers prefer to use established and opinionated frameworks even with the given overhead and learning curves. </span><span class="koboSpan" id="kobo.168.2">If you follow the JavaScript community, you will find that it is always passionately abuzz with discussions around frameworks, so let us dive deeper into the needs and benefits of </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">framework use.</span></span></p>
<p><span class="koboSpan" id="kobo.170.1">The frameworks provide good levels of abstraction to write high-level code without rewriting low-level functionality. </span><span class="koboSpan" id="kobo.170.2">Developers can be much more involved in business and product logic and iterate faster on new features. </span><span class="koboSpan" id="kobo.170.3">To give an example, up until recently, writing the code to make an asynchronous web request with proper error handling was a very time-consuming task without the aid of a good</span><a id="_idIndexMarker033"/><span class="koboSpan" id="kobo.171.1"> abstraction. </span><span class="koboSpan" id="kobo.171.2">Now that we have the Fetch API (</span><a href="https://fetch.spec.whatwg.org"><span class="koboSpan" id="kobo.172.1">fetch.spec.whatwg.org</span></a><span class="koboSpan" id="kobo.173.1">), this is a much easier endeavor, but Fetch is only part of the story, so the rest of the web APIs, especially the ones from earlier times, still benefit from good abstractions. </span><span class="koboSpan" id="kobo.173.2">In cases where we choose to write low-level code, it is a much better approach to find ways to write that code within the framework boundaries. </span><span class="koboSpan" id="kobo.173.3">This way it is tested and maintained within the primitives of the framework. </span><span class="koboSpan" id="kobo.173.4">This yields the benefits of avoiding extra maintenance and ensuring all the usages of that code are still behind sensible abstractions. </span><span class="koboSpan" id="kobo.173.5">Some backend frameworks approach this by providing extensible interfaces to hook into framework internals through plugins or extending the </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">default behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.175.1">Developing software with groups of people is a challenging endeavor, so small and large teams can benefit from integrating a framework into the engineering workflow. </span><span class="koboSpan" id="kobo.175.2">The provided structure of abstractions generally results in much more well-architected systems, given the limits of how developers can write high-level components. </span><span class="koboSpan" id="kobo.175.3">The key benefit is enabling everyone involved in the task to understand the code base better and conveniently spend less time deliberating refactors and adding </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">new code.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">Now that we have our abstracted high-level code, we can cherish another benefit of frameworks – the performance optimizations they enable. </span><span class="koboSpan" id="kobo.177.2">Writing performant code that works in all provided use cases takes skill and takes away significant time from the project at hand. </span><span class="koboSpan" id="kobo.177.3">Even the most knowledgeable developers would only be able to come up with good enough solutions in a short amount of time. </span><span class="koboSpan" id="kobo.177.4">With frameworks, especially open source ones, you benefit from many minds put together to solve performance bottlenecks, overcome typical encumbrances, and continue to benefit from improvements as the framework develops. </span><span class="koboSpan" id="kobo.177.5">The performance benefits come from optimized low-level and well-structured high-level components; notably, some frameworks will guard against code that will slow down </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">the application.</span></span></p>
<p><span class="koboSpan" id="kobo.179.1">Frameworks make integrating</span><a id="_idIndexMarker034"/><span class="koboSpan" id="kobo.180.1"> with external systems, such as databases, external APIs, or specific components, easier. </span><span class="koboSpan" id="kobo.180.2">For instance, some web frameworks can integrate directly with the GraphQL data query language, simplifying backend systems’ interaction. </span><span class="koboSpan" id="kobo.180.3">It’s not just the ease of use, but also these integrations enable safe interaction with components such as databases, which helps avoid problematic queries that can be slow or harmful to execute. </span><span class="koboSpan" id="kobo.180.4">For frontend projects, it is important to always keep up with the latest web standards, and this is where frameworks provide another </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">integration benefit.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">Finally, as with all software, support plays an important role. </span><span class="koboSpan" id="kobo.182.2">Another reason a project may use an established framework is the available support channels through paid, volunteer, and open source help. </span><span class="koboSpan" id="kobo.182.3">The shared knowledge of these systems enables developers to help each other build systems and makes it easier to hire new developers who are familiar with these </span><span class="No-Break"><span class="koboSpan" id="kobo.183.1">existing systems.</span></span></p>
<p><span class="koboSpan" id="kobo.184.1">As we see, frameworks benefit</span><a id="_idIndexMarker035"/><span class="koboSpan" id="kobo.185.1"> us in countless ways – let us recap with these exact reasons. </span><span class="koboSpan" id="kobo.185.2">Here’s what frameworks allow us </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">to do:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.187.1">Focus on business logic and writing </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">high-level code</span></span></li>
<li><span class="koboSpan" id="kobo.189.1">Write less code and follow code conventions defined by </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">the framework</span></span></li>
<li><span class="koboSpan" id="kobo.191.1">Benefit from performance gains and rely on </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">future optimizations</span></span></li>
<li><span class="koboSpan" id="kobo.193.1">Develop the project with good architecture, abstractions, </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">and organization</span></span></li>
<li><span class="koboSpan" id="kobo.195.1">Easily integrate with external systems such as databases and </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">external APIs</span></span></li>
<li><span class="koboSpan" id="kobo.197.1">Ability to rely on security fixes, audits, </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">and patches</span></span></li>
<li><span class="koboSpan" id="kobo.199.1">Improve developer workflow using framework-specific toolings, such as text-editor integrations and </span><span class="No-Break"><span class="koboSpan" id="kobo.200.1">command-line utilities</span></span></li>
<li><span class="koboSpan" id="kobo.201.1">Ability to debug issues easily by relying on detailed error messages and </span><span class="No-Break"><span class="koboSpan" id="kobo.202.1">consistent logging</span></span></li>
<li><span class="koboSpan" id="kobo.203.1">Rely on external support from framework authors and </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">the community</span></span></li>
<li><span class="koboSpan" id="kobo.205.1">Hire more developers who are already accustomed to working with the framework of our choice or with </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">similar experience</span></span></li>
<li><span class="koboSpan" id="kobo.207.1">Develop better user experiences by leveraging the framework </span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">feature set</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.209.1">While a lot of JavaScript frameworks</span><a id="_idIndexMarker036"/><span class="koboSpan" id="kobo.210.1"> focus on the developer experience, the user experience can sometimes suffer from the overhead of these systems. </span><span class="koboSpan" id="kobo.210.2">This is usually relevant in frontend projects – an example of this would be loading a complex web application on budget mobile devices. </span><span class="koboSpan" id="kobo.210.3">In backend systems, this can be seen when the APIs are not able to keep up with request load and reliably scale with </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">traffic spikes.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">Even if the systems </span><a id="_idIndexMarker037"/><span class="koboSpan" id="kobo.213.1">are skillfully built in both of these cases, the framework of choice might not be optimized to cover all use cases. </span><span class="koboSpan" id="kobo.213.2">I believe the next iteration of the framework ecosystem will largely focus on the user experience aspects, which means making load times faster, shipping less JavaScript over the network, and ensuring the web applications we create work seamlessly on all platforms. </span><span class="koboSpan" id="kobo.213.3">In the following sections, we will examine some of the most popular frameworks that enable these benefits for web </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">application developers.</span></span></p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/><span class="koboSpan" id="kobo.215.1">Frontend frameworks</span></h2>
<p><span class="koboSpan" id="kobo.216.1">Since JavaScript frameworks</span><a id="_idIndexMarker038"/><span class="koboSpan" id="kobo.217.1"> originated in the browser, let us look at modern frontend frameworks as our </span><span class="No-Break"><span class="koboSpan" id="kobo.218.1">first exploration.</span></span></p>
<h3><span class="koboSpan" id="kobo.219.1">Ember.js</span></h3>
<p><span class="koboSpan" id="kobo.220.1">Suppose we trace</span><a id="_idIndexMarker039"/><span class="koboSpan" id="kobo.221.1"> the roots</span><a id="_idIndexMarker040"/><span class="koboSpan" id="kobo.222.1"> of the first JavaScript frameworks through the origins of libraries such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Prototype.js</span></strong><span class="koboSpan" id="kobo.224.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">jQuery</span></strong><span class="koboSpan" id="kobo.226.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">script.aculo.us</span></strong><span class="koboSpan" id="kobo.228.1">. </span><span class="koboSpan" id="kobo.228.2">In that case, we</span><a id="_idIndexMarker041"/><span class="koboSpan" id="kobo.229.1"> will eventually arrive at </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">SproutCore</span></strong><span class="koboSpan" id="kobo.231.1">, a framework used by Apple and a handful of other companies to build some of the most complex web experiences many </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">years ago.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">Today this early SproutCore project has influenced the </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">Ember.js</span></strong><span class="koboSpan" id="kobo.235.1"> framework. </span><span class="koboSpan" id="kobo.235.2">Ember continues to be a highly opinionated</span><a id="_idIndexMarker042"/><span class="koboSpan" id="kobo.236.1"> piece of software that allows us to build applications with defined components, services, models, and a powerful router. </span><span class="koboSpan" id="kobo.236.2">Like many frameworks we will discuss in this chapter, Ember comes with its own command-line tooling, which helps developers quickly get started on the basics of the application and later generate more code quickly as the project scope grows. </span><span class="koboSpan" id="kobo.236.3">The usefulness of the provided framework tooling is immense. </span><span class="koboSpan" id="kobo.236.4">The CLI encapsulates the code generation steps and enables a way to run common framework commands, such as running tests or serving application files. </span><span class="koboSpan" id="kobo.236.5">With Ember, developers get a complete set of tools such as auto-reload, browser</span><a id="_idIndexMarker043"/><span class="koboSpan" id="kobo.237.1"> developer tooling, and a package called Ember Data, which helps manage the API-to-model relationship through adapters and serializers. </span><span class="koboSpan" id="kobo.237.2">Ultimately, Ember has a steeper learning curve than other frameworks, but its highly opinionated concepts guide developers</span><a id="_idIndexMarker044"/><span class="koboSpan" id="kobo.238.1"> toward highly functional </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">web applications.</span></span></p>
<h3><span class="koboSpan" id="kobo.240.1">Angular</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.241.1">Angular</span></strong><span class="koboSpan" id="kobo.242.1"> is another framework</span><a id="_idIndexMarker045"/><span class="koboSpan" id="kobo.243.1"> with a large following. </span><span class="koboSpan" id="kobo.243.2">With TypeScript</span><a id="_idIndexMarker046"/><span class="koboSpan" id="kobo.244.1"> at its core, it is often used as a subset system for other full stack web frameworks. </span><span class="koboSpan" id="kobo.244.2">Angular provides its opinionated approach to component-based architecture. </span><span class="koboSpan" id="kobo.244.3">Angular has a complex history of rewrites but is now a more streamlined project with a stable feature set. </span><span class="koboSpan" id="kobo.244.4">Angular’s template syntax extends HTML by adding expressions and new attributes. </span><span class="koboSpan" id="kobo.244.5">At its core, it uses the pattern of dependency injection. </span><span class="koboSpan" id="kobo.244.6">The latest versions of this framework offer a variety of binding techniques, including event, property, and </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">two-way binding.</span></span></p>
<h3><span class="koboSpan" id="kobo.246.1">Vue.js</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.247.1">Vue.js</span></strong><span class="koboSpan" id="kobo.248.1">, also written in TypeScript, was created</span><a id="_idIndexMarker047"/><span class="koboSpan" id="kobo.249.1"> by borrowing</span><a id="_idIndexMarker048"/><span class="koboSpan" id="kobo.250.1"> the good elements of Angular. </span><span class="koboSpan" id="kobo.250.2">Developers love Vue’s simplicity within its component</span><a id="_idIndexMarker049"/><span class="koboSpan" id="kobo.251.1"> system, syntax, and general ease of use. </span><span class="koboSpan" id="kobo.251.2">It utilizes the </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">Model–View–Viewmodel </span></strong><span class="koboSpan" id="kobo.253.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.254.1">MVVM</span></strong><span class="koboSpan" id="kobo.255.1">) pattern, where a View communicates with a ViewModel using some data binding technique. </span><span class="koboSpan" id="kobo.255.2">In the case of Vue.js, for its data, it uses different techniques through HTML classes, HTML elements, and custom binding element attributes to achieve this. </span><span class="koboSpan" id="kobo.255.3">The purpose of the given ViewModel is to handle as much of the View’s interaction logic and be the middle structure between the presentation</span><a id="_idIndexMarker050"/><span class="koboSpan" id="kobo.256.1"> logic and the application’s business logic. </span><span class="koboSpan" id="kobo.256.2">Besides using HTML authoring, Vue has the </span><strong class="bold"><span class="koboSpan" id="kobo.257.1">Single-File Component</span></strong><span class="koboSpan" id="kobo.258.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.259.1">SFC</span></strong><span class="koboSpan" id="kobo.260.1">) format (</span><a href="https://vuejs.org/api/sfc-spec.html"><span class="koboSpan" id="kobo.261.1">vuejs.org/api/sfc-spec.html</span></a><span class="koboSpan" id="kobo.262.1">) to encapsulate all aspects of the components – scripts, styling, and templating</span><a id="_idIndexMarker051"/><span class="koboSpan" id="kobo.263.1"> into one file. </span><span class="koboSpan" id="kobo.263.2">The SFC happens as part of the build step and helps the components avoid runtime compilation, scopes the CSS styles</span><a id="_idIndexMarker052"/><span class="koboSpan" id="kobo.264.1"> to the component, enables</span><a id="_idIndexMarker053"/><span class="koboSpan" id="kobo.265.1"> Hot Module Replacement, and </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">much more.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.267.1">About TypeScript</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.268.1">TypeScript</span></strong><span class="koboSpan" id="kobo.269.1"> is a superset of JavaScript, enabling</span><a id="_idIndexMarker054"/><span class="koboSpan" id="kobo.270.1"> features such as static typing and language extensions in many JavaScript environments. </span><span class="koboSpan" id="kobo.270.2">In recent years, TypeScript has become popular among framework authors and developers. </span><span class="koboSpan" id="kobo.270.3">It is also widely supported by many code editors and IDEs. </span><span class="koboSpan" id="kobo.270.4">Initially released in 2012 and inspired by ActionScript and Java, TypeScript is a superset of JavaScript, enabling features such as static typing and language extensions in many JavaScript environments. </span><span class="koboSpan" id="kobo.270.5">It helps catch errors at compile time instead of runtime error handling. </span><span class="koboSpan" id="kobo.270.6">Files with the file extensions </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">.ts</span></strong><span class="koboSpan" id="kobo.272.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">.tsx</span></strong><span class="koboSpan" id="kobo.274.1"> are TypeScript files that must be compiled to JavaScript to be used in </span><span class="No-Break"><span class="koboSpan" id="kobo.275.1">most environments.</span></span></p>
<h3><span class="koboSpan" id="kobo.276.1">Frameworks that use React</span></h3>
<p><span class="koboSpan" id="kobo.277.1">These days, we hear about </span><strong class="bold"><span class="koboSpan" id="kobo.278.1">React</span></strong><span class="koboSpan" id="kobo.279.1"> a lot; even though it is a user interface</span><a id="_idIndexMarker055"/><span class="koboSpan" id="kobo.280.1"> component library</span><a id="_idIndexMarker056"/><span class="koboSpan" id="kobo.281.1"> by itself, it has become the cornerstone for many frontend frameworks, such as </span><strong class="bold"><span class="koboSpan" id="kobo.282.1">Gatsby</span></strong><span class="koboSpan" id="kobo.283.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.284.1">Remix</span></strong><span class="koboSpan" id="kobo.285.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.286.1">Next.js</span></strong><span class="koboSpan" id="kobo.287.1">, and others. </span><span class="koboSpan" id="kobo.287.2">As part of its introduction, React also debuted </span><strong class="bold"><span class="koboSpan" id="kobo.288.1">JSX</span></strong><span class="koboSpan" id="kobo.289.1">, its own set of extensions to JavaScript, making it possible</span><a id="_idIndexMarker057"/><span class="koboSpan" id="kobo.290.1"> to define</span><a id="_idIndexMarker058"/><span class="koboSpan" id="kobo.291.1"> the components</span><a id="_idIndexMarker059"/><span class="koboSpan" id="kobo.292.1"> in a similar-looking syntax</span><a id="_idIndexMarker060"/><span class="koboSpan" id="kobo.293.1"> to HTML. </span><span class="koboSpan" id="kobo.293.2">For instance, the static site framework Gatsby relies on React’s state management and the nested component architecture to compose its web pages. </span><span class="koboSpan" id="kobo.293.3">With Gatsby, developers can multiplex data, utilizing GraphQL, from content management systems, e-commerce sources, and </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">other places.</span></span></p>
<p><span class="koboSpan" id="kobo.295.1">Following along our React route, we get to Remix, which bundles a full stack solution with features for both the server and the client, plus a compiler and a request handler. </span><span class="koboSpan" id="kobo.295.2">Remix provides solutions for the View and Controller aspects of the application and relies on the Node.js module ecosystem for the rest, giving flexibility to the developers who need custom solutions from project to project. </span><span class="koboSpan" id="kobo.295.3">Based on the experience of creating and maintaining the </span><strong class="source-inline"><span class="koboSpan" id="kobo.296.1">react-router</span></strong><span class="koboSpan" id="kobo.297.1"> project for many years, the creators of Remix were able to come up with powerful abstractions while taking advantage of the browser’s web APIs instead of investing in new concepts. </span><span class="koboSpan" id="kobo.297.2">To give an example, if you choose Remix for your project, you will find yourself using web standard APIs more than some of the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">other frameworks.</span></span></p>
<p><span class="koboSpan" id="kobo.299.1">Next.js is our next React-based framework, which extends the use of the React component architecture as well by bringing it to the server with its built-in server rendering. </span><span class="koboSpan" id="kobo.299.2">The server-rendered components allow for a pre-rendered page to be sent to the client, resulting in the client only spending resources on initializing the interactive components. </span><span class="koboSpan" id="kobo.299.3">The framework provides the concept of pages, which allows for simpler routing implementations with lazy loading and enables automatic code-splitting. </span><span class="koboSpan" id="kobo.299.4">Combining all these features results in a fantastic user experience with fast loading times. </span><span class="koboSpan" id="kobo.299.5">In addition, the deployed applications rank highly when indexed by search engines, a feature that makes this framework </span><span class="No-Break"><span class="koboSpan" id="kobo.300.1">stand out.</span></span></p>
<p><span class="koboSpan" id="kobo.301.1">While talking about React frameworks, it is worth mentioning </span><strong class="bold"><span class="koboSpan" id="kobo.302.1">Solid.js</span></strong><span class="koboSpan" id="kobo.303.1">. </span><span class="koboSpan" id="kobo.303.2">It’s a newer library that creates frontend</span><a id="_idIndexMarker061"/><span class="koboSpan" id="kobo.304.1"> interfaces. </span><span class="koboSpan" id="kobo.304.2">Solid’s benchmarks outperform React and others. </span><span class="koboSpan" id="kobo.304.3">It uses features such as JSX, but with a few key differences. </span><span class="koboSpan" id="kobo.304.4">With Solid, there is no virtual DOM</span><a id="_idIndexMarker062"/><span class="koboSpan" id="kobo.305.1"> and no concept of hooks. </span><span class="koboSpan" id="kobo.305.2">Instead, it relies on the pattern of </span><strong class="bold"><span class="koboSpan" id="kobo.306.1">signals</span></strong><span class="koboSpan" id="kobo.307.1"> to update the real DOM nodes, while utilizing</span><a id="_idIndexMarker063"/><span class="koboSpan" id="kobo.308.1"> reactive primitives. </span><span class="koboSpan" id="kobo.308.2">As part of Solid’s approach, it offers the </span><strong class="bold"><span class="koboSpan" id="kobo.309.1">SolidStart</span></strong><span class="koboSpan" id="kobo.310.1"> app framework, which is very comparable to Next.js. </span><span class="koboSpan" id="kobo.310.2">It consists of core support components – </span><em class="italic"><span class="koboSpan" id="kobo.311.1">router</span></em><span class="koboSpan" id="kobo.312.1">, </span><em class="italic"><span class="koboSpan" id="kobo.313.1">session</span></em><span class="koboSpan" id="kobo.314.1">, </span><em class="italic"><span class="koboSpan" id="kobo.315.1">document</span></em><span class="koboSpan" id="kobo.316.1">, </span><em class="italic"><span class="koboSpan" id="kobo.317.1">actions</span></em><span class="koboSpan" id="kobo.318.1">, </span><em class="italic"><span class="koboSpan" id="kobo.319.1">data</span></em><span class="koboSpan" id="kobo.320.1">, </span><em class="italic"><span class="koboSpan" id="kobo.321.1">entrypoints</span></em><span class="koboSpan" id="kobo.322.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.323.1">server</span></em><span class="koboSpan" id="kobo.324.1"> – these</span><a id="_idIndexMarker064"/><span class="koboSpan" id="kobo.325.1"> are integrated</span><a id="_idIndexMarker065"/><span class="koboSpan" id="kobo.326.1"> together as part </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">of SolidStart.</span></span></p>
<h3><span class="koboSpan" id="kobo.328.1">SvelteKit</span></h3>
<p><span class="koboSpan" id="kobo.329.1">Like SolidStart, there is also </span><strong class="bold"><span class="koboSpan" id="kobo.330.1">SvelteKit</span></strong><span class="koboSpan" id="kobo.331.1">, a new framework powered by the </span><strong class="bold"><span class="koboSpan" id="kobo.332.1">Svelte</span></strong><span class="koboSpan" id="kobo.333.1"> user interface library. </span><span class="koboSpan" id="kobo.333.2">SvelteKit</span><a id="_idIndexMarker066"/><span class="koboSpan" id="kobo.334.1"> framework</span><a id="_idIndexMarker067"/><span class="koboSpan" id="kobo.335.1"> generator script </span><a id="_idIndexMarker068"/><span class="koboSpan" id="kobo.336.1">assembles a project skeleton, which helps you quickly get started and gives you full flexibility over the configuration of the compiler and the TypeScript settings. </span><span class="koboSpan" id="kobo.336.2">When setting up SvelteKit, we can use JavaScript with JSDoc formatting or TypeScript directly to write frontend applications. </span><span class="koboSpan" id="kobo.336.3">As part of the Svelte integration, it equips developers with a compiler that pre-builds the app before the client processes it. </span><span class="koboSpan" id="kobo.336.4">Like Vue’s SFC format, Svelte uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">.svelte</span></strong><span class="koboSpan" id="kobo.338.1"> files, which encapsulate the components with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.339.1">&lt;script&gt;</span></strong><span class="koboSpan" id="kobo.340.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.341.1">&lt;style&gt;</span></strong><span class="koboSpan" id="kobo.342.1">, and HTML tags that are coded together. </span><span class="koboSpan" id="kobo.342.2">These</span><a id="_idIndexMarker069"/><span class="koboSpan" id="kobo.343.1"> are compiled</span><a id="_idIndexMarker070"/><span class="koboSpan" id="kobo.344.1"> into JavaScript output generated by </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">the compiler.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.346.1">About Vite</span></p>
<p class="callout"><strong class="bold"><span class="koboSpan" id="kobo.347.1">Vite</span></strong><span class="koboSpan" id="kobo.348.1"> (</span><a href="https://vitejs.dev"><span class="koboSpan" id="kobo.349.1">vitejs.dev</span></a><span class="koboSpan" id="kobo.350.1">) is framework-agnostic tooling, meaning</span><a id="_idIndexMarker071"/><span class="koboSpan" id="kobo.351.1"> it can be used in conjunction with different frameworks. </span><span class="koboSpan" id="kobo.351.2">It uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">vite.config.js</span></strong><span class="koboSpan" id="kobo.353.1"> configuration file. </span><span class="koboSpan" id="kobo.353.2">Mainly, it is used as a build tool for frontend projects. </span><span class="koboSpan" id="kobo.353.3">It is optimized for speed and it achieves that speed by providing a development server with Hot Module Replacement and a bundler that optimizes JavaScript output using </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">esbuild (</span></span><a href="https://esbuild.github.io"><span class="No-Break"><span class="koboSpan" id="kobo.355.1">esbuild.github.io</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.356.1">).</span></span></p>
<h3><span class="koboSpan" id="kobo.357.1">Framework features and patterns</span></h3>
<p><span class="koboSpan" id="kobo.358.1">To understand what most modern frameworks enable, we need to understand the following acronyms</span><a id="_idIndexMarker072"/> <span class="No-Break"><span class="koboSpan" id="kobo.359.1">and features:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.360.1">Single-Page Application</span></strong><span class="koboSpan" id="kobo.361.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.362.1">SPA</span></strong><span class="koboSpan" id="kobo.363.1">): An early term that describes an application that purely uses JavaScript</span><a id="_idIndexMarker073"/><span class="koboSpan" id="kobo.364.1"> and other frontend frameworks for all interactions with reduced </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">browser routing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.366.1">Server-Side Rendering</span></strong><span class="koboSpan" id="kobo.367.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.368.1">SSR</span></strong><span class="koboSpan" id="kobo.369.1">): Pre-rendered components on the server side, which are transferred</span><a id="_idIndexMarker074"/><span class="koboSpan" id="kobo.370.1"> for JavaScript hydration on the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">client side.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.372.1">Client-Side Rendering</span></strong><span class="koboSpan" id="kobo.373.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.374.1">CSR</span></strong><span class="koboSpan" id="kobo.375.1">): Rendering of components using JavaScript, purely</span><a id="_idIndexMarker075"/><span class="koboSpan" id="kobo.376.1"> on the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">browser’s side.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.378.1">Static Site Generator</span></strong><span class="koboSpan" id="kobo.379.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.380.1">SSG</span></strong><span class="koboSpan" id="kobo.381.1">): The concept of pre-generating</span><a id="_idIndexMarker076"/><span class="koboSpan" id="kobo.382.1"> all pages from source for faster rendering and better search </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">engine optimization.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.384.1">Deferred Static Generator</span></strong><span class="koboSpan" id="kobo.385.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.386.1">DSG</span></strong><span class="koboSpan" id="kobo.387.1">): Renders content on the server</span><a id="_idIndexMarker077"/><span class="koboSpan" id="kobo.388.1"> when initiated by a request to </span><span class="No-Break"><span class="koboSpan" id="kobo.389.1">the server.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.390.1">Incremental Static Regeneration</span></strong><span class="koboSpan" id="kobo.391.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.392.1">ISR</span></strong><span class="koboSpan" id="kobo.393.1">): Another pattern of static content generation. </span><span class="koboSpan" id="kobo.393.2">In this case, the static </span><a id="_idIndexMarker078"/><span class="koboSpan" id="kobo.394.1">generation is triggered by updates by some </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">external trigger.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.396.1">Content Security Policy</span></strong><span class="koboSpan" id="kobo.397.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.398.1">CSP</span></strong><span class="koboSpan" id="kobo.399.1">): Configuration for serving scripts that helps protect against</span><a id="_idIndexMarker079"/><span class="koboSpan" id="kobo.400.1"> cross-site </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">scripting attacks.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.402.1">Hot Module Replacement</span></strong><span class="koboSpan" id="kobo.403.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.404.1">HMR</span></strong><span class="koboSpan" id="kobo.405.1">): Technique to replace JavaScript modules as the application</span><a id="_idIndexMarker080"/><span class="koboSpan" id="kobo.406.1"> is running in the browser, mainly used to improve development speed and avoid </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">page reloads.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.408.1">Single-File Component</span></strong><span class="koboSpan" id="kobo.409.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.410.1">SFC</span></strong><span class="koboSpan" id="kobo.411.1">): A file structure that encapsulates all aspects of a usable</span><a id="_idIndexMarker081"/><span class="koboSpan" id="kobo.412.1"> framework component, such as styling, templating, logic, </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">and more.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.414.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.415.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.416.1">MVC</span></strong><span class="koboSpan" id="kobo.417.1">): A design pattern focusing on the separation of concerns in various</span><a id="_idIndexMarker082"/><span class="koboSpan" id="kobo.418.1"> types of applications. </span><span class="koboSpan" id="kobo.418.2">It approaches this separation by using the following: a Model that represents the data, a View that provides the user with an interface, and a Controller that is the intermediary between the views and </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">the models.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.420.1">Model-View-ViewModel</span></strong><span class="koboSpan" id="kobo.421.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.422.1">MVVM</span></strong><span class="koboSpan" id="kobo.423.1">): Another design pattern that also focuses on the separation</span><a id="_idIndexMarker083"/><span class="koboSpan" id="kobo.424.1"> of concerns in applications, but the approach to these separations is different. </span><span class="koboSpan" id="kobo.424.2">In this case, there are still Views and Models, similar to MVC. </span><span class="koboSpan" id="kobo.424.3">However, the ViewModel acts as a connection between those types. </span><span class="koboSpan" id="kobo.424.4">This approach uses two-way data</span><a id="_idIndexMarker084"/><span class="koboSpan" id="kobo.425.1"> binding between the View and </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">the Model.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.427.1">Besides the features and their acronyms, here is a helpful visual describing</span><a id="_idIndexMarker085"/><span class="koboSpan" id="kobo.428.1"> both the MVC and </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">MVVM</span></span><span class="No-Break"><a id="_idIndexMarker086"/></span><span class="No-Break"><span class="koboSpan" id="kobo.430.1"> patterns:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer018">
<span class="koboSpan" id="kobo.431.1"><img alt="Figure 1.3: MVC versus MVVM patterns" src="image/Figure_1.3_B19014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.432.1">Figure 1.3: MVC versus MVVM patterns</span></p>
<p><span class="koboSpan" id="kobo.433.1">During the renaissance</span><a id="_idIndexMarker087"/><span class="koboSpan" id="kobo.434.1"> of frontend frameworks, an open source project called </span><strong class="bold"><span class="koboSpan" id="kobo.435.1">TodoMVC</span></strong><span class="koboSpan" id="kobo.436.1"> was established to help developers compare frameworks based on the same To Do app, where anyone can send pull requests with their framework implementations. </span><span class="koboSpan" id="kobo.436.2">Besides comparing different frameworks, the project also popularized the approach to complex code organization in JavaScript. </span><span class="koboSpan" id="kobo.436.3">Now with the emergence of these new frameworks, we need another iteration of TodoMVC to continue aiding developers with comparisons of </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">these systems.</span></span></p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/><span class="koboSpan" id="kobo.438.1">Backend frameworks</span></h2>
<p><span class="koboSpan" id="kobo.439.1">Switching gears</span><a id="_idIndexMarker088"/><span class="koboSpan" id="kobo.440.1"> from the frontend, let us look at some of the backend frameworks. </span><span class="koboSpan" id="kobo.440.2">Node.js plays a vital role in the JavaScript ecosystem, powering a variety of frameworks that allow us to develop backend services. </span><span class="koboSpan" id="kobo.440.3">Similar to the frontend, it is impossible to cover all of them, but in this section, we will examine </span><strong class="bold"><span class="koboSpan" id="kobo.441.1">hapi.js</span></strong><span class="koboSpan" id="kobo.442.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.443.1">express</span></strong><span class="koboSpan" id="kobo.444.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.445.1">Sails.js</span></strong><span class="koboSpan" id="kobo.446.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.447.1">nest.js</span></strong><span class="koboSpan" id="kobo.448.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">and </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.450.1">AdonisJS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.452.1">Hapi.js</span></h3>
<p><span class="koboSpan" id="kobo.453.1">As part of framework</span><a id="_idIndexMarker089"/><span class="koboSpan" id="kobo.454.1"> explorations over the years, I had the opportunity to work</span><a id="_idIndexMarker090"/><span class="koboSpan" id="kobo.455.1"> with these frameworks in a professional capacity and on small hobby projects. </span><span class="koboSpan" id="kobo.455.2">I started with hapi.js, which is a good example of a well-crafted Node.js framework, built with essential defaults that allow it to craft a server backend quickly. </span><span class="koboSpan" id="kobo.455.3">It has a unique approach of avoiding middlewares and relying on external modules. </span><span class="koboSpan" id="kobo.455.4">As part of its core, it already has validation rules, parsing, logging, and more built right into it. </span><span class="koboSpan" id="kobo.455.5">hapi.js doesn’t lock down extensibility; developers can create plugins and register them to execute as part of the different parts of the request lifecycle. </span><span class="koboSpan" id="kobo.455.6">Hapi.js’ mission puts an emphasis on avoiding unexpected consequences when combining a lot of application logic. </span><span class="koboSpan" id="kobo.455.7">This is evident in how hapi.js approaches dependency management and </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">module namespacing.</span></span></p>
<h3><span class="koboSpan" id="kobo.457.1">Express</span></h3>
<p><span class="koboSpan" id="kobo.458.1">In stark contrast to hapi.js, the Node.js</span><a id="_idIndexMarker091"/><span class="koboSpan" id="kobo.459.1"> ecosystem also has a framework called </span><strong class="bold"><span class="koboSpan" id="kobo.460.1">Express</span></strong><span class="koboSpan" id="kobo.461.1">, which is largely an unopinionated</span><a id="_idIndexMarker092"/><span class="koboSpan" id="kobo.462.1"> approach to building backend services. </span><span class="koboSpan" id="kobo.462.2">Thousands of projects and tools usually use Express for its routing, content parsers, and high-performance reasons. </span><span class="koboSpan" id="kobo.462.3">Being flexible in almost every way and with support for over a dozen templating engines, Express is the introductory framework for developers starting with Node.js development. </span><span class="koboSpan" id="kobo.462.4">For example, a popular MVC framework, Sails.js, builds upon Express’ functionality to offer API generation, database ORM solutions, and support for building real-time features. </span><span class="koboSpan" id="kobo.462.5">Generally, it is a good solution for those appreciating the middleware patterns of Express, while having a more structured approach</span><a id="_idIndexMarker093"/><span class="koboSpan" id="kobo.463.1"> to building </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">backend</span></span><span class="No-Break"><a id="_idIndexMarker094"/></span><span class="No-Break"><span class="koboSpan" id="kobo.465.1"> systems.</span></span></p>
<h3><span class="koboSpan" id="kobo.466.1">NestJS</span></h3>
<p><span class="koboSpan" id="kobo.467.1">NestJS, not to be confused </span><a id="_idIndexMarker095"/><span class="koboSpan" id="kobo.468.1">with Next.js, is another server-side framework</span><a id="_idIndexMarker096"/><span class="koboSpan" id="kobo.469.1"> that is worth mentioning. </span><span class="koboSpan" id="kobo.469.2">It is similar to Vue, and Angular inspired its approach to application structure, but in this case, for a backend system. </span><span class="koboSpan" id="kobo.469.3">By default, it utilizes Express as its default HTTP server and creates an abstraction layer that allows for the ability to change the third-party modules, enabling the developers to swap</span><a id="_idIndexMarker097"/><span class="koboSpan" id="kobo.470.1"> out Express for some other HTTP framework such as </span><strong class="bold"><span class="koboSpan" id="kobo.471.1">Fastify</span></strong><span class="koboSpan" id="kobo.472.1">. </span><span class="koboSpan" id="kobo.472.2">In NestJS, we see a similar pattern of dependency injection, which enables developers to architect contained modules. </span><span class="koboSpan" id="kobo.472.3">These modules can be reused, overridden, and mocked </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">in tests.</span></span></p>
<h3><span class="koboSpan" id="kobo.474.1">AdonisJS</span></h3>
<p><span class="koboSpan" id="kobo.475.1">Our final Node.js framework</span><a id="_idIndexMarker098"/><span class="koboSpan" id="kobo.476.1"> for this section is AdonisJS. </span><span class="koboSpan" id="kobo.476.2">Built entirely</span><a id="_idIndexMarker099"/><span class="koboSpan" id="kobo.477.1"> with TypeScript, it is packed with features that you would expect from a mature framework, such as the ORM based on the Active Record pattern, schema validators, extensive authentication support, and much more. </span><span class="koboSpan" id="kobo.477.2">The built-in and first-party plugin features provide solutions for many mundane problems of backend building. </span><span class="koboSpan" id="kobo.477.3">AdonisJS also packs a custom templating engine to render HTML layouts. </span><span class="koboSpan" id="kobo.477.4">As an added bonus, AdonisJS has straight-to-the-point and clear documentation, which is a joy to read </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">and explore.</span></span></p>
<h3><span class="koboSpan" id="kobo.479.1">Fresh</span></h3>
<p><span class="koboSpan" id="kobo.480.1">Given the focus</span><a id="_idIndexMarker100"/><span class="koboSpan" id="kobo.481.1"> on essential frameworks in the Node.js ecosystem, we should</span><a id="_idIndexMarker101"/><span class="koboSpan" id="kobo.482.1"> also mention a backend framework called </span><strong class="bold"><span class="koboSpan" id="kobo.483.1">Fresh</span></strong><span class="koboSpan" id="kobo.484.1">, which is powered by the </span><strong class="bold"><span class="koboSpan" id="kobo.485.1">Deno</span></strong><span class="koboSpan" id="kobo.486.1"> runtime. </span><span class="koboSpan" id="kobo.486.2">This runtime is built </span><a id="_idIndexMarker102"/><span class="koboSpan" id="kobo.487.1">using a combination of technologies – JavaScript, TypeScript, WebAssembly, and the Rust programming language. </span><span class="koboSpan" id="kobo.487.2">Fresh takes a simplistic approach with its emphasis on having no build steps, minimal configuration, and just-in-time rendering of components on the server. </span><span class="koboSpan" id="kobo.487.3">Routing</span><a id="_idIndexMarker103"/><span class="koboSpan" id="kobo.488.1"> is taken care of by creating files in the directories of your project, called File-system routing, a similar pattern in </span><span class="No-Break"><span class="koboSpan" id="kobo.489.1">other frameworks.</span></span></p>
<p><span class="koboSpan" id="kobo.490.1">Looking back at all the Node.js frameworks we covered in this section, there is a healthy framework diversity that delivers solutions for projects of </span><span class="No-Break"><span class="koboSpan" id="kobo.491.1">any type.</span></span></p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/><span class="koboSpan" id="kobo.492.1">Native frameworks</span></h2>
<p><span class="koboSpan" id="kobo.493.1">The knowledge</span><a id="_idIndexMarker104"/><span class="koboSpan" id="kobo.494.1"> of JavaScript also allows us to build for native operating system environments and interact with hardware platforms. </span><span class="koboSpan" id="kobo.494.2">The availability of the runtime in other environments makes it possible for us to create unique solutions that can help web developers apply their skills in areas beyond the browser. </span><span class="koboSpan" id="kobo.494.3">In this section, we cover some of the frameworks created for native </span><span class="No-Break"><span class="koboSpan" id="kobo.495.1">JavaScript development.</span></span></p>
<h3><span class="koboSpan" id="kobo.496.1">Electron</span></h3>
<p><span class="koboSpan" id="kobo.497.1">The idea of packaging</span><a id="_idIndexMarker105"/><span class="koboSpan" id="kobo.498.1"> a web app as a native</span><a id="_idIndexMarker106"/><span class="koboSpan" id="kobo.499.1"> app is not new, but it has been perfected with </span><strong class="bold"><span class="koboSpan" id="kobo.500.1">Electron</span></strong><span class="koboSpan" id="kobo.501.1">. </span><span class="koboSpan" id="kobo.501.2">Electron allows developers to use familiar frontend technologies to build fully capable cross-platform applications that run on popular desktop platforms. </span><span class="koboSpan" id="kobo.501.3">It has feature supports features such as auto-updates and inter-process communication, as well as having a collection of plugins that tap into operating system functionality. </span><span class="koboSpan" id="kobo.501.4">Besides the advanced framework features, it is beneficial to have a single code base targeting all the platforms, which helps with efficiently building new features and bug fixing. </span><span class="koboSpan" id="kobo.501.5">These days millions of people use applications built with Electron, in many</span><a id="_idIndexMarker107"/><span class="koboSpan" id="kobo.502.1"> cases without knowing it. </span><span class="koboSpan" id="kobo.502.2">Applications such as Microsoft Teams, Slack, 1Password, Discord, Figma, Notion, and many more utilize Electron. </span><span class="koboSpan" id="kobo.502.3">Even more examples</span><a id="_idIndexMarker108"/><span class="koboSpan" id="kobo.503.1"> can be found </span><span class="No-Break"><span class="koboSpan" id="kobo.504.1">at </span></span><a href="https://electronjs.org/apps"><span class="No-Break"><span class="koboSpan" id="kobo.505.1">electronjs.org/apps</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.506.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.507.1">React Native</span></h3>
<p><span class="koboSpan" id="kobo.508.1">Another framework</span><a id="_idIndexMarker109"/><span class="koboSpan" id="kobo.509.1"> that helps us create for native platforms is </span><strong class="bold"><span class="koboSpan" id="kobo.510.1">React Native</span></strong><span class="koboSpan" id="kobo.511.1">, which unlocks the world of mobile</span><a id="_idIndexMarker110"/><span class="koboSpan" id="kobo.512.1"> development to those experienced with JavaScript. </span><span class="koboSpan" id="kobo.512.2">Targeting iOS and Android mobile platforms, just like Electron on desktop, it brings all the benefits of React user-interface building blocks, a unified codebase, and a strong, </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">established community.</span></span></p>
<h3><span class="koboSpan" id="kobo.514.1">Johnny-Five</span></h3>
<p><span class="koboSpan" id="kobo.515.1">The Node.js ecosystem</span><a id="_idIndexMarker111"/><span class="koboSpan" id="kobo.516.1"> also offers hardware frameworks such as </span><strong class="bold"><span class="koboSpan" id="kobo.517.1">Johnny-Five</span></strong><span class="koboSpan" id="kobo.518.1">, which allows for creative learning</span><a id="_idIndexMarker112"/><span class="koboSpan" id="kobo.519.1"> use cases of robotics programming using JavaScript and the Firmata protocol. </span><span class="koboSpan" id="kobo.519.2">Johnny-Five is an IoT platform supporting over 30 hardware boards. </span><span class="koboSpan" id="kobo.519.3">Mainly, it offers interfaces to interact with LEDs, services, motors, switches, </span><span class="No-Break"><span class="koboSpan" id="kobo.520.1">and more.</span></span></p>
<p><span class="koboSpan" id="kobo.521.1">All the frameworks so far deal with building out application logic, but there are also other types of frameworks in JavaScript that play an important role in the development process – these would</span><a id="_idIndexMarker113"/><span class="koboSpan" id="kobo.522.1"> be the </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">testing frameworks.</span></span></p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/><span class="koboSpan" id="kobo.524.1">Testing frameworks</span></h2>
<p><span class="koboSpan" id="kobo.525.1">Testing frameworks</span><a id="_idIndexMarker114"/><span class="koboSpan" id="kobo.526.1"> in software development are essential for ensuring our projects function as expected. </span><span class="koboSpan" id="kobo.526.2">With JavaScript and its supported runtime environments, we have a much more challenging task at hand – we have to test in different browser engines and mock the native web APIs. </span><span class="koboSpan" id="kobo.526.3">In some cases, mocking built-in and external libraries can also be challenging. </span><span class="koboSpan" id="kobo.526.4">The asynchronous behavior of the language brings its own obstacles as well. </span><span class="koboSpan" id="kobo.526.5">Luckily, the JavaScript ecosystem came up with various testing frameworks addressing many software testing challenges – unit, integration, functional, end-to-end testing, and beyond. </span><span class="koboSpan" id="kobo.526.6">To name a few, </span><strong class="bold"><span class="koboSpan" id="kobo.527.1">Jest</span></strong><span class="koboSpan" id="kobo.528.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.529.1">Playwright</span></strong><span class="koboSpan" id="kobo.530.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">Vitest</span></strong><span class="koboSpan" id="kobo.532.1"> all offer great solutions to testing challenges. </span><span class="koboSpan" id="kobo.532.2">We will discuss </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">them next.</span></span></p>
<h3><span class="koboSpan" id="kobo.534.1">Jest</span></h3>
<p><span class="koboSpan" id="kobo.535.1">As we develop</span><a id="_idIndexMarker115"/><span class="koboSpan" id="kobo.536.1"> our web applications, we want to ensure that the components we build are functioning as intended; this is where a framework such as Jest comes in. </span><span class="koboSpan" id="kobo.536.2">Jest</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.537.1"> is a unit testing framework that integrates well into other projects. </span><span class="koboSpan" id="kobo.537.2">If we are given a project with one of the frameworks that we already saw in this chapter, Jest would equip us with reliable testing solutions. </span><span class="koboSpan" id="kobo.537.3">It is ergonomic, with minimal or zero configuration, and provides us with interfaces for easy mocking, object snapshotting, code coverage, and most importantly, an easy-to-understand API for organizing </span><span class="No-Break"><span class="koboSpan" id="kobo.538.1">our tests.</span></span></p>
<h3><span class="koboSpan" id="kobo.539.1">Vitest</span></h3>
<p><span class="koboSpan" id="kobo.540.1">Vitest is a similar</span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.541.1"> unit testing framework, offering the same interfaces</span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.542.1"> to mock modules in web projects. </span><span class="koboSpan" id="kobo.542.2">It focuses on speed and support for components of many frameworks, including Vue, React, Svelte, and even Web Components. </span><span class="koboSpan" id="kobo.542.3">It is designed for developer productivity and has a mode for smart test watching, a multi-threaded test runner, and a familiar </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">snapshotting mechanism.</span></span></p>
<h3><span class="koboSpan" id="kobo.544.1">Playwright</span></h3>
<p><span class="koboSpan" id="kobo.545.1">Besides unit testing, our software</span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.546.1"> projects benefit highly from end-to-end testing; this is where</span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.547.1"> a testing framework such as Playwright is a good contender. </span><span class="koboSpan" id="kobo.547.2">It delivers cross-browser and cross-platform testing for web applications. </span><span class="koboSpan" id="kobo.547.3">Playwright comes with a set of test interfaces to automate various browsers, including navigating to URLs and clicking buttons. </span><span class="koboSpan" id="kobo.547.4">Historically, this has been a challenging problem due to the asynchronous nature of web pages, but this framework is equipped with ways to avoid flaky tests through retries and </span><span class="No-Break"><span class="koboSpan" id="kobo.548.1">await behavior.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">Depending on the requirements of the JavaScript project you are involved in, you might have to create new testing workflows or customize the existing testing infrastructure to fit your use case – this is where experience in building testing frameworks would </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">be advantageous.</span></span></p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/><span class="koboSpan" id="kobo.551.1">Framework showcase</span></h2>
<p><span class="koboSpan" id="kobo.552.1">Here’s a breakdown of the frameworks we covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.553.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.554.1">These are some of the noteworthy</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.555.1"> web application frameworks</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.556.1"> that we will be focusing on in </span><span class="No-Break"><span class="koboSpan" id="kobo.557.1">this book:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="3">
<p><strong class="bold"><span class="koboSpan" id="kobo.558.1">Frontend + </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.559.1">Full Stack</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.560.1">Name</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.561.1">Released</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.562.1">AngularJS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.563.1">2010</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.564.1">Obsolete MVC framework with features such as two-way data binding and dependency injection. </span><span class="koboSpan" id="kobo.564.2">Part of the original MEAN </span><span class="No-Break"><span class="koboSpan" id="kobo.565.1">software stack.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.566.1">Bootstrap</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.567.1">2011</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.568.1">Basic framework that allows utilizing HTML, CSS, and JavaScript to create responsive mobile-first websites and can be integrated with other systems to power interfaces for web applications. </span><span class="koboSpan" id="kobo.568.2">Bootstrap defines its own layout primitives and provides a great set of built-in components for forms and user </span><span class="No-Break"><span class="koboSpan" id="kobo.569.1">interface elements.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.570.1">Ember.js</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.571.1">2011</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.572.1">Component-service architecture SPA framework with regular releases and opinionated conventions over </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">configuration characteristics.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.574.1">Vue.js</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.575.1">2014</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.576.1">Lightweight MVVM component-based framework with an easy learning curve – uses the virtual DOM. </span><span class="koboSpan" id="kobo.576.2">Comes with its own reactivity system and support for state-changing </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">CSS transitions.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.578.1">Gatsby</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.579.1">2015</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.580.1">Advanced static site generator using React and Node.js. </span><span class="koboSpan" id="kobo.580.2">Includes various modes of rendering pages and serving dynamic websites. </span><span class="koboSpan" id="kobo.580.3">Heavily relies on GraphQL for data retrieval. </span><span class="koboSpan" id="kobo.580.4">Variety of plugins in </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">the ecosystem.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.582.1">Angular</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.583.1">2016</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.584.1">Component-based framework with dependency injection, templating, and additive directives. </span><span class="koboSpan" id="kobo.584.2">Has a slew of extra features to enable internationalization and accessibility. </span><span class="koboSpan" id="kobo.584.3">Full rewrite of the original </span><span class="No-Break"><span class="koboSpan" id="kobo.585.1">AngularJS. </span><span class="koboSpan" id="kobo.585.2">TypeScript-based.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.586.1">Next.js</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.587.1">2016</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.588.1">Server-side rendering framework using React as its rendering interface. </span><span class="koboSpan" id="kobo.588.2">Supports multiple data request methods. </span><span class="koboSpan" id="kobo.588.3">A lot of features are built right into </span><span class="No-Break"><span class="koboSpan" id="kobo.589.1">the framework.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.590.1">Nuxt.js</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.591.1">2016</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.592.1">Framework that uses Vue.js as its core, with a combination of Webpack, Babel.js, and other components. </span><span class="koboSpan" id="kobo.592.2">Focuses on delivering an optimized </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">application experience.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.594.1">SolidStart</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.595.1">2019</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.596.1">Framework for Solid.js applications. </span><span class="koboSpan" id="kobo.596.2">Supports all methods of component rendering. </span><span class="koboSpan" id="kobo.596.3">Optimizations for code splitting and providing the best Solid.js experience. </span><span class="koboSpan" id="kobo.596.4">Solid.js works with real DOM nodes, supports Web Components, and has </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">efficient rendering.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.598.1">Remix</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.599.1">2021</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.600.1">Full stack, UI-focused framework written in TypeScript. </span><span class="koboSpan" id="kobo.600.2">Consists of a browser, server, compiler, and HTTP handler. </span><span class="koboSpan" id="kobo.600.3">Built on top of React and includes a powerful application router. </span><span class="koboSpan" id="kobo.600.4">Offers many modes of rendering and </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">file-based routing.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.602.1">SvelteKit</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.603.1">2022</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.604.1">Framework to develop Svelte-based apps. </span><span class="koboSpan" id="kobo.604.2">Uses the Svelte compiler and the Vite tooling. </span><span class="koboSpan" id="kobo.604.3">Does not rely on the Virtual DOM and supports all modes of </span><span class="No-Break"><span class="koboSpan" id="kobo.605.1">rendering components.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.606.1">Figure 1.4: Examples of frontend and full stack frameworks</span></p>
<p><span class="koboSpan" id="kobo.607.1">These are some of the backend frameworks</span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.608.1"> that will serve as good examples and help us learn certain framework </span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">development patterns:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="3">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.610.1">Backend</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.611.1">Name</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.612.1">Released</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.613.1">hapi.js</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.614.1">2009</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.615.1">Framework for building backend web services of any kind, with a convention-over-configuration mantra. </span><span class="koboSpan" id="kobo.615.2">Supports a lot of advanced features such as API validation, payload parsing, and more right out of </span><span class="No-Break"><span class="koboSpan" id="kobo.616.1">the box.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.617.1">Express</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.618.1">2010</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.619.1">One of the most popular Node.js frameworks for building RESTful APIs, integrated with many modules in the ecosystem. </span><span class="koboSpan" id="kobo.619.2">Used in real-world applications and many developer tools. </span><span class="koboSpan" id="kobo.619.3">Part of the MEAN stack. </span><span class="koboSpan" id="kobo.619.4">Includes helpers for caching, redirection, and support for many </span><span class="No-Break"><span class="koboSpan" id="kobo.620.1">templating engines.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.621.1">Sails.js</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.622.1">2012</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.623.1">Enterprise-grade MVC framework built on top of Express and Socket.io. </span><span class="koboSpan" id="kobo.623.2">Comes with ORM support and a powerful CLI to generate parts </span><span class="No-Break"><span class="koboSpan" id="kobo.624.1">of projects.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.625.1">NestJS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.626.1">2018</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.627.1">Server-side application framework with a modular approach. </span><span class="koboSpan" id="kobo.627.2">It follows certain patterns of Angular and includes a lot of built-in features, such as WebSocket, GraphQL, and </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">microservice support.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.629.1">AdonisJS</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.630.1">2019</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.631.1">All-inclusive backend framework for APIs and web applications written in and for TypeScript-based code bases. </span><span class="koboSpan" id="kobo.631.2">Comes with its own components for ORM, templating, </span><span class="No-Break"><span class="koboSpan" id="kobo.632.1">and routing.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.633.1">Fresh</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.634.1">2022</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.635.1">Framework written using the Deno runtime. </span><span class="koboSpan" id="kobo.635.2">With no build steps, minimal configuration, and just-in-time rendering. </span><span class="koboSpan" id="kobo.635.3">Uses the island architecture pattern, focusing on reducing work on the client. </span><span class="koboSpan" id="kobo.635.4">Independent server-side components are rendered using HTML and sent over to </span><span class="No-Break"><span class="koboSpan" id="kobo.636.1">the client.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.637.1">Figure 1.5: Examples of backend frameworks</span></p>
<p><span class="koboSpan" id="kobo.638.1">Other frameworks that use frontend</span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.639.1"> technologies to target native or hardware</span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.640.1"> development are </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">as follows:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="3">
<p><strong class="bold"><span class="koboSpan" id="kobo.642.1">Native + </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.643.1">Hardware</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.644.1">Name</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.645.1">Released</span></span></p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.646.1">Johnny-Five</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.647.1">2012</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.648.1">Robotics framework for IoT development. </span><span class="koboSpan" id="kobo.648.2">Allows developers to interact with hardware modules with an </span><span class="No-Break"><span class="koboSpan" id="kobo.649.1">easy-to-use API.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.650.1">Electron</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.651.1">2013</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.652.1">Popular cross-platform desktop application framework that uses web technologies. </span><span class="koboSpan" id="kobo.652.2">Uses the architecture from the Chromium project, which enables developers to interact with the application and the </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">renderer processes.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.654.1">React Native</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.655.1">2015</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.656.1">Application framework for iOS, Android, and other platforms. </span><span class="koboSpan" id="kobo.656.2">Uses familiar concepts from React to build interfaces. </span><span class="koboSpan" id="kobo.656.3">Mainly useful for web developers who want a single code base for their application and don’t want to use native toolkits to build these apps. </span><span class="koboSpan" id="kobo.656.4">Has a large community and </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">plugin ecosystem.</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.658.1">Figure 1.6: Examples of native and hardware frameworks</span></p>
<p><span class="koboSpan" id="kobo.659.1">Here are testing framework</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.660.1"> examples, which are useful to integrate and use in web </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">application projects:</span></span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="3">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.662.1">Testing</span></strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.663.1">Jest</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.664.1">2019</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.665.1">Zero-configuration testing framework that universally supports many JavaScript environments, including TypeScript, Node.js, </span><span class="No-Break"><span class="koboSpan" id="kobo.666.1">and more.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.667.1">Playwright</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.668.1">2020</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.669.1">End-to-end testing and automation framework supporting cross-platform testing in the Chromium, WebKit, and Firefox browsers. </span><span class="koboSpan" id="kobo.669.2">Helps developers quickly and reliably conduct instrument tests for any </span><span class="No-Break"><span class="koboSpan" id="kobo.670.1">web application.</span></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.671.1">Vitest</span></strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><span class="koboSpan" id="kobo.672.1">2022</span></span></p>
</td>
<td class="No-Table-Style">
<p><span class="koboSpan" id="kobo.673.1">Unit test framework, part of the Vite ecosystem. </span><span class="koboSpan" id="kobo.673.2">Comes with ESM, JSX, and TypeScript support. </span><span class="koboSpan" id="kobo.673.3">Developed in conjunction </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">with Vue.js</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.675.1">Figure 1.7: Examples of testing frameworks</span></p>
<p><span class="koboSpan" id="kobo.676.1">One of the best resources to keep up with the current direction of framework development is </span><a href="https://stateofjs.com"><span class="koboSpan" id="kobo.677.1">stateofjs.com</span></a><span class="koboSpan" id="kobo.678.1">. </span><span class="koboSpan" id="kobo.678.2">It is a yearly survey with results from thousands of developers, and it provides an outlook of where the technologies are shifting. </span><span class="koboSpan" id="kobo.678.3">For example, if we look at the frontend framework rankings of 2022 (</span><a href="https://2022.stateofjs.com/en-US/libraries/front-end-frameworks"><span class="koboSpan" id="kobo.679.1">2022.stateofjs.com/en-US/libraries/front-end-frameworks</span></a><span class="koboSpan" id="kobo.680.1">), we can already start to see the retention and interest in React slowly dropping, which could potentially indicate that the industry is slowly shifting to other solutions. </span><span class="koboSpan" id="kobo.680.2">Due to this constant change of use, awareness, and popularity of all these frameworks, instead of focusing on many of the frameworks of today, we are going to cover the core patterns that could be applicable to new frameworks in the future. </span><span class="koboSpan" id="kobo.680.3">These patterns will be helpful to you while you explore creating your </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">own framework.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">Now it’s time to try out some</span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.683.1"> of the frameworks mentioned in this chapter using the GitHub repository for this book mentioned in the </span><em class="italic"><span class="koboSpan" id="kobo.684.1">Technical requirements</span></em><span class="koboSpan" id="kobo.685.1"> section. </span><span class="koboSpan" id="kobo.685.2">You can follow </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">these steps:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.687.1">Install Node.js version 20 </span><span class="No-Break"><span class="koboSpan" id="kobo.688.1">from </span></span><a href="http://nodejs.org"><span class="No-Break"><span class="koboSpan" id="kobo.689.1">nodejs.org</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.690.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.691.1">Clone the repository </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">from </span></span><a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework"><span class="No-Break"><span class="koboSpan" id="kobo.693.1">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.694.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.695.1">Using your terminal, change directories into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.696.1">chapter1</span></strong><span class="koboSpan" id="kobo.697.1"> directory of </span><span class="No-Break"><span class="koboSpan" id="kobo.698.1">the repository.</span></span></li>
<li><span class="koboSpan" id="kobo.699.1">Run </span><strong class="source-inline"><span class="koboSpan" id="kobo.700.1">npm install</span></strong><span class="koboSpan" id="kobo.701.1"> and then </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">npm start</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.704.1">Follow the interactive prompt to run </span><span class="No-Break"><span class="koboSpan" id="kobo.705.1">the examples.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.706.1">The showcase</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.707.1"> focuses on reproducing the same example based on the framework type. </span><span class="koboSpan" id="kobo.707.2">All frontend frameworks demonstrate the same component written in different structures. </span><span class="koboSpan" id="kobo.707.3">Note that some examples might take a while to install </span><span class="No-Break"><span class="koboSpan" id="kobo.708.1">and run.</span></span></p>
<p><span class="koboSpan" id="kobo.709.1">In the final part of this chapter, we shall take a look at my notable personal experiences with frameworks in </span><span class="No-Break"><span class="koboSpan" id="kobo.710.1">web development.</span></span></p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/><span class="koboSpan" id="kobo.711.1">My experiences with frameworks</span></h1>
<p><span class="koboSpan" id="kobo.712.1">My professional web development</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.713.1"> career initially started with building basic websites before established frameworks or libraries were around. </span><span class="koboSpan" id="kobo.713.2">Looking ahead, I want to share my framework experiences of professionally utilizing them and contributing to some of the open source ones. </span><span class="koboSpan" id="kobo.713.3">These days, the accumulated knowledge gathered from these experiences has helped me better assess framework usefulness and introduce new software paradigms into my work. </span><span class="koboSpan" id="kobo.713.4">Many find it challenging to keep up with the latest innovations in the JavaScript field, but building even the smallest projects helps one grow as a developer in </span><span class="No-Break"><span class="koboSpan" id="kobo.714.1">many ways.</span></span></p>
<p><span class="koboSpan" id="kobo.715.1">Here are some examples from the full stack development areas that helped me become much more effective as a </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">web developer.</span></span></p>
<h3><span class="koboSpan" id="kobo.717.1">Frontend development</span></h3>
<p><span class="koboSpan" id="kobo.718.1">The first few professional</span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.719.1"> websites I built were developed for Internet Explorer 6 and early versions of Firefox web browsers. </span><span class="koboSpan" id="kobo.719.2">As we learned from this chapter, there were no frameworks for building web applications at the time, and I had to utilize the few libraries at my disposal. </span><span class="koboSpan" id="kobo.719.3">These would help add interactivity for components such as image galleries and </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.720.1">dynamic page layouts. </span><span class="koboSpan" id="kobo.720.2">Luckily, when my focus switched to larger projects, the </span><strong class="bold"><span class="koboSpan" id="kobo.721.1">jQuery</span></strong><span class="koboSpan" id="kobo.722.1"> frontend library came along and started growing in popularity. </span><span class="koboSpan" id="kobo.722.2">Even to this day, jQuery is still a popular tool of choice for a large chunk of websites. </span><span class="koboSpan" id="kobo.722.3">I now had the opportunity to hand-craft a basic framework, which could be reused from project to project. </span><span class="koboSpan" id="kobo.722.4">This series of scripts was incredibly convenient and foreshadowed the bright future of frameworks that we have today. </span><span class="koboSpan" id="kobo.722.5">It was clear that the trend of single-page JavaScript applications was heading towards structured and </span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">opinionated solutions.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">During one of my large early-on projects – specifically the Firefox Accounts frontend (</span><a href="http://accounts.firefox.com"><span class="koboSpan" id="kobo.725.1">accounts.firefox.com</span></a><span class="koboSpan" id="kobo.726.1">), I had the opportunity to use </span><strong class="bold"><span class="koboSpan" id="kobo.727.1">Backbone.js</span></strong><span class="koboSpan" id="kobo.728.1">, with the help of jQuery and multiple extension</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.729.1"> libraries to make it more suitable for large projects. </span><span class="koboSpan" id="kobo.729.2">The Firefox Accounts frontend, which is serving millions of users, is still using Backbone.js to this day. </span><span class="koboSpan" id="kobo.729.3">The way the Backbone.js framework is structured allows for a soft dependency on jQuery, so it did feel like a natural continuation of my earlier approach to web application development. </span><span class="koboSpan" id="kobo.729.4">My key takeaways from this experience are that Backbone.js wasn’t the perfect answer to the challenges of frontend web applications, but it was beneficial in many ways. </span><span class="koboSpan" id="kobo.729.5">For example, it allowed the project to stay flexible with the ever-evolving JavaScript ecosystem and helped diverse developers work on the application while following a solid set of application guidelines. </span><span class="koboSpan" id="kobo.729.6">The unique opportunity to work on the client and the integrated services of the Firefox web browser taught me how to produce JavaScript components for a desktop client that runs on millions of </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">computers worldwide.</span></span></p>
<p><span class="koboSpan" id="kobo.731.1">Throughout many professional projects, I had the chance to work with Ember.js, Angular, and various React frameworks. </span><span class="koboSpan" id="kobo.731.2">I was impressed by how empowering these frameworks can be on these occasions. </span><span class="koboSpan" id="kobo.731.3">A notable</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.732.1"> mention from my experience is the </span><strong class="bold"><span class="koboSpan" id="kobo.733.1">Meteor</span></strong><span class="koboSpan" id="kobo.734.1"> web framework, released in early 2012. </span><span class="koboSpan" id="kobo.734.2">One of the big selling features of Meteor was the isomorphic or so-called </span><em class="italic"><span class="koboSpan" id="kobo.735.1">universal JavaScript</span></em><span class="koboSpan" id="kobo.736.1"> approach, where the code runs on both the client</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.737.1"> and the server. </span><span class="koboSpan" id="kobo.737.2">In many ways, we see similar approaches in popular frameworks today, where a full stack framework lets developers write JavaScript to develop on both sides of the stack. </span><span class="koboSpan" id="kobo.737.3">I have built a few applications and some plugins for this framework, and while it felt so easy to get started with Meteor, I have experienced hurdles while trying to build something that didn’t fit exactly into the scope of what Meteor supported, especially in the early releases of the framework. </span><span class="koboSpan" id="kobo.737.4">A particular example of fighting with the framework’s constraints was developing a feature with a synchronized document state across multiple clients. </span><span class="koboSpan" id="kobo.737.5">This ended up being challenging to implement with Meteor’s feature set at the time and had to be rebuilt with alternative tooling. </span><span class="koboSpan" id="kobo.737.6">Luckily this was not a critical project, but for times when it is important, it is a good idea to evaluate</span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.738.1"> whether the framework of your choice is the right tool for what you are trying </span><span class="No-Break"><span class="koboSpan" id="kobo.739.1">to build.</span></span></p>
<h3><span class="koboSpan" id="kobo.740.1">Backend development</span></h3>
<p><span class="koboSpan" id="kobo.741.1">During the early years</span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.742.1"> of Node.js, I had the chance to work on several projects utilizing the microservices architecture, and these involved using the Express and hapi frameworks. </span><span class="koboSpan" id="kobo.742.2">I felt the contrast between the open-ended approach of the express framework versus the rigorous set of rules and options that were defined in hapi.js. </span><span class="koboSpan" id="kobo.742.3">To give some examples, overriding and customizing certain behaviors in hapi.js was quite difficult, and keeping the framework up to date required difficult migrations to the </span><span class="No-Break"><span class="koboSpan" id="kobo.743.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.744.1">I still remember combing through the changelog of every new version of hapi.js, making sure not to miss any breaking changes that would make my projects dysfunctional. </span><span class="koboSpan" id="kobo.744.2">Even with the hardships of hapi.js, it did feel like the framework was providing a good set of abstractions. </span><span class="koboSpan" id="kobo.744.3">In many ways, following the existing examples from something like Flask in Python, hapi had the necessary components to build highly usable services. </span><span class="koboSpan" id="kobo.744.4">Meanwhile, my experiences with Express seemed more reminiscent of working with the jQuery and Backbone.js days. </span><span class="koboSpan" id="kobo.744.5">In the Express projects, I could have a highly flexible development environment, combining different Node.js modules to achieve what I wanted from the framework. </span><span class="koboSpan" id="kobo.744.6">This made me realize that the perfect framework for me would be something between Express and hapi, in the sense that it would allow me to stay creative, highly productive, and able to utilize the runtime ecosystem to the fullest, while at the same time having a strong opinionated framework core, which would keep my application efficient</span><a id="_idIndexMarker137"/> <span class="No-Break"><span class="koboSpan" id="kobo.745.1">and reliable.</span></span></p>
<h3><span class="koboSpan" id="kobo.746.1">Developer tooling and more</span></h3>
<p><span class="koboSpan" id="kobo.747.1">As part of my profession, I have always</span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.748.1"> been passionate about open source, so I focused my efforts on contributing</span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.749.1"> to developer tooling and testing frameworks. </span><span class="koboSpan" id="kobo.749.2">I have been a maintainer of </span><strong class="bold"><span class="koboSpan" id="kobo.750.1">Grunt.js</span></strong><span class="koboSpan" id="kobo.751.1"> (</span><a href="http://gruntjs.com"><span class="koboSpan" id="kobo.752.1">gruntjs.com</span></a><span class="koboSpan" id="kobo.753.1">), a JavaScript task runner for many years. </span><span class="koboSpan" id="kobo.753.2">Grunt.js has been a core component of frameworks, such as </span><strong class="bold"><span class="koboSpan" id="kobo.754.1">Yeoman</span></strong><span class="koboSpan" id="kobo.755.1">, and has been used as a tool</span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.756.1"> of choice in the early version of AngularJS. </span><span class="koboSpan" id="kobo.756.2">The task runner conventions in Node.js have changed a lot since then, but there is still a solid number of projects that use Grunt.js. </span><span class="koboSpan" id="kobo.756.3">Maintaining this project for many years feels similar to maintaining a large framework project – releasing new versions, keeping a stable API, supporting it through security bounties, and much more. </span><span class="koboSpan" id="kobo.756.4">There is also a huge list of issues, feature demands, pull requests, and plugins </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">to support.</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">In terms of my testing</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.759.1"> framework contributions, I was involved in developing the </span><strong class="bold"><span class="koboSpan" id="kobo.760.1">Intern.js</span></strong><span class="koboSpan" id="kobo.761.1"> testing framework (</span><a href="http://github.com/theintern"><span class="koboSpan" id="kobo.762.1">github.com/theintern</span></a><span class="koboSpan" id="kobo.763.1">), which enabled unit and functional testing for web applications. </span><span class="koboSpan" id="kobo.763.2">I was both the contributor and the consumer of this framework in my daily projects, which gave me a unique angle on the project. </span><span class="koboSpan" id="kobo.763.3">I was inspired to provide a good integration experience because it would aid my own projects. </span><span class="koboSpan" id="kobo.763.4">As part of this effort, besides learning how a testing framework is built, I focused on developing integration examples and documentation for other application frameworks. </span><span class="koboSpan" id="kobo.763.5">Covering many integration scenarios in the provided examples made it much easier for developers to integrate this testing system into </span><span class="No-Break"><span class="koboSpan" id="kobo.764.1">their applications.</span></span></p>
<p><span class="koboSpan" id="kobo.765.1">A final notable framework</span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.766.1"> from my personal experience would be with </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">voxel.js</span></strong><span class="koboSpan" id="kobo.768.1"> – an open source voxel game-building toolkit. </span><span class="koboSpan" id="kobo.768.2">While not that popular, it is a great example of creative use of JavaScript, combining both frontend and backend technologies. </span><span class="koboSpan" id="kobo.768.3">It is a framework built by a small team that fills in a niche for an audience of developers, who are looking into working on games and visualizations. </span><span class="koboSpan" id="kobo.768.4">voxel.js did not set out to be a world-changing framework; instead, it was a creative outlet for many to create. </span><span class="koboSpan" id="kobo.768.5">While exploring voxel.js in my personal project, I learned a lot about unique framework and module structures, and it was fun</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.769.1"> to experiment with systems that enable more </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">imaginative thinking.</span></span></p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/><span class="koboSpan" id="kobo.771.1">Contributing to new projects</span></h2>
<p><span class="koboSpan" id="kobo.772.1">These experiences with JavaScript frameworks</span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.773.1"> in frontend, backend, and developer systems were incredibly valuable to me as part of my career. </span><span class="koboSpan" id="kobo.773.2">I have learned the importance of following best practices, adhering to software patterns, and developing for various runtime environments, which ultimately helped me write better code and deliver successful projects. </span><span class="koboSpan" id="kobo.773.3">As part of this book, I am sharing my learnings and as much knowledge as possible for the next generation of devoted JavaScript developers to build and contribute to their own </span><span class="No-Break"><span class="koboSpan" id="kobo.774.1">framework projects.</span></span></p>
<p><span class="koboSpan" id="kobo.775.1">The projects that I have been involved in always had different origins. </span><span class="koboSpan" id="kobo.775.2">In my case, I had to work with both private and open source frameworks. </span><span class="koboSpan" id="kobo.775.3">In work projects, I have focused on combining open source tooling with the context of the larger business organization. </span><span class="koboSpan" id="kobo.775.4">This approach helped align the existing tooling with the requirements of particular projects. </span><span class="koboSpan" id="kobo.775.5">In the open source context, I have been lucky to contribute to projects that have improved the overall developer experience. </span><span class="koboSpan" id="kobo.775.6">In many of the scenarios, I got to work on projects that were innovative and were firsts of their kind in the JavaScript ecosystem. </span><span class="koboSpan" id="kobo.775.7">For example, when Grunt.js was coming along, there were task runner tools from other languages, but the JavaScript tools were in their inception. </span><span class="koboSpan" id="kobo.775.8">Contributing to voxel.js was a similar experience; as more HTML5 APIs and WebGL enable more advanced graphics on the web, it enabled voxel.js as a project and created the </span><span class="No-Break"><span class="koboSpan" id="kobo.776.1">contributor community.</span></span></p>
<p><span class="koboSpan" id="kobo.777.1">During my contributions to the Intern.js testing framework, the overall feeling was that there were not fully fledged testing frameworks that solved all of the needs of web application testing. </span><span class="koboSpan" id="kobo.777.2">The goal of this project was to create an all-in solution for testing using the same types of </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">testing APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.779.1">The framework that we create in this book focuses on the use of modern technologies, such as Web Components, intermixed with popular JavaScript libraries. </span><span class="koboSpan" id="kobo.779.2">The Web Components field does not feel as explored in the ecosystem just yet; therefore, with this book, we are taking aim to further widen the knowledge of these technologies among web developers. </span><span class="koboSpan" id="kobo.779.3">Besides expanding those skills, one of the greater goals is to make the framework development process more approachable and demystify the established </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">JavaScript</span></span><span class="No-Break"><a id="_idIndexMarker145"/></span><span class="No-Break"><span class="koboSpan" id="kobo.781.1"> systems.</span></span></p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/><span class="koboSpan" id="kobo.782.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.783.1">This first chapter began our exploration into how the web application development process has changed from pure basics into a full-fledged software platform. </span><span class="koboSpan" id="kobo.783.2">We have looked at how the innovations and challenges of the web shape the frameworks discussed in this chapter and play a huge role in offering a variety of useful features to web developers. </span><span class="koboSpan" id="kobo.783.3">As part of my career journey, working on various projects made me appreciate how much can be achieved by combining elegant patterns and the creative use of the JavaScript </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">programming language.</span></span></p>
<p><span class="koboSpan" id="kobo.785.1">As part of the framework showcase, it is evident that the ecosystem has a lot of options for the browser and other places where JavaScript runtime functions. </span><span class="koboSpan" id="kobo.785.2">However, there is always room for improvement in speed, features, and unique ideas, which can help us enhance the development processes. </span><span class="koboSpan" id="kobo.785.3">The significant part that stimulates this ecosystem is the ever-evolving web platform, development of the ECMAScript specification, and of course, the hard work of maintainers of runtimes such as Node.js </span><span class="No-Break"><span class="koboSpan" id="kobo.786.1">and Deno.</span></span></p>
<p><span class="koboSpan" id="kobo.787.1">In the upcoming chapters, we will dive deeper into software paradigms, focusing on framework organization and their architectural patterns. </span><span class="koboSpan" id="kobo.787.2">In </span><a href="B19014_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.788.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.789.1">, we are going to look at how frameworks are structured </span><span class="No-Break"><span class="koboSpan" id="kobo.790.1">and organized.</span></span></p>
</div>
</body></html>