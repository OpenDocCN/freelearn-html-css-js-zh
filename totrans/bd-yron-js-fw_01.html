<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-16"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>The Benefits of Different JavaScript Frameworks</h1>
<p>It has been over 25 years since JavaScript was first introduced into our web browsers. Since then, this technology has vastly changed how we interact with websites and applications, how we build APIs for backend systems, and even how we communicate with hardware platforms. JavaScript has become one of the most popular programming languages on the planet. To this day, JavaScript’s pace of evolution and rapid change is a popular topic of conversation among developers – it is a source of excitement and innovation. As a programming language, JavaScript has been ranked as the most popular among developers in the last 10 consecutive years and has been the key to client-side scripting for 98% of all websites. We cannot underestimate how much JavaScript and its closely related ECMAScript standardization have enabled the web to become the platform to host the next generation of software that can be accessed by billions of people. With these technologies, millions of businesses and individuals can easily build great applications, creative experiences, and complex software solutions. In many ways, the web platform has the potential to be the most vibrant and friendly developer ecosystem in the whole world.</p>
<p>JavaScript frameworks are the straightforward way millions of web developers build projects today. Due to their popularity and ease of use, frameworks allow developers to quickly make product ideas come to life without unnecessary overheads. Without the framework systems that we have at our disposal today, the web would not have been able to compete with other development platforms.</p>
<p>In this book, we will study the vast ecosystem and expand our knowledge to become confident in creating and maintaining our own self-developed frameworks. Developing the skill to build a framework or extend existing ones comes with the benefit of becoming an impactful domain expert in frontend and backend projects.</p>
<p>As part of becoming experts in JavaScript frameworks, we need to get a sense of the core components and tools of the web development workflow. In this first chapter of the book, we will take a look at how web development evolved, how frameworks changed the landscape of working with JavaScript, and what the ecosystem currently has to offer.</p>
<p>We will cover the following topics:</p>
<ul>
<li>The emergence of JavaScript frameworks</li>
<li>The evolution of code bases</li>
<li>Types of frameworks in JavaScript and their benefits</li>
<li>My experiences with frameworks</li>
</ul>
<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>
<p>This book has an accompanying GitHub repository at <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>. In each chapter, we will point to the relevant directories in this repository. Feel free to clone or download the repository as a ZIP file.</p>
<p>You need a desktop or a laptop computer with internet access and a terminal application to install and run the code from this repository. We shall also be utilizing Node.js to run some of the parts of the repository. Node.js is an open source, cross-platform, backend JavaScript runtime environment that runs JavaScript code outside a web browser. The installation for Node.js can be found at <a href="https://nodejs.org">nodejs.org</a>. For the code from the repository, you can use any environment that supports a terminal and runs Node.js, such as Windows, macOS, and most varieties of Linux.</p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>The emergence of JavaScript frameworks</h1>
<p>As JavaScript<a id="_idIndexMarker000"/> progressed and evolved, the innovators who were heavily involved in the language, both companies and individuals, started writing software libraries to help solve the everyday burdens of web application architectures. The initial focus of the most basic JavaScript libraries was to provide singular features, interactivity, and add-ons, which progressively enhanced the web page. At that time, JavaScript gave life to a static page with its interactive components – simple examples that always come to mind are tiny scripts, which enabled creative button effects and mouse cursor effects. In many cases, these scripts were separate from the site’s core functionality and were not essential to allow users to interact with the content. Since the inception of small libraries, these have paved the way for the complex framework systems that we have today. The frontend technology quickly evolved, and now, developers are much more accustomed to megabytes of scripts powering the frontend code.</p>
<p>JavaScript libraries were the next step in the web development evolution, assisting with cross-browser quirks, complex visual effects, network requests, and web page layout. With the use of these libraries, developers were able to have the cross-browser development challenges under control. CSS started to catch up with its focus on layout features and cross-browser standards, improving the web’s styling features. Developers finally began introducing structure and well-crafted systems into web development.</p>
<p>The time has come to finally focus on building scalable and opinionated software on the web, and this is where we began to see glimpses of complex software paradigms introduced into large websites and web applications. Companies and larger enterprises started treating the web as a serious application platform, which led to a few prominent projects written in JavaScript and compiled to JavaScript<a id="_idIndexMarker001"/> from languages such as Java. Tracing back to late 2009, we see the first iterations of <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) frameworks built entirely with HTML, CSS, and JavaScript. This MVC model allows more extensive projects to stay organized, enriches the development workflow, and opens up the world of frontend development to developers who expect a much more structured approach when writing software. The MVC model fit web applications well enough to spawn a renaissance in framework development.</p>
<p>Many development<a id="_idIndexMarker002"/> hours were invested into connecting the mechanisms between the JavaScript engines and the browser web APIs. In <em class="italic">Figure 1</em><em class="italic">.1</em>, we see a simplified view of how this interaction happens:</p>
<div><div><img alt="Figure 1.1: Interaction between the JavaScript engine and web APIs" src="img/Figure_1.1_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: Interaction between the JavaScript engine and web APIs</p>
<p>The framework<a id="_idIndexMarker003"/> code and its internal technologies, such as the virtual DOM, use the DOM and its components to make the web application experience possible. The web has its own approach to the MVC architecture, with DOM and web API events interacting with Controllers defined in JavaScript. The Controllers interface with Views written in HTML or templated HTML. Furthermore, in this paradigm, the components of the applications utilize a Model to model the data within them. Using this approach, we can later communicate with backend services to retrieve the data in a particular manner.</p>
<p>Each new JavaScript MVC framework tried to perfect its implementation or approach in various ways. About five years after the first MVC frameworks appeared and gained popularity, several new paradigms that focused on the <strong class="bold">observer</strong> software design pattern started gaining traction in the JavaScript community. This observer approach is a software design<a id="_idIndexMarker004"/> pattern in which an object maintains a list of its dependants, called observers. The object notifies<a id="_idIndexMarker005"/> the observers automatically of the state changes within it. At that time, <strong class="bold">Flux</strong> came about, which is an application architecture that concentrates on simplifying the hurdles faced within MVC. The burdens included dealing with views constantly needing to interact with the models, hard-to-debug, deeply nested logic, and the need for adequate testing solutions of complex applications.</p>
<p>In the observer pattern, we define subjects that include a collection of observers informing about state changes. The Flux architecture expanded this existing pattern to fit better with applications<a id="_idIndexMarker006"/> built on the web. In the case of the Flux pattern, it consists of <strong class="bold">stores</strong> interacting with the state of a component. These stores get notified by a <strong class="bold">dispatcher</strong> based on data coming from <strong class="bold">actions</strong> that a user in the <strong class="bold">view</strong> took. Many JavaScript frameworks<a id="_idIndexMarker007"/> started adapting this pattern, ultimately simplifying how engineers structured their applications while still enforcing a set of applicable rules to keep the separation of concerns intact. The software patterns in all of these frameworks provide a clear separation of concerns between the interface, data model, and the application logic that integrates them. The Flux-based JavaScript frameworks introduced new concepts that emerged from the known MVC patterns. Still, both the MVC and Flux approaches focused on the principle of the separation of concerns in application development.</p>
<p>Furthermore, while simplifying<a id="_idIndexMarker008"/> ideas brought to light by Flux, a library called Redux inspired the next generation of frameworks to switch their approach to application state management. Instead<a id="_idIndexMarker009"/> of the Flux dispatchers, Redux frameworks rely on a single store with pure <strong class="bold">reducer</strong> functions, taking the current state and returning an updated state. Even today, frontend patterns are still maturing, and building for the web platform is becoming increasingly easier.</p>
<p>While there’s a lot to mention<a id="_idIndexMarker010"/> with regard to frontend technologies, JavaScript has also made a great impact in places outside of web browsers. We cover those areas in the next section.</p>
<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Frameworks outside the web browser</h1>
<p>Another monumental<a id="_idIndexMarker011"/> event during<a id="_idIndexMarker012"/> the appearance of the first<a id="_idIndexMarker013"/> frontend frameworks was the emergence of a new open source runtime called Node.js. Node.js allowed developers to use JavaScript to produce server-side scripts, deploy backend systems, build developer tools, and, more importantly, write frameworks using the same language as the one from the web browser. The unique combination of having JavaScript on both sides of the software stack created immense possibilities for software developers. This runtime has since spread into many directions beyond software applications, with frameworks for desktop application development, hardware I/O solutions, and much more.</p>
<p>JavaScript-built frameworks enabled the web platform to become one of the most important technologies within reach of billions of people. It’s almost impossible to imagine starting a new project without relying on the consistency and amiability of using a framework, and even the smallest tasks benefit significantly from using a cohesive and opinionated structure. However, even with the fast-paced evolution of the language and how we build web projects, it took quite a bit of time for JavaScript frameworks to emerge as fully encapsulated platforms that can aid developers in producing efficient applications.</p>
<p>JavaScript prevailed through the rise of mobile platforms, with multiple frameworks being created for mobile and existing systems integrating mobile benchmarks into their release process. The optimizations<a id="_idIndexMarker014"/> got to the hardware level, having the <strong class="bold">ARM </strong>(<a href="https://arm.com">arm.com</a>) processor architecture<a id="_idIndexMarker015"/> introduce optimizations to improve JavaScript performance in data type conversion, resulting in performance boosts for many JavaScript applications. That is quite a journey for a scripting language that started with small scripts on plain web pages.</p>
<p>Today, we can create fully fledged applications and services using the web platform by combining the power of web APIs, the JavaScript language, and technologies such as progressive web apps, using the frameworks that bring it all together. It is a fantastic time to start traversing the world of these JavaScript systems and using them to our advantage.</p>
<p>Now that we have an overview<a id="_idIndexMarker016"/> of how web development<a id="_idIndexMarker017"/> evolved, let’s take a look at how the code bases have changed over time.</p>
<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>The evolution of code bases</h1>
<p>While learning<a id="_idIndexMarker018"/> about frameworks, it is fascinating to reflect on how building for the web has changed over time. This exploration helps us understand why we build web applications the way we do today and helps us learn from historical shifts. It also allows us to be more mindful concerning framework usability and development decisions when we take on large projects. As technology pushes forward, the requirements and expectations around how websites and web applications are built drastically change. Depending on how long someone has been involved in web development, they either experienced many rapidly evolving shifts to how the code bases are structured or were lucky enough to avoid the times when the tooling and the process were highly tedious.</p>
<p>Initially, the code bases<a id="_idIndexMarker019"/> comprised isolated frontend components stitched together, consisting of code repetition and mixes of coding patterns. Code organization, usage of software development patterns, and performance optimizations were not a primary focus for developers. The web application deployment process used to be rudimentary as well. In many cases, the websites were manually updated and did not use source control or version tracking. Testing was also highly manual and would only exist in a few projects that were large enough to enable it. This was before deployment pipelines with continuous integration, deployment automation, and advanced testing infrastructure, rigorously verified every change. There used to be a time when developers had to optimize their CSS selectors for performance reasons.</p>
<p>Luckily, productivity and workflows rapidly started to improve once the industry started focusing more on building complex applications. Today we have source control, we have a myriad of testing and deployment tools to choose from, and we have established software paradigms that considerably improve our lives as developers and vastly improve the quality of the projects we build. Improvements to JavaScript engines unlocked new pathways<a id="_idIndexMarker020"/> for frameworks, and enhancements<a id="_idIndexMarker021"/> to web browsers<a id="_idIndexMarker022"/> fixed slow DOM interactivity with techniques such as the <strong class="bold">virtual DOM</strong>, <strong class="bold">Shadow DOM</strong>, and <strong class="bold">Web Components</strong>. These days, frontend frameworks have a better client platform to target as well, and the more established and improved web standards make it possible to perform much more complex operations. For example, with<a id="_idIndexMarker023"/> the help of WebAssembly (<a href="https://webassembly.org">webassembly.org</a>) standards, we can now run low-level code with improved performance, all within the browser.</p>
<p>As part of all these developments and growth in popularity, the web application development workflow got a lot more complex in many ways. Almost at every point of interaction with a web application project, there is a tooling set designed to improve our workflow. Some examples of this would be Git source control, various pre- and post-processors of our files, code editors with plugins, browser extensions, and many more. Here we have an example that illustrates the key components<a id="_idIndexMarker024"/> of a modern web application code base structure, in this case, generated by <strong class="bold">SvelteKit</strong>:</p>
<div><div><img alt="Figure 1.2: SvelteKit code base structure" src="img/Figure_1.2_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2: SvelteKit code base structure</p>
<p>We will go over SvelteKit later<a id="_idIndexMarker025"/> in the <em class="italic">Frameworks that use React</em> section of this chapter, and even if you have never used Svelte, this project file tree will look very familiar if you work with other frameworks. This dynamic structure of tools enables flexibility when it comes to switching out certain functionality. For example, <em class="italic">Prettier</em> can be substituted for another code formatting tool if need be, while the rest of the project structure remains the same and functions as it was.</p>
<p>With the establishment of the first frameworks in JavaScript, we experienced the introduction of a build step into our projects, which meant that either external or bundled tooling would<a id="_idIndexMarker026"/> help run or build<a id="_idIndexMarker027"/> the application. Today, this build step, popularized by <strong class="bold">Webpack</strong> or <strong class="bold">esbuild</strong>, is almost impossible to avoid. As part of this build step, we fetch application dependencies using package managers, process CSS, create<a id="_idIndexMarker028"/> code bundles, and run various optimization steps to make our app run fast and consume the least bandwidth. The ecosystem also introduced JavaScript transpilers, which are a type of source-to-source code compiler. They are used to take one particular syntax, which could consist of more modern features or include additional features, and convert them<a id="_idIndexMarker029"/> to be compatible with broadly accepted JavaScript syntax. Transpilers, such as <strong class="bold">Babel</strong>, began to see everyday use, integrated with the build step in many projects; this pattern generally motivated the use of the latest language features while also supporting old browser engines. These days, transpilation and build steps apply to files beyond JavaScript, as well as files such as CSS and specific templating formats.</p>
<p>Integrating with the build step are the package managers, such as <code>npm</code> or <code>yarn</code>, which play an essential role in resolving project dependencies. If you want to bootstrap a workflow with a framework, you will likely rely on the package manager to initialize the framework structure and its dependencies. For new projects, it is almost impossible to have a sensible framework workflow without using a package manager or some form of dependency resolution. As the project grows, the package manager facilitates the organization of newer dependencies while keeping track of updates to modules that are already in use. These days text editors, such as Visual Studio Code and IntelliJ WebStorm, adapt to our code bases and provide excellent tooling to enable source control of our code. The editors rely on built-in features and external plugins that encourage better formatting, easier debugging, and framework-specific improvements.</p>
<p>The code bases will keep changing as technology develops further, and the tools will keep improving to enable us to develop applications more quickly. Regarding the framework organization, we can expect higher levels of abstractions that simplify the way we do web development. Many programming languages, such as Java and Swift, have pre-defined development workflows encapsulating all aspects of development. JavaScript code bases so far have been an exception to these rules and allowed for high levels of flexibility. This trend is going to continue for many more years as the rapid pace of tooling and innovation in web development is not slowing down at all.</p>
<p>Now that we understand how the JavaScript ecosystem<a id="_idIndexMarker030"/> has evolved and how codebases have changed over time, let us explore what JavaScript frameworks offer in terms of frontend, backend, testing, and beyond.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Types of JavaScript frameworks and their benefits</h1>
<p>Though it is challenging<a id="_idIndexMarker031"/> to compare all the subtle differences of every framework<a id="_idIndexMarker032"/> out there in the ecosystem, we can cover several frameworks that significantly impact the developer community or offer a unique approach to solving a particular problem. The expanded knowledge of the tools helps us notice specific patterns in these frameworks regarding the different strategies for developer experience and feature sets.</p>
<p>There are still ways to build apps and websites without frameworks, but many developers prefer to use established and opinionated frameworks even with the given overhead and learning curves. If you follow the JavaScript community, you will find that it is always passionately abuzz with discussions around frameworks, so let us dive deeper into the needs and benefits of framework use.</p>
<p>The frameworks provide good levels of abstraction to write high-level code without rewriting low-level functionality. Developers can be much more involved in business and product logic and iterate faster on new features. To give an example, up until recently, writing the code to make an asynchronous web request with proper error handling was a very time-consuming task without the aid of a good<a id="_idIndexMarker033"/> abstraction. Now that we have the Fetch API (<a href="https://fetch.spec.whatwg.org">fetch.spec.whatwg.org</a>), this is a much easier endeavor, but Fetch is only part of the story, so the rest of the web APIs, especially the ones from earlier times, still benefit from good abstractions. In cases where we choose to write low-level code, it is a much better approach to find ways to write that code within the framework boundaries. This way it is tested and maintained within the primitives of the framework. This yields the benefits of avoiding extra maintenance and ensuring all the usages of that code are still behind sensible abstractions. Some backend frameworks approach this by providing extensible interfaces to hook into framework internals through plugins or extending the default behavior.</p>
<p>Developing software with groups of people is a challenging endeavor, so small and large teams can benefit from integrating a framework into the engineering workflow. The provided structure of abstractions generally results in much more well-architected systems, given the limits of how developers can write high-level components. The key benefit is enabling everyone involved in the task to understand the code base better and conveniently spend less time deliberating refactors and adding new code.</p>
<p>Now that we have our abstracted high-level code, we can cherish another benefit of frameworks – the performance optimizations they enable. Writing performant code that works in all provided use cases takes skill and takes away significant time from the project at hand. Even the most knowledgeable developers would only be able to come up with good enough solutions in a short amount of time. With frameworks, especially open source ones, you benefit from many minds put together to solve performance bottlenecks, overcome typical encumbrances, and continue to benefit from improvements as the framework develops. The performance benefits come from optimized low-level and well-structured high-level components; notably, some frameworks will guard against code that will slow down the application.</p>
<p>Frameworks make integrating<a id="_idIndexMarker034"/> with external systems, such as databases, external APIs, or specific components, easier. For instance, some web frameworks can integrate directly with the GraphQL data query language, simplifying backend systems’ interaction. It’s not just the ease of use, but also these integrations enable safe interaction with components such as databases, which helps avoid problematic queries that can be slow or harmful to execute. For frontend projects, it is important to always keep up with the latest web standards, and this is where frameworks provide another integration benefit.</p>
<p>Finally, as with all software, support plays an important role. Another reason a project may use an established framework is the available support channels through paid, volunteer, and open source help. The shared knowledge of these systems enables developers to help each other build systems and makes it easier to hire new developers who are familiar with these existing systems.</p>
<p>As we see, frameworks benefit<a id="_idIndexMarker035"/> us in countless ways – let us recap with these exact reasons. Here’s what frameworks allow us to do:</p>
<ul>
<li>Focus on business logic and writing high-level code</li>
<li>Write less code and follow code conventions defined by the framework</li>
<li>Benefit from performance gains and rely on future optimizations</li>
<li>Develop the project with good architecture, abstractions, and organization</li>
<li>Easily integrate with external systems such as databases and external APIs</li>
<li>Ability to rely on security fixes, audits, and patches</li>
<li>Improve developer workflow using framework-specific toolings, such as text-editor integrations and command-line utilities</li>
<li>Ability to debug issues easily by relying on detailed error messages and consistent logging</li>
<li>Rely on external support from framework authors and the community</li>
<li>Hire more developers who are already accustomed to working with the framework of our choice or with similar experience</li>
<li>Develop better user experiences by leveraging the framework feature set</li>
</ul>
<p>While a lot of JavaScript frameworks<a id="_idIndexMarker036"/> focus on the developer experience, the user experience can sometimes suffer from the overhead of these systems. This is usually relevant in frontend projects – an example of this would be loading a complex web application on budget mobile devices. In backend systems, this can be seen when the APIs are not able to keep up with request load and reliably scale with traffic spikes.</p>
<p>Even if the systems <a id="_idIndexMarker037"/>are skillfully built in both of these cases, the framework of choice might not be optimized to cover all use cases. I believe the next iteration of the framework ecosystem will largely focus on the user experience aspects, which means making load times faster, shipping less JavaScript over the network, and ensuring the web applications we create work seamlessly on all platforms. In the following sections, we will examine some of the most popular frameworks that enable these benefits for web application developers.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Frontend frameworks</h2>
<p>Since JavaScript frameworks<a id="_idIndexMarker038"/> originated in the browser, let us look at modern frontend frameworks as our first exploration.</p>
<h3>Ember.js</h3>
<p>Suppose we trace<a id="_idIndexMarker039"/> the roots<a id="_idIndexMarker040"/> of the first JavaScript frameworks through the origins of libraries such as <code>Prototype.js</code>, <code>jQuery</code>, and <code>script.aculo.us</code>. In that case, we<a id="_idIndexMarker041"/> will eventually arrive at <strong class="bold">SproutCore</strong>, a framework used by Apple and a handful of other companies to build some of the most complex web experiences many years ago.</p>
<p>Today this early SproutCore project has influenced the <strong class="bold">Ember.js</strong> framework. Ember continues to be a highly opinionated<a id="_idIndexMarker042"/> piece of software that allows us to build applications with defined components, services, models, and a powerful router. Like many frameworks we will discuss in this chapter, Ember comes with its own command-line tooling, which helps developers quickly get started on the basics of the application and later generate more code quickly as the project scope grows. The usefulness of the provided framework tooling is immense. The CLI encapsulates the code generation steps and enables a way to run common framework commands, such as running tests or serving application files. With Ember, developers get a complete set of tools such as auto-reload, browser<a id="_idIndexMarker043"/> developer tooling, and a package called Ember Data, which helps manage the API-to-model relationship through adapters and serializers. Ultimately, Ember has a steeper learning curve than other frameworks, but its highly opinionated concepts guide developers<a id="_idIndexMarker044"/> toward highly functional web applications.</p>
<h3>Angular</h3>
<p><strong class="bold">Angular</strong> is another framework<a id="_idIndexMarker045"/> with a large following. With TypeScript<a id="_idIndexMarker046"/> at its core, it is often used as a subset system for other full stack web frameworks. Angular provides its opinionated approach to component-based architecture. Angular has a complex history of rewrites but is now a more streamlined project with a stable feature set. Angular’s template syntax extends HTML by adding expressions and new attributes. At its core, it uses the pattern of dependency injection. The latest versions of this framework offer a variety of binding techniques, including event, property, and two-way binding.</p>
<h3>Vue.js</h3>
<p><strong class="bold">Vue.js</strong>, also written in TypeScript, was created<a id="_idIndexMarker047"/> by borrowing<a id="_idIndexMarker048"/> the good elements of Angular. Developers love Vue’s simplicity within its component<a id="_idIndexMarker049"/> system, syntax, and general ease of use. It utilizes the <strong class="bold">Model–View–Viewmodel </strong>(<strong class="bold">MVVM</strong>) pattern, where a View communicates with a ViewModel using some data binding technique. In the case of Vue.js, for its data, it uses different techniques through HTML classes, HTML elements, and custom binding element attributes to achieve this. The purpose of the given ViewModel is to handle as much of the View’s interaction logic and be the middle structure between the presentation<a id="_idIndexMarker050"/> logic and the application’s business logic. Besides using HTML authoring, Vue has the <strong class="bold">Single-File Component</strong> (<strong class="bold">SFC</strong>) format (<a href="https://vuejs.org/api/sfc-spec.html">vuejs.org/api/sfc-spec.html</a>) to encapsulate all aspects of the components – scripts, styling, and templating<a id="_idIndexMarker051"/> into one file. The SFC happens as part of the build step and helps the components avoid runtime compilation, scopes the CSS styles<a id="_idIndexMarker052"/> to the component, enables<a id="_idIndexMarker053"/> Hot Module Replacement, and much more.</p>
<p class="callout-heading">About TypeScript</p>
<p class="callout"><code>.ts</code> and <code>.tsx</code> are TypeScript files that must be compiled to JavaScript to be used in most environments.</p>
<h3>Frameworks that use React</h3>
<p>These days, we hear about <strong class="bold">React</strong> a lot; even though it is a user interface<a id="_idIndexMarker055"/> component library<a id="_idIndexMarker056"/> by itself, it has become the cornerstone for many frontend frameworks, such as <strong class="bold">Gatsby</strong>, <strong class="bold">Remix</strong>, <strong class="bold">Next.js</strong>, and others. As part of its introduction, React also debuted <strong class="bold">JSX</strong>, its own set of extensions to JavaScript, making it possible<a id="_idIndexMarker057"/> to define<a id="_idIndexMarker058"/> the components<a id="_idIndexMarker059"/> in a similar-looking syntax<a id="_idIndexMarker060"/> to HTML. For instance, the static site framework Gatsby relies on React’s state management and the nested component architecture to compose its web pages. With Gatsby, developers can multiplex data, utilizing GraphQL, from content management systems, e-commerce sources, and other places.</p>
<p>Following along our React route, we get to Remix, which bundles a full stack solution with features for both the server and the client, plus a compiler and a request handler. Remix provides solutions for the View and Controller aspects of the application and relies on the Node.js module ecosystem for the rest, giving flexibility to the developers who need custom solutions from project to project. Based on the experience of creating and maintaining the <code>react-router</code> project for many years, the creators of Remix were able to come up with powerful abstractions while taking advantage of the browser’s web APIs instead of investing in new concepts. To give an example, if you choose Remix for your project, you will find yourself using web standard APIs more than some of the other frameworks.</p>
<p>Next.js is our next React-based framework, which extends the use of the React component architecture as well by bringing it to the server with its built-in server rendering. The server-rendered components allow for a pre-rendered page to be sent to the client, resulting in the client only spending resources on initializing the interactive components. The framework provides the concept of pages, which allows for simpler routing implementations with lazy loading and enables automatic code-splitting. Combining all these features results in a fantastic user experience with fast loading times. In addition, the deployed applications rank highly when indexed by search engines, a feature that makes this framework stand out.</p>
<p>While talking about React frameworks, it is worth mentioning <strong class="bold">Solid.js</strong>. It’s a newer library that creates frontend<a id="_idIndexMarker061"/> interfaces. Solid’s benchmarks outperform React and others. It uses features such as JSX, but with a few key differences. With Solid, there is no virtual DOM<a id="_idIndexMarker062"/> and no concept of hooks. Instead, it relies on the pattern of <strong class="bold">signals</strong> to update the real DOM nodes, while utilizing<a id="_idIndexMarker063"/> reactive primitives. As part of Solid’s approach, it offers the <strong class="bold">SolidStart</strong> app framework, which is very comparable to Next.js. It consists of core support components – <em class="italic">router</em>, <em class="italic">session</em>, <em class="italic">document</em>, <em class="italic">actions</em>, <em class="italic">data</em>, <em class="italic">entrypoints</em>, and <em class="italic">server</em> – these<a id="_idIndexMarker064"/> are integrated<a id="_idIndexMarker065"/> together as part of SolidStart.</p>
<h3>SvelteKit</h3>
<p>Like SolidStart, there is also <code>.svelte</code> files, which encapsulate the components with the <code>&lt;script&gt;</code>, <code>&lt;style&gt;</code>, and HTML tags that are coded together. These<a id="_idIndexMarker069"/> are compiled<a id="_idIndexMarker070"/> into JavaScript output generated by the compiler.</p>
<p class="callout-heading">About Vite</p>
<p class="callout"><code>vite.config.js</code> configuration file. Mainly, it is used as a build tool for frontend projects. It is optimized for speed and it achieves that speed by providing a development server with Hot Module Replacement and a bundler that optimizes JavaScript output using esbuild (<a href="https://esbuild.github.io">esbuild.github.io</a>).</p>
<h3>Framework features and patterns</h3>
<p>To understand what most modern frameworks enable, we need to understand the following acronyms<a id="_idIndexMarker072"/> and features:</p>
<ul>
<li><strong class="bold">Single-Page Application</strong> (<strong class="bold">SPA</strong>): An early term that describes an application that purely uses JavaScript<a id="_idIndexMarker073"/> and other frontend frameworks for all interactions with reduced browser routing.</li>
<li><strong class="bold">Server-Side Rendering</strong> (<strong class="bold">SSR</strong>): Pre-rendered components on the server side, which are transferred<a id="_idIndexMarker074"/> for JavaScript hydration on the client side.</li>
<li><strong class="bold">Client-Side Rendering</strong> (<strong class="bold">CSR</strong>): Rendering of components using JavaScript, purely<a id="_idIndexMarker075"/> on the browser’s side.</li>
<li><strong class="bold">Static Site Generator</strong> (<strong class="bold">SSG</strong>): The concept of pre-generating<a id="_idIndexMarker076"/> all pages from source for faster rendering and better search engine optimization.</li>
<li><strong class="bold">Deferred Static Generator</strong> (<strong class="bold">DSG</strong>): Renders content on the server<a id="_idIndexMarker077"/> when initiated by a request to the server.</li>
<li><strong class="bold">Incremental Static Regeneration</strong> (<strong class="bold">ISR</strong>): Another pattern of static content generation. In this case, the static <a id="_idIndexMarker078"/>generation is triggered by updates by some external trigger.</li>
<li><strong class="bold">Content Security Policy</strong> (<strong class="bold">CSP</strong>): Configuration for serving scripts that helps protect against<a id="_idIndexMarker079"/> cross-site scripting attacks.</li>
<li><strong class="bold">Hot Module Replacement</strong> (<strong class="bold">HMR</strong>): Technique to replace JavaScript modules as the application<a id="_idIndexMarker080"/> is running in the browser, mainly used to improve development speed and avoid page reloads.</li>
<li><strong class="bold">Single-File Component</strong> (<strong class="bold">SFC</strong>): A file structure that encapsulates all aspects of a usable<a id="_idIndexMarker081"/> framework component, such as styling, templating, logic, and more.</li>
<li><strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>): A design pattern focusing on the separation of concerns in various<a id="_idIndexMarker082"/> types of applications. It approaches this separation by using the following: a Model that represents the data, a View that provides the user with an interface, and a Controller that is the intermediary between the views and the models.</li>
<li><strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>): Another design pattern that also focuses on the separation<a id="_idIndexMarker083"/> of concerns in applications, but the approach to these separations is different. In this case, there are still Views and Models, similar to MVC. However, the ViewModel acts as a connection between those types. This approach uses two-way data<a id="_idIndexMarker084"/> binding between the View and the Model.</li>
</ul>
<p>Besides the features and their acronyms, here is a helpful visual describing<a id="_idIndexMarker085"/> both the MVC and MVVM<a id="_idIndexMarker086"/> patterns:</p>
<div><div><img alt="Figure 1.3: MVC versus MVVM patterns" src="img/Figure_1.3_B19014.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3: MVC versus MVVM patterns</p>
<p>During the renaissance<a id="_idIndexMarker087"/> of frontend frameworks, an open source project called <strong class="bold">TodoMVC</strong> was established to help developers compare frameworks based on the same To Do app, where anyone can send pull requests with their framework implementations. Besides comparing different frameworks, the project also popularized the approach to complex code organization in JavaScript. Now with the emergence of these new frameworks, we need another iteration of TodoMVC to continue aiding developers with comparisons of these systems.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Backend frameworks</h2>
<p>Switching gears<a id="_idIndexMarker088"/> from the frontend, let us look at some of the backend frameworks. Node.js plays a vital role in the JavaScript ecosystem, powering a variety of frameworks that allow us to develop backend services. Similar to the frontend, it is impossible to cover all of them, but in this section, we will examine <strong class="bold">hapi.js</strong>, <strong class="bold">express</strong>, <strong class="bold">Sails.js</strong>, <strong class="bold">nest.js</strong>, and <strong class="bold">AdonisJS</strong>.</p>
<h3>Hapi.js</h3>
<p>As part of framework<a id="_idIndexMarker089"/> explorations over the years, I had the opportunity to work<a id="_idIndexMarker090"/> with these frameworks in a professional capacity and on small hobby projects. I started with hapi.js, which is a good example of a well-crafted Node.js framework, built with essential defaults that allow it to craft a server backend quickly. It has a unique approach of avoiding middlewares and relying on external modules. As part of its core, it already has validation rules, parsing, logging, and more built right into it. hapi.js doesn’t lock down extensibility; developers can create plugins and register them to execute as part of the different parts of the request lifecycle. Hapi.js’ mission puts an emphasis on avoiding unexpected consequences when combining a lot of application logic. This is evident in how hapi.js approaches dependency management and module namespacing.</p>
<h3>Express</h3>
<p>In stark contrast to hapi.js, the Node.js<a id="_idIndexMarker091"/> ecosystem also has a framework called <strong class="bold">Express</strong>, which is largely an unopinionated<a id="_idIndexMarker092"/> approach to building backend services. Thousands of projects and tools usually use Express for its routing, content parsers, and high-performance reasons. Being flexible in almost every way and with support for over a dozen templating engines, Express is the introductory framework for developers starting with Node.js development. For example, a popular MVC framework, Sails.js, builds upon Express’ functionality to offer API generation, database ORM solutions, and support for building real-time features. Generally, it is a good solution for those appreciating the middleware patterns of Express, while having a more structured approach<a id="_idIndexMarker093"/> to building backend<a id="_idIndexMarker094"/> systems.</p>
<h3>NestJS</h3>
<p>NestJS, not to be confused <a id="_idIndexMarker095"/>with Next.js, is another server-side framework<a id="_idIndexMarker096"/> that is worth mentioning. It is similar to Vue, and Angular inspired its approach to application structure, but in this case, for a backend system. By default, it utilizes Express as its default HTTP server and creates an abstraction layer that allows for the ability to change the third-party modules, enabling the developers to swap<a id="_idIndexMarker097"/> out Express for some other HTTP framework such as <strong class="bold">Fastify</strong>. In NestJS, we see a similar pattern of dependency injection, which enables developers to architect contained modules. These modules can be reused, overridden, and mocked in tests.</p>
<h3>AdonisJS</h3>
<p>Our final Node.js framework<a id="_idIndexMarker098"/> for this section is AdonisJS. Built entirely<a id="_idIndexMarker099"/> with TypeScript, it is packed with features that you would expect from a mature framework, such as the ORM based on the Active Record pattern, schema validators, extensive authentication support, and much more. The built-in and first-party plugin features provide solutions for many mundane problems of backend building. AdonisJS also packs a custom templating engine to render HTML layouts. As an added bonus, AdonisJS has straight-to-the-point and clear documentation, which is a joy to read and explore.</p>
<h3>Fresh</h3>
<p>Given the focus<a id="_idIndexMarker100"/> on essential frameworks in the Node.js ecosystem, we should<a id="_idIndexMarker101"/> also mention a backend framework called <strong class="bold">Fresh</strong>, which is powered by the <strong class="bold">Deno</strong> runtime. This runtime is built <a id="_idIndexMarker102"/>using a combination of technologies – JavaScript, TypeScript, WebAssembly, and the Rust programming language. Fresh takes a simplistic approach with its emphasis on having no build steps, minimal configuration, and just-in-time rendering of components on the server. Routing<a id="_idIndexMarker103"/> is taken care of by creating files in the directories of your project, called File-system routing, a similar pattern in other frameworks.</p>
<p>Looking back at all the Node.js frameworks we covered in this section, there is a healthy framework diversity that delivers solutions for projects of any type.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Native frameworks</h2>
<p>The knowledge<a id="_idIndexMarker104"/> of JavaScript also allows us to build for native operating system environments and interact with hardware platforms. The availability of the runtime in other environments makes it possible for us to create unique solutions that can help web developers apply their skills in areas beyond the browser. In this section, we cover some of the frameworks created for native JavaScript development.</p>
<h3>Electron</h3>
<p>The idea of packaging<a id="_idIndexMarker105"/> a web app as a native<a id="_idIndexMarker106"/> app is not new, but it has been perfected with <strong class="bold">Electron</strong>. Electron allows developers to use familiar frontend technologies to build fully capable cross-platform applications that run on popular desktop platforms. It has feature supports features such as auto-updates and inter-process communication, as well as having a collection of plugins that tap into operating system functionality. Besides the advanced framework features, it is beneficial to have a single code base targeting all the platforms, which helps with efficiently building new features and bug fixing. These days millions of people use applications built with Electron, in many<a id="_idIndexMarker107"/> cases without knowing it. Applications such as Microsoft Teams, Slack, 1Password, Discord, Figma, Notion, and many more utilize Electron. Even more examples<a id="_idIndexMarker108"/> can be found at <a href="https://electronjs.org/apps">electronjs.org/apps</a>.</p>
<h3>React Native</h3>
<p>Another framework<a id="_idIndexMarker109"/> that helps us create for native platforms is <strong class="bold">React Native</strong>, which unlocks the world of mobile<a id="_idIndexMarker110"/> development to those experienced with JavaScript. Targeting iOS and Android mobile platforms, just like Electron on desktop, it brings all the benefits of React user-interface building blocks, a unified codebase, and a strong, established community.</p>
<h3>Johnny-Five</h3>
<p>The Node.js ecosystem<a id="_idIndexMarker111"/> also offers hardware frameworks such as <strong class="bold">Johnny-Five</strong>, which allows for creative learning<a id="_idIndexMarker112"/> use cases of robotics programming using JavaScript and the Firmata protocol. Johnny-Five is an IoT platform supporting over 30 hardware boards. Mainly, it offers interfaces to interact with LEDs, services, motors, switches, and more.</p>
<p>All the frameworks so far deal with building out application logic, but there are also other types of frameworks in JavaScript that play an important role in the development process – these would<a id="_idIndexMarker113"/> be the testing frameworks.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Testing frameworks</h2>
<p>Testing frameworks<a id="_idIndexMarker114"/> in software development are essential for ensuring our projects function as expected. With JavaScript and its supported runtime environments, we have a much more challenging task at hand – we have to test in different browser engines and mock the native web APIs. In some cases, mocking built-in and external libraries can also be challenging. The asynchronous behavior of the language brings its own obstacles as well. Luckily, the JavaScript ecosystem came up with various testing frameworks addressing many software testing challenges – unit, integration, functional, end-to-end testing, and beyond. To name a few, <strong class="bold">Jest</strong>, <strong class="bold">Playwright</strong>, and <strong class="bold">Vitest</strong> all offer great solutions to testing challenges. We will discuss them next.</p>
<h3>Jest</h3>
<p>As we develop<a id="_idIndexMarker115"/> our web applications, we want to ensure that the components we build are functioning as intended; this is where a framework such as Jest comes in. Jest<a id="_idIndexMarker116"/> is a unit testing framework that integrates well into other projects. If we are given a project with one of the frameworks that we already saw in this chapter, Jest would equip us with reliable testing solutions. It is ergonomic, with minimal or zero configuration, and provides us with interfaces for easy mocking, object snapshotting, code coverage, and most importantly, an easy-to-understand API for organizing our tests.</p>
<h3>Vitest</h3>
<p>Vitest is a similar<a id="_idIndexMarker117"/> unit testing framework, offering the same interfaces<a id="_idIndexMarker118"/> to mock modules in web projects. It focuses on speed and support for components of many frameworks, including Vue, React, Svelte, and even Web Components. It is designed for developer productivity and has a mode for smart test watching, a multi-threaded test runner, and a familiar snapshotting mechanism.</p>
<h3>Playwright</h3>
<p>Besides unit testing, our software<a id="_idIndexMarker119"/> projects benefit highly from end-to-end testing; this is where<a id="_idIndexMarker120"/> a testing framework such as Playwright is a good contender. It delivers cross-browser and cross-platform testing for web applications. Playwright comes with a set of test interfaces to automate various browsers, including navigating to URLs and clicking buttons. Historically, this has been a challenging problem due to the asynchronous nature of web pages, but this framework is equipped with ways to avoid flaky tests through retries and await behavior.</p>
<p>Depending on the requirements of the JavaScript project you are involved in, you might have to create new testing workflows or customize the existing testing infrastructure to fit your use case – this is where experience in building testing frameworks would be advantageous.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Framework showcase</h2>
<p>Here’s a breakdown of the frameworks we covered in this chapter.</p>
<p>These are some of the noteworthy<a id="_idIndexMarker121"/> web application frameworks<a id="_idIndexMarker122"/> that we will be focusing on in this book:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="3">
<p><strong class="bold">Frontend + </strong><strong class="bold">Full Stack</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Name</p>
</td>
<td class="No-Table-Style">
<p>Released</p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">AngularJS</strong></p>
</td>
<td class="No-Table-Style">
<p>2010</p>
</td>
<td class="No-Table-Style">
<p>Obsolete MVC framework with features such as two-way data binding and dependency injection. Part of the original MEAN software stack.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Bootstrap</strong></p>
</td>
<td class="No-Table-Style">
<p>2011</p>
</td>
<td class="No-Table-Style">
<p>Basic framework that allows utilizing HTML, CSS, and JavaScript to create responsive mobile-first websites and can be integrated with other systems to power interfaces for web applications. Bootstrap defines its own layout primitives and provides a great set of built-in components for forms and user interface elements.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Ember.js</strong></p>
</td>
<td class="No-Table-Style">
<p>2011</p>
</td>
<td class="No-Table-Style">
<p>Component-service architecture SPA framework with regular releases and opinionated conventions over configuration characteristics.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Vue.js</strong></p>
</td>
<td class="No-Table-Style">
<p>2014</p>
</td>
<td class="No-Table-Style">
<p>Lightweight MVVM component-based framework with an easy learning curve – uses the virtual DOM. Comes with its own reactivity system and support for state-changing CSS transitions.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Gatsby</strong></p>
</td>
<td class="No-Table-Style">
<p>2015</p>
</td>
<td class="No-Table-Style">
<p>Advanced static site generator using React and Node.js. Includes various modes of rendering pages and serving dynamic websites. Heavily relies on GraphQL for data retrieval. Variety of plugins in the ecosystem.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Angular</strong></p>
</td>
<td class="No-Table-Style">
<p>2016</p>
</td>
<td class="No-Table-Style">
<p>Component-based framework with dependency injection, templating, and additive directives. Has a slew of extra features to enable internationalization and accessibility. Full rewrite of the original AngularJS. TypeScript-based.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Next.js</strong></p>
</td>
<td class="No-Table-Style">
<p>2016</p>
</td>
<td class="No-Table-Style">
<p>Server-side rendering framework using React as its rendering interface. Supports multiple data request methods. A lot of features are built right into the framework.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Nuxt.js</strong></p>
</td>
<td class="No-Table-Style">
<p>2016</p>
</td>
<td class="No-Table-Style">
<p>Framework that uses Vue.js as its core, with a combination of Webpack, Babel.js, and other components. Focuses on delivering an optimized application experience.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">SolidStart</strong></p>
</td>
<td class="No-Table-Style">
<p>2019</p>
</td>
<td class="No-Table-Style">
<p>Framework for Solid.js applications. Supports all methods of component rendering. Optimizations for code splitting and providing the best Solid.js experience. Solid.js works with real DOM nodes, supports Web Components, and has efficient rendering.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Remix</strong></p>
</td>
<td class="No-Table-Style">
<p>2021</p>
</td>
<td class="No-Table-Style">
<p>Full stack, UI-focused framework written in TypeScript. Consists of a browser, server, compiler, and HTTP handler. Built on top of React and includes a powerful application router. Offers many modes of rendering and file-based routing.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">SvelteKit</strong></p>
</td>
<td class="No-Table-Style">
<p>2022</p>
</td>
<td class="No-Table-Style">
<p>Framework to develop Svelte-based apps. Uses the Svelte compiler and the Vite tooling. Does not rely on the Virtual DOM and supports all modes of rendering components.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4: Examples of frontend and full stack frameworks</p>
<p>These are some of the backend frameworks<a id="_idIndexMarker123"/> that will serve as good examples and help us learn certain framework development patterns:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table002">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="3">
<p><strong class="bold">Backend</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Name</p>
</td>
<td class="No-Table-Style">
<p>Released</p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">hapi.js</strong></p>
</td>
<td class="No-Table-Style">
<p>2009</p>
</td>
<td class="No-Table-Style">
<p>Framework for building backend web services of any kind, with a convention-over-configuration mantra. Supports a lot of advanced features such as API validation, payload parsing, and more right out of the box.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Express</strong></p>
</td>
<td class="No-Table-Style">
<p>2010</p>
</td>
<td class="No-Table-Style">
<p>One of the most popular Node.js frameworks for building RESTful APIs, integrated with many modules in the ecosystem. Used in real-world applications and many developer tools. Part of the MEAN stack. Includes helpers for caching, redirection, and support for many templating engines.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Sails.js</strong></p>
</td>
<td class="No-Table-Style">
<p>2012</p>
</td>
<td class="No-Table-Style">
<p>Enterprise-grade MVC framework built on top of Express and Socket.io. Comes with ORM support and a powerful CLI to generate parts of projects.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">NestJS</strong></p>
</td>
<td class="No-Table-Style">
<p>2018</p>
</td>
<td class="No-Table-Style">
<p>Server-side application framework with a modular approach. It follows certain patterns of Angular and includes a lot of built-in features, such as WebSocket, GraphQL, and microservice support.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">AdonisJS</strong></p>
</td>
<td class="No-Table-Style">
<p>2019</p>
</td>
<td class="No-Table-Style">
<p>All-inclusive backend framework for APIs and web applications written in and for TypeScript-based code bases. Comes with its own components for ORM, templating, and routing.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Fresh</strong></p>
</td>
<td class="No-Table-Style">
<p>2022</p>
</td>
<td class="No-Table-Style">
<p>Framework written using the Deno runtime. With no build steps, minimal configuration, and just-in-time rendering. Uses the island architecture pattern, focusing on reducing work on the client. Independent server-side components are rendered using HTML and sent over to the client.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5: Examples of backend frameworks</p>
<p>Other frameworks that use frontend<a id="_idIndexMarker124"/> technologies to target native or hardware<a id="_idIndexMarker125"/> development are as follows:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table003">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="3">
<p><strong class="bold">Native + </strong><strong class="bold">Hardware</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>Name</p>
</td>
<td class="No-Table-Style">
<p>Released</p>
</td>
<td class="No-Table-Style"/>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Johnny-Five</strong></p>
</td>
<td class="No-Table-Style">
<p>2012</p>
</td>
<td class="No-Table-Style">
<p>Robotics framework for IoT development. Allows developers to interact with hardware modules with an easy-to-use API.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Electron</strong></p>
</td>
<td class="No-Table-Style">
<p>2013</p>
</td>
<td class="No-Table-Style">
<p>Popular cross-platform desktop application framework that uses web technologies. Uses the architecture from the Chromium project, which enables developers to interact with the application and the renderer processes.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">React Native</strong></p>
</td>
<td class="No-Table-Style">
<p>2015</p>
</td>
<td class="No-Table-Style">
<p>Application framework for iOS, Android, and other platforms. Uses familiar concepts from React to build interfaces. Mainly useful for web developers who want a single code base for their application and don’t want to use native toolkits to build these apps. Has a large community and plugin ecosystem.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6: Examples of native and hardware frameworks</p>
<p>Here are testing framework<a id="_idIndexMarker126"/> examples, which are useful to integrate and use in web application projects:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table004">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style" colspan="3">
<p><strong class="bold">Testing</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Jest</strong></p>
</td>
<td class="No-Table-Style">
<p>2019</p>
</td>
<td class="No-Table-Style">
<p>Zero-configuration testing framework that universally supports many JavaScript environments, including TypeScript, Node.js, and more.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Playwright</strong></p>
</td>
<td class="No-Table-Style">
<p>2020</p>
</td>
<td class="No-Table-Style">
<p>End-to-end testing and automation framework supporting cross-platform testing in the Chromium, WebKit, and Firefox browsers. Helps developers quickly and reliably conduct instrument tests for any web application.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Vitest</strong></p>
</td>
<td class="No-Table-Style">
<p>2022</p>
</td>
<td class="No-Table-Style">
<p>Unit test framework, part of the Vite ecosystem. Comes with ESM, JSX, and TypeScript support. Developed in conjunction with Vue.js</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7: Examples of testing frameworks</p>
<p>One of the best resources to keep up with the current direction of framework development is <a href="https://stateofjs.com">stateofjs.com</a>. It is a yearly survey with results from thousands of developers, and it provides an outlook of where the technologies are shifting. For example, if we look at the frontend framework rankings of 2022 (<a href="https://2022.stateofjs.com/en-US/libraries/front-end-frameworks">2022.stateofjs.com/en-US/libraries/front-end-frameworks</a>), we can already start to see the retention and interest in React slowly dropping, which could potentially indicate that the industry is slowly shifting to other solutions. Due to this constant change of use, awareness, and popularity of all these frameworks, instead of focusing on many of the frameworks of today, we are going to cover the core patterns that could be applicable to new frameworks in the future. These patterns will be helpful to you while you explore creating your own framework.</p>
<p>Now it’s time to try out some<a id="_idIndexMarker127"/> of the frameworks mentioned in this chapter using the GitHub repository for this book mentioned in the <em class="italic">Technical requirements</em> section. You can follow these steps:</p>
<ol>
<li>Install Node.js version 20 from <a href="http://nodejs.org">nodejs.org</a>.</li>
<li>Clone the repository from <a href="https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework">https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework</a>.</li>
<li>Using your terminal, change directories into the <code>chapter1</code> directory of the repository.</li>
<li>Run <code>npm install</code> and then <code>npm start</code>.</li>
<li>Follow the interactive prompt to run the examples.</li>
</ol>
<p>The showcase<a id="_idIndexMarker128"/> focuses on reproducing the same example based on the framework type. All frontend frameworks demonstrate the same component written in different structures. Note that some examples might take a while to install and run.</p>
<p>In the final part of this chapter, we shall take a look at my notable personal experiences with frameworks in web development.</p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>My experiences with frameworks</h1>
<p>My professional web development<a id="_idIndexMarker129"/> career initially started with building basic websites before established frameworks or libraries were around. Looking ahead, I want to share my framework experiences of professionally utilizing them and contributing to some of the open source ones. These days, the accumulated knowledge gathered from these experiences has helped me better assess framework usefulness and introduce new software paradigms into my work. Many find it challenging to keep up with the latest innovations in the JavaScript field, but building even the smallest projects helps one grow as a developer in many ways.</p>
<p>Here are some examples from the full stack development areas that helped me become much more effective as a web developer.</p>
<h3>Frontend development</h3>
<p>The first few professional<a id="_idIndexMarker130"/> websites I built were developed for Internet Explorer 6 and early versions of Firefox web browsers. As we learned from this chapter, there were no frameworks for building web applications at the time, and I had to utilize the few libraries at my disposal. These would help add interactivity for components such as image galleries and <a id="_idIndexMarker131"/>dynamic page layouts. Luckily, when my focus switched to larger projects, the <strong class="bold">jQuery</strong> frontend library came along and started growing in popularity. Even to this day, jQuery is still a popular tool of choice for a large chunk of websites. I now had the opportunity to hand-craft a basic framework, which could be reused from project to project. This series of scripts was incredibly convenient and foreshadowed the bright future of frameworks that we have today. It was clear that the trend of single-page JavaScript applications was heading towards structured and opinionated solutions.</p>
<p>During one of my large early-on projects – specifically the Firefox Accounts frontend (<a href="http://accounts.firefox.com">accounts.firefox.com</a>), I had the opportunity to use <strong class="bold">Backbone.js</strong>, with the help of jQuery and multiple extension<a id="_idIndexMarker132"/> libraries to make it more suitable for large projects. The Firefox Accounts frontend, which is serving millions of users, is still using Backbone.js to this day. The way the Backbone.js framework is structured allows for a soft dependency on jQuery, so it did feel like a natural continuation of my earlier approach to web application development. My key takeaways from this experience are that Backbone.js wasn’t the perfect answer to the challenges of frontend web applications, but it was beneficial in many ways. For example, it allowed the project to stay flexible with the ever-evolving JavaScript ecosystem and helped diverse developers work on the application while following a solid set of application guidelines. The unique opportunity to work on the client and the integrated services of the Firefox web browser taught me how to produce JavaScript components for a desktop client that runs on millions of computers worldwide.</p>
<p>Throughout many professional projects, I had the chance to work with Ember.js, Angular, and various React frameworks. I was impressed by how empowering these frameworks can be on these occasions. A notable<a id="_idIndexMarker133"/> mention from my experience is the <strong class="bold">Meteor</strong> web framework, released in early 2012. One of the big selling features of Meteor was the isomorphic or so-called <em class="italic">universal JavaScript</em> approach, where the code runs on both the client<a id="_idIndexMarker134"/> and the server. In many ways, we see similar approaches in popular frameworks today, where a full stack framework lets developers write JavaScript to develop on both sides of the stack. I have built a few applications and some plugins for this framework, and while it felt so easy to get started with Meteor, I have experienced hurdles while trying to build something that didn’t fit exactly into the scope of what Meteor supported, especially in the early releases of the framework. A particular example of fighting with the framework’s constraints was developing a feature with a synchronized document state across multiple clients. This ended up being challenging to implement with Meteor’s feature set at the time and had to be rebuilt with alternative tooling. Luckily this was not a critical project, but for times when it is important, it is a good idea to evaluate<a id="_idIndexMarker135"/> whether the framework of your choice is the right tool for what you are trying to build.</p>
<h3>Backend development</h3>
<p>During the early years<a id="_idIndexMarker136"/> of Node.js, I had the chance to work on several projects utilizing the microservices architecture, and these involved using the Express and hapi frameworks. I felt the contrast between the open-ended approach of the express framework versus the rigorous set of rules and options that were defined in hapi.js. To give some examples, overriding and customizing certain behaviors in hapi.js was quite difficult, and keeping the framework up to date required difficult migrations to the code base.</p>
<p>I still remember combing through the changelog of every new version of hapi.js, making sure not to miss any breaking changes that would make my projects dysfunctional. Even with the hardships of hapi.js, it did feel like the framework was providing a good set of abstractions. In many ways, following the existing examples from something like Flask in Python, hapi had the necessary components to build highly usable services. Meanwhile, my experiences with Express seemed more reminiscent of working with the jQuery and Backbone.js days. In the Express projects, I could have a highly flexible development environment, combining different Node.js modules to achieve what I wanted from the framework. This made me realize that the perfect framework for me would be something between Express and hapi, in the sense that it would allow me to stay creative, highly productive, and able to utilize the runtime ecosystem to the fullest, while at the same time having a strong opinionated framework core, which would keep my application efficient<a id="_idIndexMarker137"/> and reliable.</p>
<h3>Developer tooling and more</h3>
<p>As part of my profession, I have always<a id="_idIndexMarker138"/> been passionate about open source, so I focused my efforts on contributing<a id="_idIndexMarker139"/> to developer tooling and testing frameworks. I have been a maintainer of <strong class="bold">Grunt.js</strong> (<a href="http://gruntjs.com">gruntjs.com</a>), a JavaScript task runner for many years. Grunt.js has been a core component of frameworks, such as <strong class="bold">Yeoman</strong>, and has been used as a tool<a id="_idIndexMarker140"/> of choice in the early version of AngularJS. The task runner conventions in Node.js have changed a lot since then, but there is still a solid number of projects that use Grunt.js. Maintaining this project for many years feels similar to maintaining a large framework project – releasing new versions, keeping a stable API, supporting it through security bounties, and much more. There is also a huge list of issues, feature demands, pull requests, and plugins to support.</p>
<p>In terms of my testing<a id="_idIndexMarker141"/> framework contributions, I was involved in developing the <strong class="bold">Intern.js</strong> testing framework (<a href="http://github.com/theintern">github.com/theintern</a>), which enabled unit and functional testing for web applications. I was both the contributor and the consumer of this framework in my daily projects, which gave me a unique angle on the project. I was inspired to provide a good integration experience because it would aid my own projects. As part of this effort, besides learning how a testing framework is built, I focused on developing integration examples and documentation for other application frameworks. Covering many integration scenarios in the provided examples made it much easier for developers to integrate this testing system into their applications.</p>
<p>A final notable framework<a id="_idIndexMarker142"/> from my personal experience would be with <strong class="bold">voxel.js</strong> – an open source voxel game-building toolkit. While not that popular, it is a great example of creative use of JavaScript, combining both frontend and backend technologies. It is a framework built by a small team that fills in a niche for an audience of developers, who are looking into working on games and visualizations. voxel.js did not set out to be a world-changing framework; instead, it was a creative outlet for many to create. While exploring voxel.js in my personal project, I learned a lot about unique framework and module structures, and it was fun<a id="_idIndexMarker143"/> to experiment with systems that enable more imaginative thinking.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Contributing to new projects</h2>
<p>These experiences with JavaScript frameworks<a id="_idIndexMarker144"/> in frontend, backend, and developer systems were incredibly valuable to me as part of my career. I have learned the importance of following best practices, adhering to software patterns, and developing for various runtime environments, which ultimately helped me write better code and deliver successful projects. As part of this book, I am sharing my learnings and as much knowledge as possible for the next generation of devoted JavaScript developers to build and contribute to their own framework projects.</p>
<p>The projects that I have been involved in always had different origins. In my case, I had to work with both private and open source frameworks. In work projects, I have focused on combining open source tooling with the context of the larger business organization. This approach helped align the existing tooling with the requirements of particular projects. In the open source context, I have been lucky to contribute to projects that have improved the overall developer experience. In many of the scenarios, I got to work on projects that were innovative and were firsts of their kind in the JavaScript ecosystem. For example, when Grunt.js was coming along, there were task runner tools from other languages, but the JavaScript tools were in their inception. Contributing to voxel.js was a similar experience; as more HTML5 APIs and WebGL enable more advanced graphics on the web, it enabled voxel.js as a project and created the contributor community.</p>
<p>During my contributions to the Intern.js testing framework, the overall feeling was that there were not fully fledged testing frameworks that solved all of the needs of web application testing. The goal of this project was to create an all-in solution for testing using the same types of testing APIs.</p>
<p>The framework that we create in this book focuses on the use of modern technologies, such as Web Components, intermixed with popular JavaScript libraries. The Web Components field does not feel as explored in the ecosystem just yet; therefore, with this book, we are taking aim to further widen the knowledge of these technologies among web developers. Besides expanding those skills, one of the greater goals is to make the framework development process more approachable and demystify the established JavaScript<a id="_idIndexMarker145"/> systems.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Summary</h1>
<p>This first chapter began our exploration into how the web application development process has changed from pure basics into a full-fledged software platform. We have looked at how the innovations and challenges of the web shape the frameworks discussed in this chapter and play a huge role in offering a variety of useful features to web developers. As part of my career journey, working on various projects made me appreciate how much can be achieved by combining elegant patterns and the creative use of the JavaScript programming language.</p>
<p>As part of the framework showcase, it is evident that the ecosystem has a lot of options for the browser and other places where JavaScript runtime functions. However, there is always room for improvement in speed, features, and unique ideas, which can help us enhance the development processes. The significant part that stimulates this ecosystem is the ever-evolving web platform, development of the ECMAScript specification, and of course, the hard work of maintainers of runtimes such as Node.js and Deno.</p>
<p>In the upcoming chapters, we will dive deeper into software paradigms, focusing on framework organization and their architectural patterns. In <a href="B19014_02.xhtml#_idTextAnchor030"><em class="italic">Chapter 2</em></a>, we are going to look at how frameworks are structured and organized.</p>
</div>
</body></html>