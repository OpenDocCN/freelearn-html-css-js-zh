- en: Chapter 6. Prototype
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you'll learn about the prototype property of the function objects.
    Understanding how the prototype works is an important part of learning the JavaScript
    language. After all, JavaScript is often classified as having a prototype-based
    object model. There's nothing particularly difficult about the prototype, but
    it's a new concept, and as such, may sometimes take a bit of time to sink in.
    Like closures (see [Chapter 3](ch03.html "Chapter 3. Functions"), *Functions*),
    the prototype is one of those things in JavaScript which, once you get, seem so
    obvious and make perfect sense. As with the rest of this book, you're strongly
    encouraged to type in and play around with the examples - this makes it much easier
    to learn and remember the concepts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Every function has a `prototype` property and it contains an object
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding properties to the prototype object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the properties added to the prototype
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between own properties and properties of the prototype
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `__proto__` property, the secret link every object keeps to its prototype
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods such as `isPrototypeOf()`, `hasOwnProperty()`, and `propertyIsEnumerable()`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing built-in objects, such as arrays or strings, and why that can be a
    bad idea
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The prototype property
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The functions in JavaScript are objects, and they contain methods and properties.
    Some of the methods that you're already familiar with are `apply()` and `call()`,
    and some of the other properties are `length` and `constructor`. Another property
    of the function objects is `prototype`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'If you define a simple function, `foo()`, you can access its properties as
    you would do with any other object. Consider the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `prototype` property is a property that is available to you as soon as
    you define the function. Its initial value is an empty object:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It''s as if you have added this property yourself, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can augment this empty object with properties and methods. They won't have
    any effect on the `foo()` function itself; they'll only be used if you call `foo()`
    as a constructor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Adding methods and properties using the prototype
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to define constructor functions that
    you can use to create (construct) new objects. The main idea is that, inside a
    function invoked with `new`, you will have access to the `this` value, which refers
    to the object to be returned by the constructor. Augmenting, which is adding methods
    and properties to `this`, is how you can add functionality to the object being
    constructed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the constructor function, `Gadget()`, which uses `this`
    to add two properties and one method to the objects it creates, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Adding methods and properties to the `prototype` property of the constructor
    function is another way to add functionality to the objects this constructor produces.
    Let''s add two more properties, `price` and `rating`, as well as a `getInfo()`
    method. As `prototype` already points to an object, you can just keep adding properties
    and methods to it, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, instead of adding properties to the `prototype` object one by
    one, you can overwrite the `prototype` completely, replacing it with an object
    of your choice, as shown in the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Using the prototype's methods and properties
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All the methods and properties you have added to the `prototype` are available
    as soon as you create a new object using the constructor. If you create a `newtoy`
    object using the `Gadget()` constructor, you can access all the methods and properties
    that are already defined, as you can see in the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's important to note that the `prototype` is live. Objects are passed by reference
    in JavaScript, and therefore, the `prototype` is not copied with every new object
    instance. What does this mean in practice? It means that you can modify the `prototype`
    at any time, and all the objects, even those created before the modification,
    will see the changes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue the example by adding a new method to the `prototype`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Even though the `newtoy` object was created before the `get()` method was defined,
    the `newtoy` object still has access to the new method, which is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Own properties versus prototype properties
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding example, `getInfo()` was used internally to access the properties
    of the object. It could''ve also used `Gadget.prototype` to achieve the same output,
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What's the difference? To answer this question, let's examine in detail how
    the `prototype` works.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the `newtoy` object again:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you try to access a property of `newtoy`, say, `newtoy.name`, the JavaScript
    engine looks through all of the properties of the object searching for one called
    `name`, and if it finds it, it returns its value, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What if you try to access the `rating` property? The JavaScript engine examines
    all of the properties of the `newtoy` object and doesn''t find the one called
    `rating`. Then, the script engine identifies the `prototype` of the constructor
    function used to create this object (the same as if you do `newtoy.constructor.prototype`).
    If the property is found in the `prototype` object, the following property is
    used:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can do the same and access the `prototype` directly. Every object has a
    `constructor` property, which is a reference to the function that created the
    object, so in this case look at the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s take this lookup one step further. Every object has a constructor.
    The `prototype` is an object, so it must have a constructor too, which, in turn,
    has a `prototype`. You can go up the prototype chain, and you will eventually
    end up with the built-in `Object()` object, which is the highest-level parent.
    In practice, this means that if you try `newtoy.toString()` and `newtoy` doesn''t
    have its own `toString()` method, and its `prototype` doesn''t either, in the
    end, you''ll get the object''s `toString()` method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Overwriting a prototype's property with an own property
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the preceding discussion demonstrates, if one of your objects doesn't have
    a certain property of its own, it can use one, if it exists, somewhere up the
    prototype chain. What if the object does have its own property and the prototype
    also has one with the same name? Then, the own property takes precedence over
    the prototype's.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where a property name exists as both an own property and
    a property of the `prototype` object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Creating a new object and accessing its `name` property gives you the object''s
    own `name` property, as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can tell where the property was defined using `hasOwnProperty()`, which
    is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you delete the `toy` object''s own `name` property, the prototype''s property
    with the same name shines through:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Of course, you can always recreate the object''s own property as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can play around with the `hasOwnProperty()` method to find out the origins
    of a particular property you're curious about. The `toString()` method was mentioned
    earlier. Where is it coming from?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Enumerating properties
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you want to list all the properties of an object, you can use a `for...in`
    loop. In [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops,
    and Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*, you saw
    that you can also loop through all the elements of an array with `for...in`, but
    as mentioned there, `for` is better suited for arrays and `for...in` for objects.
    Let''s take an example of constructing a query string for a URL from an object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This produces the `url` string as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`http://example.org/page.php?productid=666&section=products`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are a few details to be aware of:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: Not all properties show up in a `for...in` loop. For example, the length (for
    arrays) and constructor properties don't show up. The properties that do show
    up are called enumerable. You can check which ones are enumerable with the help
    of the `propertyIsEnumerable()` method that every object provides. In ES5, you
    can specify which properties are enumerable, while in ES3 you don't have that
    control.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototypes that come through the prototype chain also show up, provided they
    are enumerable. You can check whether a property is an object's own property or
    a prototype's property using the `hasOwnProperty()` method.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `propertyIsEnumerable()` method returns `false` for all of the prototype's
    properties, even those that are enumerable and show up in the `for...in` loop.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s see these methods in action. Take this simplified version of `Gadget()`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create a new object as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, if you loop using a `for...in` loop, you can see all of the object''s
    properties, including those that come from the prototype:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result also contains the object''s methods, as methods are just properties
    that happen to be functions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you want to distinguish between the object''s own properties and the prototype''s
    properties, use `hasOwnProperty()`. Try the following first:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s loop again, but this time, showing only the object''s own properties:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, let''s try `propertyIsEnumerable()`. This method returns `true` for the
    object''s own properties that are not built in, for example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Most built-in properties and methods are not enumerable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Any properties coming down the prototype chain are not enumerable:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'However, not that such properties are enumerable if you reach the object contained
    in the `prototype` and invoke its `propertyIsEnumerable()` method. Consider the
    following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Using isPrototypeOf() method
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects also have the `isPrototypeOf()` method. This method tells you whether
    that specific object is used as a prototype of another object.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a simple object named `monkey`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s create a `Human()` constructor function and set its `prototype`
    property to point to `monkey`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, if you create a new `Human` object called `george` and ask If `monkey`
    the prototype of `george`?, you''ll get `true`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that you have to know, or suspect, who the prototype is and then ask is
    it true that your prototype is `monkey`? in order to confirm your suspicion. But,
    what if you don't suspect anything, and you have no idea? Can you just ask the
    object to tell you its prototype? The answer is, you can't in all browsers, but
    you can in most of them. Most recent browsers have implemented the addition to
    ES5 called `Object.getPrototypeOf()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For some of the pre-ES5 environments that don't have `getPrototypeOf()`, you
    can use the special property, `__proto__`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The secret __proto__ link
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you already know, the `prototype` property is consulted when you try to access
    a property that does not exist in the current object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider another object called `monkey`, and use it as a prototype when creating
    objects with the `Human()` constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s create a `developer` object, and give it the following properties:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, let''s access these properties (for example, `hacks` is a property of
    the `developer` object):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `feeds` property can also be found in the object, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `breathes` property doesn''t exist as a property of the `developer` object,
    so the prototype is looked up, as if there is a secret link or passageway that
    leads to the `prototype` object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The secret link is exposed in most modern JavaScript environments as the `__proto__`
    property, the word `proto` with two underscores before and after:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can use this secret property for learning purposes, but it's not a good
    idea to use it in your real scripts because it does not exist in all browsers
    (notably IE), so your scripts won't be portable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Be aware that `__proto__` is not the same as `prototype`, as `__proto__` is
    a property of the instances (objects), whereas `prototype` is a property of the
    constructor functions used to create those objects:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once again, you should use `__proto__` only for learning or debugging purposes.
    Or, if you're lucky enough and your code only needs to work in ES5-compliant environments,
    you can use `Object.getPrototypeOf()`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Augmenting built-in objects
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The objects created by the built-in constructor functions, such as `Array`,
    `String`, and even `Object` and `Function`, can be augmented (or enhanced) through
    the use of prototypes. This means that you can, for example, add new methods to
    the `Array` prototype, and in this way you can make them available to all arrays.
    Let's see how to do this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'In PHP, there is a function called `in_array()`, which tells you whether a
    value exists in an array. In JavaScript, there is no `inArray()` method, although,
    in ES5, there''s `indexOf()`, which you can use for the same purpose. So, let''s
    implement it and add it to `Array.prototype`, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, all arrays have access to the new method. Let''s test the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That was nice and easy! Let''s do it again. Imagine your application often
    needs to spell words backward, and you feel there should be a built-in `reverse()`
    method for string objects. After all, arrays have `reverse()`. You can easily
    add a `reverse()` method to the `String` prototype by borrowing `Array.prototype.reverse()`
    (there was a similar exercise at the end of [Chapter 4](ch04.html "Chapter 4. Objects"),
    *Objects*):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This code uses the `split()` method to create an array from a string, then
    calls the `reverse()` method on this array, which produces a reversed array. The
    resulting array is then turned back into a string using the `join()` method. Let''s
    test the new method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Augmenting built-in objects - discussion
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Augmenting built-in objects through the prototype is a powerful technique, and
    you can use it to shape JavaScript in any way you like. Because of its power,
    though, you should always thoroughly consider your options before using this approach.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that once you know JavaScript, you're expecting it to work the
    same way, no matter which third-party library or widget you're using. Modifying
    core objects can confuse the users and maintainers of your code and create unexpected
    errors.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript evolves and browser's vendors continuously support more features.
    What you consider a missing method today and decide to add to a core prototype
    could be a built-in method tomorrow. In this case, your method is no longer needed.
    Additionally, what if you have already written a lot of code that uses the method
    and your method is slightly different from the new built-in implementation?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The most common and acceptable use case to augment built-in prototypes is to
    add support for new features (ones that are already standardized by the ECMAScript
    committee and implemented in new browsers) to old browsers. One example will be
    adding an ES5 method to old versions of IE. These extensions are known as **shims**
    or **polyfills**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'When augmenting prototypes, you will first check if the method exists before
    implementing it yourself. This way, you can use the native implementation in the
    browser if one exists. For example, let''s add the `trim()` method for strings,
    which is a method that exists in ES5 but is missing in older browsers:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Tip
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to augment a built-in object, or its prototype with a new property,
    do check for the existence of the new property first.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Prototype gotchas
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the two important behaviors to consider when dealing with
    prototypes:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The prototype chain is live, except for when you completely replace the `prototype`
    object
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `prototype.constructor` method is not reliable
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a simple constructor function and two objects:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Even after you''ve created the `benji` and `rusty` objects, you can still add
    properties to the prototype of `Dog()` and the existing objects will have access
    to the new properties. Let''s throw in the `say()` method:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Both objects have access to the new method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Up to this point, if you consult your objects, asking which constructor function
    was used to create them, they''ll report it correctly:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let''s completely overwrite the `prototype` object with a brand new object:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It turns out that the old objects do not get access to the new prototype''s
    properties; they still keep the secret link pointing to the old prototype object,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Any new objects that you will create from now on will use the updated prototype,
    which is as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The secret `__proto__` link points to the new prototype object, as shown in
    the following lines of code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now the `constructor` property of the new object no longer reports correctly.
    You will expect it to point to `Dog()`, but instead it points to `Object()`, as
    you can see in the following example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You can easily prevent this confusion by resetting the `constructor` property
    after you overwrite the prototype completely, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Tip
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Best practice**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: When you overwrite the prototype, remember to reset the `constructor` property.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lets practice the following exercise:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Create an object called `shape` that has the type `property` and a `getType()`
    method.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a `Triangle()` constructor function whose prototype is `shape`. Objects
    created with `Triangle()` should have three own properties-`a`, `b`, and `c`,
    representing the lengths of the sides of a triangle.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`Triangle()`构造函数，其原型是`shape`。使用`Triangle()`创建的对象应该有三个自己的属性-`a`、`b`和`c`，分别代表三角形的三边长度。
- en: Add a new method to the prototype called `getPerimeter()`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原型中添加一个名为`getPerimeter()`的新方法。
- en: 'Test your implementation with the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码测试你的实现：
- en: '[PRE59]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Loop over `t`, showing only your own properties and methods, none of the prototype's.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历`t`，只显示你的自己的属性和方法，不显示原型的任何属性。
- en: 'Make the following code work:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让以下代码工作：
- en: '[PRE60]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let''s summarize the most important topics you have learned in this chapter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下你在本章中学到的最重要的主题：
- en: All functions have a property called `prototype`. Initially, it contains an
    empty object-an object without any own properties.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有函数都有一个名为`prototype`的属性。最初，它包含一个空对象——一个没有任何自己的属性的对象。
- en: You can add properties and methods to the `prototype` object. You can even replace
    it completely with an object of your choice.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以向`prototype`对象添加属性和方法。你甚至可以完全用你选择的对象替换它。
- en: When you create an object using a function as a constructor (with `new`), the
    object gets a secret link pointing to the prototype of the constructor and can
    access the prototype's properties.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你使用函数作为构造函数（使用`new`关键字）创建一个对象时，该对象会获得一个指向构造函数原型的秘密链接，并可以访问原型的属性。
- en: An object's own properties take precedence over a prototype's properties with
    the same name.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的自身属性具有比同名原型属性更高的优先级。
- en: Use the `hasOwnProperty()` method to differentiate between an object's own properties
    and `prototype` properties.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`hasOwnProperty()`方法来区分对象的自身属性和`prototype`属性。
- en: There is a prototype chain. When you execute `foo.bar`, and if your `foo` object
    doesn't have a property called `bar`, the JavaScript interpreter looks for a `bar`
    property in the prototype. If none is found, it keeps searching in the prototype's
    prototype, then the prototype of the prototype's prototype, and it will keep going
    all the way up to `Object.prototype`.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在一个原型链。当你执行`foo.bar`，如果`foo`对象没有名为`bar`的属性，JavaScript解释器会在原型中查找`bar`属性。如果没有找到，它会继续在原型的原型中查找，然后是原型的原型的原型，并且会一直向上查找，直到`Object.prototype`。
- en: You can augment the prototypes of built-in constructor functions, and all objects
    will see your additions. Assign a function to `Array.prototype.flip` and all arrays
    will immediately get a `flip()` method, as in `[1,2,3].flip()`. But, do check
    whether the method/property you want to add already exists, so you can future-proof
    your scripts.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以增强内置构造函数的原型，所有对象都将看到你的添加。将一个函数赋值给`Array.prototype.flip`，所有数组将立即获得一个`flip()`方法，就像`[1,2,3].flip()`。但是，请确保你想要添加的方法/属性尚未存在，这样你可以确保你的脚本在未来是安全的。
