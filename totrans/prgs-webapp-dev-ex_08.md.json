["```js\n   login: function (credentials) { \n          return fetch(api + \n               \"users/?userName=\" + \n                credentials.username + \n                \"password=\" + credentials.password) \n                .then(function (response) { \n\n                if (response.ok) { \n                      return response.json() \n                      .then(function (token) { \n                       if (token.length > 0) { \n                              return saveAuthToken(token[0]); \n                             } \n                           });\n```", "```js\n                     } else { \n                     throw \"user tickets fetch failed\"; \n                    } \n                 }); \n        } \n```", "```js\n{ \n    tickets: [], \n    users: [], \n    futureEvents: [], \n    pastEvents: [], \n    contact: [] \n} \n```", "```js\njson-server --watch db.json \n```", "```js\njson-server --watch db.json -port 15501 \n```", "```js\n>npm run api-server \n>npm run web-server \n```", "```js\nhttp://localhost:15501/users/\n```", "```js\n[ \n  { \n    \"id\": \"891ad435-41f3-4b83-929b-18d8870a53a4\", \n    \"firstName\": \"Catharine\", \n    \"lastName\": \"Cormier\", \n    \"mugshot\": \"avtar-2.jpg\", \n    \"userName\": \"Clay.Parker\", \n    \"password\": \"93gQtXaB0Tc3JM5\", \n    \"streetAddress\": \"401 Kassulke Square\", \n    \"city\": \"Cronintown\", \n    \"state\": \"Vermont\", \n    \"zipCode\": \"09904-5827\", \n    \"email\": \"Bradly_Fahey56@gmail.com\", \n    \"phoneNumber\": \"400.748.9656 x0600\", \n    \"tickets\": [...] \n  }, {...} \n] \n```", "```js\n    let user = { \n        \"id\": faker.random.uuid(), \n        \"firstName\": faker.name.firstName(), \n        \"lastName\": faker.name.lastName(), \n        \"mugshot\": mugshots[mugshot], \n        \"userName\": faker.internet.userName(), \n        \"password\": faker.internet.password(), \n        \"streetAddress\": faker.address.streetAddress(), \n        \"city\": faker.address.city(), \n        \"state\": faker.address.state(), \n        \"zipCode\": faker.address.zipCode(), \n        \"email\": faker.internet.email(), \n        \"phoneNumber\": faker.phone.phoneNumber() \n    } \n```", "```js\n    let dataURI = qr(id, { \n        type: 6, \n        size: 6, \n        level: 'Q' \n    }); \n```", "```js\nba64.writeImageSync(qrCodePath + \"/\" + id, dataURI); \n```", "```js\n{ \n    \"name\": \"events\", \n    \"slug\": \"events\", \n    \"scripts\": [\"js/app/pages/events.js\"], \n    \"css\": [] \n} \n```", "```js\n>node render-public \n```", "```js\nvar pwaTicketAPI = (function () { \n\n    var api = \"http://localhost:15501/\", \n        authToken = \"auth-token\"; \n\n    function saveAuthToken(token) { \n\n        return localforage.setItem(authToken, token) \n            .then(function () { \n                return token; \n            }); \n     }\n```", "```js\n    return { \n      //API wrapper methods go here \n    }; \n\n})(); \n```", "```js\ngetUser: function (userId) { \n\n    return fetch(api + \"users/\" + userId) \n        .then(function (response) { \n\n            if (response.ok) { \n               return response.json();  \n            } else { \n\n                throw \"user tickets fetch failed\"; \n            } \n        }); \n}, \n```", "```js\nupdateUser: function (user) { \n\n    return fetch({ \n        \"method\": \"POST\", \n        \"Content-Type\": \"application/json\", \n        \"body\": JSON.stringify(user), \n        \"url\": api + \"users/\" \n    }); \n}, \n```", "```js\n(function () { \n\n//no need to render if service workers are supported \n//unless the service worker is not in control of the page yet. \n//test if the loader element exists. If so then fetch the data to //render \nif (_d.qs(\".loader\")) { \n        pwaTicketAPI.loadTemplate(\"templates/event.html\") \n       .then(function (template) { \n\n         if (template) {                        \n           pwaTicketAPI.getEvent(pwaTickets.getParameterByName(\"id\")) \n            .then(function (event) { \n\n         var target = _d.qs(\".content-target\"); \n\n         target.innerHTML = Mustache.render(template, event); \n           }); \n            } \n            }) \n            .catch(function (err) { \n               console.log(err); \n         }); \n    } \n})(); \n```", "```js\n<div class=\"loader\"></div> \n```", "```js\n    <main class=\"page-content content-target\"> \n        <%template%> \n    </main> \n```", "```js\nvar _d = { \n    qs: function (s) { \n        return document.querySelector(s); \n    }, \n    qsa: function (s) { \n        return document.querySelectorAll(s); \n    }, \n    gei: function (s) { \n        return document.getElementById(s); \n    }, \n    gen: function (s) { \n        return document.getElementsByName(s); \n    } \n}; \n```", "```js\nself.importScripts(\"js/libs/localforage.min.js\", \n    \"js/app/libs/api.js\",  \n    \"sw/response-mgr.js\",  \n    \"sw/push-mgr.js\", \n    \"sw/invalidation-mgr.js\",  \n    \"sw/date-mgr.js\" \n); \n```", "```js\n\nclass ResponseManager { \n   fetchText(url) {...} \n   fetchJSON(url) {...} \n   fetchAndRenderResponseCache(options) {...} \n   cacheFallingBackToNetwork(request, cacheName) {...} \n   cacheFallingBackToNetworkCache(request, cacheName) {...} \n   cacheOnly(request, cacheName) {...} \n   networkOnly(request) {...} \n\n} \n```", "```js\ncacheOnly(request, cacheName) { \n    return caches.match(request); \n} \n\nnetworkOnly(request) { \n    return fetch(request); \n}\n```", "```js\n<div class=\"card ticket-card\" id=\"{{id}}\"> \n    <div class=\"card-header\"> \n        <h5 class=\"card-title\">{{event.title}}</h5> \n    </div> \n    <div class=\"row\"> \n        <div class=\"col-md-6 text-center\"> \n            <img class=\"card-img-top ticket-barcode\" \n           src=\"img/{{barcode}}\"  \n             alt=\"{{id}}\" /> \n        </div> \n        <div class=\"col-md-6\"> \n            <div class=\"card-body\"> \n                <p class=\"card-text\">{{event.venue}}</p> \n                <p class=\"card-text\">{{event.date}} - {{event.city}} \n                {{event.state}}</p> \n                <p class=\"card-text\">{{id}}</p> \n            </div> \n            <ul class=\"list-group list-group-flush\"> \n                <li class=\"list-group-item\">Section {{section}}</li> \n                <li class=\"list-group-item\">Row {{row}}</li> \n                <li class=\"list-group-item\">Seat {{seat}}</li> \n            </ul> \n        </div> \n    </div> \n</div> \n```", "```js\nresponseManager.cacheOnly(request, runtimeCache) \n  .then(response => { \n   return response ||  \n             responseManager.fetchAndRenderResponseCache({...}); \n}); \n```", "```js\n{ \n    request: //the request that triggered the fetch \n    pageURL: \"url to core page html\", \n    template: \"url to the data template\", \n    api: //a method to execute that makes the API call, \n    cacheName: \"cache name to save the rendered response\" \n} \n```", "```js\nfetchAndRenderResponseCache(options) { \n    return fetchText(options.pageURL) \n        .then(pageHTML => { \n            return fetchText(options.template) \n                .then(template => { \n                    return pageHTML.replace(/<%template%>/g, template); \n                }); \n        }) \n```", "```js\n        .then(pageTemplate => { \n            return options.api() \n                .then(data => { \n                    return Mustache.render(pageTemplate, data); \n                }); \n```", "```js\n\n        }).then(html => { \n\n            //make custom response \n            let response = new Response(html, { \n                    headers: { \n                        'content-type': 'text/html' \n                    } \n                }), \n                copy = response.clone(); \n\n            caches.open(options.cacheName) \n                .then(cache => { \n                    cache.put(options.request, copy); \n                }); \n\n            return response; \n\n        }); \n} \n```", "```js\nif (!responseManager.isResponseNotFound(response)  \n    request.method.toUpperCase() === \"GET\"  \n    request.url.indexOf(\"chrome-extension\") === -1  \n    responseManager.isResponseCacheable(response)) { \n\n    //cache response here \n} \n```", "```js\nrouteRules = [ \n{ \n    \"url\": /event?/, \n    \"strategy\": \"fetchAndRenderResponseCache\", \n    \"options\": {...}, \n    \"cacheName\": eventsCacheName \n},  \n{ \n    \"url\": /qrcodes?/, \n    \"strategy\": \"cacheFallingBackToNetworkCache\", \n    \"cacheName\": qrCodesCacheName \n}  \n]; \n```", "```js\nself.addEventListener(\"fetch\", event => { \n    event.respondWith( \n        handleResponse(event) \n    ); \n});\n```", "```js\nfunction testRequestRule(url, rules) { \n\n    for (let i = 0; i < rules.length - 1; i++) { \n\n        if (rules[i].route.test(url)) { \n            return rules[i]; \n        } \n    } \n} \n```", "```js\nfunction handleResponse(event) { \n\n    let cacheName = getCacheName(event.request.url); \n    let rule = testRequestRule(event.request.url, routeRules); \n\n    rule = rule || {}; \n\n    switch(rule.strategy){ \n       // \n    } \n} \n```", "```js\n    case \"cacheFallingBackToNetwork\": \n\n        return responseManager.cacheFallingBackToNetworkCache(event.request, \n        cacheName); \n\n        break; \n```", "```js\n    case \"cacheFallingBackToNetworkCache\": \n    default: \n         return   \n        responseManager.cacheFallingBackToNetworkCache(event.request, \n        cacheName) \n            .then(response => { \n\n                invalidationManager.cacheCleanUp(cacheName); \n                return response; \n\n            }); \n\n        break; \n```", "```js\nfunction getHash(data) { \n    var md5 = crypto.createHash('md5'); \n    md5.update(data); \n\n    return md5.digest('hex'); \n} \n```", "```js\n    maxItems(options) { \n\n        self.caches.open(options.cacheName) \n            .then((cache) => { \n\n                cache.keys().then((keys) => { \n\n                    if (keys.length > options.strategyOptions.max) { \n\n                        let purge = keys.length - \n                        options.strategyOptions.max; \n\n                        for (let i = 0; i < purge; i++) { \n                            cache.delete(keys[i]); \n                        } \n\n                    } \n\n                }); \n            }); \n    } \n```", "```js\nlet responseDate = new Date(response.headers.get(\"date\")), \n  currentDate = Date.now(); \n\nif(!DateManager.compareDates(currentDate,  \n  DateManager.addSecondsToDate(responseDate, 300))) { \n    cache.add(request); \n}else{ \n    cache.delete(request); \n} \n```", "```js\nself.addEventListener(\"fetch\", event => { \n\n    let cacheName = getCacheName(event.request.url); \n\n    event.respondWith( \n\n        responseManager.cacheFallingBackToNetworkCache(event.request, \n        cacheName) \n        .then(response => { \n\n          invalidationManager.cacheCleanUp(cacheName); \n\n          return response;     \n        })     \n    ); \n}); \n```", "```js\ninvalidationManager = new InvalidationManager([{ \n        \"cacheName\": preCache, \n        \"invalidationStrategy\": \"ttl\", \n        \"strategyOptions\": { \n          \"ttl\": 604800 //1 week }\n         },\n        { \"cacheName\": qrCodesCacheName,\n          \"invalidationStrategy\": \"maxItems\",\n          \"strategyOptions\": { \"max\": 10 }\n        }]);\n```", "```js\ncacheCleanUp() { \n     let invMgr = this; \n     invMgr.invalidationRules.forEach((value) => { \n         switch (value.invalidationStrategy) { \n             case \"ttl\": \n                 invMgr.updateStaleEntries(value); \n                 break; \n\n            case \"maxItems\": \n                 invMgr.maxItems(value); \n                break; \n             default: \n                 break; \n        } \n    }); \n} \n```", "```js\nmaxItems(options) { \n\n    self.caches.open(options.cacheName) \n        .then(cache => { \n\n            cache.keys().then(keys => { \n\n                if (keys.length > options.strategyOptions.max) { \n\n                    let purge = keys.length - \n                    options.strategyOptions.max; \n\n                    for (let i = 0; i < purge; i++) { \n                        cache.delete(keys[i]); \n                    } \n\n                } \n\n            }); \n        }); \n} \n```", "```js\nupdateStaleEntries(rule) { \n\n    self.caches.open(rule.cacheName) \n        .then(cache => { \n\n            cache.keys().then(keys => { \n\n                keys.forEach((request, index, array) => { \n\n                    cache.match(request).then(response => { \n\n                        let date = new \n                        Date(response.headers.get(\"date\")), \n                            current = new Date(Date.now()); \n\n                        if (!DateManager.compareDates(current, \n                                DateManager.addSecondsToDate(date,  \n                                    rule.strategyOptions.ttl))) { \n\n                            cache.delete(request); \n\n                        } \n                    }); \n                }); \n            }); \n        }); \n} \n```", "```js\n[{ \n    \"url\": \"/\", \n    \"strategy\": \"precache-dependency\", \n    \"ttl\": 604800 \n}, { \n    \"url\": \"/privacy\", \n    \"strategy\": \"genericFallback\", \n    \"fallback\": \"fallback/\", \n    \"ttl\": 604800 \n}, { \n    \"url\": \"/product/*\", \n    \"strategy\": \"cacheFirst\", \n    \"ttl\": 1800 \n}, \n... \n] \n```", "```js\nprocessDynamicRequest(request) { \n\n    var routeTest = new RegExp(this.routes), \n        result = routeTest.exec(request.url); \n\n    if (result) { \n\n        var match = result.shift(), \n            index = result.indexOf(match); \n\n        //return request handler. Should be a promise. \n        return strategyManager[this.strategies[index - 1]](request); \n\n    } else { \n\n        //default to pass-through \n        return fetch(request); \n\n    } \n} \n```", "```js\n    canUpdateCacheManifest() { \n\n        let cm = this, \n            now = new Date(); \n\n        //retrieve persisted list of precached URLs \n        return cm.idbkv.get(this.CACHE_UPDATE_TTL_KEY).then(ret => { \n\n            if (!ret) { \n                return true; \n            } \n\n            return cm.dateMgr.compareDates(ret, Date.now()); \n\n        }); \n\n    } \n```"]