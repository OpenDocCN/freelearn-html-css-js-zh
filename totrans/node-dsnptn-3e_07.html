<html><head></head><body>
  <div id="_idContainer140">
    <h1 class="chapterNumber">7</h1>
    <h1 id="_idParaDest-190" class="chapterTitle">Creational Design Patterns</h1>
    <p class="normal">A design pattern is a reusable solution to a recurring problem. The term is really broad in its definition and can span multiple domains of an application. However, the term is often associated with a well-known set of object-oriented patterns that were popularized in the 90s by the book, <em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>, <em class="italic">Pearson Education</em>, by the almost legendary <strong class="keyword">Gang of Four</strong> (<strong class="keyword">GoF</strong>): Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. We will often refer to these specific sets of patterns as <em class="italic">traditional</em> design patterns or GoF design patterns.</p>
    <p class="normal">Applying this set of object-oriented design patterns in JavaScript is not as linear and formal as it would be in a classical object-oriented language. As we know, JavaScript is object-oriented, prototype-based, and has dynamic typing. It also treats functions as first-class citizens and allows functional programming styles. These characteristics make JavaScript a very versatile language, which gives tremendous power to the developer but at the same time, it causes fragmentation of programming styles, conventions, techniques, and ultimately the patterns of its ecosystem. With JavaScript, there are so many ways to achieve the same result that each developer has their own opinion on what's the best way to approach a problem. A clear demonstration of this phenomenon is the abundance of frameworks and opinionated libraries in the JavaScript ecosystem; probably no other language has ever seen so many, especially now that Node.js has given new astonishing possibilities to JavaScript and has created so many new scenarios.</p>
    <p class="normal">In this context, the nature of JavaScript affects traditional design patterns too. There are so many ways in which traditional design patterns can be implemented in JavaScript that the traditional, strongly object-oriented implementation stops being relevant.</p>
    <p class="normal">In some cases, the traditional implementation of these design patterns is not even possible because JavaScript, as we know, doesn't have <em class="italic">real</em> classes or abstract interfaces. What doesn't change, though, is the original idea at the base of each pattern, the problem it solves, and the concepts at the heart of the solution.</p>
    <p class="normal">In this chapter and in the two that follow, we will see how some of the most important GoF design patterns apply to Node.js and its philosophy, thus rediscovering their importance from another perspective. Among these traditional patterns, we will also have a look at some "less traditional" design patterns born from within the JavaScript ecosystem itself.</p>
    <p class="normal">In this chapter, in particular, we'll take a look at a class of design patterns called <strong class="keyword">creational</strong>. As the name suggests, these patterns address problems related to the creation of objects. For example, the <em class="italic">Factory</em> pattern allows us to encapsulate the creation of an object within a function. The <em class="italic">Revealing Constructor</em> pattern allows us to expose private object properties and methods only during the object's creation, while the <em class="italic">Builder</em> pattern simplifies the creation of complex objects. Finally, the <em class="italic">Singleton</em> pattern and the <em class="italic">Dependency Injection</em> pattern help us with wiring the modules within our applications.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">This chapter, as well as the following two, assume that you have some notion of how inheritance works in JavaScript. Please also be advised that we will often use generic and more intuitive diagrams to describe a pattern in place of standard UML. This is because many patterns can have an implementation based not only on classes but also on objects and even functions.</p>
    </div>
    <h1 id="_idParaDest-191" class="title">Factory</h1>
    <p class="normal">We'll begin our journey from one of the most common design patterns in Node.js: <strong class="keyword">Factory</strong>. As you will see, the Factory pattern<a id="_idIndexMarker545"/> is very versatile and has more than just one purpose. Its main advantage is its ability to decouple the creation of an object from one particular implementation. This allows us, for example, to create an object whose class is determined at runtime. Factory also allows us to expose "a surface area" that is much smaller than that of a class; a class can be extended or manipulated, while a factory, being just a function, offers fewer options to the user, making it more robust and easier to understand. Finally, a factory can also be used to enforce encapsulation by leveraging closures.</p>
    <h2 id="_idParaDest-192" class="title">Decoupling object creation and implementation</h2>
    <p class="normal">We already <a id="_idIndexMarker546"/>stressed the fact that, in JavaScript, the functional paradigm is often preferred to a purely object-oriented design for its simplicity, usability, and <em class="italic">small surface area</em>. This is especially true when creating new object instances. In fact, invoking a factory, instead of directly creating a new object from a class using the <code class="Code-In-Text--PACKT-">new</code> operator or <code class="Code-In-Text--PACKT-">Object.create()</code>, is so much more convenient and flexible in several respects.</p>
    <p class="normal">First and foremost, a factory allows us to <em class="italic">separate the creation of an object from its implementation</em>. Essentially, a factory wraps the creation of a new instance, giving us more flexibility and control in the way we do it. Inside the factory, we can choose to create a new instance of a class using the <code class="Code-In-Text--PACKT-">new</code> operator, or leverage closures to dynamically build a stateful object literal, or even return a different object type based on a particular condition. The consumer of the factory is totally agnostic about how the creation of the instance is carried out. The truth is that, by using <code class="Code-In-Text--PACKT-">new</code>, we are binding our code to one specific way of creating an object, while with a factory, we can have much more flexibility, almost for free. As <a id="_idIndexMarker547"/>a quick example, let's consider a simple factory that creates an <code class="Code-In-Text--PACKT-">Image</code> object:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">createImage</span><span class="hljs-function"> (</span><span class="hljs-params">name</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Image(name)
}
<span class="hljs-keyword">const</span> image = createImage(<span class="hljs-string">'photo.jpeg'</span>)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">createImage()</code> factory might look totally unnecessary; why not instantiate the <code class="Code-In-Text--PACKT-">Image</code> class by using the <code class="Code-In-Text--PACKT-">new</code> operator directly? Why not write something like the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> Image(name)
</code></pre>
    <p class="normal">As we already mentioned, using <code class="Code-In-Text--PACKT-">new</code> binds our code to one particular type of object, which in the preceding case is to the <code class="Code-In-Text--PACKT-">Image</code> object type. A factory, on the other hand, gives us much more flexibility. Imagine that we want to refactor the <code class="Code-In-Text--PACKT-">Image</code> class, splitting it into smaller classes, one for each image format that we support. </p>
    <p class="normal">If we exposed a factory as the only means to create new images, we could simply rewrite it as follows, without breaking any of the existing code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">createImage</span><span class="hljs-function"> (</span><span class="hljs-params">name</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">if</span> (name.match(<span class="hljs-regexp">/\.jpe?g$/</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ImageJpeg(name)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.match(<span class="hljs-regexp">/\.gif$/</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ImageGif(name)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name.match(<span class="hljs-regexp">/\.png$/</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ImagePng(name)
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Unsupported format'</span>)
  }
}
</code></pre>
    <p class="normal">Our factory also allows us to keep the classes hidden and prevents them from being extended or modified (remember the principle of small surface area?). In JavaScript, this can be achieved by exporting only the factory, while keeping the classes private.</p>
    <h2 id="_idParaDest-193" class="title">A mechanism to enforce encapsulation</h2>
    <p class="normal">A factory can also be used as an <strong class="keyword">encapsulation</strong> mechanism, thanks to closures.</p>
    <p class="normal">Encapsulation refers<a id="_idIndexMarker548"/> to controlling the access to some internal details of a component by preventing external code from manipulating them directly. The interaction with the component happens only through its public interface, isolating the external code from<a id="_idIndexMarker549"/> the changes in the implementation details of the component. Encapsulation is a fundamental principle of object-oriented design, together with inheritance, polymorphism, and abstraction.</p>
    <p class="normal">In JavaScript, one of the main ways to enforce encapsulation is through function scopes and closures. A factory makes it straightforward to enforce private variables. Consider the following, for example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">createPerson</span><span class="hljs-function"> (</span><span class="hljs-params">name</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">const</span> privateProperties = {}
  <span class="hljs-keyword">const</span> person = {
    setName (name) {
      <span class="hljs-keyword">if</span> (!name) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'A person must have a name'</span>)
      }
      privateProperties.name = name
    },
    getName () {
      <span class="hljs-keyword">return</span> privateProperties.name
    }
  }
  person.setName(name)
  <span class="hljs-keyword">return</span> person
}
</code></pre>
    <p class="normal">In the preceding code, we leverage a closure to create two objects: a <code class="Code-In-Text--PACKT-">person</code> object, which represents the public interface returned by the factory, and a group of <code class="Code-In-Text--PACKT-">privateProperties</code> that are inaccessible from the outside and that can be manipulated only through the interface provided by the <code class="Code-In-Text--PACKT-">person</code> object. For example, in the preceding code, we make sure that a person's <code class="Code-In-Text--PACKT-">name</code> is never empty; this would not be possible to enforce if <code class="Code-In-Text--PACKT-">name</code> was just a normal property of the <code class="Code-In-Text--PACKT-">person</code> object.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Using closures is not the only technique that we have for enforcing encapsulation. In fact, other possible approaches are:</p>
      <ul>
        <li class="Bullet-Within-Tip--PACKT-">Using private class fields (the hashbang <code class="Code-In-Text--PACKT-">#</code> prefix syntax), introduced in Node.js 12. More <a id="_idIndexMarker550"/>on this at <a href="http://nodejsdp.link/tc39-private-fields"><span class="url">nodejsdp.link/tc39-private-fields</span></a>. This is the most modern approach, but at the time of writing, the feature is still experimental and has yet to be included in the official ECMAScript specification.</li>
        <li class="Bullet-Within-Tip--PACKT-">Using WeakMaps. More on <a id="_idIndexMarker551"/>this at <a href="http://nodejsdp.link/weakmaps-private"><span class="url">nodejsdp.link/weakmaps-private</span></a>.</li>
        <li class="Bullet-Within-Tip--PACKT-">Using symbols, as explained in the<a id="_idIndexMarker552"/> following article: <a href="http://nodejsdp.link/symbol-private"><span class="url">nodejsdp.link/symbol-private</span></a>.</li>
        <li class="Bullet-Within-Tip--PACKT-">Defining private variables<a id="_idIndexMarker553"/> in a constructor (as recommended by Douglas Crockford: <a href="http://nodejsdp.link/crockford-private"><span class="url">nodejsdp.link/crockford-private</span></a>). This is the legacy but also the best-known approach.</li>
        <li class="Bullet-Within-Tip-End--PACKT-">Using conventions, for example, prefixing the name of a property with an underscore "<code class="Code-In-Text--PACKT-">_</code>". However, this does not technically prevent a member from being read or modified from the outside.</li>
      </ul>
    </div>
    <h2 id="_idParaDest-194" class="title">Building a simple code profiler</h2>
    <p class="normal">Now, let's work on a complete<a id="_idIndexMarker554"/> example using a factory. Let's build a simple <em class="italic">code profiler</em>, an object with the following properties:</p>
    <ul>
      <li class="Bullet--PACKT-">A <code class="Code-In-Text--PACKT-">start()</code> method that triggers the start of a profiling session</li>
      <li class="Bullet-End--PACKT-">An <code class="Code-In-Text--PACKT-">end()</code> method to terminate the session and log its execution time to the console</li>
    </ul>
    <p class="normal">Let's start by creating a file named <code class="Code-In-Text--PACKT-">profiler.js</code>, which will have the following content:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Profiler</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (label) {
    <span class="hljs-built_in">this</span>.label = label
    <span class="hljs-built_in">this</span>.lastTime = <span class="hljs-literal">null</span>
  }
  start () {
    <span class="hljs-built_in">this</span>.lastTime = process.hrtime()
  }
  end () {
    <span class="hljs-keyword">const</span> diff = process.hrtime(<span class="hljs-built_in">this</span>.lastTime)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Timer "</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">label}</span><span class="hljs-string">" took </span><span class="hljs-subst">${diff[</span><span class="hljs-number">0</span><span class="hljs-subst">]}</span><span class="hljs-string"> seconds `</span> +
      <span class="hljs-string">`and </span><span class="hljs-subst">${diff[</span><span class="hljs-number">1</span><span class="hljs-subst">]}</span><span class="hljs-string"> nanoseconds.`</span>)
  }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">Profiler</code> class we just defined uses the default high resolution timer of Node.js to save the current time when <code class="Code-In-Text--PACKT-">start()</code> is invoked, and then calculate the elapsed time when <code class="Code-In-Text--PACKT-">end()</code> is executed, printing the result to the console.</p>
    <p class="normal">Now, if we are going to use such a profiler in a real-world application to calculate the execution time of different routines, we can easily imagine the huge amount of profiling information printed to the console, especially in a production environment. What we may want to do instead is redirect the profiling information to another source, for example, a dedicated log file, or alternatively, disable the profiler altogether if the application is running in production mode. It's clear that if we were to instantiate a <code class="Code-In-Text--PACKT-">Profiler</code> object directly by using<a id="_idIndexMarker555"/> the <code class="Code-In-Text--PACKT-">new</code> operator, we would need some extra logic in the client code or in the <code class="Code-In-Text--PACKT-">Profiler</code> object itself in order to switch between the different logics. </p>
    <p class="normal">Alternatively, we can use a factory to abstract the creation of the <code class="Code-In-Text--PACKT-">Profiler</code> object so that, depending on whether the application runs in production or development mode, we can return a fully working <code class="Code-In-Text--PACKT-">Profiler</code> instance or a mock object with the same interface but with empty methods. This is exactly what we are going to do in our <code class="Code-In-Text--PACKT-">profiler.js</code> module. Instead of exporting the <code class="Code-In-Text--PACKT-">Profiler</code> class, we will export only our factory. The following is its code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> noopProfiler = {
  start () {},
  end () {}
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">createProfiler</span><span class="hljs-function"> (</span><span class="hljs-params">label</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">if</span> (process.env.NODE_ENV === <span class="hljs-string">'production'</span>) {
    <span class="hljs-keyword">return</span> noopProfiler
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Profiler(label)
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">createProfiler()</code> function is our factory and its role is abstracting the creation of a <code class="Code-In-Text--PACKT-">Profiler</code> object from its implementation. If the application is running in production mode, we return <code class="Code-In-Text--PACKT-">noopProfiler</code>, which essentially doesn't do anything, effectively disabling any profiling. If the application is not running in production mode, then we create and return a new, fully functional <code class="Code-In-Text--PACKT-">Profiler</code> instance.</p>
    <p class="normal">Thanks to JavaScript's dynamic typing, we were able to return an object instantiated with the <code class="Code-In-Text--PACKT-">new</code> operator in one circumstance and a simple object literal in the other (this is also known as <strong class="keyword">duck typing</strong>, and you can <a id="_idIndexMarker556"/>read more about it at <a href="http://nodejsdp.link/duck-typing"><span class="url">nodejsdp.link/duck-typing</span></a>). This confirms how we can create objects in any way we like inside the factory function. We could also execute additional initialization steps or return a different type of object based on particular conditions, all of this while isolating the consumer of the object from all these details. We can easily understand the power of this simple pattern.</p>
    <p class="normal">Now, let's play with our profiler<a id="_idIndexMarker557"/> factory a bit. Let's create an algorithm to calculate all the factors of a given number and use our profiler to record its running time:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// index.js</span>
<span class="hljs-keyword">import</span> { createProfiler } <span class="hljs-keyword">from</span> <span class="hljs-string">'./profiler.js'</span>
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">getAllFactors</span><span class="hljs-function"> (</span><span class="hljs-params">intNumber</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">const</span> profiler = createProfiler(
    <span class="hljs-string">`Finding all factors of </span><span class="hljs-subst">${intNumber}</span><span class="hljs-string">`</span>)
  profiler.start()
  <span class="hljs-keyword">const</span> factors = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> factor = <span class="hljs-number">2</span>; factor &lt;= intNumber; factor++) {
    <span class="hljs-keyword">while</span> ((intNumber % factor) === <span class="hljs-number">0</span>) {
      factors.push(factor)
      intNumber = intNumber / factor
    }
  }
  profiler.end()
  <span class="hljs-keyword">return</span> factors
}
<span class="hljs-keyword">const</span> myNumber = process.argv[<span class="hljs-number">2</span>]
<span class="hljs-keyword">const</span> myFactors = getAllFactors(myNumber)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Factors of </span><span class="hljs-subst">${myNumber}</span><span class="hljs-string"> are: `</span>, myFactors)
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">profiler</code> variable contains our <code class="Code-In-Text--PACKT-">Profiler</code> object, whose implementation will be decided by the <code class="Code-In-Text--PACKT-">createProfiler()</code> factory at runtime, based on the <code class="Code-In-Text--PACKT-">NODE_ENV</code> environment variable.</p>
    <p class="normal">For example, if we run the module in production mode, we will get no profiling information:</p>
    <pre class="programlisting con"><code class="hljs-con">NODE_ENV=production node index.js 2201307499
</code></pre>
    <p class="normal">While if we run the module<a id="_idIndexMarker558"/> in development mode, we will see the profiling information printed to the console:</p>
    <pre class="programlisting con"><code class="hljs-con">node index.js 2201307499
</code></pre>
    <p class="normal">The example that we just presented is just a simple application of the factory function pattern, but it clearly shows the advantages of separating an object's creation from its implementation.</p>
    <h2 id="_idParaDest-195" class="title">In the wild</h2>
    <p class="normal">As we said, factories are very common in Node.js. We can find one example in the popular <em class="italic">Knex</em> (<a href="http://nodejsdp.link/knex"><span class="url">nodejsdp.link/knex</span></a>) package. Knex<a id="_idIndexMarker559"/> is a SQL query builder that supports multiple databases. Its package exports just a function, which is a factory. The factory performs various checks, selects the right dialect object to use based on the database engine, and finally creates and returns the Knex object. Take a look at the code at <a href="http://nodejsdp.link/knex-factory"><span class="url">nodejsdp.link/knex-factory</span></a>.</p>
    <h1 id="_idParaDest-196" class="title">Builder</h1>
    <p class="normal">Builder is a<a id="_idIndexMarker560"/> creational design pattern that simplifies the creation of complex objects by providing a fluent interface, which allows us to build the object step by step. This greatly improves the readability and the general developer experience when creating such complex objects.</p>
    <p class="normal">The most apparent situation in which we could benefit from the Builder pattern is a class with a constructor that has a long list of arguments, or takes many complex parameters as input. Usually, these kinds of classes require so many parameters in advance because all of them are necessary to build an instance that is complete and in a consistent state, so it's necessary to take this into account when considering potential solutions.</p>
    <p class="normal">So, let's see the general structure of the pattern. Imagine having a <code class="Code-In-Text--PACKT-">Boat</code> class with a constructor such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Boat</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (hasMotor, motorCount, motorBrand, motorModel,
               hasSails, sailsCount, sailsMaterial, sailsColor,
               hullColor, hasCabin) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre>
    <p class="normal">Invoking such a constructor<a id="_idIndexMarker561"/> would create some hard to read code, which is easily prone to errors (which argument is what?). Take the following code, for example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> myBoat = <span class="hljs-keyword">new</span> Boat(<span class="hljs-literal">true</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'Best Motor Co. '</span>, <span class="hljs-string">'OM123'</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">1</span>,
                        <span class="hljs-string">'fabric'</span>, <span class="hljs-string">'white'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-literal">false</span>)
</code></pre>
    <p class="normal">A first step to improve the design of this constructor is to aggregate all arguments in a single object literal, such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Boat</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (allParameters) {
    <span class="hljs-comment">// ...</span>
  }
}
<span class="hljs-keyword">const</span> myBoat = <span class="hljs-keyword">new</span> Boat({
  <span class="hljs-attr">hasMotor</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">motorCount</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">motorBrand</span>: <span class="hljs-string">'Best Motor Co. '</span>,
  <span class="hljs-attr">motorModel</span>: <span class="hljs-string">'OM123'</span>,
  <span class="hljs-attr">hasSails</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">sailsCount</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">sailsMaterial</span>: <span class="hljs-string">'fabric'</span>,
  <span class="hljs-attr">sailsColor</span>: <span class="hljs-string">'white'</span>,
  <span class="hljs-attr">hullColor</span>: <span class="hljs-string">'blue'</span>,
  <span class="hljs-attr">hasCabin</span>: <span class="hljs-literal">false</span>
})
</code></pre>
    <p class="normal">As we can note from the previous code, this new constructor is indeed much better than the original one as it allows us to clearly see what is the parameter that receives each value. However, we can do even better than this. One drawback of using a single object literal to pass all inputs at once is that the only way to know what the actual inputs are is to look at the class documentation or, even worse, into the code of the class. In addition to that, there is no enforced protocol that guides the developers toward the creation of a coherent class. For<a id="_idIndexMarker562"/> example, if we specify <code class="Code-In-Text--PACKT-">hasMotor: true</code>, then we are required to also specify a <code class="Code-In-Text--PACKT-">motorCount</code>, a <code class="Code-In-Text--PACKT-">motorBrand,</code> and a <code class="Code-In-Text--PACKT-">motorModel</code>, but there is nothing in this interface that conveys this information to us.</p>
    <p class="normal">The Builder pattern fixes even these last few flaws and provides a fluent interface that is simple to read, self-documenting, and that provides guidance toward the creation of a coherent object. Let's take a look at the <code class="Code-In-Text--PACKT-">BoatBuilder</code> class, which implements the Builder pattern for the <code class="Code-In-Text--PACKT-">Boat</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">BoatBuilder</span><span class="hljs-class"> </span>{
  withMotors (count, brand, model) {
    <span class="hljs-built_in">this</span>.hasMotor = <span class="hljs-literal">true</span>
    <span class="hljs-built_in">this</span>.motorCount = count
    <span class="hljs-built_in">this</span>.motorBrand = brand
    <span class="hljs-built_in">this</span>.motorModel = model
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  withSails (count, material, color) {
    <span class="hljs-built_in">this</span>.hasSails = <span class="hljs-literal">true</span>
    <span class="hljs-built_in">this</span>.sailsCount = count
    <span class="hljs-built_in">this</span>.sailsMaterial = material
    <span class="hljs-built_in">this</span>.sailsColor = color
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  hullColor (color) {
    <span class="hljs-built_in">this</span>.hullColor = color
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  withCabin () {
    <span class="hljs-built_in">this</span>.hasCabin = <span class="hljs-literal">true</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  build() {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Boat({
      <span class="hljs-attr">hasMotor</span>: <span class="hljs-built_in">this</span>.hasMotor,
      <span class="hljs-attr">motorCount</span>: <span class="hljs-built_in">this</span>.motorCount,
      <span class="hljs-attr">motorBrand</span>: <span class="hljs-built_in">this</span>.motorBrand,
      <span class="hljs-attr">motorModel</span>: <span class="hljs-built_in">this</span>.motorModel,
      <span class="hljs-attr">hasSails</span>: <span class="hljs-built_in">this</span>.hasSails,
      <span class="hljs-attr">sailsCount</span>: <span class="hljs-built_in">this</span>.sailsCount,
      <span class="hljs-attr">sailsMaterial</span>: <span class="hljs-built_in">this</span>.sailsMaterial,
      <span class="hljs-attr">sailsColor</span>: <span class="hljs-built_in">this</span>.sailsColor,
      <span class="hljs-attr">hullColor</span>: <span class="hljs-built_in">this</span>.hullColor,
      <span class="hljs-attr">hasCabin</span>: <span class="hljs-built_in">this</span>.hasCabin
    })
  }
}
</code></pre>
    <p class="normal">To fully appreciate the positive impact that the Builder pattern has on the way we create our <code class="Code-In-Text--PACKT-">Boat</code> objects, let's see an example of that:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> myBoat = <span class="hljs-keyword">new</span> BoatBuilder()
  .withMotors(<span class="hljs-number">2</span>, <span class="hljs-string">'Best Motor Co. '</span>, <span class="hljs-string">'OM123'</span>)
  .withSails(<span class="hljs-number">1</span>, <span class="hljs-string">'fabric'</span>, <span class="hljs-string">'white'</span>)
  .withCabin()
  .hullColor(<span class="hljs-string">'blue'</span>)
  .build()
</code></pre>
    <p class="normal">As we can see, the role <a id="_idIndexMarker563"/>of our <code class="Code-In-Text--PACKT-">BoatBuilder</code> class is to collect all the parameters needed to create a <code class="Code-In-Text--PACKT-">Boat</code> using some helper methods. We usually have a method for each parameter or set of related parameters, but there is not an exact rule to that. It is down to the designer of the Builder class to decide the name and behavior of each method responsible for collecting the input parameters.</p>
    <p class="normal">We can instead summarize some general rules for implementing the Builder pattern, as follows:</p>
    <ul>
      <li class="Bullet--PACKT-">The main objective is to break down a complex constructor into multiple, more readable, and more manageable steps.</li>
      <li class="Bullet--PACKT-">Try to create builder methods that can set multiple related parameters at once.</li>
      <li class="Bullet--PACKT-">Deduce and implicitly set parameters based on the values received as input by a setter method, and in general, try to encapsulate as much parameter setting related logic into the setter methods so that the consumer of the builder interface is free from doing so.</li>
      <li class="Bullet--PACKT-">If necessary, it's possible<a id="_idIndexMarker564"/> to further manipulate the parameters (for example, type casting, normalization, or extra validation) before passing them to the constructor of the class being built to simplify the work left to do by the builder class consumer even more.</li>
    </ul>
    <div class="packt_tip">
      <p class="Tip--PACKT-">In JavaScript, the Builder pattern can also be applied to invoke functions, not just to build objects using their constructor. In fact, from a technical point of view, the two scenarios are almost identical. The major difference when dealing with functions is that instead of having a <code class="Code-In-Text--PACKT-">build()</code> method, we would have an <code class="Code-In-Text--PACKT-">invoke()</code> method that invokes the complex function with the parameters collected by the builder object and returns any eventual result to the caller.</p>
    </div>
    <p class="normal">Next, we will work on a more concrete example that makes use of the Builder pattern we've just learned.</p>
    <h2 id="_idParaDest-197" class="title">Implementing a URL object builder</h2>
    <p class="normal">We want to implement <a id="_idIndexMarker565"/>a <code class="Code-In-Text--PACKT-">Url</code> class that can hold all the components of a standard URL, validate them, and format them back into a string. This class in going to be intentionally simple and minimal, so for standard production use, we recommend the built-in <code class="Code-In-Text--PACKT-">URL</code> class (<a href="http://nodejsdp.link/docs-url"><span class="url">nodejsdp.link/docs-url</span></a>).</p>
    <p class="normal">Now, let's implement our custom <code class="Code-In-Text--PACKT-">Url</code> class in a file called <code class="Code-In-Text--PACKT-">url.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Url</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (protocol, username, password, hostname,
    port, pathname, search, hash) {
    <span class="hljs-built_in">this</span>.protocol = protocol
    <span class="hljs-built_in">this</span>.username = username
    <span class="hljs-built_in">this</span>.password = password
    <span class="hljs-built_in">this</span>.hostname = hostname
    <span class="hljs-built_in">this</span>.port = port
    <span class="hljs-built_in">this</span>.pathname = pathname
    <span class="hljs-built_in">this</span>.search = search
    <span class="hljs-built_in">this</span>.hash = hash
    <span class="hljs-built_in">this</span>.validate()
  }
  validate () {
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.protocol || !<span class="hljs-built_in">this</span>.hostname) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Must specify at least a '</span> +
        <span class="hljs-string">'protocol and a hostname'</span>)
    }
  }
  toString () {
    <span class="hljs-keyword">let</span> url = <span class="hljs-string">''</span>
    url += <span class="hljs-string">`</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">protocol}</span><span class="hljs-string">://`</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.username &amp;&amp; <span class="hljs-built_in">this</span>.password) {
      url += <span class="hljs-string">`</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">username}</span><span class="hljs-string">:</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">password}</span><span class="hljs-string">@`</span>
    }
    url += <span class="hljs-built_in">this</span>.hostname
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.port) {
      url += <span class="hljs-built_in">this</span>.port
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.pathname) {
      url += <span class="hljs-built_in">this</span>.pathname
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.search) {
      url += <span class="hljs-string">`?</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">search}</span><span class="hljs-string">`</span>
    }
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.hash) {
      url += <span class="hljs-string">`#</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">hash}</span><span class="hljs-string">`</span>
    }
    <span class="hljs-keyword">return</span> url
  }
}
</code></pre>
    <p class="normal">A standard URL is made of several components, so to take them all in, the <code class="Code-In-Text--PACKT-">Url</code> class' constructor is inevitably big. Invoking such a constructor can be a challenge, as we have to keep track of the argument position to know what component of the URL we are passing. Take a look at the following example to get an idea of this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Url(<span class="hljs-string">'https'</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-string">'example.com'</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>,
  <span class="hljs-literal">null</span>)
</code></pre>
    <p class="normal">This is the perfect situation <a id="_idIndexMarker566"/>for applying the Builder pattern we just learned. Let's do that now. The plan is to create a <code class="Code-In-Text--PACKT-">UrlBuilder</code> class, which has a setter method for each parameter (or set of related parameters) needed to instantiate the <code class="Code-In-Text--PACKT-">Url</code> class. Finally, the builder is going to have a <code class="Code-In-Text--PACKT-">build()</code> method to retrieve a new <code class="Code-In-Text--PACKT-">Url</code> instance that's been created using all the parameters that have been set in the builder. So, let's implement the builder in a file called <code class="Code-In-Text--PACKT-">urlBuilder.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">UrlBuilder</span><span class="hljs-class"> </span>{
  setProtocol (protocol) {
    <span class="hljs-built_in">this</span>.protocol = protocol
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  setAuthentication (username, password) {
    <span class="hljs-built_in">this</span>.username = username
    <span class="hljs-built_in">this</span>.password = password
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  setHostname (hostname) {
    <span class="hljs-built_in">this</span>.hostname = hostname
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  setPort (port) {
    <span class="hljs-built_in">this</span>.port = port
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  setPathname (pathname) {
    <span class="hljs-built_in">this</span>.pathname = pathname
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  setSearch (search) {
    <span class="hljs-built_in">this</span>.search = search
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  setHash (hash) {
    <span class="hljs-built_in">this</span>.hash = hash
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>
  }
  build () {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Url(<span class="hljs-built_in">this</span>.protocol, <span class="hljs-built_in">this</span>.username, <span class="hljs-built_in">this</span>.password,
      <span class="hljs-built_in">this</span>.hostname, <span class="hljs-built_in">this</span>.port, <span class="hljs-built_in">this</span>.pathname, <span class="hljs-built_in">this</span>.search,
      <span class="hljs-built_in">this</span>.hash)
  }
}
</code></pre>
    <p class="normal">This should be pretty straightforward. Just note the way we coupled together the <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code> parameters into a single <code class="Code-In-Text--PACKT-">setAuthentication()</code> method. This clearly conveys the fact that if we want to specify any authentication information in the <code class="Code-In-Text--PACKT-">Url</code>, we have to provide both <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code>.</p>
    <p class="normal">Now, we are ready to try our <code class="Code-In-Text--PACKT-">UrlBuilder</code> and witness its benefits over using the <code class="Code-In-Text--PACKT-">Url</code> class directly. We can do that in a <a id="_idIndexMarker567"/>file called <code class="Code-In-Text--PACKT-">index.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { UrlBuilder } <span class="hljs-keyword">from</span> <span class="hljs-string">'./urlBuilder.js'</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-keyword">new</span> UrlBuilder()
  .setProtocol(<span class="hljs-string">'https'</span>)
  .setAuthentication(<span class="hljs-string">'user'</span>, <span class="hljs-string">'pass'</span>)
  .setHostname(<span class="hljs-string">'example.com'</span>)
  .build()
<span class="hljs-built_in">console</span>.log(url.toString())
</code></pre>
    <p class="normal">As we can see, the readability of the code has improved dramatically. Each setter method clearly gives us a hint of what parameter we are setting, and on top of that, they provide some guidance on how those parameters must be set (for example, <code class="Code-In-Text--PACKT-">username</code> and <code class="Code-In-Text--PACKT-">password</code> must be set together).</p>
    <div class="note">
      <p class="Information-Box--PACKT-">The Builder pattern can also be implemented directly into the target class. For example, we could have refactored the <code class="Code-In-Text--PACKT-">Url</code> class by adding an empty constructor (and therefore no validation at the object's creation time) and the setter methods for the various components, rather than creating a separate <code class="Code-In-Text--PACKT-">UrlBuilder</code> class. However, this approach has a major flaw. Using a builder that is separate from the target class has the advantage of always producing instances that are guaranteed to be in a consistent state. For example, every <code class="Code-In-Text--PACKT-">Url</code> object returned by <code class="Code-In-Text--PACKT-">UrlBuilder.build()</code> is guaranteed to be valid and in a consistent state; calling <code class="Code-In-Text--PACKT-">toString()</code> on such objects will always return a valid URL. The same cannot be said if we implemented the Builder pattern on the <code class="Code-In-Text--PACKT-">Url</code> class directly. In fact, in this case, if we invoke <code class="Code-In-Text--PACKT-">toString()</code> while we are still setting the various URL components, its return value may not be valid. This can be mitigated by adding extra validations, but at the cost of adding more complexity.</p>
    </div>
    <h2 id="_idParaDest-198" class="title">In the wild</h2>
    <p class="normal">The<a id="_idIndexMarker568"/> Builder pattern is a quite common pattern in Node.js and JavaScript as it provides a very elegant solution to the problem of creating complex objects or invoking complex functions. One perfect example is creating new HTTP(S) client requests with the <code class="Code-In-Text--PACKT-">request()</code> API from the <code class="Code-In-Text--PACKT-">http</code> and <code class="Code-In-Text--PACKT-">https</code> built-in modules. If we look at its documentation (available at <a href="http://nodejsdp.link/docs-http-request"><span class="url">nodejsdp.link/docs-http-request</span></a>), we can immediately see it accepts a large amount of options, which is the usual sign that the Builder pattern can potentially provide a better<a id="_idIndexMarker569"/> interface. In fact, one of the most popular HTTP(S) request wrappers, <code class="Code-In-Text--PACKT-">superagent</code> (<a href="http://nodejsdp.link/superagent"><span class="url">nodejsdp.link/superagent</span></a>), aims to simplify the creation of new requests by implementing the Builder pattern, thus providing a fluent interface to create new requests step by step. See the following code fragment for an example:</p>
    <pre class="programlisting code"><code class="hljs-code">superagent
  .post(<span class="hljs-string">'https://example.com/api/person'</span>)
  .send({ <span class="hljs-attr">name</span>: <span class="hljs-string">'John Doe'</span>, <span class="hljs-attr">role</span>: <span class="hljs-string">'user'</span> })
  .set(<span class="hljs-string">'accept'</span>, <span class="hljs-string">'json'</span>)
  .then(<span class="hljs-function">(</span><span class="hljs-params">response</span><span class="hljs-function">) =&gt;</span> {
    <span class="hljs-comment">// deal with the response</span>
  })
</code></pre>
    <p class="normal">From the previous code, we can note that this is an unusual builder; in fact, we don't have a <code class="Code-In-Text--PACKT-">build()</code> or <code class="Code-In-Text--PACKT-">invoke()</code> method (or any other method with a similar purpose), and have not used the <code class="Code-In-Text--PACKT-">new</code> operator. What triggers the request instead is an invocation to the <code class="Code-In-Text--PACKT-">then()</code> method. It's interesting to note that the <code class="Code-In-Text--PACKT-">superagent</code> request object is not a promise but rather a custom <em class="italic">thenable</em> where the <code class="Code-In-Text--PACKT-">then()</code> method triggers the execution of the request we have built with the builder object.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">We already discussed <em class="italic">thenables</em> in <em class="chapterRef">Chapter 5</em>, <em class="italic">Asynchronous Control Flow Patterns with Promises and Async/Await</em>.</p>
    </div>
    <p class="normal">If you take a look at the library's code, you will see the Builder pattern in action in the <code class="Code-In-Text--PACKT-">Request</code> class (<a href="http://nodejsdp.link/superagent-src-builder"><span class="url">nodejsdp.link/superagent-src-builder</span></a>).</p>
    <p class="normal">This concludes our exploration of the Builder pattern. Next, we'll look at the Revealing Constructor pattern.</p>
    <h1 id="_idParaDest-199" class="title">Revealing Constructor</h1>
    <p class="normal">The Revealing Constructor pattern<a id="_idIndexMarker570"/> is one of those patterns that you won't find in the "Gang of Four" book, since it originated directly from the JavaScript and the Node.js community. It solves a very tricky problem, which is: how can we "reveal" some private functionality of an object only at the moment of the object's creation? This is particularly useful when we want to allow an object's internals to be manipulated only during its creation phase. This allows for a few interesting scenarios, such as:</p>
    <ul>
      <li class="Bullet--PACKT-">Creating objects that can be modified only at creation time</li>
      <li class="Bullet--PACKT-">Creating objects whose custom behavior can be defined only at creation time</li>
      <li class="Bullet-End--PACKT-">Creating objects that can be initialized only once at creation time</li>
    </ul>
    <p class="normal">These are just a few possibilities enabled by the Revealing Constructor pattern. But to better understand all the possible use cases, let's see what the pattern is about by looking at the following code fragment:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">//                    (1)               (2)          (3)</span>
<span class="hljs-keyword">const</span> object = <span class="hljs-keyword">new</span> SomeClass(<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">executor</span><span class="hljs-function">(</span><span class="hljs-params">revealedMembers</span><span class="hljs-function">) </span>{
  <span class="hljs-comment">// manipulation code ...</span>
})
</code></pre>
    <p class="normal">As we can see from the previous code, the Revealing Constructor pattern is made of three fundamental elements; a <strong class="keyword">constructor</strong> (1) that takes a function as input (the <strong class="keyword">executor</strong> (2)), which is invoked at creation time and receives a subset of the object's internals as input (<strong class="keyword">revealed members</strong> (3)).</p>
    <p class="normal">For the pattern to work, the revealed functionality must otherwise be not accessible by the users of the object once it is created. This can be achieved with one of the encapsulation techniques<a id="_idIndexMarker571"/> we've mentioned in the previous section regarding the Factory pattern.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Domenic Denicola was the first to identify and name the pattern in one of his blog posts, which can be found at <a href="http://nodejsdp.link/domenic-revealing-constructor"><span class="url">nodejsdp.link/domenic-revealing-constructor</span></a>.</p>
    </div>
    <p class="normal">Now, let's look at a couple of examples to better understand how the Revealing Constructor pattern works.</p>
    <h2 id="_idParaDest-200" class="title">Building an immutable buffer</h2>
    <p class="normal"><strong class="keyword">Immutable</strong> objects<a id="_idIndexMarker572"/> and data structures have many excellent properties that make them ideal to use in countless situations in place of their mutable (or changeable) counterparts. Immutable refers to the property of an object by which its data or state becomes unmodifiable once it's been created.</p>
    <p class="normal">With immutable objects, we don't need to create <strong class="keyword">defensive copies</strong> before passing them around to other libraries or functions. We simply have a strong guarantee, by definition, that they won't be modified, even when they are passed to code that we don't know or control.</p>
    <p class="normal">Modifying an immutable object can only be done by creating a new copy and can make the code more maintainable and easier to reason about. We do this to make it easier to keep track of state changes.</p>
    <p class="normal">Another common use case for immutable objects is efficient change detection. Since every change requires a copy and if we assume that every copy corresponds to a modification, then detecting a change is as simple as using the strict equality operator (or triple equal <code class="Code-In-Text--PACKT-">===</code>). This technique is used extensively in frontend programming to efficiently detect if the UI needs refreshing.</p>
    <p class="normal">In this context, let's now create a simple immutable version of the Node.js <code class="Code-In-Text--PACKT-">Buffer</code> component (<a href="http://nodejsdp.link/docs-buffer"><span class="url">nodejsdp.link/docs-buffer</span></a>) using the Revealing Constructor pattern. The pattern allows us to manipulate an immutable buffer only at creation time.</p>
    <p class="normal">Let's implement our immutable buffer in a new file called <code class="Code-In-Text--PACKT-">immutableBuffer.js</code>, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> MODIFIER_NAMES = [<span class="hljs-string">'swap'</span>, <span class="hljs-string">'write'</span>, <span class="hljs-string">'fill'</span>]
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">ImmutableBuffer</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (size, executor) {
    <span class="hljs-keyword">const</span> buffer = Buffer.alloc(size)                         <span class="hljs-comment">// (1)</span>
    <span class="hljs-keyword">const</span> modifiers = {}                                      <span class="hljs-comment">// (2)</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> prop <span class="hljs-keyword">in</span> buffer) {                              <span class="hljs-comment">// (3)</span>
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> buffer[prop] !== <span class="hljs-string">'function'</span>) {
        <span class="hljs-keyword">continue</span>
      }
      <span class="hljs-keyword">if</span> (MODIFIER_NAMES.some(<span class="hljs-params">m</span><span class="hljs-function"> =&gt;</span> prop.startsWith(m))) {     <span class="hljs-comment">// (4)</span>
        modifiers[prop] = buffer[prop].bind(buffer)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">this</span>[prop] = buffer[prop].bind(buffer)                <span class="hljs-comment">// (5)</span>
      }
    }
    executor(modifiers)                                       <span class="hljs-comment">// (6)</span>
  }
}
</code></pre>
    <p class="normal">Let's now see<a id="_idIndexMarker573"/> how our new <code class="Code-In-Text--PACKT-">ImmutableBuffer</code> class works:</p>
    <ol>
      <li class="numbered">First, we allocate a new Node.js <code class="Code-In-Text--PACKT-">Buffer</code> (<code class="Code-In-Text--PACKT-">buffer</code>) of the size specified in the <code class="Code-In-Text--PACKT-">size</code> constructor argument.</li>
      <li class="numbered">Then, we create an object literal (<code class="Code-In-Text--PACKT-">modifiers</code>) to hold all the methods that can mutate the buffer.</li>
      <li class="numbered">After that, we iterate over all the properties (own and inherited) of our internal <code class="Code-In-Text--PACKT-">buffer</code>, making sure to skip all those that are not functions.</li>
      <li class="numbered">Next, we try to identify if the current <code class="Code-In-Text--PACKT-">prop</code> is a method that allows us to modify the <code class="Code-In-Text--PACKT-">buffer</code>. We do that by trying to match its name with one of the strings in the <code class="Code-In-Text--PACKT-">MODIFIER_NAMES</code> array. If we have such a method, we bind it to the <code class="Code-In-Text--PACKT-">buffer</code> instance, and then we add it to the <code class="Code-In-Text--PACKT-">modifiers</code> object.</li>
      <li class="numbered">If our method is not a modifier method, then we add it directly to the current instance (<code class="Code-In-Text--PACKT-">this</code>).</li>
      <li class="numbered">Finally, we invoke the <code class="Code-In-Text--PACKT-">executor</code> function received as input in the constructor and pass the <code class="Code-In-Text--PACKT-">modifiers</code> object as an argument, which will allow <code class="Code-In-Text--PACKT-">executor</code> to mutate our internal <code class="Code-In-Text--PACKT-">buffer</code>.</li>
    </ol>
    <p class="normal">In practice, our <code class="Code-In-Text--PACKT-">ImmutableBuffer</code> is acting as a <strong class="keyword">proxy</strong> between its consumers and the internal <code class="Code-In-Text--PACKT-">buffer</code> object. Some of the methods of the <code class="Code-In-Text--PACKT-">buffer</code> instance are exposed directly through the <code class="Code-In-Text--PACKT-">ImmutableBuffer</code> interface (mainly the read-only methods), while others are provided to <a id="_idIndexMarker574"/>the <code class="Code-In-Text--PACKT-">executor</code> function (the modifier methods).</p>
    <p class="normal">We will analyze the Proxy pattern in more detail in <em class="chapterRef">Chapter 8</em>, <em class="italic">Structural Design Patterns</em>.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Please keep in mind that this is just a demonstration of the Revealing Constructor pattern, so the implementation of the immutable buffer is intentionally kept simple. For example, we are not exposing the size of the buffer or providing other means to initialize the buffer. We'll leave this to you as an exercise.</p>
    </div>
    <p class="normal">Now, let's write some code to demonstrate how to use our new <code class="Code-In-Text--PACKT-">ImmutableBuffer</code> class. Let's create a new file, <code class="Code-In-Text--PACKT-">index.js</code>, containing the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { ImmutableBuffer } <span class="hljs-keyword">from</span> <span class="hljs-string">'./immutableBuffer.js'</span>
<span class="hljs-keyword">const</span> hello = <span class="hljs-string">'Hello!'</span>
<span class="hljs-keyword">const</span> immutable = <span class="hljs-keyword">new</span> ImmutableBuffer(hello.length,
  <span class="hljs-function">(</span><span class="hljs-params">{ write }</span><span class="hljs-function">) =&gt;</span> {                                         <span class="hljs-comment">// (1)</span>
    write(hello)
  })
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">String</span>.fromCharCode(immutable.readInt8(<span class="hljs-number">0</span>)))    <span class="hljs-comment">// (2)</span>
<span class="hljs-comment">// the following line will throw</span>
<span class="hljs-comment">// "TypeError: immutable.write is not a function"</span>
<span class="hljs-comment">// immutable.write('Hello?')                               // (3)</span>
</code></pre>
    <p class="normal">The first thing we can note from the previous code is how the executor function uses the <code class="Code-In-Text--PACKT-">write()</code> function (which is part of the modifier methods) to write a string into the buffer (1). In a similar way, the executor function could've used <code class="Code-In-Text--PACKT-">fill()</code>, <code class="Code-In-Text--PACKT-">writeInt8()</code>, <code class="Code-In-Text--PACKT-">swap16()</code> or any other method exposed in the <code class="Code-In-Text--PACKT-">modifiers</code> object.</p>
    <p class="normal">The code we've just seen also demonstrates how the new <code class="Code-In-Text--PACKT-">ImmutableBuffer</code> instance exposes only the methods that don't mutate the buffer, such as <code class="Code-In-Text--PACKT-">readInt8()</code> (2), while it doesn't provide any method to change the content of the buffer (3).</p>
    <h2 id="_idParaDest-201" class="title">In the wild</h2>
    <p class="normal">The Revealing Constructor pattern<a id="_idIndexMarker575"/> offers very strong guarantees and for this reason, it's mainly used in contexts where we need to provide foolproof encapsulation. A perfect application of the pattern would be in components used by hundreds of thousands of developers that have to provide unopinionated interfaces and strict encapsulation. However, we can also use the pattern in our projects to improve reliability and simplify code sharing with other people and teams (since it can make an object safer to use by third parties).</p>
    <p class="normal">A popular application of the Revealing Constructor pattern is in the JavaScript <code class="Code-In-Text--PACKT-">Promise</code> class. Some of you may have already noticed it. When we create a new <code class="Code-In-Text--PACKT-">Promise</code> from scratch, its constructor accepts as input an <code class="Code-In-Text--PACKT-">executor</code> function that will receive the <code class="Code-In-Text--PACKT-">resolve()</code> and <code class="Code-In-Text--PACKT-">reject()</code> functions used to mutate the internal state of the <code class="Code-In-Text--PACKT-">Promise</code>. Let's provide a reminder of what this looks like:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(</span><span class="hljs-params">resolve, reject</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-comment">// ...</span>
})
</code></pre>
    <p class="normal">Once created, the <code class="Code-In-Text--PACKT-">Promise</code> state cannot be altered by any other means. All we can do is receive its fulfilment value or rejection reason using the methods we already learned about in <em class="chapterRef">Chapter 5</em>, <em class="italic">Asynchronous Control Flow Patterns with Promises and Async/Await</em>.</p>
    <h1 id="_idParaDest-202" class="title">Singleton</h1>
    <p class="normal">Now, we are going to spend a few words on a pattern that is among the most used in object-oriented programming, which is the <strong class="keyword">Singleton</strong> pattern. As we will see, Singleton is one of those patterns that has a trivial <a id="_idIndexMarker576"/>implementation in Node.js that's almost not worth discussing. However, there are a few caveats and limitations that every good Node.js developer must know.</p>
    <p class="normal">The purpose of the Singleton pattern is to enforce the presence of only one instance of a class and centralize its access. There are a few reasons for using a single instance across all the components of an application:</p>
    <ul>
      <li class="Bullet--PACKT-">For sharing stateful information</li>
      <li class="Bullet--PACKT-">For optimizing resource usage</li>
      <li class="Bullet-End--PACKT-">To synchronize access to a resource</li>
    </ul>
    <p class="normal">As you can imagine, those are quite common scenarios. Take, for example, a typical <code class="Code-In-Text--PACKT-">Database</code> class, which provides access to a database:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// 'Database.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Database</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (dbName, connectionDetails) {
    <span class="hljs-comment">// ...</span>
  }
  <span class="hljs-comment">// ...</span>
}
</code></pre>
    <p class="normal">Typical implementations of such a class usually keep a pool of database connections, so it doesn't make sense to create a new <code class="Code-In-Text--PACKT-">Database</code> instance for each request. Plus, a <code class="Code-In-Text--PACKT-">Database</code> instance may store some stateful information, such as the list of pending transactions. So, our <code class="Code-In-Text--PACKT-">Database</code> class <a id="_idIndexMarker577"/>meets two criterions for justifying the Singleton pattern. Therefore, what we usually want is to configure and instantiate one single <code class="Code-In-Text--PACKT-">Database</code> instance at the start of our application and let every component use that single shared <code class="Code-In-Text--PACKT-">Database</code> instance.</p>
    <p class="normal">A lot of people new to Node.js get confused about how to implement the Singleton pattern correctly; however, the answer is easier than what we might think. Simply exporting an instance from a module is already enough to obtain something very similar to the Singleton pattern. Consider, for example, the following lines of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file 'dbInstance.js'</span>
<span class="hljs-keyword">import</span> { Database } <span class="hljs-keyword">from</span> <span class="hljs-string">'./Database.js'</span>
<strong class="hljs-keyword-slc">export</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> dbInstance</strong> = <span class="hljs-keyword">new</span> Database(<span class="hljs-string">'my-app-db'</span>, {
    <span class="hljs-attr">url</span>: <span class="hljs-string">'localhost:5432'</span>,
    <span class="hljs-attr">username</span>: <span class="hljs-string">'user'</span>,
    <span class="hljs-attr">password</span>: <span class="hljs-string">'password'</span>
})
</code></pre>
    <p class="normal">By simply exporting a new instance of our <code class="Code-In-Text--PACKT-">Database</code> class, we can already assume that within the current package (which can easily be the entire code of our application), we are going to have only one instance of the <code class="Code-In-Text--PACKT-">dbInstance</code> module. This is possible because, as we know from <em class="chapterRef">Chapter 2</em>, <em class="italic">The Module System</em>, Node.js will cache the module, making sure not to execute its code at every import.</p>
    <p class="normal">For example, we can easily obtain a shared instance of the <code class="Code-In-Text--PACKT-">dbInstance</code> module, which we defined earlier, with the following line of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { dbInstance } <span class="hljs-keyword">from</span> <span class="hljs-string">'./dbInstance.js'</span>
</code></pre>
    <p class="normal">But there is a caveat. The module is cached using its full path as the lookup key, so it is only guaranteed to be a singleton within the current package. In fact, each package may have its own set of private dependencies inside its <code class="Code-In-Text--PACKT-">node_modules</code> directory, which might result in multiple instances of the same package and therefore of the same module, resulting in our singleton not really being unique anymore! This is, of course, a rare scenario, but it's important to understand what its consequences are.</p>
    <p class="normal">Consider, for example, the case in which the <code class="Code-In-Text--PACKT-">Database.js</code> and <code class="Code-In-Text--PACKT-">dbInstance.js</code> files that we saw earlier are wrapped into a package named <code class="Code-In-Text--PACKT-">mydb</code>. The following lines of code would be in its <code class="Code-In-Text--PACKT-">package.json</code> file:</p>
    <pre class="programlisting code"><code class="hljs-code">{
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"mydb"</span>,
  <span class="hljs-attr">"version"</span>: <span class="hljs-string">"2.0.0"</span>,
  <span class="hljs-attr">"type"</span>: <span class="hljs-string">"module"</span>,
  <span class="hljs-attr">"main"</span>: <span class="hljs-string">"dbInstance.js"</span>
}
</code></pre>
    <p class="normal">Next, consider two <a id="_idIndexMarker578"/>packages (<code class="Code-In-Text--PACKT-">package-a</code> and <code class="Code-In-Text--PACKT-">package-b</code>), both of which have a single file called <code class="Code-In-Text--PACKT-">index.js</code> containing the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { dbInstance } <span class="hljs-keyword">from</span> <span class="hljs-string">'mydb'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">getDbInstance</span><span class="hljs-function"> () </span>{
  <span class="hljs-keyword">return</span> dbInstance
}
</code></pre>
    <p class="normal">Both <code class="Code-In-Text--PACKT-">package-a</code> and <code class="Code-In-Text--PACKT-">package-b</code> have a dependency on the <code class="Code-In-Text--PACKT-">mydb</code> package. However, <code class="Code-In-Text--PACKT-">package-a</code> depends on version <code class="Code-In-Text--PACKT-">1.0.0</code> of the <code class="Code-In-Text--PACKT-">mydb</code> package, while <code class="Code-In-Text--PACKT-">package-b</code> depends on version <code class="Code-In-Text--PACKT-">2.0.0</code> of the same package (which, for our example, has an identical implementation, but just a different version specified in its <code class="Code-In-Text--PACKT-">package.json</code> file).</p>
    <p class="normal">Given the structure we just described, we would end up with the following package dependency tree:</p>
    <pre class="programlisting code"><code class="hljs-code">app/
`-- node_modules
    |-- package-a
    |  `-- node_modules
    |      `-- mydb
    `-- package-b
        `-- node_modules
            `-- mydb
</code></pre>
    <p class="normal">We end up with a directory structure like the one here because <code class="Code-In-Text--PACKT-">package-a</code> and <code class="Code-In-Text--PACKT-">package-b</code> require two different incompatible versions of the <code class="Code-In-Text--PACKT-">mydb</code> module (for example, <code class="Code-In-Text--PACKT-">1.0.0</code> versus <code class="Code-In-Text--PACKT-">2.0.0</code>). In this case, a typical package manager such as <code class="Code-In-Text--PACKT-">npm</code> or <code class="Code-In-Text--PACKT-">yarn</code> would not "hoist" the dependency to the top <code class="Code-In-Text--PACKT-">node_modules</code> directory, but it will instead install a private copy of each package in an attempt to fix the version incompatibility.</p>
    <p class="normal">With the directory structure we just saw, both <code class="Code-In-Text--PACKT-">package-a</code> and <code class="Code-In-Text--PACKT-">package-b</code> have a dependency on the <code class="Code-In-Text--PACKT-">mydb</code> package; in turn, the <code class="Code-In-Text--PACKT-">app</code> package, which is our root package, depends on both <code class="Code-In-Text--PACKT-">package-a</code> and <code class="Code-In-Text--PACKT-">package-b</code>.</p>
    <p class="normal">The scenario we just described will break the assumption about the uniqueness of the database instance. In fact, consider the following file (<code class="Code-In-Text--PACKT-">index.js</code>) located in the root folder of the <code class="Code-In-Text--PACKT-">app</code> package:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { getDbInstance <span class="hljs-keyword">as</span> getDbFromA } <span class="hljs-keyword">from</span> <span class="hljs-string">'package-a'</span>
<span class="hljs-keyword">import</span> { getDbInstance <span class="hljs-keyword">as</span> getDbFromB } <span class="hljs-keyword">from</span> <span class="hljs-string">'package-b'</span>
<span class="hljs-keyword">const</span> isSame = getDbFromA() === getDbFromB()
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Is the db instance in package-a the same '</span> +
  <span class="hljs-string">`as package-b? </span><span class="hljs-subst">${isSame</span> ? <span class="hljs-string">'YES'</span> : <span class="hljs-string">'NO'</span><span class="hljs-subst">}</span><span class="hljs-string">`</span>)
</code></pre>
    <p class="normal">If you run the previous file, you <a id="_idIndexMarker579"/>will notice that the answer to <em class="italic">Is the db instance in package-a the same as package-b?</em> is <code class="Code-In-Text--PACKT-">NO</code>. In fact, <code class="Code-In-Text--PACKT-">package-a</code> and <code class="Code-In-Text--PACKT-">package-b</code> will actually load two different instances of the <code class="Code-In-Text--PACKT-">dbInstance</code> object because the <code class="Code-In-Text--PACKT-">mydb</code> module will resolve to a different directory, depending on the package it is required from. This clearly break the assumptions of the Singleton pattern.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">If instead, both <code class="Code-In-Text--PACKT-">package-a</code> and <code class="Code-In-Text--PACKT-">package-b</code> required two versions of the <code class="Code-In-Text--PACKT-">mydb</code> package compatible with each other, for example, <code class="Code-In-Text--PACKT-">^2.0.1</code> and <code class="Code-In-Text--PACKT-">^2.0.7</code>, then the package manager would install the <code class="Code-In-Text--PACKT-">mydb</code> package into the top-level <code class="Code-In-Text--PACKT-">node_modules</code> directory (a practice known <a id="_idIndexMarker580"/>as <strong class="keyword">dependency hoisting</strong>), effectively sharing the same instance with <code class="Code-In-Text--PACKT-">package-a</code>, <code class="Code-In-Text--PACKT-">package-b</code>, and the root package.</p>
    </div>
    <p class="normal">At this point, we can easily say that the Singleton pattern, as described in the literature, does not exist in Node.js, unless we use a real <em class="italic">global variable</em> to store it, such as the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">global</span>.dbInstance = <span class="hljs-keyword">new</span> Database(<span class="hljs-string">'my-app-db'</span>, {<span class="hljs-comment">/*...*/</span>})
</code></pre>
    <p class="normal">This guarantees that the instance is the only one shared across the entire application and not just the same package. However, please consider that most of the time, we don't really need a <em class="italic">pure</em> singleton. In fact, we usually create and import singletons within the main package of an application or, at worst, in a subcomponent of the application that has been modularized into a dependency.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">If you are creating a package that is going to be used by third parties, try to keep it stateless to avoid the issues we've discussed in this section.</p>
    </div>
    <p class="normal">Throughout this book, for <a id="_idIndexMarker581"/>simplicity, we will use the term singleton to describe a class instance or a stateful object exported by a module, even if this doesn't represent a real singleton in the strict definition of the term.</p>
    <p class="normal">Next, we are going to see the two main approaches for dealing with dependencies between modules, one based on the Singleton pattern and the other leveraging the Dependency Injection pattern.</p>
    <h1 id="_idParaDest-203" class="title">Wiring modules</h1>
    <p class="normal">Every application is the result of the <a id="_idIndexMarker582"/>aggregation of several components and, as the application grows, the way we connect these components becomes a win or lose factor for the maintainability and success of the project.</p>
    <p class="normal">When a component, A, needs component B to fulfill a given functionality, we say that "A is <strong class="keyword">dependent</strong> on B" or, conversely, that "B is a <strong class="keyword">dependency</strong> of A." To appreciate this concept, let's present an example.</p>
    <p class="normal">Let's say we want to write an API for a blogging system that uses a database to store its data. We can have a generic module implementing a database connection (<code class="Code-In-Text--PACKT-">db.js</code>) and a blog module that exposes the main functionality to create and retrieve blog posts from the database (<code class="Code-In-Text--PACKT-">blog.js</code>).</p>
    <p class="normal">The following figure illustrates the relationship between the database module and the blog module:</p>
    <figure class="mediaobject"><img src="../Images/B15729_07_01.png" alt="../../../Downloads/Untitled%20Diagram%20(13).png"/></figure>
    <p class="packt_figref">Figure 7.1: Dependency graph between the blog module and the database module</p>
    <p class="normal">In this section, we are going to see how we can model this dependency using two different approaches, one based on the Singleton pattern and the other using the Dependency Injection pattern.</p>
    <h2 id="_idParaDest-204" class="title">Singleton dependencies</h2>
    <p class="normal">The simplest way to <a id="_idIndexMarker583"/>wire two modules together is by leveraging Node.js' module system. Stateful dependencies wired in this way are de facto singletons, as we discussed in the previous section.</p>
    <p class="normal">To see how this works in practice, we are going to implement the simple blogging application that we described earlier using a singleton instance for the database connection. Let's see a possible implementation of this approach (the file <code class="Code-In-Text--PACKT-">db.js</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { dirname, join } <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> sqlite3 <span class="hljs-keyword">from</span> <span class="hljs-string">'sqlite3'</span>
<span class="hljs-keyword">const</span> __dirname = dirname(fileURLToPath(<span class="hljs-keyword">import</span>.meta.url))
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> db = <span class="hljs-keyword">new</span> sqlite3.Database(
  join(__dirname, <span class="hljs-string">'data.sqlite'</span>))
</code></pre>
    <p class="normal">In the previous code, we are using SQLite (<a href="http://nodejsdp.link/sqlite"><span class="url">nodejsdp.link/sqlite</span></a>) as a database to store our posts. To interact with SQLite, we are using the module <code class="Code-In-Text--PACKT-">sqlite3</code> (<a href="http://nodejsdp.link/sqlite3"><span class="url">nodejsdp.link/sqlite3</span></a>) from<a id="_idIndexMarker584"/> npm. SQLite is<a id="_idIndexMarker585"/> a database system that keeps all the data in a single local file. In our database module, we decided to use a file called <code class="Code-In-Text--PACKT-">data.sqlite</code> saved in the same folder as the module.</p>
    <p class="normal">The preceding code creates a new instance of the database pointing to our data file and exports the database connection object as a singleton with the name <code class="Code-In-Text--PACKT-">db</code>.</p>
    <p class="normal">Now, let's see how we can<a id="_idIndexMarker586"/> implement the <code class="Code-In-Text--PACKT-">blog.js</code> module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { promisify } <span class="hljs-keyword">from</span> <span class="hljs-string">'util'</span>
<span class="hljs-keyword">import</span> { db } <span class="hljs-keyword">from</span> <span class="hljs-string">'./db.js'</span>
<span class="hljs-keyword">const</span> dbRun = promisify(db.run.bind(db))
<span class="hljs-keyword">const</span> dbAll = promisify(db.all.bind(db))
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Blog</span><span class="hljs-class"> </span>{
  initialize () {
    <span class="hljs-keyword">const</span> initQuery = <span class="hljs-string">`CREATE TABLE IF NOT EXISTS posts (</span>
<span class="hljs-string">      id TEXT PRIMARY KEY,</span>
<span class="hljs-string">      title TEXT NOT NULL,</span>
<span class="hljs-string">      content TEXT,</span>
<span class="hljs-string">      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span>
<span class="hljs-string">    );`</span>
    <span class="hljs-keyword">return</span> dbRun(initQuery)
  }
  createPost (id, title, content, createdAt) {
    <span class="hljs-keyword">return</span> dbRun(<span class="hljs-string">'INSERT INTO posts VALUES (?, ?, ?, ?)'</span>,
      id, title, content, createdAt)
  }
  getAllPosts () {
    <span class="hljs-keyword">return</span> dbAll(<span class="hljs-string">'SELECT * FROM posts ORDER BY created_at DESC'</span>)
  }
}
</code></pre>
    <p class="normal">The <code class="Code-In-Text--PACKT-">blog.js</code> module exports a class called <code class="Code-In-Text--PACKT-">Blog</code> containing three methods:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">initialize()</code>: Creates the <code class="Code-In-Text--PACKT-">posts</code> table if it doesn't exist. The table will be used to store the blog post's data.</li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">createPost()</code>: Takes all the necessary parameters needed to create a post. It will execute an <code class="Code-In-Text--PACKT-">INSERT</code> statement to add the new post to the database.</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">getAllPosts()</code>: Retrieves all the posts available in the database and returns them as an array.</li>
    </ul>
    <p class="normal">Now, let's create a module to try out the <a id="_idIndexMarker587"/>functionality of the blog module we just created (the file <code class="Code-In-Text--PACKT-">index.js</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { Blog } <span class="hljs-keyword">from</span> <span class="hljs-string">'./blog.js'</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function"> () </span>{
  <span class="hljs-keyword">const</span> blog = <span class="hljs-keyword">new</span> Blog()
  <span class="hljs-keyword">await</span> blog.initialize()
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> blog.getAllPosts()
  <span class="hljs-keyword">if</span> (posts.length === <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'No post available. Run `node import-posts.js`'</span> +
      <span class="hljs-string">' to load some sample posts'</span>)
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> post <span class="hljs-keyword">of</span> posts) {
    <span class="hljs-built_in">console</span>.log(post.title)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-'</span>.repeat(post.title.length))
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Published on </span><span class="hljs-subst">${</span><span class="hljs-keyword">new</span><span class="hljs-subst"> </span><span class="hljs-built_in">Date</span>(post.<span class="hljs-subst">created_at</span>)
      .toISOString()<span class="hljs-subst">}</span><span class="hljs-string">`</span>)
    <span class="hljs-built_in">console</span>.log(post.content)
  }
}
main().catch(<span class="hljs-built_in">console</span>.error)
</code></pre>
    <p class="normal">This preceding module is very simple. We retrieve the array with all the posts using <code class="Code-In-Text--PACKT-">blog.getAllPosts()</code> and then we loop over it and display the data for every single post, giving it a bit of formatting.</p>
    <p class="normal">You can use the provided <code class="Code-In-Text--PACKT-">import-posts.js</code> module to load some sample posts into the database before running <code class="Code-In-Text--PACKT-">index.js</code>. You can find <code class="Code-In-Text--PACKT-">import-posts.js</code> in the code repository of this book, along with the rest of the files for this example.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">As a fun exercise, you could try to modify the <code class="Code-In-Text--PACKT-">index.js</code> module to generate HTML files; one for the blog index and then a dedicated file for each blog post. This way, you would build your own minimalistic static website generator!</p>
    </div>
    <p class="normal">As we can see from the preceding code, we can implement a very simple command-line blog management system by leveraging the Singleton pattern to pass the <code class="Code-In-Text--PACKT-">db</code> instance around. Most of the time, this is how we manage stateful dependencies in our application; however, there are situations in which this may not be enough.</p>
    <p class="normal">Using a singleton, as we have done in the previous example, is certainly the most simple, immediate, and readable solution to pass stateful dependencies around. However, what happens if we want to mock our database during our tests? What can we do if we want to let the user of the blogging CLI or the blogging API select another database backend, instead of <a id="_idIndexMarker588"/>the standard SQLite backend that we provide by default? For these use cases, a singleton can be an obstacle for implementing a properly structured solution.</p>
    <p class="normal">We could introduce <code class="Code-In-Text--PACKT-">if</code> statements in our <code class="Code-In-Text--PACKT-">db.js</code> module to pick different implementations based on some environment condition or some configuration. Alternatively, we could fiddle with the Node.js module system to intercept the import of the database file and replace it with something else. But, as you can image, these solutions are far from elegant.</p>
    <p class="normal">In the next section, we will learn about another strategy for wiring modules, which can be the ideal solution to some of the issues we discussed here.</p>
    <h2 id="_idParaDest-205" class="title">Dependency Injection</h2>
    <p class="normal">The Node.js module system <a id="_idIndexMarker589"/>and the Singleton pattern can serve as great tools for organizing and wiring together the components of an application. However, these do not always guarantee success. If, on the one hand, they are simple to use and very practical, then on the other, they might introduce a tighter <em class="italic">coupling</em> between components.</p>
    <p class="normal">In the previous example, we can see that the <code class="Code-In-Text--PACKT-">blog.js</code> module is <em class="italic">tightly coupled</em> with the <code class="Code-In-Text--PACKT-">db.js</code> module. In fact, our <code class="Code-In-Text--PACKT-">blog.js</code> module cannot work without the <code class="Code-In-Text--PACKT-">database.js</code> module by design, nor can it use a different database module if necessary. We can easily fix this tight coupling between the two modules by leveraging the <strong class="keyword">Dependency Injection pattern</strong>.</p>
    <p class="normal"><strong class="keyword">Dependency Injection</strong> (<strong class="keyword">DI</strong>) is a very simple pattern in which the dependencies of a component are <em class="italic">provided as input</em> by an external entity, often referred to as the <strong class="keyword">injector</strong>.</p>
    <p class="normal">The injector<a id="_idIndexMarker590"/> initializes the different components and ties their dependencies together. It can be a simple initialization script or a more sophisticated <em class="italic">global container</em> that maps all the dependencies and centralizes the wiring of all the modules of the system. The main advantage of this approach is improved decoupling, especially for modules depending on stateful instances (for example, a database connection). Using DI, each dependency, instead of being hardcoded into the module, is received from the outside. This means that the dependent module can be configured to use any compatible dependency, and therefore the module itself can be reused in different contexts with minimal effort.</p>
    <p class="normal">The following diagram <a id="_idIndexMarker591"/>illustrates this idea:</p>
    <figure class="mediaobject"><img src="../Images/B15729_07_02.png" alt="../../../Downloads/Untitled%20Diagram%20(14).png"/></figure>
    <p class="packt_figref">Figure 7.2: Dependency injection schematic</p>
    <p class="normal">In <em class="italic">Figure 7.2</em>, we can see that a generic service expects a dependency with a predetermined interface. It's the responsibility of the <strong class="keyword">injector</strong> to retrieve or create an actual concrete instance that implements such an interface and passes it (or "injects it") into the service. In other words, the injector has the goal of providing an instance that fulfills the dependency for the service.</p>
    <p class="normal">To demonstrate this pattern in practice, let's refactor the simple blogging system that we built in the previous section by using DI to wire its modules. Let's start by refactoring the <code class="Code-In-Text--PACKT-">blog.js</code> module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { promisify } <span class="hljs-keyword">from</span> <span class="hljs-string">'util'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Blog</span><span class="hljs-class"> </span>{
  <strong class="hljs-keyword-slc">constructor</strong><strong class="hljs-slc"> (db) {</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.db = db</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.dbRun = promisify(db.run.bind(db))</strong>
    <strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.dbAll = promisify(db.all.bind(db))</strong>
  <strong class="hljs-slc">}</strong>
  initialize () {
    <span class="hljs-keyword">const</span> initQuery = <span class="hljs-string">`CREATE TABLE IF NOT EXISTS posts (</span>
<span class="hljs-string">      id TEXT PRIMARY KEY,</span>
<span class="hljs-string">      title TEXT NOT NULL,</span>
<span class="hljs-string">      content TEXT,</span>
<span class="hljs-string">      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span>
<span class="hljs-string">    );`</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dbRun(initQuery)
  }
  createPost (id, title, content, createdAt) {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dbRun(<span class="hljs-string">'INSERT INTO posts VALUES (?, ?, ?, ?)'</span>,
      id, title, content, createdAt)
  }
  getAllPosts () {
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.dbAll(
      <span class="hljs-string">'SELECT * FROM posts ORDER BY created_at DESC'</span>)
  }
}
</code></pre>
    <p class="normal">If you compare the new version <a id="_idIndexMarker592"/>with the previous one, they are almost identical. There are only two small but important differences:</p>
    <ul>
      <li class="Bullet--PACKT-">We are not importing the database module anymore</li>
      <li class="Bullet-End--PACKT-">The <code class="Code-In-Text--PACKT-">Blog</code> class constructor takes <code class="Code-In-Text--PACKT-">db</code> as an argument</li>
    </ul>
    <p class="normal">The new constructor argument <code class="Code-In-Text--PACKT-">db</code> is the expected dependency that needs to be provided at runtime by the client component of the <code class="Code-In-Text--PACKT-">Blog</code> class. This client component is going to be the injector of the dependency. Since JavaScript doesn't have any way to represent abstract interfaces, the provided dependency is expected to implement the <code class="Code-In-Text--PACKT-">db.run()</code> and <code class="Code-In-Text--PACKT-">db.all()</code> methods. This is called duck typing, as mentioned earlier in this book.</p>
    <p class="normal">Let's now rewrite our <code class="Code-In-Text--PACKT-">db.js</code> module. The goal here is to get rid of the Singleton pattern and to come up with an implementation that is more reusable and configurable:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> sqlite3 <span class="hljs-keyword">from</span> <span class="hljs-string">'sqlite3'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">createDb</span><span class="hljs-function"> (</span><span class="hljs-params">dbFile</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> sqlite3.Database(dbFile)
}
</code></pre>
    <p class="normal">This new implementation of the <code class="Code-In-Text--PACKT-">db</code> module provides a factory function called <code class="Code-In-Text--PACKT-">createDb()</code>, which allows us to create new instances of the database at runtime. It also allows us to pass the path to the database file at creation time so that we can create independent instances that can write to different files if we have to.</p>
    <p class="normal">At this point, we have almost all the <a id="_idIndexMarker593"/>building blocks in place, we are only missing the injector. We will give an example of the injector by reimplementing the <code class="Code-In-Text--PACKT-">index.js</code> module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { dirname, join } <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> { Blog } <span class="hljs-keyword">from</span> <span class="hljs-string">'./blog.js'</span>
<span class="hljs-keyword">import</span> { createDb } <span class="hljs-keyword">from</span> <span class="hljs-string">'./db.js'</span>
<span class="hljs-keyword">const</span> __dirname = dirname(fileURLToPath(<span class="hljs-keyword">import</span>.meta.url))
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">main</span><span class="hljs-function"> () </span>{
  <strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> db = createDb(join(__dirname, </strong><strong class="hljs-string-slc">'data.sqlite'</strong><strong class="hljs-slc">))</strong>
  <strong class="hljs-keyword-slc">const</strong><strong class="hljs-slc"> blog = </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> Blog(db)</strong>
  <span class="hljs-keyword">await</span> blog.initialize()
  <span class="hljs-keyword">const</span> posts = <span class="hljs-keyword">await</span> blog.getAllPosts()
  <span class="hljs-keyword">if</span> (posts.length === <span class="hljs-number">0</span>) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'No post available. Run `node import-posts.js`'</span> +
      <span class="hljs-string">' to load some sample posts'</span>)
  }
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> post <span class="hljs-keyword">of</span> posts) {
    <span class="hljs-built_in">console</span>.log(post.title)
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'-'</span>.repeat(post.title.length))
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Published on </span><span class="hljs-subst">${</span><span class="hljs-keyword">new</span><span class="hljs-subst"> </span><span class="hljs-built_in">Date</span>(post.<span class="hljs-subst">created_at</span>)
      .toISOString()<span class="hljs-subst">}</span><span class="hljs-string">`</span>)
    <span class="hljs-built_in">console</span>.log(post.content)
  }
}
main().catch(<span class="hljs-built_in">console</span>.error)
</code></pre>
    <p class="normal">This code is also quite similar to the previous implementation, except for two important changes (highlighted in the preceding code):</p>
    <ol>
      <li class="numbered">We create the database dependency (<code class="Code-In-Text--PACKT-">db</code>) using the factory function <code class="Code-In-Text--PACKT-">createDb()</code>.</li>
      <li class="numbered">We explicitly "inject" the database instance when we instantiate the <code class="Code-In-Text--PACKT-">Blog</code> class.</li>
    </ol>
    <p class="normal">In this implementation of our blogging system, the <code class="Code-In-Text--PACKT-">blog.js</code> module is totally decoupled from the actual database implementation, making it more composable and easy to test in isolation.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">We saw how to inject dependencies as<a id="_idIndexMarker594"/> constructor arguments (<strong class="keyword">constructor injection</strong>), but dependencies can also be passed when invoking a function or<a id="_idIndexMarker595"/> method (<strong class="keyword">function injection</strong>) or injected explicitly by assigning the relevant<a id="_idIndexMarker596"/> properties of an object (<strong class="keyword">property injection</strong>).</p>
    </div>
    <p class="normal">Unfortunately, the advantages in terms of decoupling and reusability offered by the Dependency Injection pattern come with a price to pay. In general, the inability to resolve a dependency at <em class="italic">coding time</em> makes it more difficult to understand the relationship between the various components of a system. This is especially true in large applications where we might have a significant amount of services with a complex dependency graph.</p>
    <p class="normal">Also, if we look at the way we instantiated our database dependency in our preceding example script, we can see that we had to make sure that the database instance was created before we could invoke any function from our <code class="Code-In-Text--PACKT-">Blog</code> instance. This means that, when used in its raw form, Dependency Injection forces us to build the dependency graph of the entire application by hand, making sure that we do it in the right order. This can become unmanageable when the number of modules to wire becomes too high.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Another pattern, called <strong class="keyword">Inversion of Control</strong>, allows us <a id="_idIndexMarker597"/>to shift the responsibility of wiring the modules of an application to a third-party entity. This entity can<a id="_idIndexMarker598"/> be a <strong class="keyword">service locator</strong> (a simple component used to retrieve a dependency, for example, <code class="Code-In-Text--PACKT-">serviceLocator.get('db')</code>) or<a id="_idIndexMarker599"/> a <strong class="keyword">dependency injection container</strong> (a system that injects the dependencies into a component based on some metadata specified in the code itself or in a configuration file). You can find more about these components on Martin Fowler's blog at <a href="http://nodejsdp.link/ioc-containers"><span class="url">nodejsdp.link/ioc-containers</span></a>. Even though these techniques derail a bit from the Node.js way of doing things, some <a id="_idIndexMarker600"/>of them have recently gained some <a id="_idIndexMarker601"/>popularity. Check out <code class="Code-In-Text--PACKT-">inversify</code> (<a href="http://nodejsdp.link/inversify"><span class="url">nodejsdp.link/inversify</span></a>) and <code class="Code-In-Text--PACKT-">awilix</code> (<a href="http://nodejsdp.link/awilix"><span class="url">nodejsdp.link/awilix</span></a>) to find out more.</p>
    </div>
    <h1 id="_idParaDest-206" class="title">Summary</h1>
    <p class="normal">In this chapter, you were gently introduced to a set of traditional design patterns concerning the creation of objects. Some of those patterns are so basic, and yet essential at the same time, that you have probably already used them in one way or another.</p>
    <p class="normal">Patterns such as Factory and Singleton are, for example, two of the most ubiquitous in object-oriented programming in general. However, in JavaScript, their implementation and significance are very different from what was thought up by the <em class="italic">Gang of Four</em> book. For example, Factory becomes a very versatile pattern that works in perfect harmony with the hybrid nature of the JavaScript language, that is, half object-oriented and half functional. On the other hand, Singleton becomes so trivial to implement that it's almost a non-pattern, but it carries a set of caveats that you should have learned to take into account.</p>
    <p class="normal">Among the patterns you've learned in this chapter, the Builder pattern may seem the one that has retained most of its traditional object-oriented form. However, we've shown you that it can also be used to invoke complex functions and not just to build objects.</p>
    <p class="normal">The Revealing Constructor pattern, on the other hand, deserves a category of its own. Born from necessities arising from the JavaScript language itself, it provides an elegant solution to the problem of "revealing" certain private object properties at construction time only. It provides strong guarantees in a language that is relaxed by nature.</p>
    <p class="normal">Finally, you learned about the two main techniques for wiring components together: Singleton and Dependency Injection. We've seen how the first is the simplest and most practical approach, while the second is more powerful but also potentially more complex to implement.</p>
    <p class="normal">As we already mentioned, this was just the first of a series of three chapters entirely dedicated to traditional design patterns. In these chapters, we will try to teach the right balance between creativity and rigor. We want to show not only that there are patterns that can be reused to improve our code, but also that their implementation is not the most important detail; in fact, it can vary a lot, or even overlap with other patterns. What really matters, however, is the blueprint, the guidelines, and the idea at the base of each pattern. This is the real reusable piece of information that we can exploit to design better Node.js applications in a fun way.</p>
    <p class="normal">In the next chapter, you will learn about another category of traditional design patterns, called <strong class="keyword">structural</strong> patterns. As the name suggests, these patterns are aimed at improving the way we combine objects together to build more complex, yet flexible and reusable structures.</p>
    <h1 id="_idParaDest-207" class="title">Exercises</h1>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">7.1 Console color factory</strong>: Create a class called <code class="Code-In-Text--PACKT-">ColorConsole</code> that has just one empty method called <code class="Code-In-Text--PACKT-">log()</code>. Then, create three subclasses: <code class="Code-In-Text--PACKT-">RedConsole</code>, <code class="Code-In-Text--PACKT-">BlueConsole</code>, and <code class="Code-In-Text--PACKT-">GreenConsole</code>. The <code class="Code-In-Text--PACKT-">log()</code> method of every <code class="Code-In-Text--PACKT-">ColorConsole</code> subclass will accept a string as input and will print that string to the console using the color that gives the name to the class. Then, create a factory function that takes color as input, such as <code class="Code-In-Text--PACKT-">'red'</code>, and returns the related <code class="Code-In-Text--PACKT-">ColorConsole</code> subclass. Finally, write a small command-line script to try the new console color factory. You can use this Stack Overflow answer as a reference for using colors in the console: <a href="http://nodejsdp.link/console-colors"><span class="url">nodejsdp.link/console-colors</span></a>.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">7.2 Request builder</strong>: Create your own Builder class around the built-in <code class="Code-In-Text--PACKT-">http.request()</code> function. The builder must be able to provide at least basic facilities to specify the HTTP method, the URL, the query component of the URL, the header parameters, and the eventual body data to be sent. To send the request, provide an <code class="Code-In-Text--PACKT-">invoke()</code> method that returns a <code class="Code-In-Text--PACKT-">Promise</code> for the invocation. You can find the docs for <code class="Code-In-Text--PACKT-">http.request()</code> at the following URL: <a href="http://nodejsdp.link/docs-http-request"><span class="url">nodejsdp.link/docs-http-request</span></a>.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">7.3 A tamper-free queue</strong>: Create a <code class="Code-In-Text--PACKT-">Queue</code> class that has only one publicly accessible method called <code class="Code-In-Text--PACKT-">dequeue()</code>. Such a method returns a <code class="Code-In-Text--PACKT-">Promise</code> that resolves with a new element extracted from an internal <code class="Code-In-Text--PACKT-">queue</code> data structure. If the queue is empty, then the <code class="Code-In-Text--PACKT-">Promise</code> will resolve when a new item is added. The <code class="Code-In-Text--PACKT-">Queue</code> class must also have a revealing constructor that provides a function called <code class="Code-In-Text--PACKT-">enqueue()</code> to the executor that pushes a new element to the end of the internal queue. The <code class="Code-In-Text--PACKT-">enqueue()</code> function can be invoked asynchronously and it must also take care of "unblocking" any eventual <code class="Code-In-Text--PACKT-">Promise</code> returned by the <code class="Code-In-Text--PACKT-">dequeue()</code> method. To try out the <code class="Code-In-Text--PACKT-">Queue</code> class, you could build a small HTTP server into the executor function. Such a server would receive messages or tasks from a client and would push them into the queue. A loop would then consume all those messages using the <code class="Code-In-Text--PACKT-">dequeue()</code> method.</li>
    </ul>
  </div>
</body></html>