- en: Chapter 13. Reactive Programming and React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 响应式编程和 React
- en: Along with ES6, several new ideas are emerging. These are powerful ideas and
    can help you build powerful systems with more streamlined code and design. In
    this chapter, we will introduce you to two such ideas-reactive programming and
    react. Although they sound similar, they are very different. This chapter does
    not go into practical details of these ideas but gives you necessary information
    to become aware of what these ideas are capable of. With that information, you
    can start incorporating these ideas and frameworks into your projects. We will
    discuss the basic idea of reactive programming and take a bit more detailed look
    at react.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 ES6 的出现，一些新的想法正在涌现。这些想法非常强大，可以帮助你用更简洁的代码和设计构建强大的系统。在本章中，我们将向您介绍两个这样的想法——响应式编程和
    React。尽管它们听起来很相似，但实际上它们非常不同。本章不会深入探讨这些想法的实践细节，但会提供必要的信息，让你了解这些想法的能力。有了这些信息，你就可以开始将这些想法和框架融入到你的项目中。我们将讨论响应式编程的基本概念，并对
    React 进行更详细的探讨。
- en: Reactive programming
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式编程
- en: Reactive programming is getting a lot of focus lately. This idea is relatively
    new and, like many new ideas, has lots of confusing, and sometimes contradictory
    information floating around. We discussed asynchronous programming earlier in
    this book. JavaScript takes asynchronous programming to new heights by providing
    first class language constructs that support it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程最近受到了很多关注。这个想法相对较新，就像许多新想法一样，有很多令人困惑，有时甚至是相互矛盾的信息在流传。我们在本书中之前讨论了异步编程。JavaScript通过提供支持异步编程的第一类语言结构，将异步编程提升到了新的高度。
- en: 'Reactive programming is essentially programming with asynchronous event streams.
    An event stream is a sequence of events happening over time. Consider the following
    diagram:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程本质上是一种使用异步事件流的编程方式。事件流是随时间发生的一系列事件。考虑以下图示：
- en: '![Reactive programming](img/image_13_001.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![响应式编程](img/image_13_001.jpg)'
- en: In the preceding diagram, time passes from left to right and different events
    occur over time. As the event happens over time, we can add an event listener
    to this whole sequence. Whenever an event happens, we can react to it by doing
    something.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，时间从左到右流逝，不同的事件随时间发生。随着事件随时间发生，我们可以为整个序列添加事件监听器。每当发生事件时，我们都可以通过做些事情来对此做出反应。
- en: 'Another type of sequence in JavaScript is an array. For example, consider the
    following lines of code:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中另一种类型的序列是数组。例如，考虑以下代码行：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this case, the entire sequence lives in memory at the same time. However,
    in case of event stream, events happen over time and there is no state at this
    point of time. Consider the following lines of code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，整个序列同时存在于内存中。然而，在事件流的情况下，事件随时间发生，此时没有状态。考虑以下代码行：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Don't worry too much about what is going on in this example just yet. Here,
    events are happening over time. Instead of having a fixed bunch of elements in
    an array, here they are happening over time, after 500 ms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不必太担心这个示例中正在发生的事情。在这里，事件随时间发生。与数组中固定的一组元素不同，这里的事件随时间发生，在500毫秒后。
- en: 'We will add an event listener to the `arr` event stream, and when an event
    happens, we will print the element on console. You can see a similarity between
    the methods in arrays and the event streams. Now, to expand on this similarity,
    let''s say, you want to filter all non-numbers from this list. You can use the
    `map` function to this event stream, just like you would use it on an array, and
    then you would want to filter the results to show only integers. Consider the
    following lines of code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 `arr` 事件流添加事件监听器，当事件发生时，我们将在控制台打印元素。你可以看到数组和事件流方法之间的相似性。现在，为了扩展这种相似性，假设你想从这个列表中过滤掉所有非数字。你可以使用
    `map` 函数来处理这个事件流，就像你会在数组上使用它一样，然后你将想要过滤结果，只显示整数。考虑以下代码行：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Interestingly, the same methods work for event streams as well. Take a look
    at the following code example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，同样的方法也适用于事件流。看看下面的代码示例：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These are simpler examples just to make sure you start seeing how event streams
    flow over time. Please don't bother about the syntax and construct just yet. Before
    we can look at them, we will need to make sure we understand how to think in reactive
    programming. Event streams are fundamental to reactive programming; they allow
    you to define the dynamic behavior of a value at declaration time (definition
    taken from Andre Staltz's blog).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是简单的例子，只是为了确保你能开始看到事件流随时间流动的方式。请暂时不要担心语法和结构。在我们能够查看它们之前，我们需要确保我们理解了如何在响应式编程中思考。事件流是响应式编程的基础；它们允许你在声明时（定义来自Andre
    Staltz的博客）定义值的动态行为。
- en: 'Let''s say you have an `a` variable, which has initially the value `3`. Then,
    you have a `b` variable, which is `10 * a`. If we console log out `b`, we will
    see `30`. Consider the following lines of code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个初始值为`3`的`a`变量。然后，你有一个`b`变量，它是`10 * a`。如果我们输出`b`的值，我们会看到`30`。考虑以下代码行：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We know the result is very straightforward. When we change the value of `a`
    to `4`, the value of `b` will not change. This is how static declaration works.
    When we talk about reactive programming and event streams, this is the area where
    people find difficulty in understanding how events flow. Ideally, we want to create
    a formula, *b=a*10*, and over time, whenever the value of `a` changes, the changed
    value is reflected in the formula.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道结果非常直接。当我们把`a`的值改为`4`时，`b`的值不会改变。这就是静态声明的工作方式。当我们谈论响应式编程和事件流时，这是人们发现难以理解事件如何流动的领域。理想情况下，我们想要创建一个公式，*b=a*10*，并且随着时间的推移，每当`a`的值发生变化时，变化后的值都会反映在公式中。
- en: That is what we can accomplish with event streams. Let's say `a` is an event
    stream of just the value `3`. Then, we have `streamB`, which is `streamA` mapped.
    Each of these `a` values will be mapped to `10 * a`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是事件流所能实现的事情。假设`a`是一个只包含值`3`的事件流。那么，我们就有`streamB`，它是`streamA`的映射。这些`a`值中的每一个都将被映射到`10
    * a`。
- en: 'If we add an event listener to that `streamB`, and we console log, we will
    see `b` being `30`. Take a look at the following example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们向`streamB`添加一个事件监听器，并在控制台输出日志，我们会看到`b`的值为`30`。请看以下示例：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we do this, we have an event stream that simply has just two events. It has
    event `3`, and then it has event `4`, and `b` will change accordingly whenever
    `a` changes. If we run this, we see `b` being `30` and `40`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，我们有一个只包含两个事件的事件流。它有一个事件`3`，然后是事件`4`，每当`a`的值发生变化时，`b`的值将相应地改变。如果我们运行这个程序，我们会看到`b`的值为`30`和`40`。
- en: Now that we have spent some time in getting the basics of reactive programming
    sorted, you may ask the following question.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经花了一些时间来整理响应式编程的基础，你可能会有以下问题。
- en: Why should you consider reactive programming?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么你应该考虑响应式编程？
- en: As we write highly responsive and interactive UI applications on modern web
    and mobile, there is a strong need to find a way to deal with real-time events
    without stopping the user interactions on the UI. When you are dealing with multiple
    UI and server events being fired, you will be spending most of your time writing
    code to deal with these events. This is tedious. Reactive programming gives you
    a structured framework to deal with asynchronous events with minimal code while
    you focus on the business logic for your application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在现代Web和移动设备上编写高度响应和交互式的UI应用程序时，我们需要找到一种方法来处理实时事件，同时不停止用户与UI的交互。当你处理多个UI和服务器事件被触发时，你将花费大部分时间编写代码来处理这些事件。这是很繁琐的。响应式编程为你提供了一个结构化的框架，以最小的代码处理异步事件，同时你专注于应用程序的业务逻辑。
- en: Reactive programming is not limited to JavaScript. Reactive extensions are available
    in many platforms and languages, such as Java, Scala, Clojure, Ruby, Python, and
    Object C/Cocoa. `Rx.js` and `Bacon.js` are popular JavaScript libraries that provide
    reactive programming support.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程并不仅限于JavaScript。响应式扩展在许多平台和语言中都是可用的，例如Java、Scala、Clojure、Ruby、Python和Objective
    C/Cocoa。`Rx.js`和`Bacon.js`是流行的JavaScript库，它们提供了响应式编程的支持。
- en: A deep dive into `Rx.js` is not the intention of this chapter. The idea was
    to introduce you to the idea of reactive programming. If you are keen on adopting
    reactive programming for your projects, you should take look at Andre Staltz's
    excellent introduction ([https://gist.github.com/staltz/868e7e9bc2a7b8c1f754](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的不是深入探讨 `Rx.js`。想法是向你介绍响应式编程的概念。如果你对你的项目采用响应式编程感兴趣，你应该看看 Andre Staltz 的优秀介绍（[https://gist.github.com/staltz/868e7e9bc2a7b8c1f754](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)）。
- en: React
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React
- en: React is taking the JavaScript world by storm. Facebook created the react framework
    to solve an age-old problem-how to deal efficiently with the view part of the
    traditional **Model-View-Controller** applications.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: React 正在 JavaScript 世界掀起一场风暴。Facebook 创建了 React 框架来解决一个古老的难题——如何高效地处理传统 **模型-视图-控制器**
    应用程序中的视图部分。
- en: React provides a declarative and flexible way to build user interfaces. The
    most important thing to remember about react is that it deals with only one thing-the
    view, or the UI. React does not deal with data, data bindings, or anything else.
    There are complete frameworks, such as Angular, that deal with data, bindings,
    and UI; React is not that.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了一种声明性和灵活的方式来构建用户界面。关于 React，最重要的是记住它只处理一件事——视图，或 UI。React 不处理数据、数据绑定或其他任何事情。有一些完整的框架，如
    Angular，处理数据、绑定和 UI；React 不是那样。
- en: React gives a template language and a small set of functions to render HTML.
    React components can store their own state in memory. To build a full-fledged
    application, you will need other pieces as well; React is just to handle the view
    part of that application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: React 提供了一种模板语言和一组小函数来渲染 HTML。React 组件可以在内存中存储它们自己的状态。要构建一个完整的应用程序，你还需要其他组件；React
    只是用来处理该应用程序的视图部分。
- en: A big challenge when writing complex UI is to manage state of the UI elements
    when the model changes. React provides a declarative API so that you don't have
    to worry about exactly what changes on every update. This makes writing applications
    a lot easier. React uses **Virtual DOM** and **diffing** algorithm, so that component
    updates are predictable while being fast enough for high-performance apps.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写复杂 UI 时的一个大挑战是在模型变化时管理 UI 元素的状态。React 提供了一个声明式 API，这样你就不必担心每次更新时确切发生了什么变化。这使得编写应用程序变得容易得多。React
    使用 **虚拟 DOM** 和 **diffing** 算法，使得组件更新既可预测又足够快，适用于高性能应用程序。
- en: Virtual DOM
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟 DOM
- en: Let's take a moment to understand what is a Virtual DOM. We discussed **DOM**
    (**document object model**), a tree structure of HTML element on a web page. DOM
    is de facto, and the primary rendering mechanism of the web. The DOM APIs, such
    as `getElementById()`, allow traversing and modification of the elements in the
    DOM tree. DOM is a tree and this structure works pretty well with traversal and
    updating of elements. However, both the traversing and updating of DOM is not
    very quick. For a large page, the DOM tree can be pretty big. When you want a
    complex UI that has bunch of user interactions, updating DOM elements can be tedious
    and slow. We have tried jQuery and other libraries to reduce the tedious syntax
    for frequent DOM modifications, but DOM as a structure itself is quite limited.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一点时间来理解什么是虚拟 DOM。我们讨论了 **DOM**（**文档对象模型**），这是网页上 HTML 元素的树状结构。DOM 是事实上的，也是网络的主要渲染机制。DOM
    API，如 `getElementById()`，允许遍历和修改 DOM 树中的元素。DOM 是一个树，这种结构在遍历和更新元素方面表现得相当好。然而，DOM
    的遍历和更新都不是很快。对于大型页面，DOM 树可能相当大。当你想要一个具有大量用户交互的复杂 UI 时，更新 DOM 元素可能会很繁琐且缓慢。我们尝试过
    jQuery 和其他库来减少频繁 DOM 修改的繁琐语法，但 DOM 作为一种结构本身是相当有限的。
- en: What if we don't have to traverse the DOM over and over again to modify elements?
    What if you just declare how a component should look like and let someone handle
    the logic of how to render that component? react does exactly that. React lets
    you declare how you want your UI element to look like and abstracts out low-level
    DOM manipulation APIs. Apart from this very useful abstraction, react does something
    pretty smart to solve the performance problem as well.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不必一次又一次地遍历 DOM 来修改元素会怎样？如果我们只是声明一个组件应该如何看起来，然后让某人处理如何渲染该组件的逻辑呢？React 正是这样做。React
    允许你声明你希望你的 UI 元素看起来如何，并抽象出低级别的 DOM 操作 API。除了这个非常有用的抽象之外，React 还采取了一些相当聪明的措施来解决性能问题。
- en: React uses something called a Virtual DOM. A virtual DOM is a lightweight abstraction
    of the HTML DOM. You can think of it as a local in-memory copy of the HTML DOM.
    React uses it to do all computations necessary to render the state of a UI component.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React 使用一种称为虚拟 DOM 的东西。虚拟 DOM 是 HTML DOM 的轻量级抽象。你可以把它想象成 HTML DOM 的本地内存副本。React
    使用它来完成渲染 UI 组件状态所需的所有计算。
- en: You can find more details of this optimization at [https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html)
    找到更多关于此优化的详细信息。
- en: React's primary strength, however, is not just Virtual DOM. React is a fantastic
    abstraction that makes composition, unidirectional dataflow, and static modeling
    easier while developing large applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，React 的主要优势并不仅仅是虚拟 DOM。React 是一个出色的抽象，它使得在开发大型应用程序时组合、单向数据流和静态建模变得更加容易。
- en: Installing and running react
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和运行 React
- en: 'First, let''s install react. Earlier, installing and getting react set up on
    your machine needed a bunch of dependencies to be taken care of. However, we will
    use a relatively faster way to get react up and running. We will use `create-react-app`
    to which we can install react without any build configuration. Installation is
    done via `npm` which is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们安装 React。以前，在您的机器上安装和设置 React 需要处理许多依赖项。然而，我们将使用一种相对更快的方法来让 React 运行起来。我们将使用
    `create-react-app`，这样我们就可以在不进行任何构建配置的情况下安装 React。安装是通过 `npm` 完成的，如下所示：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we are installing the `create-react-app` node module globally. Once `create-react-app`
    is installed, you can set up the directory for your application. Consider the
    following commands:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在全局安装 `create-react-app` 节点模块。一旦 `create-react-app` 安装完成，你就可以为你的应用程序设置目录。考虑以下命令：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, open `http://localhost:3000/` to see your app. You should see something
    like the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开 `http://localhost:3000/` 来查看您的应用。你应该会看到以下截图中的内容：
- en: '![Installing and running react](img/image_13_002.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![安装和运行 React](img/image_13_002.jpg)'
- en: 'If you open the directory in an editor, you will see several files created
    for you, as you can see in the following screenshot:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个编辑器中打开该目录，你会看到为你创建的几个文件，如下面的截图所示：
- en: '![Installing and running react](img/image_13_003.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![安装和运行 React](img/image_13_003.jpg)'
- en: 'In this project, `node_modules` are the dependencies required to run this project
    and dependencies of react itself. The important directory is `src`, where the
    source code is kept. For this example, let''s keep only two files-`App.js` and
    `index.js`. The `/public/index.html` file should contain just the root `div`,
    which will be used as a target for our react components. Consider the following
    code snippet:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，`node_modules` 是运行此项目所需的依赖项以及 React 本身的依赖项。重要的目录是 `src`，其中保存了源代码。对于这个例子，让我们只保留两个文件
    - `App.js` 和 `index.js`。`/public/index.html` 文件应只包含根 `div`，它将被用作我们的 React 组件的目标。考虑以下代码片段：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The moment you make this change, you will see the following error:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做出这个更改，你将看到以下错误：
- en: '![Installing and running react](img/image_13_004.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![安装和运行 React](img/image_13_004.jpg)'
- en: Beauty of developing with react is that the code changes are live-reloaded,
    and you can get immediate feedback.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React 开发的美妙之处在于代码更改是实时重新加载的，你可以立即获得反馈。
- en: 'Next, clear off all content of `App.js`, and replace it with the following
    lines of code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，清空 `App.js` 中的所有内容，并用以下代码行替换：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, go to `index.js` and remove the `import ./index.css;` line. Without you
    doing anything, such as restarting server and refreshing browser, you will see
    the modified page on the browser. Consider the following screenshot:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `index.js` 并删除 `import ./index.css;` 这一行。无需你做任何操作，例如重启服务器和刷新浏览器，你将在浏览器上看到修改后的页面。考虑以下截图：
- en: '![Installing and running react](img/image_13_005.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![安装和运行 React](img/image_13_005.jpg)'
- en: Before we create a `HelloWorld` react component, a couple of important things
    to notice so far.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建 `HelloWorld` React 组件之前，有一些重要的事情需要注意。
- en: 'In `App.js` and `index.js`, we are importing two libraries necessary to create
    react components. Consider the following lines of code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.js` 和 `index.js` 中，我们导入了创建 React 组件所必需的两个库。考虑以下代码行：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we're importing `React`, which is the library that allows us to build
    react components. We're also importing `ReactDOM`, which is the library that allows
    us to place our components and work with them in the context of the DOM. Then,
    we're importing the component that we just worked on-the App component.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们正在导入`React`，这是一个允许我们构建React组件的库。我们还在导入`ReactDOM`，这是一个允许我们在DOM上下文中放置我们的组件并与之交互的库。然后，我们导入我们刚刚工作的组件——`App`组件。
- en: 'We also created our first component in `App.js`. Consider the following line
    of code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在`App.js`中创建了我们的第一个组件。考虑以下代码行：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a stateless function component. The other way to create a component
    is to create a class component. We can replace the preceding component with the
    following class component:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个无状态函数组件。创建组件的另一种方式是创建类组件。我们可以用以下类组件替换前面的组件：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are a bunch of interesting things going on here. First, we are creating
    a class component with the `class` keyword that extends from the superclass `React.Component`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了很多有趣的事情。首先，我们使用`class`关键字创建了一个从超类`React.Component`扩展的类组件。
- en: Our component `App` is a react component class or react component type. A component
    takes in parameters, also called `props`, and returns a hierarchy of views to
    display via the `render` function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的组件`App`是一个React组件类或React组件类型。组件接收参数，也称为`props`，并通过`render`函数返回一个要显示的视图层次结构。
- en: 'The `render` method returns a description of what you want to render, and then
    react takes that description and renders it to the screen. In particular, `render`
    returns a react element, which is a lightweight description of what to render.
    Most react developers use a special syntax called JSX, which makes it easier to
    write these structures. The `<div />` syntax is transformed at build time to `React.createElement`(`''div''`).
    The JSX expression, `<h1>Hello World</h1>`, is transformed at build time into
    the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`render`方法返回你想要渲染的描述，然后React将这个描述渲染到屏幕上。特别是，`render`返回一个React元素，这是要渲染内容的轻量级描述。大多数React开发者使用一种特殊的语法，称为JSX，这使得编写这些结构更加容易。`<div
    />`语法在构建时被转换为`React.createElement`(`''div''`)。JSX表达式`<h1>Hello World</h1>`在构建时被转换为以下内容：'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The difference between the class component and stateless function component
    is that the class component can contain a state while the stateless (hence the
    name) function component cannot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类组件和无状态函数组件之间的区别在于，类组件可以包含状态，而无状态函数组件（因此得名）不能。
- en: 'The `render` method of the react component is allowed to return only a single
    node. If you do something like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: React组件的`render`方法只能返回一个节点。如果你做如下操作：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will get the following error:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下错误：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is because you are essentially returning two `React.createElement` functions,
    and that is not valid JavaScript. While this may seem like a deal breaker, this
    is easy to solve. We can wrap our nodes into a parent node and return that parent
    node from the `render` function. We can create a parent `div` and wrap other nodes
    under it. Consider the following example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为你实际上返回了两个`React.createElement`函数，这在JavaScript中是不合法的。虽然这看起来像是一个大问题，但这很容易解决。我们可以将我们的节点包裹在一个父节点中，并从`render`函数中返回该父节点。我们可以创建一个父`div`并将其他节点包裹在其下。考虑以下示例：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Components and props
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件和props
- en: 'Components can be conceptually considered as JavaScript functions. They take
    arbitrary number of inputs like normal functions. These inputs are called props.
    To illustrate this, let''s consider the following function:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，可以将组件视为JavaScript函数。它们像普通函数一样接受任意数量的输入。这些输入被称为props。为了说明这一点，让我们考虑以下函数：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is a normal function and also a valid react component. It takes an input
    called `props` and returns a valid JSX. We can use the `props` inside JSX using
    curly braces and properties such as `name` using a standard object notation. Now
    that `Greet` is a first class react component, let''s use it in the `render()`
    function as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通函数，也是一个有效的React组件。它接受一个名为`props`的输入并返回有效的JSX。我们可以在JSX中使用花括号和标准对象表示法中的属性，如`name`。现在`Greet`是一个一等React组件，让我们在`render()`函数中使用它，如下所示：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are calling `Greet()` as a normal component and passing `this.props` to
    it. It is required to capitalize your own components. React considers component
    names starting with a lowercase as standard HTML tags and expects custom component
    names to start with a capital letter. As we saw earlier, we can create a class
    component using ES6 class. This component is a subclass of `React.component`.
    An equivalent component to our `Greet` function is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Greet()` 作为普通组件调用，并将 `this.props` 传递给它。要求你对自己的组件进行大写。React 将以小写字母开头的组件名称视为标准
    HTML 标签，并期望自定义组件名称以大写字母开头。正如我们之前所看到的，我们可以使用 ES6 类创建一个类组件。这个组件是 `React.component`
    的子类。与我们的 `Greet` 函数等效的组件如下：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For all practical purposes, we will use this method of creating components.
    We will soon know why.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 出于所有实际目的，我们将使用这种方法来创建组件。我们很快就会知道为什么。
- en: One important point to note is that a component cannot modify its own props.
    This may seem like a limitation because, in almost all non-trivial applications,
    you will want user interactions where the UI component state is changed in react,
    for example, update date of birth in a form, `props` are read-only but there is
    a much robust mechanism to handle UI updates.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要点是，组件不能修改自己的 props。这可能会显得有些限制，因为在几乎所有非平凡的应用中，你都会希望用户交互能够改变 React 中的
    UI 组件状态，例如，在表单中更新出生日期，`props` 是只读的，但有一个更强大的机制来处理 UI 更新。
- en: State
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: State is similar to props, but it is private and fully controlled by the component.
    As we saw earlier that both functional and class components are equivalent in
    react, one important distinction is that the state is available only in class
    components. Hence, for all practical purposes, we will use class components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 状态类似于 props，但它私有且完全由组件控制。正如我们之前所看到的，在 React 中，函数组件和类组件是等效的，一个重要的区别是状态仅在类组件中可用。因此，出于所有实际目的，我们将使用类组件。
- en: We can change our existing greeting example to use state, and whenever the state
    changes, we will update our `Greet` component to reflect the changed value.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将现有的问候示例更改为使用状态，并且每当状态发生变化时，我们将更新我们的 `Greet` 组件以反映变化后的值。
- en: 'First, we will set up the state inside our `App.js`, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在 `App.js` 中设置状态，如下所示：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are a few important things to notice in this example. First, we are calling
    class `constructor` to initialize `this.state`. We also call the base class constructor,
    `super()`, and pass `props` to it. After calling `super()`, we initialize our
    default state by setting `this.state` to an object. For example, we assign a `greeting`
    property with a value here. In the `render` method, we will use this property
    using `{this.state.greeting}`. Having setup our initial state, we can add UI elements
    to update this state. Let''s add an input box, and on change of that input box,
    we will update our state and the `greeting` element. Consider the following lines
    of code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有几个重要的事情需要注意。首先，我们调用类 `constructor` 来初始化 `this.state`。我们还调用基类构造函数 `super()`，并将
    `props` 传递给它。在调用 `super()` 之后，我们通过设置 `this.state` 为一个对象来初始化我们的默认状态。例如，我们在这里分配一个
    `greeting` 属性。在 `render` 方法中，我们将使用这个属性，即 `{this.state.greeting}`。在设置好初始状态后，我们可以添加
    UI 元素来更新这个状态。让我们添加一个输入框，并在输入框更改时更新我们的状态和 `greeting` 元素。考虑以下代码行：
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, we add an input box and update the state of the component when the `onChange`
    method of the input box is invoked. We use a custom `updateGreeting()` method
    to update the state by calling `this.setState` and updating the property. When
    you run this example, you will notice that as you type something on the text box,
    only the `greeting` element is updated and not the `name`. Take a look at the
    following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加一个输入框，并在输入框的 `onChange` 方法被调用时更新组件的状态。我们使用自定义的 `updateGreeting()` 方法通过调用
    `this.setState` 并更新属性来更新状态。当你运行这个示例时，你会注意到，当你开始在文本框中输入时，只有 `greeting` 元素被更新，而
    `name` 没有变化。请看以下截图：
- en: '![State](img/image_13_006.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![状态](img/image_13_006.jpg)'
- en: 'An important feature of react is the fact that a react component can output
    or render other react components. We''ve got a very simple component here. It
    has a state with a value of text. It''s got an `update` method which will update
    that value of text from an event. What we''ll do is create a new component. This
    will be a stateless function component. We''ll call it widget. It will take in
    `props`. We''ll return this JSX input right here. Consider the following code
    snippet:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: React 的重要特性之一是，一个 React 组件可以输出或渲染其他 React 组件。这里有一个非常简单的组件。它有一个值为 text 的状态。它有一个
    `update` 方法，该方法将从事件中更新文本的值。我们将创建一个新的组件。这将是一个无状态的函数组件。我们将称之为 widget。它将接受 `props`。我们将返回这里的
    JSX 输入。考虑以下代码片段：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'First, we extract our input element into a stateless function component and
    call it a `Widget`. We pass `props` to this component. Then, we change `onChange`
    to use `props.update`. Now, inside our `render` method, we use the `Widget` component
    and pass a prop `update` that binds the `updateGreeting()` method. Now that `Widget`
    is a component, we can reuse it anywhere in the `Greet` component. We are creating
    three instances of the `Widget`, and when any of the `Widget` is updated, the
    greeting text is updated, as shown in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将我们的输入元素提取到一个无状态的函数组件中，并将其称为 `Widget`。我们将 `props` 传递给这个组件。然后，我们将 `onChange`
    更改为使用 `props.update`。现在，在我们的 `render` 方法中，我们使用 `Widget` 组件并传递一个 `update` 属性，该属性绑定
    `updateGreeting()` 方法。现在 `Widget` 是一个组件，我们可以在 `Greet` 组件的任何地方重用它。我们正在创建三个 `Widget`
    实例，当任何一个 `Widget` 被更新时，问候文本也会更新，如以下截图所示：
- en: '![State](img/image_13_007.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![状态](img/image_13_007.jpg)'
- en: Life cycle events
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期事件
- en: When you have a bunch of components with several state changes and events, the
    housekeeping becomes important. React provides you with several component life
    cycle hooks to handle life cycle events of components. Understanding the component
    life cycle will enable you to perform certain actions when a component is created
    or destroyed. Furthermore, it gives you the opportunity to decide if a component
    should be updated in the first place, and to react to `props` or state changes
    accordingly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一堆组件，它们有多个状态变化和事件时，维护变得很重要。React 为你提供了几个组件生命周期钩子来处理组件的生命周期事件。理解组件的生命周期将使你能够在组件创建或销毁时执行某些操作。此外，它还给你机会决定组件是否应该首先更新，并相应地响应
    `props` 或状态变化。
- en: 'There are three phases that the component goes through-mounting, updating,
    and unmouting. For each of these stages, we have hooks. Take a look at the following
    diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 组件会经历三个阶段：挂载、更新和卸载。对于每个阶段，我们都有钩子。看看以下图表：
- en: '![Life cycle events](img/image_13_008.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![生命周期事件](img/image_13_008.jpg)'
- en: Two methods are called when a component is initially rendered, `getDefaultProps`
    and `getInitialState`, and, as their names suggest, we can set default `props`
    and initial state of a component in these methods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件首次渲染时，会调用两个方法，`getDefaultProps` 和 `getInitialState`，正如它们的名称所暗示的，我们可以在这些方法中设置组件的默认
    `props` 和初始状态。
- en: The `componentWillMount` is called before the `render` method is executed. We
    already know `render` to be the place where we return the component to be rendered.
    As soon as the `render` method finishes, the `componentDidMount` method is invoked.
    You can access DOM in this method, and it is recommended to perform any DOM interactions
    in this method.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`componentWillMount` 在 `render` 方法执行之前被调用。我们已经知道 `render` 是我们返回要渲染的组件的地方。一旦
    `render` 方法完成，`componentDidMount` 方法就会被调用。你可以在该方法中访问 DOM，并且建议在这个方法中执行任何 DOM 交互。'
- en: State changes invoke a few methods. The `shouldComponentUpdate` method is invoked
    before the `render` method, and it lets us decide if we should allow rerendering
    or skip it. This method is never called on the initial rendering. The `componentWillUpdate`
    method gets called immediately once the `shouldComponentUpdate` method returns
    `true`. The `componentDidUpdate` method is rendered after `render` finishes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 状态变化会调用几个方法。`shouldComponentUpdate` 方法在 `render` 方法之前被调用，并允许我们决定是否允许重新渲染或跳过它。这个方法在初始渲染时永远不会被调用。`componentWillUpdate`
    方法在 `shouldComponentUpdate` 方法返回 `true` 后立即被调用。`componentDidUpdate` 方法在 `render`
    完成后被渲染。
- en: Any change to the `props` object triggers similar methods as a state change.
    One additional method called is `componentWillReceiveProps`; it is called only
    when the `props` have changed, and it is not initial rendering. You can update
    state based on new and old props in this method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对`props`对象的任何更改都会触发类似于状态变化的方法。还有一个额外的方法叫做`componentWillReceiveProps`；它仅在`props`发生变化时调用，并且不是初始渲染。您可以在该方法中根据新旧`props`更新状态。
- en: When a component is removed from DOM, `componentWillUnmount` is called. This
    is a useful method to perform cleanups.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件从DOM中移除时，会调用`componentWillUnmount`。这是一个执行清理的有用方法。
- en: Great thing about react is that when you start using it, the framework feels
    very natural to you. There are very few moving parts you will need to learn, and
    the abstraction is just right.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: React的伟大之处在于，当您开始使用它时，框架对您来说感觉非常自然。您需要学习的移动部件非常少，抽象程度恰到好处。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was aimed at some of the important new ideas that are gaining a
    lot of prominence lately. Both reactive programming and react can significantly
    boost programmer productivity. React is definitely one of the most important emerging
    technologies backed by the likes of Facebook and Netflix.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在介绍一些最近获得大量关注的重要新思想。响应式编程和React都可以显著提高程序员的效率。React无疑是Facebook和Netflix等公司支持的最重要新兴技术之一。
- en: This chapter was intended to give you an introduction to both these technologies
    and help you start exploring them in more detail.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在为您介绍这两种技术，并帮助您更深入地探索它们。
