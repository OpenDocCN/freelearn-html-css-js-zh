- en: Chapter 13. Reactive Programming and React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Along with ES6, several new ideas are emerging. These are powerful ideas and
    can help you build powerful systems with more streamlined code and design. In
    this chapter, we will introduce you to two such ideas-reactive programming and
    react. Although they sound similar, they are very different. This chapter does
    not go into practical details of these ideas but gives you necessary information
    to become aware of what these ideas are capable of. With that information, you
    can start incorporating these ideas and frameworks into your projects. We will
    discuss the basic idea of reactive programming and take a bit more detailed look
    at react.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive programming is getting a lot of focus lately. This idea is relatively
    new and, like many new ideas, has lots of confusing, and sometimes contradictory
    information floating around. We discussed asynchronous programming earlier in
    this book. JavaScript takes asynchronous programming to new heights by providing
    first class language constructs that support it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive programming is essentially programming with asynchronous event streams.
    An event stream is a sequence of events happening over time. Consider the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reactive programming](img/image_13_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding diagram, time passes from left to right and different events
    occur over time. As the event happens over time, we can add an event listener
    to this whole sequence. Whenever an event happens, we can react to it by doing
    something.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of sequence in JavaScript is an array. For example, consider the
    following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the entire sequence lives in memory at the same time. However,
    in case of event stream, events happen over time and there is no state at this
    point of time. Consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Don't worry too much about what is going on in this example just yet. Here,
    events are happening over time. Instead of having a fixed bunch of elements in
    an array, here they are happening over time, after 500 ms.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add an event listener to the `arr` event stream, and when an event
    happens, we will print the element on console. You can see a similarity between
    the methods in arrays and the event streams. Now, to expand on this similarity,
    let''s say, you want to filter all non-numbers from this list. You can use the
    `map` function to this event stream, just like you would use it on an array, and
    then you would want to filter the results to show only integers. Consider the
    following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, the same methods work for event streams as well. Take a look
    at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These are simpler examples just to make sure you start seeing how event streams
    flow over time. Please don't bother about the syntax and construct just yet. Before
    we can look at them, we will need to make sure we understand how to think in reactive
    programming. Event streams are fundamental to reactive programming; they allow
    you to define the dynamic behavior of a value at declaration time (definition
    taken from Andre Staltz's blog).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say you have an `a` variable, which has initially the value `3`. Then,
    you have a `b` variable, which is `10 * a`. If we console log out `b`, we will
    see `30`. Consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We know the result is very straightforward. When we change the value of `a`
    to `4`, the value of `b` will not change. This is how static declaration works.
    When we talk about reactive programming and event streams, this is the area where
    people find difficulty in understanding how events flow. Ideally, we want to create
    a formula, *b=a*10*, and over time, whenever the value of `a` changes, the changed
    value is reflected in the formula.
  prefs: []
  type: TYPE_NORMAL
- en: That is what we can accomplish with event streams. Let's say `a` is an event
    stream of just the value `3`. Then, we have `streamB`, which is `streamA` mapped.
    Each of these `a` values will be mapped to `10 * a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add an event listener to that `streamB`, and we console log, we will
    see `b` being `30`. Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we do this, we have an event stream that simply has just two events. It has
    event `3`, and then it has event `4`, and `b` will change accordingly whenever
    `a` changes. If we run this, we see `b` being `30` and `40`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have spent some time in getting the basics of reactive programming
    sorted, you may ask the following question.
  prefs: []
  type: TYPE_NORMAL
- en: Why should you consider reactive programming?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we write highly responsive and interactive UI applications on modern web
    and mobile, there is a strong need to find a way to deal with real-time events
    without stopping the user interactions on the UI. When you are dealing with multiple
    UI and server events being fired, you will be spending most of your time writing
    code to deal with these events. This is tedious. Reactive programming gives you
    a structured framework to deal with asynchronous events with minimal code while
    you focus on the business logic for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is not limited to JavaScript. Reactive extensions are available
    in many platforms and languages, such as Java, Scala, Clojure, Ruby, Python, and
    Object C/Cocoa. `Rx.js` and `Bacon.js` are popular JavaScript libraries that provide
    reactive programming support.
  prefs: []
  type: TYPE_NORMAL
- en: A deep dive into `Rx.js` is not the intention of this chapter. The idea was
    to introduce you to the idea of reactive programming. If you are keen on adopting
    reactive programming for your projects, you should take look at Andre Staltz's
    excellent introduction ([https://gist.github.com/staltz/868e7e9bc2a7b8c1f754](https://gist.github.com/staltz/868e7e9bc2a7b8c1f754)).
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React is taking the JavaScript world by storm. Facebook created the react framework
    to solve an age-old problem-how to deal efficiently with the view part of the
    traditional **Model-View-Controller** applications.
  prefs: []
  type: TYPE_NORMAL
- en: React provides a declarative and flexible way to build user interfaces. The
    most important thing to remember about react is that it deals with only one thing-the
    view, or the UI. React does not deal with data, data bindings, or anything else.
    There are complete frameworks, such as Angular, that deal with data, bindings,
    and UI; React is not that.
  prefs: []
  type: TYPE_NORMAL
- en: React gives a template language and a small set of functions to render HTML.
    React components can store their own state in memory. To build a full-fledged
    application, you will need other pieces as well; React is just to handle the view
    part of that application.
  prefs: []
  type: TYPE_NORMAL
- en: A big challenge when writing complex UI is to manage state of the UI elements
    when the model changes. React provides a declarative API so that you don't have
    to worry about exactly what changes on every update. This makes writing applications
    a lot easier. React uses **Virtual DOM** and **diffing** algorithm, so that component
    updates are predictable while being fast enough for high-performance apps.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual DOM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a moment to understand what is a Virtual DOM. We discussed **DOM**
    (**document object model**), a tree structure of HTML element on a web page. DOM
    is de facto, and the primary rendering mechanism of the web. The DOM APIs, such
    as `getElementById()`, allow traversing and modification of the elements in the
    DOM tree. DOM is a tree and this structure works pretty well with traversal and
    updating of elements. However, both the traversing and updating of DOM is not
    very quick. For a large page, the DOM tree can be pretty big. When you want a
    complex UI that has bunch of user interactions, updating DOM elements can be tedious
    and slow. We have tried jQuery and other libraries to reduce the tedious syntax
    for frequent DOM modifications, but DOM as a structure itself is quite limited.
  prefs: []
  type: TYPE_NORMAL
- en: What if we don't have to traverse the DOM over and over again to modify elements?
    What if you just declare how a component should look like and let someone handle
    the logic of how to render that component? react does exactly that. React lets
    you declare how you want your UI element to look like and abstracts out low-level
    DOM manipulation APIs. Apart from this very useful abstraction, react does something
    pretty smart to solve the performance problem as well.
  prefs: []
  type: TYPE_NORMAL
- en: React uses something called a Virtual DOM. A virtual DOM is a lightweight abstraction
    of the HTML DOM. You can think of it as a local in-memory copy of the HTML DOM.
    React uses it to do all computations necessary to render the state of a UI component.
  prefs: []
  type: TYPE_NORMAL
- en: You can find more details of this optimization at [https://facebook.github.io/react/docs/reconciliation.html](https://facebook.github.io/react/docs/reconciliation.html).
  prefs: []
  type: TYPE_NORMAL
- en: React's primary strength, however, is not just Virtual DOM. React is a fantastic
    abstraction that makes composition, unidirectional dataflow, and static modeling
    easier while developing large applications.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running react
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s install react. Earlier, installing and getting react set up on
    your machine needed a bunch of dependencies to be taken care of. However, we will
    use a relatively faster way to get react up and running. We will use `create-react-app`
    to which we can install react without any build configuration. Installation is
    done via `npm` which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are installing the `create-react-app` node module globally. Once `create-react-app`
    is installed, you can set up the directory for your application. Consider the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, open `http://localhost:3000/` to see your app. You should see something
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing and running react](img/image_13_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you open the directory in an editor, you will see several files created
    for you, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing and running react](img/image_13_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this project, `node_modules` are the dependencies required to run this project
    and dependencies of react itself. The important directory is `src`, where the
    source code is kept. For this example, let''s keep only two files-`App.js` and
    `index.js`. The `/public/index.html` file should contain just the root `div`,
    which will be used as a target for our react components. Consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The moment you make this change, you will see the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing and running react](img/image_13_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Beauty of developing with react is that the code changes are live-reloaded,
    and you can get immediate feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, clear off all content of `App.js`, and replace it with the following
    lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to `index.js` and remove the `import ./index.css;` line. Without you
    doing anything, such as restarting server and refreshing browser, you will see
    the modified page on the browser. Consider the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing and running react](img/image_13_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we create a `HelloWorld` react component, a couple of important things
    to notice so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `App.js` and `index.js`, we are importing two libraries necessary to create
    react components. Consider the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're importing `React`, which is the library that allows us to build
    react components. We're also importing `ReactDOM`, which is the library that allows
    us to place our components and work with them in the context of the DOM. Then,
    we're importing the component that we just worked on-the App component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also created our first component in `App.js`. Consider the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a stateless function component. The other way to create a component
    is to create a class component. We can replace the preceding component with the
    following class component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are a bunch of interesting things going on here. First, we are creating
    a class component with the `class` keyword that extends from the superclass `React.Component`.
  prefs: []
  type: TYPE_NORMAL
- en: Our component `App` is a react component class or react component type. A component
    takes in parameters, also called `props`, and returns a hierarchy of views to
    display via the `render` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` method returns a description of what you want to render, and then
    react takes that description and renders it to the screen. In particular, `render`
    returns a react element, which is a lightweight description of what to render.
    Most react developers use a special syntax called JSX, which makes it easier to
    write these structures. The `<div />` syntax is transformed at build time to `React.createElement`(`''div''`).
    The JSX expression, `<h1>Hello World</h1>`, is transformed at build time into
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the class component and stateless function component
    is that the class component can contain a state while the stateless (hence the
    name) function component cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `render` method of the react component is allowed to return only a single
    node. If you do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because you are essentially returning two `React.createElement` functions,
    and that is not valid JavaScript. While this may seem like a deal breaker, this
    is easy to solve. We can wrap our nodes into a parent node and return that parent
    node from the `render` function. We can create a parent `div` and wrap other nodes
    under it. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Components and props
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Components can be conceptually considered as JavaScript functions. They take
    arbitrary number of inputs like normal functions. These inputs are called props.
    To illustrate this, let''s consider the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a normal function and also a valid react component. It takes an input
    called `props` and returns a valid JSX. We can use the `props` inside JSX using
    curly braces and properties such as `name` using a standard object notation. Now
    that `Greet` is a first class react component, let''s use it in the `render()`
    function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We are calling `Greet()` as a normal component and passing `this.props` to
    it. It is required to capitalize your own components. React considers component
    names starting with a lowercase as standard HTML tags and expects custom component
    names to start with a capital letter. As we saw earlier, we can create a class
    component using ES6 class. This component is a subclass of `React.component`.
    An equivalent component to our `Greet` function is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For all practical purposes, we will use this method of creating components.
    We will soon know why.
  prefs: []
  type: TYPE_NORMAL
- en: One important point to note is that a component cannot modify its own props.
    This may seem like a limitation because, in almost all non-trivial applications,
    you will want user interactions where the UI component state is changed in react,
    for example, update date of birth in a form, `props` are read-only but there is
    a much robust mechanism to handle UI updates.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: State is similar to props, but it is private and fully controlled by the component.
    As we saw earlier that both functional and class components are equivalent in
    react, one important distinction is that the state is available only in class
    components. Hence, for all practical purposes, we will use class components.
  prefs: []
  type: TYPE_NORMAL
- en: We can change our existing greeting example to use state, and whenever the state
    changes, we will update our `Greet` component to reflect the changed value.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will set up the state inside our `App.js`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few important things to notice in this example. First, we are calling
    class `constructor` to initialize `this.state`. We also call the base class constructor,
    `super()`, and pass `props` to it. After calling `super()`, we initialize our
    default state by setting `this.state` to an object. For example, we assign a `greeting`
    property with a value here. In the `render` method, we will use this property
    using `{this.state.greeting}`. Having setup our initial state, we can add UI elements
    to update this state. Let''s add an input box, and on change of that input box,
    we will update our state and the `greeting` element. Consider the following lines
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we add an input box and update the state of the component when the `onChange`
    method of the input box is invoked. We use a custom `updateGreeting()` method
    to update the state by calling `this.setState` and updating the property. When
    you run this example, you will notice that as you type something on the text box,
    only the `greeting` element is updated and not the `name`. Take a look at the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![State](img/image_13_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'An important feature of react is the fact that a react component can output
    or render other react components. We''ve got a very simple component here. It
    has a state with a value of text. It''s got an `update` method which will update
    that value of text from an event. What we''ll do is create a new component. This
    will be a stateless function component. We''ll call it widget. It will take in
    `props`. We''ll return this JSX input right here. Consider the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we extract our input element into a stateless function component and
    call it a `Widget`. We pass `props` to this component. Then, we change `onChange`
    to use `props.update`. Now, inside our `render` method, we use the `Widget` component
    and pass a prop `update` that binds the `updateGreeting()` method. Now that `Widget`
    is a component, we can reuse it anywhere in the `Greet` component. We are creating
    three instances of the `Widget`, and when any of the `Widget` is updated, the
    greeting text is updated, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![State](img/image_13_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Life cycle events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you have a bunch of components with several state changes and events, the
    housekeeping becomes important. React provides you with several component life
    cycle hooks to handle life cycle events of components. Understanding the component
    life cycle will enable you to perform certain actions when a component is created
    or destroyed. Furthermore, it gives you the opportunity to decide if a component
    should be updated in the first place, and to react to `props` or state changes
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three phases that the component goes through-mounting, updating,
    and unmouting. For each of these stages, we have hooks. Take a look at the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Life cycle events](img/image_13_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Two methods are called when a component is initially rendered, `getDefaultProps`
    and `getInitialState`, and, as their names suggest, we can set default `props`
    and initial state of a component in these methods.
  prefs: []
  type: TYPE_NORMAL
- en: The `componentWillMount` is called before the `render` method is executed. We
    already know `render` to be the place where we return the component to be rendered.
    As soon as the `render` method finishes, the `componentDidMount` method is invoked.
    You can access DOM in this method, and it is recommended to perform any DOM interactions
    in this method.
  prefs: []
  type: TYPE_NORMAL
- en: State changes invoke a few methods. The `shouldComponentUpdate` method is invoked
    before the `render` method, and it lets us decide if we should allow rerendering
    or skip it. This method is never called on the initial rendering. The `componentWillUpdate`
    method gets called immediately once the `shouldComponentUpdate` method returns
    `true`. The `componentDidUpdate` method is rendered after `render` finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Any change to the `props` object triggers similar methods as a state change.
    One additional method called is `componentWillReceiveProps`; it is called only
    when the `props` have changed, and it is not initial rendering. You can update
    state based on new and old props in this method.
  prefs: []
  type: TYPE_NORMAL
- en: When a component is removed from DOM, `componentWillUnmount` is called. This
    is a useful method to perform cleanups.
  prefs: []
  type: TYPE_NORMAL
- en: Great thing about react is that when you start using it, the framework feels
    very natural to you. There are very few moving parts you will need to learn, and
    the abstraction is just right.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was aimed at some of the important new ideas that are gaining a
    lot of prominence lately. Both reactive programming and react can significantly
    boost programmer productivity. React is definitely one of the most important emerging
    technologies backed by the likes of Facebook and Netflix.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter was intended to give you an introduction to both these technologies
    and help you start exploring them in more detail.
  prefs: []
  type: TYPE_NORMAL
