["```js\n\nlet node = new TransformNode(\"cargoNode\", this.scene, \n    true);\nnode.position = this.mesh.position.clone();\nnode.rotationQuaternion = this.mesh.rotationQuaternion?.\n    clone() ?? \n    Quaternion.FromEulerVector(this.rotation.clone());\nnode.scaling = this.lastVelocity.clone();\nnode.velocity = this.lastVelocity.clone();\nnode.gravity = this.lastGravity.clone();\nnode.time = this.timeInTransit;\nnode.encounterZone = this.encounterManager.\n    currentZone?.name;\n```", "```js\n\nget currentZone() {\n    let zidx = this.encounterZones.length - this.inAndOut;\n    return this.encounterZones[zidx]?.zone;\n}\n```", "```js\n\nasteroidBelt: {\n    id: \"asteroid_belt\",\n    name: \"Asteroid Belt\",\n    innerBoundary: 1000,\n    outerBoundary: 1700,\n    encounterRate: 0.2,\n    colorCode: \"#ff0000\",\n    encounters: [\n        { id: 'rock_hazard', name: 'Rock Hazard', image\n            hazard_icon, probability: 0.90 },\n        { name: '', id: 'no_encounter', probability: 0.1, \n            image: '' }\n    ]\n}\n```", "```js\n\nencounters: [\n            { id: 'rock_hazard', name: 'Rock Hazard',\n                 image: hazard_icon, probability: 0.90 },\n            { name: '', id: 'no_encounter', probability: \n                0.1, image: '' }\n        ]\n```", "```js\n\nvar total = 0;\ndefinition.encounters.forEach((e, i) => {\n    total += e.probability;\n    this.encounterTable.push(e);\n});\n```", "```js\n\nthis.cumulativeDistribution[0] = this.encounterTable[0].\n    Probability / total;\nfor (var I = 1; i < definition.encounters.length; i++) {\n    this.cumulativeDistribution[i] = \n        this.cumulativeDistribution[i - 1] + \n            definition.encounters[i].probability / total;\n}\n```", "```js\n\nconst encounterProbability = this.encounterRate * deltaTime;\nif (Math.random() < encounterProbability) {\n    let encounter = this.getEncounter();\n    console.log('encounter ' + encounter?.name);\n    this.onEncounterObservable.notifyObservers(encounter);\n} \n```", "```js\n\nfor (var i = 0; i < this.cumulativeDistribution.length && (diceRoll > this.cumulativeDistribution[i]); i++) {};  \n```", "```js\n\nconst cargoData = this.cargo.lastFlightPoint;\nconst idx = this.encounterEvents.push({ encounter,\n    cargoData });\nthis.onNewEncounterObservable.notifyObservers(idx - 1);\n```", "```js\n\nconst encounter = evt.encounter;\nlet panel = new Rectangle(\"panel-\" + encounter.name);\nlet image = new Image(\"image-\" + encounter.name, \n    encounter.image);\nimage.alpha = 0.68;\npanel.addControl(image);\npanel.thickness = 0;\nthis.gui.addControl(panel);\nthis.encounterPanels.push(panel);\npanel.linkWithMesh(evt.cargoData);\n```", "```js\n\nthis.encounterManager.onNewEncounterObservable.add(enc => \n        this.soundManager.sound(\"encounter\").play());\n```", "```js\n\nlet animationGroup = new AnimationGroup(\"shrinkAnimationGroup-\"+ encounter.name, \n    this.scene);\nanimationGroup.addTargetedAnimation(panelShrinkX, panel);\nanimationGroup.addTargetedAnimation(panelShrinkY, panel);\nanimationGroup.start(false, 1.0, 0, 180, true);   \n```", "```js\n\nthis.encounterPanels.forEach(panel => {\n    panel.children.forEach(child => child.dispose());\n    panel.dispose();\n});\n```"]