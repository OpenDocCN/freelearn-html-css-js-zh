<html><head></head><body>
        

                            
                    <h1 class="header-title">Scoping Variables with Different Patterns</h1>
                
            
            
                
<p>In this chapter, we see the most basic concept that is a variable. Knowing what is the exact type, from a primitive to an object, is essential for accessing specific members. Scoping down the exact type at runtime and design time is crucial, to have consistency between the two environments and to have feedback about what is possible and what is not. The variety of configurations among the different types of variable requires many different patterns that are covered in this chapter.</p>
<p>This chapter will cover the following:</p>
<ul>
<li class="h1">How to compare at runtime and design time with <kbd>typeof</kbd></li>
<li class="h1">How to check with a guarantee for <kbd>undefined</kbd> and <kbd>null</kbd></li>
<li class="h1">Do I need to check every possibility of a union to have the right type?</li>
<li class="h1">What is the limitation of <kbd>instanceof</kbd>?</li>
<li class="h1">Why a discriminator is essential for type identification</li>
<li class="h1">Why using <kbd>user</kbd> defined <kbd>guard</kbd></li>
<li class="h1">How and why to cast</li>
<li class="h1">What is a type assertion?</li>
<li class="h1">How to compare classes</li>
<li class="h1">How to narrow type for function with a union in signatures</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Comparing at runtime and design time with typeof</h1>
                
            
            
                
<p>TypeScript brings type in JavaScript, but this is mostly true at design type. TypeScript during compilation removes all the type. This is the reason that the code produced is purely JavaScript and does not contain any trace of interfaces or types. The purity of respect for JavaScript makes type comparison harder because it cannot rely on the name of the type to perform a type check. However, we can use all JavaScript's tricks to know whether a value is from a different type. The first feature answers the main question of this section about how to compare runtime and design type. The use of the JavaScript <kbd>typeof</kbd> operator that is present in JavaScript is also working the same way in TypeScript. The <kbd>typeof</kbd> operator returns the type of a primitive, or it returns <kbd>object</kbd>.</p>
<p>The usage is simple: call <kbd>typeof</kbd> followed by the variable that you want to compare it with. Most of the time, you will compare it to the name of the type that requires being written in a string:</p>
<pre>const a = "test";<br/>let b: number = 2;<br/>const c: boolean = true;<br/>let d: number | string = "test";<br/>console.log(typeof a); // string<br/>console.log(typeof b); // number<br/>console.log(typeof c); // boolean<br/>console.log(typeof d); // string</pre>
<p>The <kbd>typeof</kbd> operator is especially used when having a union type where an object can be from many primitives. In fact, it can be used even with a union that has a complex object (interface or type) because <kbd>typeof</kbd> returns <kbd>object</kbd>:</p>
<pre>const e: number | string | { complex: string, obj: number } = { complex: "c", obj: 1 };<br/>console.log(typeof e); // object</pre>
<p>To know which type of object the object is will require the use of other mechanisms that we will cover in this chapter. Before moving on, even if <kbd>typeOf</kbd> is comparable to a string, the result of the operation can be set a type:</p>
<pre>let f: number = 2;<br/>if (typeof f === "number") {<br/>console.log("This is for sure a number");<br/>}<br/>type MyNewType = typeof f;</pre>
<p class="mce-root"/>
<p>Note that <kbd>typeOf</kbd> works on primitive types but behaves strangely with <kbd>undefined</kbd> or <kbd>null</kbd>. However, <kbd>undefined</kbd> will return <kbd>undefined</kbd> and null will return <kbd>object</kbd>. The best approach to check for <kbd>undefined</kbd> or <kbd>null</kbd> is to not use <kbd>typeof</kbd>:</p>
<pre>let g: number | undefined = undefined;<br/>let h: number | undefined | null = null;<br/>console.log(typeof g);<br/>console.log(typeof h);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Differentiating undefined from null</h1>
                
            
            
                
<p>While  <kbd>typeof</kbd> returns the <kbd>undefined</kbd> string when performing against an undefined type, it returns <kbd>object</kbd> against <kbd>null</kbd>. This inconsistency becomes an issue when you forget which case can use <kbd>typeof</kbd> by performing the wrong operation for the wrong <kbd>no type</kbd> type. However, <kbd>undefined</kbd> and <kbd>null</kbd> do not require the use of <kbd>typeof</kbd> to do a type check. It is possible to compare directly the variable against <kbd>undefined</kbd> or  <kbd>null</kbd>:</p>
<pre>let g: number | undefined = undefined;<br/>let h: number | undefined | null = null;<br/>console.log(typeof g); // undefined<br/>console.log(typeof h); // object<br/>console.log(g === undefined); // true<br/>console.log(g === null); // false<br/>console.log(h === undefined); // false<br/>console.log(h === null); // true</pre>
<p>In a situation where a variable can be undefined or null or any other primitive, the best way is to check for the nullability of the type and carry on with further type comparisons.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting the type of element in a union </h1>
                
            
            
                
<p>The TypeScript inference system gets better with every version. In the most recent version, TypeScript uses a control flow to find out in a smart way the type depending on how the code is written. If a check is performed in one code path, TypeScript knows that for the closure of the type validation that the type is as checked. If an <em>else</em> code path exists to a type check, it knows that it is the reverse of the type comparison.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The following code example shows that depending on the position of the execution the type changes. It starts as a number or undefined. The value check against <kbd>undefined</kbd> makes the value narrow down to an undefined value for the scope of the <kbd>if</kbd>. The <kbd>else</kbd> can only be everything else than undefined in the union. In that particular case, it can only be a number. After <kbd>if</kbd> and <kbd>else</kbd>, TypeScript cannot know what the type is; thus, the value is back to both potential types:</p>
<pre>function myFunction(value: number | undefined): void {<br/> console.log("Value is number or undefined");<br/> if (value === undefined) {<br/> console.log("Value is undefined");<br/> } else {<br/> console.log("Value is NOT undefined, hence a number");<br/> }<br/> console.log("Value is number or undefined");<br/>}</pre>
<p>TypeScript understands the code flow. It is smart to freeze the type from a particular type check. In the following code example, a value equals to undefined force the function to return. It means that passing that point, there is no way to have an undefined value. The subtraction of <kbd>undefined</kbd> in the set of potential values diminishes the possibility to only a number:</p>
<pre>function myFunction2(value: number | undefined): void {<br/> console.log("Value is number or undefined");<br/> if (value === undefined) {<br/> return;<br/> }<br/> console.log("Value is NOT undefined, hence a number");<br/>}<br/><br/></pre>
<p>TypeScript narrows down the union from your conditional check for more than a primitive. You can also use this behavior with a discriminator and a user-defined type guard, which are two patterns that we will see in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The limitations of instanceof</h1>
                
            
            
                
<p>Similar to <kbd>typeof</kbd>, there is in JavaScript the <kbd>instanceof</kbd> operator. The limitation of <kbd>instanceof</kbd> is that it can be only used on a type with a prototype chain: a class. Like <kbd>typeof</kbd>, <kbd>instanceof</kbd> works at design and runtime and is native to JavaScript:</p>
<pre>class MyClass1 {<br/> member1: string = "default";<br/> member2: number = 123;<br/>}<br/>class MyClass2 {<br/> member1: string = "default";<br/> member2: number = 123;<br/>}<br/>const a = new MyClass1();<br/>const b = new MyClass2();<br/>if (a instanceof MyClass1) {<br/> console.log("a === MyClass1");<br/>}<br/>if (b instanceof MyClass2) {<br/> console.log("b === MyClass2");<br/>}</pre>
<p>Contrary to <kbd>typeof</kbd>, the result of <kbd>instanceof</kbd> is not a string and cannot be used in the <kbd>console.log</kbd> function; it is possible to set the value in a type or in a variable. It can only be used for comparison purposes. The next example does not compile:</p>
<pre>type MyType = instanceOf MyClass1;</pre>
<p>The <kbd>instanceOf</kbd> limitations are beyond just being focused on class. The <kbd>instanceOf</kbd> operator also does not distinguish which class is exactly used in the situation of inheritance. In the next code example, the variable <kbd> c</kbd> is of type <kbd>MyClass3</kbd>, which inherits <kbd>MyClass2</kbd>.  <kbd>InstanceOf</kbd> identifies the variable to be of both types. In the following code, both <kbd>if</kbd> are entered:</p>
<pre>class MyClass3 extends MyClass2 {<br/> member3: boolean = true;<br/>}<br/>const c = new MyClass3();<br/>if (c instanceof MyClass2) {<br/> console.log("c === MyClass2");<br/>}<br/>if (c instanceof MyClass3) {<br/> console.log("c === MyClass3");<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Using of a discriminator for type identification</h1>
                
            
            
                
<p>TypeScript is a structural language, which means that it does not rely on the name of the type like a nominal language. JavaScript doesn't have a type; hence, it is a structural language. C# or Java are both nominal languages. The difference is important because it means that TypeScript doesn't check for the name of the interface or type to take any decision. This makes sense when we think about how TypeScript compiles the code. During compilation, all types are stripped out of the code to produce a clean JavaScript. This symbiosis is in respect to JavaScript; thus, giving TypeScript the honor of being a superset of JavaScript. However, at runtime for TypeScript and design time for JavaScript, we need to know which type we are manipulating. In structural code, the approach is to analyze, compare, and infer type by looking at the structure. If specific members exist, it gives a hint of what we are working on. The following code example shows two identical interfaces with the same body, a type with the same structure as well, and the first variable with an anonymous type. The object can be of each type because it respects the contract of each one:</p>
<pre>interface Type1 {<br/> m1: string;<br/>}<br/>interface Type2 {<br/> m1: string;<br/>}<br/>type Type3 = { m1: string };<br/>const v0 = { m1: "AllTheSame" };<br/>const v1: Type1 = v0;<br/>const v2: Type2 = v0;<br/>const v3: Type3 = v0;</pre>
<p>In the previous example, the way to make every type different is with the concept of a discriminator. A <strong>discriminator</strong> is a member with a shared name between a group of a common type that needs to be distinguished. This group is often a union. The idea is to have a unique <kbd>string literal</kbd> per type with the same name. Having <kbd>string literal</kbd> as a type member requires the implementation to implement the same <kbd>string</kbd>. It means that each instance of a specific type will have the same <kbd>string</kbd>. TypeScript can then infer the type by looking at <kbd>string literal</kbd>. The following code example applies this principle. The common member is named <kbd>kind</kbd><em>,</em> and each interface and type has a unique one. The anonymous type tries to impersonate <kbd>Type1</kbd> but fails because the type inferred is a <kbd>string</kbd> and not a <kbd>string literal</kbd>:</p>
<pre>interface Type1 {<br/> kind: "Type1";<br/> m1: string;<br/>}<br/><br/>interface Type2 {<br/> kind: "Type2";<br/> m1: string;<br/>}<br/><br/>type Type3 = { kind: "Type3"; m1: string };<br/>const v0 = { kind: "Type1", m1: "AllTheSame" };<br/>const v1: Type1 = v0; // Does not compile<br/>const v2: Type2 = v0; // Does not compile<br/>const v3: Type3 = v0; // Does not compile</pre>
<p>The discriminator proves to be useful not only for avoid cross type but also for narrowing down a type. In a union of many types, when comparing against the discriminator, TypeScript will know exactly the type and hence the scope of the comparison. The following code allows reducing to the exact type. In that particular case, the m1 member is a member that is in all three types and thus does not require to be narrowed down to a single type to be used:</p>
<pre class="mce-root">function threeLogic(param: Type1 | Type2 | Type3): void {<br/> switch (param.kind) {<br/>  case "Type1":<br/>   console.log(param.m1); // param is type Type1<br/>  break;<br/>  case "Type2":<br/>   console.log(param.m1); // param is type Type2<br/>  break;<br/>  case "Type3":<br/>   console.log(param.m1); // param is type Type3<br/>  break;<br/> }<br/>}</pre>
<p>If we have an interface with completely different members, the distinction is primordial to have access to a member that is unique to one interface or another. The following code narrows down the interface, allowing it to use a member from the proper type, depending on the comparison:</p>
<pre>interface Alpha { kind: "Alpha", alpha: string }<br/>interface Beta { kind: "Beta", beta: string }<br/><br/>function AlphaBeta(param: Alpha | Beta): void {<br/> switch (param.kind) {<br/>  case "Alpha":<br/>   console.log(param.alpha);<br/>  break;<br/>  case "Beta":<br/>   console.log(param.beta);<br/>  break;<br/> }<br/>}</pre>
<p>The usage of a string literal as a discriminator is often named the <strong>literal type guard</strong> or the <strong>tagged</strong> <strong>union</strong>. It is powerful for functional programming and provides a quick way to identify a type without having to develop specific conditions as needed in other techniques such as a user-defined guard.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The user-defined guard pattern</h1>
                
            
            
                
<p>Knowing the type of an interface or type can be challenging. We saw in this chapter the use of a discriminator. However, there is a drawback with the commonly named <kbd>string literal</kbd> approach, which is with inheritance and intersection. The following code does not compile:</p>
<pre>interface Type1 extends Type2 {<br/>  kind: "Type1"; // Does not compile, expect “Type2”<br/>  m1: number;<br/>}<br/><br/>interface Type2 {<br/>  kind: "Type2";<br/>  m2: string;<br/>}</pre>
<p>The same is true with an intersection:</p>
<pre>interface Type2 {<br/> kind: "Type2";<br/> m2: string;<br/>}<br/><br/>interface Type3 {<br/> kind: "Type3";<br/> m3: string;<br/>}<br/><br/>type Type4 = Type2 &amp; Type3;<br/>const type4: Type4 = { kind: ???, m2: "1", m3: "2" }; // Does not compile</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The last code example creates for the member kind a type that requires to be both <kbd>strings literal</kbd> at the same time make it impossible to fulfill and not practical. With that information to hand, we can see that the discriminator pattern works well when inheritance is avoided as well as intersecting. The idea is to use a custom user-defined guard per type. This can be cumbersome to create but will ensure you the type at design and runtime. The idea is to check for fields and see whether they are defined. This technique works well for a type with no optional field, since you need to check whether fields exist. As the author of the function and the type, you do not need to check every field. You should know which field is enough to identify the type. In the following code, both types exist, and one type extends the other. Two type user-defined guards are created—one for each interface:</p>
<pre class="mce-root"><br/>interface Type1 extends Type2 {<br/> m1: number;<br/>}<br/><br/>interface Type2 {<br/> m2: string;<br/> m3: number;<br/>}<br/><br/>function checkInterfaceICheck1(obj: any): obj is Type1 {<br/> const type1WithMaybeManyUndefinedMembers = (obj as Type1);<br/> return type1WithMaybeManyUndefinedMembers.m1 !== undefined<br/> &amp;&amp; type1WithMaybeManyUndefinedMembers.m2 !== undefined<br/> &amp;&amp; type1WithMaybeManyUndefinedMembers.m3 !== undefined<br/>}<br/><br/>function checkInterfaceICheck2(obj: any): obj is Type2 {<br/> const type1WithMaybeManyUndefinedMembers = (obj as Type2);<br/> return type1WithMaybeManyUndefinedMembers.m2 !== undefined<br/> &amp;&amp; type1WithMaybeManyUndefinedMembers.m3 !== undefined;<br/>}<br/><br/>function codeWithUnionParameter(obj: Type1 | Type2): void {<br/> if (checkInterfaceICheck1(obj)) {<br/> console.log("Type1", obj.m1);<br/> }<br/><br/> if (checkInterfaceICheck2(obj)) {<br/> console.log("Type2", obj.m2);<br/> }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The function must know which of the two types are passed, and it checks by using the user-defined guard. The return type of the defined guard is unique. It uses the name of the parameter followed by <em>is</em> and the type we are expecting if the value is <kbd>true</kbd>. It allows to automatically narrow down to the expected type by comparing the structure. If everything is present and defined, it returns <kbd>true</kbd>, but the function will not return an actual <kbd>boolean</kbd> value. It returns the object cast to the type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The reason to cast a type</h1>
                
            
            
                
<p><strong>Casting</strong> is the act of taking one type and transposing it onto something else. It is dangerous and should be used seldomly. The reason casting can have side effects is that you are taking manual control of coercing a variable into another type. The type may be creating an incompatible and unexpected result. A cast is possible for any kind of variable, from a primitive to a more-complex object.</p>
<p>The most basic cast scenario is getting a value that is from <kbd>any</kbd> and to type it. The following code shows a number that is set in <kbd>any</kbd> and then cast to a variable of type number. You can notice two different ways to cast. One with the smaller and bigger symbol <kbd>&lt;&gt;</kbd> and one with <kbd>as</kbd>. The latter is the recommended way because it does not confuse code using TSX syntax, which uses the symbols for a component:</p>
<pre>let something: any = 1;<br/>let variable1: number;<br/>variable1 = &lt;number&gt;something;<br/>variable1 = something as number;</pre>
<p>The previous code works because the cast went from <kbd>any</kbd> to <kbd>number</kbd>. Casting a number to a string does not work. The reason is that cast only works if you are working with a subtype. Furthermore, <kbd>any</kbd> is a subtype of everything, which allows casting to every type. However, the following code does not compile because <kbd>variable1</kbd> is a number that is cast to a string:</p>
<pre>let variable1: number = 1;<br/>let variable2: string = variable1 as string;</pre>
<p>TypeScript is also present to avoid casting between objects that miss fields. In the following code, both types cannot be cast to each other. TypeScript cannot find <kbd>m2</kbd> in <kbd>Type1</kbd>, and the second cast cannot find <kbd>m1</kbd> in the following code:</p>
<pre>interface Type1 {<br/> m1: number;<br/>}<br/><br/>interface Type2 {<br/> m2: string;<br/> m3: number;<br/>}<br/><br/>let t1: Type1 = { m1: 123 };<br/>let t2: Type2 = t1 as Type2; // Property 'm2' is missing in type 'Type1'<br/>let t3: Type2 = { m2: "2", m3: 3 };<br/>let t4: Type1 = t2 as Type1;// Property 'm1' is missing in type 'Type2'</pre>
<p>However, adding <kbd>m1</kbd> to <kbd>Type2</kbd> changes the whole situation and allows casting in both sides without any compilation errors. The reason is that <kbd>Type1</kbd> is a subtype of <kbd>Type2</kbd> by its structure, which is what matters in TypeScript:</p>
<pre>interface Type1 {<br/> m1: number;<br/>}<br/><br/>interface Type2 {<br/> m1: number;<br/> m2: string;<br/> m3: number;<br/>}<br/><br/>let t1: Type1 = { m1: 123 };<br/>let t2: Type2 = t1 as Type2;<br/>let t3: Type2 = { m1: 1, m2: "2", m3: 3 };<br/>let t4: Type1 = t2 as Type1;</pre>
<p>What is interesting about the last code is that the last cast is useless. The reason is that Type2 has all the structure of <kbd>Type1</kbd>, and <kbd>Type1</kbd> is a subtype of <kbd>Type2</kbd>. It means that they are structurally equivalent at a minimum point in their structure:</p>
<pre>let t3: Type2 = { m1: 1, m2: "2", m3: 3 };<br/>let t4: Type1 = t2;</pre>
<p>The casting is required for <kbd>t1</kbd> to <kbd>Type2</kbd> because <kbd>t1</kbd> doesn't fulfil the contract (it misses <kbd>m2</kbd> and <kbd>m3</kbd>). The cast produces a <kbd>false</kbd> <kbd>Type2</kbd> because <kbd>m2</kbd> and <kbd>m3</kbd> are not there, which means they are undefined. <kbd>Type2</kbd> does not have any undefined type for these members, which makes it problematic for future usage, since TypeScript will allow <kbd>m2</kbd> to use any string's function while this one is undefined. The casting comes with great responsibilities, and the tampering type will make TypeScript unable to perform safe validation.</p>
<p>The slippery slope is steeper when a cast is affecting an object that is <kbd>any</kbd>. It's hard to avoid all  <kbd>any</kbd>. For example, when data is crossing between systems. An Ajax request returns a JSON object, which is an inevitability, as <kbd>any</kbd>. The response is not typed, and to introduce the value into TypeScript, a crucial cast is performed.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mceNonEditable"/>
<p>A bad pattern is to cast to <kbd>any</kbd> and then to the desired type. This is a way to short-circuit TypeScript, finding that the cast is not a valid one. Everything can be cast to <kbd>any</kbd> and from any cast to everything else:</p>
<pre>let a: number = 1;<br/>let b: string = "2";<br/>a = b as number; // Doesn't compile<br/>a = b as any as number; //Shortcircuit with any</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">What is a type assertion?</h1>
                
            
            
                
<p>There are scenarios where you know that a type is not undefined or null but that TypeScript will hint that it might be. When this happens, you can perform a check against <kbd>undefined</kbd> or <kbd>null</kbd> and within the closure of the condition will be a guarantee that the type is not nullable. However, three scenarios can benefit from having a shorter syntax.</p>
<p>The first scenario is with a deep-nesting object. In that case, you may have several levels of nullable fields and if you are sure that they are not undefined or null, this will be great to avoid having a nested <kbd>if</kbd> structure:</p>
<pre>interface T1 {<br/> myNumber: number | undefined;<br/>}<br/><br/>interface T2 {<br/> t1: T1 | undefined;<br/>}<br/><br/>interface T3 {<br/> t2: T2 | undefined;<br/>}<br/><br/>const myObject: T3 | undefined = {<br/> t2: {<br/> t1: {<br/>  myNumber: 1<br/> }<br/> }<br/>}<br/><br/>if (myObject !== undefined) {<br/> if (myObject.t2 !== undefined) {<br/>  if (myObject.t2.t1 !== undefined) {<br/>   if (myObject.t2.t1.myNumber !== undefined) {<br/>    console.log("My number is :", myObject.t2.t1.myNumber);<br/>   }<br/>  }<br/> }<br/>}</pre>
<p>The conditional check is the safest way to ensure that nothing is undefined. However, in some cases, the check may have been made prior to accessing the data, but an access to the value is needed outside the scope of the check, which makes TypeScript nervous about <kbd>if</kbd> meanwhile, the state has changed. That would be the case if we tried to access <kbd>myNumber</kbd> right after the previous code. This is where <kbd>assertion</kbd> type comes into play. A <kbd>assertion</kbd> type is the bang operator, or exclamation point, after a member that specifies that the member is not null or undefined. You are asserting that this is the case and take the responsibility to <em>un-undefined</em> or to <em>un-nullable</em> to field.</p>
<p>It means that you can access the member by using a single line:</p>
<pre>console.log("My number is :", myObject!.t2!.t1!.myNumber);</pre>
<p>It is crucial to understand that this can lead to a potential runtime error if used at the wrong time. For some reason, any nullable field can become nullable if applied at the wrong time or place. There is no guarantee that the execution will succeed but will soothe TypeScript error saying that you are accessing a nullable field without narrowing it down to the type.</p>
<p>The second case of using type <kbd>assertion</kbd> is when you are defining a field in a class. If TypeScript is set to have the compilation strictness to avoid an uninitialized field, then you will have an error when defining a field and not specifying a value at the declaration or in the constructor. This is a great validation, but, in some rare cases, the value may come later in an <kbd>initialize</kbd> function. In that case, you can assert the class's field to say that you are taking care of the value:</p>
<pre>class LateInitialization {<br/> m1!: number; // Not initialized (use type assertion)<br/> constructor() {<br/>   // No initializing here<br/> }<br/> public init(): void {<br/>   this.m1 = 1;<br/> }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Once again, this should be used with parsimony, because it can bring some issues. For example, you can now access the member and use it without TypeScript validating that the value was assigned before accessing the value:</p>
<pre>constructor() {<br/>   this.m1 + 1; // This will fail<br/>}</pre>
<p>This might seem like a trifle, since you know that you will not do such a thing. But it can be less obvious. A case of error is that you are accessing the member from another public function that might be called before the <kbd>init</kbd> function causing any usage of the variable to be undefined. Type asserting forces TypeScript to close its eyes about uninitialized value.</p>
<p>The last scenario is also dangerous to use and should be coded only with a lot of care. You can at any time use the exclamation point to erase the nullability. It means that it works with a simple variable as well. The following code declares a variable of type string or undefined. It sets its value using a function that is immediately invoked. The function has a return type of also <kbd>string | undefined</kbd>. TypeScript concludes that this function may return one or both types, and hence could legally return something undefined. However, we know that it is not the case, and hence can use the exclamation point to remove the undefined possibility and use the string's functions:</p>
<pre>let var1: string | undefined;<br/>var1 = ((): string | undefined =&gt; "Not undefined but type is still both")();<br/>console.log(var1!.substr(0, 5));</pre>
<p>Again, this is dangerous and a better way around it could be employed. The first thing is to avoid having a union with <kbd>undefined</kbd> or <kbd>null</kbd>. If this is out of your control, avoiding functions such as one of the last code examples that aslo return undefined. The same code with the return type of string would have solved the problem gracefully.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Comparing classes</h1>
                
            
            
                
<p>Classes are different than interfaces, types, or primitives. They have a prototype chain and obey different rules. For example, two different classes can be interchangeable if they have the same structure. The following classes, <kbd>C1</kbd> and <kbd>C2</kbd>, are identical in terms of structure and can be swapped in the function that requires <kbd>C1</kbd>. You can even instantiate <kbd>C2</kbd> in a <kbd>C1</kbd> variable:</p>
<pre>class C1 {<br/> public a: number = 1;<br/> public funct(): void { }<br/>}<br/><br/>class C2 {<br/> public a: number = 1;<br/> public funct(): void { }<br/>}<br/><br/>const c1: C1 = new C1();<br/>const c2: C2 = new C2();<br/>const c12: C1 = new C2();<br/><br/>function executeClass1(c1: C1): void {<br/> c1.funct();<br/>}<br/><br/>executeClass1(c1);<br/>executeClass1(c2);<br/>executeClass1(c12);</pre>
<p>If we add in the <kbd>private</kbd> field in <kbd>C1</kbd> or <kbd>C2</kbd>, then it won't be the same:</p>
<pre>class C1 {<br/> public a: number = 1;<br/> public funct(): void { }<br/> private p: string = "p";<br/>}<br/><br/>class C2 {<br/> public a: number = 1;<br/> public funct(): void { }<br/> private p: string = "p";<br/>}<br/><br/>const c1: C1 = new C1();<br/>const c2: C2 = new C2();<br/>const c12: C1 = new C2(); // Does not compile<br/><br/>function executeClass1(c1: C1): void {<br/> c1.funct();<br/>}<br/><br/>executeClass1(c1);<br/>executeClass1(c2); // Does not compile<br/>executeClass1(c12);</pre>
<p>The <kbd>private</kbd> and <kbd>protected</kbd> fields make each class unique. TypeScript continues to compare the structure but does make an exception with regard to these two visibility modifiers.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The reason is when using inheritance and assigning a child class to a base type it must be from the same hierarchy and not something with a similar shape that is not from the same hierarchy. The following code shows how without a <kbd>private</kbd> or a <kbd>protected</kbd> field the base class can be substituted by a single class that has the structure of the child and the base:</p>
<pre>class B1 {<br/>  public baseFunct(): void { }<br/>}<br/><br/>class C1 extends B1 {<br/>  public a: number = 1;<br/>  public funct(): void { }<br/>}<br/><br/>class C2 {<br/>  public a: number = 1;<br/>  public funct(): void { }<br/>  public baseFunct(): void { }<br/>}<br/><br/>const c1: B1 = new C1();<br/>const c2: B1 = new C2();</pre>
<p>However, adding a <kbd>private</kbd> field at the base class <kbd>B1</kbd> and the same in <kbd>C2</kbd> makes them different, which stops <kbd>C2</kbd> being addressable to the variable <kbd>C2</kbd> of type <kbd>B1</kbd>:</p>
<pre>class B1 {<br/> private name: string = "b1";<br/> public baseFunct(): void { }<br/>}<br/><br/>class C1 extends B1 {<br/> public a: number = 1;<br/> public funct(): void { }<br/>}<br/><br/>class C2 {<br/> private name: string = "c2";<br/> public a: number = 1;<br/> public funct(): void { }<br/> public baseFunct(): void { }<br/>}<br/><br/>const c1: B1 = new C1();<br/>const c2: B1 = new C2(); // Does not compile</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Narrowing type for function with a union in signatures</h1>
                
            
            
                
<p>Complex functions can be hard to work with. This is often the case with a function with one or many parameters of different types, which can also return one or several types. TypeScript allows stitching any type together:</p>
<pre>function f(p: number | string): boolean | Date {<br/> if (typeof p === "number") {<br/>  return true;<br/> }<br/> return new Date();<br/>}<br/><br/>const r1: boolean = f(1); // Does not compile<br/>const r2: Date = f("string"); // Does not compile</pre>
<p>In the previous code, the code is not compiling. The reason is because the function returns a union that must narrow down. However, if we add the overloads above the function, we can match the union to one particular set of parameters to a single return type. The previous code was not compiling because it was returning a union into a single type variable. With a change specifying that when a parameter is a number, then the function returns <kbd>boolean</kbd>, and when it is a string it returns a date, no casting or anything is required:</p>
<pre>function f(p: number): boolean;<br/>function f(p: string): Date;<br/>function f(p: number | string): boolean | Date {<br/> if (typeof p === "number") {<br/>  return true;<br/> }<br/> return new Date();<br/>}<br/><br/>const r1: boolean = f(1);<br/>const r2: Date = f("string");</pre>
<p>This is beyond just associating a single parameter to a return type. For example, in the following code, we make sure we can only send all number parameters together or all strings together:</p>
<pre>function g(p: number, q: number): boolean;<br/>function g(p: string, q: string): Date;<br/>function g(p: number | string, q: number | string): void {<br/>}<br/>g(1, "123"); // Doesn't compile<br/>g(1, 2);<br/>g("1", "2");</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered how to have a better sense of the type of a variable. Not only does it help to take decisions, but it narrows down to a single type, giving the possibility to access specific members that are specific to a particular type.</p>
<p>In the next chapter, we will see how to generalize a type by using a generic variable. Generic variables increase the reusability of objects and variables in your code, which reduces the necessity of creating trivial types.</p>


            

            
        
    </body></html>