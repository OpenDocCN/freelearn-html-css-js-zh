<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. A Robust Movie API</h1></div></div></div><p>We will build a movie API that allows you to add actor and movie information to a database and connect actors with movies, and vice versa. This will make use of the information introduced in <a class="link" href="ch01.html" title="Chapter 1. Building a Basic Express Site">Chapter 1</a>, <em>Building a Basic Express Site</em>, and give you a hands-on feel for what Express.js offers. We will cover the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Folder structure and organization</li><li class="listitem" style="list-style-type: disc">Responding to CRUD operations</li><li class="listitem" style="list-style-type: disc">Object modeling with Mongoose</li><li class="listitem" style="list-style-type: disc">Generating unique IDs</li><li class="listitem" style="list-style-type: disc">Testing</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Folder structure and organization</h1></div></div></div><p>Folder<a id="id58" class="indexterm"/> structure is a very controversial topic. Though there are many clean ways to structure your project, we will use the following code for the remainder of our chapters:</p><div><pre class="programlisting">chapter2
├── app.js
├── package.json ├── node_modules
│└── npm package folders ├── src
│├── lib
│├── models
│├── routes
└── test</pre></div><p>Let's take a look this at in detail:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">app.js</code>: It is conventional to have the main <code class="literal">app.js</code> file in the root directory. The <code class="literal">app.js</code> is the entry point of our application and will be used to launch the server.</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.json:</code> As with any Node.js app, we have <code class="literal">package.json</code> in the root folder specifying our application name and version as well as all of our npm dependencies.</li><li class="listitem" style="list-style-type: disc"><code class="literal">node_modules:</code> The <code class="literal">node_modules</code> folder and its content are generated via npm<a id="id59" class="indexterm"/> installation and should usually be ignored in your version control of choice because it depends on the platform the app runs on. Having said that, according to the npm FAQ, it is probably better to commit the <code class="literal">node_modules</code> folder as well.<div><div><h3 class="title"><a id="note10"/>Note</h3><p>Check <code class="literal">node_modules</code> into git for things you deploy, such as websites and apps. Do not check <code class="literal">node_modules</code> into git for libraries and modules intended to be reused.</p><p>Refer to the following article to read more about the rationale behind this:</p><p>
<code class="literal">http://www.futurealoof.com/posts/nodemodules-in-git.html</code>
</p></div></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">src</code>: The <code class="literal">src</code> folder contains all the logic of the application.</li><li class="listitem" style="list-style-type: disc"><code class="literal">lib</code>: Within the <code class="literal">src</code> folder, we have the <code class="literal">lib</code> folder, which contains the core of the application. This includes the middleware, routes, and creating the database connection.</li><li class="listitem" style="list-style-type: disc"><code class="literal">models</code>: The <code class="literal">models</code> folder contains our <code class="literal">mongoose</code> models, which defines the structure and logic of the models we want to manipulate and save.</li><li class="listitem" style="list-style-type: disc"><code class="literal">routes</code>: The <code class="literal">routes</code> folder contains the code for all the endpoints the API is able to serve.</li><li class="listitem" style="list-style-type: disc"><code class="literal">test</code>: The <code class="literal">test</code> folder will contain our functional tests using Mocha as well as two other node modules, <code class="literal">should</code> and <code class="literal">supertest</code>, to make it easier to aim for 100 percent coverage.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Responding to CRUD operations</h1></div></div></div><p>The <a id="id60" class="indexterm"/>term CRUD refers to the four basic operations one can perform on data: create, read, update, and delete. Express gives us an easy way to handle those operations by supporting the basic methods <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">GET</code>: This <a id="id61" class="indexterm"/>method is used to retrieve the existing data from the database. This can be used to read single or multiple rows (for SQL) or documents (for MongoDB) from the database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">POST</code>: This <a id="id62" class="indexterm"/>method is used to write new data into the database, and it is common to include a JSON payload that fits the data model.</li><li class="listitem" style="list-style-type: disc"><code class="literal">PUT</code>: This method is used to update existing data in the database, and a JSON <a id="id63" class="indexterm"/>payload that fits the data model is often included for this method as well.</li><li class="listitem" style="list-style-type: disc"><code class="literal">DELETE</code>: This<a id="id64" class="indexterm"/> method is used to remove an existing row or document from the database.</li></ul></div><p>Express 4<a id="id65" class="indexterm"/> has dramatically changed from version 3. A lot of the core modules have been removed in order to make it even more lightweight and less dependent. Therefore, we have to explicitly <code class="literal">require</code> modules when needed.</p><p>One helpful module is <code class="literal">body-parser</code>. It allows us to get a nicely formatted body when a <code class="literal">POST</code> or <code class="literal">PUT</code> HTTP request is received. We have to add this middleware before our business logic in order to use its result later. We write the following in <code class="literal">src/lib/parser.js</code>:</p><div><pre class="programlisting">var bodyParser = require('body-parser');
module;exports = function(app) {
  app.use(bodyParser.json());
  app.use(bodyParser.urlencoded({ extended: false }));
   };</pre></div><p>The preceding code is then used in <code class="literal">src/lib/app.js</code> as follows:</p><div><pre class="programlisting">var express = require('express'); var app = express();
require('./parser')(app);
module.exports = app;</pre></div><p>The following example allows you to respond to a <code class="literal">GET</code> request on <code class="literal">http://host/path</code>. Once a request hits our API, Express will run it through the necessary middleware as well as the following function:</p><div><pre class="programlisting">app.get('/path/:id', function(req, res, next) {
res.status(200).json({ hello: 'world'});
});</pre></div><p>The first parameter is the path we want to handle a <code class="literal">GET</code> function. The path can contain parameters prefixed with <code class="literal">:</code>. Those path parameters will then be parsed in the request object.</p><p>The second parameter is the callback that will be executed when the server receives the request. This function gets populated with three parameters: <code class="literal">req</code>, <code class="literal">res</code>, and <code class="literal">next</code>.</p><p>The <code class="literal">req</code> parameter represents the HTTP request object that has been customized by Express and the middlewares we added in our applications. Using the path <code class="literal">http://host/</code><code class="literal">path/:id</code>, suppose a <code class="literal">GET</code> request is sent to <code class="literal">http://hos</code><code class="literal">t/path/1?a=1&amp;b=2</code>. The <code class="literal">req</code> object would be the following:</p><div><pre class="programlisting">{
params: { id: 1 }, query: { a: 1, b: 2 }
}</pre></div><p>The <code class="literal">params</code> object is a representation of the path parameters. The <code class="literal">query</code> is the query string, which are the values stated after <code class="literal">?</code> in the URL. In a <code class="literal">POST</code> request, there will often be a body in our <a id="id66" class="indexterm"/>request object as well, which includes the data we <a id="id67" class="indexterm"/>wish to place in our database.</p><p>The <code class="literal">res</code> parameter<a id="id68" class="indexterm"/> represents the response object for that request. Some methods, such as <code class="literal">status()</code> or <code class="literal">json()</code>, are provided in order to tell Express how to respond to the client.</p><p>Finally, the <code class="literal">next()</code> function will execute the next middleware defined in our application.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Retrieving an actor with GET</h2></div></div></div><p>Retrieving a<a id="id69" class="indexterm"/> movie or actor from the <a id="id70" class="indexterm"/>database consists of submitting a <code class="literal">GET</code> request to the<a id="id71" class="indexterm"/> route: <code class="literal">/movies/:id or /actors/:id</code>. We will need a unique ID that refers to a unique movie or actor:</p><div><pre class="programlisting">app.get('/actors/:id', function(req, res, next) {
//Find the actor object with this :id
//Respond to the client
});</pre></div><p>Here, the URL parameter <code class="literal">:id</code> will be placed in our request object. Since we call the first variable in our callback function <code class="literal">req</code> as before, we can access the URL parameter by calling <code class="literal">req.params.id</code>.</p><p>Since an actor may be in many movies and a movie may have many actors, we need a nested endpoint to reflect this as well:</p><div><pre class="programlisting">app.get('/actors/:id/movies', function(req, res, next) {
//Find all movies the actor with this :id is in
//Respond to the client
});</pre></div><p>If a bad <code class="literal">GET</code> request is submitted or no actor with the specified ID is found, then the appropriate status code bad request <code class="literal">400</code> or not found <code class="literal">404</code> will be returned. If the actor is found, then success request <code class="literal">200</code> will be sent back along with the actor information. On a success, the response JSON will look like this:</p><div><pre class="programlisting">{
"_id": "551322589911fefa1f656cc5", "id": 1,
"name": "AxiomZen", "birth_year": 2012, "__v": 0, "movies": []
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Creating a new actor with POST</h2></div></div></div><p>In <a id="id72" class="indexterm"/>our API, creating a new movie in the <a id="id73" class="indexterm"/>database involves submitting a <code class="literal">POST</code> request to <code class="literal">/movies</code> or <code class="literal">/actors</code> for a new actor:</p><div><pre class="programlisting">app.post('/actors', function(req, res, next) {
//Save new actor
//Respond to the client
});</pre></div><p>In this<a id="id74" class="indexterm"/> example, the user accessing our API sends a <code class="literal">POST</code> request with data that would be placed into <code class="literal">request.body</code>. Here, we call the first variable in our callback function <code class="literal">req</code>. Thus, to access the body of the request, we call <code class="literal">req.body</code>.</p><p>The request body is sent as a JSON string; if an error occurs, a <code class="literal">400</code> (bad request) status would be sent back. Otherwise, a <code class="literal">201</code> (created) status is sent to the response object. On a success request, the response will look like the following:</p><div><pre class="programlisting">{
"__v": 0, "id": 1,
"name": "AxiomZen", "birth_year": 2012,
"_id": "551322589911fefa1f656cc5", "movies": []
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Updating an actor with PUT</h2></div></div></div><p>To <a id="id75" class="indexterm"/>update a movie or actor entry, we first <a id="id76" class="indexterm"/>create a new route and submit a <code class="literal">PUT</code> request to <code class="literal">/movies/:id</code> or <code class="literal">/actors /:id</code>, where the <code class="literal">id</code> parameter is unique to an existing <code class="literal">movie/actor</code>. There <a id="id77" class="indexterm"/>are two steps to an update. We first find the movie or actor by using the unique id and then we update that entry with the body of the request object, as shown in the following code:</p><div><pre class="programlisting">app.put('/actors/:id', function(req, res) {
//Find and update the actor with this :id
//Respond to the client
});</pre></div><p>In the request, we would need <code class="literal">request.body</code> to be a JSON object that reflects the actor fields to be updated. The <code class="literal">request.params.id</code> would still be a unique identifier that refers to an existing actor in the database as before. On a successful update, the response JSON looks like this:</p><div><pre class="programlisting">{
"_id": "551322589911fefa1f656cc5",
"id": 1,
"name": "Axiomzen", "birth_year": 99, "__v": 0, "movies": []
}</pre></div><p>Here, the<a id="id78" class="indexterm"/> response will reflect the changes we made to the data.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Removing an actor with DELETE</h2></div></div></div><p>Deleting <a id="id79" class="indexterm"/>a movie is as simple as<a id="id80" class="indexterm"/> submitting a <code class="literal">DELETE</code> request to the same routes <a id="id81" class="indexterm"/>that were used earlier (specifying the ID). The actor with the appropriate id is found and then deleted:</p><div><pre class="programlisting">app.delete('/actors/:id', function(req, res) {
//Remove the actor with this :id
//Respond to the client
});</pre></div><p>If the actor with the unique id is found, it is then deleted and a response code of <code class="literal">204</code> is returned. If the actor cannot be found, a response code of <code class="literal">400</code> is returned. There is no response body for a <code class="literal">DELETE()</code> method; it will simply return the status code of <code class="literal">204</code> on a successful deletion.</p><p>Our final endpoints for this simple app will be as follows:</p><div><pre class="programlisting">//Actor endpoints 
app.get('/actors', actors.getAll);
app.post('/actors', actors.createOne); 
app.get('/actors/:id', actors.getOne); 
app.put('/actors/:id', actors.updateOne); 
app.delete('/actors/:id', actors.deleteOne) 
app.post('/actors/:id/movies', actors.addMovie); 
app.delete('/actors/:id/movies/:mid', actors.deleteMovie);
//Movie endpoints
app.get('/movies', movies.getAll); 
app.post('/movies', movies.createOne);
app.get('/movies/:id', movies.getOne); 
app.put('/movies/:id', movies.updateOne); 
app.delete('/movies/:id', movies.deleteOne); 
app.post('/movies/:id/actors', movies.addActor); 
app.delete('/movies/:id/actors/:aid', movies.deleteActor);</pre></div><p>In Express 4, there is an alternative way to describe your routes. Routes that share a common URL, but use a different HTTP verb, can be grouped together as follows:</p><div><pre class="programlisting">app.route('/actors')
.get(actors.getAll)
.post(actors.createOne);
app.route('/actors/:id')
.get(actors.getOne)
.put(actors.updateOne)
.delete(actors.deleteOne);
app.post('/actors/:id/movies', actors.addMovie); 
app.delete('/actors/:id/movies/:mid', actors.deleteMovie);
app.route('/movies')
.get(movies.getAll)
.post(movies.createOne);
app.route('/movies/:id')
.get(movies.getOne)
.put(movies.updateOne)
.delete(movies.deleteOne);
app.post('/movies/:id/actors', movies.addActor); 
app.delete('/movies/:id/actors/:aid', movies.deleteActor);</pre></div><p>Whether you prefer it this way or not is up to you. At least now you have a choice!</p><p>We <a id="id82" class="indexterm"/>have not discussed the logic<a id="id83" class="indexterm"/> of the function being run for each endpoint. We <a id="id84" class="indexterm"/>will get to that shortly.</p><p>Express allows us to easily CRUD our database objects, but how do we model our objects?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Object modeling with Mongoose</h1></div></div></div><p>Mongoose<a id="id85" class="indexterm"/> is an object data modeling library (ODM) that <a id="id86" class="indexterm"/>allows you to define schemas<a id="id87" class="indexterm"/> for your data collections. You can find out more about Mongoose on the project website: <a class="ulink" href="http://mongoosejs.com/">http://mongoosejs.com/</a>.</p><p>To connect to a MongoDB instance using the <code class="literal">mongoose</code> variable, we first need to install npm and save Mongoose. The <code class="literal">save</code> flag automatically adds the module to your <code class="literal">package.json</code> with the latest version, thus, it is always recommended to install your modules with the save flag. For modules that you only need locally (for example, Mocha), you can use the <code class="literal">savedev</code> flag.</p><p>For this project, we create a new file <code class="literal">db.js</code> under <code class="literal">/src/lib/db.js</code>, which requires Mongoose. The local connection to the <code class="literal">mongodb</code> database is made in <code class="literal">mongoose.connect</code> as follows:</p><div><pre class="programlisting">var mongoose = require('mongoose');
module.exports = function(app)
{ 
  mongoose.connect('mongodb://localhost/movies', {
  mongoose: { safe: true
}
}, function(err) { if (err) 
{
  return console.log('Mongoose - connection error:', err);
}
});
return mongoose; 
};</pre></div><p>In our <a id="id88" class="indexterm"/>movies database, we need separate schemas<a id="id89" class="indexterm"/> for actors and movies. As an example, we will go through object modeling in our actor database <code class="literal">/src/models/actor.js</code> by creating an actor schema as follows:</p><div><pre class="programlisting">// /src/models/actor.js
var mongoose = require('mongoose');
var generateId = require('./plugins/generateId');

var actorSchema = new mongoose.Schema({ 
  id: {
    type: Number, 
    required: true, 
    index: {
      unique: true
    }
  },
  name: {
    type: String, 
    required: true
  }, 
  birth_year: {
    type: Number, 
    required: true

  }, 
  movies: [{
    type : mongoose.Schema.ObjectId,
    ref : 'Movie'
  }]
});
actorSchema.plugin(generateId());
module.exports = mongoose.model('Actor', actorSchema);</pre></div><p>Each actor has a unique id, a name, and a birth year. The entries also contain validators such as the type and boolean value that are required. The model is exported upon definition (<code class="literal">module.exports</code>), so that we can reuse it directly in the app.</p><p>Alternatively, you could fetch each model through Mongoose using <code class="literal">mongoose.model('Actor', actorSchema)</code>, but this would feel less explicitly coupled compared to our approach of directly requiring it.</p><p>Similarly, we need a movie schema as well. We define the movie schema as follows:</p><div><pre class="programlisting">// /src/models/movies.js
var movieSchema = new mongoose.Schema({ 
  id: {
    type: Number, 
    required: true, 
    index: {
      unique: true
    }
  }, 
  title: {
    type: String, 
    required: true
   }, 
   year: {
     type: Number, 
     required: true
   }, 
   actors: [{
     type : mongoose.Schema.ObjectId, 
     ref : 'Actor'
   }]
});

movieSchema.plugin(generateId());
module.exports = mongoose.model('Movie', movieSchema);</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Generating unique IDs</h1></div></div></div><p>In both<a id="id90" class="indexterm"/> our movie and actor schemas, we used a plugin called <code class="literal">generateId()</code>.</p><p>While MongoDB automatically generates <code class="literal">ObjectID</code> for each document using the <code class="literal">_id</code> field, we want to generate our own IDs that are more human readable and hence friendlier. We also would like to give the user the opportunity to select their own id of choice.</p><p>However, being able to choose an id can cause conflicts. If you were to choose an id that already exists, your <code class="literal">POST</code> request would be rejected. We should autogenerate an ID if the user does not pass one explicitly.</p><p>Without this plugin, if either an actor or a movie is created without an explicit ID passed along by the user, the server would complain since the ID is required.</p><p>We can create middleware for Mongoose that assigns an <code class="literal">id</code> before we persist the object as follows:</p><div><pre class="programlisting">// /src/models/plugins/generateId.js 
module.exports = function() {

return function generateId(schema){ 
  schema.pre('validate',function(next, done) {
    var instance = this; 
    var model = instance.model(instance.constructor.modelName); 

    if( instance.id == null ) {
     model.findOne().sort("-id").exec(function(err,maxInstance) {
       if (err){
         return done(err);
       } else {
         var maxId = maxInstance.id || 0; 
         instance.id = maxId+1;
         done();
       }
    })
   } else { 
     done();
    }
  })
 }
};</pre></div><p>There are a few important notes about this code.</p><p>See what we did to get the <code class="literal">var</code> model? This makes the plugin generic so that it can be applied to multiple Mongoose schemas.</p><p>Notice that <a id="id91" class="indexterm"/>there are two callbacks available: <code class="literal">next</code> and <code class="literal">done</code>. The <code class="literal">next</code> variable passes the code to the next pre-validation middleware. That's something you would usually put at the bottom of the function right after you make your asynchronous call. This is generally a good thing since one of the advantages of asynchronous calls is that you can have many things running at the same time.</p><p>However, in this case, we cannot call the <code class="literal">next</code> variable because it would conflict with our model definition of id required. Thus, we just stick to using the <code class="literal">done</code> variable when the logic is complete.</p><p>Another concern arises due to the fact that MongoDB doesn't support transactions, which means you may have to account for this function failing in some edge cases. For example, if two calls to <code class="literal">POST</code> <code class="literal">/actor</code> happen at the same time, they will both have their IDs auto incremented to the same value.</p><p>Now that we have the code for our <code class="literal">generateId()</code> plugin, we require it in our actor and movie schema as follows:</p><div><pre class="programlisting">var generateId = require('./plugins/generateId');
actorSchema.plugin(generateId());</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Validating your database</h1></div></div></div><p>Each<a id="id92" class="indexterm"/> key in the Mongoose schema defines a property that is associated with a SchemaType. For example, in our <code class="literal">actors.js</code> schema, the actor's name key is associated with a string SchemaType. String, number, date, buffer, boolean, mixed, objectId, and array are all valid schema types.</p><p>In addition to schema types, numbers have min and max validators and strings have enum and match validators. Validation occurs when a document is being saved <code class="literal">(.save())</code> and will return an error object, containing type, path, and value properties, if the validation has failed.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Extracting functions to reusable middleware</h1></div></div></div><p>We<a id="id93" class="indexterm"/> can<a id="id94" class="indexterm"/> use our anonymous or named functions as middleware. To do so, we would export our functions by calling <code class="literal">module.exports</code> in <code class="literal">routes/actors.js</code> and <code class="literal">routes/movies.js</code>:</p><p>Let's take a look at our <code class="literal">routes/actors.js</code> file. At the top of this file, we require the Mongoose schemas we defined before:</p><div><pre class="programlisting">var Actor = require('../models/actor');</pre></div><p>This allows our variable <code class="literal">actor</code> to access our MongoDB using mongo functions such as <code class="literal">find()</code>, <code class="literal">create()</code>, and <code class="literal">update()</code>. It will follow the schema defined in the file <code class="literal">/models/actor</code>.</p><p>Since actors<a id="id95" class="indexterm"/> are in movies, we will also<a id="id96" class="indexterm"/> need to require the <code class="literal">Movie</code> schema to show this relationship by the following.</p><div><pre class="programlisting">var Movie = require('../models/movie');</pre></div><p>Now that we have our schema, we can begin defining the logic for the functions we described in endpoints. For example, the endpoint <code class="literal">GET</code> <code class="literal">/actors/:id</code> will retrieve the actor with the corresponding ID from our database. Let's call this function <code class="literal">getOne()</code>. It is defined as follows:</p><div><pre class="programlisting">getOne: function(req, res, next) { Actor.findOne({ id: req.params.id })
.populate('movies')
.exec(function(err, actor) {
if (err) return res.status(400).json(err); if (!actor) return res.status(404).json(); res.status(200).json(actor);
});
},</pre></div><p>Here, we use the mongo <code class="literal">findOne()</code> method to retrieve the actor with <code class="literal">id:</code> <code class="literal">req.params.id</code>. There are no joins in MongoDB so we use the <code class="literal">.populate()</code> method to retrieve the movies the actor is in.</p><p>The <code class="literal">.populate()</code> method will retrieve documents from a separate collection based on its <code class="literal">ObjectId</code>.</p><p>This function will return a status <code class="literal">400</code> if something went wrong with our Mongoose driver, a status <code class="literal">404</code> if the actor with <code class="literal">:id</code> is not found, and finally, it will return a status <code class="literal">200</code> along with the JSON of the actor object if an actor is found.</p><p>We define all the functions required for the actor endpoints in this file. The result is as follows:</p><div><pre class="programlisting">// /src/routes/actors.js
var Actor = require('../models/actor'); 
var Movie = require('../models/movie');

module.exports = {

  getAll: function(req, res, next) { 
    Actor.find(function(err, actors) {
      if (err) return res.status(400).json(err);

      res.status(200).json(actors); 
    });
  },


  createOne: function(req, res, next) { 
  Actor.create(req.body, function(err, actor) {
    if (err) return res.status(400).json(err);

    res.status(201).json(actor); 
  });
  },


  getOne: function(req, res, next) { 
    Actor.findOne({ id: req.params.id })
    .populate('movies')
.exec(function(err, actor) {
      if (err) return res.status(400).json(err); 
      if (!actor) return res.status(404).json();

      res.status(200).json(actor);
    });
  },


  updateOne: function(req, res, next) { 
    Actor.findOneAndUpdate({ id: req.params.id }, req.body,function(err, actor) {
      if (err) return res.status(400).json(err); 
      if (!actor) return res.status(404).json();

      res.status(200).json(actor); 
    });
  },


  deleteOne: function(req, res, next) { 
    Actor.findOneAndRemove({ id: req.params.id }, function(err) {
      if (err) return res.status(400).json(err);

      res.status(204).json(); 
    });
  },


  addMovie: function(req, res, next) {
    Actor.findOne({ id: req.params.id }, function(err, actor) { 
      if (err) return res.status(400).json(err);
      if (!actor) return res.status(404).json();

      Movie.findOne({ id: req.body.id }, function(err, movie) {
        if (err) return res.status(400).json(err);
        if (!movie) return res.status(404).json();

        actor.movies.push(movie); 
        actor.save(function(err) {
          if (err) return res.status(500).json(err);

          res.status(201).json(actor); 
        });
       })
     });
  },


  deleteMovie: function(req, res, next) {
    Actor.findOne({ id: req.params.id }, function(err, actor) { 
      if (err) return res.status(400).json(err);
      if (!actor) return res.status(404).json();

      actor.movies = []; 
      actor.save(function(err) {
        if (err) return res.status(400).json(err);

        res.status(204).json(actor);
      })
    });
   }

  };</pre></div><p>For all of our movie endpoints, we need the same functions but applied to the movie collection.</p><p>After <a id="id97" class="indexterm"/>exporting<a id="id98" class="indexterm"/> these two files, we require them in <code class="literal">app.js</code> (<code class="literal">/src/lib/app.js</code>) by simply adding:</p><div><pre class="programlisting">require('../routes/movies'); require('../routes/actors');</pre></div><p>By exporting our functions as reusable middleware, we keep our code clean and can refer to functions in our CRUD calls in the <code class="literal">/routes</code> folder.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Testing</h1></div></div></div><p>Mocha is used as the test framework along with <code class="literal">should.js</code> and supertest. The principles behind <a id="id99" class="indexterm"/>why we use testing in our apps along with some basics on Mocha are covered in <a class="link" href="ch01.html" title="Chapter 1. Building a Basic Express Site">Chapter 1</a>,<em> Building a Basic Express Site</em>. Testing supertest lets you test your HTTP assertions and testing API endpoints.</p><p>The tests are placed in the root folder <code class="literal">/test</code>. Tests are completely separate from any of the source code and are written to be readable in plain English, that is, you should be able to follow along with what is being tested just by reading through them. Well-written tests with good coverage can serve as a readme for its API, since it clearly describes the behavior of the entire app.</p><p>The initial setup to test our movies API is the same for both <code class="literal">/test/actors.js</code> and <code class="literal">/test/movies.js</code> and will look familiar if you have read <a class="link" href="ch01.html" title="Chapter 1. Building a Basic Express Site">Chapter 1</a>, <em>Building a Basic Express Site</em>:</p><div><pre class="programlisting">var should = require('should'); var assert = require('assert');
var request = require('supertest');
var app = require('../src/lib/app');</pre></div><p>In <code class="literal">src/test/actors.js</code>, we test the basic CRUD operations: creating a new actor object, retrieving, editing, and deleting the actor object. An example test for the creation of a new actor is shown as follows:</p><div><pre class="programlisting">  describe('Actors', function() { 

  describe('POST actor', function(){
    it('should create an actor', function(done){ 
      var actor = {
        'id': '1',
        'name': 'AxiomZen', 'birth_year': '2012',
       };

       request(app)
       .post('/actors')
       .send(actor)
       .expect(201, done)
    });</pre></div><p>We can<a id="id100" class="indexterm"/> see that the tests are readable in plain English. We create a new <code class="literal">POST</code> request for a new actor to the database with the <code class="literal">id</code> of <code class="literal">1</code>, <code class="literal">name</code> of <code class="literal">AxiomZen</code>, and <code class="literal">birth_year</code> of <code class="literal">2012</code>. Then, we send the request with the .<code class="literal">send()</code> function. Similar tests are present for <code class="literal">GET</code> and <code class="literal">DELETE</code> requests as given in the following code:</p><div><pre class="programlisting">  describe('GET actor', function() {
    it('should retrieve actor from db', function(done){ 
      request(app)
      .get('/actors/1')
      .expect(200, done);
    });
  describe('DELETE actor', function() {
    it('should remove a actor', function(done) { 
      request(app)
      .delete('/actors/1')
     .expect(204, done);
    });
  });</pre></div><p>To test our <code class="literal">PUT</code> request, we will edit the <code class="literal">name</code> and <code class="literal">birth_year</code> of our first actor as follows:</p><div><pre class="programlisting">  describe('PUT actor', function() {
    it('should edit an actor', function(done) { 
      var actor = {
        'name': 'ZenAxiom', 
        'birth_year': '2011'
      };

      request(app)
      .put('/actors/1')
      .send(actor)
      .expect(200, done);
    });

    it('should have been edited', function(done) { 
      request(app)
      .get('/actors/1')
      .expect(200)
      .end(function(err, res) { 
        res.body.name.should.eql('ZenAxiom');
        res.body.birth_year.should.eql(2011);
        done();
      });
     });
  });</pre></div><p>The first part of the test modifies the actor <code class="literal">name</code> and <code class="literal">birth_year</code> keys, sends a <code class="literal">PUT</code> request for <code class="literal">/actors/1</code> (<code class="literal">1</code> is the actors <code class="literal">id</code>), and then saves the new information to the database. The second part of the test checks whether the database entry for the actor with <code class="literal">id</code> <code class="literal">1</code> has been changed. The <code class="literal">name</code> and <code class="literal">birth_year</code> values are checked against their expected values using <code class="literal">.should.eql()</code>.</p><p>In addition to<a id="id101" class="indexterm"/> performing CRUD actions on the actor object, we can also perform these actions to the movies we add to each actor (associated by the actor's ID). The following snippet shows a test to add a new movie to our first actor (with the <code class="literal">id</code> of <code class="literal">1</code>):</p><div><pre class="programlisting">  describe('POST /actors/:id/movies', function() { 
    it('should successfully add a movie to the actor',function(done) { 
      var movie = {
        'id': '1',
        'title': 'Hello World', 
        'year': '2013'
      }
      request(app)
      .post('/actors/1/movies')
      .send(movie)
      .expect(201, done)
      });
    });

    it('actor should have array of movies now', function(done){ 
      request(app)
      .get('/actors/1')
      .expect(200)
      .end(function(err, res) { 
      res.body.movies.should.eql(['1']); 
      done();
     });
    });
  });</pre></div><p>The first part of the test creates a new movie object with <code class="literal">id</code>, <code class="literal">title</code>, and <code class="literal">year</code> keys, and sends a <code class="literal">POST</code> request to add the movies as an array to the actor with <code class="literal">id</code> of <code class="literal">1</code>. The second part of the test sends a <code class="literal">GET</code> request to retrieve the actor with <code class="literal">id</code> of <code class="literal">1</code>, which should now include an array with the new movie input.</p><p>We can similarly delete the movie entries as illustrated in the <code class="literal">actors.js</code> test file:</p><div><pre class="programlisting">  describe('DELETE /actors/:id/movies/:movie_id', function() { 
    it('should successfully remove a movie from actor', function(done){
      request(app)
      .delete('/actors/1/movies/1')
      .expect(200, done);
    });

    it('actor should no longer have that movie id', function(done){
      request(app)
      .get('/actors/1')
      .expect(201)
      .end(function(err, res) { 
        res.body.movies.should.eql([]); 
        done();
      });
    });
  });</pre></div><p>Again, this<a id="id102" class="indexterm"/> code snippet should look familiar to you. The first part tests that sending a <code class="literal">DELETE</code> request specifying the actor ID and movie ID will delete that movie entry. In the second part, we make sure that the entry no longer exists by submitting a <code class="literal">GET</code> request to view the actor's details where no movies should be listed.</p><p>In addition to ensuring that the basic CRUD operations work, we also test our schema validations. The following code tests to make sure two actors with the same ID do not exist (IDs are specified as unique):</p><div><pre class="programlisting">  it('should not allow you to create duplicate actors', function(done) {
    var actor = { 
      'id': '1',
      'name': 'AxiomZen', 
      'birth_year': '2012',
    };

    request(app)
    .post('/actors')
    .send(actor)
    .expect(400, done);
  });</pre></div><p>We should expect code <code class="literal">400</code> (bad request) if we try to create an actor who already exists in the database.</p><p>A similar set of tests is present for <code class="literal">tests/movies.js</code>. The function and outcome of each test should be evident now.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Summary</h1></div></div></div><p>In this chapter, we created a basic API that connects to MongoDB and supports CRUD methods. You should now be able to set up an API complete with tests, for any data, not just movies and actors!</p><p>The astute reader will have noticed that we have not addressed some issues in the current chapter such as dealing with race conditions in MongoDB. These will be clarified in detail in the following chapters.</p><p>We hope you found that this chapter has laid a good foundation for the Express and API setup.</p></div></body></html>