<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-89" lang="en-GB"><a id="_idTextAnchor088"/>9</h1>
<h1 id="_idParaDest-90" lang="en-GB"><a id="_idTextAnchor089"/>Structuring Code in Monorepos</h1>
<p lang="en-GB">In the previous chapter, you learned about everything to create and publish great libraries and tools to enhance your projects. While some packages are created in a bit of vacuum, most already have a consuming application in mind. In this case, having two separate repositories – that is, one for the application and one for the library – is quite some overhead. After all, any change to the library should be at least partially tested before the library is published. A good way to make this relation more efficient is to structure this code in a monorepo.</p>
<p lang="en-GB">A <code>package.json</code>.</p>
<p lang="en-GB">Today, monorepos are frequently used to power some of the largest Node.js project code bases in the world. If you want to properly read and contribute to projects such as Angular, React, or Vue, you’ll need extensive knowledge about monorepos and the tools that make monorepos possible. For your own projects, a good structure – quite often provided by implementing monorepos – can also be crucial.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Understanding monorepos</li>
<li lang="en-GB">Using workspaces to implement monorepos</li>
<li lang="en-GB">Working with Lerna to manage monorepos</li>
<li lang="en-GB">Working with Rush for larger repositories</li>
<li lang="en-GB">Integrating Turborepo instead of or with Lerna</li>
<li lang="en-GB">Managing a monorepo with Nx to enhance Lerna</li>
</ul>
<h1 id="_idParaDest-91" lang="en-GB"><a id="_idTextAnchor090"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter is available at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter09">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter09</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="https://bit.ly/3EjGZTL">https://bit.ly/3EjGZTL</a>.</p>
<h1 id="_idParaDest-92" lang="en-GB"><a id="_idTextAnchor091"/>Understanding monorepos</h1>
<p lang="en-GB">The structure of a dedicated<a id="_idIndexMarker318"/> repository has always been very similar; we have a single <code>package.json</code> in the root, a single <code>node_modules</code> folder containing the resolved dependencies, and a set of source and configuration files, usually scattered between the root and some specific folders such as <code>src</code>. A quite popular setup is shown in <em class="italic" lang="">Figure 9</em><em class="italic" lang="">.1</em>:</p>
<div><div><img alt="Figure 9.1 – Common setup for a repository with a single package " src="img/Figure_9.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Common setup for a repository with a single package</p>
<p lang="en-GB">In the common setup, we have some folders for CI/CD pipeline definitions and potential tools that are useful for managing the repository, as well as auxiliary files such as project documentation. Of course, for a Node.js project, we’ll see a <code>node_modules</code> directory, as well as a <code>package.json</code> file.</p>
<p lang="en-GB">In contrast, a monorepo will contain multiple <code>package.json</code> files with multiple <code>node_modules</code> (or alternative) folders. Likewise, the source files and potentially some of the configuration will also <a id="_idIndexMarker319"/>be scattered across multiple locations. A very common structure is shown in <em class="italic" lang="">Figure 9</em><em class="italic" lang="">.2</em> for the main part and <em class="italic" lang="">Figure 9</em><em class="italic" lang="">.3</em> for the individual packages:</p>
<div><div><img alt="Figure 9.2 – Common setup for a repository with multiple packages " src="img/Figure_9.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Common setup for a repository with multiple packages</p>
<p lang="en-GB">In comparison to <em class="italic" lang="">Figure 9</em><em class="italic" lang="">.1</em>, the hierarchy of the outlined folders is a bit more sophisticated. Now, we don’t see the source files immediately and need to descend into some of the directories inside the <code>packages</code> folder:</p>
<div><div><img alt="Figure 9.3 – The contents of the individual package directories " src="img/Figure_9.3_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – The contents of the individual package directories</p>
<p lang="en-GB">Ideally, the packages contained in a monorepo are crafted in such a way that makes them rather easy to extract<a id="_idIndexMarker320"/> later on. Let’s say you have a specific library in your monorepo that should now be handled by another team. If your monorepo was created to serve as the single point of development for your current team, then transferring this library makes sense.</p>
<p lang="en-GB">Quite often, common development concerns, such as the usual packages contained in the <code>devDependencies</code> of a <code>package.json</code> file, are concentrated in a dedicated <code>package.json </code>file. In many monorepos, this <code>package.json</code> file is found in the root directory of the monorepo. While this pattern makes sense from a maintenance point of view, it can also bring up challenges when it comes to library extraction. After all, you’ll now need to decide what dependencies to add to restore the development capability of the extracted library.</p>
<p lang="en-GB">In general, multiple challenges make supporting monorepos a task of its own. Here are some of the most<a id="_idIndexMarker321"/> pressing concerns:</p>
<ol>
<li lang="en-GB">How are dependencies efficiently shared to avoid installing the same dependencies over and over again?</li>
<li lang="en-GB">How can packages be treated as if they are dependencies installed from a registry?</li>
<li lang="en-GB">How can common tasks such as build steps be run in a way that works consistently?</li>
</ol>
<p lang="en-GB">Let’s go through these one by one. For (<em class="italic" lang="">1</em>), the idea is that monorepos can be more efficient than just having many different directories, where you’d need to run <code>npm install</code> in each of them. Running <code>npm install</code> in each directory would be a massive overhead, duplicating not only direct dependencies but also indirect ones – that is, dependencies of installed dependencies.</p>
<p lang="en-GB">While (<em class="italic" lang="">1</em>) is only a performance (installation time and disk space) concern, the issue with (<em class="italic" lang="">2</em>) is developer convenience. The reason for having a monorepo in the first place is to have packages that depend on one another in close proximity. This way, a bug should be visible at development time, rather than later at integration time when a package has already been published. The usual mechanism of npm for this is to use the <code>npm link</code> command, which will make a local package globally available for referencing. There are, however, multiple downsides to this mechanism. Additionally, it is not very convenient to use this command for every package.</p>
<p lang="en-GB">Finally, the dependencies between the packages in a monorepo require special attention when running commands. In terms of (<em class="italic" lang="">3</em>), tasks such as building the source code need to be performed in reverse reference order. This means, that in the case that package <em class="italic" lang="">A</em> depends on package <em class="italic" lang="">B</em>, the build process of package <em class="italic" lang="">B</em> needs to be done before package <em class="italic" lang="">A</em> is built. The reason is that through the dependency, the content of package <em class="italic" lang="">A</em> may only build successfully if the content of package <em class="italic" lang="">B</em> has been fully created – that is, the package has been built. Similar constraints arise for testing and when publishing a package.</p>
<p lang="en-GB">With this in mind, let’s start with one of the easiest options for implementing a monorepo: leveraging the workspaces feature that comes with the most popular npm clients.</p>
<h1 id="_idParaDest-93" lang="en-GB"><a id="_idTextAnchor092"/>Using workspaces to implement monorepos</h1>
<p lang="en-GB">As the need for <a id="_idIndexMarker322"/>monorepos grew, npm clients tried to help users by incorporating them. The first of the big three was <em class="italic" lang="">Yarn</em>. Already, with the first <a id="_idIndexMarker323"/>version of Yarn, a new <a id="_idIndexMarker324"/>concept called <code>workspaces</code> in <code>package.json</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">package.json</p>
<pre class="source-code" lang="en-GB">{
  "name": "monorepo-root",
  "private": true,
  "workspaces": [
    "packages/*"
  ]
}</pre>
<p lang="en-GB">Yarn workspaces require a <code>package.json</code> at the root directory of the monorepo. This <code>package.json</code> won’t be used for publishing and needs to have the <code>private</code> field set to <code>true</code>. The <code>workspaces</code> field itself is an array that contains the paths to the different packages. Wildcards using the <code>*</code> or <code>**</code> symbols – as shown here – are allowed.</p>
<p lang="en-GB">With npm <em class="italic" lang="">v7</em>, the standard npm client also received a workspaces feature. The feature is pretty much the same as the implementation in Yarn. Here, we need to have a <code>package.json</code> in the root, too. Likewise, the behavior is controlled by a <code>workspaces</code> field.</p>
<p lang="en-GB">Finally, the implementation in <em class="italic" lang="">pnpm</em> is a bit different. Here, we need a dedicated file called <code>pnpm-workspace.yaml</code>. This file contains the paths to the different packages:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">pnpm-workspace.yaml</p>
<pre class="source-code" lang="en-GB">packages:
  - 'packages/*'</pre>
<p lang="en-GB">In contrast to the other two npm clients, with pnpm, you don’t need a <code>package.json</code> file in the root directory. Since the workspaces definition is in a separate file, this file alone is sufficient to enable the workspaces feature of pnpm.</p>
<p lang="en-GB">To illustrate that, let’s create<a id="_idIndexMarker325"/> a new directory and add the preceding <code>pnpm-workspace.yaml</code> file to it. Then, create a <code>packages</code> subfolder. In there, add two<a id="_idIndexMarker326"/> more folders, <code>p1</code> and <code>p2</code>. In each of these directories, run <code>npm init -y</code>. You can now modify the contained <code>package.json</code> files, adding some dependencies to both.</p>
<p lang="en-GB">From the root directory with the <code>pnpm-workspace.yaml</code> file, run the following:</p>
<pre class="console" lang="en-GB">
$ pnpm install

Scope: all 2 workspace projects

Packages: +5

+++++

Packages are hard linked from the content-addressable store to the virtual store.

  Content-addressable store is at: /home/node/.local/share/pnpm/store/v3

  Virtual store is at:             node_modules/.pnpm

Progress: resolved 5, reused 5, downloaded 0, added 5, done</pre>
<p lang="en-GB">While editing the respective <code>package.json</code> file is always possible, <code>pnpm</code> also makes it easy to add a dependency to some contained package – or workspace in the terminology of pnpm.</p>
<p lang="en-GB">Let’s say you want to add <code>react-dom</code> to the <code>p1</code> workspace:</p>
<pre class="console" lang="en-GB">
$ pnpm add react-dom --filter p1

No projects matched the filters "/home/node/ Chapter09/example01" in "/home/node/Chapter09/example01"

.                                        |   +2 +

Progress: resolved 5, reused 5, downloaded 0, added 0, done</pre>
<p lang="en-GB">The <code>--filter</code> argument allows you to select the workspaces where the dependency should be added. While<a id="_idIndexMarker327"/> full names are accepted, the names can<a id="_idIndexMarker328"/> also be specified with wildcards (<code>*</code>).</p>
<p class="callout-heading" lang="en-GB">Specifying dependencies in monorepos</p>
<p class="callout" lang="en-GB">Dependencies on other packages contained in the same monorepo are declared just like any other dependency – in the corresponding <code>package.json</code> fields, such as <code>dependencies</code> or <code>devDependencies</code>. The specified version, however, is crucial here. You need to make sure to either match the version of the referenced package (e.g., <code>1.2.3</code> or <code>^1.0.0</code> would both correctly match a package in version <code>1.2.3</code>) or use the wildcard specifier <code>*</code>. Today, most package managers also support the special workspace protocol. With this, you can write <code>workspace:*</code> instead of a version to link against a package in another workspace.</p>
<p lang="en-GB">The workspaces option is certainly appealing to optimize packages and make their linking quite easy; however, it fails to make common monorepo tasks more approachable or convenient. An alternative is to use a tool such as <strong class="bold" lang="">Lerna</strong> on top of a workspace.</p>
<h1 id="_idParaDest-94" lang="en-GB"><a id="_idTextAnchor093"/>Working with Lerna to manage monorepos</h1>
<p lang="en-GB"><strong class="bold" lang="">Lerna</strong> is one of the oldest tools for<a id="_idIndexMarker329"/> managing monorepos. We can even say to some degree that Lerna not only made monorepos manageable but also popular. Lerna is<a id="_idIndexMarker330"/> the backbone of some of the most important monorepos, such as Jest. It also was the original choice for projects such as <em class="italic" lang="">Babel</em> or <em class="italic" lang="">React</em>.</p>
<p lang="en-GB">Originally, Lerna was mainly picked because it correctly installed and resolved all the packages. At this time, no package manager was capable of doing that intrinsically. However, today, Lerna is most often used together with the workspace features offered by the different package managers. Of course, you can still use the original mode of Lerna, where plain <code>npm</code> is used to install and link the different packages. So, how does Lerna fit into this new role when the whole installation is done by the chosen package manager anyway?</p>
<p lang="en-GB">It turns out that Lerna is a really great task-running layer on top of a package manager. For instance, running a <code>package.json</code> script such as <code>build</code> in all the contained packages is as straightforward as invoking the following:</p>
<pre class="console" lang="en-GB">
$ npx lerna run build</pre>
<p lang="en-GB">This would only run the <a id="_idIndexMarker331"/>script in the packages that contain this <a id="_idIndexMarker332"/>kind of script. In comparison, Yarn would actually error out if one of the packages did not have a <code>build</code> script.</p>
<p lang="en-GB">To get started with Lerna, you need to initialize the current repository as a Lerna monorepo. For this, the <code>init</code> command can be used:</p>
<pre class="console" lang="en-GB">
$ npx lerna init</pre>
<p lang="en-GB">Once initialized, the repository should contain a <code>lerna.json</code> and a <code>package.json</code> file. By inspecting these files, you’ll notice that <code>lerna.json</code> contains a version (by default <code>0.0.0</code>), but <code>package.json</code> does not. This is intentional. Lerna will actually manage the version here. The default choice is uniform versioning – that is, all packages will always get the same version. The other option is independent versioning. Here, each package can have its own version number. This is handy if different packages have their own release cycle.</p>
<p lang="en-GB">To enable independent versioning, we can change <code>lerna.json</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">lerna.json</p>
<pre class="source-code" lang="en-GB">{
  // ... as beforehand
  "version": "independent"
}</pre>
<p lang="en-GB">Alternatively, we could also initialize the repository using the <code>--independent</code> flag for the <code>lerna </code><code>init</code> command.</p>
<p lang="en-GB">The <code>package.json</code> file contains the <code>workspaces</code> property. By default, this is configured to include all directories from the <code>package</code> directory as packages. In the given configuration, Lerna would use npm as a package manager. In any case, the whole package management is left to an actual npm client.</p>
<p lang="en-GB">As mentioned, Lerna is really good at running tasks. What else is considered a strength of Lerna? The whole publishing and<a id="_idIndexMarker333"/> version management. We’ve already <a id="_idIndexMarker334"/>seen that Lerna knows two modes: independent and uniform versioning. In the independent versioning mode, Lerna will check the published versions with the current version that is about to be published. Only in the case of a new version will the <code>publish</code> command actually run.</p>
<p lang="en-GB">Let’s see how the packages from the previous example would actually be published with Lerna. We’ll use a local registry running Verdaccio for this:</p>
<pre class="console" lang="en-GB">
$ npx lerna publish --registry http://localhost:4873

lerna notice cli v5.5.2

lerna info versioning independent

lerna info Looking for changed packages since p1@1.0.1

? Select a new version for p1 (currently 0.0.0) Major (1.0.0)

? Select a new version for p2 (currently 0.0.0) Major (1.0.0)

Changes:

 - p1: 0.0.0 =&gt; 1.0.0

 - p2: 0.0.0 =&gt; 1.0.0

? Are you sure you want to publish these packages? Yes

lerna info execute Skipping releases

lerna info git Pushing tags...

lerna info publish Publishing packages to npm...

[...]

Successfully published:

 - p1@1.0.0

 - p2@1.0.0

lerna success published 2 packages</pre>
<p lang="en-GB">Without additional flags, Lerna will guide us through the whole publishing process. As we specified independent versioning, the tool <a id="_idIndexMarker335"/>will ask us the version to pick for each contained package. In the<a id="_idIndexMarker336"/> case here, we selected <code>1.0.0</code> for both packages.</p>
<p lang="en-GB">Lerna also does a bit more than just running <code>npm publish</code> for each package. It is strongly related to <strong class="bold" lang="">Git</strong> as a version control system. It also ties the publish to the current commit and marks the publish via Git tags, which are automatically pushed to a potential origin such as <strong class="bold" lang="">GitHub</strong>.</p>
<p lang="en-GB">Another thing that Lerna brings to the table is extensive information about a monorepo. Since Lerna needs to know which packages exist and what their relations are quite well, it also makes sense that this information is exposed to us.</p>
<p lang="en-GB">A great command to use to see what exists in the current monorepo is <code>lerna list</code>:</p>
<pre class="console" lang="en-GB">
$ npx lerna list --graph

lerna notice cli v5.5.2

lerna info versioning independent

{

  "p1": [

    "react",

    "react-dom"

  ],

  "p2": [

    "react",

    "react-dom"

  ]

}

lerna success found 2 packages</pre>
<p lang="en-GB">There are multiple options – all geared to fine-tune what information to include, exclude, and how to represent it. Ultimately, this is <a id="_idIndexMarker337"/>designed to make consumption in many ways possible. Independent of whether you consume this from <a id="_idIndexMarker338"/>a script or directly, the <code>lerna</code> tool has the right options to present the data accordingly.</p>
<p lang="en-GB">Lerna has certainly been established as one of the go-to options for handling monorepos; however, its configuration options can be daunting, and making it efficient in a larger repository could be troublesome. An alternative is to use an opinionated tool instead. One of the best options in this category is <strong class="bold" lang="">Rush</strong>.</p>
<h1 id="_idParaDest-95" lang="en-GB"><a id="_idTextAnchor094"/>Working with Rush for larger repositories</h1>
<p lang="en-GB">While Lerna provided a<a id="_idIndexMarker339"/> lot of the utility that made monorepos possible at all, its configuration and flexibility also posed some challenges. Furthermore, finding best practices proved to be difficult. Consequently, plenty of quite opinionated alternatives to using Lerna have been born. One of the most successful ones is Rush from Microsoft.</p>
<p lang="en-GB">Rush allows a variety of npm clients to be used. Classically, Rush used to be npm-only. Today, Rush recommends using pnpm, which is also the default client when setting up a monorepo with Rush.</p>
<p lang="en-GB">To work efficiently with Rush, a global installation of the tool is recommended:</p>
<pre class="console" lang="en-GB">
$ npm install -g @microsoft/rush</pre>
<p lang="en-GB">After a successful installation, the <code>rush</code> command-line utility can be used. As with <code>npm</code>, an <code>init</code> subcommand to actually initialize a new project exists:</p>
<pre class="console" lang="en-GB">
$ rush init</pre>
<p lang="en-GB">This will create and update a couple of files. Most notably, you’ll find a <code>rush.json</code> file in the current folder. This file needs to be edited next. However, before you continue, make sure to remove the files you don’t need. For instance, Rush added a <code>.travis.yml</code>, which can be useful if you use Travis for your CI/CD pipelines. In case you don’t know what Travis is or you know already that you don’t want to use Travis, just delete that file.</p>
<p lang="en-GB">Since with Rush, every<a id="_idIndexMarker340"/> package is added explicitly, there is no direct need for a <code>packages</code> subfolder. If you still prefer to group the contained packages in this way, you can of course do so.</p>
<p lang="en-GB">In order to make Rush aware of the contained packages, we need to edit the <code>rush.json</code> file in the root folder. In our case, we want to add two new packages:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">rush.json</p>
<pre class="source-code" lang="en-GB">{
  // keep the rest as is
  "projects": [
    {
      "packageName": "p1",
      "projectFolder": "packages/p1"
    },
    {
      "packageName": "p2",
      "projectFolder": "packages/p2"
    }
  ]
}</pre>
<p lang="en-GB">Once the file is saved, you can run the following command – just make sure that the given directories really exist and contain a valid <code>package.json</code> file:</p>
<pre class="console" lang="en-GB">
$ rush update</pre>
<p lang="en-GB">Among the given output, you should see some output containing messages similar to the ones we’ve seen when we introduced pnpm. As mentioned, under the hood, Rush uses <code>pnpm</code> to make package installation quite efficient.</p>
<p lang="en-GB">Adding or updating a <a id="_idIndexMarker341"/>dependency in a package involves running <code>rush add</code> within the package directory. Let’s say that we want to add <code>react-router</code> to <code>p1</code>:</p>
<pre class="console" lang="en-GB">
$ cd packages/p1

$ rush add --package react-router</pre>
<p lang="en-GB">To run commands, Rush comes with two primitives. One is the generic <code>rushx</code> command, which can be seen as a wrapper around <code>npm run</code>. Let’s say the <code>p1</code> package defines a <code>hello</code> command as follows:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">packages/p1/package.json</p>
<pre class="source-code" lang="en-GB">{
  // as beforehand
  "scripts": {
    "hello": "echo 'Hi!'"
  }
}</pre>
<p lang="en-GB">Running this script can be done as follows:</p>
<pre class="console" lang="en-GB">
$ cd packages/p1 &amp;&amp; rushx hello

Found configuration in /home/node/examples/Chapter09/example02/rush.json

Rush Multi-Project Build Tool 5.68.2 - Node.js 14.19.2 (LTS)

&gt; "echo 'Hi!'"

Hi!</pre>
<p lang="en-GB">The other primitive is to use in-built commands such as <code>rush build</code> or <code>rush rebuild</code>. They assume that<a id="_idIndexMarker342"/> every package contains a <code>build</code> script. While the <code>rebuild</code> command will run all the <code>build</code> scripts, the <code>build</code> command actually uses a cache to enable an incremental build process – as in, reuse as much as possible from the output of the previous run.</p>
<p lang="en-GB">While Rush is very restrictive and requires taking possession of the whole repository, an alternative is to use a more lightweight tool such as Turborepo.</p>
<h1 id="_idParaDest-96" lang="en-GB"><a id="_idTextAnchor095"/>Integrating Turborepo instead of or with Lerna</h1>
<p lang="en-GB">So far, we’ve seen quite a <a id="_idIndexMarker343"/>variety of tools in this chapter. While the workspaces feature of modern npm clients is already more than sufficient for smaller monorepos, larger ones require more dedicated tools to be manageable. In <a id="_idIndexMarker344"/>cases where Lerna is a bit too simplistic and Rush is too opinionated, another alternative exists – <strong class="bold" lang="">Turborepo</strong>, or Turbo for short. It can be seen as a replacement for or an addition to Lerna.</p>
<p lang="en-GB">Starting from scratch is rather easy – Turbo comes with an npm initializer:</p>
<pre class="console" lang="en-GB">
$ npm init turbo</pre>
<p lang="en-GB">This will open a command-line survey and scaffold the directory with some sample code. In the end, you should see a couple of new files being created, such as a <code>turbo.json</code> or a <code>package.json</code> file. Furthermore, Turbo creates <code>apps</code> and <code>packages</code> directories containing some sample code.</p>
<p lang="en-GB">Let’s show the strength of Turbo by running the <code>build</code> script:</p>
<pre class="console" lang="en-GB">
$ npx turbo run build</pre>
<p lang="en-GB">In contrast to Lerna, this will not run the <code>build</code> script in each package – following the package graph. Instead, this will run one of the pipelines defined in <code>turbo.json</code>. In there, you can see the following:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">turbo.json</p>
<pre class="source-code" lang="en-GB">{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    },
    "lint": {
      "outputs": []
    },
    "dev": {
      "cache": false
    }
  }
}</pre>
<p lang="en-GB">The given <code>pipeline</code> property defines a set of Turbo <code>build</code> pipelines. Every given key (in the definition here, <code>build</code>, <code>lint</code>, and <code>dev</code>) can then be run via <code>turbo run</code>. The specifics of each pipeline are specified by its given <a id="_idIndexMarker345"/>value. For instance, the <code>dev</code> pipeline does not use a cache, while the <code>lint</code> pipeline does not produce any outputs. By default, each pipeline runs a script with the same name in each package.</p>
<p lang="en-GB">The <code>build</code> pipeline here <a id="_idIndexMarker346"/>specifies some output directories that are cached to perform incremental builds. It also specifies that the <code>build</code> script has to be run in dependencies before it can run in the current package. Therefore, if you have two packages, <code>p1</code> and <code>p2</code>, where <code>p1</code> depends on <code>p2</code>, the build script of <code>p2</code> needs to run before the build script of <code>p1</code> can be invoked.</p>
<p lang="en-GB">Besides the “in a different workspace” dependency (e.g., <code>^build</code>), you can also specify “in the same workspace.” For instance, if the build script depends on a <code>prebuild</code> script, you’d just write <code>prebuild</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">turbo.json</p>
<pre class="source-code" lang="en-GB">{
  "pipeline": {
    "build": {
      "dependsOn": ["^build", "prebuild"]
    }
}</pre>
<p lang="en-GB">The <code>turbo run</code> command can also invoke multiple commands at the same time:</p>
<pre class="console" lang="en-GB">
$ npx lerna turbo lint build</pre>
<p lang="en-GB">The result is a pretty efficient <a id="_idIndexMarker347"/>run since <code>lint</code> does not specify<a id="_idIndexMarker348"/> dependencies – so all linting can be done in parallel, while the build is executed hierarchically. The idea is illustrated in <em class="italic" lang="">Figure 9</em><em class="italic" lang="">.4</em>:</p>
<div><div><img alt="Figure 9.4 – Task planning and execution from Turbo " src="img/Figure_9.4_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Task planning and execution from Turbo</p>
<p lang="en-GB">Turbo is not the only<a id="_idIndexMarker349"/> tool that can be used to make monorepos more efficient. A good alternative that goes beyond<a id="_idIndexMarker350"/> task running is Nx.</p>
<h1 id="_idParaDest-97" lang="en-GB"><a id="_idTextAnchor096"/>Managing a monorepo with Nx to enhance Lerna</h1>
<p lang="en-GB">Earlier in this chapter when we discussed Lerna, one thing we did not mention is that there is a special key in <code>lerna.json</code>, which is called <code>useNx</code> and configured to be <code>true</code>. This is a new addition to Lerna <em class="italic" lang="">5</em>, which is now<a id="_idIndexMarker351"/> maintained by the people behind Nx – another popular solution for managing monorepos. So, what does this actually bring and how can it enhance Lerna – or any other monorepo management tool?</p>
<p class="callout-heading" lang="en-GB">With Lerna or without?</p>
<p class="callout" lang="en-GB">Nx does not depend on Lerna and the use of Nx within Lerna is also optional. Therefore, the two technologies can be seen as non-exclusive – rather, they complete each other. In the end, it is your choice to decide which technologies you’d like to use. The example in this section, for instance, does not use Lerna.</p>
<p lang="en-GB">We start with a new repository again. This time, we’ll use the <code>nx-workspace</code> npm initializer provided by Nx:</p>
<pre class="console" lang="en-GB">
$ npm init nx-workspace -- --preset=react

<img alt="" src="img/016.png"/> Workspace name (e.g., org name)     · example05

<img alt="" src="img/016.png"/> Application name                    · example

<img alt="" src="img/016.png"/> Default stylesheet format           · css

<img alt="" src="img/016.png"/> Enable distributed caching to make your CI faster · Yes

[...]</pre>
<p lang="en-GB">As with Turbo, we get a <a id="_idIndexMarker352"/>command-line survey. The initial preset (in this case, <code>react</code>) defines some of the questions that appear. There are other similarities to Turbo, too. For instance, running something is done via <code>nx</code>, such as the following:</p>
<pre class="console" lang="en-GB">
$ npx nx build</pre>
<p lang="en-GB">This will look for the Nx <code>build</code> task executor of the current application (in this case, <code>example</code>) in a given environment (by default, <code>production</code>). Here is an explicitly written example:</p>
<pre class="console" lang="en-GB">
$ npx nx run example:build:production</pre>
<p lang="en-GB">The task executor is specified in the <code>project.json</code> of a package. Nx uses plugins to actually run these executors; in the case of our sample project with the <code>react</code> preset, the <code>@nrwl/webpack</code> package is used as the plugin.</p>
<p lang="en-GB">In order for Nx to work, each package requires either a <code>package.json</code> or a <code>project.json</code> file. Both can be specified, too. In this case, Nx will actually merge them internally to get the desired configuration. Usually, you’d want a <code>package.json</code> if you wanted to use npm scripts. The <code>project.json</code> file contains Nx task executors, which are a bit more<a id="_idIndexMarker353"/> powerful, but unfortunately, are beyond the scope of this quick introduction.</p>
<p lang="en-GB">Let’s stop here and recap what we learned in this chapter.</p>
<h1 id="_idParaDest-98" lang="en-GB"><a id="_idTextAnchor097"/>Summary</h1>
<p lang="en-GB">In this chapter, you learned how to organize multiple Node.js projects in a single repository known as a monorepo. You’ve seen different techniques and tools for maximizing efficiency and dealing with multiple packages and their dependencies.</p>
<p lang="en-GB">You are now ready to deal with the largest code bases available. Independent of whether a code base just uses workspaces with one of the npm clients or some other tool such as Lerna on top of it, you are able to understand its structure, run commands, and add new packages in no time.</p>
<p lang="en-GB">In the next chapter, we will conclude with a look at WebAssembly, which not only offers a lot of flexibility for code running in the browser but can also be used to run arbitrary languages in Node.js.</p>
</div>
</body></html>