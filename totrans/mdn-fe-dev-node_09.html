<html><head></head><body>
<div id="_idContainer113">
<h1 class="chapter-number" id="_idParaDest-89" lang="en-GB"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.1.1">9</span></h1>
<h1 id="_idParaDest-90" lang="en-GB"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.2.1">Structuring Code in Monorepos</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.3.1">In the previous chapter, you learned about everything to create and publish great libraries and tools to enhance your projects. </span><span class="koboSpan" id="kobo.3.2">While some packages are created in a bit of vacuum, most already have a consuming application in mind. </span><span class="koboSpan" id="kobo.3.3">In this case, having two separate repositories – that is, one for the application and one for the library – is quite some overhead. </span><span class="koboSpan" id="kobo.3.4">After all, any change to the library should be at least partially tested before the library is published. </span><span class="koboSpan" id="kobo.3.5">A good way to make this relation more efficient is to structure this code in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.4.1">a monorepo.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.5.1">A </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.6.1">monorepo</span></strong><span class="koboSpan" id="kobo.7.1"> is a single code repository that hosts multiple projects. </span><span class="koboSpan" id="kobo.7.2">Since we focus on Node.js projects, we can say that a monorepo is a repository containing multiple packages identified by their </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.8.1">own </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.9.1">package.json</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.10.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.11.1">Today, monorepos are frequently used to power some of the largest Node.js project code bases in the world. </span><span class="koboSpan" id="kobo.11.2">If you want to properly read and contribute to projects such as Angular, React, or Vue, you’ll need extensive knowledge about monorepos and the tools that make monorepos possible. </span><span class="koboSpan" id="kobo.11.3">For your own projects, a good structure – quite often provided by implementing monorepos – can also </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.12.1">be crucial.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.13.1">We will cover the following key topics in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.14.1">this chapter:</span></span></p>
<ul>
<li lang="en-GB"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.15.1">Understanding monorepos</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.16.1">Using workspaces to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.17.1">implement monorepos</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.18.1">Working with Lerna to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.19.1">manage monorepos</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.20.1">Working with Rush for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.21.1">larger repositories</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.22.1">Integrating Turborepo instead of or </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.23.1">with Lerna</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.24.1">Managing a monorepo with Nx to </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.25.1">enhance Lerna</span></span></li>
</ul>
<h1 id="_idParaDest-91" lang="en-GB"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.26.1">Technical requirements</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.27.1">The complete source code for this chapter is available </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.28.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter09"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter09</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.30.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.31.1">The CiA videos for this chapter can be accessed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.32.1">at </span></span><a href="https://bit.ly/3EjGZTL"><span class="No-Break" lang=""><span class="koboSpan" id="kobo.33.1">https://bit.ly/3EjGZTL</span></span></a><span class="No-Break" lang=""><span class="koboSpan" id="kobo.34.1">.</span></span></p>
<h1 id="_idParaDest-92" lang="en-GB"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.35.1">Understanding monorepos</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.36.1">The structure of a dedicated</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.37.1"> repository has always been very similar; we have a single </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.38.1">package.json</span></strong><span class="koboSpan" id="kobo.39.1"> in the root, a single </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.40.1">node_modules</span></strong><span class="koboSpan" id="kobo.41.1"> folder containing the resolved dependencies, and a set of source and configuration files, usually scattered between the root and some specific folders such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.42.1">src</span></strong><span class="koboSpan" id="kobo.43.1">. </span><span class="koboSpan" id="kobo.43.2">A quite popular setup is shown in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.44.1">Figure 9</span></em></span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.45.1">.1</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.46.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer105">
<span class="koboSpan" id="kobo.47.1"><img alt="Figure 9.1 – Common setup for a repository with a single package " src="image/Figure_9.1_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.48.1">Figure 9.1 – Common setup for a repository with a single package</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.49.1">In the common setup, we have some folders for CI/CD pipeline definitions and potential tools that are useful for managing the repository, as well as auxiliary files such as project documentation. </span><span class="koboSpan" id="kobo.49.2">Of course, for a Node.js project, we’ll see a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.50.1">node_modules</span></strong><span class="koboSpan" id="kobo.51.1"> directory, as well as a </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.52.1">package.json</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.53.1"> file.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.54.1">In contrast, a monorepo will contain multiple </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.55.1">package.json</span></strong><span class="koboSpan" id="kobo.56.1"> files with multiple </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.57.1">node_modules</span></strong><span class="koboSpan" id="kobo.58.1"> (or alternative) folders. </span><span class="koboSpan" id="kobo.58.2">Likewise, the source files and potentially some of the configuration will also </span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.59.1">be scattered across multiple locations. </span><span class="koboSpan" id="kobo.59.2">A very common structure is shown in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.60.1">Figure 9</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.61.1">.2</span></em><span class="koboSpan" id="kobo.62.1"> for the main part and </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.63.1">Figure 9</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.64.1">.3</span></em><span class="koboSpan" id="kobo.65.1"> for the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.66.1">individual packages:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer106">
<span class="koboSpan" id="kobo.67.1"><img alt="Figure 9.2 – Common setup for a repository with multiple packages " src="image/Figure_9.2_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.68.1">Figure 9.2 – Common setup for a repository with multiple packages</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.69.1">In comparison to </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.70.1">Figure 9</span></em></span><em class="italic" lang=""><span class="koboSpan" id="kobo.71.1">.1</span></em><span class="koboSpan" id="kobo.72.1">, the hierarchy of the outlined folders is a bit more sophisticated. </span><span class="koboSpan" id="kobo.72.2">Now, we don’t see the source files immediately and need to descend into some of the directories inside the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.73.1">packages</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.74.1"> folder:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer107">
<span class="koboSpan" id="kobo.75.1"><img alt="Figure 9.3 – The contents of the individual package directories " src="image/Figure_9.3_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.76.1">Figure 9.3 – The contents of the individual package directories</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.77.1">Ideally, the packages contained in a monorepo are crafted in such a way that makes them rather easy to extract</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.78.1"> later on. </span><span class="koboSpan" id="kobo.78.2">Let’s say you have a specific library in your monorepo that should now be handled by another team. </span><span class="koboSpan" id="kobo.78.3">If your monorepo was created to serve as the single point of development for your current team, then transferring this library </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.79.1">makes sense.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.80.1">Quite often, common development concerns, such as the usual packages contained in the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.81.1">devDependencies</span></strong><span class="koboSpan" id="kobo.82.1"> of a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.83.1">package.json</span></strong><span class="koboSpan" id="kobo.84.1"> file, are concentrated in a dedicated </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.85.1">package.json </span></strong><span class="koboSpan" id="kobo.86.1">file. </span><span class="koboSpan" id="kobo.86.2">In many monorepos, this </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.87.1">package.json</span></strong><span class="koboSpan" id="kobo.88.1"> file is found in the root directory of the monorepo. </span><span class="koboSpan" id="kobo.88.2">While this pattern makes sense from a maintenance point of view, it can also bring up challenges when it comes to library extraction. </span><span class="koboSpan" id="kobo.88.3">After all, you’ll now need to decide what dependencies to add to restore the development capability of the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.89.1">extracted library.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.90.1">In general, multiple challenges make supporting monorepos a task of its own. </span><span class="koboSpan" id="kobo.90.2">Here are some of the most</span><a id="_idIndexMarker321"/> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.91.1">pressing concerns:</span></span></p>
<ol>
<li lang="en-GB"><span class="koboSpan" id="kobo.92.1">How are dependencies efficiently shared to avoid installing the same dependencies over and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.93.1">over again?</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.94.1">How can packages be treated as if they are dependencies installed from </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.95.1">a registry?</span></span></li>
<li lang="en-GB"><span class="koboSpan" id="kobo.96.1">How can common tasks such as build steps be run in a way that </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.97.1">works consistently?</span></span></li>
</ol>
<p lang="en-GB"><span class="koboSpan" id="kobo.98.1">Let’s go through these one by one. </span><span class="koboSpan" id="kobo.98.2">For (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.99.1">1</span></em><span class="koboSpan" id="kobo.100.1">), the idea is that monorepos can be more efficient than just having many different directories, where you’d need to run </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.101.1">npm install</span></strong><span class="koboSpan" id="kobo.102.1"> in each of them. </span><span class="koboSpan" id="kobo.102.2">Running </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.103.1">npm install</span></strong><span class="koboSpan" id="kobo.104.1"> in each directory would be a massive overhead, duplicating not only direct dependencies but also indirect ones – that is, dependencies of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.105.1">installed dependencies.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.106.1">While (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.107.1">1</span></em><span class="koboSpan" id="kobo.108.1">) is only a performance (installation time and disk space) concern, the issue with (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.109.1">2</span></em><span class="koboSpan" id="kobo.110.1">) is developer convenience. </span><span class="koboSpan" id="kobo.110.2">The reason for having a monorepo in the first place is to have packages that depend on one another in close proximity. </span><span class="koboSpan" id="kobo.110.3">This way, a bug should be visible at development time, rather than later at integration time when a package has already been published. </span><span class="koboSpan" id="kobo.110.4">The usual mechanism of npm for this is to use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.111.1">npm link</span></strong><span class="koboSpan" id="kobo.112.1"> command, which will make a local package globally available for referencing. </span><span class="koboSpan" id="kobo.112.2">There are, however, multiple downsides to this mechanism. </span><span class="koboSpan" id="kobo.112.3">Additionally, it is not very convenient to use this command for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.113.1">every package.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.114.1">Finally, the dependencies between the packages in a monorepo require special attention when running commands. </span><span class="koboSpan" id="kobo.114.2">In terms of (</span><em class="italic" lang=""><span class="koboSpan" id="kobo.115.1">3</span></em><span class="koboSpan" id="kobo.116.1">), tasks such as building the source code need to be performed in reverse reference order. </span><span class="koboSpan" id="kobo.116.2">This means, that in the case that package </span><em class="italic" lang=""><span class="koboSpan" id="kobo.117.1">A</span></em><span class="koboSpan" id="kobo.118.1"> depends on package </span><em class="italic" lang=""><span class="koboSpan" id="kobo.119.1">B</span></em><span class="koboSpan" id="kobo.120.1">, the build process of package </span><em class="italic" lang=""><span class="koboSpan" id="kobo.121.1">B</span></em><span class="koboSpan" id="kobo.122.1"> needs to be done before package </span><em class="italic" lang=""><span class="koboSpan" id="kobo.123.1">A</span></em><span class="koboSpan" id="kobo.124.1"> is built. </span><span class="koboSpan" id="kobo.124.2">The reason is that through the dependency, the content of package </span><em class="italic" lang=""><span class="koboSpan" id="kobo.125.1">A</span></em><span class="koboSpan" id="kobo.126.1"> may only build successfully if the content of package </span><em class="italic" lang=""><span class="koboSpan" id="kobo.127.1">B</span></em><span class="koboSpan" id="kobo.128.1"> has been fully created – that is, the package has been built. </span><span class="koboSpan" id="kobo.128.2">Similar constraints arise for testing and when publishing </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.129.1">a package.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.130.1">With this in mind, let’s start with one of the easiest options for implementing a monorepo: leveraging the workspaces feature that comes with the most popular </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.131.1">npm clients.</span></span></p>
<h1 id="_idParaDest-93" lang="en-GB"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.132.1">Using workspaces to implement monorepos</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.133.1">As the need for </span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.134.1">monorepos grew, npm clients tried to help users by incorporating them. </span><span class="koboSpan" id="kobo.134.2">The first of the big three was </span><em class="italic" lang=""><span class="koboSpan" id="kobo.135.1">Yarn</span></em><span class="koboSpan" id="kobo.136.1">. </span><span class="koboSpan" id="kobo.136.2">Already, with the first </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.137.1">version of Yarn, a new </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.138.1">concept called </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.139.1">Yarn workspaces</span></strong><span class="koboSpan" id="kobo.140.1"> was introduced, which was represented by a special field called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.141.1">workspaces</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.142.1">in </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.143.1">package.json</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.144.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.145.1">package.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.146.1">{
  "name": "monorepo-root",
  "private": true,
  "workspaces": [
    "packages/*"
  ]
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.147.1">Yarn workspaces require a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.148.1">package.json</span></strong><span class="koboSpan" id="kobo.149.1"> at the root directory of the monorepo. </span><span class="koboSpan" id="kobo.149.2">This </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.150.1">package.json</span></strong><span class="koboSpan" id="kobo.151.1"> won’t be used for publishing and needs to have the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.152.1">private</span></strong><span class="koboSpan" id="kobo.153.1"> field set to </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.154.1">true</span></strong><span class="koboSpan" id="kobo.155.1">. </span><span class="koboSpan" id="kobo.155.2">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.156.1">workspaces</span></strong><span class="koboSpan" id="kobo.157.1"> field itself is an array that contains the paths to the different packages. </span><span class="koboSpan" id="kobo.157.2">Wildcards using the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.158.1">*</span></strong><span class="koboSpan" id="kobo.159.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.160.1">**</span></strong><span class="koboSpan" id="kobo.161.1"> symbols – as shown here – </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.162.1">are allowed.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.163.1">With npm </span><em class="italic" lang=""><span class="koboSpan" id="kobo.164.1">v7</span></em><span class="koboSpan" id="kobo.165.1">, the standard npm client also received a workspaces feature. </span><span class="koboSpan" id="kobo.165.2">The feature is pretty much the same as the implementation in Yarn. </span><span class="koboSpan" id="kobo.165.3">Here, we need to have a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.166.1">package.json</span></strong><span class="koboSpan" id="kobo.167.1"> in the root, too. </span><span class="koboSpan" id="kobo.167.2">Likewise, the behavior is controlled by a </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.168.1">workspaces</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.169.1"> field.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.170.1">Finally, the implementation in </span><em class="italic" lang=""><span class="koboSpan" id="kobo.171.1">pnpm</span></em><span class="koboSpan" id="kobo.172.1"> is a bit different. </span><span class="koboSpan" id="kobo.172.2">Here, we need a dedicated file called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.173.1">pnpm-workspace.yaml</span></strong><span class="koboSpan" id="kobo.174.1">. </span><span class="koboSpan" id="kobo.174.2">This file contains the paths to the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.175.1">different packages:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.176.1">pnpm-workspace.yaml</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.177.1">packages:
  - 'packages/*'</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.178.1">In contrast to the other two npm clients, with pnpm, you don’t need a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.179.1">package.json</span></strong><span class="koboSpan" id="kobo.180.1"> file in the root directory. </span><span class="koboSpan" id="kobo.180.2">Since the workspaces definition is in a separate file, this file alone is sufficient to enable the workspaces feature </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.181.1">of pnpm.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.182.1">To illustrate that, let’s create</span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.183.1"> a new directory and add the preceding </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.184.1">pnpm-workspace.yaml</span></strong><span class="koboSpan" id="kobo.185.1"> file to it. </span><span class="koboSpan" id="kobo.185.2">Then, create a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.186.1">packages</span></strong><span class="koboSpan" id="kobo.187.1"> subfolder. </span><span class="koboSpan" id="kobo.187.2">In there, add two</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.188.1"> more folders, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.189.1">p1</span></strong><span class="koboSpan" id="kobo.190.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.191.1">p2</span></strong><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">In each of these directories, run </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.193.1">npm init -y</span></strong><span class="koboSpan" id="kobo.194.1">. </span><span class="koboSpan" id="kobo.194.2">You can now modify the contained </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.195.1">package.json</span></strong><span class="koboSpan" id="kobo.196.1"> files, adding some dependencies </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.197.1">to both.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.198.1">From the root directory with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.199.1">pnpm-workspace.yaml</span></strong><span class="koboSpan" id="kobo.200.1"> file, run </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.201.1">the following:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.202.1">
$ pnpm install

Scope: all 2 workspace projects

Packages: +5

+++++

Packages are hard linked from the content-addressable store to the virtual store.

</span><span class="koboSpan" id="kobo.202.2">  Content-addressable store is at: /home/node/.local/share/pnpm/store/v3

  Virtual store is at:             node_modules/.pnpm

Progress: resolved 5, reused 5, downloaded 0, added 5, done</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.203.1">While editing the respective </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.204.1">package.json</span></strong><span class="koboSpan" id="kobo.205.1"> file is always possible, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.206.1">pnpm</span></strong><span class="koboSpan" id="kobo.207.1"> also makes it easy to add a dependency to some contained package – or workspace in the terminology </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.208.1">of pnpm.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.209.1">Let’s say you want to add </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.210.1">react-dom</span></strong><span class="koboSpan" id="kobo.211.1"> to the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.212.1">p1</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.213.1"> workspace:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.214.1">
$ pnpm add react-dom --filter p1

No projects matched the filters "/home/node/ Chapter09/example01" in "/home/node/Chapter09/example01"

.                                        |   +2 +

Progress: resolved 5, reused 5, downloaded 0, added 0, done</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.215.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.216.1">--filter</span></strong><span class="koboSpan" id="kobo.217.1"> argument allows you to select the workspaces where the dependency should be added. </span><span class="koboSpan" id="kobo.217.2">While</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.218.1"> full names are accepted, the names can</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.219.1"> also be specified with </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.220.1">wildcards (</span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.221.1">*</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.222.1">).</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.223.1">Specifying dependencies in monorepos</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.224.1">Dependencies on other packages contained in the same monorepo are declared just like any other dependency – in the corresponding </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.225.1">package.json</span></strong><span class="koboSpan" id="kobo.226.1"> fields, such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.227.1">dependencies</span></strong><span class="koboSpan" id="kobo.228.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.229.1">devDependencies</span></strong><span class="koboSpan" id="kobo.230.1">. </span><span class="koboSpan" id="kobo.230.2">The specified version, however, is crucial here. </span><span class="koboSpan" id="kobo.230.3">You need to make sure to either match the version of the referenced package (e.g., </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.231.1">1.2.3</span></strong><span class="koboSpan" id="kobo.232.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.233.1">^1.0.0</span></strong><span class="koboSpan" id="kobo.234.1"> would both correctly match a package in version </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.235.1">1.2.3</span></strong><span class="koboSpan" id="kobo.236.1">) or use the wildcard specifier </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.237.1">*</span></strong><span class="koboSpan" id="kobo.238.1">. </span><span class="koboSpan" id="kobo.238.2">Today, most package managers also support the special workspace protocol. </span><span class="koboSpan" id="kobo.238.3">With this, you can write </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.239.1">workspace:*</span></strong><span class="koboSpan" id="kobo.240.1"> instead of a version to link against a package in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.241.1">another workspace.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.242.1">The workspaces option is certainly appealing to optimize packages and make their linking quite easy; however, it fails to make common monorepo tasks more approachable or convenient. </span><span class="koboSpan" id="kobo.242.2">An alternative is to use a tool such as </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.243.1">Lerna</span></strong><span class="koboSpan" id="kobo.244.1"> on top of </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.245.1">a workspace.</span></span></p>
<h1 id="_idParaDest-94" lang="en-GB"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.246.1">Working with Lerna to manage monorepos</span></h1>
<p lang="en-GB"><strong class="bold" lang=""><span class="koboSpan" id="kobo.247.1">Lerna</span></strong><span class="koboSpan" id="kobo.248.1"> is one of the oldest tools for</span><a id="_idIndexMarker329"/><span class="koboSpan" id="kobo.249.1"> managing monorepos. </span><span class="koboSpan" id="kobo.249.2">We can even say to some degree that Lerna not only made monorepos manageable but also popular. </span><span class="koboSpan" id="kobo.249.3">Lerna is</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.250.1"> the backbone of some of the most important monorepos, such as Jest. </span><span class="koboSpan" id="kobo.250.2">It also was the original choice for projects such as </span><em class="italic" lang=""><span class="koboSpan" id="kobo.251.1">Babel</span></em> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.252.1">or </span></span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.253.1">React</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.254.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.255.1">Originally, Lerna was mainly picked because it correctly installed and resolved all the packages. </span><span class="koboSpan" id="kobo.255.2">At this time, no package manager was capable of doing that intrinsically. </span><span class="koboSpan" id="kobo.255.3">However, today, Lerna is most often used together with the workspace features offered by the different package managers. </span><span class="koboSpan" id="kobo.255.4">Of course, you can still use the original mode of Lerna, where plain </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.256.1">npm</span></strong><span class="koboSpan" id="kobo.257.1"> is used to install and link the different packages. </span><span class="koboSpan" id="kobo.257.2">So, how does Lerna fit into this new role when the whole installation is done by the chosen package </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.258.1">manager anyway?</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.259.1">It turns out that Lerna is a really great task-running layer on top of a package manager. </span><span class="koboSpan" id="kobo.259.2">For instance, running a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.260.1">package.json</span></strong><span class="koboSpan" id="kobo.261.1"> script such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.262.1">build</span></strong><span class="koboSpan" id="kobo.263.1"> in all the contained packages is as straightforward as invoking </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.264.1">the following:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.265.1">
$ npx lerna run build</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.266.1">This would only run the </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.267.1">script in the packages that contain this </span><a id="_idIndexMarker332"/><span class="koboSpan" id="kobo.268.1">kind of script. </span><span class="koboSpan" id="kobo.268.2">In comparison, Yarn would actually error out if one of the packages did not have a </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.269.1">build</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.270.1"> script.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.271.1">To get started with Lerna, you need to initialize the current repository as a Lerna monorepo. </span><span class="koboSpan" id="kobo.271.2">For this, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.272.1">init</span></strong><span class="koboSpan" id="kobo.273.1"> command can </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.274.1">be used:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.275.1">
$ npx lerna init</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.276.1">Once initialized, the repository should contain a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.277.1">lerna.json</span></strong><span class="koboSpan" id="kobo.278.1"> and a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.279.1">package.json</span></strong><span class="koboSpan" id="kobo.280.1"> file. </span><span class="koboSpan" id="kobo.280.2">By inspecting these files, you’ll notice that </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.281.1">lerna.json</span></strong><span class="koboSpan" id="kobo.282.1"> contains a version (by default </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.283.1">0.0.0</span></strong><span class="koboSpan" id="kobo.284.1">), but </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.285.1">package.json</span></strong><span class="koboSpan" id="kobo.286.1"> does not. </span><span class="koboSpan" id="kobo.286.2">This is intentional. </span><span class="koboSpan" id="kobo.286.3">Lerna will actually manage the version here. </span><span class="koboSpan" id="kobo.286.4">The default choice is uniform versioning – that is, all packages will always get the same version. </span><span class="koboSpan" id="kobo.286.5">The other option is independent versioning. </span><span class="koboSpan" id="kobo.286.6">Here, each package can have its own version number. </span><span class="koboSpan" id="kobo.286.7">This is handy if different packages have their own </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.287.1">release cycle.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.288.1">To enable independent versioning, we can </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.289.1">change </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.290.1">lerna.json</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.291.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.292.1">lerna.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.293.1">{
  // ... </span><span class="koboSpan" id="kobo.293.2">as beforehand
  "version": "independent"
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.294.1">Alternatively, we could also initialize the repository using the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.295.1">--independent</span></strong><span class="koboSpan" id="kobo.296.1"> flag for the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.297.1">lerna </span></strong><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.298.1">init</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.299.1"> command.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.300.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.301.1">package.json</span></strong><span class="koboSpan" id="kobo.302.1"> file contains the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.303.1">workspaces</span></strong><span class="koboSpan" id="kobo.304.1"> property. </span><span class="koboSpan" id="kobo.304.2">By default, this is configured to include all directories from the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.305.1">package</span></strong><span class="koboSpan" id="kobo.306.1"> directory as packages. </span><span class="koboSpan" id="kobo.306.2">In the given configuration, Lerna would use npm as a package manager. </span><span class="koboSpan" id="kobo.306.3">In any case, the whole package management is left to an actual </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.307.1">npm client.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.308.1">As mentioned, Lerna is really good at running tasks. </span><span class="koboSpan" id="kobo.308.2">What else is considered a strength of Lerna? </span><span class="koboSpan" id="kobo.308.3">The whole publishing and</span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.309.1"> version management. </span><span class="koboSpan" id="kobo.309.2">We’ve already </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.310.1">seen that Lerna knows two modes: independent and uniform versioning. </span><span class="koboSpan" id="kobo.310.2">In the independent versioning mode, Lerna will check the published versions with the current version that is about to be published. </span><span class="koboSpan" id="kobo.310.3">Only in the case of a new version will the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.311.1">publish</span></strong><span class="koboSpan" id="kobo.312.1"> command </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.313.1">actually run.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.314.1">Let’s see how the packages from the previous example would actually be published with Lerna. </span><span class="koboSpan" id="kobo.314.2">We’ll use a local registry running Verdaccio </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.315.1">for this:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.316.1">
$ npx lerna publish --registry http://localhost:4873

lerna notice cli v5.5.2

lerna info versioning independent

lerna info Looking for changed packages since p1@1.0.1

? </span><span class="koboSpan" id="kobo.316.2">Select a new version for p1 (currently 0.0.0) Major (1.0.0)

? </span><span class="koboSpan" id="kobo.316.3">Select a new version for p2 (currently 0.0.0) Major (1.0.0)

Changes:

 - p1: 0.0.0 =&gt; 1.0.0

 - p2: 0.0.0 =&gt; 1.0.0

? </span><span class="koboSpan" id="kobo.316.4">Are you sure you want to publish these packages? </span><span class="koboSpan" id="kobo.316.5">Yes

lerna info execute Skipping releases

lerna info git Pushing tags...

</span><span class="koboSpan" id="kobo.316.6">lerna info publish Publishing packages to npm...

</span><span class="koboSpan" id="kobo.316.7">[...]

Successfully published:

 - p1@1.0.0

 - p2@1.0.0

lerna success published 2 packages</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.317.1">Without additional flags, Lerna will guide us through the whole publishing process. </span><span class="koboSpan" id="kobo.317.2">As we specified independent versioning, the tool </span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.318.1">will ask us the version to pick for each contained package. </span><span class="koboSpan" id="kobo.318.2">In the</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.319.1"> case here, we selected </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.320.1">1.0.0</span></strong><span class="koboSpan" id="kobo.321.1"> for </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.322.1">both packages.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.323.1">Lerna also does a bit more than just running </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.324.1">npm publish</span></strong><span class="koboSpan" id="kobo.325.1"> for each package. </span><span class="koboSpan" id="kobo.325.2">It is strongly related to </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.326.1">Git</span></strong><span class="koboSpan" id="kobo.327.1"> as a version control system. </span><span class="koboSpan" id="kobo.327.2">It also ties the publish to the current commit and marks the publish via Git tags, which are automatically pushed to a potential origin such </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.328.1">as </span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.329.1">GitHub</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.330.1">.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.331.1">Another thing that Lerna brings to the table is extensive information about a monorepo. </span><span class="koboSpan" id="kobo.331.2">Since Lerna needs to know which packages exist and what their relations are quite well, it also makes sense that this information is exposed </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.332.1">to us.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.333.1">A great command to use to see what exists in the current monorepo is </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.334.1">lerna list</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.335.1">:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.336.1">
$ npx lerna list --graph

lerna notice cli v5.5.2

lerna info versioning independent

{

  "p1": [

    "react",

    "react-dom"

  ],

  "p2": [

    "react",

    "react-dom"

  ]

}

lerna success found 2 packages</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.337.1">There are multiple options – all geared to fine-tune what information to include, exclude, and how to represent it. </span><span class="koboSpan" id="kobo.337.2">Ultimately, this is </span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.338.1">designed to make consumption in many ways possible. </span><span class="koboSpan" id="kobo.338.2">Independent of whether you consume this from </span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.339.1">a script or directly, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.340.1">lerna</span></strong><span class="koboSpan" id="kobo.341.1"> tool has the right options to present the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.342.1">data accordingly.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.343.1">Lerna has certainly been established as one of the go-to options for handling monorepos; however, its configuration options can be daunting, and making it efficient in a larger repository could be troublesome. </span><span class="koboSpan" id="kobo.343.2">An alternative is to use an opinionated tool instead. </span><span class="koboSpan" id="kobo.343.3">One of the best options in this category </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.344.1">is </span></span><span class="No-Break" lang=""><strong class="bold" lang=""><span class="koboSpan" id="kobo.345.1">Rush</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.346.1">.</span></span></p>
<h1 id="_idParaDest-95" lang="en-GB"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.347.1">Working with Rush for larger repositories</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.348.1">While Lerna provided a</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.349.1"> lot of the utility that made monorepos possible at all, its configuration and flexibility also posed some challenges. </span><span class="koboSpan" id="kobo.349.2">Furthermore, finding best practices proved to be difficult. </span><span class="koboSpan" id="kobo.349.3">Consequently, plenty of quite opinionated alternatives to using Lerna have been born. </span><span class="koboSpan" id="kobo.349.4">One of the most successful ones is Rush </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.350.1">from Microsoft.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.351.1">Rush allows a variety of npm clients to be used. </span><span class="koboSpan" id="kobo.351.2">Classically, Rush used to be npm-only. </span><span class="koboSpan" id="kobo.351.3">Today, Rush recommends using pnpm, which is also the default client when setting up a monorepo </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.352.1">with Rush.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.353.1">To work efficiently with Rush, a global installation of the tool </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.354.1">is recommended:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.355.1">
$ npm install -g @microsoft/rush</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.356.1">After a successful installation, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.357.1">rush</span></strong><span class="koboSpan" id="kobo.358.1"> command-line utility can be used. </span><span class="koboSpan" id="kobo.358.2">As with </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.359.1">npm</span></strong><span class="koboSpan" id="kobo.360.1">, an </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.361.1">init</span></strong><span class="koboSpan" id="kobo.362.1"> subcommand to actually initialize a new </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.363.1">project exists:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.364.1">
$ rush init</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.365.1">This will create and update a couple of files. </span><span class="koboSpan" id="kobo.365.2">Most notably, you’ll find a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.366.1">rush.json</span></strong><span class="koboSpan" id="kobo.367.1"> file in the current folder. </span><span class="koboSpan" id="kobo.367.2">This file needs to be edited next. </span><span class="koboSpan" id="kobo.367.3">However, before you continue, make sure to remove the files you don’t need. </span><span class="koboSpan" id="kobo.367.4">For instance, Rush added a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.368.1">.travis.yml</span></strong><span class="koboSpan" id="kobo.369.1">, which can be useful if you use Travis for your CI/CD pipelines. </span><span class="koboSpan" id="kobo.369.2">In case you don’t know what Travis is or you know already that you don’t want to use Travis, just delete </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.370.1">that file.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.371.1">Since with Rush, every</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.372.1"> package is added explicitly, there is no direct need for a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.373.1">packages</span></strong><span class="koboSpan" id="kobo.374.1"> subfolder. </span><span class="koboSpan" id="kobo.374.2">If you still prefer to group the contained packages in this way, you can of course </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.375.1">do so.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.376.1">In order to make Rush aware of the contained packages, we need to edit the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.377.1">rush.json</span></strong><span class="koboSpan" id="kobo.378.1"> file in the root folder. </span><span class="koboSpan" id="kobo.378.2">In our case, we want to add two </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.379.1">new packages:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.380.1">rush.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.381.1">{
  // keep the rest as is
  "projects": [
    {
      "packageName": "p1",
      "projectFolder": "packages/p1"
    },
    {
      "packageName": "p2",
      "projectFolder": "packages/p2"
    }
  ]
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.382.1">Once the file is saved, you can run the following command – just make sure that the given directories really exist and contain a valid </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.383.1">package.json</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.384.1"> file:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.385.1">
$ rush update</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.386.1">Among the given output, you should see some output containing messages similar to the ones we’ve seen when we introduced pnpm. </span><span class="koboSpan" id="kobo.386.2">As mentioned, under the hood, Rush uses </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.387.1">pnpm</span></strong><span class="koboSpan" id="kobo.388.1"> to make package installation </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.389.1">quite efficient.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.390.1">Adding or updating a </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.391.1">dependency in a package involves running </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.392.1">rush add</span></strong><span class="koboSpan" id="kobo.393.1"> within the package directory. </span><span class="koboSpan" id="kobo.393.2">Let’s say that we want to add </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.394.1">react-router</span></strong> <span class="No-Break" lang=""><span class="koboSpan" id="kobo.395.1">to </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.396.1">p1</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.397.1">:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.398.1">
$ cd packages/p1

$ rush add --package react-router</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.399.1">To run commands, Rush comes with two primitives. </span><span class="koboSpan" id="kobo.399.2">One is the generic </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.400.1">rushx</span></strong><span class="koboSpan" id="kobo.401.1"> command, which can be seen as a wrapper around </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.402.1">npm run</span></strong><span class="koboSpan" id="kobo.403.1">. </span><span class="koboSpan" id="kobo.403.2">Let’s say the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.404.1">p1</span></strong><span class="koboSpan" id="kobo.405.1"> package defines a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.406.1">hello</span></strong><span class="koboSpan" id="kobo.407.1"> command </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.408.1">as follows:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.409.1">packages/p1/package.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.410.1">{
  // as beforehand
  "scripts": {
    "hello": "echo 'Hi!'"
</span><span class="koboSpan" id="kobo.410.2">  }
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.411.1">Running this script can be done </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.412.1">as follows:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.413.1">
$ cd packages/p1 &amp;&amp; rushx hello

Found configuration in /home/node/examples/Chapter09/example02/rush.json

Rush Multi-Project Build Tool 5.68.2 - Node.js 14.19.2 (LTS)

&gt; "echo 'Hi!'"

</span><span class="koboSpan" id="kobo.413.2">Hi!</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.414.1">The other primitive is to use in-built commands such as </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.415.1">rush build</span></strong><span class="koboSpan" id="kobo.416.1"> or </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.417.1">rush rebuild</span></strong><span class="koboSpan" id="kobo.418.1">. </span><span class="koboSpan" id="kobo.418.2">They assume that</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.419.1"> every package contains a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.420.1">build</span></strong><span class="koboSpan" id="kobo.421.1"> script. </span><span class="koboSpan" id="kobo.421.2">While the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.422.1">rebuild</span></strong><span class="koboSpan" id="kobo.423.1"> command will run all the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.424.1">build</span></strong><span class="koboSpan" id="kobo.425.1"> scripts, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.426.1">build</span></strong><span class="koboSpan" id="kobo.427.1"> command actually uses a cache to enable an incremental build process – as in, reuse as much as possible from the output of the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.428.1">previous run.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.429.1">While Rush is very restrictive and requires taking possession of the whole repository, an alternative is to use a more lightweight tool such </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.430.1">as Turborepo.</span></span></p>
<h1 id="_idParaDest-96" lang="en-GB"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.431.1">Integrating Turborepo instead of or with Lerna</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.432.1">So far, we’ve seen quite a </span><a id="_idIndexMarker343"/><span class="koboSpan" id="kobo.433.1">variety of tools in this chapter. </span><span class="koboSpan" id="kobo.433.2">While the workspaces feature of modern npm clients is already more than sufficient for smaller monorepos, larger ones require more dedicated tools to be manageable. </span><span class="koboSpan" id="kobo.433.3">In </span><a id="_idIndexMarker344"/><span class="koboSpan" id="kobo.434.1">cases where Lerna is a bit too simplistic and Rush is too opinionated, another alternative exists – </span><strong class="bold" lang=""><span class="koboSpan" id="kobo.435.1">Turborepo</span></strong><span class="koboSpan" id="kobo.436.1">, or Turbo for short. </span><span class="koboSpan" id="kobo.436.2">It can be seen as a replacement for or an addition </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.437.1">to Lerna.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.438.1">Starting from scratch is rather easy – Turbo comes with an </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.439.1">npm initializer:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.440.1">
$ npm init turbo</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.441.1">This will open a command-line survey and scaffold the directory with some sample code. </span><span class="koboSpan" id="kobo.441.2">In the end, you should see a couple of new files being created, such as a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.442.1">turbo.json</span></strong><span class="koboSpan" id="kobo.443.1"> or a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.444.1">package.json</span></strong><span class="koboSpan" id="kobo.445.1"> file. </span><span class="koboSpan" id="kobo.445.2">Furthermore, Turbo creates </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.446.1">apps</span></strong><span class="koboSpan" id="kobo.447.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.448.1">packages</span></strong><span class="koboSpan" id="kobo.449.1"> directories containing some </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.450.1">sample code.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.451.1">Let’s show the strength of Turbo by running the </span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.452.1">build</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.453.1"> script:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.454.1">
$ npx turbo run build</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.455.1">In contrast to Lerna, this will not run the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.456.1">build</span></strong><span class="koboSpan" id="kobo.457.1"> script in each package – following the package graph. </span><span class="koboSpan" id="kobo.457.2">Instead, this will run one of the pipelines defined in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.458.1">turbo.json</span></strong><span class="koboSpan" id="kobo.459.1">. </span><span class="koboSpan" id="kobo.459.2">In there, you can see </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.460.1">the following:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.461.1">turbo.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.462.1">{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**", ".next/**"]
    },
    "lint": {
      "outputs": []
    },
    "dev": {
      "cache": false
    }
  }
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.463.1">The given </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.464.1">pipeline</span></strong><span class="koboSpan" id="kobo.465.1"> property defines a set of Turbo </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.466.1">build</span></strong><span class="koboSpan" id="kobo.467.1"> pipelines. </span><span class="koboSpan" id="kobo.467.2">Every given key (in the definition here, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.468.1">build</span></strong><span class="koboSpan" id="kobo.469.1">, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.470.1">lint</span></strong><span class="koboSpan" id="kobo.471.1">, and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.472.1">dev</span></strong><span class="koboSpan" id="kobo.473.1">) can then be run via </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.474.1">turbo run</span></strong><span class="koboSpan" id="kobo.475.1">. </span><span class="koboSpan" id="kobo.475.2">The specifics of each pipeline are specified by its given </span><a id="_idIndexMarker345"/><span class="koboSpan" id="kobo.476.1">value. </span><span class="koboSpan" id="kobo.476.2">For instance, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.477.1">dev</span></strong><span class="koboSpan" id="kobo.478.1"> pipeline does not use a cache, while the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.479.1">lint</span></strong><span class="koboSpan" id="kobo.480.1"> pipeline does not produce any outputs. </span><span class="koboSpan" id="kobo.480.2">By default, each pipeline runs a script with the same name in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.481.1">each package.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.482.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.483.1">build</span></strong><span class="koboSpan" id="kobo.484.1"> pipeline here </span><a id="_idIndexMarker346"/><span class="koboSpan" id="kobo.485.1">specifies some output directories that are cached to perform incremental builds. </span><span class="koboSpan" id="kobo.485.2">It also specifies that the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.486.1">build</span></strong><span class="koboSpan" id="kobo.487.1"> script has to be run in dependencies before it can run in the current package. </span><span class="koboSpan" id="kobo.487.2">Therefore, if you have two packages, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.488.1">p1</span></strong><span class="koboSpan" id="kobo.489.1"> and </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.490.1">p2</span></strong><span class="koboSpan" id="kobo.491.1">, where </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.492.1">p1</span></strong><span class="koboSpan" id="kobo.493.1"> depends on </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.494.1">p2</span></strong><span class="koboSpan" id="kobo.495.1">, the build script of </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.496.1">p2</span></strong><span class="koboSpan" id="kobo.497.1"> needs to run before the build script of </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.498.1">p1</span></strong><span class="koboSpan" id="kobo.499.1"> can </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.500.1">be invoked.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.501.1">Besides the “in a different workspace” dependency (e.g., </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.502.1">^build</span></strong><span class="koboSpan" id="kobo.503.1">), you can also specify “in the same workspace.” </span><span class="koboSpan" id="kobo.503.2">For instance, if the build script depends on a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.504.1">prebuild</span></strong><span class="koboSpan" id="kobo.505.1"> script, you’d just </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.506.1">write </span></span><span class="No-Break" lang=""><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.507.1">prebuild</span></strong></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.508.1">:</span></span></p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.509.1">turbo.json</span></p>
<pre class="source-code" lang="en-GB"><span class="koboSpan" id="kobo.510.1">{
  "pipeline": {
    "build": {
      "dependsOn": ["^build", "prebuild"]
    }
}</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.511.1">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.512.1">turbo run</span></strong><span class="koboSpan" id="kobo.513.1"> command can also invoke multiple commands at the </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.514.1">same time:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.515.1">
$ npx lerna turbo lint build</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.516.1">The result is a pretty efficient </span><a id="_idIndexMarker347"/><span class="koboSpan" id="kobo.517.1">run since </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.518.1">lint</span></strong><span class="koboSpan" id="kobo.519.1"> does not specify</span><a id="_idIndexMarker348"/><span class="koboSpan" id="kobo.520.1"> dependencies – so all linting can be done in parallel, while the build is executed hierarchically. </span><span class="koboSpan" id="kobo.520.2">The idea is illustrated in </span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.521.1">Figure 9</span></em></span><span class="No-Break" lang=""><em class="italic" lang=""><span class="koboSpan" id="kobo.522.1">.4</span></em></span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.523.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer108">
<span class="koboSpan" id="kobo.524.1"><img alt="Figure 9.4 – Task planning and execution from Turbo " src="image/Figure_9.4_B18989.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.525.1">Figure 9.4 – Task planning and execution from Turbo</span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.526.1">Turbo is not the only</span><a id="_idIndexMarker349"/><span class="koboSpan" id="kobo.527.1"> tool that can be used to make monorepos more efficient. </span><span class="koboSpan" id="kobo.527.2">A good alternative that goes beyond</span><a id="_idIndexMarker350"/><span class="koboSpan" id="kobo.528.1"> task running </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.529.1">is Nx.</span></span></p>
<h1 id="_idParaDest-97" lang="en-GB"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.530.1">Managing a monorepo with Nx to enhance Lerna</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.531.1">Earlier in this chapter when we discussed Lerna, one thing we did not mention is that there is a special key in </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.532.1">lerna.json</span></strong><span class="koboSpan" id="kobo.533.1">, which is called </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.534.1">useNx</span></strong><span class="koboSpan" id="kobo.535.1"> and configured to be </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.536.1">true</span></strong><span class="koboSpan" id="kobo.537.1">. </span><span class="koboSpan" id="kobo.537.2">This is a new addition to Lerna </span><em class="italic" lang=""><span class="koboSpan" id="kobo.538.1">5</span></em><span class="koboSpan" id="kobo.539.1">, which is now</span><a id="_idIndexMarker351"/><span class="koboSpan" id="kobo.540.1"> maintained by the people behind Nx – another popular solution for managing monorepos. </span><span class="koboSpan" id="kobo.540.2">So, what does this actually bring and how can it enhance Lerna – or any other monorepo </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.541.1">management tool?</span></span></p>
<p class="callout-heading" lang="en-GB"><span class="koboSpan" id="kobo.542.1">With Lerna or without?</span></p>
<p class="callout" lang="en-GB"><span class="koboSpan" id="kobo.543.1">Nx does not depend on Lerna and the use of Nx within Lerna is also optional. </span><span class="koboSpan" id="kobo.543.2">Therefore, the two technologies can be seen as non-exclusive – rather, they complete each other. </span><span class="koboSpan" id="kobo.543.3">In the end, it is your choice to decide which technologies you’d like to use. </span><span class="koboSpan" id="kobo.543.4">The example in this section, for instance, does not </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.544.1">use Lerna.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.545.1">We start with a new repository again. </span><span class="koboSpan" id="kobo.545.2">This time, we’ll use the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.546.1">nx-workspace</span></strong><span class="koboSpan" id="kobo.547.1"> npm initializer provided </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.548.1">by Nx:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.549.1">
$ npm init nx-workspace -- --preset=react

</span><span class="koboSpan" id="kobo.550.1"><img alt="" src="image/016.png"/></span><span class="koboSpan" id="kobo.551.1"> Workspace name (e.g., org name)     · example05

</span><span class="koboSpan" id="kobo.552.1"><img alt="" src="image/016.png"/></span><span class="koboSpan" id="kobo.553.1"> Application name                    · example

</span><span class="koboSpan" id="kobo.554.1"><img alt="" src="image/016.png"/></span><span class="koboSpan" id="kobo.555.1"> Default stylesheet format           · css

</span><span class="koboSpan" id="kobo.556.1"><img alt="" src="image/016.png"/></span><span class="koboSpan" id="kobo.557.1"> Enable distributed caching to make your CI faster · Yes

[...]</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.558.1">As with Turbo, we get a </span><a id="_idIndexMarker352"/><span class="koboSpan" id="kobo.559.1">command-line survey. </span><span class="koboSpan" id="kobo.559.2">The initial preset (in this case, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.560.1">react</span></strong><span class="koboSpan" id="kobo.561.1">) defines some of the questions that appear. </span><span class="koboSpan" id="kobo.561.2">There are other similarities to Turbo, too. </span><span class="koboSpan" id="kobo.561.3">For instance, running something is done via </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.562.1">nx</span></strong><span class="koboSpan" id="kobo.563.1">, such as </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.564.1">the following:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.565.1">
$ npx nx build</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.566.1">This will look for the Nx </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.567.1">build</span></strong><span class="koboSpan" id="kobo.568.1"> task executor of the current application (in this case, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.569.1">example</span></strong><span class="koboSpan" id="kobo.570.1">) in a given environment (by default, </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.571.1">production</span></strong><span class="koboSpan" id="kobo.572.1">). </span><span class="koboSpan" id="kobo.572.2">Here is an explicitly </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.573.1">written example:</span></span></p>
<pre class="console" lang="en-GB"><span class="koboSpan" id="kobo.574.1">
$ npx nx run example:build:production</span></pre>
<p lang="en-GB"><span class="koboSpan" id="kobo.575.1">The task executor is specified in the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.576.1">project.json</span></strong><span class="koboSpan" id="kobo.577.1"> of a package. </span><span class="koboSpan" id="kobo.577.2">Nx uses plugins to actually run these executors; in the case of our sample project with the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.578.1">react</span></strong><span class="koboSpan" id="kobo.579.1"> preset, the </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.580.1">@nrwl/webpack</span></strong><span class="koboSpan" id="kobo.581.1"> package is used as </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.582.1">the plugin.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.583.1">In order for Nx to work, each package requires either a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.584.1">package.json</span></strong><span class="koboSpan" id="kobo.585.1"> or a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.586.1">project.json</span></strong><span class="koboSpan" id="kobo.587.1"> file. </span><span class="koboSpan" id="kobo.587.2">Both can be specified, too. </span><span class="koboSpan" id="kobo.587.3">In this case, Nx will actually merge them internally to get the desired configuration. </span><span class="koboSpan" id="kobo.587.4">Usually, you’d want a </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.588.1">package.json</span></strong><span class="koboSpan" id="kobo.589.1"> if you wanted to use npm scripts. </span><span class="koboSpan" id="kobo.589.2">The </span><strong class="source-inline" lang=""><span class="koboSpan" id="kobo.590.1">project.json</span></strong><span class="koboSpan" id="kobo.591.1"> file contains Nx task executors, which are a bit more</span><a id="_idIndexMarker353"/><span class="koboSpan" id="kobo.592.1"> powerful, but unfortunately, are beyond the scope of this </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.593.1">quick introduction.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.594.1">Let’s stop here and recap what we learned in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.595.1">this chapter.</span></span></p>
<h1 id="_idParaDest-98" lang="en-GB"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.596.1">Summary</span></h1>
<p lang="en-GB"><span class="koboSpan" id="kobo.597.1">In this chapter, you learned how to organize multiple Node.js projects in a single repository known as a monorepo. </span><span class="koboSpan" id="kobo.597.2">You’ve seen different techniques and tools for maximizing efficiency and dealing with multiple packages and </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.598.1">their dependencies.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.599.1">You are now ready to deal with the largest code bases available. </span><span class="koboSpan" id="kobo.599.2">Independent of whether a code base just uses workspaces with one of the npm clients or some other tool such as Lerna on top of it, you are able to understand its structure, run commands, and add new packages in </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.600.1">no time.</span></span></p>
<p lang="en-GB"><span class="koboSpan" id="kobo.601.1">In the next chapter, we will conclude with a look at WebAssembly, which not only offers a lot of flexibility for code running in the browser but can also be used to run arbitrary languages </span><span class="No-Break" lang=""><span class="koboSpan" id="kobo.602.1">in Node.js.</span></span></p>
</div>
</body></html>