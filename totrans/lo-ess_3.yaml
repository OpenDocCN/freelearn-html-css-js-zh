- en: Chapter 3. Working with Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：与函数一起工作
- en: You'll find functions everywhere within a sufficiently large piece of JavaScript
    code. That's because they're treated in the same way as any other primitive type.
    Everything is an object in JavaScript, including functions. Functions have a context
    and a prototype, and they can be assigned to a new context and to variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在足够大的JavaScript代码块中到处找到函数。这是因为它们被当作任何其他原始类型一样对待。在JavaScript中，一切都是对象，包括函数。函数有一个上下文和原型，并且可以被分配到新的上下文和变量中。
- en: Lo-Dash helps to best utilize functions. Where there are missing pieces, the
    utilities that Lo-Dash provides let us write some truly elegant, functional code.
    This chapter dives into these utilities. Whether we're changing the meaning of
    `this` or decorating an existing function, we'll walk through examples that illustrate
    how to get started.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash帮助最佳利用函数。在缺少部分的情况下，Lo-Dash提供的实用工具让我们能够编写真正优雅的函数式代码。本章深入探讨这些实用工具。无论我们是改变`this`的含义还是装饰现有的函数，我们都会通过示例说明如何开始。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Binding function contexts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定函数上下文
- en: Decorating functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰函数
- en: Function constraints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数约束
- en: Timed execution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时执行
- en: Composing and currying functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合和柯里化函数
- en: Binding function contexts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定函数上下文
- en: Every JavaScript function has a context. If you're coming from an object-oriented
    language, the function context is a lot like the object a method belongs to. The
    difference of course is that JavaScript doesn't classify objects in the object-oriented
    sense of the concept. Instead, functions are bound to a default context, and this
    can easily be changed at runtime. There are even built-in language mechanisms
    to make this happen.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个JavaScript函数都有一个上下文。如果你来自面向对象的语言，函数上下文与一个方法所属的对象非常相似。当然，区别在于JavaScript并不在面向对象的概念意义上对对象进行分类。相反，函数绑定到一个默认上下文，并且这个上下文可以很容易地在运行时改变。甚至有内置的语言机制来实现这一点。
- en: Lo-Dash makes changing function contexts easy. We'll need to work with function
    contexts often when programming with Lo-Dash. We'll take a look at a number of
    approaches to working with and changing the context of functions now.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash使改变函数上下文变得容易。在用Lo-Dash编程时，我们经常需要处理函数上下文。现在我们将探讨几种处理和改变函数上下文的方法。
- en: Changing the this keyword
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变`this`关键字
- en: Inside a function, the execution context is referred to by the `this` keyword.
    This is a special binding that we don't need to declare. It's always available
    to reference within a given function scope. It's important to keep in mind that
    it's entirely up to the caller, should he/she decide to override the meaning of
    `this`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，执行上下文通过`this`关键字来引用。这是一个我们不需要声明的特殊绑定。它始终在给定的函数作用域内可用。重要的是要记住，如果调用者决定覆盖`this`的含义，那么这完全取决于调用者。
- en: 'The `bind()` function is a powerful way to construct a new function that is
    permanently bound to the specified context. Here''s a first look at how `bind()`
    works:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`bind()`函数是一种强大的方式，可以构建一个永久绑定到指定上下文的新函数。以下是如何`bind()`工作的初步了解：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code defines a generic `sayWhat()` function that formats a string
    message based on the context for the function. In particular, it looks for the
    `what` property of the context. Next we use `bind()` to define two new functions
    based on `sayWhat()`. The `sayHello()` function is bound to a new context, while
    the `sayGoodbye()` function is bound to yet another context. The second argument
    to `bind()` is the object that becomes `this` in the function that's being bound.
    We can see that each of these contexts defines a unique `what` property value
    and this is reflected in the output of calling these two functions.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码定义了一个通用的`sayWhat()`函数，它根据函数的上下文格式化字符串消息。特别是，它寻找上下文的`what`属性。接下来我们使用`bind()`根据`sayWhat()`定义两个新的函数。`sayHello()`函数绑定到一个新的上下文，而`sayGoodbye()`函数绑定到另一个上下文。`bind()`的第二个参数是函数绑定时成为`this`的对象。我们可以看到，每个上下文都定义了一个独特的`what`属性值，并且这在调用这两个函数的输出中得到了反映。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Without Lo-Dash, we would rely on the `call()`, `apply()`, or `bind()` methods
    of the function to change its context. The advantage with the Lo-Dash `bind()`
    implementation is that it performs better because it's able to optimize better
    than the native methods.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 没有Lo-Dash，我们将依赖于函数的`call()`、`apply()`或`bind()`方法来改变其上下文。Lo-Dash `bind()`实现的优点是它性能更好，因为它能够比原生方法进行更好的优化。
- en: 'The `sayWhat()` function didn''t make use of any arguments. But just because
    we''re fiddling with contexts doesn''t mean the function we''re binding can''t
    accept arguments. Many functions make use of both arguments passed by the caller
    and the context object. Functions with custom contexts can indeed accept arguments.
    They can also be called with additional arguments after being bound to a new context,
    as shown in the following code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayWhat()` 函数没有使用任何参数。但仅仅因为我们正在玩弄上下文并不意味着我们绑定的函数不能接受参数。许多函数同时使用调用者传递的参数和上下文对象。具有自定义上下文的函数确实可以接受参数。它们也可以在绑定到新的上下文后使用额外的参数调用，如下面的代码所示：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `sayWhat()` function accepts a `what` parameter used to construct the string
    message. If this parameter is not supplied, it falls back to the `what` property
    of the context. Now we define three new functions, all with unique context and
    argument constraints. The `sayHello()` function isn't any different from the previous
    example; the `what` value is in the context. The `sayGoodbye()` function definition
    passes a third argument to `bind()`. After the context object, `bind()` will accept
    any number of arguments that are also bound to the function, but in a different
    way. This is called **partial application**, and we'll look at this later on in
    the chapter. The function is always bound, not only to the context, but to the
    argument values as well. Lastly, the `saySomething()` function is bound to a context
    that lacks the `what` property. Also, it is not bound to any `what` parameter.
    However, the `what` argument can still be supplied when the function is called,
    as is the case here.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayWhat()` 函数接受一个 `what` 参数，用于构建字符串消息。如果未提供此参数，则回退到上下文的 `what` 属性。现在我们定义了三个新的函数，它们都具有独特的上下文和参数约束。`sayHello()`
    函数与前面的例子没有区别；`what` 值在上下文中。`sayGoodbye()` 函数定义传递了 `bind()` 的第三个参数。在上下文对象之后，`bind()`
    将接受任何数量的参数，这些参数也被绑定到函数上，但以不同的方式。这被称为**部分应用**，我们将在本章后面讨论这一点。函数始终绑定到上下文，同时也绑定到参数值。最后，`saySomething()`
    函数绑定到一个缺少 `what` 属性的上下文。此外，它也没有绑定到任何 `what` 参数。然而，当函数被调用时，仍然可以提供 `what` 参数，就像这里的情况一样。'
- en: Binding methods
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定方法
- en: There are no methods, per se, in JavaScript—just functions and context. However,
    that doesn't prevent programmers from following a more traditional object-oriented
    model.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中本身没有方法——只有函数和上下文。然而，这并不妨碍程序员遵循更传统的面向对象模型。
- en: 'If we assign a function to an object property, that object then becomes the
    context for the function. This is just the default behavior, and as the previous
    section illustrated, the context can change. However, the object to which the
    function belongs, being the default context, maps well to methods and encapsulation.
    The `bindAll()` function can help enforce this mapping:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将函数分配给对象属性，那么该对象就成为函数的上下文。这只是默认行为，正如前节所示，上下文可以改变。然而，函数所属的对象，作为默认上下文，很好地映射到方法和封装。`bindAll()`
    函数可以帮助强制这种映射：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's walk through the bits of this experiment. The goal is to illustrate that
    once the `bindAll()` function is applied to an object, all methods belonging to
    that object have the context glued to it. It cannot change after this. First,
    the `bindName()` function just takes another function and binds it to the `Becky`
    context. We'll use this later on to prove a point.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步分析这个实验。目标是说明一旦将 `bindAll()` 函数应用于对象，该对象的所有方法都将绑定到它，并且上下文不能改变。首先，`bindName()`
    函数只是接受另一个函数并将其绑定到 `Becky` 上下文。我们将在稍后用它来证明一个观点。
- en: The `object` variable holds a plain object with some simple properties and a
    simple method. The `name` variable is a function defined using the `bindName()`
    function. Notice that we're taking the `object.name()` method and assigning it
    a new context. The values we put in the `result` object confirm this. Next is
    the call to `bindAll()` on `object`. From this point onward, the `name()` method
    context can't change—it's glued to `object`. We then proceed to prove this fact
    by trying to bind it to a new context again, but `bindAll()` has enforced the
    context.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`object` 变量包含一个具有一些简单属性和简单方法的普通对象。`name` 变量是使用 `bindName()` 函数定义的函数。请注意，我们正在将
    `object.name()` 方法赋予一个新的上下文。我们放入 `result` 对象中的值证实了这一点。接下来是调用 `object` 上的 `bindAll()`。从这一点开始，`name()`
    方法的上下文不能再改变——它被固定在 `object` 上。然后我们通过再次尝试将其绑定到新的上下文来证明这一事实，但 `bindAll()` 强制了上下文。'
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using `bindAll()`, you can unintentionally break other functionality in
    your application. The ability to change function context is a strength, not a
    weakness. Use `bindAll()` when you're absolutely certain that the method context
    should never change. If there's little to no chance of your method context changing
    when it shouldn't, don't bother with `bindAll()`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `bindAll()` 时，你可能会无意中破坏应用程序中的其他功能。改变函数上下文的能力是一种优势，而不是弱点。只有在你绝对确定方法上下文永远不会改变时才使用
    `bindAll()`。如果方法上下文不应该改变时改变的可能性很小，那么没有必要使用 `bindAll()`。
- en: 'The name `bindAll()` implies that this is an all or nothing operation, which
    actually isn''t the case. We don''t have to enforce the context of every method
    attached to your object. We can actually specify the method names as a second
    argument and only these methods are glued to the object context. This is illustrated
    in the following example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 `bindAll()` 表明这是一个全有或全无的操作，但实际上并非如此。我们不必强制每个附加到对象上的方法的上下文。我们实际上可以指定方法名称作为第二个参数，并且只有这些方法被绑定到对象上下文中。以下示例说明了这一点：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can see that the call to `bindAll()` specifies that only `method1` and `method2`
    are bound to `object`. Later on, we actually try binding `method3` to a completely
    new context and it works as expected. Had we not limited the `bindAll()` call
    to specific methods, we wouldn't have been able to change the context of `method3`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`bindAll()` 的调用指定了只有 `method1` 和 `method2` 被绑定到 `object` 上。稍后，我们实际上尝试将
    `method3` 绑定到一个全新的上下文，并且它按预期工作。如果我们没有将 `bindAll()` 调用限制为特定方法，我们就无法改变 `method3`
    的上下文。
- en: Dynamic methods
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态方法
- en: 'Methods can also lazily bind to objects. We can use the `bindKey()` function
    to construct a new function that will call the given method name on the given
    object. The method doesn''t actually have to exist prior to calling `bindKey()`.
    That''s the lazy part. And this comes in handy if you need to assign a method
    as a callback but aren''t exactly sure if the method exists yet. Consider the
    following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也可以懒绑定到对象上。我们可以使用 `bindKey()` 函数构建一个新的函数，该函数将在给定的对象上调用给定的方法名称。该方法实际上在调用 `bindKey()`
    之前不必存在。这就是懒绑定部分。如果你需要将方法作为回调分配，但不确定该方法是否已经存在，这会很有用。以下是一个示例：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we have an object with an `age` property. We also have a `workLeft()` function
    that computes a number based on the `age` property of the context. We could assign
    this function directly to the `work` property, but we've instead used the `bindKey()`
    function to construct a new function that will reference the `work()` method when
    called. The crucial thing to note is that we're able to build this callback function
    before the `work()` method exists in `object`. It gets added later. It could also
    get swapped out for a different implementation and would still call the appropriate
    method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个具有 `age` 属性的对象。我们还有一个 `workLeft()` 函数，它根据上下文的 `age` 属性计算一个数字。我们可以直接将这个函数分配给
    `work` 属性，但我们已经使用 `bindKey()` 函数构建了一个新的函数，当调用时将引用 `work()` 方法。需要注意的是，我们能够在 `object`
    中 `work()` 方法存在之前构建这个回调函数。它稍后会被添加。它也可以被替换为不同的实现，并且仍然会调用适当的方法。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The bound key has to exist when the function created by `bindKey()` is eventually
    called. Otherwise, you'll get a `TypeError`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `bindKey()` 创建的函数最终被调用时，绑定的键必须存在。否则，你会得到一个 `TypeError`。
- en: 'Just like a function that has been bound to a context using the `bind()` function,
    we still have freedom with the way arguments are managed. That is, we can bind
    argument values or supply argument values when the bound function is called, as
    shown in the following code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用 `bind()` 函数将函数绑定到上下文一样，我们在管理参数方面仍然拥有自由度。也就是说，当调用绑定的函数时，我们可以绑定参数值或提供参数值，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `workLeft()` function depends on a couple of arguments and the `age` property
    of the context. Next, we define a collection of objects and a couple of empty
    arrays to perform our experiment. Now we have three `forEach()` iterations that
    demonstrate how arguments work with `bindKey()`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`workLeft()` 函数依赖于几个参数和上下文的 `age` 属性。接下来，我们定义了一组对象和几个空数组来执行我们的实验。现在我们有三个 `forEach()`
    迭代，展示了参数如何与 `bindKey()` 一起工作。'
- en: The first iteration is over the collection and is where the `bindKey()` function
    is applied in order to generate a `work()` method. We can see that not every object
    in the collection has a `retirement` property value. If it doesn't, we bind `65`
    as the argument value. At this point, we have an array of functions, each bound
    to the `work()` method of their object. The second iteration populates the `work`
    property of each object in the collection, so now `work()` is a callable function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次迭代是遍历集合，并在其中应用 `bindKey()` 函数以生成 `work()` 方法。我们可以看到，集合中的不是每个对象都有 `retirement`
    属性值。如果没有，我们将其绑定为 `65` 作为参数值。此时，我们有一个函数数组，每个函数都绑定到其对象的 `work()` 方法。第二次迭代填充集合中每个对象的
    `work` 属性，因此现在 `work()` 成为一个可调用的函数。
- en: The last iteration calls each of these bound method functions with another argument.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次迭代使用另一个参数调用每个这些绑定方法函数。
- en: Decorating functions
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰函数
- en: A decorator does what the name implies. It decorates functions with additional
    capabilities. It's like an adornment for a piece of functionality. For example,
    let's say we've already implemented a function that looks up data in some structure.
    It's already used throughout our application, but now we're implementing a new
    component that requires this same functionality and something extra. We can use
    the function-decorating tools provided by Lo-Dash to take existing functions and
    extend them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的作用正如其名，它为函数添加额外的功能。它就像是对功能的一种装饰。例如，假设我们已经实现了一个在某种结构中查找数据的函数。这个函数已经在我们的应用程序中得到了使用，但现在我们正在实现一个新的组件，它需要这个相同的功能以及一些额外的功能。我们可以使用
    Lo-Dash 提供的函数装饰工具来扩展现有的函数。
- en: 'There are two flavors of Lo-Dash function decoration: **Partials**, which construct
    new functions that have the arguments of the original function partially supplied,
    and **Wrappers**, which build a new function that wraps the original function
    with a whole new function.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Lo-Dash 函数装饰有两种类型：**部分函数**，它构建具有原始函数部分参数的新函数，以及**包装器**，它构建一个新函数，该函数将原始函数包裹在一个全新的函数中。
- en: Partials
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分函数
- en: 'To create a partial function using Lo-Dash, you use the `partial()` function.
    The resulting function then has some arguments presupplied—we don''t have to supply
    them again when called. This concept is really useful when we need to dynamically
    supply arguments to a function, just before it''s passed to a new context where
    those arguments aren''t available. This is also the case with callbacks, as shown
    in the following example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Lo-Dash 创建部分函数，您使用 `partial()` 函数。生成的函数将预先提供一些参数——在调用时我们不需要再次提供。这个概念在我们需要动态向函数提供参数，尤其是在将其传递到那些参数不可用的新上下文之前时非常有用。以下示例也展示了回调函数的情况：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `sayWhat()` function builds a simple string based on the supplied string
    argument. The two calls to `partial()` that follow supply this argument. The `hello()`
    and `goodbye()` functions, when called, will call `sayWhat()` with their respective
    partial arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`sayWhat()` 函数根据提供的字符串参数构建一个简单的字符串。接下来的两个 `partial()` 调用提供了这个参数。当 `hello()`
    和 `goodbye()` 函数被调用时，它们将使用各自的局部参数调用 `sayWhat()`。'
- en: 'As we''ve seen so far in this chapter, many of the Lo-Dash functions that deal
    with functions return new ones. They also support the arguments passed by the
    caller. This is valuable because adding new parameters to our functions doesn''t
    require changes to our function bindings, as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章中迄今为止所看到的，许多处理函数的 Lo-Dash 函数返回新的函数。它们也支持调用者传递的参数。这很有价值，因为向我们的函数添加新参数不需要更改我们的函数绑定，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `greet()` function in the preceding code accepts two arguments, `greeting`
    and `name`. The `hello()` and the `goodbye()` functions are constructed as partial
    functions that call `greet()` with the first argument already supplied. Later
    on, when these functions are called, we can supply the more context-specific argument—`name`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码中的 `greet()` 函数接受两个参数，`greeting` 和 `name`。`hello()` 和 `goodbye()` 函数被构建为部分函数，它们使用已提供的第一个参数调用
    `greet()`。稍后，当这些函数被调用时，我们可以提供更具体的参数——`name`。
- en: 'What if the context-specific argument were the first function argument? Can
    we still have the caller of the partial function supply the name? To answer this
    question, we turn to the `partialRight()` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上下文特定的参数是第一个函数参数，我们还能否让部分函数的调用者提供名称？为了回答这个问题，我们转向 `partialRight()` 函数：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code looks similar to the previous example, but there is one important
    difference. The `greet()` function expects the `name` parameter as the first argument.
    We want the caller to be able to specify this value, but we also want to specify
    `greeting` as a partial argument. The `partialRight()` function works the same
    as `partial()` except that it passes arguments to the function in a different
    order.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来与上一个示例相似，但有一个重要的区别。`greet()` 函数期望 `name` 参数作为第一个参数。我们希望调用者能够指定这个值，但我们还想指定
    `greeting` 作为部分参数。`partialRight()` 函数与 `partial()` 函数的工作方式相同，除了它以不同的顺序传递参数给函数。
- en: 'Partials aren''t limited to our own functions. We can exploit this shorthand
    against Lo-Dash functionality itself. If you need to run a Lo-Dash function, in
    a callback for example, you can construct a new partial function that redefines
    the Lo-Dash function, with the arguments presupplied. This is shown in the following
    code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数不仅限于我们自己的函数。我们可以利用这种简写来对抗 Lo-Dash 功能本身。如果你需要在回调中运行 Lo-Dash 函数，例如，你可以构造一个新的部分函数，该函数重新定义了
    Lo-Dash 函数，并预先提供了参数。这在上面的代码中有所展示：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we have a simple collection and two partial functions that operate on it.
    First, we utilize the `random()` Lo-Dash function, supplying the range as partial
    arguments. Then we utilize the `sample()` function, supplying the collection to
    sample as a partial argument.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的集合和两个操作该集合的部分函数。首先，我们利用 `random()` Lo-Dash 函数，提供部分参数作为范围。然后我们利用
    `sample()` 函数，提供要采样的集合作为部分参数。
- en: Function decorators
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数装饰器
- en: 'We can utilize the `wrap()` function to decorate a value or another function
    with specific behavior. As with all other Lo-Dash function helpers, one advantage
    of using `wrap()` is that the caller of the generated function can supply more
    data via arguments, as demonstrated in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用 `wrap()` 函数来装饰值或另一个函数，使其具有特定的行为。与所有其他 Lo-Dash 函数辅助函数一样，使用 `wrap()` 的一个优点是，生成函数的调用者可以通过参数提供更多数据，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first function, `strong()`, wraps the value in `<strong/>` tags. The second
    function, `regex()`, is a little more involved. It wraps a value in a `RegExp`
    instance. But it's smart enough to do this only if the value is a string—if it's
    already a regular expression, there's no need to create another. Also, if a value
    is supplied to the second argument, it'll execute the regular expression against
    it, returning the result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数 `strong()` 将值包裹在 `<strong/>` 标签中。第二个函数 `regex()` 稍微复杂一些。它将值包裹在一个 `RegExp`
    实例中。但它足够智能，只有在值是字符串的情况下才这样做——如果它已经是一个正则表达式，就没有必要创建另一个。此外，如果提供了第二个参数，它将对该值执行正则表达式，并返回结果。
- en: The result of calling `boldName()` is self-explanatory. The value `'Marianne'`
    is wrapped with the `strong()` function. The `getNumber()` function is a result
    of wrapping a regular expression string that looks for numbers. However, the call
    to `getNumber()` supplies an additional argument, that is, the call provides a
    string to execute the regular expression against it. This is why we access the
    result using a numerical index following the call.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `boldName()` 的结果不言自明。值 `'Marianne'` 被包裹在 `strong()` 函数中。`getNumber()` 函数是包裹了一个看起来像数字的正则表达式字符串的结果。然而，对
    `getNumber()` 的调用提供了一个额外的参数，即调用提供了要对其执行正则表达式的字符串。这就是为什么我们使用调用后的数字索引来访问结果。
- en: 'Let''s turn our attention to decorating existing functions with new functionality
    using `wrap()`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向使用 `wrap()` 装饰现有函数以添加新功能：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The basic idea here is to decorate the `echo()` function with permission checking
    ability. The `permission()` function will call the function that is passed to
    it only if the `user` variable exists in the `allowed` array. An exception is
    raised if this is not the case. Repeatedly running this code will randomly generate
    denied errors. It all depends on whether `'Breanne'`, who isn't in the `allowed`
    array, is sampled as the current user or not.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基本思想是使用权限检查能力来装饰 `echo()` 函数。如果 `user` 变量存在于 `allowed` 数组中，`permission()`
    函数将只调用传递给它的函数。如果不满足这种情况，将引发异常。反复运行此代码将随机生成拒绝错误。这完全取决于 `'Breanne'`（她不在 `allowed`
    数组中）是否被采样为当前用户。
- en: Function constraints
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数约束
- en: Similar to decorating functions with new behavior are the constraints imposed
    on functions. This impacts when and how often the function can be called. Function
    constraints also control how values returned by calling a function are cached.
    Lo-Dash has functions that deal with each of these scenarios.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于用新行为装饰函数的是对函数施加的约束。这影响了函数何时以及多久可以调用。函数约束还控制了通过调用函数返回的值的缓存方式。Lo-Dash 有处理这些场景的函数。
- en: Limiting call counts
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制调用次数
- en: 'There are two Lo-Dash functions that deal with counting the number of times
    a given function is called. The `after()` function will execute a callback after
    the composed function is called a given number of times. The `once()` function
    constrains the given function to being called only once. Let''s look at `after()`
    and see how it works:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个 Lo-Dash 函数处理给定函数被调用的次数计数。`after()` 函数将在组合函数被调用指定次数后执行回调。`once()` 函数将给定的函数限制为只调用一次。让我们看看
    `after()` 并了解它是如何工作的：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `work()` function is a contrived function that actually does nothing other
    than calling `progress()`, which notifies the world that progress has been made.
    A real function that actually did work would call `progress()` after having done
    the work. Next, we have a `reportProgress()` function. It is responsible for logging
    the progress. It also creates the `progress()` function using `after()`. Until
    the `complete` variable has reached 100 percent, it'll call `reportProgress()`
    again, which redefines the `progress()` function. The `after()` function will
    call the callback function supplied to it after the `progress()` function has
    been called `x` number of times. In this case, `x` is 1 percent of the collection
    length.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`work()` 函数是一个虚构的函数，实际上它除了调用 `progress()` 以外什么都不做，这通知世界进度已经有所进展。一个真正做了工作的函数会在完成工作后调用
    `progress()`。接下来，我们有一个 `reportProgress()` 函数。它负责记录进度。它还使用 `after()` 创建了 `progress()`
    函数。直到 `complete` 变量达到 100%，它将再次调用 `reportProgress()`，这会重新定义 `progress()` 函数。`after()`
    函数将在 `progress()` 被调用 `x` 次之后调用它所提供的回调函数。在这种情况下，`x` 是集合长度的 1%。'
- en: To sum up, `reportProgress()` defines the `progress()` function. This function
    is called by worker functions that need to notify the world about their progress.
    After `progress()` has been called so many times, `reportProgress()` is called.
    This is where the progress is logged and `progress()` is redefined.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`reportProgress()` 定义了 `progress()` 函数。这个函数被需要通知世界其进度的工作函数调用。在 `progress()`
    被调用多次之后，会调用 `reportProgress()`。这是记录进度和重新定义 `progress()` 的地方。
- en: All this is put into action by creating a rather large collection and iterating
    over it, calling `work()` along the way. But before the iterating starts, we kick
    off the progress tracker by calling `reportProgress()`. One nice aspect of this
    code is that there is a separation of concerns between tracking progress and performing
    work. The worker function only needs to worry about calling `progress()`. The
    `reportProgress()` is only concerned about periodically logging the progress and
    doesn't care about the actual work being done.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都是通过创建一个相当大的集合并遍历它来实现的，在遍历过程中调用 `work()`。但在迭代开始之前，我们通过调用 `reportProgress()`
    来启动进度跟踪器。这个代码的一个优点是，在跟踪进度和执行工作之间有一个关注点的分离。工作函数只需要担心调用 `progress()`。`reportProgress()`
    只关心定期记录进度，而不关心实际的工作内容。
- en: 'Asynchronous operations can make use of `after()` as well. The previous example
    explicitly called the function that was created by `after()`. However, what if
    we want to synchronize what happens after several asynchronous callback functions
    have fired? Let''s find out using the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 异步操作也可以使用 `after()`。前面的例子明确调用了由 `after()` 创建的函数。但是，如果我们想在几个异步回调函数触发后同步发生的事情，该怎么办？让我们使用以下代码来找出答案：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'First, we have a `process()` function meant to symbolize a long-running asynchronous
    process—something that runs in the background, in other words. This function takes
    two arguments: a collection and a callback. The `callback` is a function that
    is called after each asynchronous operation on the collection has completed. We
    do this by creating a new `sync()` function using `after()`. The collection length
    is passed to `after()`. This means that after `sync()` has been called five times,
    which is the length of our collection, the callback is called.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个 `process()` 函数，它的目的是象征一个长时间运行的后台异步过程——换句话说，就是运行在后台的过程。这个函数接收两个参数：一个集合和一个回调函数。`callback`
    是一个在集合上的每个异步操作完成后被调用的函数。我们通过使用 `after()` 创建一个新的 `sync()` 函数来实现这一点。集合长度被传递给 `after()`。这意味着在
    `sync()` 被调用五次之后，即我们的集合长度，回调函数将被调用。
- en: Next, we randomly choose a timeout and call `sync()`—this is the asynchronous
    part. After all the timeouts have been set, we then log that the calls to `sync()`
    have been scheduled. The callback that executes when these are done logs a basic
    message.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们随机选择一个超时时间并调用 `sync()`——这是异步部分。在所有超时都设置完毕后，我们记录 `sync()` 的调用已被安排。当这些操作完成后，执行的回调记录一个基本消息。
- en: 'Sometimes, it''s useful to call a function just once. Beyond that, it is just
    useless repetition—harmless, but unnecessary. Therefore, a useful constraint for
    a function might be only allowing it to be called once. But how would we enforce
    such a thing? This can be done using the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，只调用一次函数是有用的。除此之外，它只是无用的重复——无害，但不是必要的。因此，一个函数的一个有用的约束可能是只允许它被调用一次。但我们如何强制执行这样的规则呢？这可以通过以下代码来完成：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `getLeader()` function in this code takes a collection and returns the name
    of the leader, according to the `score` property. We use this function to construct
    the `leader()` function. Using `once()`, we tell the `leader()` function to only
    call `getLeader()` once, and only once. You can't prevent the caller from making
    50 calls to these functions. The job of the `once()` function is to encapsulate
    the function passed to it, storing the return value of the first invocation. If
    this value is set, it's cached for subsequent calls. So the preceding code assumes
    that the collection is unchanging and the leader will always be the same.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`getLeader()` 函数接收一个集合并返回领导者的名字，根据的是 `score` 属性。我们使用这个函数来构建 `leader()`
    函数。使用 `once()`，我们告诉 `leader()` 函数只调用一次 `getLeader()`，并且只调用一次。你无法阻止调用者对这些函数进行50次调用。`once()`
    函数的职责是封装传递给它的函数，存储第一次调用的返回值。如果这个值被设置，它将被缓存以供后续调用。因此，前面的代码假设集合是不变的，领导者将始终相同。
- en: Caching values
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存值
- en: 'The preceding example gave the first glimpse into caching values with Lo-Dash.
    If the function is constrained to be called only once, it might as well store
    the value of that first invocation. This is almost caching as a side effect—there''s
    a more explicit approach that uses the `memoize()` function. Explicit caching
    is especially useful for mathematical functions, where given the same input, the
    same output is always produced. This is also referred to as **referential transparency**.
    An example for this is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了使用 Lo-Dash 缓存值的第一个例子。如果函数被限制只能调用一次，那么存储第一次调用的值可能就足够了。这几乎是一种副作用式的缓存——有一个更明确的办法，使用
    `memoize()` 函数。显式缓存对于数学函数特别有用，因为给定相同的输入，总是产生相同的输出。这也被称为 **引用透明性**。以下是一个例子：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we have two simple mathematical functions and they are good candidates
    for **memoization**. The `toCelsius()` function takes the given degrees in Fahrenheit
    and returns the Celsius equivalent. The `toFahrenheit()` function is the inverse—it
    takes a Celsius argument and returns a Fahrenheit value. We then take these two
    functions and wrap them with `memoize()`, yielding two new functions, `celsius()`
    and `fahrenheit()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个简单的数学函数，它们是 **memoization** 的良好候选。`toCelsius()` 函数接收给定的华氏度数并返回相应的摄氏度值。`toFahrenheit()`
    函数是它的逆函数——它接收摄氏度参数并返回华氏值。然后我们用 `memoize()` 包装这两个函数，得到两个新的函数，`celsius()` 和 `fahrenheit()`。
- en: 'After that, we make two calls each to the same function successively. The first
    call computes the value and stores it. The second call returns the cached result
    and computes nothing, but how does this cache lookup work? How does the memoized
    function know to use a value from the cache and not to compute a value? Let''s
    find this out using the following code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们连续对同一个函数进行两次调用。第一次调用计算值并存储它。第二次调用返回缓存的值而不进行计算，但这个缓存查找是如何工作的？缓存的函数是如何知道使用缓存中的值而不是计算一个值的？让我们通过以下代码来找出答案：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: By default, the resulting function generated by `memoize()` will use the first
    supplied argument as the cache key. The cache is a simple object and values are
    looked up by the property key. In the previous example, the memoized functions
    accepted only one argument. This is fine, but in more complex functions that accept
    more than one argument, you need a means to resolve the lookup key, as is illustrated
    in the preceding example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，由 `memoize()` 生成的函数将使用提供的第一个参数作为缓存键。缓存是一个简单的对象，通过属性键来查找值。在先前的例子中，缓存函数只接受一个参数。这是可以的，但在接受多个参数的更复杂函数中，你需要一种方法来解析查找键，正如前面例子所示。
- en: 'This is basically a rewrite of the previous example, as it generates the same
    result. We still have the `toCelsius()` and `toFahrenheit()` functions, but we''ve
    introduced a new `convertTemp()` function. This function accepts two arguments:
    the `degrees` and the temperature `system` these degrees represent. Based on these
    argument values, we can make the appropriate call to either `toCelsius()` or `toFahrenheit()`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是前面例子的重写，因为它生成了相同的结果。我们仍然有 `toCelsius()` 和 `toFahrenheit()` 函数，但我们引入了一个新的
    `convertTemp()` 函数。这个函数接受两个参数：`degrees` 和代表这些度数的温度 `system`。基于这些参数值，我们可以适当地调用
    `toCelsius()` 或 `toFahrenheit()`。
- en: We then construct the `convert()` function, a memoized version of `convertTemp()`.
    You'll notice the second function passed to `memoize()` here builds and returns
    a cache key. Without it, cache keys would still be consulted based only on the
    first argument value, which would return incorrect data. Be careful.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着构建 `convert()` 函数，它是 `convertTemp()` 的缓存版本。你会注意到传递给 `memoize()` 的第二个函数构建并返回一个缓存键。如果没有它，缓存键仍然只会根据第一个参数的值进行咨询，这会导致返回错误的数据。请小心。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that we could have continued using the previously cached
    functions, `celsius()` and `fahrenheit()`. That would mean a multilayered cache,
    which sounds kind of cool actually. Resist the temptation to do stuff like this.
    If you're performing badly enough to require a multilayer cache, it's time to
    reconsider the design at a higher level.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们可以继续使用之前缓存的函数，`celsius()` 和 `fahrenheit()`。这意味着多层缓存，这听起来实际上相当酷。抵制这种做法的诱惑。如果你执行得足够糟糕，以至于需要多层缓存，那么是时候在更高层次上重新考虑设计。
- en: Timed execution
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定时执行
- en: By nature, JavaScript code executes synchronously, that is, you don't have multiple
    threads of control, each running a piece of your code and competing for the CPU's
    attention. There are web workers in modern browsers, but these are far from commonplace
    yet and don't share much similarity with a threading API you'd find in another
    language. The upside to all of this is that you, as the programmer, don't need
    to concern yourself with synchronization primitives and all the other nasty details
    associated with multithreaded programming.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，JavaScript 代码是同步执行的，也就是说，你没有多个控制线程，每个线程运行你代码的一部分，并争夺 CPU 的注意力。现代浏览器中有
    Web Workers，但这些还远未普及，并且与你在其他语言中找到的线程 API 相似度不高。这一切的好处是，作为程序员，你不需要担心同步原语和与多线程编程相关的所有其他讨厌的细节。
- en: Instead, you face a different kind of difficulty in that you have to deal with
    events, the DOM, and other forms of callbacks; so much for synchronous code. Sometimes,
    this is actually desired. For example, you need to wait for a predetermined amount
    of time before something can happen. Or, perhaps you want to update the DOM and
    then pick up where you left off. Lo-Dash has tools that help you figure out the
    tricky details when it comes to timing function calls and coping with the side
    effects.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你面临的是不同类型的困难，因为你必须处理事件、DOM 和其他形式的回调；这就是同步代码的局限性。有时，这实际上是期望的。例如，你需要等待预定的时间后才能发生某些事情。或者，也许你想要更新
    DOM，然后从上次离开的地方继续。Lo-Dash 提供了一些工具，帮助你处理在调用定时函数和应对副作用时的棘手细节。
- en: Delaying function calls
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟函数调用
- en: 'The `delay()` function is used to execute a given callback function after the
    given number of milliseconds has elapsed. This actually works the same way as
    the built-in `setTimeout()` function does. This is shown in the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`delay()` 函数用于在给定数量的毫秒数过去后执行一个指定的回调函数。这实际上与内置的 `setTimeout()` 函数的工作方式相同。以下代码展示了这一点：'
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code defines a `poll()` function that is used to periodically log which
    round of polling we're on. Polling is a common pattern used in frontends to synchronize
    data from the API, with what the user is looking at. We've set the `max` variable,
    which controls the number of polling iterations, to `5`. The `interval` variable
    is set to `3000` milliseconds. It controls the polling call frequency. You can
    see that the `poll()` function will first check whether we've already reached
    the maximum number of iterations or not. If not, the `timer` variable gets a timeout
    value—just an integer—by calling `delay()`. The `delay()` callback is `poll()`.
    If we've already reached our threshold, the timeout is cleared and there's no
    further poll scheduling.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个 `poll()` 函数，用于定期记录我们正在进行的轮询哪一轮。轮询是前端中常用的模式，用于同步来自 API 的数据与用户正在查看的内容。我们已将控制轮询迭代次数的
    `max` 变量设置为 `5`。`interval` 变量设置为 `3000` 毫秒。它控制轮询调用的频率。你可以看到，`poll()` 函数首先检查我们是否已经达到最大迭代次数。如果没有，通过调用
    `delay()`，`timer` 变量获得一个超时值——只是一个整数。`delay()` 回调是 `poll()`。如果我们已经达到阈值，超时将被清除，并且不再进行进一步的轮询调度。
- en: 'If you look closely, you''ll notice that there''s no difference between using
    `delay()` and the built-in `setTimeout()` function. Both accept a callback function
    and duration as arguments, and both return a timeout number that can be cleared
    using `clearTimeout()`. What''s interesting about `delay()` compared to `setTimeout()`
    is how they deal with arguments. Let''s see how arguments are handled:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察，你会发现使用 `delay()` 和内置的 `setTimeout()` 函数之间没有区别。两者都接受回调函数和持续时间作为参数，并且两者都返回一个可以清除的超时编号
    `clearTimeout()`。与 `setTimeout()` 相比，`delay()` 的有趣之处在于它们如何处理参数。让我们看看参数是如何处理的：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we've created a `sayHi()` function. This has a nested function within the
    called `sayHiImp()`function , which is the actual implementation. The `sayHi()`
    function is just a wrapper for `sayHiImp()`. It logs the given `name` parameter
    and checks whether the `delay` parameter was supplied or not; if not, it supplies
    a default `delay` value. It's important that our function either always runs synchronously
    or asynchronously, but never both. However, if there's a `delay` value, we use
    it with the `delay()` function to postpone the call to `sayHiImp()`. Notice that
    we pass the `name` parameter to the `delay()` call as well. Rather than having
    to construct our own partial function, we let `delay()` make one for us.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `sayHi()` 函数。这个函数在调用的 `sayHiImp()` 函数内部有一个嵌套函数，这是实际的实现。`sayHi()`
    函数只是 `sayHiImp()` 的包装器。它记录给定的 `name` 参数并检查是否提供了 `delay` 参数；如果没有，它提供一个默认的 `delay`
    值。重要的是我们的函数要么始终同步运行，要么异步运行，但绝不能两者兼而有之。然而，如果有 `delay` 值，我们使用 `delay()` 函数来推迟对 `sayHiImp()`
    的调用。注意，我们还把 `name` 参数传递给 `delay()` 调用。我们不需要构建自己的部分函数，而是让 `delay()` 为我们构建一个。
- en: Deferring function calls
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟函数调用
- en: Whenever JavaScript code is run in the browser, it kicks off what is known as
    a **call stack**. Most programming languages share the notion of a call stack.
    It can be thought of as a traceable graph of function calls, starting with the
    root call. What's interesting is that the JavaScript call stack and the DOM are
    two completely separate entities that share the same thread of control. The implication
    is that the DOM doesn't run while there's an active JavaScript call stack. This
    is why long-running JavaScript code locks up UI interactivity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JavaScript 代码在浏览器中运行时，它会启动一个被称为 **调用栈** 的过程。大多数编程语言都共享调用栈的概念。它可以被看作是一个可追踪的函数调用图，从根调用开始。有趣的是，JavaScript
    调用栈和 DOM 是两个完全独立的实体，它们共享相同的控制线程。这意味着在存在活动的 JavaScript 调用栈时，DOM 不会运行。这就是为什么长时间运行的
    JavaScript 代码会锁定 UI 交互性的原因。
- en: 'Using the `defer()` function is a workaround for scenarios where you have a
    function that could take a while (a while being a relative term here—2 seconds
    is a while). You can push the call to that function till after the call stack
    has cleared, as shown in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `defer()` 函数是解决那些可能需要一段时间（在这里，“一段时间”是一个相对术语——2秒就是一段时间）的函数的场景的解决方案。你可以将对该函数的调用推迟到调用栈清除之后，以下代码展示了这一点：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `expensive()` function does nothing but hog the CPU for a bit, preventing
    the `console.log()` call from running. So we use `defer()` to call `expensive()`,
    which waits till the current call stack has finished. The `'computing...'` string
    is logged as the last statement in the call stack. Shortly thereafter, the `'done'`
    string appears in the console log. The trick is that we're giving the DOM a chance
    to update before the expensive code runs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`expensive()`函数什么都不做，只是占用CPU一段时间，防止`console.log()`调用执行。因此，我们使用`defer()`来调用`expensive()`，它等待当前调用栈完成。`''computing...''`字符串作为调用栈中的最后一个语句被记录。不久之后，`''done''`字符串出现在控制台日志中。这个技巧是我们给DOM一个更新机会，在执行昂贵的代码之前。'
- en: 'An alternative approach to calling `defer()` every time you want to invoke
    something after the call stack has cleared is to create a wrapper function. You
    then call this wrapper as you would call any other function and it''ll take care
    of deferring it for you. This is done using the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在调用栈清除后每次想要调用某个函数时调用`defer()`的方法是创建一个包装函数。然后，你可以像调用任何其他函数一样调用这个包装函数，它会为你处理延迟。这是通过以下代码实现的：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are two functions here, `setTitle()` and `setState()`, both of which we'd
    like to be made deferrable. The first function takes a `title` argument and logs
    it. The second function takes an `app` object and logs the `state` property of
    that object. The `deferred()` function is a wrapper. We'll use it along with `wrap()`
    to make any function deferrable. All `deferred()` does is apply `defer()` to the
    function that was passed along with some arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个函数，`setTitle()`和`setState()`，我们希望它们都是可延迟的。第一个函数接受一个`title`参数并记录它。第二个函数接受一个`app`对象并记录该对象的`state`属性。`deferred()`函数是一个包装器。我们将使用它和`wrap()`一起使任何函数可延迟。`deferred()`所做的只是将`defer()`应用于传递给它的函数和一些参数。
- en: Next, you can see that the `title()` function is the deferred version of `setTitle()`
    while the `state()` function is the deferred version of `setState()`. We also
    have an `app` object with an initial state of `'stopped'`. Calling `title()` and
    `state()` will always be deferred to after the call stack clears. This point is
    further illustrated in the preceding code by setting the state to `started`, after
    the call to `state()`. You can guess which string is logged.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以看到`title()`函数是`setTitle()`的延迟版本，而`state()`函数是`setState()`的延迟版本。我们还有一个初始状态为`'stopped'`的`app`对象。调用`title()`和`state()`将始终在调用栈清除后延迟执行。这一点在前面的代码中通过在调用`state()`之后将状态设置为`started`进一步说明。你可以猜测哪个字符串会被记录。
- en: Throttling function calls
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节流函数调用
- en: 'Often, events in the DOM can trigger much more frequently than you''re equipped
    to handle them. The simple act of moving the mouse pointer around has the potential
    to generate hundreds of events per second. If each of these events has a handler
    and that handler does anything meaningful, the UI will lag. There''s simply no
    way to keep up, no matter how fast the processor is. The only way to keep up is
    to ignore the majority of these events and only responds at a certain frequency.
    The idea is illustrated in the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，DOM中的事件触发频率可能会比你能够处理的频率要高得多。简单地移动鼠标指针就有可能在每秒生成数百个事件。如果每个事件都有一个处理程序，并且该处理程序执行任何有意义的操作，UI将会滞后。无论处理器有多快，都无法跟上。唯一跟上节奏的方法是忽略大多数这些事件，并且只在一定频率下做出响应。这个想法在以下代码中得到了说明：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `el` variable is a DOM element that we want to listen to for `mousemove`
    events. The `onMouseMove` function is created by passing a function to `throttle()`.
    This callback simply logs the mouse coordinates. We also pass `750` to `throttle()`
    as the maximum frequency with this callback is allowed to run. Next, we bind the
    event and set up the cleanup actions to remove the listener when we're done with
    it. Had we not throttled `onMouseMove()`, you would see a noticeable difference
    in the `console.log()` verbosity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`el`变量是我们想要监听`mousemove`事件的DOM元素。`onMouseMove`函数是通过将一个函数传递给`throttle()`创建的。这个回调函数简单地记录鼠标坐标。我们还向`throttle()`传递`750`，因为这是这个回调函数允许运行的最大频率。接下来，我们绑定事件并设置清理操作，在完成时移除监听器。如果我们没有节流`onMouseMove()`，你会在`console.log()`的详细程度中看到明显的差异。'
- en: Debouncing function calls
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 防抖函数调用
- en: '**Debouncing** functions is similar to throttling them. The difference is in
    what happens when the wait duration has elapsed. With `throttle()`, the function
    is invariably called. For example, if the `wait` value was set to `10` milliseconds
    on a throttled function, and the function was called during those 10 milliseconds,
    it''ll get called before the next wait. With `debounce()`, during the 10-millisecond
    wait, if the function was called, it''ll wait an additional 10 milliseconds. Let''s
    look at some debouncing code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**去抖动**函数与节流函数类似。区别在于等待时间结束后会发生什么。使用`throttle()`，函数总是会被调用。例如，如果将节流函数的`wait`值设置为`10`毫秒，并且在这10毫秒内调用了函数，它将在下一次等待之前被调用。使用`debounce()`，在10毫秒的等待期间，如果调用了函数，它将额外等待10毫秒。让我们看看一些去抖动代码：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have a simple `log()` function that logs a message and an item number. We
    then proceed to build a `debounced()` and a `throttled()` version of the function.
    Then we run both through the same-sized loop. What''s the difference? The output
    looks something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个简单的`log()`函数，它记录一条消息和一个项目编号。然后我们继续构建`debounced()`和`throttled()`函数的版本。然后我们通过相同大小的循环运行这两个版本。有什么区别？输出看起来像这样：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What happened here? We set the `wait` time to `1` millisecond for both `debounced()`
    and `throttled()`. In the time it took to process `1500` items, the wait period
    elapsed twice for the `throttled()` function. As soon as that happened, the `log()`
    function was called, hence the output. Notice that the `debounce()` output happened
    only after the processing was done. That's because `debounce()` was called many
    times during the 1-millisecond wait, and again during the next wait.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？我们将`debounced()`和`throttled()`的`wait`时间都设置为`1`毫秒。在处理`1500`个项目所需的时间内，`throttled()`函数的等待期过去了两次。一旦发生这种情况，就调用了`log()`函数，因此产生了输出。注意，`debounce()`的输出只有在处理完成后才发生。这是因为`debounce()`在1毫秒的等待期间被多次调用，并在下一次等待期间再次调用。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `throttle()` function actually uses `debounce()` under the hood. All of
    the complexity is in `debounce()` and it accepts several configuration options.
    Among these are the **leading** and **trailing** edges of execution. What does
    this mean? You'll notice in the preceding output that the `throttled()` function
    is called after `debounce()`. That's the trailing edge of the wait period. The
    leading edge of the wait period is before the wait period starts. Both of these
    edges default to `true` for `throttle()`. This means that you're in an intense
    loop where your throttled function is being hammered, the function is called immediately,
    before waiting for the next call. Then, if the loop ends abruptly, the function
    is called again when the wait period ends.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttle()`函数实际上在底层使用了`debounce()`。所有的复杂性都在`debounce()`中，它接受几个配置选项。其中之一是执行的**前导**和**尾随**边缘。这意味着什么？你会在前面的输出中注意到，`throttled()`函数是在`debounce()`之后被调用的。这是等待期的尾随边缘。等待期的前导边缘是在等待期开始之前。这两个边缘对于`throttle()`默认都是`true`。这意味着你在一个紧张的循环中，你的节流函数正在被猛烈地打击，函数立即被调用，在等待下一次调用之前。然后，如果循环突然结束，当等待期结束时，函数再次被调用。'
- en: Composing and currying functions
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数组合和柯里化
- en: The last section of this chapter is about assembling functions that realize
    larger behavior out of smaller functions. There are two ways to assemble such
    functions. The first is to use the appropriately named `compose()` function, which
    performs a nested invocation of the provided functions, or where order is important,
    we can use the `flow()` function to return values together. Currying lets you
    adapt your function to be called successively in different contexts. Each of these
    Lo-Dash tools lets you take the existing functionality in your application and
    build on it in interesting ways.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后部分是关于组装函数，这些函数通过较小的函数实现更大的行为。组装此类函数有两种方法。第一种是使用名为`compose()`的适当命名的函数，它执行提供的函数的嵌套调用，或者在顺序很重要的情况下，我们可以使用`flow()`函数一起返回值。柯里化允许你根据不同的上下文连续调用函数。这些Lo-Dash工具中的每一个都让你能够以有趣的方式在你的应用程序中构建现有的功能。
- en: Composing functions
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数组合
- en: 'The `compose()` function builds a new function out of the provided functions.
    When we call this new function, a nested invocation of the supplied function starts,
    that is, the last supplied function is called with any additional arguments. The
    returned value is then fed to the next function and so on, ultimately producing
    a value for the caller. This is better explained in the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose()` 函数从提供的函数中构建一个新的函数。当我们调用这个新函数时，会开始一个嵌套的函数调用，即最后提供的函数会使用任何额外的参数被调用。然后返回的值会被传递给下一个函数，依此类推，最终为调用者产生一个值。以下示例更好地解释了这一点：'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are three functions responsible for assembling pizza—`dough()`, `sauce()`,
    and `cheese()`. The job of each one of these functions is to set their corresponding
    attribute to `true` on the supplied `pizza` object. The `pizza()` function is
    composed using these functions which in turn use the `compose()` function. So
    calling `pizza()` will call `cheese(sauce(dough()))`. Note some of the checking
    that happens in these functions. For example, `dough()` will accept an object
    or construct a new one. However, the `sauce()` function won't work if there's
    no `dough` attribute. Likewise, `cheese()` complains if there's no `sauce`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个函数负责组装披萨——`dough()`、`sauce()` 和 `cheese()`。每个函数的职责是在提供的 `pizza` 对象上设置相应的属性为
    `true`。`pizza()` 函数是通过这些函数组合而成的，这些函数又使用 `compose()` 函数。因此调用 `pizza()` 将会调用 `cheese(sauce(dough()))`。注意这些函数中发生的一些检查。例如，`dough()`
    可以接受一个对象或构造一个新的对象。然而，如果没有 `dough` 属性，`sauce()` 函数将无法工作。同样，如果没有 `sauce`，`cheese()`
    函数会抱怨。
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While being able to compose functions is handy, it's a good idea to have precondition
    checking. Then they fail fast, so other developers attempting to compose something
    out of your functions have an obvious indication if something isn't possible.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然能够组合函数很方便，但进行先决条件检查是个好主意。这样它们会快速失败，因此其他尝试从你的函数中组合出东西的开发者会有一个明显的指示，如果某件事不可能的话。
- en: 'If the reverse order of the function invocation is confusing, don''t worry.
    We can reverse the order using the `flow()` function. Using the same `pizza` functions,
    we could make a slight modification to the `pizza()` composition function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数调用的反向顺序让你感到困惑，不要担心。我们可以使用 `flow()` 函数来反转顺序。使用相同的 `pizza` 函数，我们可以对 `pizza()`
    组合函数进行轻微的修改：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `compose()` function is actually an alias for the `flowRight()` function.
    The `flow()` and `flowRight()` functions are newer. In previous versions of Lo-Dash,
    the `compose()` function was standalone.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`compose()` 函数实际上是 `flowRight()` 函数的别名。`flow()` 和 `flowRight()` 函数较新。在 Lo-Dash
    的早期版本中，`compose()` 函数是独立的。'
- en: Currying functions
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柯里化函数
- en: 'Have you ever found yourself having to create a bunch of variables that do
    nothing aside from eventually getting passed to a function? Instead of variable
    creation, the currying technique lets you partially apply the function. That is,
    you call the function, supplying only the data you have at that moment. Curried
    functions will keep returning the function until it has all the arguments necessary.
    This technique is explained using the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经发现自己不得不创建一大堆变量，这些变量除了最终传递给函数之外没有任何作用？与变量创建不同，柯里化技术允许你部分应用函数。也就是说，你只需调用函数，提供你当时拥有的数据即可。柯里化函数会持续返回函数，直到它拥有所有必要的参数。这个技术将通过以下示例进行解释：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `makePizza()` function has any arity of three—the number of arguments expected
    by the function. This means that the `pizza()` function created by calling `curry()`
    on `makePizza()` will keep returning the function until it's invoked with three
    arguments. We have the flexibility to pass these arguments however we want. This
    could be all three at once or it could be one at a time. This means that different
    contexts could pass data into the function, without the need to store them elsewhere.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`makePizza()` 函数具有任意数量的三个参数——函数期望的参数数量。这意味着通过在 `makePizza()` 上调用 `curry()`
    创建的 `pizza()` 函数会持续返回函数，直到它被三个参数调用。我们可以以任何我们想要的方式传递这些参数。这可以是所有三个参数同时传递，也可以是一个接一个地传递。这意味着不同的上下文可以将数据传递给函数，而无需在其他地方存储它们。'
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Hopefully after reading this chapter, your appreciation for functions in JavaScript
    went up a little. Lo-Dash just makes functional programming in the frontend that
    much better. Functions in JavaScript are flexible by default, changing the execution
    context for example. This chapter showed you how some Lo-Dash functions make working
    with function contexts much easier by removing much of the boiler-plate code that
    would otherwise be needed. Partials are fundamental to functional programming,
    but it's one of those tasks that's anything but easy in JavaScript. Lo-Dash makes
    it easy to create partials and to decorate functions by wrapping them with additional
    logic.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 希望在阅读本章之后，你对JavaScript中函数的欣赏有所提升。Lo-Dash让前端中的函数式编程变得更好。JavaScript中的函数默认是灵活的，例如改变执行上下文。本章向你展示了Lo-Dash的一些函数如何通过移除否则可能需要的许多样板代码，使处理函数上下文变得更加容易。部分函数是函数式编程的基础，但在JavaScript中，这是一项相当不容易的任务。Lo-Dash使得创建部分函数和通过包装额外的逻辑来装饰函数变得简单。
- en: We looked at functions that help constrain when a function should run. For example,
    should a function be allowed to run only once? Should the return values be cached?
    Timing the execution of functions is a complex topic, especially when you consider
    the DOM and how it integrates with the JavaScript call stack. Lo-Dash has a number
    of functions that deal with managing the timed execution of functions. We looked
    at these in detail.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了帮助限制函数何时应该运行的函数。例如，函数是否应该只允许运行一次？返回值是否应该被缓存？函数执行的计时是一个复杂的话题，尤其是当你考虑到DOM以及它是如何与JavaScript调用栈集成的时候。Lo-Dash有一系列处理函数定时执行的函数。我们详细地研究了这些函数。
- en: The chapter wrapped up with a look at how to compose larger pieces of functionality
    out of smaller functions. Currying functions let you define functions flexible
    enough to be invoked in a number of contexts, reducing the need to temporarily
    store arguments before they're passed. And on that note, we covered the Lo-Dash
    fundamentals. The concepts you've learned so far about collections, objects, and
    functions are applicable throughout the remainder of the book. We're now ready
    to move on to mapping and reducing values, a powerful technique that you'll utilize
    over and over again when programming with Lo-Dash.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以如何将较小的函数组合成较大的功能模块结束。柯里化函数允许你定义足够灵活的函数，可以在多个上下文中调用，从而减少了在传递之前临时存储参数的需求。在此基础上，我们介绍了Lo-Dash的基本概念。你到目前为止学到的关于集合、对象和函数的概念，在整个书籍的剩余部分都是适用的。我们现在可以继续学习映射和归约值，这是一种强大的技术，你将在使用Lo-Dash编程时反复使用。
