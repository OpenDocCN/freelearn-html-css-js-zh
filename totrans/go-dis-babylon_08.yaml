- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the Driving Game
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It may not be easy to believe it, but we are officially past the halfway point
    – while the end is still not in sight, we’ve made so much progress it’s tough
    to see our starting point. In the previous six chapters, we built out a huge amount
    of functionality encompassing an almost breathtaking diversity of subjects. The
    following figure shows where we were before and where we are now:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – How it started versus how it’s going. A montage of screenshots
    showing our progress'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_8.01_B17266.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – How it started versus how it’s going. A montage of screenshots
    showing our progress
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: From setting up the basic web application to implementing random encounters,
    a lot has gone into our code base to get to this point, but we’re not stopping
    or even slowing down any time soon! Making it this far into this book shows admirable
    persistence and determination – this chapter is where all of that will pay off.
    One of the more enjoyable aspects of game development is also one of the more
    obvious ones – the part of getting to work on the core gameplay and logic code.
    Unfortunately, and as people with experience of developing and shipping software
    will attest, all the other activities that go into building and delivering software
    tend to take up the lion’s share of available project time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we’re going to be building out the driving phase of
    Space-Truckers. Along with some of the techniques we learned earlier, we’re going
    to introduce a few new tools for the ol’ toolbox. We’re going to take things up
    a notch by adding a second camera to our scene that will render the **Graphical
    User Interface** (**GUI**). We’ll generate a route based on the previous phase’s
    simulated route and allow players to drive their trucks along it, avoiding obstacles
    (if they can). Our scene will use physics as the previous phase does, but instead
    of mainly using it as a gravitational simulation, we’re going to make use of the
    physics engine’s capabilities to simulate the results of collisions, friction,
    and more. Some things we’re going to introduce but defer more detailed examination
    until upcoming chapters – when this is the case, the relevant chapters and sections
    will be linked for easy reference.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: All those exciting topics will hopefully more than make up for the more mundane
    but no less important task of building the necessary logic ahead of us. By the
    end of this chapter, we’ll have a playable driving game that sets us up for the
    following chapter, where we will continue to finish the overall game’s life cycle
    as we learn how to calculate and display scoring results.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Prototyping the Driving Phase
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with the Application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Encounters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making the Mini-Map
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Nothing in this chapter is required from a technical perspective that hasn’t
    already been listed as being needed for the previous chapters, but there are some
    technical areas where it might be useful to have working knowledge as you read
    through this chapter:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，本章没有要求任何之前章节中未列出的内容，但有一些技术领域，在阅读本章时拥有实际知识可能是有用的：
- en: '**MultiViews**: [https://doc.babylonjs.com/divingDeeper/cameras/multiViewsPart2](https://doc.babylonjs.com/divingDeeper/cameras/multiViewsPart2)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多视图**：[https://doc.babylonjs.com/divingDeeper/cameras/multiViewsPart2](https://doc.babylonjs.com/divingDeeper/cameras/multiViewsPart2)'
- en: '**Layer Masks**: [https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam](https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层掩码**：[https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam](https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam)'
- en: '**In-Depth Layer Masks**: [https://doc.babylonjs.com/divingDeeper/scene/layermask](https://doc.babylonjs.com/divingDeeper/scene/layermask)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度层掩码**：[https://doc.babylonjs.com/divingDeeper/scene/layermask](https://doc.babylonjs.com/divingDeeper/scene/layermask)'
- en: '**Loading Any File Type**: [https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes](https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载任何文件类型**：[https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes](https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes)'
- en: '**Polar Coordinates**: [https://tutorial.math.lamar.edu/Classes/CalcII/PolarCoordinates.aspx](https://tutorial.math.lamar.edu/Classes/CalcII/PolarCoordinates.aspx)
    and [https://math.etsu.edu/multicalc/prealpha/Chap3/Chap3-2/](https://math.etsu.edu/multicalc/prealpha/Chap3/Chap3-2/)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**极坐标**：[https://tutorial.math.lamar.edu/Classes/CalcII/PolarCoordinates.aspx](https://tutorial.math.lamar.edu/Classes/CalcII/PolarCoordinates.aspx)
    和 [https://math.etsu.edu/multicalc/prealpha/Chap3/Chap3-2/](https://math.etsu.edu/multicalc/prealpha/Chap3/Chap3-2/)'
- en: Prototyping the Driving Phase
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 驾驶阶段的原型设计
- en: 'There’s a lot to do, so let’s dive right into it. Due to the way the driving
    phase is designed, players must navigate their trucks along a route that’s been
    pre-determined by the players in the previous game phase. The nature of the overall
    planned route determines similar overall characteristics of the driving route.
    Factors such as total transit time, distance, and velocities all fall into that
    kind of characteristic. Others, such as random encounters along the path, are
    more localized to a specific portion of the path. The behavior of each encounter
    is variable, but all will have a general form of forcing the player to make choices
    to avoid/obtain a collision while piloting their space-truck. Capturing the correlations
    between the two phases is an important design specification that will be useful
    – here’s what is listed on the Space-Trucker Issue created for that purpose:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工作要做，所以让我们直接进入正题。由于驾驶阶段的设计方式，玩家必须沿着在之前游戏阶段由玩家预先确定的路线驾驶他们的卡车。整体计划的路线性质决定了驾驶路线的相似整体特征。诸如总通行时间、距离和速度等因素都属于这种特征。其他因素，如路径上的随机遭遇，则更局限于路径的特定部分。每个遭遇的行为是可变的，但所有遭遇都将采取一种迫使玩家在驾驶太空卡车时做出选择以避免/获得碰撞的一般形式。捕捉两个阶段之间的相关性是一个重要的设计规范，将非常有用——以下是为此目的创建的Space-Trucker问题中列出的内容：
- en: '![Figure 8.2 – Comparison of Route Planning versus driving phase variables.
    Source: https://github.com/jelster/space-truckers/issues/84](img/Figure_8.02_B17266.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 路线规划与驾驶阶段变量的比较。来源：https://github.com/jelster/space-truckers/issues/84](img/Figure_8.02_B17266.jpg)'
- en: 'Figure 8.2 – Comparison of Route Planning versus driving phase variables. Source:
    [https://github.com/jelster/space-truckers/issues/84](https://github.com/jelster/space-truckers/issues/84)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 路线规划与驾驶阶段变量的比较。来源：[https://github.com/jelster/space-truckers/issues/84](https://github.com/jelster/space-truckers/issues/84)
- en: Some of the properties have a direct 1:1 correlation between phases, such as
    total transit time and distance traveled. Others are used as scale or other indirect
    influencing factors, such as the point velocity affecting the route’s diameter.
    This will all be quite useful a bit further down this chapter’s journey, but for
    now, we will turn our attention to building out a Playground demonstrating the
    core principles of the driving phase.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性在相位之间存在直接的1:1相关性，例如总通行时间和行驶距离。其他属性则用作比例或其他间接影响因素，例如点速度影响路线的直径。所有这些内容将在本章的后续部分变得非常有用，但就目前而言，我们将把注意力转向构建一个演示驾驶阶段核心原理的游乐场。
- en: Playground Overview
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游乐场概述
- en: Prototyping in software is all about reducing a particular problem or area of
    interest to its bare essence. It forces us to ask the question – what is the smallest
    set of characteristics, attributes, features, and so on needed to evaluate the
    viability of a particular approach? In the case of our driving phase prototype,
    we don’t need to play through the planning phase to accomplish our goals – we
    just need to be able to process the route data generated by that phase. Focusing
    in, the problem of hooking up our route data to the driving phase isn’t the problem
    we’re trying to solve right now (though we can certainly do our future selves
    a solid by structuring our code in ways that facilitate building that logic!).
    This saves mental bandwidth and energy that can be put to good use elsewhere,
    which is where we will begin.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中进行原型设计，就是将特定问题或兴趣领域简化到其本质。这迫使我们提出问题——为了评估特定方法的可行性，需要的最小特征、属性、功能等集合是什么？在我们的驾驶阶段原型中，我们不需要通过规划阶段来达成目标——我们只需要能够处理该阶段生成的路线数据。专注于这个问题，将我们的路线数据连接到驾驶阶段的问题并不是我们现在试图解决的问题（尽管我们当然可以通过以促进构建该逻辑的方式结构化我们的代码来为未来的自己提供帮助！）。这节省了可以用于其他地方的思维带宽和能量，这也是我们将开始的地方。
- en: Important note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The Playground at [https://playground.babylonjs.com/#WU7235#49](https://playground.babylonjs.com/%23WU7235%2349)
    is the reference for this section of this chapter.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://playground.babylonjs.com/#WU7235#49](https://playground.babylonjs.com/%23WU7235%2349)
    的游乐场是本章该部分的参考。'
- en: 'We’ll need physics to be working so that we can playtest the interactions and
    relationships between the truck, obstacles, and velocities. We need to determine
    the proper scaling, orientation, and import settings for loading the first 3D
    asset model into the game – the semi-truck. Finally, we need to figure out how
    we’re going to plot oncoming obstacles in the radar GUI presented to the player.
    This seems like quite a lot to take on, but thanks to the functionality built
    into Babylon.js there’s much less complexity than it might seem. The following
    screenshot illustrates how these elements all come together in the Playground
    demo:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要物理引擎正常工作，以便我们可以测试卡车、障碍物和速度之间的交互和关系。我们需要确定加载第一个 3D 资产模型（半挂卡车）的正确缩放、方向和导入设置。最后，我们需要弄清楚如何在玩家面前的雷达
    GUI 上绘制即将到来的障碍物。这似乎是一项相当大的任务，但多亏了 Babylon.js 内置的功能，其复杂性远低于表面看起来那么多。以下截图展示了这些元素如何在游乐场演示中结合在一起：
- en: '![Figure 8.3 – Space-Truckers driving phase Playground at https://playground.babylonjs.com/#WU7235#49](img/Figure_8.03_B17266.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 空间卡车手驾驶阶段游乐场，见 https://playground.babylonjs.com/#WU7235#49](img/Figure_8.03_B17266.jpg)'
- en: Figure 8.3 – Space-Truckers driving phase Playground at [https://playground.babylonjs.com/#WU7235#49](https://playground.babylonjs.com/%23WU7235%2349)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 空间卡车手驾驶阶段游乐场，见 [https://playground.babylonjs.com/#WU7235#49](https://playground.babylonjs.com/%23WU7235%2349)
- en: In the center of the viewport is our game’s protagonist, the eponymous space-trucker.
    The space-road stretches out in front of them, littered with the untextured blocks
    that are filling the place of encounters. In the lower-left part of the screen,
    a radar display sweeps in a circle, revealing upcoming obstacles as blips. The
    camera is chained to the truck so that the player’s perspective is always behind
    and a bit above the truck – the classic Third-Person Perspective. The controls
    are simple – *W* and *S* accelerate and decelerate in the truck’s forward direction,
    while *A* and *D* accelerate to the left and right, respectively. Vertical acceleration
    is managed with the *up arrow* and *down arrow* keys, and rotation with the *right
    arrow* and *left arrow*; resetting the demo is done by pressing the *Delete* key.
    Try to make it to the end of the path as fast as you can!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在视口的中心是我们的游戏主角，即同名空间卡车手。空间道路在他们面前延伸，散布着填充遭遇地点的无纹理方块。在屏幕的左下角，雷达显示器以圆形扫过，揭示即将到来的障碍物作为亮点。摄像机与卡车相连，因此玩家的视角始终在卡车后面和略高位置——这是经典的第三人称视角。控制很简单——*W*
    和 *S* 在卡车的前进方向上加速和减速，而 *A* 和 *D* 分别向左和向右加速。垂直加速由 *上箭头* 和 *下箭头* 键管理，旋转由 *右箭头* 和
    *左箭头* 管理；通过按 *Delete* 键重置演示。尽量快速到达路径的尽头！
- en: 'Let’s swap over to looking at the code for the demo, and how the demo is structured.
    Right away, we can see some similarities but also some differences from how we’ve
    structured our previous Playground demos. At the very top are the various asset
    URL and `gameData` object, and then we get to the most striking difference yet:
    the `async drive(scene)` function.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到查看演示代码以及演示的结构。立即，我们可以看到一些相似之处，但也有一些与我们的先前 PlayGround 演示结构不同的地方。在最顶部是各种资产
    URL 和 `gameData` 对象，然后我们到达最引人注目的差异：`async drive(scene)` 函数。
- en: This is, as implied by the `async` prefix, an `await` statement in expressions
    within the function body, and two, to provide a container for closure over all
    the ***var***-ious objects and values used by the demo.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这，正如 `async` 前缀所暗示的，是在函数体中的表达式中一个 `await` 语句，二是提供一个容器，用于封装演示中使用的所有 ***var***-ious
    对象和值。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The editors of this book apologize for subjecting you to the inredibad pun that
    was just made.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本书编辑为让你忍受刚才那个糟糕的双关语表示歉意。
- en: 'Furious punning discharged, we will continue with the first few lines of the
    PG above the `drive` function. To load our route data, we’ll choose the simple
    approach of wrapping a call to `jQuery.getJSON` in a promise that resolves to
    the array of route path points:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 狂野的双关语已经释放，我们将继续查看 `drive` 函数上方的 PG 的前几行。为了加载我们的路线数据，我们将选择将 `jQuery.getJSON`
    的调用包装在一个承诺中，该承诺解析为路线路径点的数组：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This requires us to specify our `createScene` method as `async`, allowing us
    to write a simple harness to instantiate and return the Playground’s Scene after
    doing the same for the driving phase initialization logic:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们将 `createScene` 方法指定为 `async`，这样我们就可以在完成驾驶阶段初始化逻辑后，编写一个简单的 harness 来实例化并返回
    PlayGround 的 Scene：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `drive` function is responsible for creating and/or loading any type of
    asset or resource that might require a bit of time to complete, so it is also
    marked as async. There’s a ton of code that goes into this function, so to make
    it easier to work with, the logic is split up into a few helper methods. Before
    those, the logic for basic scene and environment setup is constructed or defined.
    These are elements that might be needed by any or all the (potentially asynchronous)
    helper functions that include the invocation of those helper functions in the
    proper order. Once those tasks are complete, the `run` function is returned:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`drive` 函数负责创建和/或加载任何可能需要一些时间才能完成的资产或资源，因此它也被标记为 `async`。这个函数中包含大量的代码，为了使其更容易处理，逻辑被拆分成了几个辅助方法。在这些方法之前，构建或定义了基本场景和环境设置的逻辑。这些是可能被任何或所有（可能是异步的）辅助函数需要的元素，包括以正确的顺序调用这些辅助函数。一旦这些任务完成，就返回
    `run` 函数：'
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ll cover the `initializeGui` method in this chapter’s *Making a Mini-Map*
    section after we establish a bit more context. Earlier in the `drive` function
    is probably the most important helper function that we want to prove out in the
    Playground, and that is the `calculateRouteParameters(routeData)` method. This
    is the workhorse function of the driving phase’s world creation and has probably
    the largest impact on how gameplay evolves in the form of dictating the properties
    of the route driven by the player.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的 *制作迷你地图* 部分介绍 `initializeGui` 方法，在建立更多上下文之后。在 `drive` 函数中，可能是我们希望在 PlayGround
    中证明的最重要的辅助函数是 `calculateRouteParameters(routeData)` 方法。这是驾驶阶段世界创建的工作马，可能对游戏玩法如何演变有最大的影响，因为它决定了玩家驾驶的路线属性。
- en: Generating the Driving Path
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成驾驶路径
- en: 'In [*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142), *Processing Route
    Data*, we set up `cargoUnit` to log `routeData`: timing, position, velocity, rotation,
    and gravity are all captured every few frames of rendering into a collection of
    data points (along with encounters, which we’ll get to in the *Adding Encounters*
    section). The telemetry data is a deep well for creative and interesting ideas
    (see *Extended Topics*), but for now, we’ll just use the position, velocity, and
    gravity route values described in the *Playground Overview* section to generate
    the route path.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 7 章*](B17266_07_Final_AM.xhtml#_idTextAnchor142) *处理路线数据* 中，我们设置 `cargoUnit`
    记录 `routeData`：时间、位置、速度、旋转和重力都在渲染的每几个帧中捕获到数据点集合中（包括遭遇，我们将在 *添加遭遇* 部分中讨论）。遥测数据是一个充满创意和有趣想法的深井（参见
    *扩展主题*），但就目前而言，我们将仅使用 *PlayGround 概述* 部分中描述的位置、速度和重力路线值来生成路线路径。
- en: The beginning of the function grabs `routeDataScalingFactor` from `gameData`;
    though currently set to a value of `Vector3` values, as opposed to a Plain Ol’
    JavaScript Object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的开始部分从`gameData`中获取`routeDataScalingFactor`；尽管目前设置为`Vector3`值，而不是普通的JavaScript对象。
- en: Important note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Taking proactive steps like this to reduce friction on quick iteration is key
    to building momentum!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 采取这样的主动措施来减少快速迭代的摩擦，对于建立势头至关重要！
- en: 'Once that’s done, we use the positional vectors from the telemetry data to
    construct a new `Path3D` instance:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们使用来自遥测数据的定位向量来构建一个新的`Path3D`实例：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the Babylon.js docs ([https://doc.babylonjs.com/divingDeeper/mesh/path3D](https://doc.babylonjs.com/divingDeeper/mesh/path3D)),
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Babylon.js文档([https://doc.babylonjs.com/divingDeeper/mesh/path3D](https://doc.babylonjs.com/divingDeeper/mesh/path3D))
- en: “A Path3D is a mathematical object created from a sequence of position vectors
    of points on a curve.”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “一个`Path3D`是由曲线上的点的位置向量序列创建的数学对象。”
- en: '`Error! Hyperlink reference not valid.`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error! Hyperlink reference not valid.`'
- en: Put another way, a `Path3D` represents an ordered set of coordinate points with
    some interesting and useful properties.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，一个`Path3D`代表了一组有序的坐标点，并具有一些有趣和有用的特性。
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason for calling it a “mathematical object” is because it is not a member
    of the Scene and does not take part in rendering. This also sounds a lot cooler
    than calling it a “non-rendered abstract geometrical data structure.”
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 称其为“数学对象”的原因是它不是场景的成员，也不参与渲染。这听起来也比称之为“非渲染的抽象几何数据结构”酷多了。
- en: The `getCurve()` method is a utility method that spits back the sequence of
    points that define the path, but there are even more useful nuggets of value tucked
    away in `Path3D` that we’ll soon be exploring. First, though, we want to display
    the specific path taken by the player during the planning phase as a straight
    line going down the middle of the space-road. This is easy – we use the curve
    array in a call to `MeshBuilder.CreateLines` and that’s all there is to it! For
    more on this, see [https://doc.babylonjs.com/divingDeeper/mesh/creation/param/lines](https://doc.babylonjs.com/divingDeeper/mesh/creation/param/lines).
    After that is when we start constructing the geometry for the space-road, which
    is where things start to get interesting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`getCurve()`方法是一个实用方法，它会返回定义路径的点序列，但在`Path3D`中还有更多有用的价值点，我们很快就会探索。不过，首先，我们希望显示玩家在规划阶段所采取的具体路径，作为穿过空间道路中间的直线。这很简单——我们使用曲线数组在调用`MeshBuilder.CreateLines`时，这就是全部！有关更多信息，请参阅[https://doc.babylonjs.com/divingDeeper/mesh/creation/param/lines](https://doc.babylonjs.com/divingDeeper/mesh/creation/param/lines)。在那之后，我们开始构建空间道路的几何形状，这是事情开始变得有趣的地方。'
- en: 'The geometric shape forming the base of our space-road is a Ribbon – a series
    of one or more paths, each with at least two `Vector3` points. The order the paths
    are provided works in conjunction with the paths themselves to produce geometry
    with a huge range of flexibility, and though potentially entertaining, it would
    be counterproductive to attempt to reproduce the excellent examples already created
    as part of the Ribbon’s documentation at [https://doc.babylonjs.com/divingDeeper/mesh/creation/param/ribbon_extra](https://doc.babylonjs.com/divingDeeper/mesh/creation/param/ribbon_extra).
    From those docs, this thought experiment nicely explains the concept we’re looking
    at currently:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构成我们空间道路基础的几何形状是带状物——一系列一个或多个路径，每个路径至少有两个`Vector3`点。提供的路径顺序与路径本身结合使用，以产生具有巨大灵活性的几何形状，尽管这可能很有趣，但尝试复制在带状物文档中已经创建的优秀示例可能会适得其反。从那些文档中，这个思想实验很好地解释了我们目前正在研究的概念：
- en: “Imagine a long ribbon of narrow width in the real world with a wire running
    down its length. Closing the paths forms a loop of ribbon while closing the array
    would form a tube.”
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: “想象一下在现实世界中一条长而窄的带状物，其长度上有一条线。关闭路径形成一个带状物的环，而关闭数组则会形成一个管状物。”
- en: Closing the array seems like the option we want rather than closing the paths
    themselves since we want our road to be enclosed, but not like a donut or loop.
    This faces us with a bit of a choice regarding how we’d like to approach implementing
    this, but only after we have established the value in doing it via prototyping,
    which in this circumstance becomes the link back to our choice of implementation
    paths in an endlessly circular argument.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭数组看起来是我们想要的选项，而不是关闭路径本身，因为我们希望我们的道路是封闭的，但又不像是甜甜圈或环。这让我们面临一些选择，关于我们希望如何实现这一点，但只有在确立了通过原型化实现它的价值之后，这在这个情况下才成为我们选择实现路径的无限循环论证的链接。
- en: 'When prototyping out the path creation (or any prototyping process in software),
    there’s a certain point in the process where you realize the need to transition
    from throwing something together to see if it works and taking consideration to
    build something more robust with the knowledge that it will be incorporated into
    the final product. Playground snippet **#WU7235#11** ([https://playground.babylonjs.com/#WU7235#11](https://playground.babylonjs.com/%23WU7235%2311))
    shows, starting around **line 168**, what this prototyped logic can look like
    (comments have been removed for clarity):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型化路径创建（或软件中的任何原型化过程）时，在某个阶段你会意识到需要从只是拼凑一些东西来测试其是否可行，并考虑到构建一个更稳健的产品的需求。Playground片段**#WU7235#11**（[https://playground.babylonjs.com/#WU7235#11](https://playground.babylonjs.com/%23WU7235%2311)）展示了大约从**第168行**开始的原型化逻辑可能的样子（为了清晰起见，已移除注释）：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is a scheme for path geometry that takes the form of a four-sided box
    (the ends are open). The preceding code uses four separate arrays of points –
    one for each corner – to capture the paths as it loops through each of the points
    along the route. This is what that looks like:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个路径几何的方案，其形式为四边形的方框（两端是开放的）。前面的代码使用四个独立的点数组 – 每个角落一个 – 来捕捉路径，它在沿着路线的每个点循环时记录路径。这看起来是这样的：
- en: '![Figure 8.4 – Prototype path geometry hardcoded to make a four-sided box with
    open ends. Four paths are used. Simple and effective, yet extremely limited (https://playground.babylonjs.com/#WU7235#11)](img/Figure_8.04_B17266.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 原型路径几何硬编码为制作一个四边形的方框，两端开口。使用了四个路径。简单而有效，但极其有限（https://playground.babylonjs.com/#WU7235#11）](img/Figure_8.04_B17266.jpg)'
- en: Figure 8.4 – Prototype path geometry hardcoded to make a four-sided box with
    open ends. Four paths are used. Simple and effective, yet extremely limited ([https://playground.babylonjs.com/#WU7235#11](https://playground.babylonjs.com/%23WU7235%2311))
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 原型路径几何硬编码为制作一个四边形的方框，两端开口。使用了四个路径。简单而有效，但极其有限 ([https://playground.babylonjs.com/#WU7235#11](https://playground.babylonjs.com/%23WU7235%2311))
- en: Mission accomplished! We’re done here, right? Wrong. This is just the beginning!
    It’s OK to celebrate accomplishments, but it’s best to keep any celebrations proportional
    to the achievement in the context of the end goal. A box shape works to prove
    that we can create a playable path demo from actual route data, but it’s not particularly
    fun or attractive to look at. To step this up to a place where it’s something
    that will surprise and delight users, we need to make it more spherical and less
    boxy. We need to add more path segments to do this, and that’s where our prototype
    reaches its limits.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 任务完成！我们在这里就结束了，对吧？错了。这只是一个开始！庆祝成就当然可以，但最好是将庆祝的规模与最终目标所取得的成就相匹配。一个方框形状可以证明我们可以从实际路线数据中创建一个可玩路径演示，但这看起来既不有趣也不吸引人。为了将其提升到一个能够令人惊讶和愉悦用户的地方，我们需要让它更加球形而不是方形。为了做到这一点，我们需要添加更多的路径段，而我们的原型就在这里达到了极限。
- en: Referring to the previous code listing, each path of the ribbon has been predefined
    in the form of the `pathA`, `pathB`, `pathC`, and `pathD` arrays. If we want to
    add more segments, we need to manually add the additional path array, along with
    the appropriate logic, to locate path segments that aren’t at 90-degree right-angles
    to each other correctly – and that makes our current approach much tougher. There’s
    a certain mindset that prefers to attack this sort of problem head-on, with brute
    force. They might add `pathE`, `pathF`, or `pathG` arrays and pre-calculate the
    paths’ offsets relative to one another based on hardcoded numbers and after the
    dust settles, what comes out will probably work just fine… until the need arises
    to change the number of segments again. Or worse yet, the need arises to *dynamically*
    set the number of paths based on, for example, device performance characteristics.
    That’s why it’s necessary to come up with a Better Way Forward.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的代码列表，带状路径的每条路径都已预定义，形式为`pathA`、`pathB`、`pathC`和`pathD`数组。如果我们想添加更多段，我们需要手动添加额外的路径数组，以及适当的逻辑，以正确定位彼此不是90度直角的路径段——这使得我们的当前方法变得更加困难。有一种特定的思维方式更喜欢直接面对这类问题，使用蛮力。他们可能会添加`pathE`、`pathF`或`pathG`数组，并基于硬编码的数字预先计算路径相对于彼此的偏移量，尘埃落定后，出来的结果可能工作得很好……直到需要再次更改段数。或者更糟糕的是，需要根据例如设备性能特性*动态地*设置路径数量。这就是为什么有必要想出一个更好的前进方法。
- en: 'Let’s jump back to the original Playground we started with – `NUM_SEGMENTS`
    constant. Next, we need to instantiate new path arrays to hold each path. We do
    this in a simple loop:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们最初开始的原始游乐场——`NUM_SEGMENTS`常量。接下来，我们需要实例化新的路径数组来保存每条路径。我们通过一个简单的循环来完成这个操作：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Great – we have our array of path arrays ready to go. Now, it’s time to populate
    those paths, so we set up an outer loop over `routePath` containing an inner loop
    over each path array. But how do we figure out where each point of each path is
    supposed to be located? It’s not enough to use the simple constant offsets to
    each point position like we did in the prototype; each path segment’s points will
    have different offset values from each other. In the following diagram, the hoop
    or ring shape is a single cross-section segment, with all points lying in the
    same plane (math folks call this an affine set of points):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们准备好了路径数组的数组。现在，是时候填充这些路径了，所以我们设置了一个外层循环遍历`routePath`，包含一个内层循环遍历每个路径数组。但我们如何确定每条路径的每个点的位置？仅仅使用像原型中那样对每个点位置使用简单的常数偏移量是不够的；每个路径段的点将彼此有不同的偏移值。在下面的图中，环形或环形形状是一个单独的横截面段，所有点都位于同一平面（数学家称之为点的仿射集）：
- en: '![Figure 8.5 – Creating a point of route geometry starts from the center point
    that moves clockwise around the diameter, adding path points for each discrete
    segment](img/Figure_8.05_B17266.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 创建路线几何的点从中心点开始，该点沿直径顺时针移动，为每个离散段添加路径点](img/Figure_8.05_B17266.jpg)'
- en: Figure 8.5 – Creating a point of route geometry starts from the center point
    that moves clockwise around the diameter, adding path points for each discrete
    segment
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 创建路线几何的点从中心点开始，该点沿直径顺时针移动，为每个离散段添加路径点
- en: Start from the current route position and use it as the center point. Now, focusing
    on one individual execution of the outer-most loop through `routeData`, we know
    that we need to create points equal in number to the number of desired segments.
    We also know that those segments should be evenly and contiguously distributed
    around the diameter of a hypothetical circle.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从当前路线位置开始，并以此作为中心点。现在，专注于通过`routeData`执行最外层循环的单一实例，我们知道我们需要创建与所需段数相等的点。我们还知道这些段应该均匀且连续地分布在假设圆的直径周围。
- en: Note
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The reason we use a circle rather than a sphere is that relative to a given
    route point, the *Z*-axis values will always be the same for every path segment
    around that point. This is rather tautological since that’s also a somewhat meandering
    way to define a circle!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用圆而不是球体的原因是，相对于给定的路线点，每个路径段的*Z*轴值对于该点的每个路径段始终相同。这相当自相矛盾，因为这也是定义圆的一种相当曲折的方式！
- en: 'Putting those facts together and combining them with what we already know regarding
    circles and trig functions, we have a way to do just what we want. There’s just
    one remaining obstacle: how can we vary the position offset on the individual
    path being computed? Fortunately, this isn’t as big of an issue as it might seem
    at first.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些事实放在一起，并结合我们已知的关于圆和三角函数的知识，我们就有了一种实现我们想要的方法。唯一剩下的障碍是：我们如何改变正在计算的单独路径上的位置偏移量？幸运的是，这个问题并没有看起来那么大。
- en: 'Let’s remind ourselves of these facts about circles and trigonometric functions.
    The sine and cosine functions each take an input angle (in radians for this text
    unless otherwise noted) and output a value between -1 and 1 corresponding to the
    angle-dependent *X*- and *Y*-axis values, respectively. A full circle comprises
    two times Pi (3.14159…) radians, or about 6.28 radians. If we divide the number
    of segments by 6.28 radians, we would get the arc that an individual segment traverses,
    but if we divide the number of segments by the zero-based index of the currently
    iterating segment, then we get something more useful – the position between 0..1
    of our current segment. A percentage, or ratio in other words. By multiplying
    that ratio with our two times Pi value, we get… the position of the segment, in
    radians! All that’s left is to scale the result by a value representing the desired
    radius (or diameter, for the *X*-axis) and add it to the path collection:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次提醒自己关于圆和三角函数的事实。正弦和余弦函数各自接受一个输入角度（除非另有说明，否则以弧度为单位），并输出一个介于-1和1之间的值，分别对应于角度相关的*X*-和*Y*-轴值。一个完整的圆包含两倍的Pi（3.14159…）弧度，或大约6.28弧度。如果我们把线段的数量除以6.28弧度，我们就会得到单个线段所跨越的弧，但如果我们把线段的数量除以当前迭代的线段的零基索引，那么我们就会得到更有用的事情——我们当前线段的位置在0..1之间。换句话说，一个百分比，或比率。通过将这个比率乘以两倍的Pi值，我们得到…线段的位置，以弧度为单位！剩下的只是将结果按代表所需半径（或直径，对于*X*-轴）的值进行缩放，并将其添加到路径集合中：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code listing from `velocity` vector to determine the size of
    the space-road. We must `clone` the `last` point before mutating it; otherwise,
    we will end up corrupting the data needed by the rest of the application. By setting
    the value of `NUM_SEGMENTS` to `4` and progressively running the Playground at
    increasing numbers, it’s easy to see that the updated logic can now handle an
    arbitrary amount of line segments – an enormous improvement over our first-generation
    prototype! This code will be ready to integrate with the application when we’re
    ready to begin that process starting in the *Initializing the Driving Phase* section.
    There are still a few more things to prove out in other areas before that can
    happen, though. The `loadAssets` function is next up on our list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码列表中，从`速度`向量到确定空间道路的大小。我们必须在修改它之前`克隆`最后一个点；否则，我们最终会破坏应用程序其余部分所需的数据。通过将`NUM_SEGMENTS`的值设置为`4`并逐步以递增的数字运行沙盒，我们可以很容易地看到更新的逻辑现在可以处理任意数量的线段——这比我们的第一代原型有了巨大的改进！当我们准备从*初始化驾驶阶段*部分开始那个过程时，这段代码将准备好与应用程序集成。但在那之前，我们还需要在其他领域证明一些事情。`loadAssets`函数是我们列表中的下一个。
- en: Loading Assets Asynchronously
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步加载资产
- en: 'In this Playground, we’re going to be loading two things asynchronously as
    part of the `loadAssets` function – the semi-truck model and the radar procedural
    texture asset. We need to make sure that all the asynchronous function calls have
    been completed before continuing by returning a promise that resolves only when
    all of its constituent promises have done so as well. Here’s what that looks like
    in `loadAssets()`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个沙盒中，我们将作为`loadAssets`函数的一部分异步加载两样东西——半挂车模型和雷达程序纹理资产。我们需要确保在继续之前所有异步函数调用都已经完成，通过返回一个只有在所有其构成承诺都这样做之后才会解决的承诺来实现。这就是在`loadAssets()`中看起来像什么：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`nodeMatProm` is created using a pattern that is used throughout Babylon.js
    and one we most recently used in the previous chapter’s discussion on loading
    JSON for a `ParticleSystemSet`, only for this Playground, instead of loading JSON
    directly, we will load data from the Babylon.js Snippet Server. Specifically,
    we are loading a snippet from the **Node Material Editor** (**NME**) that we will
    then use to create the radar procedural texture that is displayed on the GUI.
    Further details on those elements will have to wait until [*Chapter 11*](B17266_11_Final_AM.xhtml#_idTextAnchor230),
    *Scratching the Surface of Shaders*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodeMatProm` 是使用在 Babylon.js 中广泛使用的一种模式创建的，我们最近在上一章关于加载 `ParticleSystemSet`
    JSON 的讨论中使用过。但在这个 Playground 中，我们不是直接加载 JSON，而是从 Babylon.js Snippet Server 加载数据。具体来说，我们正在加载来自
    **节点材质编辑器**（**NME**）的片段，然后我们将使用它来创建显示在 GUI 上的雷达程序纹理。关于这些元素的更多细节将留待 [*第 11 章*](B17266_11_Final_AM.xhtml#_idTextAnchor230)，*Shader
    的表面之下* 中讨论。'
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'While it may be obvious that `radarTexture` is a variable containing the `radarTextureResolution`
    value comes in. One of the difficulties in creating a “simple” game prototype
    is that even something simple requires creating and managing a fair amount of
    configuration data. The `gameData` structure serves the purpose of centralizing
    and consolidating access to these types of values; when we want to utilize one
    or more of these values in a function, we can use JavaScript’s **deconstruction**
    feature to simplify and make our code much more readable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能很明显，`radarTexture` 是一个包含 `radarTextureResolution` 值的变量。创建一个“简单”的游戏原型的一个困难之处在于，即使是简单的东西也需要创建和管理相当数量的配置数据。`gameData`
    结构的作用是集中和整合对这些类型值的访问；当我们想在函数中使用一个或多个这些值时，我们可以使用 JavaScript 的 **解构** 功能来简化代码并使其更易于阅读：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we saw in the preceding code block, `radarTextureResolution` is used for
    determining the render height and width in pixels of the procedural texture, whereas
    we’ll shortly see how `truckModelName` and `truckModelScaling` are used. The `SceneLoader.ImportMeshAsync`
    method (new to v5!) takes an optional list of model names, along with the path
    and filename of an appropriate file containing the meshes to load (for example,
    `.glb`, `.gltf`, `.obj`, and so on), along with the current scene. The promise
    that’s returned resolves to an object containing the loaded file’s `meshes`, `particleSystems`,
    `skeletons`, and `animationGroups`, although we’re only going to be using the
    meshes collection for this scenario.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的代码块中看到的，`radarTextureResolution` 用于确定程序纹理的渲染高度和宽度（以像素为单位），而我们将很快看到 `truckModelName`
    和 `truckModelScaling` 的用途。`SceneLoader.ImportMeshAsync` 方法（新引入 v5！）接受一个可选的模型名称列表，以及包含要加载的网格的适当文件的路径和文件名（例如，`.glb`、`.gltf`、`.obj`
    等），以及当前场景。返回的承诺解析为一个包含加载文件 `meshes`、`particleSystems`、`skeletons` 和 `animationGroups`
    的对象，尽管在这个场景中我们只将使用网格集合。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about `SceneLoader` and its related functionality at [https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes#sceneloaderimportmesh](https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes#sceneloaderimportmesh).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes#sceneloaderimportmesh](https://doc.babylonjs.com/divingDeeper/importers/loadingFileTypes#sceneloaderimportmesh)
    了解更多关于 `SceneLoader` 及其相关功能的信息。
- en: 'Once we’ve loaded the semi-truck’s model file, we’ve got a bit more work to
    do before we can start using the loaded asset. Models saved in the GLTF or GLB
    formats are imported into Babylon.js with some additional properties that are
    going to get in our way, so let’s simplify and set up `truckModel` for the game
    world:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了半挂车的模型文件，我们还需要做一些额外的工作，才能开始使用加载的资产。以 GLTF 或 GLB 格式保存的模型在导入 Babylon.js
    时会带有一些额外的属性，这些属性可能会妨碍我们，所以让我们简化并设置 `truckModel` 以适应游戏世界：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The first few lines of our processing pipeline perform some convenient setup
    for the variables from the result structure, but then we do something a bit unusual
    by setting the parent of `truckModel` to `null` before disposing of the first
    mesh in the `meshes` array – what’s up with that, and what’s with `SCENE_MASK`?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们处理管道的前几行对结果结构中的变量进行了一些方便的设置，但然后在处理 `meshes` 数组中的第一个网格之前，我们将 `truckModel` 的父级设置为
    `null`，这是怎么回事，`SCENE_MASK` 又是什么意思？
- en: Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For more on layer masks and how they operate, see the docs at [https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam](https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于层掩码及其如何工作的信息，请参阅文档：[https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam](https://doc.babylonjs.com/divingDeeper/cameras/layerMasksAndMultiCam)。
- en: 'The answer to the second is, briefly, that cameras can be assigned a specific
    number that only allows meshes with a compatible `layerMask` to be rendered by
    that camera. We use the `layerMask` property to hide non-GUI meshes from the main
    scene camera, for example. The answer to the first lies in the specifics of how
    an asset is loaded from a GLB or GLTF file. When Babylon.js reads in the file,
    there is an invisible transform node named `__root__` placed at the root of the
    model hierarchy. Although it doesn’t cause any problems in simple scenarios, when
    dealing with physics, parenting, collisions, and transforms, it becomes a major
    hindrance. The following screenshot illustrates what this looks like in the **Scene
    Inspector** window:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题的答案是，简而言之，相机可以分配一个特定的编号，这个编号只允许具有兼容的 `layerMask` 的网格被该相机渲染。我们使用 `layerMask`
    属性来隐藏非 GUI 网格从主场景相机中，例如。第一个问题的答案在于从 GLB 或 GLTF 文件加载资产的具体细节。当 Babylon.js 读取文件时，在模型层次结构的根位置放置了一个名为
    `__root__` 的不可见变换节点。尽管在简单场景中不会引起任何问题，但在处理物理、父节点、碰撞和变换时，它成为一个主要的障碍。以下截图说明了在 **场景检查器**
    窗口中看起来是什么样子：
- en: '![Figure 8.6 – The Alien.gltf model. The Scene Inspector window shows the __root__
    transform node. From https://playground.babylonjs.com/#8IMNBM#1](img/Figure_8.06_B17266.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – Alien.gltf 模型。场景检查器窗口显示了 __根__ 变换节点。来源：https://playground.babylonjs.com/#8IMNBM#1](img/Figure_8.06_B17266.jpg)'
- en: Figure 8.6 – The Alien.gltf model. The Scene Inspector window shows the __root__
    transform node. From [https://playground.babylonjs.com/#8IMNBM#1](https://playground.babylonjs.com/%238IMNBM%231)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – Alien.gltf 模型。场景检查器窗口显示了 __根__ 变换节点。来源：[https://playground.babylonjs.com/#8IMNBM#1](https://playground.babylonjs.com/%238IMNBM%231)
- en: 'The Alien geometry is what we’re interested in working with, but because it
    is parented to the `__root__` node, any changes to the position, rotation, or
    scaling of `Alien` are evaluated in a coordinate space relative to that root node,
    resulting in undesired and unpredictable results. The solution to this is simple
    and answers our earlier question regarding what was up with our `loadAssets` code
    – unparent the desired mesh and dispose of the root. Once that’s accomplished,
    the rest of the code in our truck loading method is all housekeeping setup for
    the model – with some important considerations to keep in mind:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的是与 Alien 几何体一起工作，但由于它被连接到 `__root__` 节点，对 `Alien` 的位置、旋转或缩放的任何更改都是在相对于该根节点的坐标系中评估的，这会导致不希望的和不可预测的结果。这个问题的解决方案很简单，回答了我们之前关于
    `loadAssets` 代码中发生了什么的问题——取消所需网格的父节点并丢弃根节点。一旦完成，我们卡车加载方法中的其余代码都是为模型进行的家务设置——有一些重要的考虑事项需要记住：
- en: Order of operations is important, but not in the way you might think. Changes
    to a `TransformNode` (which `Mesh` is a descendent of) over a given frame are
    applied in the fixed order of **Transform, Rotate, Scale** (**TRS**).
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作顺序很重要，但不是你想象中的那种方式。在给定帧中对 `TransformNode`（`Mesh` 是其子类）的更改按照固定的顺序 **变换、旋转、缩放**（**TRS**）应用。
- en: Use `setParent(null)` rather than the alternative of setting `mesh.parent =
    null`. The `setParent` function preserves positional and rotational values, whereas
    setting the parent to null does not. This results in any root transformations
    being removed from the mesh, which is why we need to reset the position and rotation
    vectors.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `setParent(null)` 而不是将 `mesh.parent` 设置为 `null` 的替代方案。`setParent` 函数保留位置和旋转值，而将父节点设置为
    `null` 则不会。这会导致从网格中移除任何根变换，这就是为什么我们需要重置位置和旋转向量。
- en: Once the transformations have been cleared and the scaling has been set to world-appropriate
    values, the mesh geometry will need to have new bounding information generated.
    Otherwise, collisions won’t work properly. The solution to this is the two-step
    process of calling `mesh.bakeCurrentTransformIntoVertices()` before calling `mesh.refreshBoundingInfo()`.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦变换被清除并且缩放被设置为适合世界的值，网格几何体将需要生成新的边界信息。否则，碰撞将无法正常工作。这个问题的解决方案是在调用 `mesh.refreshBoundingInfo()`
    之前调用 `mesh.bakeCurrentTransformIntoVertices()` 的两步过程。
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Normally, it’s not recommended to call `bakeCurrentTransformIntoVertices` when
    there are better options such as **parenting** and **pivotPoints** that might
    work. In this case, we need to perform this step since we’ve removed the parenting
    to root. See [https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/bakingTransforms](https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/bakingTransforms)
    for more information and guidance on this topic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不建议在存在更好的选项（如 **parenting** 和 **pivotPoints**）时调用 `bakeCurrentTransformIntoVertices`。在这种情况下，我们需要执行此步骤，因为我们已经从根节点移除了父级。有关此主题的更多信息和建议，请参阅[https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/bakingTransforms](https://doc.babylonjs.com/divingDeeper/mesh/transforms/center_origin/bakingTransforms)。
- en: As mentioned previously, the result of calling `Promise.all` with the unresolved
    promises is the returned `loadAssets`, bringing us full circle back to where this
    discussion started! Initialization is mostly done – or at least the portion of
    it taking the longest time is complete – and now with the availability of the
    semi-truck model, the `initializeDrivingPhase` function has been invoked to set
    up the rest of the scene’s elements. This function sets up the cameras, creates
    the ground ribbon mesh from the `routePaths`, sets up physics, and more.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，调用 `Promise.all` 与未解决的承诺的结果是返回的 `loadAssets`，使我们回到了这次讨论的起点！初始化主要完成——或者至少是最耗时的部分完成——现在随着半挂车模型的可用性，`initializeDrivingPhase`
    函数已被调用以设置场景的其他元素。此函数设置摄像机，从 `routePaths` 创建地面带状网格，设置物理属性，等等。
- en: Initializing the Driving Phase Scene
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化驾驶阶段场景
- en: As mentioned in this chapter’s introduction, the viewpoint for the player is
    in a third-person perspective, with the camera behind the semi-truck and looking
    over its top. As the truck moves (translation) or rotates (um, rotation), the
    camera mimics every movement from its offset position. The way this is accomplished
    is one of those situations where real-world analogies match well to software,
    in the form of `cameraDolly`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章引言所述，玩家的视点是第三人称视角，摄像机位于半挂车后面，并从上方俯视。随着卡车的移动（平移）或旋转（嗯，旋转），摄像机从其偏移位置模仿每一个动作。这是通过将现实世界的类比很好地匹配到软件中的一种情况，即
    `cameraDolly`。
- en: 'A camera dolly is normally an engineered sort of cart used in the film industry
    that allows the Grip operating the camera to smoothly move in multiple dimensions
    while capturing footage. Our camera dolly doesn’t run on tracks, but it fulfills
    a similar purpose by moving with the truck to maintain the same forward-facing
    orientation regardless of the truck’s world-space orientation. This can be accomplished
    in just a few steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像车通常是一种在电影行业中使用的工程式手推车，它允许操作摄像机的摄影师在多个维度上平滑移动并捕捉画面。我们的摄像机车不使用轨道，但它通过随卡车移动来保持相同的面向前方方向，无论卡车的世界空间方向如何。这可以通过几个步骤完成：
- en: Create a `TransformNode` to serve as the “camera dolly:”
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `TransformNode` 作为“摄像机车”：
- en: '[PRE11]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define an `ArcRotateCamera` and set up its basic properties. We’re patching
    property values in from `gameData` structures to reduce the amount of code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个 `ArcRotateCamera` 并设置其基本属性。我们正在从 `gameData` 结构中修补属性值以减少代码量：
- en: '[PRE12]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Order of operations is important for this and the next step! First, parent `cameraDolly`
    to `truckMesh`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作顺序对于这一步和下一步都很重要！首先，将 `cameraDolly` 父级设置为 `truckMesh`。
- en: 'Now, parent `followCamera` to `cameraDolly`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将 `followCamera` 父级设置为 `cameraDolly`：
- en: '[PRE13]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first thing that happens in the `initializeDrivingPhase` method is that
    the camera gets created and the Viewport is set up. A quick aside to explain a
    bit more about that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initializeDrivingPhase` 方法中发生的第一件事是创建摄像机并设置视口。这里简要说明一下这一点。
- en: If a `(0,0)` and has a size of `(1,1)`. In other words, the default Viewport’s
    top-left corner is located at `(0,0)` and the bottom-right corner is located at
    `(1,1)`; the entire screen is covered by it. This is greatly desired when a Scene
    has but a single camera, but there are many circumstances where it is useful to
    have a second camera positioned somewhere in the scene that renders to a smaller
    segment of the full screen – think of strategy games that provide a mini-map or
    racing games that have a rear-view mirror display.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个 `(0,0)` 并且大小为 `(1,1)`。换句话说，默认视口的左上角位于 `(0,0)`，右下角位于 `(1,1)`；整个屏幕都被它覆盖。当场景只有一个摄像机时，这非常理想，但在许多情况下，在场景中某个位置放置一个渲染到整个屏幕较小部分的第二个摄像机是有用的——想想提供迷你地图的策略游戏或具有后视镜显示的赛车游戏。
- en: 'In most cases, there are elements of the scene that should be rendered just
    in one camera, but not in another, which is finally where we make the connection
    with Layer Masks. By setting `layerMask` of all the involved cameras and meshes,
    we can efficiently show or hide geometry according to the mesh’s role in the scene.
    Our driving screen currently has two separate layer masks: `SCENE_MASK` and `GUI_MASK`.
    Cleverly toggling a mesh’s `layerMask` property can allow fine-grained control
    over camera rendering; if we want to display the mesh on one camera or the other,
    we can explicitly set its `layerMask` to `SCENE_MASK` or `GUI_MASK` (`0x00000001`
    and `0x00000002`, respectively). If we wish to display a mesh on *both* cameras,
    we can set and/or leave the default layer mask value in place (`0xFFFFFFFF`).
    Now that we know what’s going on with the viewport, we can get back to the function
    code.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，场景中应该只在一个相机中渲染某些元素，但在另一个相机中不渲染，这正是我们与层掩码建立联系的地方。通过设置所有相关相机和网格的`layerMask`，我们可以根据网格在场景中的作用高效地显示或隐藏几何形状。我们的驾驶屏幕目前有两个独立的层掩码：`SCENE_MASK`和`GUI_MASK`。巧妙地切换网格的`layerMask`属性可以允许对相机渲染进行精细控制；如果我们想在某个相机上显示网格，我们可以显式地将它的`layerMask`设置为`SCENE_MASK`或`GUI_MASK`（分别为`0x00000001`和`0x00000002`）。如果我们想在两个相机上显示网格，我们可以设置和/或保留默认的层掩码值（`0xFFFFFFFF`）。现在我们知道了视口的情况，我们可以回到函数代码。
- en: 'After setting up the viewport, the parenting steps listed previously are executed.
    The `MeshBuilder.CreateRibbon` method is the next point of interest, where we
    pass the array or path arrays into the options of the function and get back our
    path geometry, which then gets some property tweaks and a grid material (for now)
    assigned:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好视口之后，执行之前列出的父级步骤。`MeshBuilder.CreateRibbon`方法是下一个关注的点，我们将数组或路径数组传递到函数的选项中，并获取我们的路径几何形状，然后对其进行一些属性调整，并分配一个网格材质（目前是这样）：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the ribbon created, material assigned, and a physics impostor similarly
    created and assigned to the ground mesh, the restitution property makes anything
    hitting the wall rebound with a little less momentum than before. That’s new,
    but there’s a bit of a twist (highlighted in the preceding code block) with the
    type of impostor we’re using here as well – `MeshImpostor`. Previously only available
    in the CannonJS physics plugin, where it is limited to interacting only with spheres,
    `MeshImpostor` is different from the other `PhysicsImpostor` types we’ve previously
    looked at (`Box` and `Sphere`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建出带状物、分配了材质，并将一个物理模拟器同样创建并分配给地面网格之后，恢复系数属性使得任何撞击墙壁的物体都比之前具有更小的动量反弹。这是新的，但这里使用的模拟器类型（`MeshImpostor`）也有一些转折（在先前的代码块中突出显示）——与之前我们查看的其他`PhysicsImpostor`类型（`Box`和`Sphere`）不同。`MeshImpostor`之前仅在CannonJS物理插件中可用，在那里它仅限于与球体交互。
- en: Instead of using a rough approximation of the physics-enabled object’s geometry,
    it uses that very geometry itself to provide precise collision detection! The
    trade-off is that collision computation becomes more expensive the more complex
    the mesh’s geometry is structured. We should be OK for our needs though, since
    we don’t need our obstacles (that is, encounters) to interact with the path, leaving
    just the truck with complex collision calculation needs. Just a few more tasks
    remain before we will be done with our preparations and be ready to write the
    runtime logic!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用物理启用对象的几何形状的粗糙近似不同，它使用那个几何形状本身来提供精确的碰撞检测！代价是，随着网格几何结构的复杂度增加，碰撞计算变得更加昂贵。不过，对于我们的需求来说，应该没问题，因为我们不需要我们的障碍物（即，遭遇）与路径交互，只需让卡车具有复杂的碰撞计算需求。在我们完成准备工作并准备好编写运行时逻辑之前，还有一些任务需要完成！
- en: After setting up the physics of `truckModel` – albeit using the equally applicable
    and much simpler `BoxImpostor` – we spawn some sample obstacles along the path
    before setting up an `OnIntersectionExitTrigger` that calls `killTruck` whenever
    the truck exits the `routePath` ribbon mesh’s confines. The `spawnObstacles` function
    will ultimately be discussed in the *Adding Encounters* section, so skipping over
    a discussion of that leads us to the familiar-in-practice of setting up `ground.actionManager`
    with the appropriate trigger (see the section on *Defining the EncounterZones
    in* [*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142)*, Processing Route
    Data*) – another place that is familiar enough to skip past. Now, we approach
    the final act of the `initializeDrivingPhase` function – (re)setting the truck
    to its starting position and state.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`truckModel`的物理属性——尽管使用了同样适用但更简单的`BoxImpostor`——之后，我们在设置`OnIntersectionExitTrigger`之前在路径上生成一些样本障碍物，该触发器会在卡车退出`routePath`带状网格的界限时调用`killTruck`。`spawnObstacles`函数将在*添加遭遇*部分进行讨论，因此跳过对这个问题的讨论将我们引向了实践中熟悉的设置`ground.actionManager`的过程，使用适当的触发器（参见*在*
    [*第7章*](B17266_07_Final_AM.xhtml#_idTextAnchor142)*中定义遭遇区域*，处理路线数据*）——另一个足够熟悉以至于可以跳过的部分。现在，我们接近`initializeDrivingPhase`函数的最后一部分——（重新）设置卡车到其起始位置和状态。
- en: Using our sample route data, we could empirically determine what coordinates
    in the world space the truck should start at, its initial rotation, and other
    such values. We would iteratively refine our values through trial and error until
    the results were satisfactory, but would that satisfy our requirements? No.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的样本路线数据，我们可以通过实验确定卡车在世界空间中的起始坐标，其初始旋转以及其他类似的值。我们会通过试错法迭代地细化我们的值，直到结果令人满意，但那会满足我们的要求吗？不。
- en: Note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you ever see a question asked in the preceding fashion, the answer is almost
    always “No.” This is the second instance in this chapter of that kind of rhetorical
    writing. Can you spot the third?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到有人以这种方式提出问题，答案几乎总是“不。”这是本章中那种修辞写作的第二种情况。你能找到第三种吗？
- en: That entire trial and error approach will not “satisfy our requirements,” no
    thank you sir! We can make this extremely easy on ourselves by recalling that
    we already know exactly and precisely where the truck should start, where it should
    be pointing, and how fast it should be moving in the form of our pal `route.path3d`.
    It was mentioned in the earlier discussion on `Path3D`, it is a mathematical construct,
    and two of the more useful functions it provides, `getPointAt` and `getTangentAt`,
    are used to help us position the truck, but we didn’t get much into the details
    of why they’re useful.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那种整个试错的方法不会“满足我们的要求”，不，谢谢先生！我们可以通过回忆我们已经确切地知道卡车应该从哪里开始，它应该指向哪里，以及它应该以多快的速度移动，这些信息都包含在我们的朋友`route.path3d`中，来极大地简化这个过程。在之前关于`Path3D`的讨论中已经提到，它是一个数学结构，它提供的两个更有用的函数`getPointAt`和`getTangentAt`被用来帮助我们定位卡车，但我们并没有深入探讨为什么它们是有用的。
- en: Think about a path of some arbitrary length that consists of several points.
    Every point along that path has a set of vectors describing the position (naturally!),
    the `Path3D` instance, making it easy to work with.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个由几个点组成的任意长度的路径。路径上的每个点都有一组描述位置的向量（当然是！），`Path3D`实例，这使得处理起来变得容易。
- en: If we think of the point’s position in the path’s collection of points (that
    is, what index it occupies in the array) as being the ratio between the index
    and the total number of elements, then we can easily picture that ratio being
    a percentage, or a number between 0 and 1 (inclusive of both). `Path3D` module
    all accept a number representing the percentage (between 0 and 1) along the path
    to operate against and include the related `getNormalAt`, `getBinormalAt`, and
    `getDistanceAt` functions.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将点的位置在路径点集合中的位置（即它在数组中占据的索引）视为索引与元素总数的比率，那么我们就可以很容易地想象这个比率是一个百分比，或者一个介于0和1之间的数（包括两者）。`Path3D`模块都接受一个表示路径上百分比的数字（介于0和1之间）来进行操作，并包括相关的`getNormalAt`、`getBinormalAt`和`getDistanceAt`函数。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There are more interpolation functions to explore! See [https://doc.babylonjs.com/divingDeeper/mesh/path3D#interpolatio](https://doc.babylonjs.com/divingDeeper/mesh/path3D#interpolatio)
    for the full list.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多的插值函数可以探索！有关完整列表，请参阅[https://doc.babylonjs.com/divingDeeper/mesh/path3D#interpolatio](https://doc.babylonjs.com/divingDeeper/mesh/path3D#interpolatio)。
- en: 'This is useful because you don’t need to know what the length of the path is
    or how many points are in it to obtain useful information. In the `resetTruck`
    function, we get the position and the tangent of the first point in the route
    – the beginning of the path – then set the truck’s properties accordingly:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，因为你不需要知道路径的长度或其中有多少个点，就能获得有用的信息。在`resetTruck`函数中，我们获取路线中第一个点的位置和切线——路径的起点——然后相应地设置卡车的属性：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since the physics engine sets and uses the `rotationQuaternion` property, we
    can’t just use the vector provided by `getTangentAt(0)` – we need to convert it
    into a Quaternion using the `FromLookDirectionRH` method. This function takes
    two vectors for its arguments: the first, a vector representing the desired forward
    direction, and then another vector representing the orthogonal (for example, perpendicular
    along all axis), with the return value being a Quaternion representing the input
    vectors. After setting the truck’s position and rotation, it’s necessary to reset
    the truck’s physical values for velocity since, from the physics engine’s perspective,
    the effects of being moved and rotated would need to be considered. Therefore,
    the `reset` method is a deterministic function – the effect on the state of the
    scene is always the same whenever it is called. This makes it especially useful
    to use it both immediately post-initialization and any time that the player chooses
    to do so. We listen for that player input in this Playground’s update method.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于物理引擎设置并使用`rotationQuaternion`属性，我们无法直接使用`getTangentAt(0)`提供的向量——我们需要使用`FromLookDirectionRH`方法将其转换为四元数。此函数接受两个向量作为参数：第一个，表示所需的前进方向的向量，然后是另一个表示正交的向量（例如，沿所有轴垂直），返回值是一个表示输入向量的四元数。在设置卡车的位置和旋转后，有必要重置卡车的物理值，因为从物理引擎的角度来看，移动和旋转的效果需要被考虑。因此，`reset`方法是一个确定性函数——每次调用时对场景状态的影响总是相同的。这使得它在初始化后立即使用以及玩家选择这样做时都非常有用。我们在这个Playground的更新方法中监听那个玩家输入。
- en: Running the Update Loop
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行更新循环
- en: Most of the code discussed up to this point has been code that directly relates
    to the context at hand. That’s the great thing about Babylon.js and its tooling
    – many common tasks are possible to complete with just a few lines of code. The
    `update` method is a good example of that but it’s also an example of one of the
    few places in the Playground where the code will need to be changed around completely
    to integrate it with the application, simply due to the more complex nature of
    the application versus the much more narrowly scoped Playground (see the next
    section, *Integrating with the Application*, for more). For that reason, we aren’t
    going to look too hard at the specifics of the function and instead focus on the
    mechanics of how the truck is controlled by the logic in it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的大多数代码都与当前上下文直接相关。这正是Babylon.js及其工具的伟大之处——许多常见任务只需几行代码即可完成。`update`方法是一个很好的例子，但它也是Playground中需要完全更改代码以与应用程序集成的少数几个地方之一，这仅仅是因为应用程序比Playground的范围更广（有关更多信息，请参阅下一节，*与应用程序集成*）。因此，我们不会深入研究函数的具体细节，而是专注于卡车是如何通过其中的逻辑来控制的机制。
- en: The truck can be controlled in the three translational axes (forward/back, left/right,
    up/down) and one rotational axis (the yaw axis), which might seem to make for
    a total of eight separate pieces of logic to handle the motion. However, since
    pairs of actions (for example, left and right) are simply the negated values of
    each other, we only need to figure it out for four – a nice reduction in complexity.
    In each frame, the delta frame time variable is used to scale `truckAcceleration`
    and `truckTurnSpeedRadians` to the correct values; the `currVelocity` and `currAngVel`
    counter variables track the accumulated changes that are then applied to the physics
    model’s linear and angular velocities at the end of the update process. This is
    like what we’ve done in the past, but some mathematical tools are being employed
    that we’ve not yet seen that are worth taking a closer look at.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 卡车可以在三个平移轴（前进/后退、左/右、上/下）和一个旋转轴（偏航轴）上被控制，这似乎需要处理运动的总共八种不同的逻辑。然而，由于一对动作（例如，左和右）只是彼此的相反值，我们只需要考虑四种——这是一个很好的复杂性降低。在每个帧中，delta帧时间变量被用来将`truckAcceleration`和`truckTurnSpeedRadians`缩放到正确的值；`currVelocity`和`currAngVel`计数变量跟踪累积的变化，然后在更新过程的最后将这些变化应用到物理模型的线性和角速度上。这就像我们过去所做的那样，但正在使用一些我们尚未见过的数学工具，值得我们仔细研究。
- en: 'Changing the forward or backward translational velocity is simple – just get
    the current forward vector for the truck mesh, scale it by `currAccel`, then add
    it to the `currVelocity` counter; the backward vector consists of the negated
    value of the forward vector:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 改变前进或后退的平移速度很简单——只需获取卡车网格的当前前进向量，将其乘以`currAccel`，然后将其加到`currVelocity`计数器上；后退向量由前进向量的相反值组成：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: All of the various `Vector3` math methods come in various flavors that allow
    the developer to control whether or not the operation should allocate memory or
    reuse an existing object. In this case, we are using the `addInPlace` function
    to avoid creating a new vector object, whereas we create a new `Vector3` with
    the `currDir.scale(currAccel)` function call to avoid corrupting the truck mesh’s
    forward vector – a value relied upon by the engine for proper rendering.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的`Vector3`数学方法都有各种风味，允许开发者控制操作是否应该分配内存或重用现有对象。在这种情况下，我们使用`addInPlace`函数来避免创建新的向量对象，而使用`currDir.scale(currAccel)`函数调用创建一个新的`Vector3`，以避免破坏卡车网格的前进向量——这是引擎用于正确渲染所依赖的值。
- en: Important note
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Knowing when and what to perform memory allocation and disposal with can be
    key to a smoothly rendered scene. See [*Chapter 13*](B17266_13_Final_AM.xhtml#_idTextAnchor264),
    *Converting the Application to a PWA*, for more information and guidance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 知道何时以及如何进行内存分配和释放对于渲染流畅的场景至关重要。参见[*第13章*](B17266_13_Final_AM.xhtml#_idTextAnchor264)，*将应用程序转换为PWA*，获取更多信息和建议。
- en: 'Back to our truck’s control logic, the mathematical trick is in how we figure
    out what direction to apply the remaining translational and rotational forces.
    Translating to the truck’s left or right is done by taking the cross product of
    the truck’s forward vector and the truck’s up vector – the result is a vector
    pointing in either the left or right direction (the same trick with `negateInPlace`
    can yield the opposite side from the same inputs):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们卡车的控制逻辑，数学技巧在于我们如何确定应用剩余的平移和旋转力的方向。将卡车向左或向右移动是通过取卡车的前进向量和卡车向上向量的叉积来完成的——结果是指向左或右方向的向量（使用`negateInPlace`的相同技巧可以从相同的输入中得到相反的一侧）：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Allowing players to side-strafe at the same speed as the other directions feels
    a bit too easy to lose control of the truck, so we cut the value in half to help
    players keep their speed under control. After integrating the accumulated changes
    to velocities and resetting the accumulation counters, the respective linear and
    angular physics properties are set along with an angular “damping” mechanism to
    help ease control:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 允许玩家以与其他方向相同的速度进行侧滑可能会让卡车失去控制，所以我们将其值减半，以帮助玩家控制速度。在将累积的速度变化整合并重置累积计数器后，相应的线性和角物理属性被设置，同时设置一个角“阻尼”机制以帮助缓解控制：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: That’s the end of the Playground’s update method, as well as the end of our
    examination of the driving phase prototype. After looking through what we want
    to accomplish overall with the Playground, we learned how to take the raw route
    data and turn it into a segmented tube encompassing the path. In an asynchronous
    loading method, we saw how a GLTF model can be imported and prepared for use with
    a Scene before we saw how the `initializeDrivingPhase` function sets up the camera
    dolly, physics, and obstacles along the path. With the `reset` method, we saw
    how to use the `Path3D` methods to properly position the truck, regardless of
    where it is and what state it is in. Not counting the GUI (which we’ll cover in
    the next chapter), we’ve seen how each of our objectives for the prototype is
    accomplished. This is a great foundation for the next step in progressing the
    game along, which is the less fun but ultimately more rewarding aspect of integrating
    our playground into the rest of the game.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是游乐场更新方法的结束，也是我们对驾驶阶段原型的考察的结束。在查看我们希望通过游乐场实现的整体目标后，我们学习了如何将原始路线数据转换为包含路径的分段管道。在异步加载方法中，我们看到了如何导入并准备GLTF模型，以便在看到`initializeDrivingPhase`函数设置路径上的摄像机、物理和障碍物之前使用场景。通过`reset`方法，我们看到了如何使用`Path3D`方法正确地定位卡车，无论它在哪里以及处于何种状态。不计入GUI（我们将在下一章中介绍），我们已经看到了如何实现原型中的每个目标。这是游戏下一步进展的坚实基础，即集成我们的游乐场到游戏其余部分的过程，这是一个不那么有趣但最终更有回报的过程。
- en: Integrating with the Application
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成到应用程序中
- en: By constructing the playground driving demo, we’ve uncovered the techniques
    and basic design approach to use for the application code. The structure of our
    code is such that we should be able to simply lift and shift key pieces of functionality
    straight into the application’s code base, but only after we make modifications
    to prepare the way.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建游乐场驾驶演示，我们揭示了用于应用程序代码的技术和基本设计方法。我们的代码结构使得我们能够简单地将关键功能部分直接提升并转移到应用程序代码库中，但前提是我们必须先进行修改以做好准备。
- en: Playground logic aside, there are various hooks in `SpaceTruckerApplication`
    that need to be added or modified to get the driving phase to work properly, some
    of which include the ability to load into the driving game without going through
    Route Planning. Our basic input controls will need to be adapted to the input
    system of Space-Truckers, as well as the converse need to add new pieces of functionality
    to the input system. All of this starts with de-structuring and bringing in code
    from the Playground.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了游乐场逻辑之外，`SpaceTruckerApplication`中还有各种钩子需要添加或修改，以便正确地执行驾驶阶段，其中一些包括能够在不经过路线规划的情况下加载到驾驶游戏中。我们的基本输入控制需要适应Space-Truckers的输入系统，以及向输入系统添加新功能的需求。所有这些工作都始于对游乐场代码的解构和引入。
- en: Splitting Up the Playground
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将游乐场拆分
- en: '`spaceTruckerDrivingScreen` is where the primary logic will reside for the
    driving phase, and similarly to how we tucked the Route Planning modules into
    the `/src/route-planning` subdirectory, we put the driving phase code and data
    into a `/src/driving` folder. Within that folder and, again, like the `route-planning`
    folder, is the `gameData.js` file, where we will place the equivalently named
    Playground object. A new addition to the `gameData` object from the Playground
    is the `environmentConfig` section; this data contains information such as the
    environment texture URL and other pieces of deployment-time-specific information.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`spaceTruckerDrivingScreen`是驾驶阶段主要逻辑所在的地方，类似于我们将路线规划模块放入`/src/route-planning`子目录中，我们将驾驶阶段代码和数据放入一个`/src/driving`文件夹中。在该文件夹内，同样地，就像`route-planning`文件夹一样，有一个`gameData.js`文件，我们将放置同名游乐场对象。从游乐场添加到`gameData`对象的新内容是`environmentConfig`部分；这些数据包含有关环境纹理URL和其他部署时间特定信息的部分。'
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will be using the Encounter system (see the *Adding Encounters* section,
    later in this chapter) to populate the path with obstacles so that the `obstacleCount`
    property is omitted from the application code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用遭遇系统（参见本章后面的*添加遭遇*部分）来填充路径上的障碍物，这样就可以从应用程序代码中省略`obstacleCount`属性。
- en: 'Although it is less consistent with the code design for Route Planning, the
    `Driving` screen breaks out the environment creation code into its own module,
    `environment.js`. Exporting just the `initializeEnvironment` function, this module
    demonstrates how it isn’t always necessary to create JavaScript classes to encapsulate
    and abstract logic – sometimes, a simple function will do the job just as well:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这与路线规划的代码设计不太一致，但`Driving`屏幕将环境创建代码分离到它自己的模块`environment.js`中。仅导出`initializeEnvironment`函数，这个模块展示了有时并不总是需要创建JavaScript类来封装和抽象逻辑——有时候，一个简单的函数就能很好地完成工作：
- en: '[PRE19]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: None of the code in the preceding listing is particularly different from what
    we’ve already looked at in the Playground, except for the screen parameter representing
    the `SpaceTruckerDrivingScreen` instance being targeted by the function. To ensure
    that we can access (and later dispose of properly) the environment data, a composite
    data structure is returned to the caller containing `skyBox`, `hemisphericLight`,
    and `skyTexture`. This is similar to how the `initializeEnvironment` method of
    `environment.js`, `driving-gui.js` contains the `initializeGui` function. A minor
    detail for this is that, unlike `initializeEnvironment`, the `initializeGui` method
    is marked as `async`, but the details of what’s going on in this module will have
    to **await** the next chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码列表中的代码与我们之前在游乐场中看到的内容没有特别的不同，除了屏幕参数代表的是函数要针对的目标`SpaceTruckerDrivingScreen`实例。为了确保我们可以访问（并且稍后正确地处置）环境数据，返回给调用者的是一个复合数据结构，包含`skyBox`、`hemisphericLight`和`skyTexture`。这与`environment.js`、`driving-gui.js`中的`initializeEnvironment`方法的`initializeGui`函数类似。关于这一点的一个小细节是，与`initializeEnvironment`不同，`initializeGui`方法被标记为`async`，但这个模块中正在发生的事情的细节将在下一章中**等待**。
- en: Note
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Is there any limit to how bad a pun can get before intervention becomes necessary?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在干预成为必要之前，恶作剧的笑话可以有多糟糕？
- en: Our last component of the driving phase is the humble truck. The driving phase
    analog of the Route Planning’s `cargoUnit`, our `Truck` class is derived from
    `BaseGameObject`, where it inherits the `update`, `dispose`, and various other
    properties of its base. We’re able to use most of the code from the Playground’s
    `loadAssets` method verbatim, and we only need to grab the non-input handling
    code from the Playground’s `update` method to use it with the truck (the screen
    will host the input actions and processing). Now that we’ve defined the logic
    and behavior for the screen, let’s look at how that logic is applied to the application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们驾驶阶段的最后一个组件是谦逊的卡车。驾驶阶段的“路线规划”的`cargoUnit`的对应物，我们的`Truck`类是从`BaseGameObject`派生出来的，其中它继承了其基类的`update`、`dispose`以及各种其他属性。我们能够直接使用游乐场的`loadAssets`方法中的大部分代码，并且我们只需要从游乐场的`update`方法中获取非输入处理代码来与卡车一起使用（屏幕将负责输入动作和处理）。现在我们已经定义了屏幕的逻辑和行为，让我们看看这个逻辑是如何应用到应用程序中的。
- en: Transitioning to the Driving Screen
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换到驾驶屏幕
- en: 'During regular gameplay, the Driving phase is preceded immediately by the Route
    Planning phase. When the player manages to get the cargo unit to its destination,
    they are asked to confirm the route or retry. On the choice to confirm, the screen
    raises `routeAcceptedObservable` to notify interested parties of the event, the
    main subscriber to which is the `initialize` method of `SpaceTruckerApplication`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规游戏过程中，驾驶阶段紧随路线规划阶段之后。当玩家成功将货物单元运送到目的地时，他们会被要求确认路线或重试。在确认的选择上，屏幕提升`routeAcceptedObservable`以通知感兴趣的各方事件，其中主要订阅者是`SpaceTruckerApplication`的`initialize`方法：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For the other Screens (Main Menu, Splash Screen, and Route Planning), we’ve
    taken the approach of creating and loading up the screens as part of the `SpaceTruckerApplication.initialize`
    method. This obviates delay when transitioning between the Screens mentioned previously,
    but this approach won’t work with the Driving screen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他屏幕（主菜单、启动屏幕和路线规划），我们采取了在`SpaceTruckerApplication.initialize`方法中创建和加载屏幕的方法。这种方法消除了在之前提到的屏幕之间转换时的延迟，但这种方法不适用于驾驶屏幕。
- en: 'The Driving screen, as you might recall from earlier discussions in this chapter,
    needs to have `routeData` supplied to it at construction time. As we are yet unable
    to determine a player’s route before they’ve created it, so we must defer construction
    of the Screen until that time. We should also keep in mind that though a Screen
    might not be taking up render time, it will certainly consume memory – it would
    be prudent of us to dispose of the Route Planning screen and free up its resources
    as we transition to our new game state. This is the job of the `goToDrivingPhase`
    function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能从本章早些时候的讨论中回忆起来的，驾驶屏幕在构造时需要提供 `routeData`。由于我们尚未能够在玩家创建路线之前确定玩家的路线，因此我们必须将屏幕的构建推迟到那时。我们还应该记住，尽管屏幕可能不会占用渲染时间，但它肯定会消耗内存——在我们过渡到新的游戏状态时，我们明智地处理路线规划屏幕并释放其资源。这是
    `goToDrivingPhase` 函数的工作：
- en: '[PRE21]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Many of the code is standard to the family of methods we’ve written to handle
    state transitions, such as the process of detaching control from `_currentScene`
    and attaching it to the new `_drivingScene` and `moveNextAppState`, with the main
    difference being in the disposal of `_routePlanningScene`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 许多代码是针对我们编写的处理状态转换的方法族的标准代码，例如从 `_currentScene` 中分离控制并将其附加到新的 `_drivingScene`
    和 `moveNextAppState` 的过程，主要区别在于 `_routePlanningScene` 的处理方式。
- en: 'The disposal logic for a Screen is fairly simple. Most resources associated
    directly with the Scene will be disposed of along with the Scene, but it’s also
    necessary to ensure that `SoundManager` is disposed of along with `EncounterManager`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕的销毁逻辑相当简单。与场景直接关联的大多数资源将随着场景一起被销毁，但还必须确保 `SoundManager` 和 `EncounterManager`
    一起被销毁：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `Observable.clear()` method is useful when disposing of an object that
    you have control over because it precludes any need to know or have any references
    to the original subscription created via `Observable.add`. The final piece of
    the Driving phase transition is a shortcut to having the application directly
    load the Driving phase when launched, using the sample route data instead of a
    player’s simulated route. This is done by including the `testDrive` Query String
    value in the browser’s URL; when it is present and the player skips the Splash
    Screen, it will use the sample JSON route data:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理你有所控制的对象时，`Observable.clear()` 方法很有用，因为它排除了知道或拥有通过 `Observable.add` 创建的原始订阅的任何需要或引用。驾驶阶段转换的最后一部分是当应用程序启动时直接加载驾驶阶段的快捷方式，使用示例路线数据而不是玩家的模拟路线。这是通过在浏览器的
    URL 中包含 `testDrive` 查询字符串值来完成的；当它存在且玩家跳过启动屏幕时，它将使用示例 JSON 路线数据：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is a nice trick enabled by the fundamentally web-based nature of Babylon.js
    – we can easily use familiar web development tricks and tools to ease testing!
    Being able to quickly jump to a populated, “known good” Driving phase lets us
    quickly add and test various pieces of code for the application, which leads us
    to the major area of difference between the Playground and our application – how
    the `Truck` component is updated with input.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种由 Babylon.js 的基本基于网页的特性所启用的巧妙技巧——我们可以轻松地使用熟悉的网页开发技巧和工具来简化测试！能够快速跳转到已填充的、“已知良好”的驾驶阶段，使我们能够快速添加和测试应用程序的各种代码片段，这导致我们关注游乐场和我们的应用程序之间的主要差异区域——`Truck`
    组件如何更新输入。
- en: Truck Update and Input Controls
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卡车更新和输入控制
- en: 'Right away, there’s one obvious difference that needs to be addressed, and
    that’s the aspect of handling user input. Our Playground used a very simple input
    scheme, which will need to be refactored to use `SpaceTruckerInputProcessor` (see
    [*Chapter 5*](B17266_05_Final_AM.xhtml#_idTextAnchor103), *Adding a Cut Scene
    and Handling Input*). With the delegation of the actual per-frame update logic
    to the `Truck` component (see the *Splitting Up the Playground* section), the
    `update` method of `SpaceTruckerDrivingScreen` becomes very simple:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 立即，有一个需要解决的问题，那就是处理用户输入的方面。我们的游乐场使用了一个非常简单的输入方案，这需要重构以使用 `SpaceTruckerInputProcessor`（参见[*第5章*](B17266_05_Final_AM.xhtml#_idTextAnchor103)，*添加场景和输入处理*)。由于实际的每帧更新逻辑被委派给
    `Truck` 组件（参见 *Splitting Up the Playground* 部分），`SpaceTruckerDrivingScreen` 的
    `update` 方法变得非常简单：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `isLoaded` flag is used to help prevent extraneous updates from being processing
    during/while the async initialization logic is executing. Input must be updated
    before calling the Truck’s update method, to ensure that the latest values have
    been read and set. Looking at the control scheme for the Drive phase, it’s also
    obvious that there are differences between it and the controls for the Route Planning
    phase. The application needs a way to specify new or modified control map schemes
    that can apply just to the currently active Screen.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`isLoaded` 标志用于帮助防止在异步初始化逻辑执行期间/时处理不必要的更新。必须在调用卡车的更新方法之前更新输入，以确保已读取并设置了最新值。查看驾驶阶段的控制方案，很明显它与路线规划阶段的控制方案之间存在差异。应用程序需要一种方法来指定仅适用于当前活动屏幕的新或修改后的控制图方案。'
- en: Patching the input map
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 补丁输入图
- en: 'The original `inputActionMap` defined the set of actions relevant to the Route
    Planning screen and the Main Menu, but there are additional actions that we need
    to support that aren’t present in the mapping file. We also need to redefine specific
    inputs that are used to control the camera during Route Planning. Consolidating
    those changes, we have a “patch” of sorts that we can apply to `inputActionMap`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的 `inputActionMap` 定义了与路线规划屏幕和主菜单相关的动作集合，但我们需要支持一些在映射文件中不存在的额外动作。我们还需要重新定义用于在路线规划期间控制摄像头的特定输入。合并这些更改，我们有一个“补丁”可以应用到
    `inputActionMap` 上：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `patchControlMap` function is a static method of the `SpaceTruckerInputManager`
    class. It has a corresponding `unPatchControlMap` function that reverts a given
    input map patch to the previous values:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`patchControlMap` 函数是 `SpaceTruckerInputManager` 类的一个静态方法。它有一个相应的 `unPatchControlMap`
    函数，该函数将给定的输入图补丁还原到之前的值：'
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The two different uses of `Object.assign` are interesting to note. The first
    uses a new, empty object (`{}`) to create a copy or clone of the original `controlsMap`,
    while the second copies the properties from `newMaps` into the existing `controlsMap`.
    This has the effect of overwriting any pre-existing properties, as well as creating
    new properties from the input patch. While the unpatching can be done manually,
    by adding it to the `SpaceTruckerInputManager.dispose()` function, it is performed
    automatically as part of the `dispose` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign` 的两种不同用法值得关注。第一种用法使用一个新空对象 (`{}`) 来创建原始 `controlsMap` 的副本或克隆，而第二种用法则是将
    `newMaps` 中的属性复制到现有的 `controlsMap` 中。这会导致覆盖任何现有的属性，并从输入补丁中创建新属性。虽然可以通过将它们添加到 `SpaceTruckerInputManager.dispose()`
    函数中手动进行解补丁，但它作为 `dispose` 函数的一部分自动执行。'
- en: If it seems like we’re starting to move a lot faster now than we were earlier
    in this chapter, which is because it’s true – we’ve gotten the most complex part
    of the Driving Screen out of the way with our Playground demo. The Playground
    code is factored into different functions that can be split off and made into
    their own source files (with some modifications), and then consumed and orchestrated
    by `SpaceTruckerDrivingScreen`. We looked at the state machine changes to `SpaceTruckerApplication`
    that were needed to load sample route data by appending a query string to the
    browser URL before turning our attention to updating the control scheme and adding
    the ability for a screen to patch the input control map. Now that we’ve seen how
    it has been integrated with the application, it’s time to look at how encounters
    factor into the Driving phase gameplay.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在感觉我们比本章早期开始的速度快得多，那是因为这是真的——我们已经通过我们的游乐场演示将驾驶屏幕最复杂的部分处理掉了。游乐场代码被分解成不同的函数，可以拆分出来并制作成它们自己的源文件（进行一些修改），然后由
    `SpaceTruckerDrivingScreen` 消费和编排。我们研究了需要通过在浏览器 URL 中附加查询字符串来加载样本路线数据所需的 `SpaceTruckerApplication`
    状态机更改，然后转向更新控制方案和添加屏幕补丁输入控制图的能力。现在我们已经看到它是如何与应用程序集成的，是时候看看遭遇如何影响驾驶阶段的游戏玩法了。
- en: Adding Encounters
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加遭遇
- en: 'The first thing needed to get encounters from Route Planning into the driving
    phase is to capture them into the route in the first place. Making a slight modification
    to the `SpaceTruckerEncounterManager.onEncounter` function gets the job done:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要将遭遇从路线规划阶段捕获到驾驶阶段，首先需要将它们捕获到路线中。对 `SpaceTruckerEncounterManager.onEncounter`
    函数进行轻微修改即可完成任务：
- en: '[PRE27]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The addition to the code (highlighted) adds the encounter instance to the last
    telemetry data point in the route, making it available to us later when we process
    the route. In `calculateRouteParameters`, we are making sure to include the encounter
    data in the resulting `routePath` structure, along with the position, velocity,
    and gravitational acceleration.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 代码（突出显示）的添加将遭遇实例添加到路线中的最后一个遥测数据点，以便我们在处理路线时可以使用。在`calculateRouteParameters`中，我们确保将遭遇数据包含在结果`routePath`结构中，包括位置、速度和重力加速度。
- en: 'Now that the encounters have been located and processed, we can spawn the encounters
    themselves. For the time being, we are creating a temporary spherical mesh in
    the constructor to serve as a template for when we spawn the encounters:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经找到了并处理了遭遇，我们可以生成遭遇本身了。目前，我们在构造函数中创建一个临时的球形网格，作为生成遭遇时的模板：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It may seem contradictory to set `tempObstacleMesh.visibility` to `1` (fully
    visible) along with `layerMask = 0` (not rendered at all), but it makes sense
    when we look at the `spawnObstacle(seed)` function body and how it uses `tempObstacle
    mesh` as a template from which to create individual **Instances** of the mesh:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 将`tempObstacleMesh.visibility`设置为`1`（完全可见）同时将`layerMask = 0`（完全不渲染），看起来可能有些矛盾，但当我们查看`spawnObstacle(seed)`函数体以及它是如何将`tempObstacle
    mesh`作为模板来创建网格的各个**实例**时，这就有意义了：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In [*Chapter 6*](B17266_06_Final_AM.xhtml#_idTextAnchor120), *Implementing the
    Game Mechanics*, we saw a few different ways of efficiently replicating a single
    mesh across a scene, hundreds or even thousands of times. In that case, we used
    Thin Instances to procedurally generate and render the asteroid belt because the
    balance of features and friction met our needs. In this case, we are creating
    more CPU-bound Instance meshes because we want to enable physics, animate properties
    such as scale and position, and have more control over the characteristics of
    the resultant mesh. At the same time, because Instances are all drawn during the
    same draw call on the GPU (and therefore share render characteristics), changing
    the visibility property would have the same effect across all instances. `layerMask`
    is not shared between Instances, though, hence why we use it to hide the mesh
    used for Instancing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B17266_06_Final_AM.xhtml#_idTextAnchor120) *实现游戏机制*中，我们看到了几种高效复制单个网格到场景中的不同方法，数百次甚至数千次。在那个案例中，我们使用了瘦实例来程序化生成和渲染小行星带，因为功能和摩擦的平衡满足了我们的需求。在这个案例中，我们创建更多CPU密集型实例网格，因为我们希望启用物理，动画属性如缩放和位置，并对结果网格的特性有更多控制。同时，由于实例都是在GPU上的同一绘制调用中绘制的（因此共享渲染特性），改变可见性属性将对所有实例产生相同的效果。然而，`layerMask`在实例之间并不共享，这就是为什么我们用它来隐藏用于实例化的网格。
- en: We are retaining some vestiges of the Playground, even though those elements
    don’t need to remain in the code base in the long term; an example of this is
    `tempObstacleMesh`. Though it will be very important for us to switch this out
    for a more appropriate set of meshes that match the encounters, it is not a feature
    that is needed to make immediate progress. How do we ensure that we do not neglect
    to return to this area in the future? Since we’re using GitHub, we can create
    an Issue to track it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从长远来看，这些元素不需要保留在代码库中；`tempObstacleMesh`就是这样一个例子。虽然它对我们替换为更适合遭遇的网格集非常重要，但它不是立即取得进展所需的功能。我们如何确保我们不会在未来忽视这个区域？由于我们使用GitHub，我们可以创建一个Issue来跟踪它。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See [https://github.com/jelster/space-truckers/issues/92](https://github.com/jelster/space-truckers/issues/92)
    to read about the history of the issue described previously.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://github.com/jelster/space-truckers/issues/92](https://github.com/jelster/space-truckers/issues/92)了解之前描述的问题的历史。
- en: Unlike the needs captured in the Issue, being able to place encounters as obstacles
    in the driving route is a critical-path piece of functionality because, without
    it, we wouldn’t be able to properly plot those obstacles into the player’s radar
    UI display. Now that we do have them, we have enough context to look at how encounters
    are combined with the GUI system to make the mini-map.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与Issue中捕获的需求不同，能够在驾驶路线上放置遭遇作为障碍物是一个关键路径功能，因为没有它，我们就无法正确地将这些障碍物绘制到玩家的雷达UI显示中。现在我们有了它们，我们有足够的上下文来查看遭遇是如何与GUI系统结合来制作迷你地图的。
- en: Making the Mini-Map
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作迷你地图
- en: While the bulk of the next chapter will focus on the Babylon.js GUI, we’ll dip
    our feet into the waters of the topic of `initializeGui` method of our Playground.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章的大部分内容将专注于Babylon.js GUI的同时，我们将涉足Playground的`initializeGui`方法这一主题。
- en: Note
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the application, this logic is contained in the `driving-gui.js` module in
    `/src/driving/`. Aside from moving the code to load the Node Material into it,
    the code is identical to the Playground.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用中，这种逻辑包含在`/src/driving/`目录下的`driving-gui.js`模块中。除了将加载Node Material的代码移动到其中之外，代码与Playground中的代码相同。
- en: At the beginning of this chapter, we talked about Viewports in the *Initializing
    the Driving Phase Scene* section, and we described two main characteristics –
    the viewport’s size and position. For the main Scene camera, the Viewport stretches
    the full size of the screen, but for our GUI system, the Viewport is defined differently.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们在*初始化驾驶阶段场景*部分讨论了视口，并描述了两个主要特征——视口的大小和位置。对于主场景相机，视口拉伸整个屏幕大小，但对我们GUI系统来说，视口的定义不同。
- en: The GUI Camera
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GUI相机
- en: 'The `initializeGui` function starts its business by immediately defining the
    camera and Viewport, but it also sets the camera up in Orthographic mode. This
    is a different way of rendering the 3D scene onto a 2D screen that can be essentially
    summarized as being a camera mode that renders objects without distance or perspective
    corrections:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`initializeGui`函数一开始就立即定义了相机和视口，但它也将相机设置为正交模式。这是一种将3D场景渲染到2D屏幕上的不同方式，可以基本上总结为是一种渲染对象而不进行距离或透视校正的相机模式：'
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In our code, `guiViewportSize` corresponds to the number of units that the camera
    should cover in its field of view. That value is taken and used to compute the
    respective top, right, left, and bottom coordinates for the camera. Lastly, `guiCamera`
    is pushed onto the Scene’s `activeCameras` array to begin rendering through the
    camera. Once the camera and Viewport have been set up, the camera needs to have
    something to render, and that is the job of `radarMesh`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中，`guiViewportSize`对应于相机在其视场中应该覆盖的单位数。该值被取来用于计算相机相应的顶部、右侧、左侧和底部坐标。最后，`guiCamera`被推入场景的`activeCameras`数组以通过相机开始渲染。一旦设置好相机和视口，相机就需要有东西可以渲染，而这正是`radarMesh`的工作。
- en: 'As a simple Plane, `radarMesh` gets its magic from the textures assigned to
    its `StandardMaterial`. The first texture is one we mentioned earlier, and that’s
    the radar procedural texture created from `NodeMaterial` that we loaded up (see
    [*Chapter 11*](B17266_11_Final_AM.xhtml#_idTextAnchor230), *Scratching the Surface
    of Shaders*, for more on `NodeMaterial` and the NME), and the second is a variant
    of our old friend `AdvancedDynamicTexture`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 作为简单的平面，`radarMesh`从其`StandardMaterial`分配的纹理中获得魔力。第一个纹理是我们之前提到过的，那就是从我们加载的`NodeMaterial`创建的雷达过程纹理（有关`NodeMaterial`和NME的更多信息，请参阅[*第11章*](B17266_11_Final_AM.xhtml#_idTextAnchor230)，*Shader的表面摩擦*），第二个是我们老朋友的`AdvancedDynamicTexture`的变体：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`CreateFullScreenUI` is what we’ve used in the past when defining our GUI containers,
    and `CreateForMeshTexture` is quite similar. Instead of creating a texture the
    height and width of the screen, `CreateForMeshTexture` does the same for a specific
    mesh. The GUI texture can then be assigned to the mesh’s material as one of its
    textures:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateFullScreenUI`是我们过去在定义GUI容器时使用过的，而`CreateForMeshTexture`与之非常相似。`CreateForMeshTexture`不是创建与屏幕高度和宽度相同的纹理，而是为特定的网格执行相同的操作。然后可以将GUI纹理分配给网格的材质，作为其纹理之一：'
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After the GUI system has been set up and assigned to the radar mesh, the encounters
    are looped over to create individual GUI “blips” to represent each:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI系统设置并分配给雷达网格之后，遍历遭遇以创建代表每个遭遇的单独GUI“亮点”：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Developers familiar with CSS may recall using the trick of setting a high corner
    radius on a square to turn it into a circle, but otherwise, there isn’t anything
    we haven’t seen before in this code. The last thing to happen in the `initializeGui`
    function is the creation of a GUI-specific Glow Layer to help illuminate the radar
    and punch up its look. Defining the GUI elements involved putting a few new tools
    into our tool belt, and what better way to validate those tools than to put them
    to use in the runtime behavior of the radar?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉CSS的开发者可能会记得使用在正方形上设置高角落半径的技巧来将其变成圆形，但除此之外，在这段代码中我们之前没有看到过任何东西。在`initializeGui`函数中发生的最后一件事是创建一个用于照亮雷达并增强其外观的GUI专用发光层。定义GUI元素意味着将一些新工具放入我们的工具箱中，而将它们用于雷达的运行时行为来验证这些工具不是更好吗？
- en: Blip Plotting in Polar Coordinates
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 极坐标下的Blip绘图
- en: 'Normally, when we talk about the position of a particular object such as an
    encounter, we refer to it in terms of it representing a position in the World
    Space, the top-level 3D coordinate space for a rendered Scene. Sometimes, usually
    in the context of a model and its submeshes or bones, the position referred to
    is given relative to the parent mesh or transform node’s origin, or center. This
    is called a Local Space position and relates to a World Position via the World
    Matrix. In this chapter, we saw an example of working with these elements when
    we loaded the semi-truck model and removed the parent root node (see the *Loading
    Assets Asynchronously* section earlier in this chapter). The following diagram
    depicts some different ways of representing coordinates:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们谈论特定物体的位置，比如遭遇，我们会用它在世界空间中的位置来表示，这是渲染场景的最高级3D坐标系。有时，通常在模型及其子网格或骨骼的上下文中，所提到的位置是相对于父网格或变换节点的原点或中心给出的。这被称为本地空间位置，并通过世界矩阵与世界位置相关联。在本章中，当我们加载半挂车模型并移除父根节点时（参见本章前面较早的*异步加载资源*部分），我们看到了处理这些元素的一个例子。以下图表展示了表示坐标的不同方式：
- en: '![Figure 8.7 – Local and World Space coordinate systems are Cartesian coordinate
    systems that depict locations as a combination of vector elements](img/Figure_8.07_B17266.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 本地空间和世界空间坐标系是笛卡尔坐标系，它们将位置描绘为向量元素的组合](img/Figure_8.07_B17266.jpg)'
- en: Figure 8.7 – Local and World Space coordinate systems are Cartesian coordinate
    systems that depict locations as a combination of vector elements
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 本地空间和世界空间坐标系是笛卡尔坐标系，它们将位置描绘为向量元素的组合
- en: Sometimes, it can be advantageous to represent coordinates in a different form.
    A Polar Coordinate system is one of those alternate ways of representing the position
    of something concerning another.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用不同的形式表示坐标可能会有优势。极坐标系统就是表示某物相对于另一物的位置的替代方法之一。
- en: 'In polar coordinates, the origin of the plot represents the unit’s location
    in space with all other objects plotted around the center of that circle. Those
    objects’ coordinates can be captured into just two variables: **angle** (**theta**,
    or **θ**) and **distance** (**r**, or radius).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在极坐标中，绘图的原点表示单位在空间中的位置，所有其他对象都绘制在该圆的中心。这些对象的坐标可以仅用两个变量来捕捉：**角度**（**theta**，或**θ**）和**距离**（**r**，或半径）。
- en: Important note
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Since the radar is in two dimensions but the location is in three, we use the
    *X*- and *Z*-axes while the *Y*-axis is discarded. Information about the object’s
    position along that axis is preserved as part of the Vector distance between the
    origin and the object being plotted.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于雷达在二维空间中，而位置在三维空间中，所以我们使用*X*轴和*Z*轴，而*Y*轴被丢弃。关于该轴上物体位置的信息作为从原点到正在绘制的物体的向量距离的一部分被保留。
- en: 'The math to accomplish this is deceptively easy once we know the operations
    needed. To determine the vector distance, we could subtract the position of the
    encounter obstacle from the truck and obtain it via the `Vector3.length()` function,
    but the more direct path is to use the static `Vector3.Distance()` function instead.
    The value for `theta` has multiple paths to the same end:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道所需的操作，完成这个数学问题就出奇地简单。为了确定向量的距离，我们可以从卡车位置减去遭遇障碍物的位置，并通过`Vector3.length()`函数获得它，但更直接的方法是使用静态的`Vector3.Distance()`函数。对于`theta`的值有多个到达同一目的的路径：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`Vector3.GetAngleBetweenVectorsOnPlane` is perfect for our use because it will
    automatically take differences in altitude between the truck and the obstacle
    into account by projecting each onto the same plane defined by the truck’s up
    vector. The next part is a bit tricky, though, because our coordinate system places
    `(0, 0)` at the center, whereas the GUI system placement puts the origin at the
    top-left bounds:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vector3.GetAngleBetweenVectorsOnPlane`非常适合我们的使用，因为它会自动考虑卡车和障碍物之间的高度差异，通过将每个对象投影到由卡车的向上向量定义的同一平面上。然而，下一部分有点棘手，因为我们的坐标系将`(0,
    0)`放在中心，而GUI系统的放置将原点放在左上角边界：'
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When setting the left and top properties of `uiBlip`, the points are scaled
    to the mesh’s size before correcting for origin locations. The result, as shown
    in the following screenshot, is circular blips that show their position relative
    to the player in a cool-looking way:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置`uiBlip`的左和上属性时，在纠正原点位置之前，这些点会根据网格的大小进行缩放。结果，如以下截图所示，是圆形的Blip，以一种酷炫的方式显示它们相对于玩家的位置：
- en: '![Figure 8.8 – The radar GUI element plots the positions of encounters in terms
    of their relative distance and angle from the player (at the center of the circle)](img/Figure_8.08_B17266.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 雷达GUI元素以玩家（圆圈中心）的相对距离和角度来绘制遭遇的位置](img/Figure_8.08_B17266.jpg)'
- en: Figure 8.8 – The radar GUI element plots the positions of encounters in terms
    of their relative distance and angle from the player (at the center of the circle)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 雷达GUI元素以玩家（圆圈中心）的相对距离和角度来绘制遭遇的位置
- en: Though this section may have been short, it has certainly been full of sweet
    knowledge and results. There remain several mysteries to uncover regarding the
    radar mesh texture and its construction, but those will have to await a later
    chapter of our journey. We come out of this section knowing how to plot polar
    coordinates as well as how to set up a multi-camera scene with layer masks and
    Viewports. It’s a nice way to wrap up our work in this area and prepares us for
    what comes next!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一节可能很短，但它确实充满了甜蜜的知识和成果。关于雷达网格纹理及其构建，还有一些谜团需要揭开，但这些将留待我们旅程的后续章节。通过这一节，我们知道了如何绘制极坐标，以及如何设置带有层掩码和视口的多人相机场景。这是结束我们在这个领域工作的好方法，并为接下来要做的事情做好了准备！
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Let’s take a step back and look at how far we’ve come during this chapter. When
    we started it, all we had was some route data and a vague idea of what we wanted
    to happen. Having completed it, we now have a game that can be played from end
    to end from Route Planning to Driving!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们退一步，看看在这一章中我们走了多远。当我们开始时，我们只有一些路线数据和关于我们想要发生什么的模糊想法。完成它之后，我们现在有一个可以从路线规划到驾驶的从头到尾可以玩的游戏！
- en: Along the way, we’ve leveraged the Playground to help us define a prototype
    demo of the driving phase gameplay. It was in that Playground that we learned
    how to take the raw route data and turn it into a configurable Ribbon mesh with
    as many or few segments as we’d like. The semi-truck GLB asset was introduced
    as we learned how to load and prepare assets like this for use in our Scene. Once
    we learned how to set up the scene, we defined physics and gave our truck the
    ability to bounce off the route’s walls with `MeshImpostor`, as well as a way
    to automatically “kill” the truck if it wanders out of bounds. All that work set
    us up for smooth integration with the application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在旅途中，我们利用游乐场帮助我们定义了驾驶阶段游戏玩法的原型演示。正是在那个游乐场中，我们学会了如何将原始路线数据转换为可配置的带状网格，其段落数量可以多也可以少，正如我们所希望的那样。当我们学习如何加载和准备此类资产以用于我们的场景时，引入了半挂车GLB资产。一旦我们学会了如何设置场景，我们就定义了物理属性，并使用`MeshImpostor`让我们的卡车能够从路线的墙壁上弹跳，以及一种自动“杀死”卡车的方法，如果它越界了。所有这些工作都为我们与应用程序的顺利集成奠定了基础。
- en: Beginning with a divide-and-conquer approach, we split the code from the Playground
    up into its different functional areas of responsibility. Then, we hooked up the
    plumbing to transition from either the splash screen (with the `?testDrive` URL
    Query string) or the `onCargoAccepted` event of the Route Planning Screen. Having
    the ability to quickly jump into the driving phase using sample route data made
    it easy to iterate and test through the rest of the integration with the runtime
    and input systems.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 从分而治之的方法开始，我们将游乐场的代码拆分成了不同的功能责任区域。然后，我们将管道连接到从启动屏幕（带有`?testDrive` URL查询字符串）或路线规划屏幕的`onCargoAccepted`事件过渡。使用示例路线数据快速跳入驾驶阶段使得迭代和测试与运行时和输入系统的其余集成变得容易。
- en: Our input handling needs for the Driving Phase are different from those of the
    Planning Phase, so to support that, we added the ability to path the base input
    action map with an updated set of input-to-action mappings. To keep our space-truck
    from getting lonely along its route, we turned our attention to hooking up encounters
    with the Driving screen via `routeData`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 对于驾驶阶段，我们的输入处理需求与规划阶段不同，因此为了支持这一点，我们添加了使用更新后的输入到动作映射集来路径化基本输入动作图的功能。为了不让我们的太空卡车在它的路线上感到孤单，我们将注意力转向通过`routeData`将遭遇与驾驶屏幕连接起来。
- en: Once we’d added encounter data to the overall `routeData`, it was straightforward
    to use a (for now) sphere mesh as a source for Instances of an Encounter. We’ll
    be changing this around later, but at this time, we don’t want to arrest any of
    the hard-earned momenta gained to take on any side-quests. Similarly, we learned
    how to set up our alternate GUI camera along with the polar coordinates – plotting
    encounters onto our radar procedural texture/GUI mesh. Put all together, we are
    in a great place to begin the next chapter in our journey, where we will cover
    the GUI.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们向整体`routeData`添加遭遇数据后，使用（目前）球体网格作为遭遇实例的源是直接的。我们稍后会改变这一点，但在此期间，我们不想阻碍我们为任何侧任务所获得的任何来之不易的动量。同样，我们学习了如何设置我们的备用GUI相机以及极坐标——将遭遇绘制到我们的雷达程序纹理/GUI网格上。综合来看，我们正处于开始我们旅程下一章的绝佳位置，我们将介绍GUI。
- en: Up until now, we’ve kept our GUI to a minimum. Even so, what amounts to basic
    boilerplate code while assigning values to properties can be quite astonishing.
    Nobody wants to have to write all that code and nobody wants to have to maintain
    it. In the next chapter, we’ll learn how we solve both of those problems while
    covering some other problems we didn’t even know existed when we go in-depth into
    the brand-new **Babylon.js GUI Editor**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将GUI保持到最小。即便如此，在分配属性值时，相当于基本样板代码的东西可能会相当令人惊讶。没有人想写那么多代码，也没有人想维护它。在下一章中，我们将学习我们如何解决这两个问题，同时介绍一些我们甚至不知道存在的其他问题，当我们深入探讨全新的**Babylon.js
    GUI编辑器**时。
- en: 'Until then, if you want to spend some more time exploring the ideas and concepts
    from this chapter, check out the *Extended Topics* section next for ideas and
    projects. As always, Space-Truckers: The Discussion Boards at [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)
    is the place to ask questions and exchange ideas with fellow Space-Truckers, while
    the Babylon.js forums are where to engage with the greater Babylon.js community.
    See a problem with the code or have an idea you’d like to see implemented? Feel
    free to create an Issue in the Space-Truckers repository!'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之前，如果你想花更多时间探索本章中的想法和概念，请查看下一节的*扩展主题*部分以获取想法和项目。一如既往，Space-Truckers：[https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions)的讨论板是提问和与同行的Space-Truckers交流想法的地方，而Babylon.js论坛是参与更大Babylon.js社区的地方。如果代码有问题或你有想看到实现的想法？请随意在Space-Truckers仓库中创建一个Issue！
- en: Extended Topics
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展主题
- en: 'The following are some extended topics for you to try out:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些你可以尝试的扩展主题：
- en: Add an “encounter warning” UI indication whenever the truck is within a set
    distance of an encounter
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当卡车在遭遇的设定距离内时，添加“遭遇警告”UI指示。
- en: When the ship hits the side of the wall, play an appropriate sound effect. The
    volume of the played effect should scale with the energy of the impact. Bonus
    points for spatially locating the sound at the location of the collision.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当飞船撞到墙壁侧面时，播放适当的声音效果。播放效果的声音大小应与撞击的能量成比例。如果能在碰撞位置定位声音，则加分。
- en: An Encounter Table implies something static. Make encounters more dynamic by
    loading the list of potential encounters from a remote index repository hosted
    on GitHub. Community members can contribute new encounters by submitting a Pull
    Request containing the new encounter’s definition. Once accepted and merged, the
    encounter becomes available to be used in a game session.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遭遇表暗示着某种静态的东西。通过从GitHub上托管的远程索引仓库加载潜在遭遇的列表，使遭遇更加动态。社区成员可以通过提交包含新遭遇定义的Pull Request来贡献新的遭遇。一旦被接受并合并，遭遇就可以在游戏会话中使用。
- en: As a prerequisite for the preceding bullet, adding the ability for each encounter
    to use a different mesh/material combination is a necessity. Read the mesh URL
    from the encounter data but be careful that you’re not creating new meshes/materials
    for every instance of an encounter!
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为前一条清单的前提，为每次遭遇添加使用不同网格/材料组合的能力是必要的。从遭遇数据中读取网格URL，但请注意，你并不是为每次遭遇的实例创建新的网格/材料！
- en: Another Encounter feature could be the ability for each encounter type to define
    and control its behavior. An easy and cool way to do this is outlined in the very
    next chapter in the *Advanced Coroutine Usage* section.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个遭遇功能可能是让每种遭遇类型能够定义和控制其行为。在下一章的*高级协程使用*部分中概述了一种简单且酷的方法来实现这一点。
