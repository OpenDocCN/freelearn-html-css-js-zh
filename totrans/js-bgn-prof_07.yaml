- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: In this chapter, we are going to discuss JavaScript classes. We have seen JavaScript
    objects already, and classes are a blueprint or template for object creation.
    So, many of the things discussed here should not sound too unfamiliar or revolutionary.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论 JavaScript 类。我们已经看到了 JavaScript 对象，而类是对象创建的蓝图或模板。因此，这里讨论的许多内容不应该听起来太陌生或革命性。
- en: Classes enable object-oriented programming, which was one of the most important
    design advancements in software development. This development reduced the complexity
    of applications and increased maintainability by a huge margin.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 类使面向对象编程成为可能，这是软件开发中最重要的设计进步之一。这种发展大大降低了应用程序的复杂性，并极大地提高了可维护性。
- en: 'So, object-oriented programming and classes are of great importance for computer
    science in general. This is not necessarily the case when we apply it to JavaScript
    though. JavaScript classes are something special compared to other programming
    languages. Beneath the surface, classes are wrapped in some sort of special function.
    This means that they are actually an alternative syntax for defining objects using
    a constructor function. In this chapter, we will learn what classes are and how
    we can create and use them. Along the way, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，面向对象编程和类对于计算机科学来说非常重要。然而，当我们将其应用于 JavaScript 时，情况并不一定如此。JavaScript 类与其他编程语言相比有一些特殊之处。在表面之下，类被某种特殊函数所包装。这意味着它们实际上是一种使用构造函数定义对象的替代语法。在本章中，我们将学习类是什么，以及我们如何创建和使用它们。在这个过程中，我们将涵盖以下主题：
- en: Object-oriented programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Classes and objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和对象
- en: Classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Prototypes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: 'Note: exercise, project, and self-check quiz answers can be found in the *Appendix*.'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：练习、项目和自我检查测验的答案可以在*附录*中找到。
- en: Object-oriented programming
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Before we start diving right into the fun of classes, let's briefly say something
    about **object-oriented programming** (**OOP**). OOP is a very important programming
    paradigm wherein code is structured in objects, leading to more maintainable and
    reusable code. Working with OOP teaches you to really try to think of all sorts
    of topics in objects, by bundling properties in such a way that they can be wrapped
    in a blueprint called a class. This in turn might be inheriting properties from
    a parent class.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨类的乐趣之前，让我们简要地谈谈**面向对象编程**（**OOP**）。OOP是一种非常重要的编程范式，其中代码以对象的形式组织，从而产生更易于维护和重用的代码。使用
    OOP 可以教会你真正尝试以对象的形式思考各种主题，通过将属性捆绑在一起，使它们可以包含在一个称为类的蓝图内。这反过来又可能从父类继承属性。
- en: 'For example, if we are thinking of an animal, we can come up with certain properties:
    name, weight, height, maximum speed, colors, and a lot more. And then if we think
    of a specific species of fish, we can reuse all the properties of "animal" and add
    a few fish-specific properties in there as well. The same for dogs; if we then
    think of a dog, we can reuse all the properties of "animal" and add a few dog-specific
    ones to it. This way we have reusable code of our animal class. And when we realize
    we forgot a very important property for the many animals in our application, we
    only need to add it to the animal class.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们考虑一个动物，我们可以想出一些属性：名称、重量、高度、最大速度、颜色等等。然后如果我们考虑一种特定的鱼类，我们可以重用“动物”的所有属性，并在其中添加一些特定的鱼类属性。对狗也是如此；如果我们考虑狗，我们可以重用“动物”的所有属性，并添加一些特定的狗属性。这样我们就有了可重用的动物类代码。当我们意识到我们忘记了一个非常重要的属性，这个属性对于我们的应用程序中的许多动物都很重要时，我们只需要将其添加到动物类中。
- en: This is very important for Java, .NET, and other classic object-oriented ways
    of writing code. JavaScript doesn't necessarily revolve around objects. We will
    need them and we will use them, but they are not the star of our code, so to speak.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于 Java、.NET 和其他经典面向对象编程方式来说非常重要。JavaScript 并不一定是围绕对象构建的。我们需要它们并会使用它们，但它们并不是我们代码的明星，换句话说。
- en: Classes and objects
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: 'As a quick refresher, objects are a collection of properties and methods. We
    saw them in *Chapter 3*, *JavaScript Multiple Values*. The properties of an object
    should have sensible names. So for example, if we have a `person` object, this
    object could have properties called `age` and `lastName` that contain values.
    Here is an example of an object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快速回顾，对象是一系列属性和方法集合。我们在*第3章*，*JavaScript 多值*中看到了它们。对象的属性应该有合理的名称。例如，如果我们有一个`person`对象，这个对象可以拥有名为`age`和`lastName`的属性，它们包含值。以下是一个对象的示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Classes in JavaScript encapsulate data and functions that are part of that
    class. If you create a class, you can later create objects using that class using
    the following syntax:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的类封装了属于该类的数据和函数。如果你创建了一个类，你可以稍后使用以下语法使用该类创建对象：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code defines a class with `ClassName` as a name, declares an `obj` variable,
    and initializes this with a new instance of the object. Two arguments are provided.
    These arguments will be used by the constructor to initialize the properties.
    As you can see, the parameters of the constructor and the properties of the class
    (`prop1` and `prop2`) have the same name. The properties of the class can be recognized
    by the `this` keyword in front of them. The `this` keyword refers to the object
    it belongs to, so it is the first property of the instance of `ClassName`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码定义了一个名为`ClassName`的类，声明了一个`obj`变量，并用这个对象的新实例初始化它。提供了两个参数。这些参数将由构造函数用于初始化属性。正如你所看到的，构造函数的参数和类的属性（`prop1`和`prop2`）具有相同的名称。类的属性可以通过它们前面的`this`关键字来识别。`this`关键字指的是它所属的对象，因此它是`ClassName`实例的第一个属性。
- en: 'Remember we said that classes are just some special function beneath the surface.
    We could create the object with a special function like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们说过，类只是表面下的一些特殊函数。我们可以使用如下特殊函数来创建对象：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The dog example could have been made using a class syntax as well. It would
    have looked like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 狗的例子也可以使用类语法来创建。它看起来像这样：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This results in an object with the same properties. If we do some logging as
    follows, we will be able to see it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生具有相同属性的对象。如果我们像下面这样进行日志记录，我们就能看到它：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the next section, we will dive into all the parts of classes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨类的所有部分。
- en: Classes
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: You may wonder, if classes do the exact same thing as simply defining an object,
    why do we even need classes? The answer is that classes are essentially blueprints
    for object creation. This means that we need to do much less typing if we need
    to create 20 dogs when we have a `dog` class. If we have to create the objects,
    we will have to specify all the properties' names each time. And it would be easy
    to make a typo and misspell a property name. Classes come in handy in these sorts
    of situations.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，如果类和简单地定义一个对象做的是完全相同的事情，我们为什么还需要类呢？答案是，类本质上是为对象创建的蓝图。这意味着如果我们有一个`dog`类，需要创建20只狗时，我们就不需要输入很多代码。如果我们必须创建对象，我们每次都必须指定所有属性的名称。而且很容易出错，拼错属性名。在这些情况下，类非常有用。
- en: As shown in the previous section, we use the `class` keyword to tell JavaScript
    we want to create a class. Next, we give the class a name. It is the convention
    to start class names with a capital letter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前节所示，我们使用`class`关键字告诉JavaScript我们想要创建一个类。接下来，我们给类起一个名字。按照惯例，类名应该以大写字母开头。
- en: Let's have a look at all the different elements of a class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看类的所有不同元素。
- en: Constructors
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: The `constructor` method is a special method that we use to initialize objects
    with our class blueprint. There can only be one constructor in a class. This constructor
    contains properties that will be set when initiating the class.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个特殊的方法，我们用它来使用我们的类蓝图初始化对象。一个类中只能有一个构造函数。这个构造函数包含在初始化类时将被设置的属性。
- en: 'Here you can see an example of a constructor in a `Person` class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你可以看到一个`Person`类中构造函数的例子：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Beneath the surface, JavaScript creates a special function based on this constructor.
    This function gets the class name, and it will create an object with the given
    properties. With this special function, you can create instances (objects) of
    the class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在表面之下，JavaScript基于这个构造函数创建了一个特殊函数。这个函数获取类名，并使用给定的属性创建一个对象。通过这个特殊函数，你可以创建类的实例（对象）。
- en: 'Here is how you can create a new object from the `Person` class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何从`Person`类创建一个新对象的方法：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `new` word is what tells JavaScript to look for the special constructor
    function in the `Person` class and create a new object. The constructor gets called
    and returns an instance of the person object with the specified properties. This
    object gets stored in the `p` variable.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`这个词告诉JavaScript在`Person`类中查找特殊的构造函数并创建一个新对象。构造函数被调用并返回一个具有指定属性的person对象实例。这个对象被存储在`p`变量中。'
- en: 'If we use our new `p` variable in a logging statement, you can see that the
    properties are really set:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在日志语句中使用我们的新`p`变量，你可以看到属性确实被设置了：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This outputs:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What do you think will happen when we create a class without all of the properties?
    Let''s find out:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为当我们创建一个没有所有属性的类时会发生什么？让我们找出答案：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Many languages would crash, but not JavaScript. It just sets the remaining
    properties to `undefined`. You can see what happens by logging it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言会崩溃，但JavaScript不会。它只是将剩余的属性设置为`undefined`。你可以通过记录它来看到会发生什么：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This results in:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can specify default values in `constructor`. You would do it like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`constructor`中指定默认值。你可以这样做：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This way, it would not have printed `Hi Maaike undefined`, but `Hi Maaike Doe`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，它就不会打印`Hi Maaike undefined`，而是`Hi Maaike Doe`。
- en: Practice exercise 7.1
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7.1
- en: 'Take the following steps to create a person class, and print instances of friends''
    names:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤创建一个`Person`类，并打印朋友的姓名实例：
- en: Create a class for `Person` including the constructor for `firstname` and `lastname`.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Person`创建一个类，包括`firstname`和`lastname`的构造函数。
- en: Create a variable and assign a value of the new `Person` object using your friend's
    first and last names.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量，并使用你朋友的第一个和最后一个名字将新`Person`对象赋值给它。
- en: Now add a second variable with another friend's name using their first name
    and last name.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加第二个变量，使用另一个朋友的第一个和最后一个名字。
- en: Output both friends into the console with a greeting of `hello`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个朋友的姓名输出到控制台，问候语为`hello`。
- en: Methods
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法
- en: 'In a class, we can specify functions. This means that our object can start
    doing things using the object''s own properties—for example, printing a name.
    Functions on a class are called methods. When defining these methods, we don''t
    use the `function` keyword. We start directly with the name:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，我们可以指定函数。这意味着我们的对象可以使用对象的自身属性开始做一些事情——例如，打印一个名字。类上的函数被称为方法。在定义这些方法时，我们不使用`function`关键字。我们直接从名称开始：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can call the `greet` method on a `Person` object like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样在`Person`对象上调用`greet`方法：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It will output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can specify as many methods on a class as you want. In this example, we
    are using the `firstname` property. We do so by saying `this.property`. If we
    had a person with a different value for the `firstname` property, for example,
    `Rob`, it would have printed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在类上指定任意多的方法。在这个例子中，我们使用了`firstname`属性。我们这样做是通过说`this.property`。如果我们有一个`firstname`属性值不同的个人，例如`Rob`，它将打印：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Just like functions, methods can also take parameters and return results:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数一样，方法也可以接受参数并返回结果：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `compliment` function does not output anything itself, so we are logging
    it
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`compliment`函数本身不输出任何内容，所以我们记录它'
- en: '[PRE19]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output will be:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case we are sending parameters into our method, because you don't usually
    compliment your own properties (that's a nice sentence, Maaike!). However, whenever
    the method doesn't require external input but only the properties of the object,
    no parameters will work and the method can use its object's properties. Let's do
    an exercise and then move on to using the properties of classes outside the class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们向我们的方法发送参数，因为你通常不会赞美你自己的属性（这是一个好句子，Maaike！）。然而，每当方法不需要外部输入而只需要对象的属性时，就不需要任何参数，方法可以使用其对象的属性。让我们做一个练习，然后继续使用类外部的属性。
- en: Practice exercise 7.2
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7.2
- en: 'Get your friend''s full name:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 获取你朋友的完整姓名：
- en: Using the `Person` class from *Practice exercise 7.1*, add a method called `fullname`,
    which returns the concatenated value of `firstname` and `lastname` when invoked.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*练习7.1*中使用的`Person`类中添加一个名为`fullname`的方法，当调用时返回`firstname`和`lastname`的连接值。
- en: Create values for `person1` and `person2` using two friends' first and last
    names.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个朋友的第一个和最后一个名字为`person1`和`person2`创建值。
- en: Using the `fullname` method within the class, return the full name of one or
    both people.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中使用`fullname`方法，返回一个人的或两个人的全名。
- en: Properties
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'Properties, sometimes also called fields, hold the data of the class. We have
    seen one kind of property already, when we created them in our constructors:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 属性，有时也称为字段，存储类的数据。我们已经在构造函数中创建它们时看到了一种属性：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, the `Person` class gets two properties from the constructor: `firstname`
    and `lastname`. Properties can be added or removed just like we did for objects.
    These properties can be accessed from outside the class, as we saw when we logged
    them outside the class by accessing them on the instance:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Person`类从构造函数中获取两个属性：`firstname`和`lastname`。属性可以像我们对对象所做的那样添加或删除。这些属性可以从类外部访问，就像我们在类外部通过访问实例来记录它们时看到的那样：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Often, it is not desirable to provide direct access to our properties. We want
    our class to be in control of the values of properties for several reasons—perhaps
    we want to do validation on a property to assure it has a certain value. For example,
    imagine wanting to validate an age as not being lower than 18\. We can achieve
    this by making direct access to the property from outside the class impossible.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们不希望直接提供对属性的访问。我们希望我们的类控制属性的值，有多个原因——也许我们想在属性上执行验证以确保它具有某个值。例如，想象一下想要验证年龄不低于18岁。我们可以通过使从类外部直接访问属性变得不可能来实现这一点。
- en: 'This is how to add properties that aren''t accessible from outside. We prefix
    them with a `#` symbol:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何添加外部不可访问的属性的示例。我们用`#`符号作为前缀：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Right now, the `firstname` and `lastname` properties cannot be accessed from
    outside the class. This is done by adding `#` in front of the property. If we
    try it:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`firstname`和`lastname`属性不能从类外部访问。这是通过在属性前添加`#`符号来实现的。如果我们尝试这样做：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ll get:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we wanted to make sure we could only create objects with names starting
    with an "M," we could modify our constructor a bit:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要确保只能创建以"M"开头的名字的对象，我们可以稍微修改一下构造函数：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now when you try to create a person that has a `firstname` value that doesn''t
    start with an "M," it will add an `M` in front. So for example, the value of the
    following first name is `Mkay`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你尝试创建一个`firstname`值不以"M"开头的个人时，它会在前面添加一个"M"。例如，以下名字的值是`Mkay`：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a very silly example of validation. At this point, we cannot access
    it from outside the class at all after the constructor. We can only access it
    from inside the class. This is where getters and setters come into play.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常愚蠢的验证示例。在这个阶段，在构造函数之后，我们根本不能从类外部访问它。我们只能从类内部访问它。这就是获取器和设置器发挥作用的地方。
- en: Getters and setters
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: Getters and setters are special properties that we can use to get data from
    a class and to set data fields on the class. Getters and setters are computed
    properties. So, they are more like properties than they are like functions. We
    call them accessors. They do look a bit like functions, because they have `()`
    behind them, but they are not!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和设置器是特殊的属性，我们可以使用它们从类中获取数据，并在类上设置数据字段。获取器和设置器是计算属性。因此，它们更像属性而不是函数。我们称它们为访问器。它们看起来有点像函数，因为它们后面有`()`，但它们不是！
- en: These accessors start with the `get` and `set` keywords. It is considered good
    practice to make fields private as much as possible and provide access to them
    using getters and setters. This way, the properties cannot be set from outside
    without the object itself being in control. This principle is called **encapsulation**.
    The class encapsulates the data, and the object is in control of its own fields.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些访问器以`get`和`set`关键字开头。尽可能将字段设置为私有，并使用获取器和设置器来访问它们被认为是良好的实践。这样，属性就不能从外部设置，除非对象本身控制。这个原则被称为**封装**。类封装了数据，对象控制自己的字段。
- en: 'Here is how to do it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何做到这一点的示例：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The getter is used to get the property. Therefore, it doesn''t take any parameters,
    but simply returns the property. The setter is the other way around: it takes
    a parameter, assigns this new value to the property, and returns nothing. The
    setter can contain more logic, for example, some validation, as we''ll see below.
    The getter can be used outside the object as if it were a property. The properties
    are no longer directly accessible from outside the class, but can be accessed
    via the getter to get the value and via the setter to update the value. Here is
    how to use it outside the class instance:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器用于获取属性。因此，它不需要任何参数，只需返回属性即可。设置器则相反：它接受一个参数，将这个新值赋给属性，然后不返回任何内容。设置器可以包含更多的逻辑，例如，一些验证，正如我们下面将要看到的。获取器可以在对象外部使用，就像它是一个属性一样。属性不再可以从外部直接访问，但可以通过获取器获取值，通过设置器更新值。以下是如何在类实例外部使用它的示例：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We have created a new `Person` object with a first name of `Maria` and last
    name of `Saga`. The output is showing the first name, which is only possible because
    we have a getter accessor. We can also set the value to something else, because
    there is a setter. Here is how to update the first name, so the name is no longer
    `Maria`, but `Adnane`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`Person`对象，名字为`Maria`，姓氏为`Saga`。输出显示了名字，这仅因为我们可以使用获取器访问器。我们也可以将值设置为其他内容，因为存在设置器。以下是更新名字的示例，这样名字就不再是`Maria`，而是`Adnane`。
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'At this point, nothing special is happening in the setter. We could do a similar
    validation as in the constructor before, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，setter中并没有发生任何特殊的事情。我们可以像在构造函数中那样进行类似的验证，如下所示：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will check whether `firstname` starts with an `M`, and if it does it will
    update the value to whatever the `firstname` parameter is. If it doesn't, it will
    concatenate an `M` in front of the parameter.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检查`firstname`是否以`M`开头，如果是，它将更新值为`firstname`参数的值。如果不是，它将在参数前面连接一个`M`。
- en: Please note that we do not access `firstname` as if it was a function. If you
    put two parentheses `()` after it, you would actually get an error telling you
    that it is not a function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不是像函数一样访问`firstname`。如果你在它后面放两个括号`()`，实际上你会得到一个错误，告诉你它不是一个函数。
- en: Inheritance
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is one of the key concepts of OOP. It is the concept that classes
    can have child classes that inherit the properties and methods from the parent
    class. For example, if you needed all sorts of vehicle objects in your application,
    you could specify a class named `Vehicle` in which you specify some shared properties
    and methods of vehicles. You would then go ahead and create the specific child
    classes based on this `Vehicle` class, for example, `boat`, `car`, `bicycle`,
    and `motorcycle`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程中的一个关键概念。它是这样的概念：类可以有子类，这些子类继承父类的属性和方法。例如，如果你在应用程序中需要各种车辆对象，你可以在一个名为`Vehicle`的类中指定一些车辆的共享属性和方法。然后，基于这个`Vehicle`类，你可以继续创建具体的子类，例如`boat`、`car`、`bicycle`和`motorcycle`。
- en: 'This could be a very simple version of the `Vehicle` class:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是`Vehicle`类的一个非常简单的版本：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here we have two methods in our `Vehicle` class: `move` and `accelerate`. And
    this could be a `Motorcyle` class inheriting from this class using the `extends`
    keyword:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Vehicle`类中，有两种方法：`move`和`accelerate`。这可以是一个使用`extends`关键字从该类继承的`Motorcyle`类：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: With the `extends` keyword we specify that a certain class is the child of another
    class. In this case, `Motorcycle` is a child class of `Vehicle`. This means that
    we'll have access to properties and methods from `Vehicle` in our `Motorcycle`
    class. We have added a special `doWheelie()` method. This is not something that
    makes sense to add to the `Vehicle` class, because this is an action that is specific
    to certain vehicles.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`extends`关键字，我们指定一个类是另一个类的子类。在这种情况下，`Motorcycle`是`Vehicle`的子类。这意味着我们将在我们的`Motorcycle`类中访问`Vehicle`的属性和方法。我们添加了一个特殊的`doWheelie()`方法。这不是可以添加到`Vehicle`类中的东西，因为这是一种特定于某些车辆的行为。
- en: 'The `super` word in the constructor is calling the constructor from the parent,
    the `Vehicle` constructor in this case. This makes sure that the fields from the
    parent are set as well and that the methods are available without having to do
    anything else: they are automatically inherited. Calling `super()` is not optional,
    you must do it when you are in a class that is inheriting from another class,
    else you will get a `ReferenceError`.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的`super`关键字是在调用父类的构造函数，在这个例子中是`Vehicle`构造函数。这确保了父类的字段也被设置，并且方法可用，而无需做任何其他事情：它们是自动继承的。调用`super()`是必须的，当你在一个继承自另一个类的类中时，否则你会得到一个`ReferenceError`。
- en: 'Because we have access to the fields of `Vehicle` in `Motorcycle`, this will
    work:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在`Motorcycle`中可以访问`Vehicle`的字段，所以这会起作用：
- en: '[PRE35]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And this is what it will output:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它将输出的内容：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We cannot access any `Motorcycle` specific properties or methods in our `Vehicle`
    class. This is because not all vehicles are motorcycles, so we cannot be sure
    that we would have the properties or methods from a child.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在我们的`Vehicle`类中访问任何`Motorcycle`特定的属性或方法。这是因为并不是所有的车辆都是摩托车，所以我们不能确定我们会有来自子类的属性或方法。
- en: Right now, we don't use any getters and setters here, but we clearly could.
    If there are getters and setters in the parent class, they are inherited by the
    child class as well. This way we could influence which properties could be fetched
    and changed (and how) outside our class. This is generally a good practice.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们没有在这里使用任何getter和setter，但我们当然可以。如果父类中有getter和setter，它们也会被子类继承。这样我们就可以影响哪些属性可以被获取和修改（以及如何修改）在我们的类外部。这通常是一个好的实践。
- en: Prototypes
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: A prototype is the mechanism in JavaScript that makes it possible to have objects.
    When nothing is specified when creating a class, the objects inherit from the
    `Object.prototype` prototype. This is a rather complex built-in JavaScript class
    that we can use. We don't need to look at how this is implemented in JavaScript,
    as we can consider it the base object that is always on top of the inheritance
    tree and therefore always present in our objects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 原型是 JavaScript 中使对象成为可能的一种机制。在创建类时没有指定任何内容时，对象会从 `Object.prototype` 原型继承。这是一个相当复杂的内置
    JavaScript 类，我们可以使用它。我们不需要查看它在 JavaScript 中的实现方式，因为我们把它看作是始终位于继承树顶部的基对象，因此始终存在于我们的对象中。
- en: 'There is a `prototype` property available on all classes, and it is always
    named "prototype." We can access it like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都有一个名为 "prototype" 的 `prototype` 属性，我们可以这样访问它：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s give an example of how to add a function to a class using the `prototype`
    property. In order to do so, we''ll be using this `Person` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过 `prototype` 属性向一个类添加函数的例子。为了做到这一点，我们将使用这个 `Person` 类：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And here is how to add a function to this class using `prototype`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如此，这是如何使用 `prototype` 向此类添加函数的方法：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`prototype` is a property holding all the properties and methods of an object.
    So, adding a function to `prototype` is adding a function to the class. You can
    use `prototype` to add properties or methods to an object, like we did in the
    above example in our code with the `introduce` function. You can also do this
    for properties:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`prototype` 是一个包含对象所有属性和方法属性的属性。因此，向 `prototype` 添加函数就是向类添加函数。你可以使用 `prototype`
    向对象添加属性或方法，就像我们在上面的例子中用 `introduce` 函数所做的那样。你也可以为属性做同样的事情：'
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And then you can call them from instances of `Person`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以从 `Person` 的实例中调用它们：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It will output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: And it will be as if you had defined the class with a favorite color holding
    a default value, and a function, `introduce`. They have been added to the class
    and are available for all instances and future instances.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就好像你定义了一个类，其中有一个喜欢的颜色并持有默认值，还有一个函数 `introduce`。它们已经被添加到类中，并且对所有实例和未来的实例都是可用的。
- en: So the methods and properties defined via `prototype` are really as if they
    were defined in the class. This means that overwriting them for a certain instance
    doesn't overwrite them for all instances. For example, if we were to have a second
    `Person` object, this person could overwrite the `favoriteColor` value and this
    wouldn't change the value for our object with `firstname` as `Maria`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过 `prototype` 定义的属性和方法实际上就像它们是在类中定义的一样。这意味着对于特定实例的重写不会影响所有实例。例如，如果我们有一个第二个
    `Person` 对象，这个人可以重写 `favoriteColor` 值，这不会改变 `firstname` 为 `Maria` 的对象中的值。
- en: This is something you should not be using when you have control over the class
    code and you want to change it permanently. In that case, just change the class.
    However, you can expand existing objects like this and even expand existing objects
    conditionally. It is also important to know that the JavaScript built-in objects
    have prototypes and inherit from `Object.prototype`. However, be sure not to modify
    this prototype since it will affect how our JavaScript works.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你控制类代码并希望永久更改它时，你不应该使用这种方法。在这种情况下，只需更改类即可。然而，你可以像这样扩展现有对象，甚至有条件地扩展现有对象。重要的是要知道，JavaScript
    内置对象有原型，并从 `Object.prototype` 继承。但是，请确保不要修改这个原型，因为它会影响我们的 JavaScript 的工作方式。
- en: Practice exercise 7.3
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 7.3
- en: 'Create a class that contains properties for different animal species and the
    sound that each species makes, and create two (or more) animals:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含不同动物物种及其叫声的属性的类，并创建两个（或更多）动物：
- en: Create a method that prints a given animal and its sound.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个打印给定动物及其叫声的方法。
- en: Add a prototype with another action for the animal.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为动物添加一个具有另一个动作的原型。
- en: Output an entire animal object into the console.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将整个动物对象输出到控制台。
- en: Chapter projects
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节项目
- en: Employee tracking app
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 员工跟踪应用
- en: 'Create a class to track the employees of a company:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类来跟踪公司的员工：
- en: Use first names, last names, and the number of years worked as values in the
    constructor.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中使用名字、姓氏和工作年数作为值。
- en: Create two or more people with values for their first names, last names, and
    the number of years they've worked at the company. Add the people into an array.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个或更多具有他们的名字、姓氏和在公司工作年数的人。将这些人添加到数组中。
- en: Set up a prototype to return the details of the person's first and last names
    and how long they've worked at the company.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个原型来返回人员的姓名细节以及他们在公司工作的时间。
- en: Iterate the contents of the array to output the results into the console, adding
    some text to make the output a full sentence.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历数组的元素，将结果输出到控制台，并添加一些文本使输出成为一个完整的句子。
- en: Menu items price calculator
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 菜单项价格计算器
- en: Create a class which will allow you to work out the combined price of a number
    of items, and interact with it to work out the total cost of different orders.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类，它将允许你计算出多个项目的组合价格，并与它交互以计算出不同订单的总成本。
- en: Create a class that contains the prices of two menu items as private field declarations.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含两个菜单项价格的私有字段声明。
- en: Use the constructor in the class to get the argument values (how many of each
    item are being bought).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中使用构造函数来获取参数值（购买每种物品的数量）。
- en: Create a method to calculate and return the total cost depending on how many
    of each item the user selects.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来根据用户选择的每种物品的数量计算并返回总成本。
- en: Use a getter property to grab the value output by the calculation method.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用getter属性来获取计算方法输出的值。
- en: Create two or three objects with different combinations of menu selections,
    and output the total cost in the console.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个或三个具有不同菜单选择组合的对象，并在控制台输出总成本。
- en: Self-check quiz
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查测验
- en: What is the keyword used to create a class?
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于创建类的关键字是什么？
- en: How would you set up a class for a person's first and last names that could
    include `first` and `last` as initial properties?
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何设置一个包含`first`和`last`作为初始属性的类来存储人的姓名？
- en: What is the concept of one thing gaining the properties and behaviors of another
    thing called?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一种事物获得另一种事物的属性和行为的概念称为什么？
- en: Which of the following are true about the `constructor` method?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关于`constructor`方法的哪些说法是正确的？
- en: It gets executed automatically when a new object is created.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建新对象时自动执行。
- en: It should only be added afterward.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该只在之后添加。
- en: It has to include the `constructor` keyword.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须包含`constructor`关键字。
- en: It is used to initialize object properties.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用于初始化对象属性。
- en: It can be used when you have multiple values.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你有多重值时可以使用它。
- en: Troubleshoot the following code so that the prototype outputs the first and
    last name of the `Person` into the console. Which is the correct syntax for the
    `Person` prototype?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复以下代码，以便原型将`Person`的姓名输出到控制台。`Person`原型的正确语法是什么？
- en: '[PRE43]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A)
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A)
- en: '[PRE44]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: B)
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B)
- en: '[PRE45]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: C)
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C)
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we introduced you to the concept of OOP. This means that we
    structure our code in such a way that objects are the central players of the logic.
    Classes are blueprints for objects. We can make a template for an object and create
    an instance easily by using the `new` keyword.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了面向对象编程（OOP）的概念。这意味着我们以这种方式组织代码，使得对象是逻辑中的核心角色。类是对象的蓝图。我们可以为对象制作一个模板，并通过使用`new`关键字轻松创建实例。
- en: We then saw that classes can inherit from each other by using the `extends`
    keyword. Classes that extend from another class will have to call the constructor
    of this class with `super()` and will then automatically have access to all the
    properties and methods of the parent. This is great for reusable and highly maintainable
    code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到类可以通过使用`extends`关键字相互继承。从另一个类继承的类必须使用`super()`调用此类的构造函数，然后自动访问所有父类的属性和方法。这对于可重用和高度可维护的代码来说是非常好的。
- en: Lastly, we encountered prototypes. This is the built-in JavaScript concept that
    makes classes possible. By adding properties and methods to a class using `prototype`,
    we can modify the blueprint of that class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遇到了原型。这是JavaScript的内置概念，使得类成为可能。通过使用`prototype`向类添加属性和方法，我们可以修改该类的蓝图。
- en: In the next chapter, we will consider some of JavaScript's built-in methods,
    which can be used to manipulate and add complexity to your code!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将考虑一些JavaScript的内置方法，这些方法可以用来操纵和增加代码的复杂性！
