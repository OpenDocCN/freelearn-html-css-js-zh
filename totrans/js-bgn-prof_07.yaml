- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to discuss JavaScript classes. We have seen JavaScript
    objects already, and classes are a blueprint or template for object creation.
    So, many of the things discussed here should not sound too unfamiliar or revolutionary.
  prefs: []
  type: TYPE_NORMAL
- en: Classes enable object-oriented programming, which was one of the most important
    design advancements in software development. This development reduced the complexity
    of applications and increased maintainability by a huge margin.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, object-oriented programming and classes are of great importance for computer
    science in general. This is not necessarily the case when we apply it to JavaScript
    though. JavaScript classes are something special compared to other programming
    languages. Beneath the surface, classes are wrapped in some sort of special function.
    This means that they are actually an alternative syntax for defining objects using
    a constructor function. In this chapter, we will learn what classes are and how
    we can create and use them. Along the way, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: exercise, project, and self-check quiz answers can be found in the *Appendix*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start diving right into the fun of classes, let's briefly say something
    about **object-oriented programming** (**OOP**). OOP is a very important programming
    paradigm wherein code is structured in objects, leading to more maintainable and
    reusable code. Working with OOP teaches you to really try to think of all sorts
    of topics in objects, by bundling properties in such a way that they can be wrapped
    in a blueprint called a class. This in turn might be inheriting properties from
    a parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we are thinking of an animal, we can come up with certain properties:
    name, weight, height, maximum speed, colors, and a lot more. And then if we think
    of a specific species of fish, we can reuse all the properties of "animal" and add
    a few fish-specific properties in there as well. The same for dogs; if we then
    think of a dog, we can reuse all the properties of "animal" and add a few dog-specific
    ones to it. This way we have reusable code of our animal class. And when we realize
    we forgot a very important property for the many animals in our application, we
    only need to add it to the animal class.'
  prefs: []
  type: TYPE_NORMAL
- en: This is very important for Java, .NET, and other classic object-oriented ways
    of writing code. JavaScript doesn't necessarily revolve around objects. We will
    need them and we will use them, but they are not the star of our code, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: Classes and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a quick refresher, objects are a collection of properties and methods. We
    saw them in *Chapter 3*, *JavaScript Multiple Values*. The properties of an object
    should have sensible names. So for example, if we have a `person` object, this
    object could have properties called `age` and `lastName` that contain values.
    Here is an example of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes in JavaScript encapsulate data and functions that are part of that
    class. If you create a class, you can later create objects using that class using
    the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code defines a class with `ClassName` as a name, declares an `obj` variable,
    and initializes this with a new instance of the object. Two arguments are provided.
    These arguments will be used by the constructor to initialize the properties.
    As you can see, the parameters of the constructor and the properties of the class
    (`prop1` and `prop2`) have the same name. The properties of the class can be recognized
    by the `this` keyword in front of them. The `this` keyword refers to the object
    it belongs to, so it is the first property of the instance of `ClassName`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember we said that classes are just some special function beneath the surface.
    We could create the object with a special function like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The dog example could have been made using a class syntax as well. It would
    have looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in an object with the same properties. If we do some logging as
    follows, we will be able to see it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the next section, we will dive into all the parts of classes.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may wonder, if classes do the exact same thing as simply defining an object,
    why do we even need classes? The answer is that classes are essentially blueprints
    for object creation. This means that we need to do much less typing if we need
    to create 20 dogs when we have a `dog` class. If we have to create the objects,
    we will have to specify all the properties' names each time. And it would be easy
    to make a typo and misspell a property name. Classes come in handy in these sorts
    of situations.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the previous section, we use the `class` keyword to tell JavaScript
    we want to create a class. Next, we give the class a name. It is the convention
    to start class names with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at all the different elements of a class.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `constructor` method is a special method that we use to initialize objects
    with our class blueprint. There can only be one constructor in a class. This constructor
    contains properties that will be set when initiating the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you can see an example of a constructor in a `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Beneath the surface, JavaScript creates a special function based on this constructor.
    This function gets the class name, and it will create an object with the given
    properties. With this special function, you can create instances (objects) of
    the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how you can create a new object from the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `new` word is what tells JavaScript to look for the special constructor
    function in the `Person` class and create a new object. The constructor gets called
    and returns an instance of the person object with the specified properties. This
    object gets stored in the `p` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we use our new `p` variable in a logging statement, you can see that the
    properties are really set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What do you think will happen when we create a class without all of the properties?
    Let''s find out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Many languages would crash, but not JavaScript. It just sets the remaining
    properties to `undefined`. You can see what happens by logging it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify default values in `constructor`. You would do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This way, it would not have printed `Hi Maaike undefined`, but `Hi Maaike Doe`.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 7.1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take the following steps to create a person class, and print instances of friends''
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class for `Person` including the constructor for `firstname` and `lastname`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable and assign a value of the new `Person` object using your friend's
    first and last names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a second variable with another friend's name using their first name
    and last name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output both friends into the console with a greeting of `hello`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a class, we can specify functions. This means that our object can start
    doing things using the object''s own properties—for example, printing a name.
    Functions on a class are called methods. When defining these methods, we don''t
    use the `function` keyword. We start directly with the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can call the `greet` method on a `Person` object like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify as many methods on a class as you want. In this example, we
    are using the `firstname` property. We do so by saying `this.property`. If we
    had a person with a different value for the `firstname` property, for example,
    `Rob`, it would have printed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like functions, methods can also take parameters and return results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `compliment` function does not output anything itself, so we are logging
    it
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this case we are sending parameters into our method, because you don't usually
    compliment your own properties (that's a nice sentence, Maaike!). However, whenever
    the method doesn't require external input but only the properties of the object,
    no parameters will work and the method can use its object's properties. Let's do
    an exercise and then move on to using the properties of classes outside the class.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 7.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Get your friend''s full name:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `Person` class from *Practice exercise 7.1*, add a method called `fullname`,
    which returns the concatenated value of `firstname` and `lastname` when invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create values for `person1` and `person2` using two friends' first and last
    names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `fullname` method within the class, return the full name of one or
    both people.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Properties, sometimes also called fields, hold the data of the class. We have
    seen one kind of property already, when we created them in our constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `Person` class gets two properties from the constructor: `firstname`
    and `lastname`. Properties can be added or removed just like we did for objects.
    These properties can be accessed from outside the class, as we saw when we logged
    them outside the class by accessing them on the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Often, it is not desirable to provide direct access to our properties. We want
    our class to be in control of the values of properties for several reasons—perhaps
    we want to do validation on a property to assure it has a certain value. For example,
    imagine wanting to validate an age as not being lower than 18\. We can achieve
    this by making direct access to the property from outside the class impossible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how to add properties that aren''t accessible from outside. We prefix
    them with a `#` symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Right now, the `firstname` and `lastname` properties cannot be accessed from
    outside the class. This is done by adding `#` in front of the property. If we
    try it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wanted to make sure we could only create objects with names starting
    with an "M," we could modify our constructor a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now when you try to create a person that has a `firstname` value that doesn''t
    start with an "M," it will add an `M` in front. So for example, the value of the
    following first name is `Mkay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This is a very silly example of validation. At this point, we cannot access
    it from outside the class at all after the constructor. We can only access it
    from inside the class. This is where getters and setters come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Getters and setters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getters and setters are special properties that we can use to get data from
    a class and to set data fields on the class. Getters and setters are computed
    properties. So, they are more like properties than they are like functions. We
    call them accessors. They do look a bit like functions, because they have `()`
    behind them, but they are not!
  prefs: []
  type: TYPE_NORMAL
- en: These accessors start with the `get` and `set` keywords. It is considered good
    practice to make fields private as much as possible and provide access to them
    using getters and setters. This way, the properties cannot be set from outside
    without the object itself being in control. This principle is called **encapsulation**.
    The class encapsulates the data, and the object is in control of its own fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The getter is used to get the property. Therefore, it doesn''t take any parameters,
    but simply returns the property. The setter is the other way around: it takes
    a parameter, assigns this new value to the property, and returns nothing. The
    setter can contain more logic, for example, some validation, as we''ll see below.
    The getter can be used outside the object as if it were a property. The properties
    are no longer directly accessible from outside the class, but can be accessed
    via the getter to get the value and via the setter to update the value. Here is
    how to use it outside the class instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have created a new `Person` object with a first name of `Maria` and last
    name of `Saga`. The output is showing the first name, which is only possible because
    we have a getter accessor. We can also set the value to something else, because
    there is a setter. Here is how to update the first name, so the name is no longer
    `Maria`, but `Adnane`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, nothing special is happening in the setter. We could do a similar
    validation as in the constructor before, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This will check whether `firstname` starts with an `M`, and if it does it will
    update the value to whatever the `firstname` parameter is. If it doesn't, it will
    concatenate an `M` in front of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that we do not access `firstname` as if it was a function. If you
    put two parentheses `()` after it, you would actually get an error telling you
    that it is not a function.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inheritance is one of the key concepts of OOP. It is the concept that classes
    can have child classes that inherit the properties and methods from the parent
    class. For example, if you needed all sorts of vehicle objects in your application,
    you could specify a class named `Vehicle` in which you specify some shared properties
    and methods of vehicles. You would then go ahead and create the specific child
    classes based on this `Vehicle` class, for example, `boat`, `car`, `bicycle`,
    and `motorcycle`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This could be a very simple version of the `Vehicle` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we have two methods in our `Vehicle` class: `move` and `accelerate`. And
    this could be a `Motorcyle` class inheriting from this class using the `extends`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: With the `extends` keyword we specify that a certain class is the child of another
    class. In this case, `Motorcycle` is a child class of `Vehicle`. This means that
    we'll have access to properties and methods from `Vehicle` in our `Motorcycle`
    class. We have added a special `doWheelie()` method. This is not something that
    makes sense to add to the `Vehicle` class, because this is an action that is specific
    to certain vehicles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `super` word in the constructor is calling the constructor from the parent,
    the `Vehicle` constructor in this case. This makes sure that the fields from the
    parent are set as well and that the methods are available without having to do
    anything else: they are automatically inherited. Calling `super()` is not optional,
    you must do it when you are in a class that is inheriting from another class,
    else you will get a `ReferenceError`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we have access to the fields of `Vehicle` in `Motorcycle`, this will
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what it will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: We cannot access any `Motorcycle` specific properties or methods in our `Vehicle`
    class. This is because not all vehicles are motorcycles, so we cannot be sure
    that we would have the properties or methods from a child.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, we don't use any getters and setters here, but we clearly could.
    If there are getters and setters in the parent class, they are inherited by the
    child class as well. This way we could influence which properties could be fetched
    and changed (and how) outside our class. This is generally a good practice.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A prototype is the mechanism in JavaScript that makes it possible to have objects.
    When nothing is specified when creating a class, the objects inherit from the
    `Object.prototype` prototype. This is a rather complex built-in JavaScript class
    that we can use. We don't need to look at how this is implemented in JavaScript,
    as we can consider it the base object that is always on top of the inheritance
    tree and therefore always present in our objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a `prototype` property available on all classes, and it is always
    named "prototype." We can access it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s give an example of how to add a function to a class using the `prototype`
    property. In order to do so, we''ll be using this `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And here is how to add a function to this class using `prototype`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`prototype` is a property holding all the properties and methods of an object.
    So, adding a function to `prototype` is adding a function to the class. You can
    use `prototype` to add properties or methods to an object, like we did in the
    above example in our code with the `introduce` function. You can also do this
    for properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you can call them from instances of `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: And it will be as if you had defined the class with a favorite color holding
    a default value, and a function, `introduce`. They have been added to the class
    and are available for all instances and future instances.
  prefs: []
  type: TYPE_NORMAL
- en: So the methods and properties defined via `prototype` are really as if they
    were defined in the class. This means that overwriting them for a certain instance
    doesn't overwrite them for all instances. For example, if we were to have a second
    `Person` object, this person could overwrite the `favoriteColor` value and this
    wouldn't change the value for our object with `firstname` as `Maria`.
  prefs: []
  type: TYPE_NORMAL
- en: This is something you should not be using when you have control over the class
    code and you want to change it permanently. In that case, just change the class.
    However, you can expand existing objects like this and even expand existing objects
    conditionally. It is also important to know that the JavaScript built-in objects
    have prototypes and inherit from `Object.prototype`. However, be sure not to modify
    this prototype since it will affect how our JavaScript works.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 7.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a class that contains properties for different animal species and the
    sound that each species makes, and create two (or more) animals:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a method that prints a given animal and its sound.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a prototype with another action for the animal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output an entire animal object into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Employee tracking app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a class to track the employees of a company:'
  prefs: []
  type: TYPE_NORMAL
- en: Use first names, last names, and the number of years worked as values in the
    constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two or more people with values for their first names, last names, and
    the number of years they've worked at the company. Add the people into an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a prototype to return the details of the person's first and last names
    and how long they've worked at the company.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate the contents of the array to output the results into the console, adding
    some text to make the output a full sentence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Menu items price calculator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a class which will allow you to work out the combined price of a number
    of items, and interact with it to work out the total cost of different orders.
  prefs: []
  type: TYPE_NORMAL
- en: Create a class that contains the prices of two menu items as private field declarations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the constructor in the class to get the argument values (how many of each
    item are being bought).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a method to calculate and return the total cost depending on how many
    of each item the user selects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a getter property to grab the value output by the calculation method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create two or three objects with different combinations of menu selections,
    and output the total cost in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-check quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the keyword used to create a class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you set up a class for a person's first and last names that could
    include `first` and `last` as initial properties?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the concept of one thing gaining the properties and behaviors of another
    thing called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following are true about the `constructor` method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It gets executed automatically when a new object is created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It should only be added afterward.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It has to include the `constructor` keyword.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is used to initialize object properties.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be used when you have multiple values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshoot the following code so that the prototype outputs the first and
    last name of the `Person` into the console. Which is the correct syntax for the
    `Person` prototype?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: B)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: C)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to the concept of OOP. This means that we
    structure our code in such a way that objects are the central players of the logic.
    Classes are blueprints for objects. We can make a template for an object and create
    an instance easily by using the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: We then saw that classes can inherit from each other by using the `extends`
    keyword. Classes that extend from another class will have to call the constructor
    of this class with `super()` and will then automatically have access to all the
    properties and methods of the parent. This is great for reusable and highly maintainable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we encountered prototypes. This is the built-in JavaScript concept that
    makes classes possible. By adding properties and methods to a class using `prototype`,
    we can modify the blueprint of that class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will consider some of JavaScript's built-in methods,
    which can be used to manipulate and add complexity to your code!
  prefs: []
  type: TYPE_NORMAL
