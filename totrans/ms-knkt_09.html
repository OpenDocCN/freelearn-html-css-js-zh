<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Under the Hood</h1></div></div></div><p class="calibre8">We have covered the Knockout basics, learned how to extend Knockout's binding system, and seen how to organize applications. Now, it's time to indulge our inner tinkerers. In this chapter, we will look at the internals of Knockout to see what makes it tick. By the end of this chapter, you should be familiar with how Knockout handles the following:</p><div><ul class="itemizedlist"><li class="listitem">Dependency tracking</li><li class="listitem">The prototype chain</li><li class="listitem">Parsing binding attribute expressions</li><li class="listitem">Applying bindings</li><li class="listitem">Templating</li></ul></div><p class="calibre8">In addition to this, we will also look at the <code class="literal">ko.utils</code> namespace, which provides lots of useful tools for common actions.</p><div><h3 class="title2"><a id="note29" class="calibre1"/>Note</h3><p class="calibre8">Note that all of the code discussed in this chapter is based on the Knockout 3.2 release. It is possible, and likely, that parts of this will change in the future.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec68" class="calibre1"/>Dependency tracking</h1></div></div></div><p class="calibre8">Binding handlers<a id="id676" class="calibre1"/> and computed observables need to re-evaluate when their observable dependencies update. This means keeping track of dependencies and subscribing to them. Three objects make up the dependency-tracking feature: observables, computed observables, and the dependency-detection module.</p><p class="calibre8">Here's the basic overview. When a computed is evaluated, it asks <code class="literal">ko.dependencyDetection</code> to start tracking things. When observables are accessed, they register themselves with <code class="literal">ko.dependencyDetection</code>. When the computed is done evaluating, it records all of the registered dependencies and subscribes to each of them.</p><p class="calibre8">Okay, now let's look at some code.</p></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec123" class="calibre1"/>ko.dependencyDetection</h2></div></div></div><p class="calibre8">The dependency <a id="id677" class="calibre1"/>detection module is very small—small enough to <a id="id678" class="calibre1"/>reproduce here in its entirety, actually:</p><div><pre class="programlisting">ko.computedContext = ko.dependencyDetection = (function () {
  var outerFrames = [],
  currentFrame,
  lastId = 0;

  function getId() {
    return ++lastId;
  }

  function begin(options) {
    outerFrames.push(currentFrame);
    currentFrame = options;
  }

  function end() {
    currentFrame = outerFrames.pop();
  }

  return {
    begin: begin,
    end: end,
    registerDependency: function (subscribable) {
      if (currentFrame) {
        if (!ko.isSubscribable(subscribable))
        throw new Error("Only subscribable things can act as dependencies");
        currentFrame.callback(subscribable, subscribable._id || (subscribable._id = getId()));
      }
    },
    ignore: function (callback, callbackTarget, callbackArgs) {
      try {
        begin();
        return callback.apply(callbackTarget, callbackArgs || []);
      } finally {
        end();
      }
    },
    getDependenciesCount: function () {
      if (currentFrame)
      return currentFrame.computed.getDependenciesCount();
    },
    isInitial: function() {
      if (currentFrame)
      return currentFrame.isInitial;
    }
  };
})();</pre></div><p class="calibre8">The preceding code is using the revealing module pattern to hide the internal variables for <code class="literal">outerFrames</code>, <code class="literal">currentFrame</code>, <code class="literal">lastId</code>, and the <code class="literal">getId</code> function.</p><div><h3 class="title2"><a id="note30" class="calibre1"/>Note</h3><p class="calibre8">For more information on the <a id="id679" class="calibre1"/>revealing module pattern, check out Todd Motto's blog at <a class="calibre1" href="http://toddmotto.com/mastering-the-module-pattern">http://toddmotto.com/mastering-the-module-pattern</a>.</p></div><p class="calibre8">The idea here is that <code class="literal">begin</code> is called with either a frame that can be used for tracking, or it is called with nothing to disable tracking. When <code class="literal">end</code> is called, the previous frame is popped off and set to the current frame. A <strong class="calibre9">frame</strong>
<a id="id680" class="calibre1"/> is a layer that tracks dependencies; a frame exists inside of another frame, but only the current frame will register dependencies when they are accessed. This allows dependency tracking to occur recursively, while each layer receives only its immediate dependencies.</p><p class="calibre8">The <code class="literal">options</code> object that is passed to <code class="literal">begin</code> should expose the following properties:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">callback</code>: This is a <a id="id681" class="calibre1"/>function that receives a dependency and its ID when a dependency registers itself</li><li class="listitem"><code class="literal">computed</code>: This is the <a id="id682" class="calibre1"/>computed observable that performs the dependency tracking on the frame</li><li class="listitem"><code class="literal">isInitial</code>: This is a <a id="id683" class="calibre1"/>Boolean that indicates whether this is the first time dependency tracking has been requested for the current frame</li></ul></div><p class="calibre8">When <code class="literal">registerDependency</code> is called, the current frame's callback is passed to the <a id="id684" class="calibre1"/>dependency and its ID. The ID is a sequentially generated number, which is assigned to the dependency if it is missing.</p><p class="calibre8">The <code class="literal">ignore</code> function provides an easy <a id="id685" class="calibre1"/>wrapper around <code class="literal">begin</code> and <code class="literal">end</code> inside a <code class="literal">try</code>/<code class="literal">finally</code> block. The call to <code class="literal">begin</code> has no options, so it will not trigger dependency detection. This makes it easy to evaluate data in situations where you know dependency detection will not, or should not, be used. Knockout does this inside several binding handlers as well as inside the <code class="literal">notifySubscribers</code> function of subscribables.</p><p class="calibre8">The last two properties, which are <code class="literal">getDependenciesCount</code> and <code class="literal">isInitial</code>, expose the properties of the same name on the current frame.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec124" class="calibre1"/>Registering dependencies</h2></div></div></div><p class="calibre8">When an observable is<a id="id686" class="calibre1"/> read, it has to notify <code class="literal">ko.dependencyDetection</code> in order to indicate that a dependency has been accessed. Because computeds and observables are both descendants of subscribables, which do not register dependencies, each of them has their own similar dependency registration logic.</p><p class="calibre8">The observable implementation happens when the observable is called with no arguments:</p><div><pre class="programlisting">function observable() {
  if (arguments.length &gt; 0) {
    /* write new value */
  }
  else {
    // Read
    ko.dependencyDetection.registerDependency(observable); 
    return _latestValue;
  }
}</pre></div><p class="calibre8">After registering itself as a dependency, it returns its current value. The computed version is almost identical:</p><div><pre class="programlisting">function dependentObservable() {
  if (arguments.length &gt; 0) {
    /* write new value */
  } else {
    ko.dependencyDetection.registerDependency(dependentObservable);
    if (_needsEvaluation) //suppressChangeNotification
    evaluateImmediate(true);
    return _latestValue;
  }
}</pre></div><p class="calibre8">The only difference here is that because computeds can be evaluated asynchronously, the <code class="literal">read</code> function checks whether a re-evaluation is needed before returning its value.</p><p class="calibre8">There isn't much else to say regarding this. The observable array type makes no changes to the registration process. In fact, it couldn't make any changes. Dependency registration is an internal logic for observables; it can't be overridden.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec125" class="calibre1"/>Subscribing to dependencies</h2></div></div></div><p class="calibre8">The prototype for all <a id="id687" class="calibre1"/>observables is the subscribable. The subscribable prototype provides two functions for dependency work: <code class="literal">subscribe</code> and <code class="literal">notifySubscribers</code>.</p><p class="calibre8">The <code class="literal">subscrib</code>e function creates a subscription on the subscribable. The subscription doesn't do anything on its own, it's just an object with a <code class="literal">callback</code> and <code class="literal">dispose</code> property (it has other properties; these are just the relevant ones). The subscription is stored in the <code class="literal">_subscriptions</code> object and the internal-use property. As subscriptions can be attached to named events, the subscriptions object has an array for each event:</p><div><pre class="programlisting">_subscriptions: {
  change: [sub1, sub2],
  beforeChange: [sub3, sub4]
};</pre></div><p class="calibre8">When a subscription is created without a name, it is attached to the change event by default. The other standard event is the <code class="literal">beforeChange</code> event, which is fired by observables just before they update. This is the write logic from the observable:</p><div><pre class="programlisting">function observable() {
  if (arguments.length &gt; 0) {
    // Ignore writes if the value hasn't changed
    if (observable.isDifferent(_latestValue, arguments[0])) {
      observable.valueWillMutate();
      _latestValue = arguments[0];
      observable.valueHasMutated();
    }
    return this; // Permits chained assignments
  }
  else {
    // Read code
  }
}
//...
observable.valueHasMutated = function () {
  observable["notifySubscribers"](_latestValue);
}
observable.valueWillMutate = function () {
  observable["notifySubscribers"](_latestValue, "beforeChange");
}</pre></div><p class="calibre8">Before an observable is updated, it calls <code class="literal">valueWillMutate</code>, and afterwards, it calls <code class="literal">valueHasMutated</code>. Both of these are wrappers around the <code class="literal">notifySubscribers</code> function, with the first providing the <code class="literal">beforeChange</code> event name:</p><div><pre class="programlisting">notifySubscribers: function (valueToNotify, event) {
  event = event || defaultEvent;
  if (this.hasSubscriptionsForEvent(event)) {
    try {
      // Begin suppressing dependency detection
      ko.dependencyDetection.begin();
      for (var a = this._subscriptions[event].slice(0), 
      i = 0, subscription; 
      subscription = a[i]; ++i) {
        if (!subscription.isDisposed)
        subscription.callback(valueToNotify);
      }
    } finally {
      // End suppressing dependency detection
      ko.dependencyDetection.end(); 
   }
 }
}</pre></div><p class="calibre8">Once again, the <a id="id688" class="calibre1"/>event name is optional and defaults to <code class="literal">change</code> when omitted. It also checks to make sure subscriptions for the event exist before it starts. Then, it disables dependency detection. If it didn't disable dependency detection, then a false dependency would be established between the original writer of the new value and subscribers of the current observable.</p><div><h3 class="title2"><a id="note31" class="calibre1"/>Note</h3><p class="calibre8">This basic publish/subscribe implementation<a id="id689" class="calibre1"/> can easily be used to create a messaging system. In fact, Ryan Niemeyer has created a plugin to do just that (see <a class="calibre1" href="https://github.com/rniemeyer/knockout-postbox">https://github.com/rniemeyer/knockout-postbox</a>).</p></div><p class="calibre8">The primary work is to loop through the subscriptions and pass the current value to the subscriptions callback. A check is performed to ensure that the subscription didn't get disposed, as it is possible that one subscription is disposed because of another. Finally, the previous block of code ends the current frame of dependency detection.</p><p class="calibre8">With these three pieces, Knockout provides a simple and performant dependency tracking system.</p></div></div></div>

<div><div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec126" class="calibre1"/>Subscribing to observable arrays</h2></div></div></div><p class="calibre8">Prototypically speaking, observable <a id="id690" class="calibre1"/>arrays are still observables, but because their changes are primarily their contents and not their values, they have a lot of additional logic that ensures performant notifications.</p><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec51" class="calibre1"/>Standard array functions</h3></div></div></div><p class="calibre8">JavaScript has had a<a id="id691" class="calibre1"/> standard set of array functions since ECMAScript's first edition, so you should already be familiar with them. The headache they cause for Knockout is that they modify the contents of the array directly. Since array subscribers expect to be notified to changes in the array's content, Knockout provides their own implementation for <code class="literal">observableArray</code>. This implementation makes calls to the standard notification functions on observables before calling the original array function. The <code class="literal">slice</code> function is skipped, since it is a read-only function and doesn't needs to notify subscribers:</p><div><pre class="programlisting">ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
  ko.observableArray['fn'][methodName] = function () {
    var underlyingArray = this.peek();
    this.valueWillMutate();
    this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);
    var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
    this.valueHasMutated();
    return methodCallResult;
  };
});</pre></div><p class="calibre8">This function has barely changed since Knockout 1.0, where it added the methods to each instance instead of the observable array's <code class="literal">fn</code> prototype. The only addition is the call to <code class="literal">cacheDiffForKnownOperation</code>, which works with the internal <code class="literal">trackArrayChanges</code> extender to provide smaller, faster change notifications for incremental updates to the array. Prior to this extender, observable arrays broadcasted their entire contents on every update.</p><p class="calibre8">This function is not too different from the <code class="literal">write</code> function of normal observables; it calls <code class="literal">valueWillMutat</code>e before performing an update, and it calls <code class="literal">valueHasMutated</code> afterward. Instead of setting its own value, it just applies the original method name to the underlying array.</p><p class="calibre8">The <code class="literal">slice</code> function is even simpler. It does not cause subscriptions to fire, as it is read-only. All it does is wrap the original function on the underlying array:</p><div><pre class="programlisting">ko.utils.arrayForEach(["slice"], function (methodName) {
  ko.observableArray['fn'][methodName] = function () {
    var underlyingArray = this();
    return underlyingArray[methodName].apply(underlyingArray, arguments);
  };
});</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch09lvl3sec52" class="calibre1"/>The utility methods</h3></div></div></div><p class="calibre8">In addition to the standard methods, Knockout also provides friendly functions to common array changes that JavaScript, for some reason, still hasn't bothered to implement: <code class="literal">remove</code>, <code class="literal">removeAll</code>, <code class="literal">destroy</code>, <code class="literal">destroyAll</code>, and <code class="literal">replace</code>.</p><p class="calibre8">You should <a id="id692" class="calibre1"/>be able to guess what these functions look like by now; peek to get the underlying array, call <code class="literal">valueWillMutate</code>, make some changes, and then finish with <code class="literal">valueHasMutated</code>. The interesting part about the preceding functions is the arguments they take. If you pass an object to <code class="literal">remove</code>, it will predictably remove that object from the array if it exists. However, if you pass a function, it will be used as a predicate, removing any elements in the array, which causes the predicate to return truthy (I'm very fond of this pattern):</p><div><pre class="programlisting">remove: function (valueOrPredicate) {
  var underlyingArray = this.peek();
  var removedValues = [];
  var predicate = typeof valueOrPredicate == "function" &amp;&amp; !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
  for (var i = 0; i &lt; underlyingArray.length; i++) {
    var value = underlyingArray[i];
    if (predicate(value)) {
      //Remove element, add to removedValues
    }
  }
  if (removedValues.length) {
    this.valueHasMutated();
  }
  return removedValues;
}</pre></div><p class="calibre8">This works by converting single values into a predicate that checks for strict equality. The check for <code class="literal">!ko.isObservable(valueOrPredicate)</code> is important as observables are functions but should be treated as values here and not as predicates.</p><p class="calibre8">This same pattern is used for <code class="literal">destroy</code>, except that it marks the observables with the <code class="literal">_destory</code> property instead of removing them.</p><p class="calibre8">The <code class="literal">removeAll</code> and <code class="literal">destroyAll</code> functions<a id="id693" class="calibre1"/> are also overloaded: they can take an array of<a id="id694" class="calibre1"/> values to be removed, or it can remove all elements if no argument is provided. In the case where an array of values is provided, they<a id="id695" class="calibre1"/> just call <code class="literal">remove</code>/<code class="literal">destroy</code> with a predicate based on the array:</p><div><pre class="programlisting">removeAll: function (arrayOfValues) {
  // If you passed zero args, we remove everything
  if (arrayOfValues === undefined) {
    //remove all elements
  }
  return this['remove'](function (value) {
    return ko.utils.arrayIndexOf(arrayOfValues, value) &gt;= 0;
  });
}</pre></div></div></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec69" class="calibre1"/>The prototype chain</h1></div></div></div><p class="calibre8">Back <a id="id696" class="calibre1"/>in <a class="calibre1" title="Chapter 1. Knockout Essentials" href="part0015_split_000.html#page">Chapter 1</a>, <em class="calibre12">Knockout Essentials</em>, I showed you this diagram:</p><div><img src="img/00016.jpeg" alt="The prototype chain" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The way functions are inherited by these objects is not through the normal JavaScript prototype chain, where a constructor function has its prototype assigned to an object. This is because observables are functions and not objects, and functions cannot be created with constructors or the <code class="literal">Object.create</code> function. Standard JavaScript prototypical inheritance doesn't work for functions. To see how Knockout shares methods, let's look at how subscribable and its descendant observable are constructed.</p><p class="calibre8">First, the base methods for subscribables are defined on the <code class="literal">fn</code> object:</p><div><pre class="programlisting">var ko_subscribable_fn = {
  subscribe: function (callback, target, event) { /* logic */ },
  notifySubscribers: function (value, event) { /* logic */ },
  limit: function(limitFunction) { /* logic */ },
  hasSubscriptionsForEvent: function(event) { /* logic */ },
  getSubscriptionsCount: function () { /* logic */ },
  isDifferent: function(oldValue, newValue) { /* logic */ },
  extend: applyExtenders
};
ko.subscribable['fn'] = ko_subscribable_fn;</pre></div><p class="calibre8">This is added to subscribables during the construction:</p><div><pre class="programlisting">ko.subscribable = function () {
  ko.utils.setPrototypeOfOrExtend(this, ko.subscribable['fn']);
  this._subscriptions = {};
}</pre></div><p class="calibre8">The <code class="literal">setPrototypeOfOrExtend</code> method will <a id="id697" class="calibre1"/>either assign the <code class="literal">__proto__</code> property of an object—something higher IE versions can't do—or use <code class="literal">ko.utils.extend</code> to extend the object.</p><p class="calibre8">Observables are built differently. Their <em class="calibre12">factory</em> method returns an internally built object, which uses both <code class="literal">ko.subscribable.call</code> and <code class="literal">setPrototypeOfOrExtend</code> to inherit methods:</p><div><pre class="programlisting">ko.observable = function (initialValue) {
  var _latestValue = initialValue;

  function observable() {
    //build observable
  }
  ko.subscribable.call(observable);
  ko.utils.setPrototypeOfOrExtend(observable, ko.observable['fn']);

  observable.peek = function() { return _latestValue };
  observable.valueHasMutated = function () { 
    observable["notifySubscribers"](_latestValue); 
  }
  observable.valueWillMutate = function () { 
    observable["notifySubscribers"](_latestValue, "beforeChange"); 
  }

  return observable;
}</pre></div><p class="calibre8">An observable is built and then run through the subscribable's constructor, extended with the <code class="literal">observable[''fn'']</code> object, and finally has its own methods added.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec127" class="calibre1"/>The ko.isObservable function</h2></div></div></div><p class="calibre8">In standard <a id="id698" class="calibre1"/>JavaScript inheritance, the <code class="literal">instanceof</code> operator<a id="id699" class="calibre1"/> can be used to check whether an object, or any of its prototypes, has a constructor that matches the supplied function. Because Knockout isn't using standard inheritance,  it cannot use the <code class="literal">instanceof</code> operator; instead Knockout uses the following code for the <code class="literal">ko.isObservable</code> function.</p><div><pre class="programlisting">var protoProperty = ko.observable.protoProperty = "__ko_proto__";
ko.observable['fn'][protoProperty] = ko.observable;

ko.hasPrototype = function(instance, prototype) {
  if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
  if (instance[protoProperty] === prototype) return true;
  return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
};

ko.isObservable = function (instance) {
  return ko.hasPrototype(instance, ko.observable);
}</pre></div><p class="calibre8">Knockout defines a <code class="literal">__ko_proto__</code> property on the <code class="literal">observable[''fn'']</code> object, which is set to the <code class="literal">ko.observable</code> object. This custom prototype property is used by <code class="literal">hasPrototype</code> in place of the <code class="literal">instanceof</code> operator to determine whether an instanced object is an observable.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec70" class="calibre1"/>The binding expression parser</h1></div></div></div><p class="calibre8">The expressions<a id="id700" class="calibre1"/> written in data-bind attributes are not truly JavaScript or JSON, though they look very similar. Knockout has its own parser to convert these attributes into JavaScript. Say you write a data-bind attribute like this one:</p><div><pre class="programlisting">data-bind="value: name, visible: showName"</pre></div><p class="calibre8">Then, the binding provider's job is to return an object like this:</p><div><pre class="programlisting">{
  value: function() { return name; },
  visible: function() { return showName; }
}</pre></div><p class="calibre8">The default binding provider does this using the <code class="literal">ko.expressionRewriting</code> module, which is responsible for calling binding preprocessors and returning a JSON-esque string. Internally, this is done using regex to parse the full attribute into a key/value pair array. This might sound messy, but it gets the job done. That being said, even for an <em class="calibre12">under the hood</em> look, the details are not very relevant to Knockout, as the parsing is general purpose. If you are <a id="id701" class="calibre1"/>still curious, the code is located at <a class="calibre1" href="https://github.com/knockout/knockout/blob/master/src/binding/expressionRewriting.js">https://github.com/knockout/knockout/blob/master/src/binding/expressionRewriting.js</a>, and its inline comments are better than average.</p><p class="calibre8">After parsing the data-bind attribute, the array of key/value pairs is iterated to build an array of JSON-esque strings:</p><div><pre class="programlisting">function processKeyValue(key, val) {
  var writableVal;
  function callPreprocessHook(obj) {
    return (obj &amp;&amp; obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;
  }
  if (!bindingParams) {
    if (!callPreprocessHook(ko['getBindingHandler'](key)))
    return;

    if (twoWayBindings[key] &amp;&amp; (writableVal = getWriteableValue(val))) {
      //provide a write method in case the value
      // isn't a writable observable.
      propertyAccessorResultStrings.push("'" + key + "':function(_z){" + writableVal + "=_z}");
    }
  }
  if (makeValueAccessors) {
    val = 'function(){return ' + val + ' }';
  }
  resultStrings.push("'" + key + "':" + val);
}</pre></div><p class="calibre8">The key is used to look up the binding handler to call its <code class="literal">preprocess</code> function. If it returns falsy, the processing stops, as the binding was removed. The <code class="literal">makeValueAccessors</code> property will be true when it comes from <code class="literal">getBindingAccessors</code> and false when it comes from <code class="literal">getBindings</code>. The result is then added to a running list.</p><p class="calibre8">The <code class="literal">twoWayBindings</code> block adds a special function string to <code class="literal">propertyAccessorResultStrings</code>, which is checked after all the other bindings keys are finished:</p><div><pre class="programlisting">if (propertyAccessorResultStrings.length)
  processKeyValue('_ko_property_writers', "{" + propertyAccessorResultStrings.join(",") + " }");</pre></div><p class="calibre8">This adds one extra binding property, <code class="literal">_ko_property_writers</code>, which is a function that will return a binding object that can be used to write to bound properties instead of reading from them. We will come back to this in just a minute.</p><p class="calibre8">Finally, the running list of strings is returned with a join:</p><div><pre class="programlisting">return resultStrings.join(",");</pre></div><p class="calibre8">The resulting string from the example binding will look like this:</p><div><pre class="programlisting">'value': function() { return name; }, 'visible': function() { return showName; '_ko_property_writers':function(){return {'value':function(_z){ name =_z} } } }</pre></div><p class="calibre8">The binding provider<a id="id702" class="calibre1"/> turns this string into a real object by putting the string inside a function body and calling the function with the binding context and the element being bound:</p><div><pre class="programlisting">var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),
  functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
  return new Function("$context", "$element", functionBody);</pre></div><div><h3 class="title2"><a id="note32" class="calibre1"/>Note</h3><p class="calibre8">This use of <code class="literal">new Function</code> causes Knockout's default binding provider to fail in environments using a <strong class="calibre9">Content Security Policy</strong> (<strong class="calibre9">CSP</strong>)<a id="id703" class="calibre1"/> that blocks <code class="literal">new Function</code> and <code class="literal">eval</code>, such as in Google Chrome Extensions. Knockout Secure Binding, which is a binding provider that does not use <code class="literal">new Function</code>, allows Knockout to be used with a CSP (see <a class="calibre1" href="https://github.com/brianmhunt/knockout-secure-binding">https://github.com/brianmhunt/knockout-secure-binding</a>).</p></div><p class="calibre8">When this function is evaluated with the binding context and element, it produces the final binding object:</p><div><pre class="programlisting">{
  value: function() { return name; },
  visible: function() { return showName; },
  _ko_property_writers: function (){
    return {'value':function(_z){query=_z} } 
  }
}</pre></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec128" class="calibre1"/>Knockout property writers</h2></div></div></div><p class="calibre8">We haven't<a id="id704" class="calibre1"/> covered the _<code class="literal">ko_property_writers</code> property yet, because<a id="id705" class="calibre1"/> it's surprising to most people and would have been distracting. The role of this property is to expose writing functions for nonobservable values so that two-way binding handlers can still update their values. They aren't observable, so notifications won't occur, but it's still a supported scenario.</p><p class="calibre8">This special binding is carried on the binding accessor. When two-way bindings, such as <code class="literal">value</code>, need to update the viewmodel they, call <code class="literal">ko.expressionRewriting.writeValueToProperty</code>: </p><div><pre class="programlisting">writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {
  if (!property || !ko.isObservable(property)) {
    var propWriters = allBindings.get('_ko_property_writers');
    if (propWriters &amp;&amp; propWriters[key])
    propWriters[key](value);
  } else if (ko.isWriteableObservable(property) &amp;&amp; (!checkIfDifferent || property.peek() !== value)) {
    property(value);
  }
}</pre></div><div><h3 class="title2"><a id="note33" class="calibre1"/>Note</h3><p class="calibre8">This is an undocumented part of the API, so it is subject to changing without notice.</p></div><p class="calibre8">If the <a id="id706" class="calibre1"/>property is not observable and a property<a id="id707" class="calibre1"/> writer exists for it, then it is used to update the value. If the property is observable, the property is written directly.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec71" class="calibre1"/>Applying bindings</h1></div></div></div><p class="calibre8">The binding application<a id="id708" class="calibre1"/> process takes place primarily in the <code class="literal">bindingAttributeSyntax</code> module, which defines the <code class="literal">ko.bindingContext</code> class as well as the <code class="literal">ko.applyBindings</code> method. The high-level overview looks like this:</p><div><ol class="orderedlist"><li class="listitem" value="1">The <code class="literal">ko.applyBindings</code> method is called with the viewmodel.</li><li class="listitem" value="2">A binding context is constructed using the viewmodel.</li><li class="listitem" value="3">The binding provider is retrieved from <code class="literal">ko.bindingProvider.instance</code>.</li><li class="listitem" value="4">Knockout works with the DOM tree:<div><ul class="itemizedlist1"><li class="listitem">It is passed through the binding provider's node preprocessor (except the root node)</li><li class="listitem">The binding handlers for the node are constructed using the binding provider</li><li class="listitem">The binding handlers are sorted by ensuring that any bindings in their <code class="literal">after</code> property are loaded first</li><li class="listitem">The binding handlers are iterated through, calling each handler's <code class="literal">init</code> and <code class="literal">update</code> function.</li></ul></div></li></ol><div></div><p class="calibre8">The first three steps are pretty straightforward; even the walking algorithm is just a simple recursion that applies bindings to a node and then iterates over its children to preprocess and bind them. The real meat of this process is the <code class="literal">applyBindingsToNodeInternal</code> function, which actually does the work of applying bindings to a node.</p><p class="calibre8">The first half of <a id="id709" class="calibre1"/>the function is safety checks. We are going to skip the code for this, as it's not very important to understanding how the binding part works. As we have already covered how the binding provider generates bindings, we are only going to look at the last two bullet points.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec129" class="calibre1"/>Sorting binding handlers</h2></div></div></div><p class="calibre8">Knockout uses a topological <a id="id710" class="calibre1"/>sort to order the binding handlers.</p><p class="calibre8">If you are unfamiliar with topological sorting, remember that it comes from graph theory. We will not go into the details of graph theory here (if you are interested, Google can tell you all about it), but a topological sort is basically an ordering of elements, which ensures that all dependencies of an element come before the element itself. Topological sorts do not guarantee the same order every time; it's just that no dependency cycles exist.</p><p class="calibre8">This is the sort function that Knockout uses to order binding handlers; it is a fairly common implementation:</p><div><pre class="programlisting">function topologicalSortBindings(bindings) {
  // Depth-first sort
  var result = [],                // The list of key/handler pairs that we will return
  bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'
  cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it
  ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {
    if (!bindingsConsidered[bindingKey]) {
      var binding = ko['getBindingHandler'](bindingKey);
      if (binding) {
        // First add dependencies (if any) of the current binding
        if (binding['after']) {
          cyclicDependencyStack.push(bindingKey);
          ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {
            if (bindings[bindingDependencyKey]) {
              if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {
                throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + cyclicDependencyStack.join(", "));
              } else {
                pushBinding(bindingDependencyKey);
              }
            }
          });
          cyclicDependencyStack.length--;
        }
        // Next add the current binding
        result.push({ key: bindingKey, handler: binding });
      }
      bindingsConsidered[bindingKey] = true;
    }
  });

  return result;
}</pre></div><p class="calibre8">This function<a id="id711" class="calibre1"/> loops through the supplied bindings, skipping bindings it has already processed; if it has an <code class="literal">after</code> property, it starts the dependency check. It pushes the current binding into the array-tracking dependencies, and then loops through each of the bindings in the <code class="literal">after</code> property. If a dependent binding is already found to be in the array of dependencies Knockout throws an exception, it would mean a cycling dependency. If the dependent binding is not found, it recurses into the loop handler so that its dependencies are checked.</p><p class="calibre8">After the dependent bindings are checked, the last element in the array of dependencies is removed and the current binding is pushed to the array of results and the array of already processed bindings. If a future binding requires it as a dependency, the loop handler will return immediately, indicating that the future binding is safe to continue.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec130" class="calibre1"/>Running the binding handlers</h2></div></div></div><p class="calibre8">After getting the <a id="id712" class="calibre1"/>binding handlers in the proper order, they are iterated through. One last safety check is made in order to ensure that if the node is a comment node, the binding handler is allowed for virtual elements. Then the <code class="literal">init</code> and <code class="literal">update</code> functions are called inside a <code class="literal">try</code>/<code class="literal">catch</code> block:</p><div><pre class="programlisting">// Run init, ignoring any dependencies
var handlerInitFn = bindingKeyAndHandler.handler["init"];
if (typeof handlerInitFn == "function") {
  ko.dependencyDetection.ignore(function() {
    var initResult = handlerInitFn(node, 
    getValueAccessor(bindingKey),
    allBindings,
    bindingContext['$data'],
    bindingContext);

    // If this binding handler claims to control descendant bindings, make a note of this
    if (initResult &amp;&amp; initResult['controlsDescendantBindings']) {
      if (bindingHandlerThatControlsDescendantBindings !== undefined)
      throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
      bindingHandlerThatControlsDescendantBindings = bindingKey;
    }
  });
}</pre></div><p class="calibre8">The whole thing is<a id="id713" class="calibre1"/> run in a scope with dependency detection disabled, as the <code class="literal">init</code> function does not run twice. The <code class="literal">init</code> handler passes all the required arguments, and the result is checked to see whether this handler wants to control descendant bindings. If it isn't the first handler to control descendant bindings, then Knockout throws an exception:</p><div><pre class="programlisting">// Run update in its own computed wrapper
var handlerUpdateFn = bindingKeyAndHandler.handler["update"];
if (typeof handlerUpdateFn == "function") {
  ko.dependentObservable(
    function() {
      handlerUpdateFn(node, 
      getValueAccessor(bindingKey), 
      allBindings, 
      bindingContext['$data'], 
      bindingContext);
    },
    null,
    { disposeWhenNodeIsRemoved: node }
  );
}</pre></div><p class="calibre8">The <code class="literal">update</code> handler is run inside of a computed observable (<code class="literal">dependantObservable</code> was the original name for computeds and is still used in the source code), which will automatically rerun it when dependencies change. This is one of my favorite parts of Knockout: binding handlers rerun automatically when observable dependencies change because <em class="calibre12">they are inside observables themselves</em>.</p><p class="calibre8">Once the binding <a id="id714" class="calibre1"/>handlers have all been looped through, <code class="literal">applyBindingsToNodeInternal</code> returns with an object that tells its caller whether or not to recurse into the current node's children using the flag from the <code class="literal">init</code> handler's result:</p><div><pre class="programlisting">return {
  'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined
};</pre></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec72" class="calibre1"/>Templates</h1></div></div></div><p class="calibre8">Knockout's template system<a id="id715" class="calibre1"/> is incredibly flexible: it works with <em class="calibre12">anonymous</em> templates, named templates, and allows the engine that renders templates to be overridden. The template binding is also used by the <code class="literal">foreach</code> binding, which is just a syntactic sugar for the <code class="literal">{ foreach: someExpression }</code> template. To understand how the template system works, let's start with the template-binding handler.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec131" class="calibre1"/>The template binding handler</h2></div></div></div><p class="calibre8">The <code class="literal">init</code> function of the<a id="id716" class="calibre1"/> template binding understands that templates can either be named (loaded from a source) or inline (loaded using the contents of the bound element):</p><div><pre class="programlisting">'init': function(element, valueAccessor) {
  // Support anonymous templates
  var bindingValue = ko.utils.unwrapObservable(valueAccessor());
  if (typeof bindingValue == "string" || bindingValue['name']) {
    // It's a named template - clear the element
    ko.virtualElements.emptyNode(element);
  } else {
    var templateNodes = ko.virtualElements.childNodes(element),
    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes);
    new ko.templateSources.anonymousTemplate(element)['nodes'](container);
  }
  return { 'controlsDescendantBindings': true };
}</pre></div><p class="calibre8">If the binding value is just a string, or if the binding value is an object with a <code class="literal">name</code> property, then we are using a named source and the only work that needs to be done is to empty the node. Named sources need to be changed when the name of the template changes, so all of the work of actually rendering the template is in the <code class="literal">update</code> method.</p><p class="calibre8">If it's an anonymous template, <code class="literal">moveCleanedNodesToContainerElement</code> removes the children from the element and places them in a <code class="literal">div</code> container, but the <code class="literal">div</code> container isn't placed in the DOM. A new anonymous template source is created with the element, and the <code class="literal">div</code> container is passed to the template's <code class="literal">nodes</code> function. The <code class="literal">nodes</code> function stores the container with <code class="literal">utils.domData</code>.</p><p class="calibre8">A <strong class="calibre9">template source</strong>
<a id="id717" class="calibre1"/>is an <a id="id718" class="calibre1"/>object that is used by the template engine to provide the DOM that is required to render the template. It must provide either a <code class="literal">nodes</code> function that returns a container with the nodes to be used, or a text function that provides a stringified version of the same. The <code class="literal">ko.templateSources</code> array contains two template source types: <code class="literal">domElement</code> for named sources and <code class="literal">anonymousTemplate</code> for inline sources.</p><p class="calibre8">Finally, the <code class="literal">init</code> function returns <code class="literal">{ 'controlsDescendantBindings': true }</code>.</p><p class="calibre8">The <code class="literal">update</code> function has three different branches: branches that render a single template, branches that render an array of templates with <code class="literal">foreach</code>, and branches that remove everything if an <code class="literal">if</code> (or <code class="literal">ifnot</code>) binding is present and false. The last branch doesn't need much explanation, and the first two branches are very functionally similar: they call <code class="literal">renderTemplate</code> on the template engine, which returns an array of DOM nodes that are then added to the DOM. After this, they each call <code class="literal">applyBindings</code> on the template.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec132" class="calibre1"/>The template engine</h2></div></div></div><p class="calibre8">The <a id="id719" class="calibre1"/>template engine is responsible for generating DOM nodes. It can't be used on its own though, as it's just a base class. When <code class="literal">renderTemplate</code> is called on the base template engine, it calls <code class="literal">makeTemplateSource</code> and passes the result to <code class="literal">renderTemplateSource</code>.</p><p class="calibre8">The default <code class="literal">makeTemplateSource</code> method takes a template parameter. If a template is a string, it will try to find a script by that name and create a <code class="literal">domElement</code> source. If the template is a node, it will create and return a new <code class="literal">anonymousTemplate</code> source from it.</p><p class="calibre8">The default <code class="literal">renderTemplateSource</code> method is not implemented and will throw an error. A template implementation must override this method in order to work.</p><p class="calibre8">Knockout provides two template engine implementations out of the box: native and jQuery.tmpl. The jQuery.tmpl engine hasn't been under development since 2011, and I think Knockout's continued inclusion with the standard distribution is probably more backwards-compatibility than anyone really needs. It's there, but we are going to ignore it.</p><p class="calibre8">The native template engine overrides <code class="literal">renderTemplateSource</code> with this:</p><div><pre class="programlisting">function (templateSource, bindingContext, options) {
  // IE&lt;9 cloneNode doesn't work properly
  var useNodesIfAvailable = !(ko.utils.ieVersion &lt; 9),
  templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
  templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

  if (templateNodes) {
    return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
  } else {
    var templateText = templateSource['text']();
    return ko.utils.parseHtmlFragment(templateText);
  }
};</pre></div><p class="calibre8">If <code class="literal">nodes</code> is <a id="id720" class="calibre1"/>present, it will be used to get the template node container, clone it, and return it. If it's in an higher IE, where clone doesn't work, or if <code class="literal">nodes</code> isn't provided, the text source will be parsed by <code class="literal">ko.utils</code> and will be returned.</p><p class="calibre8">The template engine does not add the nodes to the DOM and does not bind them; it just returns them. The template binding takes care of this part after it gets the generated template from the template engine.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec73" class="calibre1"/>The ko.utils reference</h1></div></div></div><p class="calibre8">The <code class="literal">ko.utils</code> namespace<a id="id721" class="calibre1"/> is Knockout's bucket for utility functions. Not all of these functions are publicly exposed—at least not in a usable way. Knockout's minification process obfuscates more than half of them. As the unobfuscated methods are a public API that Knockout has committed to providing, changing them would be a major change. Despite considering all of the exposed methods on the <code class="literal">ko.utils</code> part of the API, Knockout does not provide any documentation for them.</p><p class="calibre8">Here is a complete list of the<a id="id722" class="calibre1"/> public functions on <code class="literal">ko.utils</code> as of Knockout 3.2:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">addOrRemoveItem(array, item, included)</code>: If <code class="literal">included</code> is <code class="literal">true</code>, it will add the <a id="id723" class="calibre1"/>item to the array if it is not already there; if <code class="literal">included</code> is <code class="literal">false</code>, it will remove the item from the array if it is present.</li><li class="listitem"><code class="literal">arrayFilter(array, predicate)</code>: This <a id="id724" class="calibre1"/>returns an array of elements from the array that returns <code class="literal">true</code> from the predicate using <code class="literal">predicate(element, index)</code>.</li><li class="listitem"><code class="literal">arrayFirst(array, predicate, predicateOwner)</code>: This returns the first element in the array<a id="id725" class="calibre1"/> that returns <code class="literal">true</code> from the predicate using <code class="literal">predicate.call(predicateOwner, element, index)</code>. This makes <code class="literal">predicateOwner</code> an optional parameter, which controls this in the predicate.</li><li class="listitem"><code class="literal">arrayForEach(array, action)</code>: This <a id="id726" class="calibre1"/>calls the action on each element in the array with <code class="literal">action(element, index)</code>.</li><li class="listitem"><code class="literal">arrayGetDistinctValues(array)</code>: This<a id="id727" class="calibre1"/> returns an array with only distinct elements from the original array. It uses <code class="literal">ko.utils.arrayIndexOf</code> to determine the uniqueness.</li><li class="listitem"><code class="literal">arrayIndexOf(array, item)</code>: If <code class="literal">Array.prototype.indexOf</code> is present, <code class="literal">arrayIndexOf(array, item)</code> will<a id="id728" class="calibre1"/> call it, otherwise it will loop the array manually and return the index or <code class="literal">-1</code> if the element isn't found. This is a polyfill for versions of Internet Explorer less than 9.</li><li class="listitem"><code class="literal">arrayMap(array, mapping)</code>: This is not <a id="id729" class="calibre1"/>quite a polyfill for <code class="literal">Array.prototype.map</code>; this<a id="id730" class="calibre1"/> function returns an array by calling <code class="literal">mapping(element, index)</code> on each element of the original array.</li><li class="listitem"><code class="literal">arrayPushAll(array, valuesToPush)</code>: This pushes the <code class="literal">valuesToPush</code> parameter into the <code class="literal">array</code> parameter. This function <a id="id731" class="calibre1"/>handles cases where <code class="literal">valuesToPush</code> is like an array but is not a real array, such as <code class="literal">HTMLCollection</code>, where calling <code class="literal">array.push.apply(array, valuesToPush</code>) would normally fail.</li><li class="listitem"><code class="literal">arrayRemoveItem(array, itemToRemove)</code>: This removes the item from the array by either<a id="id732" class="calibre1"/> splicing or shifting, depending on the item's index.</li><li class="listitem"><code class="literal">domData</code>: This <a id="id733" class="calibre1"/>object provides a <code class="literal">get</code>, <code class="literal">set</code>, and <code class="literal">clear</code> method in order to work with arbitrary key/value pairs on DOM nodes. Knockout uses it internally to track the binding information, but it can be used to store anything.</li><li class="listitem"><code class="literal">domNodeDisposal</code>: This<a id="id734" class="calibre1"/> object provides the <a id="id735" class="calibre1"/>following  utilities that are related to DOM's cleanup tasks:<div><ul class="itemizedlist1"><li class="listitem"><code class="literal">addDisposeCallback(node, callback)</code>: This adds a callback to the node <a id="id736" class="calibre1"/>with <code class="literal">domData</code>. The callback will be used if Knockout removes the node via templating or control flow.</li><li class="listitem"><code class="literal">cleanNode(node)</code>: This <a id="id737" class="calibre1"/>runs all the associated disposal callbacks that were registered with <code class="literal">addDisposeCallback</code>. This function is aliased as <code class="literal">ko.cleanNode</code>.</li><li class="listitem"><code class="literal">cleanExternalData(node)</code>: This uses jQuery's <code class="literal">cleanData</code> function to remove data<a id="id738" class="calibre1"/> added by jQuery plugins. It does nothing if jQuery is not found.</li><li class="listitem"><code class="literal">removeDisposeCallback(node, callback)</code>: This removes the callback from the<a id="id739" class="calibre1"/> node's <code class="literal">domData</code> function.</li><li class="listitem"><code class="literal">removeNode(node)</code>: This <a id="id740" class="calibre1"/>cleans the node with <code class="literal">cleanNode</code> and then removes it from the DOM. This function is aliased as <code class="literal">ko.removeNode</code>.</li></ul></div></li><li class="listitem"><code class="literal">Extend(target, source)</code>: This is <a id="id741" class="calibre1"/>a run-of-the-mill extend method; it adds or overwrites all properties on<a id="id742" class="calibre1"/> the target with those on the source. It filters source properties with <code class="literal">hasOwnProperty</code>.</li><li class="listitem"><code class="literal">fieldsIncludedWithJsonPost</code>: This is an array of default fields that are used for <code class="literal">postJson</code> if <a id="id743" class="calibre1"/>an <code class="literal">includeFields</code> option is not specified.</li><li class="listitem"><code class="literal">getFormFields(form, fieldName)</code>: This returns all the <code class="literal">input</code> or <code class="literal">textarea</code> fields <a id="id744" class="calibre1"/>from a form that matches <code class="literal">fieldname</code>, which can be either a string, a regex, or an object with a test predicate that takes the field's name.</li><li class="listitem"><code class="literal">objectForEach(obj, action)</code>: This calls <code class="literal">action(properyName, propetyValue)</code> on <a id="id745" class="calibre1"/>each property in <code class="literal">obj</code>, filtering it with <code class="literal">hasOwnProperty</code>.</li><li class="listitem"><code class="literal">parseHtmlFragment(html)</code>: If jQuery is<a id="id746" class="calibre1"/> present, this function uses its <code class="literal">parseHTML</code> function; otherwise, it uses a simple internal HTML parse. It returns DOM nodes.</li><li class="listitem"><code class="literal">parseJson(jsonString)</code>: This will return a JavaScript object by parsing the supplied string. If the JSON object <a id="id747" class="calibre1"/>exists, it will be used; otherwise, <code class="literal">new Function</code> will be used.</li><li class="listitem"><code class="literal">peekObservable(value)</code>: Just like <code class="literal">ko.unwrap</code>, this is a safety method. If the value is observable, it <a id="id748" class="calibre1"/>will return the result of its peek; otherwise, it will just return the value.</li><li class="listitem"><code class="literal">postJson(urlOrForm, data, options)</code>: This will perform a post by creating a new<a id="id749" class="calibre1"/> form, appending it to the DOM, and calling <code class="literal">submit</code> on it. The form will use <code class="literal">data</code> to create its fields. If <code class="literal">urlOrForm</code> is a form, its fields will be included in the data if they match <code class="literal">options[''includeFields'']</code> (or <code class="literal">fieldsIncludedWithJsonPost</code> if <code class="literal">options[''includeFields'']</code> isn't present), and its action will be used as the URL.</li><li class="listitem"><code class="literal">Range(min, max)</code>: This <a id="id750" class="calibre1"/>returns an array<a id="id751" class="calibre1"/> of values between <code class="literal">min</code> and <code class="literal">max</code>. It uses <code class="literal">ko.unwrap</code> on both the arguments.</li><li class="listitem"><code class="literal">registerEventHandler(element, eventType, handler)</code>: This attaches an event handler<a id="id752" class="calibre1"/> to the element. It uses jQuery if possible, <code class="literal">addEventListener</code> if available or <code class="literal">attachEvent</code> as a last resort (Internet Explorer). If using <code class="literal">attachEvent</code>, it registers a disposal handler to call <code class="literal">detachEvent</code>, as IE does not do so automatically.</li><li class="listitem"><code class="literal">setHtml(node, html)</code>: This <a id="id753" class="calibre1"/>empties the node's contents, unwraps the HTML, and sets the node's HTML using either <code class="literal">jQuery.html</code>, if available, or <code class="literal">parseHtmlFragement</code>.</li><li class="listitem"><code class="literal">stringifyJson(data, replacer, space)</code>: This uses <code class="literal">ko.unwrap</code> to handle observable data <a id="id754" class="calibre1"/>and calls <code class="literal">JSON.stringify</code>. The <code class="literal">replacer</code> and <code class="literal">space</code> parameters are optional. If the JSON object is not present, it throws an exception.</li><li class="listitem"><code class="literal">toggleDomNodeCssClass(node, classNames, shouldHaveClass)</code>: This uses <a id="id755" class="calibre1"/>the <code class="literal">shouldHaveClass</code> Boolean to either add or remove all of <code class="literal">classNames</code> Boolean from the node.</li><li class="listitem"><code class="literal">triggerEvent(element, eventType)</code>: This triggers the event on the element. It uses jQuery <a id="id756" class="calibre1"/>when applicable and handles known issues with raising the click event in IE and in jQuery.</li><li class="listitem"><code class="literal">unwrapObservable(value)</code>: This <a id="id757" class="calibre1"/>was the original name of <code class="literal">ko.unwrap</code> and is maintained for <a id="id758" class="calibre1"/>backward compatibility. It will either return the underlying value of an observable or the value itself if it's not an observable.</li></ul></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec74" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">While this certainly isn't an exhaustive look at the guts of Knockout, which you probably wouldn't want anyway, you should at least have a good understanding of how Knockout gets most of the important things done. This chapter covered dependency tracking, the <em class="calibre12">prototype</em> (<code class="literal">fn</code>) chain, the binding expression parser, how <code class="literal">ko.applyBindings</code> works, how Knockout handles templates, and the <code class="literal">ko.utils</code> namespace. Hopefully, you will feel comfortable with how each of these systems work internally. Knowing how these pieces fit together should help you in troubleshooting those really tricky bugs.</p></div></body></html>