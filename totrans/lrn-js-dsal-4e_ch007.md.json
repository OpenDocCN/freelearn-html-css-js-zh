["```js\nclass LinkedListNode {\n  constructor(data, next = null) {\n    this.data = data;\n    this.next = next;\n  }\n}\n```", "```js\nclass LinkedList {\n  #head;\n  #size = 0;\n  // other methods\n} \n```", "```js\nappend(data) {\n  const newNode = new LinkedListNode(data);\n  if (!this.#head) {\n    this.#head = newNode;\n  } else {\n    let current = this.#head;\n    while (current.next !== null) {\n      current = current.next;\n    }\n    current.next = newNode;\n  }\n  this.#size++;\n}\n```", "```js\nprepend(data) {\n  const newNode = new LinkedListNode(data, this.#head);\n  this.#head = newNode;\n  this.#size++;\n}\n```", "```js\ninsert(data, position) {\n  if (this.#isInvalidPosition(position)) {\n    return false;\n  }\n  const newNode = new LinkedListNode(data);\n  if (position === 0) {\n    this.prepend(data);\n    return true;\n  }\n  let current = this.#head;\n  let previous = null;\n  let index = 0;\n\n  while (index++ < position) {\n    previous = current;\n    current = current.next;\n  }\n\n  newNode.next = current;\n  previous.next = newNode;\n  this.#size++;\n  return true;\n}\n```", "```js\n#isInvalidPosition(position) {\n  return position < 0 || position >= this.size;\n}\n```", "```js\nindexOf(data, compareFunction = (a, b) => a === b) {\n  let current = this.#head;\n  let index = 0;\n  while (current) {\n    if (compareFunction(current.data, data)) {\n      return index;\n    }\n    index++;\n    current = current.next;\n  }\n  return -1;\n}\n```", "```js\n removeAt(position) {\n    if (this.#size === 0) {\n      throw new RangeError('Cannot remove from an empty list.');\n    }\n    if (this.#isInvalidPosition(position)) {\n      throw new RangeError('Invalid position');\n    }\n    if (position === 0) {\n      return this.#removeFromHead();\n    }\n    return this.#removeFromMiddleOrEnd(position);\n  }\n```", "```js\n#removeFromHead() {\n  const nodeToRemove = this.#head;\n  this.#head = this.#head.next;\n  this.#size--;\n  return nodeToRemove.data;\n}\n```", "```js\n#removeFromMiddleOrEnd(position) {\n  let nodeToRemove = this.#head;\n  let previous;\n  for (let index = 0; index < position; index++) {\n    previous = nodeToRemove;\n    nodeToRemove = nodeToRemove.next;\n  }\n  // unlink the node to be removed\n  previous.next = nodeToRemove.next;\n  this.#size--;\n  return nodeToRemove.data;\n}\n```", "```js\nremove(data, compareFunction = (a, b) => a === b) {\n  const index = this.indexOf(data, compareFunction);\n  if (index === -1) {\n    return null;\n  }\n  return this.removeAt(index);\n}\n```", "```js\nisEmpty() {\n  return this.#size === 0;\n}\nget size() {\n  return this.#size;\n}\nclear() {\n  this.#head = null;\n  this.#size = 0;\n}\n```", "```js\ntoString() {\n  let current = this.#head;\n  let objString = '';\n  while (current) {\n    objString += this.#elementToString(current.data);\n    current = current.next;\n    if (current) {\n      objString += ', ';\n    }\n  }\n  return objString;\n}\n```", "```js\nclass DoublyLinkedListNode {\n  constructor(data, next = null, previous = null) {\n    this.data = data;\n    this.next = next;\n    this.previous = previous; // new\n  } \n}\n```", "```js\nclass DoublyLinkedList {\n  #head;\n  #tail; // new\n  #size = 0;\n  // other methods\n} \n```", "```js\nappend(data) {\n  const newNode = new DoublyLinkedListNode(data);\n  if (!this.#head) { // empty list\n    this.#head = newNode;\n    this.#tail = newNode;\n  } else { // non-empty list\n    newNode.previous = this.tail;\n    this.#tail.next = newNode;\n    this.#tail = newNode;\n  }\n  this.#size++;\n}\n```", "```js\nprepend(data) {\n  const newNode = new DoublyLinkedListNode(data);\n  if (!this.#head) {  // empty list\n    this.#head = newNode;\n    this.#tail = newNode;\n  } else { // non-empty list\n    newNode.next = this.#head;\n    this.#head.previous = newNode;\n    this.#head = newNode;\n  }\n  this.#size++;\n}\n```", "```js\ninsert(data, position) {\n  if (this.isInvalidPosition(position)) {\n    return false;\n  }\n  if (position === 0) { // first position\n    this.prepend(data);\n    return true;\n  }\n  if (position === this.#size) { // last position\n    this.append(data);\n    return true;\n  }\n  // middle position\n  return this.#insertInTheMiddle(data, position);\n}\n```", "```js\n#insertInTheMiddle(data, position) {\n  const newNode = new DoublyLinkedListNode(data);\n  let currentNode = this.#head;\n  let previousNode;\n  for (let index = 0; index < position; index++) {\n    previousNode = currentNode;\n    currentNode = currentNode.next;\n  }\n  newNode.next = currentNode;\n  newNode.previous = previousNode;\n  currentNode.previous = newNode;\n  previousNode.next = newNode;\n  this.#size++;\n  return true;\n}\n```", "```js\nremoveAt(position) {\n  if (this.#size === 0) {\n    throw new RangeError('Cannot remove from an empty list.');\n  }\n  if (this.#isInvalidPosition(position)) {\n    throw new RangeError('Invalid position.');\n  }\n  if (position === 0) {\n    return this.#removeFromHead();\n  }\n  if (position === this.#size - 1) {\n    return this.#removeFromTail();\n  }\n  return this.#removeFromMiddle(position);\n}\n```", "```js\n#removeFromHead() {\n  const nodeToRemove = this.#head;\n  this.#head = nodeToRemove.next;\n  if (this.#head) {\n    this.#head.previous = null;\n  } else {\n    this.#tail = null; // List becomes empty\n  }\n  this.#size--;\n  nodeToRemove.next = null;\n  return nodeToRemove.data;\n}\n```", "```js\n#removeFromTail() {\n  const nodeToRemove = this.#tail;\n  this.#tail = nodeToRemove.previous;\n  if (this.#tail) {\n    this.#tail.next = null;\n  } else {\n    this.#head = null; // List becomes empty\n  }\n  this.#size--;\n  nodeToRemove.previous = null;\n  return nodeToRemove.data;\n}\n```", "```js\n #removeFromMiddle(position) {\n    let nodeToRemove = this.#head;\n    let previousNode;\n    for (let index = 0; index < position; index++) {\n      previousNode = nodeToRemove;\n      nodeToRemove = nodeToRemove.next;\n    }\n\n    previousNode.next = nodeToRemove.next;\n    nodeToRemove.next.previous = previousNode;\n    nodeToRemove.next = null;\n    nodeToRemove.previous = null;\n    this.#size--;\n    return nodeToRemove.data;\n  }\n```", "```js\nclass CircularLinkedList {\n  #head;\n  #size = 0;\n  // other methods\n}\n```", "```js\n append(data) {\n    const newNode = new LinkedListNode(data);\n    if (!this.#head) { // empty list                             \n      this.#head = newNode;\n      newNode.next = this.#head; // points to itself\n    } else { // non-empty list\n      let current = this.#head;\n      while (current.next !== this.#head) {\n        current = current.next;\n      }\n      current.next = newNode;\n      newNode.next = this.#head; // circular reference\n    }\n    this.#size++;\n  }\n```", "```js\nprepend(data) {\n  const newNode = new LinkedListNode(data, this.#head);\n  if (!this.head) {\n    this.head = newNode;\n    newNode.next = this.head; // make it circular\n  } else {\n    // Find the last node\n    let current = this.head;\n    while (current.next !== this.head) {\n      current = current.next;\n    }\n    current.next = newNode;\n    this.head = newNode;\n  }\n  this.#size++;\n}\n```", "```js\n #removeFromHead() {\n    const nodeToRemove = this.#head;\n    let lastNode = this.#head;\n    while (lastNode.next !== this.#head) { // Find the last node\n      lastNode = lastNode.next;\n    }\n    this.#head = nodeToRemove.next; // skip the head\n    lastNode.next = this.#head;  // make it circular\n\n    if (this.#size === 1) {  // only one node\n      this.#head = null;\n    }\n    this.#size--;               \n    return nodeToRemove.data;\n  }\n```", "```js\n#removeFromTail() {\n  if (this.#head.next === this.#head) { // single node case\n    const nodeToRemove = this.#head;\n    this.#head = null;\n    this.#size--;\n    return nodeToRemove.data;\n  } else {\n    let lastNode = this.#head;\n    let previousNode = null;\n    while (lastNode.next !== this.#head) { // Find the last node\n      previousNode = lastNode;\n      lastNode = lastNode.next;\n    }\n    previousNode.next = this.#head; // skip the last node to remove it\n    this.#size--;                 \n    return lastNode.data;         \n  }\n}\n```", "```js\nclass MediaPlayerSong {\n  constructor(songTitle) {\n    this.songTitle = songTitle;\n    this.previous = null;\n    this.next = null;\n  }\n}\n```", "```js\nclass MediaPlayer {\n  #firstSong;\n  #lastSong;\n  #size = 0;\n  #playingSong;\n  // other methods\n} \n```", "```js\naddSongByTitle(newSongTitle) {\n  const newSong = new MediaPlayerSong(newSongTitle);\n  if (this.#size === 0) { // empty list\n    this.#insertEmptyPlayList(newSong);\n  } else {\n    const position = this.#findIndexOfSortedSong(newSongTitle);\n    if (position === 0) { // insert at the beginning\n      this.#insertAtBeginning(newSong);\n    } else if (position === this.#size) { // insert at the end\n      this.#insertAtEnd(newSong);\n    } else { // insert in the middle\n      this.#insertInMiddle(newSong, position);\n    }\n  }\n  this.#size++;\n}\n```", "```js\n#insertEmptyPlayList(newSong) {\n  this.#firstSong = newSong;\n  this.#lastSong = newSong;\n  newSong.next = newSong; // points to itself\n  newSong.previous = newSong; // points to itself\n}\n```", "```js\n#findIndexOfSortedSong(newSongTitle) {\n  let currentSong = this.#firstSong;\n  let i = 0;\n  for (; i < this.#size && currentSong; i++) {\n    const currentSongTitle = currentSong.songTitle;\n    if (this.#compareSongs(currentSongTitle, newSongTitle) >= 0) {\n      return i;\n    }\n    currentSong = currentSong.next;\n  }\n  return 0;\n}\n```", "```js\n#compareSongs(songTitle1, songTitle2) {\n  return songTitle1.localeCompare(songTitle2);\n}\n```", "```js\n#insertAtBeginning(newSong) {\n  newSong.next = this.#firstSong;\n  newSong.previous = this.#lastSong;\n  this.#firstSong.previous = newSong;\n  this.#lastSong.next = newSong;\n  this.#firstSong = newSong;\n}\n```", "```js\n#insertAtEnd(newSong) {\n  newSong.next = this.#firstSong;\n  newSong.previous = this.#lastSong;\n  this.#lastSong.next = newSong;\n  this.#firstSong.previous = newSong;\n  this.#lastSong = newSong;\n}\n```", "```js\n#insertInMiddle(newSong, position) {\n  let currentSong = this.#firstSong;\n  for (let i = 0; i < position - 1; i++) {\n    currentSong = currentSong.next;\n  }\n  newSong.next = currentSong.next;\n  newSong.previous = currentSong;\n  currentSong.next.previous = newSong;\n  currentSong.next = newSong;\n}\n```", "```js\nplay() {\n  if (this.#size === 0) {\n    return null;\n  }\n  this.#playingSong = this.#firstSong;\n  return this.#playingSong.songTitle;\n}\n```", "```js\nnext() {\n  if (this.#size === 0) {\n    return null;\n  }\n  if (!this.#playingSong) {\n    return this.play();\n  }\n  this.#playingSong = this.#playingSong.next;\n  return this.#playingSong.songTitle;\n}\n```", "```js\nprevious() {\n  if (this.#size === 0) {\n    return null;\n  }\n  if (!this.#playingSong) {\n    return this.play();\n  }\n  this.#playingSong = this.#playingSong.previous;\n  return this.#playingSong.songTitle;\n}\n```", "```js\nconst mediaPlayer = new MediaPlayer();\nmediaPlayer.addSongByTitle('The Bard\\'s Song');\nmediaPlayer.addSongByTitle('Florida!!!');\nmediaPlayer.addSongByTitle('Run to the Hills');\nmediaPlayer.addSongByTitle('Nothing Else Matters');\n```", "```js\nconsole.log('Playing:', mediaPlayer.play()); // Florida!!!\n```", "```js\nconsole.log('Next:', mediaPlayer.next()); // Nothing Else Matters\nconsole.log('Next:', mediaPlayer.next()); // Run to the Hills\nconsole.log('Next:', mediaPlayer.next()); // The Bard's Song\nconsole.log('Next:', mediaPlayer.next()); // Florida!!!\n```", "```js\nconsole.log('Previous:', mediaPlayer.previous()); // The Bard's Song\nconsole.log('Previous:', mediaPlayer.previous()); // Run to the Hills\nconsole.log('Previous:', mediaPlayer.previous()); // Nothing Else Matters\nconsole.log('Previous:', mediaPlayer.previous()); // Florida!!!\n```", "```js\nfunction reverseList(head: ListNode | null): ListNode | null {\n  let current = head;\n  let newHead = null;\n  let nextNode = null;\n  while (current) {\n    nextNode = current.next;\n    current.next = newHead;\n    newHead = current;\n    current = nextNode;\n  }\n  return newHead;\n}\n```"]