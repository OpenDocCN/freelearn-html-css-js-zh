<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Building a World</h1></div></div></div><p>This chapter explains the components of a Three.js scene in detail, including the different kinds of renderers, geometries, materials, and lighting. We will also build a procedurally generated city.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Geometries</h1></div></div></div><p>Geometries <a class="indexterm" id="id66"/>are instances of <code class="literal">THREE.Geometry</code> <a class="indexterm" id="id67"/>that define the shape of an object in a scene. They are made up of vertices<a class="indexterm" id="id68"/> and faces (which are themselves objects and are accessible through the <code class="literal">vertices</code> <a class="indexterm" id="id69"/>and <code class="literal">faces</code> <a class="indexterm" id="id70"/>array properties). Vertices are the <code class="literal">THREE.Vector3</code> objects representing points in three-dimensional space, while faces are the <code class="literal">THREE.Face3</code> objects representing triangular surfaces. (All more complex shapes are subdivided into triangular faces for rendering purposes.)</p><p>Luckily, dealing with vertices and faces directly is usually unnecessary because <code class="literal">THREE.Geometry</code> has many subclasses that help create commonly used shapes.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec07"/>3D primitives</h2></div></div></div><p>Three.js provides a<a class="indexterm" id="id71"/> number of classes that generate common shapes. <a class="indexterm" id="id72"/>The official documentation for each type is available <a class="indexterm" id="id73"/>at <a class="ulink" href="http://threejs.org/docs/">http://threejs.org/docs/</a>, but a summary of common types is shown in the following table (some obscure, optional constructor parameters were omitted):</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Constructor</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Cube</p>
<div><img alt="3D primitives" src="img/8539_02_01.jpg"/></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.CubeGeometry(width, height, depth, widthSegments = 1, heightSegments = 1,
depthSegments = 1)</pre></div></td><td style="text-align: left" valign="top">
<p>It is a <a class="indexterm" id="id74"/>rectangular<a class="indexterm" id="id75"/> box with the specified dimensions. The <code class="literal">segments</code> parameters<a class="indexterm" id="id76"/> split the sides into smaller rectangles.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Sphere</p>
<div><img alt="3D primitives" src="img/8539_02_02.jpg"/></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.Sphere(radius, horizontalSegments = 8, verticalSegments = 6)</pre></div></td><td style="text-align: left" valign="top">
<p>It is a<a class="indexterm" id="id77"/> sphere<a class="indexterm" id="id78"/> approximation created by calculating segments.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Polyhedra (spheroids)</p>
<div><img alt="3D primitives" src="img/8539_02_03.jpg"/></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.Icosahedron(radius, detail = 0); 
THREE.Octahedron(radius, detail = 0);
THREE.Tetrahedron(radius, detail = 0);</pre></div></td><td style="text-align: left" valign="top">
<p>It is a sphere<a class="indexterm" id="id79"/> approximation based on shapes<a class="indexterm" id="id80"/> with 20, 8, or 4 sides, respectively; the <code class="literal">detail</code> parameter<a class="indexterm" id="id81"/> specifies how many times to split each edge to make more faces, making the shape more spherical.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Cylinder</p>
<div><img alt="3D primitives" src="img/8539_02_04.jpg"/></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.CylinderGeometry(radiusTop, radiusBottom, height, radiusSegments = 8, heightSegments = 1, openEnded = false)</pre></div></td><td style="text-align: left" valign="top">
<p><code class="literal">radiusSegments</code> is<a class="indexterm" id="id82"/> the number of edges connecting the top and bottom<a class="indexterm" id="id83"/> faces, down the curved surface; <code class="literal">heightSegments</code> <a class="indexterm" id="id84"/>is the number <a class="indexterm" id="id85"/>of rings of faces around the curved surface, and if <code class="literal">openEnded</code> <a class="indexterm" id="id86"/>is <code class="literal">true</code>, the ends of the cylinder will not be rendered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Torus</p>
<div><img alt="3D primitives" src="img/8539_02_05.jpg"/></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.TorusGeometry(radius, tubeWidth = 40, radialSegments = 8, tubularSegments = 6)</pre></div></td><td style="text-align: left" valign="top">
<p>It is<a class="indexterm" id="id87"/> a<a class="indexterm" id="id88"/> donut shape.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>TorusKnot</p>
<div><img alt="3D primitives" src="img/8539_02_06.jpg"/></div>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.TorusKnotGeometry(radius, tubeWidth = 40, radialSegments, tubularSegments, p = 2, q = 3, heightScale = 1)</pre></div></td><td style="text-align: left" valign="top">
<p>It is a<a class="indexterm" id="id89"/> knot<a class="indexterm" id="id90"/> shape, sort of like a pretzel. <code class="literal">p</code> and <code class="literal">q</code> are integers that affect how many twists are in the knot.</p>
</td></tr></tbody></table></div><p>You can try changing the spinning icosahedron<a class="indexterm" id="id91"/> example we built in the last chapter to use different geometries by changing the <code class="literal">IcosahedronGeometry</code> constructor<a class="indexterm" id="id92"/> to one of the options in the preceding table. There is also a geometry viewer at <a class="ulink" href="http://threejsplaygnd.brangerbriz.net/gui/">http://threejsplaygnd.brangerbriz.net/gui/</a> that allows you to tweak the<a class="indexterm" id="id93"/> constructor parameters to see the result and also copy the code required to generate the shape you're viewing.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec08"/>2D primitives</h2></div></div></div><p>Three.js also has default<a class="indexterm" id="id94"/> geometry for 2D shapes as shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Constructor</p>
</th><th style="text-align: left" valign="bottom">
<p>Explanation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Plane</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.PlaneGeometry(width, height, widthSegments = 1, heightSegments = 1)</pre></div></td><td style="text-align: left" valign="top">
<p>It is a<a class="indexterm" id="id95"/> rectangle with the <a class="indexterm" id="id96"/>specified dimensions. The <code class="literal">segments</code> parameters<a class="indexterm" id="id97"/> subdivide the plane into smaller rectangles.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Circle</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.CircleGeometry(radius, numberOfSides = 8)</pre></div></td><td style="text-align: left" valign="top">
<p>It is<a class="indexterm" id="id98"/> a<a class="indexterm" id="id99"/> regular polygon.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Ring</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.RingGeometry(innerRadius, outerRadius, radialSegments = 8, ringSegments = 8)</pre></div></td><td style="text-align: left" valign="top">
<p>It is a<a class="indexterm" id="id100"/> circle <a class="indexterm" id="id101"/>with a hole in the middle.</p>
</td></tr></tbody></table></div><p>These shapes are created along the x and y axes by default.</p><p>Additionally, Three.js can create lines. Almost all objects you would normally place in a scene will be meshes, but lines are exceptions. Consider code like the following, which creates a mesh:</p><div><pre class="programlisting">geometry = new THREE.IcosahedronGeometry(200, 2);
material = new THREE.MeshBasicMaterial({color: 0x000000});
mesh = new THREE.Mesh(geometry, material);</pre></div><p>Instead of using the preceding code, you could use the code as shown in the following snippet to create a line:</p><div><pre class="programlisting">geometry = new THREE.IcosahedronGeometry(200, 2);
material = new THREE.LineBasicMaterial({color: 0x000000});
mesh = new THREE.Line(geometry, material);</pre></div><p>This can create some strange results for<a class="indexterm" id="id102"/> standard geometry such as <code class="literal">IcosahedronGeometry</code> because lines will be drawn connecting points in an unexpected order. Instead, you will usually want to create a custom geometry so that you can add vertices in <a class="indexterm" id="id103"/>your desired order.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Use <code class="literal">LineDashedMaterial</code> instead of <code class="literal">LineBasicMaterial</code> to make a dotted line.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec09"/>Custom geometries</h2></div></div></div><p>Several default geometry<a class="indexterm" id="id104"/> types allow creating shapes based on<a class="indexterm" id="id105"/> vertices or paths specifically created by the developer. (You can also import geometry created in external programs, a topic covered in <a class="link" href="ch04.html" title="Chapter 4. Adding Detail">Chapter 4</a>, <em>Adding Detail</em>.) The most basic type is the <code class="literal">THREE.Geometry</code> class<a class="indexterm" id="id106"/> itself. For example, you can create a triangle using the code shown in the following snippet:</p><div><pre class="programlisting">var geo = new THREE.Geometry();
geo.vertices = [
  new THREE.Vector3(0, 0, 0),
  new THREE.Vector3(0, 100, 0),
  new THREE.Vector3(0, 0, 100)
];
geo.faces.push(new THREE.Face3(0, 1, 2));
geo.computeBoundingSphere();</pre></div><p>First, this code creates a geometry object that has no vertices or faces yet. Then, it adds specific vertices, where each vertex is represented by a <code class="literal">THREE.Vector3</code> that holds spatial coordinates on the x, y, and z axes. Next, a <code class="literal">THREE.Face3</code> is added into the <code class="literal">faces</code> array. The <code class="literal">Face3</code> constructor's parameters indicate the indices of vertices in the geometry's <code class="literal">vertices</code> array to use for the face's corners. Finally, the bounding sphere is computed, which triggers internal calculations for properties Three.js needs to track such as whether the shape is in view. <a class="indexterm" id="id107"/>If you have trouble getting a texture to display correctly on your custom material, you may also need to call <code class="literal">geo.computeFaceNormals()</code> and <code class="literal">geo.computeVertexNormals()</code>. These functions calculate additional information about the geometry's visual layout.</p><p>Manually creating shapes out of individual<a class="indexterm" id="id108"/> vertices can quickly get tiring; however, some utilities exist to help make the process faster as introduced in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Geometry</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">THREE.LatheGeometry</code></p>
</td><td style="text-align: left" valign="top">
<p>It<a class="indexterm" id="id109"/> revolves<a class="indexterm" id="id110"/> a shape in a circle</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">THREE.PolyhedronGeometry</code></p>
</td><td style="text-align: left" valign="top">
<p>A spheroid;<a class="indexterm" id="id111"/> examples<a class="indexterm" id="id112"/> include <code class="literal">IcosahedronGeometry</code>, <code class="literal">TetrahedronGeometry</code>, and so on</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">THREE.ExtrudeGeometry</code></p>
</td><td style="text-align: left" valign="top">
<p>It starts <a class="indexterm" id="id113"/>with a 2D shape and <a class="indexterm" id="id114"/>stretches it into a 3D space</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">THREE.ShapeGeometry</code></p>
</td><td style="text-align: left" valign="top">
<p>It is a<a class="indexterm" id="id115"/> 2D shape</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">THREE.TubeGeometry</code></p>
</td><td style="text-align: left" valign="top">
<p>It is a<a class="indexterm" id="id116"/> hollow<a class="indexterm" id="id117"/> cylinder</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">THREE.ParametricGeometry</code></p>
</td><td style="text-align: left" valign="top">
<p>These<a class="indexterm" id="id118"/> are curved <a class="indexterm" id="id119"/>tubes</p>
</td></tr></tbody></table></div><p>Let's take extruding as an example since that's a relatively common operation:</p><div><pre class="programlisting">var triangle = new THREE.Shape([
  new THREE.Vector2 (0,  50),
  new THREE.Vector2 (50, 50),
  new THREE.Vector2 (50,  0)
]);
var geometry = new THREE.ExtrudeGeometry(triangle, {
  bevelEnabled: false,
  amount: 30
});</pre></div><p>The approach here is to create a 2D shape (<code class="literal">THREE.Shape</code>) out of (x, y) coordinates and then stretch it out along the z axis. The second parameter for <code class="literal">ExtrudeGeometry</code> <a class="indexterm" id="id120"/>is a map of options. The most important one, <code class="literal">amount</code>, controls how far to stretch out the shape. <code class="literal">bevelEnabled</code> controls whether the extruded edges are rounded or not. You can see the result in the following screenshot:</p><div><img alt="Custom geometries" src="img/8539_02_07.jpg"/><div><p>An extruded triangle</p></div></div><p>Use cases for the other <a class="indexterm" id="id121"/>custom geometries<a class="indexterm" id="id122"/> are unusual in games because normally if you wanted to create a complex shape, you could create a model in a 3D modeling program<a class="indexterm" id="id123"/> and then import it into Three.js (a process covered in <a class="link" href="ch04.html" title="Chapter 4. Adding Detail">Chapter 4</a>, <em>Adding Detail</em>).</p><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>There is a WebGL-only class called <code class="literal">THREE.BufferGeometry</code> <a class="indexterm" id="id124"/>which is faster than <code class="literal">THREE.Geometry</code>, but is much more difficult to work with because it stores WebGL buffers instead of Three.js vertices and faces. However, future developments in Three.js will shift the default geometry to work more like <code class="literal">THREE.BufferGeometry</code> under the hood so that you don't have to think about the differences.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec10"/>Text</h2></div></div></div><p>Three.js can render text<a class="indexterm" id="id125"/> in 3D using geometry as well. To use this feature, you must<a class="indexterm" id="id126"/> include the font files after the Three.js library, but before your own code. For example, include the Helvetiker font<a class="indexterm" id="id127"/> using the following code:</p><div><pre class="programlisting">&lt;script src="img/helvetiker_bold.typeface.js"&gt;&lt;/script&gt;
&lt;script src="img/helvetiker_regular.typeface.js"&gt;&lt;/script&gt;</pre></div><p>(In production projects, you should download the fonts you want to use and include them locally.)</p><p>Three.js comes with several fonts in the <code class="literal">examples/fonts</code> directory. Custom fonts must be in the <code class="literal">typeface.js</code> format (you can convert OpenType and TrueType fonts to Typeface format at <a class="ulink" href="http://typeface.neocracy.org/fonts.html">http://typeface.neocracy.org/fonts.html</a>). Use the following code to create text geometry:</p><div><pre class="programlisting">new THREE.TextGeometry("Text message goes here", {
  size: 30,
  height: 20, // extrude thickness
  font: "helvetiker", // font family in lower case
  weight: "normal", // or e.g. bold
  style: "normal", // or e.g. italics
  bevelEnabled: false
});</pre></div><p>The <code class="literal">THREE.TextGeometry</code> constructor<a class="indexterm" id="id128"/> creates<a class="indexterm" id="id129"/> a shape representing the text in 2D, and then extrudes it as we did with our triangle. <a class="indexterm" id="id130"/>You can see the result in the<a class="indexterm" id="id131"/> following <a class="indexterm" id="id132"/>screenshot:</p><div><img alt="Text" src="img/8539_02_08.jpg"/><div><p>3D text</p></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Materials</h1></div></div></div><p>Materials <a class="indexterm" id="id133"/>are instances of <code class="literal">THREE.Material</code> that define how objects appear. There are several<a class="indexterm" id="id134"/> common material<a class="indexterm" id="id135"/> subclasses:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Constructor</p>
</th><th style="text-align: left" valign="bottom">
<p>Explanation</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">MeshBasicMaterial</code></p>
<div><img alt="Materials" src="img/8539_02_09.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>It is not affected <a class="indexterm" id="id136"/>by lighting<a class="indexterm" id="id137"/> (a characteristic called <strong>unlit</strong><a class="indexterm" id="id138"/>), so this is usually used to display a solid color or a wireframe. Two adjacent, same-colored, unlit surfaces are difficult to tell apart.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">MeshNormalMaterial</code></p>
<div><img alt="Materials" src="img/8539_02_10.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>The red/green/blue values<a class="indexterm" id="id139"/> of the<a class="indexterm" id="id140"/> colors displayed by this material are based on the magnitude of the x/y/z values of the faces' normal vectors. (A <em>normal</em> vector is perpendicular to a surface.) This material is unlit and useful for quickly distinguishing the shape of an object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">MeshDepthMaterial</code></p>
<div><img alt="Materials" src="img/8539_02_11.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>It is an unlit material<a class="indexterm" id="id141"/> that shows shades of gray, with brightness depending on the distance from <a class="indexterm" id="id142"/>the camera. It is useful when designing scenes before applying more realistic textures.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">MeshLambertMaterial</code></p>
<div><img alt="Materials" src="img/8539_02_12.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Faces are affected <a class="indexterm" id="id143"/>by lighting, <a class="indexterm" id="id144"/>but are not shiny. Specifically, lighting is calculated per-vertex and is interpolated over faces. It will appear black if there are no lights in the scene.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">MeshPhongMaterial</code></p>
<div><img alt="Materials" src="img/8539_02_13.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>Faces are affected <a class="indexterm" id="id145"/>by lighting, and<a class="indexterm" id="id146"/> can be shiny. Specifically, lighting is calculated per-<em>texel</em> (texture pixel), so this will be more accurate than Lambert materials when the light source is close to the object in question.<a class="indexterm" id="id147"/> It will appear black if there<a class="indexterm" id="id148"/> are no lights in the scene.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">MeshFaceMaterial</code></p>
<div><img alt="Materials" src="img/8539_02_14.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>It is essentially an<a class="indexterm" id="id149"/> array of materials<a class="indexterm" id="id150"/> used to map different materials to different surfaces. This material is unique in that instantiating it is different than all the others, as you can see in the following code:</p>
<div><pre class="programlisting">var mat1 = new THREE.MeshPhongMaterial({ color: 0x0000ff  });
var mat2 = new THREE.MeshPhongMaterial({ color: 0xff0000 });
var mat3 = new THREE.MeshPhongMaterial({ color: 0xffffff });
var materials = [mat1, mat2, mat3];
material = new THREE.MeshFaceMaterial(materials);
for (var i = 0, l = geometry.faces.length; i &lt; l; i++) {
  geometry.faces[i].materialIndex = i % l;
}</pre></div>
<p>Here, we create three new materials we want to use, pass them in an array to <code class="literal">MeshFaceMaterial</code>, and then set each face on our geometry to an index of the <code class="literal">materials</code> array that corresponds to the material we want for that face.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">ShaderMaterial</code></p>
<div><img alt="Materials" src="img/8539_02_15.jpg"/></div>
</td><td style="text-align: left" valign="top">
<p>It displays a <strong>GLSL</strong> (<strong>open Graphics Library Shading Language</strong>)<a class="indexterm" id="id151"/> texture.<a class="indexterm" id="id152"/> GLSL is a programming<a class="indexterm" id="id153"/> language based on C that is used by WebGL and OpenGL to provide developers with a high-level, platform-agnostic way to control graphics. It is quite powerful and will be addressed more in <a class="link" href="ch04.html" title="Chapter 4. Adding Detail">Chapter 4</a>, <em>Adding Detail</em>.</p>
</td></tr></tbody></table></div><p>All of these material<a class="indexterm" id="id154"/> constructors except <code class="literal">MeshFaceMaterial</code> take a map of options as their only parameter. We've already encountered three options from our icosahedron example:<a class="indexterm" id="id155"/> <code class="literal">color</code>, <code class="literal">wireframe</code>,<a class="indexterm" id="id156"/> and <code class="literal">wireframeLinewidth</code>.<a class="indexterm" id="id157"/> Additionally, setting the <code class="literal">transparency</code> option<a class="indexterm" id="id158"/> to <code class="literal">true</code> allows use of the <code class="literal">opacity</code> option<a class="indexterm" id="id159"/>, a value between zero and one indicating how see-through <a class="indexterm" id="id160"/>the material should be (zero is invisible, one is opaque). For materials that don't use images, the other option that may be relevant is <code class="literal">shading</code>, <a class="indexterm" id="id161"/>which has a value of either <code class="literal">THREE.SmoothShading</code> or <code class="literal">THREE.FlatShading</code> indicating whether to blend colors of each face together, as shown in the next screenshot:</p><div><img alt="Materials" src="img/8539_02_16.jpg"/><div><p>Left, THREE.MeshNormalMaterial({shading: THREE.FlatShading}); Right, THREE.MeshNormalMaterial({shading: THREE.SmoothShading});</p></div></div><p>There are several other properties,<a class="indexterm" id="id162"/> the most important of which is also the most useful: <code class="literal">map</code>.<a class="indexterm" id="id163"/> This defines the texture used to wrap over the geometry. Usually, using this property looks like the following code snippet:</p><div><pre class="programlisting">var image = THREE.ImageUtils.loadTexture('image.jpg');
new THREE.MeshBasicMaterial({map: image});</pre></div><div><div><h3 class="title"><a id="note04"/>Note</h3><p>There are two issues to watch out for when loading images. First, if you are running your application locally (by double-clicking on the file, you will see a <code class="literal">file:///</code> URL), Chrome will prevent loading images by default for security reasons (to keep malicious JavaScript from accessing local files on your computer). You can solve this by either changing your browser's security settings or running the file using a local HTTP server as explained at <a class="ulink" href="https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally">https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally</a>. The second issue is that you cannot render images loaded from another domain in WebGL, also for security reasons. You can solve this by serving the image with the <code class="literal">Access-Control-Allow-Origin</code> header set to <code class="literal">null</code> as explained at <a class="ulink" href="https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/">https://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/</a>.</p></div></div><p>The <code class="literal">ImageUtils.loadTexture()</code> function<a class="indexterm" id="id164"/> loads images.<a class="indexterm" id="id165"/> Let's use a slightly more advanced version to render the <code class="literal">earth</code> image:</p><div><pre class="programlisting">THREE.ImageUtils.loadTexture('earth.jpg', undefined, function(texture) {
  geometry = new THREE.SphereGeometry(280, 20, 20);
  material = new THREE.MeshBasicMaterial({map: texture, overdraw: true});
  mesh = new THREE.Mesh(geometry, material);
  mesh.rotation.x = 30 * Math.PI / 180;
  scene.add(mesh);
});</pre></div><p>The second parameter for <code class="literal">loadTexture</code> is currently unused, and the third parameter is a callback that is invoked when the image is successfully loaded. (A fourth parameter is also accepted for an error callback function.) We've seen all the rest of this code before except the <code class="literal">overdraw</code> option<a class="indexterm" id="id166"/>, which eliminates small gaps between the mesh's faces that arise due to limitations<a class="indexterm" id="id167"/> of the canvas API. (The <code class="literal">WebGLRenderer</code> does not need this property; it can align faces more perfectly.) You can see the result in the following screenshot:</p><div><img alt="Materials" src="img/8539_02_17.jpg"/><div><p>Earth as a sphere with a mapped texture</p></div></div><p>The image used in this example<a class="indexterm" id="id168"/> is available in the Three.js package at <code class="literal">examples/textures/planets/land_ocean_ice_cloud_2048.jpg</code>.</p><p>There are a number of other options for different kinds of materials that are too complex to address in the space we have. You can read more about them in the documentation for the different materials. For example, the <code class="literal">MeshPhongMaterial</code> documentation<a class="indexterm" id="id169"/> (<a class="ulink" href="http://threejs.org/docs/#Reference/Materials/MeshPhongMaterial">http://threejs.org/docs/#Reference/Materials/MeshPhongMaterial</a>) includes notes on<a class="indexterm" id="id170"/> producing <a class="indexterm" id="id171"/>reflective surfaces.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>A city scene</h1></div></div></div><p>We've covered a lot of ground<a class="indexterm" id="id172"/> with the Three.js API. Let's tie it all together<a class="indexterm" id="id173"/> with a project that uses what we've learned about geometry and materials.</p><p>So far, we've been working with a single object in our world. If we wanted to move it around, we'd have to change its <code class="literal">position</code> vector<a class="indexterm" id="id174"/>. We could create a full scene this way by adding multiple objects and manually positioning them. However, for worlds with more than a few objects, this can quickly get quite tedious. There are several alternatives:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Rectangular layout</strong>: This method involves storing a map in some simple format such as a string or an image, where each character or pixel color represents a type of object</li><li class="listitem" style="list-style-type: disc"><strong>Procedural generation</strong>: This method involves the use of an algorithm to position objects semi-randomly</li><li class="listitem" style="list-style-type: disc"><strong>Editor</strong>: This method involves the use of an external tool to construct the scene, followed by exporting the result (for example, in JSON format), and importing it when the application executes</li></ul></div><p>The rectangular format is the easiest for simple game levels, and we'll be using it in <a class="link" href="ch03.html" title="Chapter 3. Exploring and Interacting">Chapter 3</a>, <em>Exploring and Interacting</em>. <a class="link" href="ch05.html" title="Chapter 5. Design and Development">Chapter 5</a>, <em>Design and Development</em> discusses the editor approach in detail. For now, let's try procedurally creating a city, based on an example created by <em>Ricardo Cabello</em> (the original Three.js author) at <a class="ulink" href="http://www.mrdoob.com/lab/javascript/webgl/city/01/">http://www.mrdoob.com/lab/javascript/webgl/city/01/</a>.</p><p>First, let's create a cube <a class="indexterm" id="id175"/>and material that we'll use as the basis for our city buildings. We'll copy our geometry and material for each new building and scale the geometry appropriately:</p><div><pre class="programlisting">var geo = new THREE.CubeGeometry(1, 1, 1);
geo.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
var material = new THREE.MeshDepthMaterial({overdraw: true});</pre></div><p>The second line from the previous code snippet moves the geometry's origin (the point around which the geometry is scaled and rotated) to the bottom so that when we scale up a building, all the buildings' floors will be at the same height. This is done by shifting the y coordinate of every vertex and face 0.5 units up using a matrix that represents a vertical translation.</p><div><div><h3 class="title"><a id="note05"/>Note</h3><p>Matrices can be thought of as rectangular arrays or tables with rows and columns. A matrix with four rows and four columns is particularly useful for storing information about objects in 3D space because a single 4 x 4 matrix can represent position, rotation, and scale. This is the only point in this book that will mention matrices, so it's okay if you don't understand the underlying math; one of the reasons to use Three.js is to avoid having to do linear algebra manually. The transformation we are doing in this case is just one short way to move all the vertices and faces of a geometry at once without moving its origin.</p></div></div><p>Next, we'll create all our buildings:</p><div><pre class="programlisting">for (var i = 0; i &lt; 300; i++) {
  var building = new THREE.Mesh(geo.clone(), material.clone());
  building.position.x = Math.floor(Math.random() * 200 - 100) * 4;
  building.position.z = Math.floor(Math.random() * 200 - 100) * 4;
  building.scale.x = Math.random() * 50 + 10;
  building.scale.y = Math.random() * building.scale.x * 8 + 8;
  building.scale.z = building.scale.x;
  scene.add(building);
}</pre></div><p>The only thing that's new here<a class="indexterm" id="id176"/> is the <code class="literal">clone()</code> method<a class="indexterm" id="id177"/>. Almost all Three.js objects can be cloned to create a copy that can be modified without altering the original. We are taking advantage of that to create new geometry and material instances based on our <a class="indexterm" id="id178"/>original instances.</p><p>Let's position the camera in a place where it can get a better view:</p><div><pre class="programlisting">camera.position.y = 400;
camera.position.z = 400;
camera.rotation.x = -45 * Math.PI / 180;</pre></div><p>We've seen rotation a couple of times now, but it's important to recall that rotation is measured in radians. The conversion we perform here tilts the camera 45 degrees down. You can also use the convenient <code class="literal">lookAt</code> method<a class="indexterm" id="id179"/>. For example, <code class="literal">camera.lookAt(new THREE.Vector3(0, 0, 0))</code> turns the camera to look at the default scene origin.</p><p>Finally, we'll add a floor as well:</p><div><pre class="programlisting">var geo = new THREE.PlaneGeometry(2000, 2000, 20, 20);
var mat = new THREE.MeshBasicMaterial({color: 0x9db3b5, overdraw: true});
var mesh = new THREE.Mesh(geo, mat);
mesh.rotation.x = -90 * Math.PI / 180;
scene.add(mesh);</pre></div><p>The last two parameters to <code class="literal">PlaneGeometry()</code> <a class="indexterm" id="id180"/>split the plane into a 20 x 20 grid. This prevents Three.js from optimizing away the floor if it thinks all the vertices are too far out of view. Also, the plane is created along the x and y axes initially, so we need to rotate it by -90 degrees to make<a class="indexterm" id="id181"/> it lie flat<a class="indexterm" id="id182"/> under the buildings.</p><p>Putting it all together now:</p><div><pre class="programlisting">var camera, scene, renderer;

function setup() {
  document.body.style.backgroundColor = '#d7f0f7';
  setupThreeJS();
  setupWorld();

  requestAnimationFrame(function animate() {
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  });
}

function setupThreeJS() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 10000);
  camera.position.y = 400;
  camera.position.z = 400;
  camera.rotation.x = -45 * Math.PI / 180;

  renderer = new THREE.CanvasRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
}

function setupWorld() {
  // Floor
  var geo = new THREE.PlaneGeometry(2000, 2000, 20, 20);
  var mat = new THREE.MeshBasicMaterial({color: 0x9db3b5, overdraw: true});
  var floor = new THREE.Mesh(geo, mat);
  floor.rotation.x = -90 * Math.PI / 180;
  scene.add(floor);

  // Original building
  var geometry = new THREE.CubeGeometry(1, 1, 1);
  geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0.5, 0));
  var material = new THREE.MeshDepthMaterial({overdraw: true});

  // Cloned buildings
  for (var i = 0; i &lt; 300; i++) {
    var building = new THREE.Mesh(geometry.clone(), material.clone());
    building.position.x = Math.floor(Math.random() * 200 - 100) * 4;
    building.position.z = Math.floor(Math.random() * 200 - 100) * 4;
    building.scale.x  = Math.random() * 50 + 10;
    building.scale.y  = Math.random() * building.scale.x * 8 + 8;
    building.scale.z  = building.scale.x;
    scene.add(building);
  }
}

// Run it!
setup();</pre></div><p>Let's see the result,<a class="indexterm" id="id183"/> shown in<a class="indexterm" id="id184"/> the next screenshot:</p><div><img alt="A city scene" src="img/8539_02_18.jpg"/><div><p>Procedurally generated cityscape</p></div></div><p>Let's optimize the scene by merging the geometries of all the buildings. To do this, we'll tweak the code that spawns our many<a class="indexterm" id="id185"/> buildings:</p><div><pre class="programlisting">
<strong>var cityGeometry = new THREE.Geometry();</strong>
for (var i = 0; i &lt; 300; i++) {
<strong>  var building = new THREE.Mesh(geometry.clone());</strong>
  building.position.x = Math.floor(Math.random() * 200 - 100) * 4;
  building.position.z = Math.floor(Math.random() * 200 - 100) * 4;
  building.scale.x  = Math.random() * 50 + 10;
  building.scale.y  = Math.random() * building.scale.x * 8 + 8;
  building.scale.z  = building.scale.x;
<strong>  THREE.GeometryUtils.merge(cityGeometry, building);</strong>
}
<strong>var city = new THREE.Mesh(cityGeometry, material);</strong>
<strong>scene.add(city);</strong>
</pre></div><p>The key here is that we're now merging all of the building meshes into a single <code class="literal">cityGeometry</code> using <code class="literal">GeometryUtils.merge()</code>.<a class="indexterm" id="id186"/> This is an important optimization for scenes with a lot of geometry<a class="indexterm" id="id187"/> that does not move independently because the renderer can more intelligently batch drawing calls if it knows about all the vertices and faces <a class="indexterm" id="id188"/>at once instead of drawing them one mesh at a time.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Lighting</h1></div></div></div><p>Lights <a class="indexterm" id="id189"/>are instances of <code class="literal">THREE.Light</code> that affect how the <code class="literal">MeshLambertMaterial</code> and <code class="literal">MeshPhongMaterial</code> surfaces are illuminated. Most lights have color (specified in hexadecimal notation like CSS colors) <a class="indexterm" id="id190"/>and intensity (a decimal value, usually between zero and one, indicating how bright the light should be). There are different kinds<a class="indexterm" id="id191"/> of lights as shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type</p>
</th><th style="text-align: left" valign="bottom">
<p>Constructor</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Ambient</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.AmbientLight(color)</pre></div></td><td style="text-align: left" valign="top">
<p>It affects<a class="indexterm" id="id192"/> all lit objects<a class="indexterm" id="id193"/> in the scene equally.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Directional</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.DirectionalLight(color, intensity = 1)</pre></div></td><td style="text-align: left" valign="top">
<p>For this<a class="indexterm" id="id194"/> type, all light is<a class="indexterm" id="id195"/> parallel and comes from a given direction, as if the source was very far away.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Hemisphere</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.HemisphereLight(skyColor, groundColor, intensity = 1)</pre></div></td><td style="text-align: left" valign="top">
<p>It simulates<a class="indexterm" id="id196"/> refractive lighting<a class="indexterm" id="id197"/> from the sun, sort of like two opposing directional lights.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Point</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.PointLight(color, intensity = 1, radius = 0)</pre></div></td><td style="text-align: left" valign="top">
<p>It emanates<a class="indexterm" id="id198"/> from a specific point<a class="indexterm" id="id199"/> in space, like a lightbulb. It illuminates only objects within <code class="literal">radius</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Spot</p>
</td><td style="text-align: left" valign="top">
<div><pre class="programlisting">THREE.SpotLight(color, intensity, radius = 0, coneAngle = Math.PI / 3, falloff = 10)</pre></div></td><td style="text-align: left" valign="top">
<p>It emanates <a class="indexterm" id="id200"/>from a specific point in space in a specific direction.<a class="indexterm" id="id201"/> It illuminates objects in a cone pointing in its direction of rotation, falling off exponentially within a distance of <code class="literal">radius</code>.</p>
</td></tr></tbody></table></div><p>To update our procedural city scene with lighting,<a class="indexterm" id="id202"/> let's first change<a class="indexterm" id="id203"/> the buildings' material to respond to light:</p><div><pre class="programlisting">var material = new THREE.MeshPhongMaterial({overdraw: true, color: 0xcccccc});</pre></div><p>Then we'll add our light to the scene:</p><div><pre class="programlisting">var light = new THREE.DirectionalLight(0xf6e86d, 1);
light.position.set(1, 3, 2);
scene.add(light);</pre></div><p>For directional lights, the direction of the light is the direction from <code class="literal">light.position</code> to <code class="literal">light.target.position</code>; both are vectors that you can change, and the target defaults to the world's origin.</p><p>Let's also change our renderer to WebGL because <code class="literal">CanvasRenderer</code> does not support advanced lighting features such as shadows and fog, which we'll want to add momentarily:</p><div><pre class="programlisting">renderer = new THREE.WebGLRenderer();</pre></div><p>As a final touch now that our scene has lighting, let's add fog for a little ambiance:</p><div><pre class="programlisting">scene.fog = new THREE.FogExp2(0x9db3b5, 0.002);</pre></div><p>There are actually two kinds of fog. <code class="literal">FoxExp2</code> <a class="indexterm" id="id204"/>gets exponentially denser with distance, and appropriately <a class="indexterm" id="id205"/>its parameters<a class="indexterm" id="id206"/> are color and density exponent (a small decimal you will need to play around with depending on<a class="indexterm" id="id207"/> the scale of your world). The other kind of fog is <code class="literal">THREE.Fog</code>,<a class="indexterm" id="id208"/> which gets denser linearly; its parameters are color, minimum distance at which fog starts appearing, and maximum distance beyond which objects will be occluded by fog. For example:</p><div><pre class="programlisting">scene.fog = new THREE.Fog(0x9db3b5, 0, 800);</pre></div><p>The differences between the two kinds of fog are difficult to capture in static images, but the next two screenshots show a contrast between exponential falloff and rapid linear falloff. The following screenshot shows <code class="literal">FogExp2</code> with low density:</p><div><img alt="Lighting" src="img/8539_02_19.jpg"/></div><p>The following<a class="indexterm" id="id209"/> screenshot shows <code class="literal">Fog</code> with short falloff:</p><div><img alt="Lighting" src="img/8539_02_20.jpg"/></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec11"/>Shadows</h2></div></div></div><p>Only the <code class="literal">DirectionalLight</code> <a class="indexterm" id="id210"/>and <code class="literal">PointLight</code> objects<a class="indexterm" id="id211"/> can cast shadows<a class="indexterm" id="id212"/>. Casting shadows first requires that we<a class="indexterm" id="id213"/> enable shadows on the renderer:</p><div><pre class="programlisting">renderer.shadowMapEnabled = true;</pre></div><p>If you want, you can also set <code class="literal">renderer.shadowMapSoft = true</code>, which will somewhat smooth the edges of the shadows.</p><p>Then, each object that will<a class="indexterm" id="id214"/> cast or receive shadows must be explicitly set to do so. (Shadows are disabled by default because calculating shadows can be slow.) For our city scene, we'll enable shadow receiving for our floor and both casting and receiving for our buildings:</p><div><pre class="programlisting">floor.receiveShadow = true;
city.castShadow = true;
city.receiveShadow = true;</pre></div><p>The <code class="literal">castShadow</code> <a class="indexterm" id="id215"/>and <code class="literal">receiveShadow</code> properties<a class="indexterm" id="id216"/> do pretty much what they sound like—enabling casting and receiving shadows.</p><p>Finally, we configure our <code class="literal">DirectionalLight</code> object<a class="indexterm" id="id217"/> to use shadows:</p><div><pre class="programlisting">light.castShadow = true;
light.shadowDarkness = 0.5;
light.shadowMapWidth = 2048;
light.shadowMapHeight = 2048;
light.position.set(500, 1500, 1000); 
light.shadowCameraFar = 2500; 
// DirectionalLight only; not necessary for PointLight
light.shadowCameraLeft = -1000;
light.shadowCameraRight = 1000;
light.shadowCameraTop = 1000;
light.shadowCameraBottom = -1000;</pre></div><p>We set the light to cast a shadow and set how dark we want it to be. The darkness usually ranges from <code class="literal">0</code> (no shadows) to <code class="literal">1</code> (dark shadows), but it can have other values; values below <code class="literal">0</code> will cause a sort of anti-shadow, where objects that would be in shadow are instead illuminated, and values higher than <code class="literal">1</code> will make shadows appear very black. Then we set the resolution of our<a class="indexterm" id="id218"/> shadows with the <code class="literal">shadowMapWidth</code> <a class="indexterm" id="id219"/>and <code class="literal">shadowMapHeight</code> properties<a class="indexterm" id="id220"/>, which affect the crispness of shadows' edges; higher values look sharper but are more computationally expensive.<a class="indexterm" id="id221"/> Next, we describe the <strong>shadow camera</strong><a class="indexterm" id="id222"/> that will be used to project the shadows. In fact, when it comes to shadows, the <code class="literal">DirectionalLight</code> and <code class="literal">PointLight</code> objects<a class="indexterm" id="id223"/> are analogous to the <code class="literal">OrthographicCamera</code> <a class="indexterm" id="id224"/>and <code class="literal">PerspectiveCamera</code> objects<a class="indexterm" id="id225"/> in that the former uses parallel projection while the latter uses perspective projection. Therefore, to set up our camera, we move the light to a point that is far enough away to be able to <em>see</em> everything we want to have a shadow. Then we describe the shape of the frustum with the <code class="literal">shadowCamera</code> properties; the left, right, top, or bottom values are the lengths of the corresponding sides of the end of the frustum, and the <code class="literal">Far</code> value is the distance to the end of the frustum. (Recall from <a class="link" href="ch01.html" title="Chapter 1. Hello, Three.js">Chapter 1</a>, <em>Hello, Three.js</em>, that a frustum is a shape encompassing what a camera can <em>see</em>.) If this is difficult to visualize, you can display the frustum like this:</p><div><pre class="programlisting">light.shadowCameraVisible = true;</pre></div><p>The result is a wireframe shape representing the shadow projection, shown in the next screenshot:</p><div><img alt="Shadows" src="img/8539_02_21.jpg"/><div><p>A shadow camera</p></div></div><p>The <code class="literal">DirectionalLight</code> object<a class="indexterm" id="id226"/> is positioned<a class="indexterm" id="id227"/> at the peak of the red cone, the ends of the yellow boxes are at the <code class="literal">shadowCameraNear</code> <a class="indexterm" id="id228"/>and <code class="literal">shadowCameraFar</code> distances<a class="indexterm" id="id229"/>, and the edges of the box are the size<a class="indexterm" id="id230"/> of the frustum. For <code class="literal">PointLights</code>, the entire frustum is a cone.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Renderers</h1></div></div></div><p>Earlier, we switched from <code class="literal">CanvasRenderer</code> to <code class="literal">WebGLRenderer</code> in order to support shadows and fog. As a rule<a class="indexterm" id="id231"/> of thumb, <code class="literal">WebGLRenderer</code> is faster and has the<a class="indexterm" id="id232"/> most features, while <code class="literal">CanvasRenderer</code> <a class="indexterm" id="id233"/>has fewer features but broader browser support. One particularly nice feature of <code class="literal">WebGLRenderer</code> <a class="indexterm" id="id234"/>is that it supports antialiasing to smooth out jagged edges. We can enable this for our cityscape by passing the option in to the renderer constructor:</p><div><pre class="programlisting">renderer = new THREE.WebGLRenderer({antialias: true});</pre></div><p>With that, our cityscape is finally complete, as shown in the next screenshot:</p><div><img alt="Renderers" src="img/8539_02_22.jpg"/><div><p>A completed city</p></div></div><p>Three.js has several other renderers, most notably for CSS and SVG. These can be found in the <code class="literal">examples/js/renderers</code> folder and are available as <code class="literal">THREE.CSS3DRenderer</code> <a class="indexterm" id="id235"/>and <code class="literal">THREE.SVGRenderer</code>,<a class="indexterm" id="id236"/> respectively, if their eponymous files are included in your HTML document. These renderers have a smaller set of supported <a class="indexterm" id="id237"/>features and are not as widely used, so they are not <a class="indexterm" id="id238"/>included in the main library, but they can be useful for scenes with a limited amount of primitive geometry and no lighting.</p><p>For the rest of this book, we'll be using the <code class="literal">WebGLRenderer</code>, <a class="indexterm" id="id239"/>so if you're using a version before version 11 of Internet Explorer, you should switch to Chrome or Firefox.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>If WebGL isn't available, your game can fall back to the <code class="literal">CanvasRenderer</code> or just display an error message. The easiest way to do this is with the script at <code class="literal">examples/js/Detector.js</code>. Once the script is included on your page, you can simply check the <code class="literal">Detector.webgl</code> Boolean to see if WebGL is supported on the current system. If it's not, you can call <code class="literal">Detector.addGetWebGLMessage()</code> <a class="indexterm" id="id240"/>to explain to the user why your game won't run on their device and how to switch to a browser that supports WebGL.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we learned how to work with different kinds of geometry, materials, and lighting. We also learned about renderers and scenes, and completed a project to build a city procedurally. In the next chapter, we'll learn about ways that users can interact with Three.js, add some physics to the mix, and build a basic first-person shooter game.</p></div></body></html>