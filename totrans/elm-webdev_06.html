<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Exploring Elm in Greater Detail</h1>
                </header>
            
            <article>
                
<p>Welcome to <a href="651ea5bb-9106-4053-b8b4-6481508a775b.xhtml">Chapter 6</a>, <em>Exploring Elm in Greater Detail</em>.<span> While the previous chapter was more on the practical side, this chapter will deal with more theoretical concepts. </span></p>
<p><span>The topics we will cover include:</span></p>
<ul>
<li>Destructuring values in Elm</li>
<li><span>How does Elm deal with randomness?</span></li>
<li><span>Commands in Elm</span></li>
<li><span>Subscriptions in Elm</span></li>
<li>Working with <kbd>Html.program</kbd></li>
</ul>
<p>After completing this chapter, you will be able to:</p>
<ul>
<li>Improve your apps by understanding more advanced Elm concepts</li>
<li>Send commands to deal with randomness</li>
<li>Subscribe to events </li>
<li>Desctructure values and work with them</li>
</ul>
<p>Let's begin the chapter by looking at a very important topic: destructuring values in Elm.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring values in Elm</h1>
                </header>
            
            <article>
                
<p>Destructuring is an elegant and effective way to extract values from data structures in Elm. Destructuring is also referred to as pattern matching. The syntax is terse, and for the uninitiated, it can be slightly confusing, precisely because it is so short. However, once understood, it feels like a natural and practical way to get the values out from Elm data structures.</p>
<p>Let's look at an example of destructuring a tuple in Elm. As a reminder, a tuple is a data structure similar to a record. The difference is that it is usually shorter, and we do not care about naming the values stored in a tuple. If you really must name values in your data structure, you need to use records.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring tuples in Elm using let-in expressions</h1>
                </header>
            
            <article>
                
<p>Let's imagine that a 400-meter race took place. The race involved five participants. We will use a tuple to store all the times of all the race participants (in seconds). Let's use Elm REPL to store those times:</p>
<pre><strong>aTuple = (60,65,71,75,90)</strong></pre>
<p>The REPL will return the following:</p>
<pre><strong>(60,65,71,75,90) : ( number, number1, number2, number3, number4 )</strong></pre>
<p>Now that we have the times, we want to do some analysis. However, to perform the analysis, we first need to know how to extract those values.</p>
<p>To extract the values, we'll use a <kbd>let-in</kbd> expression. The first task we have is to calculate the total time of all the racers. We will do that by adding up all the individual times, or, put differently, by adding up all the values stored in the tuple. Easy enough:</p>
<pre><strong>let \</strong><br/><strong>  (a,b,c,d,e) = aTuple \</strong><br/><strong>in \</strong><br/><strong>  a + b + c + d + e</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>271 : number</strong></pre>
<p>Let's now calculate the average time by dividing the result by <kbd>5</kbd> (since there were five racers):</p>
<pre><strong>let \</strong><br/><strong>  (a,b,c,d,e) = aTuple \</strong><br/><strong>in \</strong><br/><strong>  (a + b + c + d + e) / 5</strong></pre>
<p>This time, the REPL returns the following:</p>
<pre><strong>72.2 : Float</strong></pre>
<p>How did we destructure the preceding tuple? To understand what is happening in the preceding code, we need to discuss this line of code:</p>
<pre><strong>(a,b,c,d,e) = aTuple \</strong></pre>
<p>The preceding line of code follows the <kbd>let</kbd> keyword, which, as explained previously, allows us to scope variables and use them only in the <kbd>in</kbd> part of a <kbd>let-in</kbd> expression. </p>
<p>Thus, we have pattern-matched a five-tuple (containing variables <kbd>a</kbd>, <kbd>b</kbd>, <kbd>c</kbd>, <kbd>d</kbd>, and <kbd>e</kbd>) to the specific tuple we declared previously, and gave it the name <kbd>aTuple</kbd>. In other words, if we pretend that Elm REPL is a person, the preceding line of code is the same as if we said: <em>Hey Elm REPL, use the values from aTuple, and match the values to letters a,b,c,d, and e, because I want to perform some calculations on those values</em>.</p>
<p>Then in the <kbd>in</kbd> part of our <kbd>let-in</kbd> expression, we simply performed our calculations as needed. The preceding example shows what destructuring essentially is.</p>
<p>In the next example, let's see how easy it is to work with only some of the values from our <kbd>aTuple</kbd>. We'll calculate the average time of the first three runners. This is really easy. Along the lines of what we did earlier, we'll simply do this:</p>
<pre><strong>let \</strong><br/><strong>  (a,b,c,d,e) = aTuple \</strong><br/><strong>in \</strong><br/><strong>  (a+b+c) / 3</strong></pre>
<p>This is what Elm REPL returns:</p>
<pre><strong>65.33333333333333 : Float</strong></pre>
<p>Finally, let's calculate the time difference between the last to the finish line and the first racer to have crossed it. We'll do another simple calculation:</p>
<pre><strong>let \</strong><br/><strong>  (a,b,c,d,e) = aTuple \</strong><br/><strong>in \</strong><br/><strong>  e-a</strong></pre>
<p>The Elm REPL will return the following:</p>
<pre><strong>30 : number</strong></pre>
<p>Great, everything works as expected. Let's now imagine a similar use of tuple destructuring. This time, we'll be using a five-tuple of Strings. The goal is to play around with destructuring only some values from a tuple, just like we did before:</p>
<pre><strong>aTupleOfStrings = ("Hello", "Big", "Wild", "Funny", "World")</strong></pre>
<p>Next, let's print out a ''Hello World'' to the REPL:</p>
<pre><strong>let \</strong><br/><strong>  (a, b) = aTupleOfStrings</strong><br/><strong>in \</strong><br/><strong>  a ++ e</strong></pre>
<p>Unfortunately, this will not work like we thought it would. The error is self-explanatory:</p>
<pre><strong>-- TYPE MISMATCH --------------------------------------------- repl-temp-000.elm</strong><br/><br/><strong>`aTupleOfStrings` is being used in an unexpected way.</strong><br/><br/><strong>5| (a,e) = aTupleOfStrings</strong><br/><strong>           ^^^^^^^^^^^^^^^</strong><br/><strong>Based on its definition, `aTupleOfStrings` has this type:</strong><br/><br/><strong>    ( String, String, String, String, String )</strong><br/><br/><strong>But you are trying to use it as:</strong><br/><br/><strong>    ( a, b )</strong></pre>
<p>This poses a problem. While we already know, from the examples of calculating race times, that we could pattern-match all the values from a tuple using a one-to-one mapping, with temporary variables, this approach might not always be the most efficient. Why?</p>
<p>Because sometimes we might have to assign longer, more expressive variable names in our let expressions, to satisfy the compiler. And then, once we don't get the error, we'd never actually use those variable names. This is impractical. Realistically<span>, we will not be able to always type one-letter temporary variables and still be able to easily make sense of our programs. </span></p>
<p>Luckily, the solution is simple—when we don't care about some of the values that will appear in a tuple while we are destructuring it, we can use the underscore character to signify it. Effectively, what we are saying to the Elm REPL is—d<em>on't pay attention to these values</em>. Let's rewrite the previous example so that it works with underscores:</p>
<pre><strong>let \</strong><br/><strong>  (a,_,_,_,e) = aTupleOfStrings \</strong><br/><strong>in \</strong><br/><strong>  a ++ e</strong></pre>
<p>The Elm REPL responds with the following:</p>
<pre><strong>''HelloWorld'' : String</strong></pre>
<p>Let's replace the one-letter variables with something more meaningful:</p>
<pre><strong>let \</strong><br/><strong>  (greeting,_,_,_,planetDescription) = aTupleOfStrings \</strong><br/><strong>in \</strong><br/><strong>  greeting ++ planetDescription</strong></pre>
<p>The Elm REPL will still return the same result.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring tuples in Elm using case-of expressions</h1>
                </header>
            
            <article>
                
<p>In this section, we will destructure tuples using <kbd>case-of</kbd> expressions. To see the effects of tuple destructuring, we'll have to use the Ellie app rather than Elm REPL. To begin, let's set up the following basic example in the Ellie app:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (Html, text)<br/><br/>greeting = ("Hello", "World")<br/><br/>main : Html msg<br/>main =<br/>    case greeting of <br/>        ("Hello", "World") -&gt;<br/>            text "Tuple contained: Hello, World!"<br/>            <br/>        ("Hello", _) -&gt;<br/>            text "Tuple contained: Hello "<br/><br/>        (_, "World") -&gt;<br/>            text "Tuple contained: World!"<br/><br/>        (_, _) -&gt;<br/>            text "There were neither 'Hello' nor 'World' in the greeting Tuple"</pre>
<p>What the preceding code does should be easy to understand—using the values from the greeting variable, the main function will pattern-match using the case-of expression, and return text based on the values destructured from the tuple.</p>
<p>First we check for literal match on both <kbd>Strings</kbd> in the two-tuple of <kbd>greeting</kbd>. Then, we check for literal match on only the first <kbd>String</kbd>. Next, we check only for the match of the <kbd>"World"</kbd>—the second <kbd>String</kbd> in our greeting two-tuple. Finally, we cover all other possible cases by matching for anything else, using the following pattern:</p>
<pre>(_, _) -&gt;</pre>
<p>Let's now test our application with various combinations. First, we'll use the code as is. Pressing the <span class="packt_screen">Compile</span> button in the Ellie app will produce the following text printed to the screen:</p>
<pre>Tuple had: Hello, World!</pre>
<p>Let's change the greeting tuple so that it looks as follows:</p>
<pre>greeting = ("Howdy", "World")</pre>
<p>Now, compile the Ellie app, and you should get the following:</p>
<pre>Tuple had: World!</pre>
<p>Finally, let's try changing the greeting to this:</p>
<pre>greeting = ("Howdy", "Earth")</pre>
<p>Upon compilation, the Ellie app will produce the following output:</p>
<pre>There were neither 'Hello' nor 'World' in the greeting Tuple</pre>
<p>In the next section, we'll use our newly-found knowledge of tuple destructuring and apply it in an improved version of our FizzBuzz app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building a FizzBuzz app using tuple destructuring inside of a case-of expression</h1>
                </header>
            
            <article>
                
<p>Let's revisit our FizzBuzz problem. This time we can use our modulus operations as conditions of a <kbd>case</kbd> expression. The code will be as follows:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>n = 100<br/>modulusTest = (n % 3, n % 5)<br/><br/>main : Html msg<br/>main = <br/>  text &lt;| let fizzBuzz n = <br/>              case modulusTest of<br/>                (0, 0) -&gt; "fizzBuzz"<br/>                (0, _) -&gt; "fizz"<br/>                (_, 0) -&gt; "buzz"<br/>                (_,_) -&gt; toString n<br/>          in fizzBuzz n</pre>
<p>To keep the preceding code concise, we have set the value of <kbd>n</kbd> to a single fixed number of 100. Feel free to test out the app by replacing that value with a different number.</p>
<p>The preceding code should be easy to understand—we set our <kbd>modulusTest</kbd> to a tuple that contains the calculation of <kbd>n % 5</kbd> and <kbd>n % 3</kbd>. Then, in <kbd>main</kbd>, we use the <kbd>text</kbd> function on the <kbd>let-in</kbd> expression. The <kbd>&lt;|</kbd> is the backward function application operator. It takes the value that gets evaluated to its right, and passes it as an argument to whatever sits on its left—in this case, a <kbd>text</kbd> function. Essentially, it is used in place of parentheses. In other words, we could have written the <kbd>main</kbd> function as follows:</p>
<pre>main = <br/>  text (let fizzBuzz n = <br/>              case modulusTest of<br/>                (0, 0) -&gt; "fizzBuzz"<br/>                (0, _) -&gt; "buzz"<br/>                (_, 0) -&gt; "fizz"<br/>                (_,_) -&gt; toString n<br/>        in fizzBuzz n)</pre>
<p>It would do the exact same thing as the code we used prior to the preceding snippet. Finally, our case expression takes the value returned from the calculations performed in <kbd>modulusTest</kbd> and pattern-matches it to appropriate values. The beauty of this setup is that now it is very easy to check for different numbers. For example, we could print out threes and sevens, as follows:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>n = 70<br/>modulusTest = (n % 3, n % 7)<br/><br/>main : Html msg<br/>main = <br/>  text (let fizzBuzz n = <br/>              case modulusTest of<br/>                (0, 0) -&gt; "Divisible by 21, seven, and three"<br/>                (0, _) -&gt; "Divisible by three"<br/>                (_, 0) -&gt; "Divisible by seven"<br/>                (_,_) -&gt; toString n<br/>        in fizzBuzz n)</pre>
<p>Let's now look at how to destructure tuples inside of tuples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring nested tuples using let-in expressions</h1>
                </header>
            
            <article>
                
<p>Let's try this in Elm REPL:</p>
<pre><strong>nestedTuples = (1, 2, 3, (5, 10, 15, (100, 50, 0)))</strong></pre>
<p>The REPL will return the following:</p>
<pre><strong>(1,2,3,(5,10,15,(100,50,0)))</strong><br/><strong>    : ( number</strong><br/><strong>      , number1</strong><br/><strong>      , number2</strong><br/><strong>      , ( number3, number4, number5, ( number6, number7, number8 ) )</strong><br/>      )</pre>
<p>Next, let's destructure the value of <kbd>i</kbd> from the innermost tuple:</p>
<pre><strong>let \</strong><br/><strong>  (a, b, c, (d, e, f, (g, h, i))) = nestedTuples \</strong><br/><strong>in \</strong><br/><strong>  i</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>0 : number</strong></pre>
<p> Note that we did not even have to declare the <kbd>nestedTuples</kbd> variable. Instead, we could have destructured values on the fly, inside the let-in statement. For example, let's use the Ellie app to compile the following code:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>main : Html msg<br/>main = <br/>  text (toString (<br/>              let <br/>                  (a,b,c,(d,e,f,(g,h,i))) = (1, 2, 3, (5, 10, 15, (100, 50, 0)))<br/>              in<br/>                  i<br/>              ))</pre>
<p>Finally, we could have used the underscore when suitable, as follows:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>main : Html msg<br/>main = <br/>  text (toString (<br/>              let <br/>                  (_,_,c,(_,_,f,(_,_,i))) = (1, 2, 3, (5, 10, 15, (100, 50, 0)))<br/>              in<br/>                  i<br/>              ))</pre>
<p>With this, we wrap up our discussion of tuple destructuring. Next, we'll look at record destructuring.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring records in Elm using let-in expressions</h1>
                </header>
            
            <article>
                
<p>Records in Elm are destructured similar to tuples. Let's rewrite our example of race times using a record instead of a tuple. Compile the following app in the Ellie app:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>raceTimes = { first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }<br/><br/>averageRunnerTime record =<br/>    let <br/>        {first, second, third, fourth, fifth} = record<br/>    in<br/>        (first + second + third + fourth + fifth) / 5<br/>        <br/>main : Html msg<br/>main = <br/>  text (toString (<br/>              averageRunnerTime raceTimes<br/>              ))</pre>
<p>Once compiled, the following text should be displayed on the screen:</p>
<pre>72.2</pre>
<p>The code used in the preceding app is essentially the same code we used in the example on destructuring tuples. The difference comes  from the way that records work in Elm—since they <em>must</em> have named values, we <em>must</em> use these names when destructuring values out of records.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring records on the fly</h1>
                </header>
            
            <article>
                
<p>When destructuring records, we don't even have to use the underscore character. Since all the values in a record are named, it's enough to use that name to extract the value from a record. Using our previous example of race times, let's put the record that stores them inside Elm REPL:</p>
<pre><strong>raceTimes = { first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>{ first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }</strong><br/><strong>    : { fifth : number</strong><br/><strong>      , first : number1</strong><br/><strong>      , fourth : number2</strong><br/><strong>      , second : number3</strong><br/><strong>      , third : number4</strong><br/><strong>      }</strong></pre>
<p>Next, let's look at extracting the time of the fifth runner:</p>
<pre><strong>{ fifth } = raceTimes</strong></pre>
<p>The REPL returns the following:</p>
<pre><strong>90 : number</strong></pre>
<p>Let's use the Ellie app to destructure the time of the fifth runner:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>extractorFunction { fifth } =<br/>    fifth<br/>    <br/>raceTimes = { first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }<br/>fifth = raceTimes<br/><br/>main : Html msg<br/>main = <br/>  text (toString (<br/>              extractorFunction raceTimes<br/>              ))</pre>
<p><span>But why do we need to use our custom <kbd>extactorFunction</kbd>? </span>Can't we just go without it? Let's try this:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>    <br/>raceTimes = { first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }<br/>fifth = raceTimes<br/><br/>main : Html msg<br/>main = <br/>  text (toString (<br/>              fifth<br/>              ))</pre>
<p>Upon compilation, the Ellie app will print this on the screen:</p>
<pre>{ first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }</pre>
<p>If we really wanted to do it without the extractor function, we could have done it like this:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>    <br/>raceTimes = { first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }<br/>fifth = raceTimes<br/><br/>main : Html msg<br/>main = <br/>  text (toString (<br/>              raceTimes.fifth<br/>              ))</pre>
<p>When compiled, the Ellie app will print out the expected value of <kbd>90</kbd> on the screen. <span>Finally, let's deconstruct and use only two values. We will begin with faulty code, which will throw an error. The code will look as follows: </span></p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>extractorFunction { first, fifth } =<br/>    first, fifth<br/>    <br/>raceTimes = { first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }<br/>{first, fifth} = raceTimes<br/><br/>main : Html msg<br/>main = <br/>  text (toString (<br/>              extractorFunction raceTimes<br/>              ))</pre>
<p>The preceding code, when compiled, will throw the following error:</p>
<pre><strong>SYNTAX PROBLEM</strong><br/><strong>Line 6, Column 10</strong><br/><strong>I am looking for one of the following things:</strong><br/><br/><strong>"'"</strong><br/><strong>a field access like .name</strong><br/><strong>an expression</strong><br/><strong>an infix operator like (+)</strong><br/><strong>end of input</strong><br/><strong>more letters in this name</strong><br/><strong>whitespace</strong></pre>
<p>Why? Give yourself some time to think it through. It will be a useful discovery. For the impatient reader, here is the appropriate code:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>extractorFunction { first, fifth } =<br/>    (first, fifth)<br/>    <br/>raceTimes = { first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }<br/>{first, fifth} = raceTimes<br/><br/>main : Html msg<br/>main = <br/>  text (toString (<br/>              extractorFunction raceTimes<br/>              ))</pre>
<p>The error was due to the fact that initially, we gave a confusing expression to the Elm compiler, and it simply did not know what to do with it. Let's look at the offending code again:</p>
<pre>extractorFunction { first, fifth } =<br/>    first, fifth</pre>
<p>The compiler sees: a value, a comma, and a value, and it has no idea how to return a single value from this line of code. We've already seen one way of solving this error; by extracting the values from a record into a tuple.</p>
<p>An alternative approach would be to print these values out as a string, like so:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (..)<br/><br/>    <br/>raceTimes = { first = 60, second = 65, third = 71, fourth = 75, fifth = 90 }<br/><br/><br/>main : Html msg<br/>main = <br/>  text &lt;|<br/>      toString (raceTimes.first)<br/>      ++ ", " <br/>      ++ toString (raceTimes.fifth)</pre>
<p><span>With this, we have completed our discussion of destructuring values in Elm. </span>Next, we will look into the ways in which Elm deals with randomness.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dealing with randomness in Elm</h1>
                </header>
            
            <article>
                
<p>As mentioned before, values in Elm are immutable. The functions are pure; they allow for no side effects. When a specific value goes in, a function will operate on it and always return another specific value.</p>
<p>This poses a problem—just how do we deal with randomness? For example, how do we generate random numbers? Or, for that matter, how do we perform anything that involves a side effect? We do that by<span> </span><em>having functions return commands</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Commands in Elm</h1>
                </header>
            
            <article>
                
<p>With a command, you are telling the Elm runtime to do something you are not allowed to do, since doing it would break the concept of guarantees. Thus, a command that you return from a function is just a static, immutable value. What does this value do? It just<span> </span><em>names</em><span> </span>the desired result. It does not tell Elm how to do it. It is just a name for one or more things that need to be done by the Elm runtime.</p>
<p>For example, since the concept of guarantees says that for every input into a pure function, we should receive the same kind of output, we cannot have a function return a random number, since doing so would break the concept of guarantees. In order to make the preceding scenario possible, we need to send a command to the Elm runtime,<span> </span><em>asking it</em><span> </span>to give us a random number. </p>
<p>Thus, once the Elm runtime receives a command, such as a request for a random number,<span> </span><em>it will return a message</em>. Then we can use that message in the update function, as explained in <a href="c80584ff-97c8-411b-8ec3-a4b122121579.xhtml">Chapter 2</a>, <em>Building Your First Elm App</em>.</p>
<p>The goal of this very basic introduction to commands in Elm is that there are no ambiguities about the new code that we will introduce, or, put differently, that we have at least some knowledge about what each piece of code does. Next, we'll look at subscriptions, and how they fit into the Elm architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscriptions in Elm</h1>
                </header>
            
            <article>
                
<p>Commands allow us to tell the Elm runtime to <em>do random things</em><span> </span>without breaking Elm's guarantees.</p>
<p>However, let's say we want the Elm runtime to tell us when some changes happen in the outside world (that is, anything that we cannot directly control in our app). We cannot control the changes in the outside world with commands—because<span> </span><em>we are not the source</em><span> </span>of these changes.</p>
<p>That's why subscriptions exist. They allow us to listen for things such as mouse movements, keyboard presses, time changes, and so on. With commands,<span> </span><em>we order the Elm runtime to do random things</em>; with subscriptions,<span> </span><em>the Elm runtime tells us of random things being done</em>.</p>
<p>For example, we want to track when a keyboard button is pressed. We'll have our app subscribe to those keyboard presses. Once that specific keyboard button is pressed, the Elm runtime will send a message, and in our update function, we specify how it should behave when such a message is received.</p>
<p>Now that we are familiar with commands and subscriptions in Elm, we can look at how they can be used to extend our current concept of the Elm architecture.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Improving the Elm architecture by adding effects</h1>
                </header>
            
            <article>
                
<p>Before we knew about commands in Elm, we used to implement the Elm architecture using the <kbd>beginnerProgram</kbd> function:</p>
<pre>main =<br/>  Html.beginnerProgram<br/>    { model = model<br/>    , view = view<br/>    , update = update<br/>    }</pre>
<p>However, using only <kbd>beginnerProgram</kbd>, we have no way to deal with either commands or subscriptions. Practically, our <kbd>beginnerProgram</kbd> function is just a watered-down version of the <kbd>Html.program</kbd> function.</p>
<p>Put differently, using <kbd>Html.program</kbd>, we have the ability to extend our Elm architecture so that we keep Elm's guarantees and still deal with randomness, that is, side effects, regardless of these side effects' origin.</p>
<p>Thus, rather than using<span> </span><span> <kbd>Html.beginnerProgram</kbd> (like we did previously), </span>let's see how we can set up our main function so that it is using <kbd>Html.program</kbd>:</p>
<pre>main =<br/>    Html.program<br/>        { init = init<br/>        , view = view<br/>        , update = update<br/>        , subscriptions = subscriptions<br/>        }</pre>
<p>The change in the code is minimal, but our Elm program just got a lot more capable. This concludes our brief introduction to dealing with randomness in Elm. In the next section, we will look at a very useful concept in Elm: partial application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding partial application</h1>
                </header>
            
            <article>
                
<p>Let's say we have a function that takes in two parameters. The function is very simple—it just takes two <kbd>Strings</kbd> and concatenates them, with an added space in between. </p>
<p>The function signature will look as follows:</p>
<pre>concatTwoWords wordOne wordTwo = wordOne ++ " " ++ wordTwo</pre>
<p>When we call the function, we might pass two words like this:</p>
<pre>concatTwoWords "User" "Experience"</pre>
<p>The preceding function will evaluate to the following:</p>
<pre>"User Experience"</pre>
<p>Let's now implement this as a tiny program that we can run in the Ellie app:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (Html, text)<br/><br/>concatTwoWords : String -&gt; String -&gt; String<br/>concatTwoWords wordOne wordTwo = wordOne ++ " " ++ wordTwo<br/><br/>main : Html msg<br/>main =<br/>    text (concatTwoWords "User" "Experience")</pre>
<p>Upon compilation, the Ellie app will show the words <span class="packt_screen">User Experience</span> in the right-hand preview pane:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e194a6f6-022b-4b74-81bf-b5aa243198db.png"/></div>
<p>Note that we have also added type annotation preceding the function definition. The type annotation reads:</p>
<pre>concatTwoWords : String -&gt; String -&gt; String</pre>
<p>Looking at the type annotation, we could say that our <kbd>concatTwoWords</kbd> function takes two strings and returns a string. After all, that is what the type annotation looks like. What would happen if we passed only one argument to our <kbd>concatTWoWords</kbd> function? Let's try it. Run the following code in the Ellie app:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (Html, text)<br/><br/>concatTwoWords : String -&gt; String -&gt; String<br/>concatTwoWords wordOne wordTwo = wordOne ++ " " ++ wordTwo<br/><br/>main : Html msg<br/>main =<br/>    text (concatTwoWords "User")</pre>
<p>This time we got a <kbd>Type Mismatch</kbd> error, which reads as follows:</p>
<pre><strong>The argument to function text is causing a mismatch.</strong><br/><br/><strong>Function text is expecting the argument to be:</strong><br/><br/><strong>String</strong><br/><strong>But it is:</strong><br/><br/><strong>String -&gt; String</strong><br/><strong>Hint: It looks like a function needs 1 more argument.</strong></pre>
<p>So, obviously, if our function is expecting two arguments, we can't just pass one argument to it and call it a day, since, as we have just seen, that will cause the compiler to throw an error.</p>
<p>Instead, what we can do is a neat little trick. We can define a new function. This new function that we'll define will store the result of passing only one String to <kbd>concatTwoWords</kbd>. In other words, it will store the result of partial application of the <kbd>concatTwoWords</kbd> function.</p>
<p>For lack of a better name, we will give this new function the name <kbd>partiallyApply</kbd>, and define it as follows:</p>
<pre>partiallyApply = concatTwoWords wordOne</pre>
<p>What we have done here is that, we have <em>partially applied</em> our <kbd>concatTwoWords</kbd> function by <em>passing it only one argument.</em> Then, we stored the result in another function that we called <kbd>partiallyApply</kbd>. We can still pass an argument to our <kbd>partiallyApply</kbd> function, and we will store it in the <kbd>partiallyApplyAgain</kbd> function, as follows:</p>
<pre>partiallyApplyAgain = partiallyApply wordTwo</pre>
<p>The updated code, ready to be run in the Ellie app, will now look as follows:</p>
<pre>module Main exposing (main)<br/><br/>import Html exposing (Html, text)<br/><br/>wordOne = "User"<br/>wordTwo = "Experience"<br/><br/>concatTwoWords : String -&gt; String -&gt; String<br/>concatTwoWords wordOne wordTwo = wordOne ++ " " ++ wordTwo<br/><br/>partiallyApply = concatTwoWords wordOne<br/>partiallyApplyAgain = partiallyApply wordTwo<br/><br/>main : Html msg<br/>main =<br/>    text (partiallyApplyAgain)</pre>
<p>Running the preceding code will result in the words <kbd>User Experience</kbd> displayed on the right-hand pane of the Ellie app.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have covered a number of important topics, namely:</p>
<ul>
<li><span>Destructuring values in Elm</span></li>
<li><span>How does Elm deal with randomness?</span></li>
<li>Understanding partial application</li>
<li>Introducing effects to our apps by using <kbd>Html.program</kbd></li>
</ul>
<p>In the next chapter, we will begin building a fully functional weather app which will connect to a remote API to fetch weather information.</p>
<p> </p>
<p> </p>


            </article>

            
        </section>
    </body></html>