- en: Chapter 2. Using Arrays, Nesting, and Grids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''ve had a taste of KnockoutJS, we are now ready to learn new coding
    skills. In this chapter, we will see how to extend our MVVM skills to make a lot
    more sweet data interaction experiences. This chapter will focus on:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler nested binding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observable arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Paged grids
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting data collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data binding is the essence of many new libraries that interact with the HTML
    markup as it gets converted to the DOM. We saw binding in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with KnockoutJS"), *Getting Started with KnockoutJS*,
    using the `data-bind ="..."` bindings. Here we will be looking at conditional
    binding.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we will do is understand the concept of conditional binding.
    Our example is meant to be conceptual. We will show a more practical example shortly
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `if` binding plays a very similar role to the visible property in the DOM.
    The difference is that the `if` binding actually adds and removes the content
    from the DOM whereas visible swaps the CSS display style between visible and none.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file by copying the `_base.htm` file, located in the `ko_2/do`
    folder, and naming it `condition.htm` within the `do` folder. If you get stuck,
    there is a completed copy inside the `done` folder. To make things look better,
    we will now be using the larger Bootstrap template base as it will give us better
    presentation. You will see the following area in the markup code, which is where
    you will place the code for the rest of the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You will place the rest of the code in the same place as explained in [Chapter
    1](ch01.html "Chapter 1. Getting Started with KnockoutJS"), *Getting Started with
    KnockoutJS*. Again, this is just to make our work look better as we go through
    the rest of the book. Now, enter the following code in the markup section of the
    `htm` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give us a checkbox to toggle our content. We will create a variable
    called `showDetails` to bind our content toggle in the `script` section of the
    page. When the checkbox is checked, the content will be added, and when the checkbox
    is unchecked, the content will be removed. Here is the content for the `script`
    section of the `.htm` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing complex here. We just have a variable that will hold our true
    or false state. When the variable is true, the content will be added, and when
    the variable is false, it will be removed from the page. Here is what it will
    look like when the value is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Conditional binding](img/1028OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Go ahead and run the code in the browser and toggle the content by setting the
    checkbox as checked and not checked a few times to make sure your code is working.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to arrays in Knockout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by working with an unbound array. You will see that Knockout
    is smart enough to still work with the array and display the contents correctly.
    In fact, the array we will start out with will be an array with nested data. Add
    the highlighted data to the `script` section of our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The employee array data will automatically bind to the MVVM system when we
    run our `applyBindings` function on the page. We will need some markup to tell
    us that it has actually worked. I suggest separating the section of content on
    the page using the `<hr/>` tag just for clarity. Now add the following code to
    the markup section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We learn a few new commands now with Knockout. The first is the `foreach` command.
    If we have an array, which I refer to as a collection, this will look through
    each item. We tell the `foreach` loop to loop through the employee array collection.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you will notice is that the elements of the collection are addressed
    at the item level. In other words, we do not need to use `myVM.employee.name`;
    instead, we simply use `name`. This makes for much cleaner code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also see we are using the `if` command again. We have also thrown
    in the opposite logic command, `ifnot`. If a null result is returned, then it
    is understood to be the same thing functionally as a false value. This means if
    a person does not have a spouse, they will be marked as available. Hint: this
    would likely cause social waves if you ran a page in your company declaring who
    was available, so this is definitely not suggested as the best practice for a
    company web page.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to arrays in Knockout](img/1028OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When we run the code, we get the result as shown in the preceding screenshot.
    We see that Bill is not married as expected. Since we know it would not be a good
    idea to post that someone is available there is a simpler way to display this
    same information while skipping the risky classification. We will copy the code
    section and repeat it using the `with` command in place of the `if` command as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is what the page looks like when we run the `with` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to arrays in Knockout](img/1028OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now I am not saying that `with` is safer than `if` from a technical perspective.
    You will need to think through your business logic smartly just like you would
    think about the social issues in this example. Take a few moments and think about
    the business requirements as the issues that are there are not always technical
    issues. We need to make sure the technical code is taking care of any business
    issues that we should know about as we do our work.
  prefs: []
  type: TYPE_NORMAL
- en: Working with array collections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s copy our `_base.htm` file to `arrays.htm` in the `do` folder to continue
    our study of array collections in Knockout. First, add our core markup to the
    new page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We will again need to create a data model in the `script` section for this
    to work. The following is the code for the data section. Here is where we will
    start using an observable array. Knockout uses additional logic to handle arrays
    than it does for simple variable types. These arrays can be a collection of simple
    variables or nested rows of complex structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Run the page and make sure you get the following result. Of course, if you modified
    the data, you get bonus points for exploring and enjoying the work. In that case,
    your results will look slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with array collections](img/1028OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will be adding four different buttons to experience working with array collections
    using observable arrays in Knockout. Before we do that, here are the functions
    we can perform on array methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `push()` | Adds item to the end of the collection |'
  prefs: []
  type: TYPE_TB
- en: '| `pop()` | Removes the last item from the collection |'
  prefs: []
  type: TYPE_TB
- en: '| `unshift()` | Inserts a new item at the start of the collection |'
  prefs: []
  type: TYPE_TB
- en: '| `shift()` | Removes the first item from the collection and returns it |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse()` | Swaps the order of items in the collection |'
  prefs: []
  type: TYPE_TB
- en: '| `sort()` | Sorts the order of the collection (requires a sorting function)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `splice()` | Removes a given number of elements from the collection beginning
    at a declared starting point |'
  prefs: []
  type: TYPE_TB
- en: '| `remove()` | Removes all values that equal something and returns them as
    an array; this can also be run as a function for identifying items |'
  prefs: []
  type: TYPE_TB
- en: '| `removeAll()` | Removes all items from an array list or removes everything
    and returns removed items as an array |'
  prefs: []
  type: TYPE_TB
- en: '| `destroy()` | This the **Ruby on Rails** (**RoR**) version of `remove()`
    to make things more familiar to RoR developers |'
  prefs: []
  type: TYPE_TB
- en: '| `destroyAll()` | This is the RoR version of `removeAll()` to make things
    more familiar to RoR developers |'
  prefs: []
  type: TYPE_TB
- en: 'We will start by adding a button to the page to work with reversing the array
    collection order. On this page, we will be practicing interacting with the data
    model by using functions outside the MVVM binding of Knockout. We will still be
    interacting with the binding results. This will help build inside and outside
    coding skills to use Knockout in different scenarios. Use the following code to
    make a button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You see here that we are running the JavaScript directly from the button using
    the `reverse` method of the array collection. Add this button and run the page
    again. After clicking on the button, you will see that all of the items in the
    array collection are now in reverse order. Click on it again and again and you
    will see it will reverse the items each time you click. If you compare the previous
    screenshot with the following screenshot, you can see the items in the array collection
    are reversed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with array collections](img/1028OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While this is all nice, dynamic websites are sites that need to have data added
    and removed. We will get started learning about this right now in this chapter.
    The first thing we will do is create a button to add staff. Add the highlighted
    code here to the markup section of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Working with array collections](img/1028OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You see the `addStaff` function that we need to add staff to our page attached
    to the `onClick` event handler of the button. We will need to use the `push` method
    of our bound array collection to add this in. Add the following function to the
    `script` section of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the code, it should add the new employee as expected. The
    `push` method will always add the item to the end of the collection, as seen in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with array collections](img/1028OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s refresh the page and follow these steps in order to verify that assumption:'
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Reverse Sort Staff** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Add Staff** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Reverse Sort Staff** button one more time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And here is the output image you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with array collections](img/1028OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If all we wanted to do was put the item at the top of the list, it would have
    been too much work. This will become especially true as we begin to work with
    larger and larger sets of data. To insert an item at the start of the array collection,
    we will use the `unshift` method in place of the `push` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now is there anyone besides me who thinks the term `unshift()` is just strange?
    Perhaps that will help us remember it easier!
  prefs: []
  type: TYPE_NORMAL
- en: Removing the last item
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We saw how `push` added the item to the end of the data; now we can take a
    look at pulling the last item off the array collection. If you use the `pop` method,
    it will not be the last item added to the end of the data, but the last item on
    the collection. This will be the last item showing on the page at the bottom of
    the list of employees; in our case, we will use the following lines code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now add a staff member using the **Add Staff** button and you will get the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the last item](img/1028OS_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see things working just like before. Now there are four staff members. We
    are now going to remove the last item using the inline JavaScript code within
    our button's `onClick` method. This has the opposite effect of the `push` function
    that adds an item to the end of the array collection. It removes the very last
    item of the array collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the view you should have after clicking on the **Remove Staff** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the last item](img/1028OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Try clicking on the **Reverse Sort Staff** button followed by the **Remove
    Staff** button. This time, you should see **John Jones** gone from the bottom
    of the list, and the list should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing the last item](img/1028OS_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sorting time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Displaying data is a very common use case for web pages. Perhaps the most common
    function people perform on data besides searching is sorting. We are going to
    look at how to sort data based on particular data fields. This time, we will create
    the logic first. Enter the following code into the `script` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We will break down the logic for those unfamiliar with this level of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: The `sort` function passes in two structures. Each structure matches the items
    being sorted. The variable name could be anything; we choose `left` and `right`
    because it helps the programmer remember which variable is which. You can use,
    of course, any variable naming you choose. Each variable contains the whole structure
    of the item being passed in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The basic return value for `sort` needs to be true or false. This tells the
    program whether the two items should be swapped. This is why they return a value
    using the ternary symbols. It is likely that these are not symbols you used in
    high school math, so they will be foreign to most of us. Here is an explanation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First, there is a logical comparison followed by the `?` symbol; symbolizing
    the value before `?` tells us whether the results should be based on true or on
    false.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The first value is what should be returned if the results are true.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then there is a colon to represent the results that should be returned if the
    logic evaluation is false.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You should see here that the logic can be stacked to perform a second logical
    evaluation if desired. This could be in either the true or false position.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The second value will be what is returned if the value is false. Again, in this
    example, we observe a nested logic that is run when the results are false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the same logic in an `if` statement for the sake of comparison:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: One of the things you should notice is that there is definitely less code using
    the ternary operator approach. This doesn't mean using the `if` approach is wrong;
    it's just more code to get right, and the more code we type, of course, the more
    time we are likely to spend debugging. If you don't have a standard where you
    work and prefer to use the `if` logic, feel free to go that way. My main goal
    was to show you what many experienced developers do so you could understand the
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s add the button to call the code in the markup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is what you should see before the sort button is clicked on:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Sorting time](img/1028OS_02_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Notice that it sorts alphabetically based on the first name because the whole
    name is stored as a single field. This is what we expected, and it is working
    correctly if it looks the same as in the following image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Sorting time](img/1028OS_02_13.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Now, let's add a staff member to see whether it will sort properly with the
    added item:![Sorting time](img/1028OS_02_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Sort Staff** button to see whether our added item appears properly
    in the employee list:![Sorting time](img/1028OS_02_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The simpleGrid plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like jQuery allows for custom plugins, it is possible to use plugins with
    Knockout as well. Here, we are going to use a simple plugin to add grid functionality
    to our page. This plugin also smartly adds paging to the page. We will also do
    some simple CSS to set our grid so it loosens up the space between the cells in
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason we code with jQuery, KnockoutJS, Bootstrap, and other **Don't Repeat
    Yourself** (**DRY)** libraries is that they package our work. We don't have to
    rethink, recode, or repeat our work when this is done. Using solutions such as
    jQuery and KnockoutJS, we can DRY out our code by adding our own library extensions.
    The simple grid plugin is an example of this.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we will cover enough detail in this book that by the end you should
    be able to modify this plugin or build your own. However, you will have to understand
    JavaScript, CSS, HTML, and other topics enough to get the job you are seeking
    to DRY out. Regarding KnockoutJS, you will get the knowledge you need from this
    book. (The `simpleGrid` code was acquired from the KnockoutJS main site. It is
    not part of the core but great learning code just the same.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `_base.htm` copy and create a new page in the `do` folder of `ko_2`,
    named `paged.htm` for this exercise. The first modification we will make is adding
    the highlighted line after the `include` tag for Knockout.js near the bottom of
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds in the logic we need for the simple grid plugin for Knockout. Now
    we can create the markup for our exercise. In the markup section, add the following
    markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Look closely at the `data-bind` attribute of the `div` tag. You should notice
    a new command attribute called `simpleGrid`. This is not part of Knockout by default.
    It has been added by our plugin. The `orderVM` attribute that follows is a root
    structure in our ViewModel. This elegant code teaches you how to package your
    code. It is so much simpler and easier to reuse your work or even take advantage
    of the work of others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through this code. First, we will add in some data for the grid within
    the `script` tag section. This code will be a standard array collection. Take
    a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will add our ViewModel to bind using Knockout. Add the following code
    to the page in the `script` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Running the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a common manner in which you will see code for Knockout. Let''s run
    the code and make some observations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the code](img/1028OS_02_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We see that our data displays as expected with the names of the collection
    item fields listed as the column names. It also added a paging item to the bottom
    automatically. This is the default configuration when running the code for the
    `simpleGrid` plugin. The default page size is 5 records per page. Notice that
    the columns are all squished together. Let''s begin by adding the following line
    of code to the CSS styles on our page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![Running the code](img/1028OS_02_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This looks much better with this simple modification. If you are using this
    grid and actually need more control over the style, you can use the cascading
    logic in CSS and nest the table inside a second `div` tag to create an ID or class
    to manage tables contained within that class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to modify the columns and the default number of columns that
    show by setting the configuration. Add this highlighted code to our `script` section
    on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With the columns detail declared and the page size set, we see the greater
    value of using DRY code. This has enabled us to manage the ViewModel from our
    scripted code. This is our result with our code at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the code](img/1028OS_02_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now you can click through to page 2 to see how this grid is working. We also
    see that our columns look much better with custom column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is time to consider the best practice approach to coding with Knockout.
    Open your browser developer tools and go to **Console**. From the console, we
    want to interact with the ViewModel. Try typing the following in the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You will get a response similar to the undefined response given by Chrome. The
    model is there and working but suddenly you cannot access the model. This one
    stumped me the first time my code had this issue. The biggest stump was that my
    code came from an online example, but there was a key point I was missing. The
    online example was not interacting with the code from the command prompt and it
    was not interacting with the code from JavaScript outside the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is when we declare a `new` object within a JavaScript function,
    the object will not be available outside the call to the code. We can solve this
    by creating a variable to hold the object outside the method call and then passing
    in the object that was created outside the method argument. Let''s change the
    `applyBindings` method by making the following changes. First add the line declaring
    the variable and then update the `applyBindings` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can return to the browser developer tools and run the page again. Then
    type the new command in and notice that the first P is now in lowercase. JavaScript
    is case sensitive, so make sure you get your upper and lowercase right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you should see an array of collection items. I expanded the first one so
    we could see the results from Chrome here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the code](img/1028OS_02_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you are using JavaScript and it is not connecting to your ViewModel, then
    you might want to make sure you have not made the previously explained error in
    coding. This is only an issue if you need to connect to the ViewModel from outside
    the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to add some buttons below our grid for even more custom control.
    We will be adding two buttons: **Add Order** and **First Page**. Let''s add the
    **Add Order** button first. It is code we should be familiar with as we have used
    it earlier in this chapter. We are going to use it again to show that even while
    working with a completely different **user interface** (**UI**) presentation,
    when we update the data in the ViewModel, the View is automatically updated. Add
    the following code to our `script` section on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We also, of course, need the markup for the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the button, refresh the browser. Add the order and click through
    to the second page of data, and this is what it should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Running the code](img/1028OS_02_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see that the record for **Gerry Markus** has been added. We could use any
    of the code we used in earlier examples to do things like reversing or removing
    records using the array methods listed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have one more button to add that will allow us to control the grid
    page from our ViewModel. First, add the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We see the click event is wired to the ViewModel method to move to page one.
    We also see a command to enable the page index. This will make sure our index
    is updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some other methods that can be called on `simpleGrid` that have been
    listed here. You will notice that some of the items are variables while others
    are method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pagedOrderModel.orderVM.columns`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pagedOrderModel.orderVM.data()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pagedOrderModel.orderVM.currentPageIndex()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pagedOrderModel.orderVM.itemsOnCurrentPage()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pagedOrderModel.orderVM.maxPageIndex()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pagedOrderModel.orderVM.pageSize`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, if you use these items bound to the Knockout `data-bind` attributes,
    you don't always need the parenthesis. This topic was covered in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with KnockoutJS"), *Getting Started with KnockoutJS*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final `script` section should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Final sort
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Congratulations on creating a fairly functional piece of code using Knockout!
    Yet, what would data interaction be without the ability to sort? We are going
    to see how to take the sorting we did earlier and modify it to make it more dynamic
    than our previous example with a few simple modifications. You can just continue
    to modify the current page or you could copy the page as `sorting.htm` as that
    is how we approached it. Note that this is completely a matter of choice as it
    will only serve to make your `do` folder match our `done` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following two buttons to your page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'In our previous example for sorting, we did not pass in any values during the
    method call. Here, we are passing the name of a field in our data that tells us
    what we will be sorting with. This follows our theme of DRY coding as we are able
    to use the same command for either of these buttons or in any future code that
    matches. Here is the `script` code we need to add to actually do the sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As simple as it seems, this is all the code it takes to create a reusable piece
    of code allowing us to sort when desired. Here is a screenshot showing name-based
    sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final sort](img/1028OS_02_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is another screenshot based on item sorting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final sort](img/1028OS_02_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Why don''t you create one more button to sort based on quantity as an exercise
    to see whether you have it figured out. The following screenshot is what the table
    should look like if you get it right. We will do one more thing though. We need
    to make sure our sort is out of order, so click on the **Sort By Name** button
    first. Then, clicking on the **Sort By Quantity** button should give us this result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final sort](img/1028OS_02_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we should modify the table so that we can do reverse sorting. Basically,
    all that is needed is for us to flip our greater than sign in our code where we
    compare the left and right items passed from the sorting logic. We will, of course,
    also need another argument in our method because we want to reuse our code. Since
    the sort direction is not always passed in, we will also include a line to set
    ascending sort as the default choice if one is not declared. The `script` code
    should look like this with the changes highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We will, of course, need a new set of buttons for the reverse sort as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the view with the reverse sort on the quantity column labeled **Count**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final sort](img/1028OS_02_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever built any JavaScript pages with this much interaction with
    your data using JavaScript or even with jQuery, then you will know why the library
    deserves the title of Knockout. The amount of power we have gained using this
    library in just two chapters is compelling. Through this chapter you should have
    gained the ability to do conditional binding, nested binding, observable array
    collections, adding and deleting records in array style management, and sorting
    observable arrays. You even got a quick look at a Knockout plugin.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn to drive web forms with the power of Knockout.
    They think differently; and for a few, that is the first reaction. It is an interesting
    double take as the second reaction that nearly instantly follows is that it is
    better. Event binding is also a topic we will dig into in the next chapter with
    special focus on the over-the-top punch Knockout gives us when dealing with grid
    forms.
  prefs: []
  type: TYPE_NORMAL
