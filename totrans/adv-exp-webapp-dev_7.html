<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Production"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Production</h1></div></div></div><p>In this chapter we will <a id="id216" class="indexterm"/>discuss putting an Express application into production. We start this chapter by making our Express application a bit more robust as we look at handling exceptions. We then take a look at a series of performance improvements we will need to make in order for our application to survive in a production environment.</p><div class="section" title="Error handling, domains, and crash-only design"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Error handling, domains, and crash-only design</h1></div></div></div><p>The Node community <a id="id217" class="indexterm"/>has embraced a <a id="id218" class="indexterm"/>crash-only design pattern, <a id="id219" class="indexterm"/>which simply means this: if you get an uncaught exception, catch it, log it, <a id="id220" class="indexterm"/>and restart the process. Crash-only design and <a id="id221" class="indexterm"/>domains work quite well as a pattern, particularly if your <a id="id222" class="indexterm"/>application is using <code class="literal">cluster</code>. Let's make a change to our <code class="literal">cluster</code> module, <code class="literal">./lib/cluster/index.js</code>, on <code class="literal">vision-core</code>. Here, we include the <code class="literal">domain</code> module; instead of simply including our module to run in a cluster, we create a domain and call the <code class="literal">run</code> method. We then include a domain-based <code class="literal">error</code> handler that logs and then closes the process via <code class="literal">process.exit(1)</code>. The cluster <code class="literal">exit</code> handler will pick this up and <code class="literal">fork</code> a new process:</p><div class="informalexample"><pre class="programlisting">var cluster = require('cluster')
, http = require('http')
, numCPUs = require('os').cpus().length
, logger = require('../logger')
, domain = require('domain');

function Cluster() {}

Cluster.prototype.run = function(module) {
  if (cluster.isMaster) {
    for (var i = 0; i &lt; numCPUs; i++) {
      cluster.fork();
    }

    cluster.on('exit', function(worker, code, signal) {
      logger.info('Worker ' + worker.process.pid + ' died');
      cluster.fork();
    });
  } else {
    var d = domain.create();

    d.on('error', function(err) {
      logger.info('Error ', err);
      process.exit(1);
    });

    d.run(function() {
      require(module);
    });
  }
}

module.exports = Cluster;</pre></div></div></div>
<div class="section" title="Redis sessions"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec70"/>Redis sessions</h1></div></div></div><p>The majority of Express <a id="id223" class="indexterm"/>applications in <a id="id224" class="indexterm"/>production that require session support will probably use Redis, so making Redis performant is quite important. Our Redis client, <code class="literal">node-redis</code>, uses a pure JavaScript parser; the node-redis documentation suggests using an alternative module for parsing.</p><p>Hiredis<a id="id225" class="indexterm"/> is a binding to the official Hiredis C library; it's non-blocking and fast. If you install <code class="literal">hiredis</code>, node-redis will use it by default. Let's install Hiredis on <code class="literal">vision-core</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd vision-core</strong></span>
<span class="strong"><strong>npm install hiredis redis --save</strong></span>
</pre></div></div>
<div class="section" title="SSL termination"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec71"/>SSL termination</h1></div></div></div><p>
<span class="strong"><strong>SSL termination</strong></span>
<a id="id226" class="indexterm"/> is the term given to the decrypting of a TLS-encrypted (HTTPS) stream<a id="id227" class="indexterm"/> into plain text (HTTP). The TLS module in Node core is not as fast as some other technologies used for terminating SSL and is generally not used in production. Our application runs entirely over HTTPS, so TLS performance is vital.</p><p>Fortunately, we have options for SSL; we will use <code class="literal">stud</code>, a network proxy that terminates TLS/SSL connections and forwards the unencrypted traffic to a web server. Stud is built on <code class="literal">libev</code> and is non-blocking; it is designed to handle tens of thousands of connections efficiently on multicore machines. Let's<a id="id228" class="indexterm"/> clone the stud GitHub repository:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>git clone http://github.com/bumptech/stud.git</strong></span>
</pre></div><p>Now compile stud from source:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd stud</strong></span>
<span class="strong"><strong>make</strong></span>
<span class="strong"><strong>sudo make install</strong></span>
</pre></div><p>When the <a id="id229" class="indexterm"/>installation is complete, we can generate a stud file. Stud comes with a default configuration that we can request via:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd vision-web</strong></span>
<span class="strong"><strong>stud --default-config &gt; stud.conf</strong></span>
</pre></div><p>Our stud file, <code class="literal">./vision-web/stud.conf</code>, requires a couple of important changes for it to work; the <code class="literal">frontend</code> configuration should be set to port <code class="literal">8443</code>, and the <code class="literal">backend</code> configuration should be set to our Hipache load balancer for <code class="literal">vision-web</code>, which we have hosted on port <code class="literal">3003</code>. Finally, we set <code class="literal">pem-file</code>, which is a single PEM file that includes an SSL certificate and private key:</p><div class="informalexample"><pre class="programlisting"># stud(8), The Scalable TLS Unwrapping Daemon's configuration

# Listening address. REQUIRED.
# type: string
# syntax: [HOST]:PORT
frontend = "[127.0.0.1]:8443"

# Upstream server address. REQUIRED.
# type: string
# syntax: [HOST]:PORT.
backend = "[127.0.0.1]:3003"

# SSL x509 certificate file. REQUIRED.
# List multiple certs to use SNI. Certs are used in the order they
# are listed; the last cert listed will be used if none of the others match
# type: string
pem-file = "lib/secure/vision.pem"

# EOF</pre></div><p>Now that we have our stud configuration in place, our Hipache load balancer will no longer need to terminate SSL. Let's remove the SSL configuration from our Hipache configuration, <code class="literal">./vision-web/config/server.json</code>:</p><div class="informalexample"><pre class="programlisting">{
"server": {
    "accessLog": "hipache_access.log",
    "port": 3000,
    "workers": 5,
    "maxSockets": 100,
    "deadBackendTTL": 30,
    "address": ["127.0.0.1"],
    "address6": ["::1"]
  },
  "redisHost": "127.0.0.1",
  "redisPort": 6379,
  "redisDatabase": 0
}</pre></div><p>With our <a id="id230" class="indexterm"/>configuration in place, let's <a id="id231" class="indexterm"/>create a certificate with a private key as a single PEM file. </p><p>Simply copy your <code class="literal">cert.pem</code> and <code class="literal">key.pem</code> into a single file called <code class="literal">./lib/secure/vision.pem</code>; private key first followed by your certificate.</p><p>Now, we can run stud in front of our Hipache load balancer; stud will handle SSL and will direct unencrypted traffic to Hipache as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd vision-web</strong></span>
<span class="strong"><strong>stud --config=stud.conf</strong></span>
</pre></div><p>Please run the following set of commands to run our stack behind stud:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/vision-web/hipache --config ./config/server-no-ssl.json</strong></span>
<span class="strong"><strong>/vision-api/hipache --config ./config/server.json</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>redis-cli (these may already exist in redis)</strong></span>
<span class="strong"><strong>rpush frontend:web.vision.net web.vision</strong></span>
<span class="strong"><strong>rpush frontend:web.vision.net http://127.0.0.1:3003</strong></span>
<span class="strong"><strong>rpush frontend:api.vision.net api.vision</strong></span>
<span class="strong"><strong>rpush frontend:api.vision.net http://127.0.0.1:3005</strong></span>
<span class="strong"><strong> </strong></span>
<span class="strong"><strong>/vision-web/NODE_ENV=production PORT=3003 npm start</strong></span>
<span class="strong"><strong>/vision-api/NODE_ENV=production PORT=3005 npm start</strong></span>
<span class="strong"><strong>/vision-worker/npm start</strong></span>
</pre></div></div>
<div class="section" title="Caching"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Caching</h1></div></div></div><p>Our static file requirements are <a id="id232" class="indexterm"/>minimal; the<a id="id233" class="indexterm"/> only static content we serve would be the components used on the client side of our application. In order to cache our static files/components, let's make a simple change to <code class="literal">vision-web/lib/express/index.js</code>. We set the <code class="literal">maxAge</code> property to a week, which we store in config, as follows:</p><div class="informalexample"><pre class="programlisting">app.use(express.static('public',
  { maxAge: config.get('express:staticCache') }));
app.use(express.static('public/components',
  { maxAge: config.get('express:staticCache') }));
app.use('/bootstrap',express.static('public/components/bootstrap/docs/assets/css',
  { maxAge: config.get('express:staticCache') }));
app.use('/sockets',
  express.static('public/components/socket.io-client/dist/', { maxAge: config.get('express:staticCache') }));</pre></div><p>Let's add the config value, <code class="literal">staticCache</code>, to <code class="literal">vision-web/config/*.json</code>, as follows:</p><div class="informalexample"><pre class="programlisting">  "express": {
    "port": 8443,
    "staticCache" : 6048000000
  },</pre></div><p>Now, when we hit our<a id="id234" class="indexterm"/> application, the response <a id="id235" class="indexterm"/>headers will have a cache-control header. If you visit the homepage for our application and check the response headers via your browser tools for any of the resources served, you should see:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Cache-Control:public, max-age = 86400</strong></span>
</pre></div></div>
<div class="section" title="Favicon"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec73"/>Favicon</h1></div></div></div><p>Lets add a favicon to<a id="id236" class="indexterm"/> our application using the <code class="literal">connect.favicon</code> middleware. From a <a id="id237" class="indexterm"/>performance perspective, this has some value as we can cache it. Also, your browser will request a favicon even if one does not exist, and this can result in 404 errors being thrown. We will use the existing <code class="literal">staticCache</code> config value to set <code class="literal">maxAge</code> for the favicon. Let's edit the Express server, <code class="literal">/vision-web/lib/express/index.js</code>, and add the <code class="literal">favicon</code> middleware:</p><div class="informalexample"><pre class="programlisting">app.set('views', 'views');
app.use(express.favicon('public/components/vision/favicon.ico'), { maxAge: config.get('express:staticCache') });</pre></div><div class="section" title="Minification"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec12"/>Minification</h2></div></div></div><p>We can improve page load time<a id="id238" class="indexterm"/> by minifying our static assets. We will <a id="id239" class="indexterm"/>minify our JavaScript and CSS files by installing the following two grunt tasks:</p><p>
<code class="literal">grunt-contrib-uglify</code>: This allows you to minify JavaScript files:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install grunt-contrib-uglify --save-dev</strong></span>
</pre></div><p>
<code class="literal">grunt-contrib-cssmin</code>: This allows you to minify CSS files:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install grunt-contrib-cssmin --save-dev</strong></span>
</pre></div><p>Let's add these minification tasks to our grunt file, as follows:</p><div class="informalexample"><pre class="programlisting">grunt.loadNpmTasks('grunt-contrib-uglify');
grunt.loadNpmTasks('grunt-contrib-cssmin');

uglify: {
  dist: {
    files: {
      'public/components/vision/templates.min.js':
      'public/components/vision/templates.js',
      'public/components/vision/vision.min.js':
      'public/components/vision/vision.js',
      'public/components/json2/json2.min.js':
      'public/components/json2/json2.js',
      'public/components/handlebars/handlebars.runtime.min.js':
      'public/components/handlebars/handlebars.runtime.js'
   }
 }
  },
  cssmin: {
    minify: {
      expand: true,
      src: ['public/components/vision/vision.css'],
      ext: '.min.css'
    }
  }</pre></div><p>Let's run the <a id="id240" class="indexterm"/>following <a id="id241" class="indexterm"/>commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>grunt uglify</strong></span>
<span class="strong"><strong>grunt cssmin</strong></span>
</pre></div><p>Not all of our JavaScript components have a minified version, so we minify these as well, adding a <code class="literal">.min</code> version for json2 and handlebars.</p></div></div>
<div class="section" title="Compression"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Compression</h1></div></div></div><p>We can improve page load times further <a id="id242" class="indexterm"/>by compressing static files<a id="id243" class="indexterm"/>. Express includes the <code class="literal">compress</code> middleware, which will gzip an HTTP response. Let's edit the Express server, <code class="literal">/vision-web/lib/express/index.js</code>, and add the <code class="literal">compress</code> middleware, as follows:</p><div class="informalexample"><pre class="programlisting">app.set('views', 'views');
app.use(express.logger({ immediate: true, format: 'dev' }));
app.use(express.compress());</pre></div><p>If you visit the homepage for our application and check the response headers via your browser tools for all of the resources served, you should see this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>Content-Encoding: gzip</strong></span>
</pre></div></div>
<div class="section" title="Logging"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Logging</h1></div></div></div><p>The Express<a id="id244" class="indexterm"/> server, <code class="literal">./lib/express/index.js</code>, uses the <code class="literal">logger</code> middleware<a id="id245" class="indexterm"/> for <a id="id246" class="indexterm"/>logging. The Express logger<a id="id247" class="indexterm"/> should only be used in development. In fact, in a production environment, this will seriously impact performance as console functions are synchronous. Let's change the Express server and switch off logging when in production, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">if (process.env['NODE_ENV'] !== "production")
 app.use(express.logger({ immediate: true, format: 'dev' }));</pre></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec76"/>Summary</h1></div></div></div><p>Express in commercial production environments can look a little different, but for good reason. Many of the tasks Express/Node support can be performed better by other tools. In our application, we have tried to stay on the node stack; we have chosen to use stud to terminate SSL as our entire application runs on SSL. Stud will outperform all in this space, including Nginx and Haproxy. Stud will forward unencrypted responses to Hipache, which balances load. Hipache is based on node-http-proxy; it uses cluster for failover. More importantly, unlike node-http-proxy, it can manage memory, making it a reasonable choice for a load balancer.</p><p>Hipache works well, but if it's performance you really seek, Nginx and Haproxy are the de facto tools to reach for. For failover, we are using node's cluster module, which along with domains, makes our application a little more robust.</p><p>Our static file requirements are minimal, so we have chosen to serve, cache, compress, and minify our static resources via Express. Any deviation from these minimal requirements will make me reach for either Nginx or Haproxy to deliver statics, or a Content Delivery Network.</p><p>We have managed to automate many tasks. Our code coverage is sitting at around 80 percent, running YSlow and PageSpeed on our application produces good results. Ideally, we would like to have driven all our requirements via test, driven some of the smaller code modules with unit tests, and added more acceptance tests using Cucumber. I hope that you have at least managed to get the feel of all these elements and will be able to make your own informed choices about testing.</p><p>The Node/Express stack is a great platform for building web applications. Working with full-stack JavaScript is a great development experience. The node community and the thousands of Node module developers make Node a vibrant and interesting space to work in.</p></div></body></html>