- en: Hosting the Website
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The frontend is the easiest layer to go serverless. You just need a service
    to host your website's static files, and the user's browser will download the
    files, render the pages and execute the client-side JavaScript code. On AWS, the
    service we will use to host the frontend pages is Amazon S3\. In this chapter,
    you'll also learn how to configure and optimize your website by adding a CDN and
    the supporting HTTPS connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Amazon S3 to host static files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Route 53 to associate your domain name with S3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CloudFront to serve files through a CDN
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requesting a free SSL/TLS certificate to support HTTPS connections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter, you'll have learned how to host a frontend in a serverless
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Serving static files with Amazon S3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon S3 is extremely useful because it is a cheap service that provides high
    availability and scalability, requiring zero management effort. The infrastructure
    is fully managed by AWS. In this section, we are going to use S3 to host our website
    static files such as HTML, CSS, JavaScript, and images. You will see that this
    is done by uploading the files to a bucket and configuring S3 to enable website
    hosting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides hosting static websites, you can also host complex applications. You
    just need to have a clear separation of concerns: the *frontend* files (HTML/CSS/JavaScript)
    will be hosted on S3 and will be used by the browser to render the web page and
    request additional data to the *backend* code, which will be hosted and executed
    by Lambda functions. As we are going to discuss in [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml),
    *Building the Frontend*, you can build your frontend as an SPA. This requires
    the browser to render the pages. Alternatively, you can use Lambda to serve server-side
    rendered pages.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a bucket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](246b3080-28af-4aa3-805f-5fbf9908caae.xhtml), *Getting Started
    with AWS*, we created a bucket using the CLI. In this section, we are going to
    use the Management Console to create another bucket so you can see the configuration
    options that S3 offers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to browse the S3 console at [https://console.aws.amazon.com/s3](https://console.aws.amazon.com/s3)
    and select the Create bucket option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/86450c8f-e00a-47ba-aa93-9548792ddbc2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We are creating a new bucket to host the website. If you don''t have a domain
    name, you can still use S3 to host the website. You will have to access it from
    a URL in the following format: `http://my-bucket-name.com.s3-website-us-east-1.amazonaws.com`.
    If you have a domain name, such as `example.com`, you *must* set the bucket name
    with the same name as that of your domain, in this case, `example.com`. It is
    mandatory that you match the domain with the bucket name to allow Route 53 to
    make the association. As for the region, choose the one that is closer to your
    target audience:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a6548e0d-5eaf-49f7-b6d0-c610f42eb0c1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Set properties screen allows you to add Versioning, Logging, and Tags.
    However, these are not required for our sample and can be skipped:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/792064e4-3225-4161-8878-5cc8d907efe7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Set permissions screen, under Manage public permissions, select the
    option Grant public read access to this bucket. Click on Next to continue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b6960cda-2a9c-4eff-9322-b3370fc135a9.png)'
  prefs: []
  type: TYPE_IMG
- en: Finish by reviewing the selected options and clicking on Create bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enabling web hosting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To enable web hosting in this bucket, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on your bucket name and select Properties from the second tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b84cd453-4265-4c91-84d1-c921b7ee3844.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the Static website hosting card, click on the Disabled button to enable
    the option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/016d1be0-ae61-4729-bea8-742939d11130.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now select the Use this bucket to host a website option and set Index document and
    Error document with the value `index.html`. Also, note that you can see the bucket''s
    Endpoint address in this image. It''s `http://example.com.s3-website-us-east-1.amazonaws.com`
    in this example. Write it down because you will need it later during testing and
    when you configure the CloudFront distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/79c53ba3-307f-494d-9958-a454ff6b5e0b.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Save to finish this setting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are four common ways to handle errors using S3\. I will explain the options
    you have, but before I do that, let me define what I mean by "handling errors".
    When a user makes an HTTP request, S3 may fail to get the answer and it will return
    a status code to explain the failure. An HTTP 500 *Internal Server Error* could
    be a possible result, but it would be extremely rare and odd. However, S3 returning
    either a 404 *Not Found* or 403 *Forbidden* error is pretty common.
  prefs: []
  type: TYPE_NORMAL
- en: 404 *Not Found* is an error that will be returned when the user browses your
    website for a page that does not exist. For example, if you have a page named
    `company.io/about` and the user incorrectly browses `company.io/abot`, S3 won't
    be able to find the `abot.html` file and will return a 404 error. Another example
    is when you use a JavaScript framework to create a **Single-Page Application**
    (**SPA**). Although your frontend code knows how to serve the `/about` page, the
    framework will not create a physical `about.html` file to upload to S3, and a
    404 error will be returned even when browsing `company.io/about`.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to discuss SPA in [Chapter 5](6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml),
    *Building the Frontend*. For the time being, note that an SPA can serve multiple
    pages, but there is only one complete HTML file, named `index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: 403 *Forbidden* is an error that happens when the bucket has restricted permissions.
    If the bucket doesn't allow access to *everyone* or there is a specific file with
    restricted access, the 403 error will be returned. In my opinion, I prefer to
    consider *all* the files within the bucket public. If there is a page that shouldn't
    be public, showing the HTML file should not be a problem. The objective is to
    protect the *data* and not the *layout*. Setting authorization and data visibility
    is something that needs to be handled on the server side, not the client side.
    Also, if there are static files that must remain private, such as photos, you
    can save them in another bucket instead of reusing the bucket that was created
    to host the website. These *photos* can be considered *data* and, likewise, need
    to be controlled by the backend with special care.
  prefs: []
  type: TYPE_NORMAL
- en: Considering that all the files of a bucket will remain public, and that we don't
    need not worry so much about strange S3 errors, the only problem that we need
    to handle now is 404 errors.
  prefs: []
  type: TYPE_NORMAL
- en: Using redirection rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A very common approach to handle 404 errors for an SPA is to add a redirection
    rule in the Static website hosting page using the `ReplaceKeyPrefixWith` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With this solution, when the user browses `company.io/about`, the address will
    be replaced by `company.io/#!/about` and the `index.html` file will be returned.
    If you have an SPA, it can identify which page needs to be displayed and render
    it correctly. If the page doesn't exist, it will be able to render a generic 404
    page. Also, you can configure HTML5's pushState to remove the hashbang sign (`#!`)
    after the page loads, but it will make the page to blink.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback of this approach is that you need to choose between a polluted
    URL with `#!` or experience the page blinking when it is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Using an error document
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of setting a redirection rule, you can set an error document with `index.html`.
    This is the easiest solution for SPAs. When the user requests an `/about` page
    that doesn't have a physical `about.html` file to match, the `index.html` file
    is loaded and the SPA reads the address and understands that it needs to serve
    the contents of the `/about` page.
  prefs: []
  type: TYPE_NORMAL
- en: This configuration is what we have done in the previous image and it works pretty
    well without polluting the URL address with `#!` and without blinking the page
    when loading. However, search engines may refuse to index your website because,
    when browsing the `/about` page, the result's `body` message will be set using
    the correct page, but the `status code` will still be set as 404\. If the Google
    crawler sees a 404 error, it will understand that the page doesn't exist and the
    page content is probably a generic error page.
  prefs: []
  type: TYPE_NORMAL
- en: Delegating to CloudFront
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can set the error document to `index.html`, as in the previous solution,
    but using CloudFront instead of S3\. CloudFront provides a *custom error response*
    setting that allows you to change the status code of the `response` object. In
    this case, we can configure CloudFront to act on 404 errors, returning S3's `index.html`
    file and modifying the `status code` to `200 *OK*` instead of returning 404.
  prefs: []
  type: TYPE_NORMAL
- en: If you opt for this, the problem is that you will return status code 200 even
    for pages that doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: Prerendering pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another issue with the other solutions is that **Search Engine Optimization**
    (**SEO**) is not considered, because they require JavaScript to be enabled in
    the browser to render the correct page. Since most web crawlers can't execute
    JavaScript code, they will not be able to index the webpage. This problem is solved
    with prerendering.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you are going to learn how you can prerender pages. This
    technique creates physical pages for SPA routes. For example, in an SPA, the `/about`
    page doesn't have an `about.html` file, but with prerendering, you will be able
    to create it.
  prefs: []
  type: TYPE_NORMAL
- en: When you prerender all the possible pages and upload the files to S3, there
    will be no need to worry about 404 errors. If the page exist, S3 will find an
    HTML file for it. We still need to configure the error document to `index.html` to
    handle pages that doesn't exist, but we don't need to configure CloudFront to
    force the status code 200.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting www anchors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A domain name without the **www** anchor text is usually referred to as a *naked*
    domain. For instance, `www.example.com` is a domain with the www anchor and `example.com`
    is a naked domain. The *canonical* URL is the option that you choose as the main
    address.
  prefs: []
  type: TYPE_NORMAL
- en: There are pros and cons that you'll need to consider when deciding which address
    should be your website's main one. One issue with using naked domains is that
    if your site has cookies, then placing static files in a subdomain, such as `static.example.com`,
    will not be optimized because each browser request for static files will automatically
    send cookies that were created for `example.com`. If your login happens at `www.example.com`,
    you can place static content inside `static.example.com` without worrying about
    cookies.
  prefs: []
  type: TYPE_NORMAL
- en: This issue can be mitigated by creating another domain or using a CDN to retrieve
    the static files. Despite this, the current trend is to drop the www anchor. It
    looks more modern to brand your tech company as `company.io` than it does using
    the old `www.company.com` format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose your main address, but support both formats. Some people are used to
    adding www to the address and some of them may forget to include it. In the previous
    example, we created a domain without the www address. Now we are going to create
    another bucket, in the `www.example.com` format, and set the Static website hosting
    configuration with the Redirect requests option to target the address without
    www:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/56f84f40-75d7-43b2-8448-22d3e5822a26.png)'
  prefs: []
  type: TYPE_IMG
- en: Uploading static files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Uploading is pretty straightforward. Let''s perform the following steps to
    upload static files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a very simple `index.html` file for testing purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you click on the main bucket name, an Upload button will be made available.
    Click on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5001da1d-cb8d-4bac-b7a7-9053555a0886.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screen is simple. Click on Add files, select the `index.html` file,
    and continue by clicking on Next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c04237b1-2b72-4ca1-abd2-f850d72ae508.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the Set permissions step, under Manage public permissions, select the option
    Grant public read access to this object(s):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/288cd06e-1f6c-47ae-bc94-9caafa7e11ca.png)'
  prefs: []
  type: TYPE_IMG
- en: 'At the Set properties step, keep the default option for Storage class as Standard
    because files will be frequently accessed. Also, set Encryption to None because
    all the files will be publicly available, and therefore, adding an extra layer
    of security is not necessary and will only slow down your responses. As for the
    Metadata fields, you don''t need to set them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/a8e62c85-9cd0-4528-a022-579309c94e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, review the options and confirm by clicking on Upload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you can check whether it is working by browsing the bucket's endpoint, for
    example, `http://example.com.s3-website-us-east-1.amazonaws.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it doesn't work on the first try, clear your browser cache and try again
    because when you test the endpoint before uploading a file, the browser may cache
    the information indicating that the link is invalid. This may avoid further requests
    for a short time.
  prefs: []
  type: TYPE_NORMAL
- en: Automating website publishing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have gone through the necessary steps to upload our site's frontend using
    the S3 console. It's easy and fast, but it's also pretty easy to automate this
    task. If you haven't configured the AWS CLI, as instructed in [Chapter 2](246b3080-28af-4aa3-805f-5fbf9908caae.xhtml),
    *Getting Started with AWS*, do so now and see how useful it is to automate the
    uploading of files. In fact, what we are going to do is synchronize the bucket
    contents with a local folder. The CLI will upload only the modified files, which
    will make the upload much faster in future when your site grows.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can execute the following command to upload your files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Serving gzip files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The gzip file format is a standard format used on the Web to compress files
    and improve the download speed by reducing the transferred file sizes. It can
    lower the bandwidth costs for you and for your users by providing smaller files.
    This approach has a huge impact on the perceived performance when loading the
    website.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is currently supported by every major browser. By default, for every request,
    the browser will add an `Accept-Encoding: gzip` header. If the server supports
    gzip, the file is sent in compressed form.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows an HTTP request without gzip support:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26db65cb-1b15-4635-a7ec-9b5e434a5ea4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following diagram shows how much bandwidth you can save with gzip. The
    compressed response is usually 10 times smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f75fb39d-f681-4660-a8e2-be1e28310e6b.png)'
  prefs: []
  type: TYPE_IMG
- en: With this format, the server needs CPU time to compress the file and the user's
    browser needs CPU cycles to decompress the same file. However, with modern CPUs,
    the time to compress/decompress is much lower than the extra time taken to send
    the uncompressed file through the network. Even with low-end mobile devices, the
    CPU is much faster than the mobile network.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a problem. Since we don't have server-side processing with
    Amazon S3, there is no option to natively compress files in response to requests.
    You need to compress them locally before uploading the files and setting the metadata
    to identify `Content-Encoding` as `gzip`. Thankfully, you can skip the trouble
    of including this step in the deployment workflow if you use CloudFront. As we
    are going to see later, CloudFront has an option to automatically compress all
    your files with gzip.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Route 53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Route 53 is a DNS management service. You don''t need to use it if you want
    to expose subdomains, such as `www.example.com`, however, it is indeed obligatory
    if you want to serve your website data under a naked domain, such as `example.com`,
    hosted on S3 or CloudFront. This is due to the RFC rule: you can''t have a CNAME
    record for your domain root, it must be an A record.'
  prefs: []
  type: TYPE_NORMAL
- en: What's the difference? CNAME and A records are both record types that help the
    DNS system to translate a domain name into an IP address. While CNAME references
    another domain, an A record references an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you don't want to use Route 53, you can use your own domain management
    system, such as GoDaddy, to add a CNAME that will map your `www.example.com` domain
    to an S3 endpoint, for example, `www.example.com.s3-website-us-east-1.amazonaws.com`.
    This configuration works fine, but you can't do the same for `example.com` because
    the IP address of the `example.com.s3-website-us-east-1.amazonaws.com` endpoint
    changes frequently and your third-party domain controller (GoDaddy, in this example)
    won't follow the changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you need to use Route 53 because it will allow an A record to
    be created referencing your S3 bucket endpoint, such as `example.com.s3-website-us-east-1.amazonaws.com`.
    You just need to say that this endpoint is an alias and Route 53 will be able
    to track the correct IP address to answer DNS queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a hosted zone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you register your domain address with Amazon, a hosted zone will be automatically
    created. If you register your domain with another vendor, you will need to create
    a new hosted zone.
  prefs: []
  type: TYPE_NORMAL
- en: A hosted zone allows you to configure your domain's DNS settings. You can set
    where your naked domain and subdomains are hosted and configure other parameters,
    for example, a *mail exchange* record set.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a hosted zone, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse the Route 53 Management Console at [https://console.aws.amazon.com/route53](https://console.aws.amazon.com/route53).
    You will see a welcome screen, click on Get started now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the next screen, click on Hosted zones in the left menu, followed by the
    Create Hosted Zone button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/37c1fb06-d764-4ba5-b6d7-f4bc5f9cf683.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Type the domain name and confirm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/255f2be9-668e-4bc4-9501-41b892dbb95f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'A hosted zone will be created with two record types, namely `NS` (Name Server)
    and `SOA` (Start Of Authority):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4fae923e-91c6-44ce-afdc-66a86fa97e7a.png)'
  prefs: []
  type: TYPE_IMG
- en: If you have registered your domain with another vendor, you must transfer the
    DNS management to Route 53\. This is done by changing your domain registrar Name
    Servers (NS records) to Amazon's Name Servers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your registrar may offer a control panel for your domain with an option such
    as Manage DNS. Find where the Name Servers are located and edit them to use Amazon's
    servers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating record sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s create two record sets such as one for `example.com` and another
    for `www.example.com`. Do this by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on Create Record Set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9e8c92d3-2af7-4023-b17a-4b2a60484f00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the first record, set the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name: Leave this field empty'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type: In this field, select A - IPv4 address'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alias: Check this field with Yes'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alias Target: This field is a drop-down list where you can select the S3 endpoint
    of your bucket:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/33fcd17e-73ea-48d1-a315-7a06dcfcc885.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create another record set. This time, use the following parameter values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Name: Set this field as `www`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type: In this field select CNAME - Canonical name'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alias: Check this field with No'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Value: Fill this field input with the S3 bucket''s endpoint:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1166f2ae-aba1-4e06-8bc8-ffe94aed0db3.png)'
  prefs: []
  type: TYPE_IMG
- en: Now test your domain name by typing it in your browser address. You will see
    the `index.html` file that you have uploaded to the S3 bucket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have transferred DNS control from another vendor to AWS, then because
    of DNS caching, you may need to wait for some minutes or even hours before the
    transfer completes. You will only be able to see the files that were hosted on
    Amazon S3 after the transfer finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up CloudFront
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CloudFront serves static files as a **Content Delivery Network** (**CDN**).
    Having file copies next to your users reduces latency and improves your perceived
    website speed. Another feature, which we will discuss later, is support for HTTPS
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will create a CloudFront distribution and adjust the
    Route 53 settings to use CloudFront instead of the S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a distribution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A CloudFront distribution is what makes it possible to associate a DNS configuration
    (Route 53) with CloudFront to distribute static content. A distribution needs
    an origin server to know where the files are stored. In our case, the origin will
    be the S3 bucket that was previously configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to create a CloudFront distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Browse the CloudFront Management Console at [https://console.aws.amazon.com/cloudfront](https://console.aws.amazon.com/cloudfront)
    and click on Create Distribution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/44d8951c-f0ee-468a-a555-45287b7bdb1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to select the distribution type. For our website, select Get
    Started under the Web option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/497cc3b0-36e5-440c-9181-5dc7903d4844.png)'
  prefs: []
  type: TYPE_IMG
- en: The next screen is a big form that we need to fill out. In the first fieldset,
    Origin Settings, the Origin Domain Name option will provide a drop-down list of
    S3 endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You should not use the endpoints provided here because some S3 configurations,
    such as redirects or error messages, won't be available when using this address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, use the endpoint that is available in the bucket properties inside
    the Static Website Hosting settings. The difference between these S3 endpoints
    is that the suggested endpoint doesn''t have the bucket region (for example, `example.com.s3.amazonaws.com`)
    and the endpoint that we will use does have the region (for example, `example.com.s3-website-us-east-1.amazonaws.com`).
    Origin ID will be set automatically after you provide Origin Domain Name. Leave
    Origin Path and Origin Custom Headers empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb6b5c32-c102-4a52-a760-87c071d2dd65.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Default Cache Behavior Settings, set the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Viewer Protocol Policy as HTTP and HTTPS
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowed HTTP Methods as all the HTTP verb options
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Cached HTTP Methods with OPTIONS checked
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Object Caching as Use Origin Cache Headers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/5da573aa-b0a2-416e-92ad-ab699a02b9c2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Leave the rest of the fields in this section with their default values, except
    the Compress Objects Automatically option. This feature is used to compress the
    files on demand using gzip. As already discussed in this chapter, Amazon S3 doesn''t
    offer automatic compression, but CloudFront does. You just need to set the Yes
    option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/833ee269-532e-4313-be9e-b7a8b4d12c72.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Distribution Settings, set the following parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set Price Class with the option based on your target audience and the costs
    that you are willing to pay (better performance means higher costs).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Set Alternate Domain Names (CNAMEs) with the naked domain and the www domain,
    separated by commas.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In SSL Certificate, choose Default CloudFront Certificate (*.cloudfront.net).
    We will return to this option later once we issue our own certificate.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave the rest of the fields with their default values.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/38ebfe3e-0c14-4eae-b282-5f93e8870e13.png)'
  prefs: []
  type: TYPE_IMG
- en: Now click on Create Distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'CloudFront needs a few minutes to replicate the distribution configuration
    between all the edge points, but you can follow the status in the CloudFront console
    main page. After it finishes, it will display the status as Deployed. In the following
    screenshot, you can see the CloudFront distribution address. Copy this link to
    your browser and test to check whether it is working:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8dc3ce93-3830-4bed-90f7-a4f3fb61f141.png)'
  prefs: []
  type: TYPE_IMG
- en: Handling CloudFront caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, CloudFront will cache all the files for 24 hours. It means that
    if you modify the files in your S3 bucket, you won''t see any changes when browsing
    through a CloudFront distribution. Forcing a cache reset in your browser will
    not help because it''s server-side caching. So, what''s the recommended practice
    to handle caching? You have the following two options for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Server side**: Create a cache invalidation request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Client side**: Add suffixes to all the static files when changing their contents'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invalidating server-side cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a cache invalidation request to CloudFront takes some minutes to process
    because CloudFront will need to contact all the edge locations and request them
    to clear their individual caches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this will be a recurring task, I don''t recommend that you use the CloudFront
    console. It''s better to use the CLI. However, CLI support for CloudFront is currently
    only available at the preview stage. So you may need to enable it by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a cache invalidation request for all files (path `/*`), execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find `DISTRIBUTION_ID` of your CloudFront distribution by looking at
    the CloudFront console or running the following CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can add `--query DistributionList.Items[0].Id` to the previous command in
    order to only output the distribution ID of the first distribution.
  prefs: []
  type: TYPE_NORMAL
- en: This solution requires a long time for the invalidation to take effect, and
    it doesn't solve the problem of client-side caching.
  prefs: []
  type: TYPE_NORMAL
- en: Invalidating client-side cache
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you browse a web page, the browser will cache all the files that were
    downloaded to display the page (HTML, CSS, JavaScript, images, and so on) and
    avoid requiring the same files in the near future to improve performance. However,
    if you modify the contents of one file, how can you tell the browser to dispose
    of the previous cached content? You can''t create an invalidation request because
    this time the cache is at the client side, not server side, but you can force
    the browser to make a new request by changing the name of the file that has been
    modified. For example, you can change the file name from `script.js` to `script.v2.js`
    and use its new name inside the HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to add a query string to the filename when declaring it inside
    the HTML page, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the filename was not changed, but the reference was changed,
    and this is enough for the browser to consider the previous cache invalid and
    make a new request to get the updated content.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of both strategies is that you can't cache the HTML page. All other
    data can be cached, except the HTML page. Otherwise, the client will not understand
    that it should download a newer version of a file dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'To upload HTML files in such a way that they will never be cached, you must
    set the `Cache-Control` header to `no-cache` when uploading the files. In our
    website, after syncing a local folder with your bucket, upload the `index.html`
    file again, but this time, use the `cp` (copy) command and add the `Cache-Control`
    header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This strategy works pretty well, but it requires you to automate your build
    process to change the filenames or query string parameters for all changed files.
    In the next chapter, we are going to build a React app using the "Create React
    App" tool. Thankfully, this tool is already configured to change the filenames
    of all the deployments. It adds random strings, as in the `main.12657c03.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Route 53 to use CloudFront
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our current record sets use S3 buckets. You just need to go back to Route 53
    and replace it with the new CloudFront distribution. For the naked domain, which
    uses the A record type, you need to select the Alias option as Yes and the CloudFront
    distribution in the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: For the `www` domain, which uses the CNAME record type, select the Alias option
    as No. In this case, copy the CloudFront distribution address available in the
    A record and paste it into the box of the CNAME record.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, Amazon S3 does not support HTTPS connections, it only supports
    HTTP. We have set the Route 53 record sets to use a CloudFront distribution, but
    we haven't enabled support to HTTPS in CloudFront yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'But why should we support HTTPS? There are many reasons nowadays. Let''s list
    some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: We are building an online store. We need to handle logins and payment transactions.
    Doing such things without an encrypted connection is not safe. It's too easy to
    eavesdrop the network and steal sensitive data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP/2 is the newest protocol and is much faster than the old HTTP/1.1 version.
    Currently, *all* major browsers that support HTTP/2 *require* HTTPS. It is not
    possible to support HTTP/2 over an unencrypted HTTP connection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HTTP/2 with encryption is faster than HTTP/1.1 without encryption. Troy Hunt
    shows an interesting demo at this link: [https://www.troyhunt.com/i-wanna-go-fast-https-massive-speed-advantage](https://www.troyhunt.com/i-wanna-go-fast-https-massive-speed-advantage).
    In his test, loading a website with hundreds of small files was 80 percent faster
    with HTTP/2 over TLS due to the multiplexing feature of the newer protocol.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another good reason is privacy. Using HTTPS everywhere helps to keep your browsing
    data safe. It's not enough because the domain names of the sites that you visit
    will continue to be exposed, but it helps a lot. The pages that you visit and
    the things that you read or write will not be (easily) compromised because data
    will always be transferred with encryption.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are convinced and want to support HTTPS, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a mail exchange record in Route 53.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Request a free SSL/TLS certificate to AWS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the CloudFront distribution to use this new certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first step, to create a mail account, is necessary because AWS will only
    issue a free SSL/TLS certificate if you prove that you own the domain, and this
    verification is done by following a link sent to the `admin@example.com` e-mail
    address.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mail exchange record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need a service that will handle e-mail messages before we request our free
    certificate to AWS. I suggest Zoho Mail as a free option (up to 5 GB space). In
    this section, we will see how to configure this service by performing the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, browse [www.zoho.com/mail](http://www.zoho.com/mail) and sign up for
    a free *business* e-mail account. This account will be associated with your domain.
    When selecting the administrator account, choose the name `admin`. This name is
    important because AWS will check your domain ownership by sending a confirmation
    e-mail to `admin@example.com`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you create your account, you will be requested to confirm the ownership
    of the associated domain. There are a few options to prove your ownership, and
    I prefer using the CNAME method. In the Select your domain''s DNS Manager (DNS
    Hosting provider) from the list option, choose Others.. because AWS is not listed.
    Now, select CNAME Method, and the CNAME and Destination will be presented. You
    need to configure a new temporary Route 53 record set with this pair and finish
    clicking on the Proceed to CNAME Verification button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/672b939a-0210-47a1-8ff1-2d0ef765a1f7.png)'
  prefs: []
  type: TYPE_IMG
- en: After verifying, confirm the creation of the `admin` account. You can add in
    the sequence other users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is to configure MX (mail exchange) records in Route 53\. Copy
    the values that are presented by Zoho:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0bc0c885-3afb-4f7c-b02b-160293bfe2df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Go back to Route 53\. Delete the CNAME record set that was created to verify
    your Zoho account because it is no longer necessary. Now you need to create a
    new record set of the type MX using the values from the preceding screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ca7e6731-96b1-4121-bb0f-661c3fc49d49.png)'
  prefs: []
  type: TYPE_IMG
- en: We are done. You can test whether it is working correctly by sending an e-mail
    to this new address and by checking your Zoho e-mail account for received e-mails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Requesting free certificates with AWS Certificate Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see how to request free certificates with AWS Certificate Manager by
    performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Request a TLS certificate at [https://console.aws.amazon.com/acm/home?region=us-east-1](https://console.aws.amazon.com/acm/home?region=us-east-1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You need to be on us-east-1 because CloudFront only uses certificates from this
    region.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the welcome screen, click on Get started. In the next screen, type your
    naked domain name and the www version and click on Review and request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0b0a779c-f324-4ae8-a5c0-82eed3a82a93.png)'
  prefs: []
  type: TYPE_IMG
- en: In the following screen, you just need to click on Confirm and request. Amazon
    will try to prove your domain ownership by sending an e-mail to `admin@example.com`.
    If you have configured your e-mail account correctly in the previous section,
    you will receive an e-mail in your Zoho inbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The e-mail has a confirmation link that you must click on to prove your ownership.
    After that, Amazon will issue a new TLS certificate that will be available for
    your account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You don't need to worry about the certificate expiration date. AWS will renew
    it automatically when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CloudFront to support HTTPS connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The last step to support HTTPS is to edit the CloudFront distribution to use
    the new certificate. To perform this task, take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Browse the CloudFront Management Console at [https://console.aws.amazon.com/cloudfront](https://console.aws.amazon.com/cloudfront)
    and open your distribution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the General tab, click on the Edit option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the Custom SSL Certificate (example.com): option and select your domain
    certificate using the drop-down button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/169b6130-fe64-4b84-86ab-a5e244a20945.png)'
  prefs: []
  type: TYPE_IMG
- en: Save to return to the previous page, then click on the third tab, Behaviors,
    and click on Edit to edit the existing behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now we can change the Viewer Protocol Policy parameter to Redirect HTTP to
    HTTPS to force the users to always use HTTPS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b3be0f11-99cb-4981-a1b5-e6304abc7ce2.png)'
  prefs: []
  type: TYPE_IMG
- en: After changing these settings, CloudFront will automatically deploy the new
    configuration to all the edge nodes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After waiting for some minutes, you can browse your domain to confirm HTTPS
    support.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to configure S3, CloudFront, and Route 53 to
    host a serverless frontend solution. Now you have your site distributed all around
    the world for reduced latency and increased speed along with HTTPS support to
    make the Web more safe and private.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to build the frontend of our serverless store
    application using React as an SPA.
  prefs: []
  type: TYPE_NORMAL
