<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Controllers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Controllers</h1></div></div></div><p class="calibre7">In the previous chapter, we discussed how templates in Ember.js are used to present data to users. We also covered how user interactions, in our applications, are easily made possible through these templates. We noted that templates serve their purpose by communicating with controllers. This chapter will expound on this, and will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Defining controllers</li><li class="listitem">Storing models and objects in controllers</li><li class="listitem">Using object and array controllers</li><li class="listitem">Specifying controller dependencies</li><li class="listitem">Registering action handlers in controllers</li><li class="listitem">State transitions in controllers</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Controllers">
<div class="book" title="Defining controllers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec55" class="calibre1"/>Defining controllers</h1></div></div></div><p class="calibre7">Just like<a id="id187" class="calibre1"/> route handlers, a controller can be defined by extending the <code class="email">Ember.Controller</code> class, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">AppNamespace.ControllernameController = Ember.Controller.extend();</pre></div><p class="calibre7">A defined controller can further be extended to create yet another new controller class:</p><div class="informalexample"><pre class="programlisting">App.TweetsController = Ember.Controller.extend();
App.RetweetsController = App.TweetsController.extend();</pre></div><p class="calibre7">These controller classes can then be instantiated with the <code class="email">create</code> method, as shown in the following examples:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.Controller.create();
var tweetsController = App.TweetsController.create();</pre></div><p class="calibre7">Just like objects, if we need to use mixins when instantiating controllers, we need to use the <a id="id188" class="calibre1"/>
<code class="email">createWithMixins</code> method instead:</p><div class="informalexample"><pre class="programlisting">var mixin = Ember.Mixin.create({
  model: [1, 2, 3]
});
var controller = Ember.Controller.createWithMixins(mixin);</pre></div><p class="calibre7">This is <a id="id189" class="calibre1"/>equivalent to the following:</p><div class="informalexample"><pre class="programlisting">var Controller = Ember.Controller.extend({
  model: [1, 2, 3]
});
var controller  Controller.create();</pre></div><p class="calibre7">We rarely instantiate application controllers ourselves because Ember.js does it for us when needed.</p></div></div>
<div class="book" title="Providing controllers with models"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec56" class="calibre1"/>Providing controllers with models</h1></div></div></div><p class="calibre7">Before we<a id="id190" class="calibre1"/> proceed, let's<a id="id191" class="calibre1"/> recap and see how data is loaded and stored in controllers. Most of the applications we'll build will communicate with REST endpoints, and therefore, Ember.js comes with features that make the creation of such applications trivial. In  <a class="calibre1" title="Chapter 3. Routing and State Management" href="part0029_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre9">Routing and State Management</em></span>, we learned that data can be loaded from the server in an asynchronous fashion via a route handler's <code class="email">model</code> hook. For example, let's define a blog post route that loads a particular blog post from our server. First, we'll define our application's router as:</p><div class="informalexample"><pre class="programlisting">App.Router.map(function(){
  this.resource('posts', function(){
  });
  this.resource('post', {path: '/post/:post_id'});
});</pre></div><p class="calibre7">We just defined a post resource that will handle requests to a post's detail page, as shown in the following line of code:</p><div class="informalexample"><pre class="programlisting">this.resource('post', {path: '/post/:post_id'});</pre></div><p class="calibre7">If a user visits a post's path, say <code class="email">/post/100</code>, Ember.js expects that the post route handler will define a <code class="email">model</code> hook that will load the matching post from the server. Here's an example that illustrates this using jQuery:</p><div class="informalexample"><pre class="programlisting">App.PostRoute = Ember.Route.extend({
  model: function(params){
    // load matching post from server
    return Ember.$.getJSON('/posts/'+params.post_id);
  }
});</pre></div><p class="calibre7">In the preceding example, the handler's <code class="email">model</code> hook took an <code class="email">options</code> object that contained the post's ID. This ID was then used to load the matching post from the server using jQuery's <code class="email">getJSON()</code> method<a id="id192" class="calibre1"/> that returned a promise with which our application resolved on load. Once resolved, Ember.js expected this route to define a <a id="id193" class="calibre1"/>
<code class="email">setupController</code> hook<a id="id194" class="calibre1"/> that stored the resolved post into the corresponding controller. This is the default behavior that is implemented as the following code:</p><div class="informalexample"><pre class="programlisting">App.PostRoute = Ember.Route.extend({
  model: function(params){
    return Ember.$.getJSON('/posts/'+params.post_id);
  },
  setupController: function(controller, model){
    controller.set('model', model);
  }
});</pre></div><p class="calibre7">The <code class="email">setupController</code> hook<a id="id195" class="calibre1"/> receives two arguments: an instance of the corresponding controller and the resolved model. This model is stored inside the controller's <code class="email">model</code> property. Note that this is just the default implementation; we can store the model in any other desired property or controller.</p></div>

<div id="page" style="height:0pt"/><div class="book" title="Rendering dynamic data from controllers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec57" class="calibre1"/>Rendering dynamic data from controllers</h1></div></div></div><p class="calibre7">After<a id="id196" class="calibre1"/> loading data from the server, the controller's purpose is to make this model available to the corresponding template for display. These templates will then register bindings to the properties of the provided model and send updates of changes made to these properties using form controls. Since controllers are an extension of <code class="email">Ember.Object</code>, they realize better management of the evented nature of browser environments using the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Properties</li><li class="listitem">Computed properties</li><li class="listitem">Observables</li></ul></div></div>

<div class="book" title="Rendering dynamic data from controllers">
<div class="book" title="Properties"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec11" class="calibre1"/>Properties</h2></div></div></div><p class="calibre7">Templates<a id="id197" class="calibre1"/> can display properties<a id="id198" class="calibre1"/> of bound controllers using expressions. For example, the post template in the previous example will display the loaded post as:</p><div class="informalexample"><pre class="programlisting">  {{! post.hbs}}
  
  &lt;h1&gt;{{model.title}}&lt;/h1&gt;
  &lt;p&gt;{{model.body}}&lt;/p&gt;</pre></div><p class="calibre7">When the post loads, the rendered post template will resemble the following:</p><div class="informalexample"><pre class="programlisting">&lt;h1&gt;Introduction to Ember.js.&lt;/h1&gt;
&lt;p&gt;A gentle introduction to Ember.js.&lt;/p&gt;</pre></div><p class="calibre7">If the post's title<a id="id199" class="calibre1"/> changes at a later point in time, the title portion of the template will be rerendered to display the new title, as shown:</p><div class="informalexample"><pre class="programlisting">  controller.set(model.title', 'A guide to using Ember.js.');</pre></div><p class="calibre7">Templates <a id="id200" class="calibre1"/>can also push updates back to controllers. This is typically done using HTML-form elements. Ember provides Handlebars expressions that abstract the use of these controls to create two-way bindings, as we discussed in the previous chapter. To illustrate this, let's add a new route in our blog application, which will enable the blog's admin to add a new post entry, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">  this.resource('posts', function(){
    this.route('/new'); // route to add a new post

});</pre></div><p class="calibre7">The admin will of course create the new post on the <code class="email">/posts/new</code> page. Ember.js will expect a <code class="email">posts/new</code> template for this route, which will resemble the following code:</p><div class="informalexample"><pre class="programlisting">{{! posts/new template }}

&lt;form&gt;
  {{input name='title' value=model.title}}
  {{textarea name='body' value=model.body}}
  &lt;button type='submit'&gt;Save post&lt;/button&gt;
&lt;/form&gt;</pre></div><p class="calibre7">The <code class="email">PostsNewRoute</code> handler will also need to provide the model for the template that will serve as its context. As you might have guessed, its <code class="email">model</code> hook will return a new post object to be updated, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">App.PostsNewRoute = Ember.Route.extend({
  model: function(params){
    return Ember.Object.create();
  }
});</pre></div><p class="calibre7">The <code class="email">model</code> hook returns an Ember.js object that will serve as the post to be created by the admin. Since this is common practice, we'll learn how to use <code class="email">ember-data</code>, a higher level library that helps in the definition and creation of such models in a later chapter. Any update to both text controls will update the new post, thanks to the two-way bindings.</p></div></div>

<div class="book" title="Rendering dynamic data from controllers">
<div class="book" title="Computed properties"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec12" class="calibre1"/>Computed properties</h2></div></div></div><p class="calibre7">Computed properties <a id="id201" class="calibre1"/>are<a id="id202" class="calibre1"/> functions that evaluate to properties and depend on other properties. We can use computed properties to create states and properties that depend on other properties. This is especially helpful when we want to obtain states through aggregation or any form of map reduce. Here's a use case example:</p><div class="informalexample"><pre class="programlisting">{{! application template }}
{{input name="firstName" value=model.firstName}
}
{{input name="lastName" value=model.lastName}}
Full name: {{fullName}}

// application controller

App.ApplicationController = Em.Controller.extend({
  fullName: function(){
    return this.get('model.firstName') + ' ' + this.get('model.lastName');
  }.property('model.firstName', 'model.lastName')
});

// application route
App.ApplicationRoute = Em.Route.extend({
  setupController: function(controller){
    controller.set('model', Em.Object.create({
      firstName: 'Jon',
      lastName: 'Doe',
    });
  });
     });</pre></div><p class="calibre7">In this example, the template is able to display the user's <code class="email">fullName</code> based on their first and last names. We already mentioned that such an implementation is impossible to accomplish in the template layer alone, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">  Full name: {{firstName+lastName}} // wrong</pre></div><p class="calibre7">One thing to note is that instances of objects are never set on a class definition unless they're meant to be static. For example, if the template is a form that updates the values of the model, we might be tempted to provide the default model of the controller as:</p><div class="informalexample"><pre class="programlisting">App.ApplicationController = Em.Controller.extend({
  model: Em.Object.create({
    firstName: 'Jon',
    lastName: 'Doe',
  },

  fullName: function(){
    return this.get('firstName') + ' ' + this.get('lastName');
  }.property('firstName', 'lastName')

});</pre></div><p class="calibre7">The<a id="id203" class="calibre1"/> preceding implementation <a id="id204" class="calibre1"/>can lead to updates not being isolated as intended. Here's another example of a search feature that can be added in our blog application:</p><div class="informalexample"><pre class="programlisting">{{! search template}}

{{input name="search" value=queryTerm}}
&lt;ul&gt;
  {{#each results}}
  &lt;li&gt;{{user}}: {{body}}&lt;li&gt;
  {{/each}}
&lt;/ul&gt;

// search controller
App.SearchController = Em.Controller.extend({

  // require posts controller
  needs: ['posts'],

  // compute matching posts
  results: function(){

    var queryTerm = this.get('queryTerm');
    if (!queryTerm &amp;&amp; queryTerm.trim() === '') return;

    return this
    .get('controllers.posts.model')
    .filter(function(){
      return post.match(queryTerm);
    });

  }.property('queryTerm')

});</pre></div><p class="calibre7">This example <a id="id205" class="calibre1"/>contains some features that we already discussed. If a user visits the search page at <code class="email">say/search</code>, they will be presented with a search input that automatically updates the search controller's <code class="email">queryTerm</code> property on input. As you might notice, this controller's <code class="email">results</code> property will be recalculated because it depends on the controller's <code class="email">queryTerm</code> property.</p><p class="calibre7">One feature <a id="id206" class="calibre1"/>that we introduced is the ability of the controller to reference other controllers. We will discuss this in a later section, but the important thing to note is that we are able to generate results by filtering the model of the <code class="email">posts</code> controller. The search template automatically redisplays  results as the user types along. This example demonstrates how trivial it is to add such seemingly difficult features in single-page applications. Here are a few other features that you can try adding into the application:</p><div class="book"><ul class="itemizedlist"><li class="listitem">A spinner that shows up new posts every time are being loaded from the server. Now is a good time to revisit the loading-and-error action hooks we discussed in <a class="calibre1" title="Chapter 3. Routing and State Management" href="part0029_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre9">Routing and State Management</em></span>.</li><li class="listitem">Define a <code class="email">humanizedDate</code> computed property for each of the loaded posts. Let this property return the post's date in a readable format such as <code class="email">Mon, 15th</code>. Moment.js (<a class="calibre1" href="http://momentjs.com">http://momentjs.com</a>) can come in handy.</li></ul></div></div></div>

<div class="book" title="Rendering dynamic data from controllers">
<div class="book" title="Observables"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec13" class="calibre1"/>Observables</h2></div></div></div><p class="calibre7">In <a id="id207" class="calibre1"/>addition to computed properties, we also <a id="id208" class="calibre1"/>learned how to use observables. These are functions that react to changes made on other properties. For example, let's make the search functionality previously mentioned more user friendly. Most users expect the search request to kick off after a second or two, after they've stopped typing the query term. We, therefore, need a way to <span class="strong"><em class="calibre9">debounce</em></span> this search. Ember.js provides a function that serves this purpose and can be referenced as <code class="email">Ember.run.debounce</code>. Here's a possible implementation:</p><div class="informalexample"><pre class="programlisting">App.SearchController = Em.Controller.extend({

  needs: ['posts'],

  queryTermDidChange: function(){
    Em.run.debounce(this, this.searchResults, 1000);
  }.observes('queryTerm'),
  searchResults: function(){
    var queryTerm = this.get('queryTerm');
    if (!queryTerm &amp;&amp; queryTerm.trim() === '') return;
    var results = this
    .get('controllers.posts.model')
    .filter(function(){
      return post.match(queryTerm);
    });
    this.set('results', results);
  }
});</pre></div><p class="calibre7">The controller <a id="id209" class="calibre1"/>defines an observer, <code class="email">queryTermDidChange</code>, which<a id="id210" class="calibre1"/> invokes the search function after only a second of typing. As <a id="id211" class="calibre1"/>illustrated, the <code class="email">debounce</code> function (<a class="calibre1" href="http://emberjs.com/api/classes/Ember.run.html#method_debounce">http://emberjs.com/api/classes/Ember.run.html#method_debounce</a>) takes three arguments—a context, a function to invoke within the specified context, and the time to wait for invocation if no other calls are made.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Object and array controllers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec58" class="calibre1"/>Object and array controllers</h1></div></div></div><p class="calibre7">Ember.js ships with the<a id="id212" class="calibre1"/> following controllers that are meant to easily represent objects and enumerable data, respectively:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Object controller</li><li class="listitem">Array controller</li></ul></div><p class="calibre7">These controllers are a bit different from the other controllers in the sense that the data being represented is usually set as the <code class="email">model</code> property of the controller, for example:</p><div class="informalexample"><pre class="programlisting">Ember.ObjectController.create({
  model: {
    name: 'Jon Doe'
    age: 23
  }
});

Ember.ArrayController.create({
  model: [1, 2]
});</pre></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="An object controller"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec14" class="calibre1"/>An object controller</h2></div></div></div><p class="calibre7">An<a id="id213" class="calibre1"/> object controller is used to proxy properties of the object being represented. This means that if a controller property is accessed, Ember.js will look for the property first in the controller, and then the model. For example, let's create a post model class:</p><div class="informalexample"><pre class="programlisting">App.Post = Ember.Object.extend({
    title: null,
    body: null
});</pre></div><p class="calibre7">Then, create a new post from this model as:</p><div class="informalexample"><pre class="programlisting">var post = App.Post.create({
    title: 'JavaScript prototypes.',
    body: 'This post will discuss JavaScript prototypes.'
});</pre></div><p class="calibre7">This post's properties can obviously be accessed using the object's getter and setter methods as:</p><div class="informalexample"><pre class="programlisting">post.set('title', 'Design patterns.');
post.get('title'); // Design patterns.</pre></div><p class="calibre7">When this post is set as the model of an <code class="email">ObjectController</code> instance, as shown, access to the controller properties translates to access to the post, for example:</p><div class="informalexample"><pre class="programlisting">var postController = Ember.ObjectController.create();
postController.set('model', post);
postController.get('title'); // Design patterns.</pre></div><p class="calibre7">Note that using a normal controller will not yield the same results:</p><div class="informalexample"><pre class="programlisting">var postController = Ember.Controller.create();
postController.set('model', post);
postController.get('title'); //  undefined
  postController.get('model.title'); // Design patterns.</pre></div><p class="calibre7">Object properties are useful when we wish to create computed properties on the controller whose dependent properties are those of the model. For example, let's pass the preceding defined post as a route's model:</p><div class="informalexample"><pre class="programlisting">App.PostRoute = Ember.Route.extend({
  model: function(){
    return App.Post.create({
      title: 'JavaScript prototypes.',
      body: 'This post will discuss JavaScript prototypes.',
      tagIds: [1, 2, 3, 4]
    });
  }
});</pre></div><p class="calibre7">Now, suppose we want to compute a <code class="email">tags</code> property based on the given array of IDs, we will implement <a id="id214" class="calibre1"/>this in the corresponding controller as:</p><div class="informalexample"><pre class="programlisting">App.PostController = Ember.ObjectController.extend({

  TAGS: {
     1: 'ember.js',
     2: 'javascript',
     3: 'web',
     4: 'mvc'
  },

  tags: function(){
    var tags = this.get('TAGS');
    return this.get('tagIds').map(function(id){
    return tags[id];
    });
  }.property('TAGS', 'tags.length')

});</pre></div><p class="calibre7">With the computed property defined, we can go ahead and use it in the post template as:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;{{title}}&lt;/p&gt;
&lt;p&gt;{{body}}&lt;/p&gt;
&lt;ul&gt;
     {{#each tags}}
     &lt;li&gt;{{this}}&lt;/li&gt;
    {{/each}}
&lt;/ul&gt;</pre></div><p class="calibre7">This will yield something like the following:</p><div class="informalexample"><pre class="programlisting">&lt;p&gt;JavaScript prototypes.&lt;/p&gt;
&lt;p&gt;This post will discuss JavaScript prototypes.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ember.js&lt;/li&gt;
  &lt;li&gt;javascript&lt;/li&gt;
  &lt;li&gt;web&lt;/li&gt;
  &lt;li&gt;mvc&lt;/li&gt;
&lt;/ul&gt;</pre></div><p class="calibre7">Note that we do not have to prefix the variables with <code class="email">model.</code>, as we did in the preceding sections, because the template's context, the controller, forwarded these requests to the model. This type of controller <a id="id215" class="calibre1"/>uses the <code class="email">Ember.ObjectProxy</code> (<a class="calibre1" href="http://emberjs.com/api/classes/Ember.ObjectProxy.html">http://emberjs.com/api/classes/Ember.ObjectProxy.html</a>) mixin, which enables a proxy (in this case, the controller) to forward all requests to the properties that it has not defined, and to its model, as we already discussed.</p></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="An array controller"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec15" class="calibre1"/>An array controller</h2></div></div></div><p class="calibre7">Likewise, array controllers<a id="id216" class="calibre1"/> are <a id="id217" class="calibre1"/>used to represent enumerable data. An example of enumerable data is the JavaScript <code class="email">Array</code> primitive:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.ArrayController.create({
  model: [1, 2, 3]
});
controller.get('length'); // 3</pre></div><p class="calibre7">In this case, the corresponding template will list the items as:</p><div class="informalexample"><pre class="programlisting">{{#each}}
   {{this}}
{{/each}}</pre></div><p class="calibre7">Note that we also did not need to reference the model, as shown in the following cases:</p><div class="informalexample"><pre class="programlisting">{{#each model}}
{{this}}
{{/each}}

{{#each controller.model}}
{{this}}
{{/each}}</pre></div><p class="calibre7">Since array controllers represent enumerable data, they provide the following useful methods that can be used to manipulate their models.</p></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="addObject(object)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec16" class="calibre1"/>addObject(object)</h2></div></div></div><p class="calibre7">The <code class="email">addObject(object)</code> method<a id="id218" class="calibre1"/> adds<a id="id219" class="calibre1"/> the given object to the end of the controller model if the latter does not contain the former, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.ArrayController.create({
  model: []
});
controller.addObject('a'); // ['a']
controller.addObject('b'); // ['a', 'b']
controller.addObject('b'); // ['a', 'b'] // already added</pre></div><p class="calibre7">If the model already contains the object, this method call fails silently.</p></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="pushObject(object)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec17" class="calibre1"/>pushObject(object)</h2></div></div></div><p class="calibre7">The <a id="id220" class="calibre1"/>
<code class="email">pushObject(object)</code> method<a id="id221" class="calibre1"/> always adds the object, regardless of whether the model contains it or not, for example:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.ArrayController.create({
  model: []
});
controller.pushObject('a');  // ['a']
controller.pushObject('b'); // ['a', 'b']
controller.pushObject('b'); // ['a', 'b', 'b'] // still added</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="removeObject(object)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec18" class="calibre1"/>removeObject(object)</h2></div></div></div><p class="calibre7">The <a id="id222" class="calibre1"/>
<code class="email">removeObject(object)</code> method<a id="id223" class="calibre1"/> is used to remove the given object from the controller's model, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.ArrayController.create({
  model: ['a', 'b', 'c']
});
controller.removeObject('a');    // ['b', 'c']
controller.removeObject('b');    // ['c']
controller.removeObject('b');    // ['c'] // fails silently</pre></div><p class="calibre7">This method also does nothing if the model doesn't contain the object.</p></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="addObjects(objects), pushObjects(objects), and removeObjects(objects)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec19" class="calibre1"/>addObjects(objects), pushObjects(objects), and removeObjects(objects)</h2></div></div></div><p class="calibre7">The<a id="id224" class="calibre1"/> three methods mentioned previously <a id="id225" class="calibre1"/>are <a id="id226" class="calibre1"/>used to <a id="id227" class="calibre1"/>perform the three<a id="id228" class="calibre1"/> methods <a id="id229" class="calibre1"/>we just discussed using multiple objects, for example:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.ArrayController.create({
  model: []
});
controller.pushObjects(['a', 'b']);       // ['a', 'b']
controller.addObjects(['b', 'c']);        // ['a', 'b', 'c']
controller.removeObjects(['b', 'c']); // ['a']</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="contains(object)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch05lvl2sec20" class="calibre1"/>contains(object)</h2></div></div></div><p class="calibre7">To check <a id="id230" class="calibre1"/>if a model contains an object, we can use the <code class="email">contains(object)</code> method<a id="id231" class="calibre1"/> that returns a Boolean:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.ArrayController.create({
  model: ['a', 'c']
});
controller.contains('a');    // true
controller.contains('b');    // false</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="compact()"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch05lvl2sec21" class="calibre1"/>compact()</h2></div></div></div><p class="calibre7">The <a id="id232" class="calibre1"/>
<code class="email">compact()</code> method<a id="id233" class="calibre1"/> returns a copy of the underlying model, with undefined and null items removed:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.ArrayController.create({
  model: ['a', 'b', 'c', undefined, null]
});
controller.compact();    // ['a', 'b', 'c']</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="every(callback)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch05lvl2sec22" class="calibre1"/>every(callback)</h2></div></div></div><p class="calibre7">The <a id="id234" class="calibre1"/>
<code class="email">every(callback)</code> method<a id="id235" class="calibre1"/> is used to check if each of the items contained in the model satisfies a given condition:</p><div class="informalexample"><pre class="programlisting">var areEven = [2, 2, 4, 24, 80].every(condition); // true
var areEven = [1, 2, 3, 4, 5].every(condition);     // false

function condition(integer){
  return integer %2 === 0;
}</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="filter(object)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_10"><a id="ch05lvl2sec23" class="calibre1"/>filter(object)</h2></div></div></div><p class="calibre7">Filter <a id="id236" class="calibre1"/>works<a id="id237" class="calibre1"/> in the same as way as the native JavaScript array object, <code class="email">Array.filter</code>:</p><div class="informalexample"><pre class="programlisting">[2, 2, 4, 24, 80].filter(condition); // [2, 2, 4, 24, 80]
[1, 2, 3, 4, 5].filter(condition);     // [2, 4]

function condition(integer){
  return integer %2 === 0;
}</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="filterBy(property)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_11"><a id="ch05lvl2sec24" class="calibre1"/>filterBy(property)</h2></div></div></div><p class="calibre7">Sometimes, we <a id="id238" class="calibre1"/>want to compact a model, but <a id="id239" class="calibre1"/>only if the items contained define the given property. We can use the preceding <code class="email">filter</code> method, as shown:</p><div class="informalexample"><pre class="programlisting">var colors = [
  { name: 'red', isPrimary: true },
  { name: 'green', isPrimary: false },
  { name: 'black', isPrimary: undefined },
  { name: 'white', isPrimary: null },
];
colors.filter(condition);     // [{ name: 'red', isPrimary: true }]
function condition(color){
  return !!color.isPrimary;
}</pre></div><p class="calibre7">We can also use a shorter version, as shown:</p><div class="informalexample"><pre class="programlisting">var colors = [
  { name: 'red', isPrimary: true },
  { name: 'green', isPrimary: false },
  { name: 'black', isPrimary: undefined },
  { name: 'white', isPrimary: null },
];
colors.filterBy('isPrimary');     // [{ name: 'red', isPrimary: true }]</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="find(callback)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_12"><a id="ch05lvl2sec25" class="calibre1"/>find(callback)</h2></div></div></div><p class="calibre7">In the <a id="id240" class="calibre1"/>preceding example, we can use the <code class="email">filter</code> method<a id="id241" class="calibre1"/> to return the first occurrence of a primary color, as shown:</p><div class="informalexample"><pre class="programlisting">var colors = [
  { name: 'red', isPrimary: true },
  { name: 'green', isPrimary: false },
  { name: 'black', isPrimary: undefined }
];
colors.filter(condition)[0];     // { name: 'red', isPrimary: true }
function condition(color){
  return !!color.isPrimary;
}</pre></div><p class="calibre7">This is inefficient because we always loop through all the model items. The <code class="email">find</code> method can be used to achieve this need as:</p><div class="informalexample"><pre class="programlisting">var colors = [
  { name: 'red', isPrimary: true },
  { name: 'green', isPrimary: false },
  { name: 'black', isPrimary: undefined }
];
colors.find(condition);     // { name: 'red', isPrimary: true }
function condition(color){
  return !!color.isPrimary;
}</pre></div><p class="calibre7">As soon as a match is found, the check iteration is aborted.</p></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="findBy(key, value)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_13"><a id="ch05lvl2sec26" class="calibre1"/>findBy(key, value)</h2></div></div></div><p class="calibre7">Just <a id="id242" class="calibre1"/>as in the <code class="email">filter</code> versus <code class="email">filterBy</code> case, we <a id="id243" class="calibre1"/>can reimplement the preceding example using the <code class="email">findBy</code> method instead of <code class="email">find</code>, as shown:</p><div class="informalexample"><pre class="programlisting">var colors = [
  { name: 'red', isPrimary: true },
  { name: 'green', isPrimary: false },
  { name: 'black', isPrimary: undefined }
];
colors.findBy('isPrimary', true);     // { name: 'red', isPrimary: true }</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="insertAt(index, object), objectAt(index), and removeAt(index, length)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_14"><a id="ch05lvl2sec27" class="calibre1"/>insertAt(index, object), objectAt(index), and removeAt(index, length)</h2></div></div></div><p class="calibre7">The <code class="email">insertAt(index, object)</code>, <code class="email">objectAt(index)</code>, and <code class="email">removeAt(index, length)</code> methods are used to perform operations <a id="id244" class="calibre1"/>using item indices. The first method is used to add an <a id="id245" class="calibre1"/>object at the given index. An<a id="id246" class="calibre1"/> error<a id="id247" class="calibre1"/> is thrown if the<a id="id248" class="calibre1"/> index is out of bounds. The second<a id="id249" class="calibre1"/> method is used to retrieve an object at the specified index. Again, if the index is out of bounds, an undefined value is returned. </p><p class="calibre7">Note that we cannot use negative indices for lookups, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var colors = ['red', 'blue'];
colors.insertAt(1, 'yellow'); // ['red',  'yellow', 'blue'];
colors.insertAt(10, 'green'); // Error: Index out of range
colors.objectAt(0); // 'red'
colors.objectAt(10); // undefined
colors.objectAt(-1); // undefined - negative index</pre></div><p class="calibre7">The last method removes objects matching the given index by an optional range:</p><div class="informalexample"><pre class="programlisting">var fruits = ['mango', 'apple, 'banana', 'orange', 'papaya', 'lemon'];
fruits.removeAt(0); // [apple, 'banana', 'orange', 'papaya', 'lemon'];
fruits.removeAt(1, 2); [apple, 'papaya', 'lemon'];
fruits.removeAt (10, 3); // Error: Index out of range</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="map(callback)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_15"><a id="ch05lvl2sec28" class="calibre1"/>map(callback)</h2></div></div></div><p class="calibre7">A map <a id="id250" class="calibre1"/>works in<a id="id251" class="calibre1"/> the same way as <code class="email">Array.map</code>:</p><div class="informalexample"><pre class="programlisting">var fruits = ['mango', 'apple', 'banana', 'orange', 'papaya', 'lemon'];
fruits.map(function(fruit){
  return {name: fruit};
});
// [
//  { name: 'mango'},
//  { name: 'apple'},
//  { name: 'banana'},
//  { name: 'orange'},
//  { name: 'papaya'},
//  { name: 'lemon'}
// ];</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="mapBy(property)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_16"><a id="ch05lvl2sec29" class="calibre1"/>mapBy(property)</h2></div></div></div><p class="calibre7">With the <a id="id252" class="calibre1"/>result generated in the preceding example, we can use<a id="id253" class="calibre1"/> the <code class="email">mapBy</code> method to get back the original array as:</p><div class="informalexample"><pre class="programlisting">var fruits = [
 { name: 'mango'},
 { name: 'apple'},
 { name: 'banana'},
 { name: 'orange'},
 { name: 'papaya'},
 { name: 'lemon'}
];
fruits.mapBy('name');
// ['mango', 'apple', 'banana', 'orange', 'papaya', 'lemon'];</pre></div><p class="calibre7">As illustrated, this method returns a new array containing the values evaluated on the model items.</p></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="forEach(function)"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_17"><a id="ch05lvl2sec30" class="calibre1"/>forEach(function)</h2></div></div></div><p class="calibre7">This<a id="id254" class="calibre1"/> is a <a id="id255" class="calibre1"/>commonly used method that invokes the given function on each of the items contained in the model:</p><div class="informalexample"><pre class="programlisting">var Dog = Em.Object.extend({
  bark: function(){
    console.log('woof: %s', this.get('name'));
  }
});
// model
var dogs = ['bo', 'sunny'].map(function(name){
  return Dog.create({
    name: name
  });
});
dogs.forEach(function(dog){
  dog.bark();
});
// woof: bo
// woof: sunny</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="uniq()"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_18"><a id="ch05lvl2sec31" class="calibre1"/>uniq()</h2></div></div></div><p class="calibre7">As the <a id="id256" class="calibre1"/>name suggests, the <code class="email">uniq()</code> method<a id="id257" class="calibre1"/> returns a new array devoid of duplicates:</p><div class="informalexample"><pre class="programlisting">['papaya', 'apple', 'banana', 'orange', 'papaya', 'apple'].uniq();
// ["papaya", "apple", "banana", "orange"]</pre></div></div></div>

<div class="book" title="Object and array controllers">
<div class="book" title="sortProperties and sortAscending"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_19"><a id="ch05lvl2sec32" class="calibre1"/>sortProperties and sortAscending</h2></div></div></div><p class="calibre7">The<a id="id258" class="calibre1"/> <code class="email">sortProperties</code>
<a id="id259" class="calibre1"/> and <code class="email">sortAscending</code> methods <a id="id260" class="calibre1"/>are used<a id="id261" class="calibre1"/> to sort the represented data. For example, we might have a music catalog that we want to sort by album name, and later by song name, as shown in the following table:</p><div class="informalexample"><table border="1" class="calibre13"><colgroup class="calibre14"><col class="calibre15"/><col class="calibre15"/></colgroup><thead class="calibre16"><tr class="calibre17"><th valign="bottom" class="calibre18">
<p class="calibre19">Album name</p>
</th><th valign="bottom" class="calibre18">
<p class="calibre19">Song name</p>
</th></tr></thead><tbody class="calibre20"><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Folie a deux</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Tiffany Blews</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Folie a deux</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">W.A.M.S</p>
</td></tr><tr class="calibre17"><td valign="top" class="calibre21">
<p class="calibre19">Infinity on high</p>
</td><td valign="top" class="calibre21">
<p class="calibre19">Thriller</p>
</td></tr></tbody></table></div><p class="calibre7">To accomplish this, we need to define the following properties in the controller:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">sortProperties</code></li><li class="listitem"><code class="email">sortAscending</code></li></ul></div><p class="calibre7">The first <a id="id262" class="calibre1"/>property specifies the properties to use when ordering <a id="id263" class="calibre1"/>the items, while the second property specifies the sort direction. In our cases, we will sort the music catalog as:</p><div class="informalexample"><pre class="programlisting">var controller = Ember.ArrayControler.create({
  model: [
   {name: 'W.A.M.S', album: 'Folie a deux'},    {name: 'Thriller', album: 'Infinity on high'},   {name: 'Tiffany blues', album: 'Folie a deux'},
  ],
  sortProperties: ['name', 'album'],
  sortAscending: true
});</pre></div><p class="calibre7">To sort the <a id="id264" class="calibre1"/>songs in the reverse order, we need to <a id="id265" class="calibre1"/>set the <code class="email">sortAscending</code> property as <code class="email">False</code>.</p><p class="calibre7">These are just a<a id="id266" class="calibre1"/> few of the common methods that are provided by the <code class="email">Ember.ArrayProxy</code> (<a class="calibre1" href="http://emberjs.com/api/classes/Ember.ArrayProxy.html">http://emberjs.com/api/classes/Ember.ArrayProxy.html</a>) mixin, which <code class="email">Ember.ArrayController</code> uses.</p></div></div>
<div class="book" title="Handling event actions"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec59" class="calibre1"/>Handling event actions</h1></div></div></div><p class="calibre7">In the previous<a id="id267" class="calibre1"/> chapter, we learned how user actions can easily be delegated to controllers and routes from templates. Let's have a recap with an example:</p><div class="informalexample"><pre class="programlisting">{{! posts/new template }}

&lt;form {{action 'save' model on='submit'}}&gt;
  {{input name='title' value=title}}
  {{textarea name='body' value=body}}
  &lt;button type='submit'&gt;Create&lt;/button&gt;
  &lt;button type='cancel' {{action 'cancel' this}}&gt;Cancel&lt;/button&gt;
&lt;/form&gt;</pre></div><p class="calibre7">In this example, we defined two actions that will be handled by the corresponding controller as:</p><div class="informalexample"><pre class="programlisting">App.PostsNewController = Ember.ObjectController.extend({
  actions: {
    save: function(post){
      post.save();
    },
    cancel: function(post){
      post.rollback();
    }
  }
});</pre></div><p class="calibre7">We already <a id="id268" class="calibre1"/>learned that all action handlers are defined in the <code class="email">actions</code> property of the target controller or route. In this case, when the user submits the form either by clicking on the <span class="strong"><strong class="calibre8">submit</strong></span> button or by hitting the <span class="strong"><em class="calibre9">Enter</em></span> key, the <code class="email">save</code> hook in the controller is called with the post context as the only argument. Likewise, clicking on the <span class="strong"><strong class="calibre8">cancel</strong></span> button calls the corresponding <code class="email">cancel</code> hook.</p><p class="calibre7">A typical widget consisting of tabs can be implemented in the same way, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00009.jpeg" alt="Handling event actions" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">In this case, the widget template might look like the following code:</p><div class="informalexample"><pre class="programlisting">&lt;ul class="tabs"&gt;
  {{#each}}
  &lt;li    {{bind-attr selected="selected"}} 
    {{action "selected" this}}&gt;
      {{name}}
  &lt;/li&gt;
  {{/each}}
&lt;ul&gt;</pre></div><p class="calibre7">This template contains the <code class="email">tabs</code> element group generated from the <code class="email">tabs</code> context property. If any of the tabs are clicked on, they will need to acquire a <code class="email">selected</code> class. Here's suitable styling that will achieve this effect:</p><div class="informalexample"><pre class="programlisting">.tabs .selected{
  color: deepskyblue
}</pre></div><p class="calibre7">The <code class="email">selected</code> action handler <a id="id269" class="calibre1"/>for the controls will then be implemented as:</p><div class="informalexample"><pre class="programlisting">App.TabsRoute = Ember.Route.extend({

  model: function(){

    return [{

      name: 'tab 1',

      body: 'tab 1 content'

    }, {

      name: 'tab 2',

      body: 'tab 2 content'

    }];
  }

});

App.TabsController = Ember.ArrayController.extend({

  actions: {

    selected: function(selectedTab){

      this.forEach(function(tab){

        var selected = tab.get('name') === selectedTab.get('name');

        tab.set('selected', selected);

      });

    }

  }

});</pre></div><p class="calibre7">Note that these actions don't have to be caught in the context controller as we discussed in the previous chapter. When an action is triggered, typically from a template element, Ember.js checks to <a id="id270" class="calibre1"/>see if the appropriate action handler is defined inside the actions property of the immediate controller. If this is not the case, Ember.js proceeds to search for the action handler in the corresponding route. If this route still doesn't implement the handler, Ember.js will continue searching for the action handler in higher routes. One thing to note is that if an action handler returns <code class="email">True</code>, Ember.js will still continue to search for this handler, constituting <a id="id271" class="calibre1"/>
<span class="strong"><strong class="calibre8">action bubbling</strong></span>.</p></div>
<div class="book" title="Specifying controller dependencies"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec60" class="calibre1"/>Specifying controller dependencies</h1></div></div></div><p class="calibre7">Controller<a id="id272" class="calibre1"/> dependencies <a id="id273" class="calibre1"/>enable controllers to associate. Therefore, whenever a controller needs to access the properties of another controller, it should first declare the controller as a dependency in order for it to be able to do so. These dependencies are defined in the <code class="email">needs</code> property of the affected controller. For example, let's say we decided to add a commenting system to our blog application:</p><div class="informalexample"><pre class="programlisting">  this.resource('post', {path: '/post/:post_id'}, function(){
    this.resource('comments', function(){
  });    });</pre></div><p class="calibre7">In a typical blog, comments are usually displayed on a separate page, and in our case, at a page with a path such as <code class="email">/post/100/comments</code>. We will need to define a <code class="email">comments</code> template that lists the loaded comments as:</p><div class="informalexample"><pre class="programlisting">{{! comments template}}
&lt;h1&gt; Comments for &lt;h1&gt;
&lt;ul&gt;
  {{#each comments}}
  &lt;li&gt;{{user}}: {{body}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p class="calibre7">As you might have noticed, the template needs to display the title of the comments' post. To do this, it needs to be able to access a loaded post in the <code class="email">post</code> controller. By specifying a dependency to the post controller, the comments controller will be able to access the post controller in its <code class="email">controllers</code> object property. For example:</p><div class="informalexample"><pre class="programlisting">App.CommentsController = Ember.Controller.extend({
  needs: ['post']
});</pre></div><p class="calibre7">Then, the <code class="email">comments</code> template will be updated to the following:</p><div class="informalexample"><pre class="programlisting">{{! comments template}}
&lt;h1&gt;Comment listing for {{controller.controllers.post.title}}&lt;/h1&gt;
&lt;ul&gt;
     {{#each comments}}
  &lt;li&gt;{{user}}: {{body}}&lt;/li&gt;
  {{/each}}
&lt;/ul&gt;</pre></div><p class="calibre7">You might be <a id="id274" class="calibre1"/>wondering whether this can lead to an infinite dependency loop. Well, controllers can depend on each other without suffering from this fate:</p><div class="informalexample"><pre class="programlisting">App.AController = Ember.Controller.extend({
  needs: ['b']
}); 
App.BController = Ember.Controller.extend({
  needs: ['a']
}); </pre></div><p class="calibre7">This association serves as the correct channel of communication between the different components of the application.</p></div>
<div class="book" title="State transitions in controllers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec61" class="calibre1"/>State transitions in controllers</h1></div></div></div><p class="calibre7">In <a class="calibre1" title="Chapter 3. Routing and State Management" href="part0029_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre9">Routing and State Management</em></span>, we learned <a id="id275" class="calibre1"/>that routes can transition the state of <a id="id276" class="calibre1"/>an application into other routes by invoking their <code class="email">transitionTo</code> method, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">App.IndexRoute = Ember.Route.extend({
  redirect: function(){
    this.transintionTo('posts');
  }
});</pre></div><p class="calibre7">Likewise, controllers also have this capability through the use of the provided <code class="email">transitionToRoute</code> method. For example, we can change states in a controller's action handler as:</p><div class="informalexample"><pre class="programlisting">App.PostsNewController = Ember.ObjectController.extend({
  actions: {
    cancel: function(post){
      this.transitionToRoute('posts');
    }
  }
});</pre></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec62" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This has been an exciting chapter that helped us understand the primary purpose of controllers, which is data representation. We learned how controllers are defined based on the defined application routes. We also learned how to use object and array controllers to represent models. Lastly, we learned how to set up dependencies between controllers, which might handle different concerns of the application. At this point of the book, we really should be ready to start thinking of ways to architect Ember.js applications. The next chapter will cover the view layer, for which a good amount of knowledge in the use of controllers will be required.</p></div></body></html>