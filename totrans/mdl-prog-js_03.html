<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Module Design Pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Module Design Pattern</h1></div></div></div><p>Now that we have reviewed some important JavaScript OOP concepts in the previous chapter, we are going to leverage some of the techniques discussed to create modules and start using them in our application.</p><p>You are<a id="id103" class="indexterm"/> probably familiar with the term <span class="strong"><strong>design pattern</strong></span>, which is essentially a way of structuring code as a reusable solution for common programming problems. In this chapter, we are going to focus on a particular design pattern in <a id="id104" class="indexterm"/>JavaScript called <span class="strong"><strong>module pattern</strong></span>.</p><p>We will explore how we can create simple modules using this pattern and then we will build upon these modules to create our application's modules in the following chapters.</p><p>Module pattern is one of the most frequently used patterns in JavaScript for creating modular applications.</p><p>Some of the topics that we will discuss in this chapter are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Structure of module pattern</li><li class="listitem" style="list-style-type: disc">Internal private scope in module pattern</li><li class="listitem" style="list-style-type: disc">How to create simple modules</li><li class="listitem" style="list-style-type: disc">How to create a module factory</li></ul></div><div class="section" title="Module pattern"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Module pattern</h1></div></div></div><p>In the <a id="id105" class="indexterm"/>previous chapter, we had a look at how we can create private variables and namespaces inside functions. We also explored how private scopes can be implemented. Some concepts related to private scopes can also be<a id="id106" class="indexterm"/> applied to <span class="strong"><strong>singleton</strong></span> objects residing inside functions.</p><p>A singleton object is an object there will only ever be one instance of it in the application. Singleton objects can be created using object literal notation, which we saw examples of in the previous chapter.</p><p>Consider the following object definition:</p><div class="informalexample"><pre class="programlisting">var mySingletonObj = {};</pre></div><p>While the preceding object does not do anything, it is in fact a valid object and there can only be one instance of this object as we cannot create other objects based on <code class="literal">mySingletonObj</code>.</p><p>Let's add <a id="id107" class="indexterm"/>some value properties and methods (method properties) to this object and see how we can access such properties outside of the object definition:</p><div class="informalexample"><pre class="programlisting">var mySingletonObj = {
  
  name: "Sasan",
  
  title: "Software Developer",
 
  getName: function(){
  
    return this.name;  
  },
  
  getTitle: function(){
  
    return this.title;  
  }

};
// displays "Sasan"
console.log(mySingletonObj.getName()); 

//  displays "Software Developer"
console.log(mySingletonObj.getTitle()); </pre></div><p>In the above object definition, we have created a singleton object with four properties. Two of them are value properties and two are method properties.</p><p>Our method properties have access to our value properties and return their values. However, we can also directly access the object's properties and even override their values from outside of the object.</p><p>Have a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">mySingletonObj.name = "John";
console.log(mySingletonObj.name); // displays "John"</pre></div><p>This shows that, while we have encapsulation (I am using the term loosely here) in our code, we do not have access control and the external code can change the values of the properties<a id="id108" class="indexterm"/> in our object. This at times, is undesirable.</p><p>Let's re-factor our code and create a simple module, using the module pattern. This will help us implement encapsulations as well as access control in our singleton object.</p><p>Consider the following:</p><div class="informalexample"><pre class="programlisting">var mySingletonObj = (function(){
    
    //private variables
    var name = "Sasan"; 
    var title = "Software Developer";
  
    //returning a Singleton
    return {
      
        // privileged method
        getName : function(){
            
            return name;
        },
        // privileged method
        getTitle: function(){
          
            return title;
        }            
      
    };
         
})();</pre></div><p>In <a id="id109" class="indexterm"/>the preceding code, we have created an <span class="strong"><strong>Immediately Invoked Function Expression</strong></span> (<span class="strong"><strong>IIFE</strong></span>) and have assigned its return value (which is a singleton object) to the variable <code class="literal">mySingletonObj</code>.</p><p>The returned singleton object has two methods that have access to the private variables of the container function and return their related values.</p><p>If we try to access the function variables directory from the returned object such as:</p><div class="informalexample"><pre class="programlisting">console.log(mySingletonObj.name); // displays undefined</pre></div><p>We are unable to do so. This is because the <code class="literal">name</code> property is a private property of the container function and it does not exist on the returned anonymous object.</p><p>However, we can access this property through the privileged method <code class="literal">getName</code>, which is defined on the singleton object returned by our IIFE.</p><p>As the <code class="literal">mySingletonObj</code> variable has a reference to this singleton object, if we execute the following code:</p><div class="informalexample"><pre class="programlisting">console.log(mySingletonObj.getName()); // displays "Sasan"</pre></div><p>We are able to access the value assigned to the <code class="literal">name</code> property of the function. Note that the singleton<a id="id110" class="indexterm"/> object returned from the IIFE still has access to the context of the anonymous function that contains it. This is possible because we have created a closure here. Of course, the same applies to the <code class="literal">title</code> property of the function as seen here:</p><div class="informalexample"><pre class="programlisting">// displays "Software Developer"
console.log(mySingletonObj.getTitle());</pre></div><p>This approach of structuring our code in such a way that a returned singleton object from inside a function provides access to the private members (internal private scope) of the container function object) is what forms the basis of module pattern in JavaScript.</p><div class="section" title="Internal private scope in module pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Internal private scope in module pattern</h2></div></div></div><p>Module <a id="id111" class="indexterm"/>pattern enables us to create a private scope for our code inside a function while providing controlled access to such a private scope through an interface. This interface can be in the form of a returned singleton object.</p><p>In the code example in the previous section, <code class="literal">mySingletonObj</code> is the interface to the private scope of our IIFE.</p><p>What happens if we add another property to <code class="literal">mySingletonObj</code> that has the same identifier as one of the properties of the containing function?</p><p>Well, <code class="literal">mySingletonObj</code> is like any other object in the sense that we can add properties to it regardless of it containing the object's properties. However, the important thing to remember here is that assigning or modifying such properties on the returned interface has no effect on the private variables encapsulated in the function that contains the returned object.</p><p>Let's modify our previous module and dig a little deeper:</p><div class="informalexample"><pre class="programlisting">var mySingletonObj = function() {
    //private variables
    var name = "Sasan";
    var title = "Software Developer";
  
    //returning a singleton
    return {
        name: 'Tom',
      
        // privileged method
        getOuterName: function() {
            return name;
        },
      
        // privileged method
        getInnerName: function() {
            return this.name;
        },
      
        // privileged method
        getTitle: function() {
            return title;
        }
    };
}();</pre></div><p>As you<a id="id112" class="indexterm"/> can see, we have added a <code class="literal">name</code> property to our returned singleton object from the IIFE, which has the same identifier as the <code class="literal">name</code> property on the function object. We have also replaced one of the previous methods with two new methods in our interface (the singleton object returned from the IIFE). The first method, <code class="literal">getOuterName</code>, simply returns the value of the <code class="literal">name</code> property. </p><p>The question is, which <code class="literal">name</code> property, the one from the private scope of the function or the <code class="literal">name</code> property from the singleton object itself?</p><p>If we run the following line of code:</p><div class="informalexample"><pre class="programlisting">console.log(mySingletonObj.name); // displays "Tom"</pre></div><p>We can see that the value returned is the value in the scope of the singleton object itself; thus, <code class="literal">Tom</code> is displayed.</p><p>However, if we try to access the same property, using the method property on the interface, a different value will be returned. Have a look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">console.log(mySingletonObj.getOuterName()); // displays "Sasan"</pre></div><p>As you can see, the value returned from this method is the value for the <code class="literal">name</code> property from the outer scope of the interface, which is the scope of the container function. This can be rather confusing.</p><p>If the intent is to return the value for the name property which is defined inside the singleton object itself (the interface), we need to qualify the property using the <code class="literal">this</code> keyword.</p><p>Have a look at the second new method that we added to our module:</p><div class="informalexample"><pre class="programlisting">    getInnerName: function(){
          
        return this.name;
    }</pre></div><p>In this method, we specifically qualify the context for <code class="literal">name</code> using the <code class="literal">this</code> keyword, which references the context of the singleton object itself as opposed to the containing function. Thus, if we run the following code:</p><div class="informalexample"><pre class="programlisting">console.log(mySingletonObj.getInnerName()); // displays "Tom"</pre></div><p>The <a id="id113" class="indexterm"/>value assigned to <code class="literal">name</code> in the context of the singleton object is returned. This is an important distinction to keep in mind.</p></div><div class="section" title="Adding properties to an interface in module pattern"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Adding properties to an interface in module pattern</h2></div></div></div><p>Now<a id="id114" class="indexterm"/> that we have seen how internal private scope is at in play when we use the module pattern, let's see what happens if we add new dynamic properties to the singleton object returned in our previous example.</p><p>Consider the following line of code:</p><div class="informalexample"><pre class="programlisting">mySingletonObj.name = "Jack";</pre></div><p>Here, we are simply adding a new property dynamically to our object <code class="literal">mySingletonObj</code>. This property happens to have the same identifier as an already existing property on the object. What happens to the original value of the <code class="literal">name</code> property?</p><p>We can find out by running the following tests:</p><div class="informalexample"><pre class="programlisting">console.log(mySingletonObj.name); // displays "Jack"
console.log(mySingletonObj.getOuterName()); // displays "Sasan"
console.log(mySingletonObj.getInnerName()); // displays "Jack"</pre></div><p>As you can see, the new value of the singleton object's property is displayed regardless of whether we directly access the property or use our singleton's method to return the value of the property.</p><p>On the other hand, as expected, no changes have taken place in the value of the property contained in the container function's context, even though our singleton object does have access to this context.</p><p>Remember, when we use the module pattern in JavaScript and return a singleton object from it (as an interface to the containing object/function), there are two contexts that are at play.</p><p>First, the internal private scope of the container function, which our singleton object has access to through closure.</p><p>The second is the context of the singleton object itself as with any other object in JavaScript. It is important to understand the distinction between the two contexts when you design your modules using the module pattern in JavaScript.</p><p>Another important point to keep in mind is that the code structure (pattern) shown previously allows us to have both object encapsulation and access control on the properties defined in a private namespace. In this case, the anonymous function creates a namespace that returns an anonymous object or, more accurately, a reference to the anonymous object (the singleton object) as an interface.</p><p>This<a id="id115" class="indexterm"/> approach becomes very valuable since now we can be sure that no external code is able to either intentionally or accidentally change the values of the properties in our namespace. This structure provides control over what properties are accessible by the outside code and what properties are hidden away and protected in the private scope.</p></div><div class="section" title="Object factory module"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Object factory module</h2></div></div></div><p>We can<a id="id116" class="indexterm"/> design our modules to be very specialized <a id="id117" class="indexterm"/>chunks of code that do very specific tasks, while protecting their internals from external code interferences. So far, we have looked at a very simple pattern for creating modules. We can take this pattern a step further and design a module that creates instances of an object, adds properties to these instances, and then returns them to the code external to the module.</p><p>Consider the following module:</p><div class="informalexample"><pre class="programlisting">var myCarFactoryModule = function() {
  
    var createdCars = [];

    function carFactory() {
      
        // could also use "var newCar = {}";  
        var newCar = new Object();
      
        newCar.type = arguments[0];
        newCar.color = arguments[1];
        newCar.gearType = arguments[2];
        newCar.cylinder = arguments[3];
        createdCars.push(newCar);
        return newCar;
    }
    return {
      
        // privileged method
        createCar: function(type, color, gearType, cylinder) {
            return carFactory(type, color, gearType, cylinder);
        },
      
        // privileged method
        getCarCount: function() {
            return createdCars.length;
        },
      
        // privileged method
        removeCar: function(index) {
            createdCars.splice(index, 1);
        }
    };
}();</pre></div><p>As <a id="id118" class="indexterm"/>you can see in this code, we have combined two <a id="id119" class="indexterm"/>patterns together: the <span class="strong"><strong>object factory</strong></span> pattern and the module pattern.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>
<span class="strong"><strong>Design patterns in JavaScript</strong></span>
</p><p>If you are not familiar with design patterns in general or would like to become more familiar with design patterns in JavaScript, I highly recommend the following resource:</p><p>
<span class="emphasis"><em>Mastering JavaScript Design Patterns</em></span> by <span class="emphasis"><em>Simon Timms</em></span>.</p></div></div><p>When our function <code class="literal">myCarFactoryModule</code> is called, based on the parameters passed in, we create an instance of a car and then we assign it to an array which is the repository for all instances of the cars created. We have designed this module in such a way that the external code to the module has no access to the method that creates the cars, nor has access to the car repository.</p><p>Let's test this using the following code:</p><div class="informalexample"><pre class="programlisting">var myFirstCar = myCarFactoryModule.createCar("Sedan", "red", "automatic",4); // creates first instance of car

var mySecondCar = myCarFactoryModule.createCar("SUV", "Silver", "Standard",6); // creates second instance of car

console.log(myFirstCar.color); // displays "red"
console.log(mySecondCar.gearType); // displays "Standard"

var myTotalCars = myCarFactoryModule.getCarCount();
console.log(myTotalCars); //displays 2

myCarFactoryModule.removeCar(0); // removes the first care object

var myTotalCars = myCarFactoryModule.getCarCount();
console.log(myTotalCars); // displays 1</pre></div><p>As you can see, the outside code can call our module's interface to create cars and also get a count on the number of the cars created. It can also remove a car, if it is desired to do so.</p><p>There <a id="id120" class="indexterm"/>are three privileged methods in this module: <code class="literal">createCar</code>, <code class="literal">getCarCount</code>, and <code class="literal">removeCar</code>. You can think of these methods as bridges<a id="id121" class="indexterm"/> between the internals of the module, which are hidden away from the outside world, and the external code, which relies on the internals of the module to do some specific tasks.</p><p>The privileged methods (which are members of the singleton interface object) are exposed to the external code to provide the module's functionality to whoever needs its services.</p><p>There is a notable advantage to this design. As you might have noticed, we can modify the code inside our module and add additional functionality to the module without affecting how other parts of our application can interact with our module.</p><p>This is true, as long as we don't change the name or the functionality of the privileged methods that provide access for the external code to utilize the module's functionality.</p><p>At the same time, we can add new privileged methods to the interface of the module or modify the internals of our current privileged methods in the singleton object without affecting the internal code of the module itself.</p><p>This allows us to have a good separation of concerns and responsibilities between the exposed part of our module (the module's interface) and the private internals of the module.</p></div></div></div>
<div class="section" title="Creating loose coupling among modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Creating loose coupling among modules</h1></div></div></div><p>In a<a id="id122" class="indexterm"/> modular design, an application is often created using many modules. In order for these modules to work together, we need to create coupling among them, without the modules being tightly dependent on each other.</p><p>Let's create an application based on a few simple modules and have the modules interact with each other in a loosely coupled manner. Of course, we will keep this application very simple for now. In later chapters, we will take the concepts utilized in this application and build upon them to create our fully modularized application ecosystem.</p><p>I'm making the safe assumption here that our future application will consist of many separate modules, with each one of them being responsible for doing a very specific task.</p><p>We will start by creating our core application module and calling it <code class="literal">ApplicationInitModule</code>. Usually, the very first step in running an application is to take care of the application's initialization tasks. Our <code class="literal">ApplicationInitModule</code> will be designed to do just that.</p><p>In the<a id="id123" class="indexterm"/> following code snippet, when <code class="literal">ApplicationInitModule</code> is started, it will in turn start all the registered modules and their initialization routines. This process will take care of the application's initialization routine as a whole.</p><p>Have a look at the following code and see how our application is designed:</p><div class="informalexample"><pre class="programlisting">var ApplicationInitModule = function() {
    var registeredModules = [];
  
    return {
        registerModule: function(module) {
            registeredModules.push(module);
        },
        getAppModulesCount: function() {
            return registeredModules.length;
        },
        removeRegisteredModule: function(index) {
            registeredModules.splice(index, 1);
        },
        initializeAllModules: function() {
            for (var module in registeredModules) {
                registeredModules[module].initialize();
            }
        },
    };
}();

var GlobalApp = (function() {
    var registerModule = ApplicationInitModule.registerModule;
    return {
        registerModule: registerModule
    };
})();

var testModule1 = (function() {
    var self = {};
    var moduleName = "Module 1";
  
    self.initialize = function() {
        //displays "testmodule1 has been initialized!"
        console.log("testmodule1 has been initialized!");
        //displays "module name is: Module 1"
        console.log("module name is: " + moduleName);
    };
  
    (function() {
        GlobalApp.registerModule(self);
    })();
  
    return {
        initialize: self.initialize,
        getName: function() {
            return moduleName;
        }
    };
})();

var testModule2 = (function() {
    var moduleName = "Module 2";

    function initialize() {
        //displays "testmodule2 has been initialized!"
        console.log("testmodule2 has been initialized!");
    }
    return {
        initialize: initialize
    };
})();
GlobalApp.registerModule(testModule2);</pre></div><p>As<a id="id124" class="indexterm"/> you can see, a few interesting things are taking place in this application, but all the techniques used, we have already discussed in this book. Nonetheless, I'll go through each piece and explain the inner workings of each module.</p><div class="section" title="Application core module"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Application core module</h2></div></div></div><p>The code <a id="id125" class="indexterm"/>starts by defining <code class="literal">ApplicationInitModule</code> as an application initializer module. The purpose of this module is to register all the available modules in the application (store them in an array) and then initialize them all (one at a time), when the application runs.</p><p>This module also provides an interface with some hooks for the external code to interact with it. As you can see, there are methods to register a module, get the count of all the modules registered in the app for initialization, and remove a module from the list of registered modules; of course, there is also a method to initialize all modules that have been registered with the app.</p><p>In this module, we are using an IIFE to return a reference to an anonymous singleton object, which is essentially the interface of the module.</p><p>One<a id="id126" class="indexterm"/> of the points that I'd like to draw your attention to is the fact that the functionality of this module is really defined in its interface. However, the module didn't have to be designed in this manner. You can also see that, in the other modules shown in the previous code, I have not used this approach. This is so you can see how we can implement the module pattern in various ways.</p></div><div class="section" title="Application Mediator module"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Application Mediator module</h2></div></div></div><p>Our <code class="literal">GlobalApp</code> module also uses an IIFE to return a singleton object as the interface to the <a id="id127" class="indexterm"/>module. The whole purpose of this module is to act as a mediator (abstraction layer) between <code class="literal">testModule1</code>, <code class="literal">testModule2</code>, and our core module, <code class="literal">ApplicationInitModule</code>.</p><p>We have designed the application this way so we can create a loose coupling between our core module and the other registered modules. As you can see, <code class="literal">GlobalApp</code> has been designed as a very thin layer.</p><p>This thin layer allows us to change our core module (<code class="literal">ApplicationInitModule</code>) as we please and even change its interface to the outside world, without affecting the other modules that rely on this module's functionality.</p><p>In our design, the only module which relies directly on the <code class="literal">ApplicationInitModule</code> interface is our <code class="literal">GlobalApp</code> module. This means that, if there are any changes to the interface of <code class="literal">ApplicationInitModule</code>, we only need to make modifications to our thin mediator layer <code class="literal">GlobalApp</code>. All the other modules in the application will be unaffected, as they still use the same thin layer interface provided by <code class="literal">GlobalApp</code>.</p><p>You will see in the future chapters of this book that this thin layer is called the <span class="strong"><strong>sandbox</strong></span> and we will be using this concept of sandboxing to isolate our application modules/components from our application's core module(s). We will also use the same technique to isolate the modules/components from each other. For now, just try to become familiar with the general idea of module isolation (sandboxing) as shown in the previous application.</p></div><div class="section" title="Application non-core modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Application non-core modules</h2></div></div></div><p>In our <a id="id128" class="indexterm"/>application implementation, we have<a id="id129" class="indexterm"/> created two simple modules that register themselves with the core module and really do nothing other than announcing to the world that they have been initialized.</p><p>Let's have a closer look at how these modules have been implemented.</p><div class="section" title="testModule1 implementation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec06"/>testModule1 implementation</h3></div></div></div><p>In <code class="literal">testModule1</code>, we have created an empty object called <code class="literal">self</code>, which gets augmented with a method <a id="id130" class="indexterm"/>called <code class="literal">initialize</code>. This is the method that will be called when our core module tries to initialize this module.</p><p>The registration of this module with the core module happens using an internal IIFE, which in turn calls our mediator module <code class="literal">GlobalApp</code> with a reference to the object <code class="literal">self</code>. This is implemented as shown below:</p><div class="informalexample"><pre class="programlisting">(function(){
    
    GlobalApp.registerModule(self);        
    
})(); </pre></div><p>Of course, the <code class="literal">GlobalApp.registerModule</code> method is in fact a reference to the core module's method, <code class="literal">ApplicationInitModule.registerModule</code>. However, <code class="literal">testModule1</code> does not know that and is only aware of <code class="literal">GlobalApp</code> provided interface, <code class="literal">GlobalApp.registerModule</code>.</p><p>We have also used an IIFE to return an interface to this module, which is available through the <code class="literal">testModule1</code> variable.</p><p>Note that the interface provides two properties. One is a reference to the <code class="literal">self.initialize</code> method of the module and the other, <code class="literal">getName</code>, simply returns the value of the encapsulated and hidden <code class="literal">moduleName</code> variable. Also note that <code class="literal">moduleName</code> is not a property on the <code class="literal">self</code> object. Instead, it is implemented as a containing function's property.</p></div><div class="section" title="testModule2 implementation"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec07"/>testModule2 implementation</h3></div></div></div><p>Our <code class="literal">testModule2</code> is implemented a little differently in comparison to <code class="literal">testModule1</code>. As shown<a id="id131" class="indexterm"/> in the code, we have simply defined a function inside our module called <code class="literal">initialize</code> that is exposed to the external code indirectly through the interface returned from our IIFE for this module.</p><p>In our <code class="literal">testModule2</code>, the <code class="literal">moduleName</code> variable is completely sealed from the outside world as there are no methods defined on the interface to provide access to this variable.</p><p>There is also no internal IIFE that registers the module with our core module, <code class="literal">ApplicationInitModule</code>, thus we need to make a call outside of our module definition to achieve this task, as shown here:</p><div class="informalexample"><pre class="programlisting">GlobalApp.registerModule(testModule2);</pre></div><p>Notice that we have used our mediator module <code class="literal">GlobalApp</code> for this registration again and we are not directly calling the related method on the core module. This allows us to still preserve <a id="id132" class="indexterm"/>our loose coupling among the modules.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>
<span class="strong"><strong>Design Pattern used in testModule2</strong></span>
</p><p>The way we have implemented <code class="literal">testModule2</code> is based on a design pattern known as <span class="strong"><strong>revealing module pattern</strong></span>, in its simplest form. This is a very popular <a id="id133" class="indexterm"/>pattern for designing modules but of course there are various ways of implementing modules, as we have already seen. We will see even more patterns for implementing modules in the upcoming chapters. To get a better understanding of this pattern, please refer to previously mentioned resource for JavaScript design patterns.</p></div></div></div><div class="section" title="Auto-initialization of application modules"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec08"/>Auto-initialization of application modules</h3></div></div></div><p>So far<a id="id134" class="indexterm"/> we have seen how our application modules use a mediator module to register themselves with our application's core module, without being aware of the existence of the core module.</p><p>We also noted that communication among modules was done through the interfaces that were provided by the modules to the outside world. Only such interfaces had access to the internals of the modules and their internal private scope.</p><p>The following diagram depicts the relationships that exist among our application modules and provides an overall view of our application:</p><div class="mediaobject"><img src="graphics/B04910_03_01.jpg" alt="Auto-initialization of application modules"/></div><p>Let's have a look at the method in the core module that is responsible for calling initialization methods on all of our registered modules.</p><p>Remember that a reference to each application module registered with the core module has been added to the array <code class="literal">registeredModules</code>. This is shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">registerModule : function(module){
      
        registeredModules.push(module);
}</pre></div><p>When <a id="id135" class="indexterm"/>we call the <code class="literal">initializeAllModules</code> method in our application (on the core module), a <code class="literal">for</code> loop is used to call the <code class="literal">initialize</code> method on all the registered modules. This is done as follows:</p><div class="informalexample"><pre class="programlisting">initializeAllModules: function(){
    
    for(var module in registeredModules){
        
        registeredModules[module].initialize();
        
    }
};</pre></div><p>As you can see, <code class="literal">initializeAllModules</code> has no idea what each registered module's <code class="literal">initialize</code> method does when it is called. All it knows is to call the <code class="literal">initialize</code> method on the registered module and let the module take care of its own initialization tasks.</p><p>This is a very important point when we modularize our code. Each module only deals with tasks that are specific to that module's design and none of the other modules have any knowledge of how such tasks are done in that module.</p><p>This means, while our core module calls the <code class="literal">initialize</code> method on one or many modules, it does not directly get involved with the initialization tasks of each module.</p><p>It is time to run a test and see how application initialization takes place. Consider the following:</p><div class="informalexample"><pre class="programlisting">// displays 
// "testmodule1 has been initialized!" 
// "module name is: Module 1"
// "testmodule2 has been initialized!" 
ApplicationInitModule.initializeAllModules();</pre></div><p>When we run the preceding code, we can see that both of our modules report that they have been successfully initialized.</p><p>Of course, we have designed our application in such a way that all the registered modules do have an accessible method called <code class="literal">initialize</code>. This allows us to use an array and a <code class="literal">for</code> loop to initialize them all in sequence.</p></div></div><div class="section" title="Module initialization and design considerations"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Module initialization and design considerations</h2></div></div></div><p>At <a id="id136" class="indexterm"/>the application design time, you decide on how the <a id="id137" class="indexterm"/>modules should be initialized and how the initialization method in each module should be called. The important point is that calling the initialization routine of each module should not cause a tight coupling.</p><p>For consistency reasons, as well as ease of maintainability, I usually name the methods which are responsible for initialization tasks in all of my application modules: <code class="literal">initialize</code> or <code class="literal">init</code>. This allows me to use a <code class="literal">for</code> loop to call all the registered modules in sequence and ask the modules to initialize themselves accordingly.</p><p>Keep in mind that creating loose coupling among modules is only possible as long as the interfaces (public method hooks) in our modules do not change their names and their accessibility for the external code.</p><p>This means that, for example, if <code class="literal">testModule1</code> calls the <code class="literal">GlobalApp.registerModule</code> method to register itself, it should always be able to call that method for registration. This should hold true even if the mechanism of how this registration takes place changes internally in the <code class="literal">GlobalApp</code> object.</p><p>The architecture and design that you saw in our simple application here creates a foundation for creating loose coupling among our application modules. This in turn leads to a more extensible and maintainable implementation for both small and large applications.</p><p>You can look at module interfaces as contracts among modules, which enables them to interact with each other regardless of how the internals of such contracts are implemented. Note that, while there are contracts among modules in the application, there is no direct dependency among them. Each module is free to decide on how to implement its specific functionality to accomplish the tasks that it was designed to do.</p><p>This is so, as long as the module provides the functionality and the service which is expected from it.</p><p>This approach will provide a great deal of flexibility and extensibility for our application. It allows us to add, remove, and modify various parts of our application in a very targeted and manageable manner without such changes having an impact on other pieces of the application.</p><p>The fundamental architectural concepts that we discussed here are the concepts that will form the building blocks of the final application that we will build in this book.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we looked at one of the most popular design patterns in JavaScript: module pattern.</p><p>By creating simple modules, we explored various aspects of internal private scope in module pattern and saw how modules can interact with each other, without having access to the protected properties of each other's private scope.</p><p>This pattern allows us to create encapsulation and access control in our objects and modules, while providing an interface for the external code to leverage the implemented functionality intended for external use.</p><p>One of the most important aspect of module pattern is how it can be used to create a modular design for our application as a whole. This enables us to create loose coupling among our modules, which are essentially the building blocks of our application.</p><p>In later chapters, we will utilize this approach and slowly build more complex modules to create a robust and easily maintainable code base for our application. These modules can also be easily reused as needed, in all of our future applications.</p></div></body></html>