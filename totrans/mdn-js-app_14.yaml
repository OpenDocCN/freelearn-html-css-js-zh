- en: Chapter 14. Securing and Scaling Node.js Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's very important to scale and secure your applications. Scaling and securing
    are not one-time tasks. You need to keep making changes to your code as you add
    new features to increase application security, and as your application traffic
    and data increases, you need to scale your servers. In this chapter, you will
    learn how to make Node.js applications more secure and how to scale Node.js applications.
    I will be assuming that your are using Express for creating your web server as
    it is the most common.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Application vulnerabilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-vulnerability attacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various third-party services to protect your application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking security issues in third-party packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques of distributing traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common vulnerabilities in applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: According to Wikipedia, a **vulnerability** is a weakness in the application
    that allows an attacker to reduce a system's information assurance. Applications
    expose different types of vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at some important vulnerabilities and how to prevent them.
  prefs: []
  type: TYPE_NORMAL
- en: Helmet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Helmet** is a Node.js library that helps you prevent various attacks by setting
    various security-related HTTP headers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the various headers added by Helmet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Strict-Transport-Policy`: This header is used to enforce secure (HTTP over
    SSL/TLS) connections to the server. HTTPS prevents man-in-the-middle attacks.
    In a man-in-the-middle attack, an attacker secretly alters the communication between
    the client and server. This is done to steal data, add ads to web pages, and so
    on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Frame-Options`: This header provides clickjacking protection. **Clickjacking**
    is a technique by which an attacker uses multiple transparent or opaque layers
    to trick a user into clicking on a button or link on another page when they intended
    to click on the top-level page. Thus, the attacker is "hijacking" clicks meant
    for their page and routing them to some other page, most likely owned by another
    application, domain, or both. This header prevents the application from being
    viewed inside an iFrame, therefore providing clickjacking protection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-XSS-Protection`: This header prevents reflective XSS attacks. Reflective
    XSS attacks are a type of XSS attack. **Cross-Site Scripting** (**XSS**) attacks
    are a type of injection in which malicious scripts are injected into otherwise
    benign and trusted web sites. XSS attacks occur when an attacker uses a web application
    to send malicious code, generally in the form of a browser-side script, to a different
    end user. Reflected XSS is the most frequent type of XSS attack. They are also
    known as non-persistent XSS attacks since the attack payload is delivered and
    executed via a single request and response. Reflected XSS occurs when the attacker
    injects executable JavaScript code into the HTML response by injecting the code
    into the URL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`X-Content-Type-Options`: Browsers can override response `Content-Type` headers
    to guess and process data using an implicit content type. While this can be convenient
    in some scenarios, it can also lead to some kinds of attack, such as a MIME confusion
    attack, authorized hotlinking, and so on. Returning `X-Content-Type-Options` will
    cause browsers to use the provided `Content-Type` header and not interpret the
    content as a different content type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Content-Security-Policy`: This header lets us provide a list of trusted sources
    to the browser, from which content such as JavaScript, CSS, HTML frames, fonts,
    images, and embeddable objects (Java applets, ActiveX, audio, and video) can be
    loaded onto a page. This helps us prevent XSS attacks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To learn more about Helmet, visit [https://www.npmjs.com/package/helmet](https://www.npmjs.com/package/helmet)
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site request forgery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Cross-site request forgery** (**CSRF**) is a type of attack in which requests
    from a user are sent to servers without the user knowing about it.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if an attacker is able to find a reproducible link that executes
    a specific action on the target page while the victim is logged in to it, he is
    able to embed such a link on a page he controls and trick the victim into opening
    it. The attack-carrying link may be placed in a location that the victim is likely
    to visit while logged in to the target site sent in a HTML e-mail body or attachment.
  prefs: []
  type: TYPE_NORMAL
- en: There are various ways to prevent CSRF attacks. Most CSRF prevention techniques
    work by embedding additional authentication data into requests, which allows the
    web application to detect requests from unauthorized locations.
  prefs: []
  type: TYPE_NORMAL
- en: There is a library named `csrf` ([https://www.npmjs.com/package/csrf](https://www.npmjs.com/package/csrf))
    for Node.js that lets you prevent CSRF attacks. It provides you middleware to
    protect Express web servers from CSRF attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We saw earlier what the XSS vulnerability is. We basically saw what a reflected
    XSS attack is. There is another type of XSS attack called **stored XSS**.
  prefs: []
  type: TYPE_NORMAL
- en: Stored XSS occurs when the application stores user input that is not correctly
    filtered. For example, while chatting, if a message is not sanitized, then both
    users can run scripts on each other's browsers by sending JS code within `<script>`
    tags as messages.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent both types of XSS attack, we should always filter/sanitize user input.
  prefs: []
  type: TYPE_NORMAL
- en: Session fixation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Session fixation** is an attack that permits an attacker to hijack a valid
    user session. Here are several techniques to prevent session fixation:'
  prefs: []
  type: TYPE_NORMAL
- en: Set session timeouts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regenerate session tokens frequently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When logged out, expire the session token
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store the user agent and IP address of the user when creating a session and
    check whether the value matches during the following HTTP requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-vulnerability based attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various kinds of attack that can be made on any kind of application,
    as they depend on loopholes in the application. Still, applications can do a lot
    to prevent these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see a few of the most common non-vulnerability-based attacks and how to
    prevent them.
  prefs: []
  type: TYPE_NORMAL
- en: Denial-of-service attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **denial-of-service** (**DoS**) attack is an attempt to make a server machine
    unavailable to its intended users temporarily. An attacker uses one or many machines
    to make continuous requests to the server to take it down.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to prevent DoS is to use an external service such as CloudFlare,
    which uses a lot of different techniques and data from various sources to block
    malicious requests on your server. It's always better to avoid handling DoS on
    your server and leave it to a service created by DoS experts.
  prefs: []
  type: TYPE_NORMAL
- en: Brute force attacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **brute force attack** aims at being the simplest kind of method to gain
    access to a site: trying usernames and passwords, over and over, until it gets
    in.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are several ways to prevent brute force attacks:'
  prefs: []
  type: TYPE_NORMAL
- en: We can embed CAPTCHA in forms that can completely prevent bots from making brute
    force attacks and slow down brute force attacks made by humans.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a middleware program for Express servers called **express-brute** that
    limits the rate of incoming requests based on several factors. You can find out
    more about **express-brute** at [https://www.npmjs.com/package/express-brute](https://www.npmjs.com/package/express-brute).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using secure packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The npm packages you use may contain critical security vulnerabilities that
    could also affect your application. It's not possible to go through every package's
    code or test each of them separately.
  prefs: []
  type: TYPE_NORMAL
- en: There is a database called `Node Security Project` that has a list of the most
    important vulnerable packages. You can use command-line tools such as `nsp` ([https://www.npmjs.com/package/nsp](https://www.npmjs.com/package/nsp))
    and `requireSafe` ([https://www.npmjs.com/package/requiresafe](https://www.npmjs.com/package/requiresafe))
    to check the vulnerable dependencies of your application.
  prefs: []
  type: TYPE_NORMAL
- en: You should always keep an eye on the new version releases of the packages that
    your application is dependent on and update it, as a new release often fixes issues
    related to security.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Node.js servers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If your application has lots of users accessing the system simultaneously, then
    obviously a single server cannot handle all the traffic. It will slow down and
    crash. Therefore, we need to deploy the application on multiple servers and then
    distribute the traffic equally between them.
  prefs: []
  type: TYPE_NORMAL
- en: To distribute traffic between servers, we need to use something called a **load
    balancer**. A load balancer is a server that sits in front of the application
    servers. The client communicates with the load balancer instead of the application
    servers, and instead of handling the request, the load balancer forwards it to
    an application server; when the application servers sends the response, it sends
    the same response to the client.
  prefs: []
  type: TYPE_NORMAL
- en: As a load balancer doesn't actually process the request, it can handle many
    more requests than an application server. Obviously, a load balancer cannot handle
    unlimited requests, so we can use multiple load balancers. When we use multiple
    load balancers, the traffic between them is distributed by using the round-robin
    DNS technique. In round-robin DNS, the IP address of the domain pointing to the
    load balancer changes according to an appropriate statistical model.
  prefs: []
  type: TYPE_NORMAL
- en: '**Amazon Web Services** (**AWS**) provides a load balancer called Amazon ELB,
    which can be used to distribute traffic between Amazon EC2 servers, that is, application
    servers. Obviously, it difficult to predict the total number of EC2 instances
    you would need to scale your application; therefore, AWS also provides something
    called **auto scaling**, which can add/remove EC2 instances as needed. Therefore,
    to host a large-scale application, Amazon is the best choice. It also provides
    lots of other cloud services to scale and deploy your application.'
  prefs: []
  type: TYPE_NORMAL
- en: In case you don't want to worry about scaling, deploying, and managing your
    servers, then you can use cloud services such as Heroku, which makes it much easier
    to achieve all this, and you just need to worry about the application code—that's
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw a lot of services and libraries to scale and secure
    Node.js applications. We saw various vulnerabilities and how to prevent them.
    Make sure you take regular backups of your data so that even if your app is hacked,
    you will still have a chance to get the application running again as the data
    is not lost. Obviously, there is a lot more to learn about scaling and securing
    Node.js applications as this is an unending topic and new things come up regularly.
  prefs: []
  type: TYPE_NORMAL
