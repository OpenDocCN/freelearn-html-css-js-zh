- en: Multiuser Authentication the Microservice Way
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our Notes application can save its data in a database, we can think
    about the next phase of making this a real application, namely authenticating
    our users.
  prefs: []
  type: TYPE_NORMAL
- en: It's so natural to log in to a website to use its services. We do it every day,
    and we even trust banking and investment organizations to secure our financial
    information through login procedures on a website. HTTP is a stateless protocol,
    and a web application cannot tell much about one HTTP request versus another.
    Because HTTP is stateless, HTTP requests do not natively know whether the user
    driving the web browser is logged in, the user's identity, or even whether the
    HTTP request was initiated by a human being.
  prefs: []
  type: TYPE_NORMAL
- en: The typical method for user authentication is to send a cookie to the browser
    containing a token to carry user identity. The cookie needs to contain data identifying
    the browser and whether that browser is logged in. The cookie will then be sent
    with every request, letting the application track which user account is associated
    with the browser.
  prefs: []
  type: TYPE_NORMAL
- en: With Express, the best way to do this is with the `express-session` middleware.
    It stores data as a cookie and looks for that data on every browser request. It
    is easy to configure, but is not a complete solution for user authentication.
    There are several add-on modules that handle user authentication, and some even
    support authenticating users against third-party websites, such as Facebook or
    Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: One package appears to be leading the pack in user authentication – Passport
    ([http://passportjs.org/](http://passportjs.org/)). It supports a long list of
    services against which to authenticate, making it easy to develop a website that
    lets users sign up with credentials from another website, for example, Twitter.
    Another, express-authentication ([https://www.npmjs.com/package/express-authentication](https://www.npmjs.com/package/express-authentication)),
    bills itself as the opinionated alternative to Passport.
  prefs: []
  type: TYPE_NORMAL
- en: We will use Passport to authenticate users against both a locally stored user
    credentials database and using OAuth2 to authenticate against a Twitter account.
    We'll also take this as an opportunity to explore REST-based microservice implementation
    with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll discuss the following three aspects of this phase:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a microservice to store user profile/authentication data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User authentication with a locally stored password.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using OAuth2 to support authentication via third-party services. Specifically,
    we'll use Twitter as a third-party authentication service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to do is duplicate the code used for the previous chapter. For
    example, if you kept that code in `chap07/notes`, create a new directory, `chap08/notes`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a user information microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We could implement user authentication and accounts by simply adding a user
    model, and a few routes and views to the existing *Notes* application. While it
    would be accomplishable, is this what we would do in a real-world production application?
  prefs: []
  type: TYPE_NORMAL
- en: Consider the high value of user identity information, and the super-strong need
    for robust and reliable user authentication. Website intrusions happen regularly,
    and it seems the item most frequently stolen is user identities.
  prefs: []
  type: TYPE_NORMAL
- en: Can you design and build a user authentication system with the required level
    of security?  One that is probably safe against all kinds of intruders?
  prefs: []
  type: TYPE_NORMAL
- en: As with so many other software development problems, it's best to use a pre-existing
    authentication library, preferably one with a long track record, where significant
    bugs have been fixed already.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue is architectural choices to promote security. Bugs will occur
    and the talented miscreants will break in. Walling off the user information database
    is an excellent idea to limit the risk.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping a user information database enables you to authenticate your users,
    present user profiles, help users connect with each other, and so forth. Those
    are useful services to offer to website users, but how can you limit the risk
    that data will fall into the wrong hands?
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll develop a user authentication microservice. The plan
    is to eventually segregate that service into a well-protected barricaded area.
    This mimics an architectural choice made by some sites, to strictly control API
    and even physical access to the user information database, implementing as many
    technological barriers as possible against unapproved access.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices are, of course, not a panacea, meaning we shouldn't try to force-fit
    every application into the microservice box. By analogy, microservices are like
    the Unix philosophy of small tools each doing one thing well, which we mix/match/combine
    into larger tools. Another word for this is composability. While we can build
    a lot of useful software tools with that philosophy, does it work for applications
    such as Photoshop or LibreOffice?  While composing a system out of single-purpose
    tools is highly flexible, one loses the advantages gained by tight integration
    of components.
  prefs: []
  type: TYPE_NORMAL
- en: The first question is whether to use a REST-service oriented framework, code
    the REST application on bare Node.js, or what? You could implement REST services
    on the built-in `http` module. The advantage of using an application framework
    is the framework authors will have already baked-in a lot of best practices and
    bug fixing and security measures. Express, for example, is widely used, very popular,
    and can easily be used for REST services. There are other frameworks more aligned
    with developing REST services, and we'll use one of them – Restify ([http://restify.com/](http://restify.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The user authentication server will require two modules:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Restify, implementing the REST interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A data model using Sequelize to store user data objects in an SQL database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To test the service, we'll write a couple of simple scripts for administering
    user information in the database. We won't be implementing an administrative user
    interface in the *Notes* application, and will rely on the scripts to administer
    the users. As a side effect, we'll have a tool to run a couple of simple tests
    against the user service.
  prefs: []
  type: TYPE_NORMAL
- en: After this service is functioning correctly, we'll set about modifying the Notes
    application to access user information from the service, while using Passport
    to handle authentication.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is creating a new directory to hold the User Information microservice.
    This should be a sibling directory to the Notes application. If you created a
    directory named `chap08/notes` to hold the Notes application, then create a directory
    named `chap08/users` to hold the microservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This gets us ready to start coding. We'll use the `debug` module for logging
    messages, `js-yaml` to read the Sequelize configuration file, `restify` for its
    REST framework, and `sequelize/mysql/sqlite3` for database access.
  prefs: []
  type: TYPE_NORMAL
- en: User information model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll be storing the user information using a Sequelize-based model in an
    SQL database. As we go through this, ponder a question: should we integrate the
    database code directly into the REST API implementation? Doing so would reduce
    the user information microservice to one module, with database queries mingled
    with REST handlers. By separating the REST service from the data storage model,
    we have the freedom to adopt other data storage systems besides Sequelize/SQL.
    Further, the data storage model could conceivably be used in ways other than the
    REST service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file named `users-sequelize.mjs` in `users`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As with our Sequelize-based model for Notes, we use a YAML file to store connection
    configuration. We're even using the same environment variable, `SEQUELIZE_CONNECT`.
  prefs: []
  type: TYPE_NORMAL
- en: What is the best storage service for user authentication data? By using Sequelize, we
    have our pick of SQL databases to choose from. While NoSQL databases are all the
    rage, is there any advantage to using one to store user authentication data? 
    Nope. An SQL server will do the job just fine, and Sequelize allows us the freedom
    of choice.
  prefs: []
  type: TYPE_NORMAL
- en: It's tempting to simplify the overall system by using the same database instance to
    store notes and user information, and to use Sequelize for both. But we've chosen
    to simulate a secured server for user data. That calls for the data to be in separate
    database instances, preferably on separate servers. A highly secure application
    deployment might put the user information service on completely separate servers,
    perhaps in a physically isolated data center, with carefully configured firewalls,
    and there might even be armed guards at the door.
  prefs: []
  type: TYPE_NORMAL
- en: 'The user profile schema shown here is derived from the normalized profile provided
    by Passport; refer to [http://www.passportjs.org/docs/profile](http://www.passportjs.org/docs/profile)
    for more information. Passport will harmonize information given by third-party
    services into a single object definition. To simplify our code, we''re simply
    using the schema defined by Passport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `create` and `update` functions take user information and either add a
    new record or update an existing record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This lets us look up a user information record, and we return a sanitized version
    of that data.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Sequelize returns a `Promise` object. Because this is executed
    inside an `async` function, the `await` keyword will resolve the Promise, causing any error
    to be thrown or results to be provided as the return value. In turn, async functions
    return a `Promise` to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we''re segregating the user data from the rest of the Notes application,
    we want to return a sanitized object rather than the actual `SQUser` object. What
    if there was some information leakage because we simply sent the `SQUser` object
    back to the caller? The `sanitizedUser` function, shown later, creates an anonymous
    object with exactly the fields we want exposed to the other modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets us support deleting user information. We do this as we did for the
    Notes Sequelize model, by first finding the user object and then calling its `destroy`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets us support the checking of user passwords. The three conditions to
    handle are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Whether there's no such user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether the passwords matched
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether they did not match
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The object we return lets the caller distinguish between those cases. The `check`
    field indicates whether to allow this user to be logged in. If `check` is false,
    there''s some reason to deny their request to log in, and the `message` is what
    should be displayed to the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This combines two actions in one function: first, to verify whether the named
    user exists and, if not, to create that user. Primarily, this will be used while
    authenticating against third-party services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'List the existing users. The first step is using `findAll` to give us the list
    of the users as an array of `SQUser` objects. Then we sanitize that list so we
    don''t expose any data that we don''t want exposed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is our utility function to ensure we expose a carefully controlled set
    of information to the caller. With this service, we're emulating a secured user
    information service that's walled off from other applications. As we said earlier,
    this function returns an anonymous sanitized object where we know exactly what's
    in the object.
  prefs: []
  type: TYPE_NORMAL
- en: It's very important to decode the JSON string we put into the database. Remember
    that we stored the `emails` and `photos` data using `JSON.stringify` in the database.
    Using `JSON.parse`, we decode those values, just like adding hot water to instant
    coffee produces a drinkable beverage.
  prefs: []
  type: TYPE_NORMAL
- en: A REST server for user information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are building our way towards integrating user information and authentication
    into the Notes application. The next step is to wrap the user data model we just
    created into a REST server. After that, we'll create a couple of scripts so that
    we can add some users, perform other administrative tasks, and generally verify
    that the service works. Finally, we'll extend the Notes application with login
    and logout support.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `package.json` file, change the `main` tag to the following line of
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create a file named `user-server.mjs`, containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `createServer` method can take a long list of configuration options. These
    two may be useful for identifying information.
  prefs: []
  type: TYPE_NORMAL
- en: As with Express applications, the `server.use` calls initialize what Express
    would call middleware functions, but which Restify calls handler functions. These
    are callback functions whose API is `function (req, res, next)`. As with Express,
    these are the request and response objects, and `next` is a function which, when
    called, carries execution to the next handler function.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Express, every handler function must call the `next` function. In order
    to tell Restify to stop processing through handlers, the `next` function must
    be called as `next(false)`. Calling `next` with an `error` object also causes
    the execution to end, and the error is sent back to the requestor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The handler functions listed here do two things: authorize requests and handle
    parsing parameters from both the URL and the `post` request body. The `authorizationParser`
    function looks for HTTP basic auth headers. The `check` function is shown later
    and emulates the idea of an API token to control access.'
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [http://restify.com/docs/plugins-api/](http://restify.com/docs/plugins-api/) for
    more information on the built-in handlers available in Restify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this to `user-server.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As for Express, the `server.VERB` functions let us define the handlers for specific
    HTTP actions. This route handles a POST on `/create-user`, and, as the name implies,
    this will create a user by calling the `usersModel.create` function.
  prefs: []
  type: TYPE_NORMAL
- en: As a `POST` request, the parameters arrive in the body of the request rather
    than as URL parameters. Because of the `mapParams` flag on the `bodyParams` handler, the
    arguments passed in the HTTP body are added to `req.params`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply call `usersModel.create` with the parameters sent to us. When completed,
    the `result` object should be a `user` object, which we send back to the requestor
    using `res.send`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `/update-user` route is handled in a similar way. However, we have put the
    `username` parameter on the URL. Like Express, Restify lets you put named parameters
    in the URL like as follows. Such named parameters are also added to `req.params`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply call `usersModel.update` with the parameters sent to us. That, too,
    returns an object we send back to the caller with `res.send`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This handles our `findOrCreate` operation. We simply delegate this to the model
    code, as done previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the name implies, we''ll look to see whether the named user already exists
    and, if so, simply return that user, otherwise it will be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we support looking up the user object for the provided `username`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user was not found, then we return a 404 status code because it indicates
    a resource that does not exist. Otherwise, we send the object that was retrieved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how we delete a user from the Notes application. The `DEL` HTTP verb
    is meant to be used to delete things on a server, making it the natural choice
    for this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another aspect of keeping the password solely within this server. The
    password check is performed by this server, rather than in the Notes application.
    We simply call the `usersModel.userPasswordCheck` function shown earlier and send
    back the object it returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, finally, if required, we send a list of Notes application users back
    to the requestor. In case no list of users is available, we at least send an empty
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As with the Notes application, we listen to the port named in the `PORT` environment
    variable. By explicitly listening only on `localhost`, we'll limit the scope of
    systems that can access the user authentication server. In a real deployment,
    we might have this server behind a firewall with a tight list of host systems
    allowed to have access.
  prefs: []
  type: TYPE_NORMAL
- en: This last function, `check`, implements authentication for the REST API itself.
    This is the handler function we added earlier.
  prefs: []
  type: TYPE_NORMAL
- en: It requires the caller to provide credentials on the HTTP request using the
    basic auth headers. The `authorizationParser` handler looks for this and gives
    it to us on the `req.authorization.basic` object. The `check` function simply
    verifies that the named user and password combination exists in the local array.
  prefs: []
  type: TYPE_NORMAL
- en: This is meant to mimic assigning an API key to an application. There are several
    ways of doing so; this is just one.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is not limited to just authenticating using HTTP basic auth. The
    Restify API lets us look at any header in the HTTP request, meaning we could implement
    any kind of security mechanism we like. The `check` function could implement some
    other security method, with the right code.
  prefs: []
  type: TYPE_NORMAL
- en: Because we added `check` with the initial set of `server.use` handlers, it is
    called on every request. Therefore, every request to this server must provide
    the HTTP basic auth credentials required by this check.
  prefs: []
  type: TYPE_NORMAL
- en: 'This strategy is good if you want to control access to every single function
    in your API. For the user authentication service, that''s probably a good idea.
    Some REST services in the world have certain API functions that are open to the
    world and others protected by an API token. To implement that, the `check` function
    should not be configured among the `server.use` handlers. Instead, it should be
    added to the appropriate route handlers as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Such an `authHandler` would be coded similarly to our `check` function. A failure
    to authenticate is indicated by sending an error code and using `next(false)`
    to end the routing function chain.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the complete code for the user authentication server. It defines
    several request URLs, and for each, the corresponding function in the user model
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need a YAML file to hold the database credentials, so create `sequelize-sqlite.yaml`,
    containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Since this is Sequelize, it's easy to switch to other database engines simply
    by supplying a different configuration file. Remember that the filename of this
    configuration file must appear in the `SEQUELIZE_CONNECT` environment variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, `package.json` should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We configure this server to listen on port `3333` using the database credentials
    we just gave and with debugging output for the server code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now start the user authentication server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: But we don't have any way to interact with this server, yet.
  prefs: []
  type: TYPE_NORMAL
- en: Scripts to test and administer the user authentication server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To give ourselves assurance that the user authentication server works, let's
    write a couple of scripts to exercise the API. Because we're not going to take
    the time to write an administrative backend to the Notes application, these scripts
    will let us add and delete users who are allowed access to Notes. These scripts
    will live within the user authentication server package directory.
  prefs: []
  type: TYPE_NORMAL
- en: The Restify package supports coding REST servers. For the REST clients, we're
    using a companion library, `restify-clients`, which has been spun out of Restify.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `users-add.js`, containing the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is the basic structure of a Restify client. We create the `Client` object
    – we have a choice between the `JsonClient`, as used here, the `StringClient`,
    and the `HttpClient`. The HTTP `basicAuth` credentials are easy to set, as shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: Then we make the request, in this case a `POST` request on `/create-user`. Because
    it is a `POST` request, the object we specify here is formatted by Restify into
    `HTTP POST` body parameters. As we saw earlier, the server has the `bodyParser`
    handler function configured, which converts those body parameters into the `req.param`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: In the Restify client, as for the Restify server, we use the various HTTP methods
    by calling `client.METHOD`. Because it is a `POST` request, we use `client.post`.
    When the request finishes, the callback function is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running these scripts, start the authentication server in one window
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run the test script using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can inspect our handiwork using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s write a script, `users-find.js`, to look up a given user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This simply calls the `/find` URL, specifying the `username` that the user supplies
    as a command-line argument. Note that the `get` operation does not take an object
    full of parameters. Instead, any parameters would be added to the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we can write scripts against the other REST functions. But we need
    to get on with the real goal of integrating this into the Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: Login support for the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have proved that the user authentication service is working, we
    can set up the Notes application to support user logins. We'll be using Passport
    to support login/logout, and the authentication server to store the required data.
  prefs: []
  type: TYPE_NORMAL
- en: Among the available packages, Passport stands out for simplicity and flexibility.
    It integrates directly with the Express middleware chain, and the Passport community
    has developed hundreds of so-called Strategy modules to handle authentication
    against a long list of third-party services. See [http://www.passportjs.org/](http://www.passportjs.org/)
    for information and documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the user authentication REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first step is to create a user data model for the Notes application. Rather
    than retrieving data from data files or a database, it will use REST to query
    the server we just created. We could have created user model code that directly
    accesses the database but, for reasons already discussed, we've decided to segregate
    user authentication into a separate service.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now turn to the Notes application, which you may have stored as `chap08/notes`.
    We'll be modifying the application, first to access the user authentication REST
    API, and then to use Passport for authorization and authentication.
  prefs: []
  type: TYPE_NORMAL
- en: For the test/admin scripts that we created earlier, we used the `restify-clients`
    module. That package is a companion to the `restify` library, where `restify`
    supports the server side of the REST protocol and `restify-clients` supports the
    client side. Their names might give away the purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'However nice the `restify-clients` library is, it doesn''t support a Promise-oriented
    API, as is required to play well with `async` functions. Another library, `superagent`,
    does support a Promise-oriented API, plays well in `async` functions, and there
    is a companion to that package, Supertest, that''s useful in unit testing. We''ll
    use Supertest in Chapter 11, *Unit Testing and Functional Testing*, when we talk
    about unit testing. For documentation, see [https://www.npmjs.com/package/superagent](https://www.npmjs.com/package/superagent):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file, `models/users-superagent.mjs`, containing the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `reqURL` function replaces the `connectXYZZY` functions that we wrote in
    earlier modules. With `superagent`, we don''t leave a connection open to the service,
    but open a new connection on each request. The common thing to do is to formulate
    the request URL. The user is expected to provide a base URL, such as `http://localhost:3333/`,
    in the `USER_SERVICE_URL` environment variable. This function modifies that URL,
    using the new WHATWG URL support in Node.js, to use a given URL path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These are our `create` and `update` functions. In each case, they take the data
    provided, construct an anonymous object, and `POST` it to the server.
  prefs: []
  type: TYPE_NORMAL
- en: The `superagent` library uses an API style where one chains together method
    calls to construct a request. The chain of method calls can end in a `.then` or
    `.end` clause, either of which take a callback function. But leave off both, and
    it will return a Promise.
  prefs: []
  type: TYPE_NORMAL
- en: All through this library, we'll use the `.auth` clause to set up the required
    authentication key.
  prefs: []
  type: TYPE_NORMAL
- en: 'These anonymous objects are a little different than usual. We''re using a new
    ES-2015 feature here that we haven''t discussed so far. Rather than specifying
    the object fields using the `fieldName: fieldValue` notation, ES-2015 gives us
    the option to shorten this when the variable name used for `fieldValue` matches
    the desired `fieldName`. In other words, we can just list the variable names,
    and the field name will automatically match the variable name.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we''ve purposely chosen variable names for the parameters to
    match field names of the object with parameter names used by the server. By doing
    so, we can use this shortened notation for anonymous objects, and our code is
    a little cleaner by using consistent variable names from beginning to end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `find` operation lets us look up user information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We're sending the request to check passwords to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'A point about this method is useful to note. It could have taken the parameters
    in the URL, instead of the request body as is done here. But since request URL
    are routinely logged to files, putting the username and password parameters in
    the URL means user identity information would be logged to files and part of activity
    reports. That would obviously be a very bad choice. Putting those parameters in
    the request body not only avoids that bad result, but if an HTTPS connection to
    the service were used, the transaction would be encrypted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `findOrCreate` function either discovers the user in the database, or creates
    a new user. The `profile` object will come from Passport, but take careful note
    of what we do with `profile.id`. The Passport documentation says it will provide
    the username in the `profile.id` field. But we want to store it as `username`,
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can retrieve a list of users.
  prefs: []
  type: TYPE_NORMAL
- en: Login and logout routing functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we've built so far is a user data model, with a REST API wrapping that
    model to create our authentication information service. Then, within the Notes
    application, we have a module that requests user data from this server. As of
    yet, nothing in the Notes application knows that this user model exists. The next
    step is to create a routing module for login/logout URLs and to change the rest
    of Notes to use user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The routing module is where we use `passport` to handle user authentication.
    The first task is to install the required modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `passport` module gives us the authentication algorithms. To support different
    authentication mechanisms, the passport authors have developed several strategy
    implementations. The authentication mechanisms, or strategies, correspond to the
    various third-party services that support authentication, such as using OAuth2
    to authenticate against services such as Facebook, Twitter, or GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The `LocalStrategy` authenticates solely using data stored local to the application,
    for example, our user authentication information service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the routing module, `routes/users.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This brings in the modules we need for the `/users` router. This includes the
    two `passport` modules and the REST-based user authentication model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `app.mjs`, we will be adding *session* support so our users can log in and
    log out. That relies on storing a cookie in the browser, and the cookie name is
    found in this variable exported from `app.mjs`. We''ll be using that cookie in
    a moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `initPassport` function will be called from `app.mjs`, and it installs the
    `Passport` middleware into the Express configuration. We'll discuss the implications
    of this later when we get to `app.mjs` changes, but `Passport` uses sessions to
    detect whether this HTTP request is authenticated or not. It looks at every request
    coming into the application, looks for clues about whether this browser is logged
    in or not, and attaches data to the request object as `req.user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ensureAuthenticated` function will be used by other routing modules and
    is to be inserted into any route definition that requires an authenticated logged-in
    user. For example, editing or deleting a note requires the user to be logged in,
    and therefore the corresponding routes in `routes/notes.mjs` must use `ensureAuthenticated`.
    If the user is not logged in, this function redirects them to `/users/login` so
    that they can do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Because this router is mounted on `/users`, all these routes will have `/user`
    prepended. The `/users/login` route simply shows a form requesting a username
    and password. When this form is submitted, we land in the second route declaration,
    with a `POST` on `/users/login`. If `passport` deems this a successful login attempt
    using `LocalStrategy`, then the browser is redirected to the home page. Otherwise,
    it is redirected to the `/users/login` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When the user requests to log out of Notes, they are to be sent to `/users/logout`.
    We'll be adding a button to the header template for this purpose. The `req.logout`
    function instructs Passport to erase their login credentials, and they are then
    redirected to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function deviates from what''s in the Passport documentation. There, we
    are told to simply call `req.logout`. But calling only that function sometimes
    results in the user not being logged out. It''s necessary to destroy the session
    object, and to clear the cookie, in order to ensure that the user is logged out.
    The cookie name is defined in `app.mjs`, and we imported `sessionCookieName` for
    this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Here is where we define our implementation of `LocalStrategy`. In the callback
    function, we call `usersModel.userPasswordCheck`, which makes a REST call to the
    user authentication service. Remember that this performs the password check and
    then returns an object indicating whether they're logged in or not.
  prefs: []
  type: TYPE_NORMAL
- en: A successful login is indicated when `check.check` is `true`. For this case,
    we tell Passport to use an object containing the `username` in the session object.
    Otherwise, we have two ways to tell Passport that the login attempt was unsuccessful.
    In one case, we use `done(null, false)` to indicate an error logging in, and pass
    along the error message we were given. In the other case, we'll have captured
    an exception, and pass along that exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll notice that Passport uses a callback-style API. Passport provides a
    `done` function, and we are to call that function when we know what''s what. While
    we use an `async` function to make a clean asynchronous call to the backend service,
    Passport doesn''t know how to grok the Promise that would be returned. Therefore,
    we have to throw a `try/catch` around the function body to catch any thrown exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The preceding functions take care of encoding and decoding authentication data
    for the session. All we need to attach to the session is the `username`, as we
    did in `serializeUser`. The `deserializeUser` object is called while processing
    an incoming HTTP request and is where we look up the user profile data. Passport will
    attach this to the request object.
  prefs: []
  type: TYPE_NORMAL
- en: Login/logout changes to app.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a few changes required in `app.mjs`, some of which we've already touched
    on. We did carefully isolate the Passport module dependencies to `routes/users.mjs`.
    The changes required in `app.mjs` support the code in `routes/users.mjs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s now time to uncomment a line we told you to comment out way back in [Chapter
    5](e4322e55-673b-45c5-b64e-fc107d57ef03.xhtml), *Your First Express Application. *The
    imports for the routing modules will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The User router supports the `/login` and `/logout` URL''s as well as using
    `Passport` for authentication. We need to call `initPassport` for a little bit
    of initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Because `Passport` uses sessions, we need to enable session support in Express,
    and these modules do so. The `session-file-store` module saves our session data
    to disk so that we can kill and restart the application without losing sessions.
    It's also possible to save sessions to databases with appropriate modules. A filesystem
    session store is suitable only when all Notes instances are running on the same
    server computer. For a distributed deployment situation, you'll need to use a
    session store that runs on a network-wide service, such as a database.
  prefs: []
  type: TYPE_NORMAL
- en: We're defining `sessionCookieName` here so it can be used in multiple places.
    By default, `express-session` uses a cookie named `connect.sid` to store the session
    data. As a small measure of security, it's useful when there's a published default
    to use a different non-default value. Any time we use the default value, it's
    possible that an attacker might know a security flaw depending on that default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following command to install the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Express Session support, including all the various Session Store implementations,
    is documented on its GitHub project page at [https://github.com/expressjs/session](https://github.com/expressjs/session).
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this in `app.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here we initialize the session support. The field named `secret` is used to
    sign the session ID cookie. The session cookie is an encoded string that is encrypted
    in part using this secret. In the Express Session documentation, they suggest
    the string `keyboard cat` for the secret. But, in theory, what if Express has
    a vulnerability, such that knowing this secret can make it easier to break the
    session logic on your site? Hence, we chose a different string for the secret
    just to be a little different and perhaps a little more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the default cookie name used by `express-session` is `connect.sid`.
    Here's where we change the cookie name to a non-default name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FileStore` will store its session data records in a directory named `sessions`.
    This directory will be auto-created as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The preceding are the three routers used in the Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: Login/logout changes in routes/index.mjs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This router module handles the home page. It does not require the user to be
    logged in, but we want to change the display a little if they are logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we ensured that `req.user` has the user profile data, which we
    did in `deserializeUser`. We simply check for this and make sure to add that data
    when rendering the views template.
  prefs: []
  type: TYPE_NORMAL
- en: We'll be making similar changes to most of the other route definitions. After
    that, we'll go over the changes to the view templates in which we use `req.user`
    to show the correct buttons on each page.
  prefs: []
  type: TYPE_NORMAL
- en: Login/logout changes required in routes/notes.mjs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The changes required here are more significant, but still straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the `ensureAuthenticated` function to protect certain routes
    from being used by users who are not logged in. Notice how ES6 modules let us
    import just the function(s) we require. Since that function is in the user router
    module, we need to import it from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we added is to call `usersRouter.ensureAuthenticated` in the
    route definition. If the user is not logged in, they'll redirect to `/users/login`,
    thanks to that function.
  prefs: []
  type: TYPE_NORMAL
- en: Because we've ensured that the user is authenticated, we know that `req.user`
    will already have their profile information. We can then simply pass it to the
    view template.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the other routes, we need to make similar changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The `/save` route requires only this change to call `ensureAuthenticated` to
    make sure that the user is logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'For this route, we don''t require the user to be logged in. We do need the
    user''s profile information, if any, sent to the view template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: For these routes, we require the user to be logged in. In most cases, we need
    to send the `req.user` value to the view template.
  prefs: []
  type: TYPE_NORMAL
- en: View template changes supporting login/logout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've created a backend user authentication service, a REST module,
    to access that service, a router module to handle routes related to logging in
    and out of the website, and changes in `app.mjs` to use those modules. We're almost
    ready, but we've got a number of outstanding changes to make in the templates.
    We're passing the `req.user` object to every template because each one must be
    changed to accommodate whether the user is logged in or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `partials/header.hbs`, make the following additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: What we're doing here is controlling which buttons to display at the top of
    the screen depending on whether the user is logged in or not. The earlier changes
    ensure that the `user` variable will be `undefined` if the user is logged out,
    otherwise it will have the user profile object. Therefore, it's sufficient to
    check the `user` variable as shown here to render different user interface elements.
  prefs: []
  type: TYPE_NORMAL
- en: A logged-out user doesn't get the ADD Note button, and gets a Log in button.
    Otherwise, the user gets an ADD Note button and a Log Out button. The Log in button
    takes the user to `/users/login`, while the Log Out button takes them to `/users/logout`.
    Both of those are handled in `routes/users.js`, and perform the expected function.
  prefs: []
  type: TYPE_NORMAL
- en: The Log Out button has a Bootstrap badge component displaying the username. This
    adds a little visual splotch, in which we'll put the username that's logged in. As
    we'll see later, it will serve as a visual cue to the user as to their identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create `views/login.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple form decorated with Bootstrap goodness to ask for the username
    and password. When submitted, it creates a `POST` request to `/users/login`, which
    invokes the desired handler to verify the login request. The handler for that
    URL will start the Passport's process to decide whether the user is authenticated
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `views/notedestroy.hbs`, we want to display a message if the user is not
    logged in. Normally, the form to cause the note to be deleted is displayed, but
    if the user is not logged in, we want to explain the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: That's straightforward; if the user is logged in, display the form, otherwise
    display the message in `partials/not-logged-in.hbs`. We determine our approach
    based on the `user` variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could put something like this in `partials/not-logged-in.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In `views/noteedit.hbs`, we need a similar change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: That is, at the bottom we add a segment that, for non-logged-in users, pulls
    in the `not-logged-in` partial.
  prefs: []
  type: TYPE_NORMAL
- en: The **Bootstrap jumbotron** component makes a nice and large text display that
    stands out nicely, and will catch the viewer's attention. However, the user should
    never see this because each of those templates is used only when we've preverified
    that the user is logged in.
  prefs: []
  type: TYPE_NORMAL
- en: A message such as this is useful as a check against bugs in your code. Suppose
    that we slipped up and failed to properly ensure that these forms were displayed
    only to logged-in users. Suppose that we had other bugs that didn't check the
    form submission to ensure it's requested only by a logged-in user. Fixing the
    template in this way is another layer of prevention against displaying forms to
    users who are not allowed to use that functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Running the Notes application with user authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we're ready to run the Notes application and try our hand at logging in and
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to change the scripts section of `package.json` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the previous chapters, we built up quite a few combinations of models and
    databases for running the Notes application. This leaves us with one, configured
    to use the Sequelize model for Notes, using the SQLite3 database, and to use the
    new user authentication service that we wrote earlier. We can simplify the `scripts`
    section by deleting those other configurations. All the other Notes data models
    are still available just by setting the environment variables appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: The `USER_SERVICE_URL` needs to match the port number that we designated for
    that service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In one window, start the user authentication service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in another window, start the Notes application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll be greeted with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e80c39ba-4a49-467f-a29b-2c538f7b7225.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the new button, Log in, and the lack of an ADD Note button. We're not
    logged in, and therefore `partials/header.hbs` is rigged to show only the Log
    in button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the Log in button, and you will see the login screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0713ca75-9e6f-4d2c-9b5d-3ca5e5178d45.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is our login form from `views/login.hbs`. You can now log in, create a
    note or three, and you might end up with the following on the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a54e0a3-df46-44ba-ab10-925f5be169fd.png)'
  prefs: []
  type: TYPE_IMG
- en: You now have both Log Out and ADD Note buttons.
  prefs: []
  type: TYPE_NORMAL
- en: You'll notice that the Log Out button has the username (me) shown. After some
    thought and consideration, this seemed the most compact way to show whether the
    user is logged in or not, and which user is logged in. This might drive the user
    experience team nuts, and you won't know whether this user interfaces design works
    until it's tested with users, but it's good enough for our purpose at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Twitter login support for the Notes application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want your application to hit the big time, it's a great idea to allow
    users to register using third-party credentials. Websites all over the internet
    allow you to log in using Facebook, Twitter, or accounts from other services.
    Doing so removes hurdles to prospective users signing up for your service. Passport
    makes it extremely easy to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Twitter requires installing **TwitterStrategy**, registering a new
    application with Twitter, and adding a couple of routes into `routes/user.mjs`
    and a small change in `partials/header.hbs`. Integrating other third-party services
    requires similar steps.
  prefs: []
  type: TYPE_NORMAL
- en: Registering an application with Twitter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Twitter, as with every other third-party service, uses OAuth to handle authentication
    and requires an authentication key to write software using their API. It's their
    service, so you have to play by their rules, of course.
  prefs: []
  type: TYPE_NORMAL
- en: To register a new application with Twitter, go to [https://apps.twitter.com/](https://apps.twitter.com/). Then
    you click on the *Create New App* button. Since we haven't deployed the Notes
    application to a regular server and, more importantly, there isn't a valid domain
    name for the application, we have to give Twitter the configuration required for
    testing on our local laptop.
  prefs: []
  type: TYPE_NORMAL
- en: Every service offering OAuth2 authentication has an administrative backend for
    registering new applications. The common purpose is to describe the application
    to the service so that the service can correctly recognize the application when
    requests are made using the authentication tokens. The normal situation is that
    the application is deployed to a regular server, and is accessed through a domain
    name such as `MyNotes.info`.  We've done neither as of this moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, there are four pieces of information requested by the
    Twitter sign-up process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: This is the application name, and it can be anything you like. It
    would be good form to use test in the name in case Twitter''s staff decide to
    do some validation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: Descriptive phrase, and again it can be anything you like.
    Again, it would be good form to, at this time, describe it as a test application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Website**: This would be your desired domain name. Here, the help text helpfully
    suggests *If you don''t have a URL yet, just put a placeholder here but remember
    to change it later*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Callback URL**: This is the URL to return to after successful authentication.
    Since we don''t have a public URL to supply, this is where we specify a value
    referring to your laptop. It''s been found that `http://localhost:3000` works
    just fine. macOS users have another option because of the `.local` domain name,
    which is automatically assigned to their laptop. All along, we could have used
    a URL similar to this to access the Notes application at `http://MacBook-Pro-2.local:3000/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It was found by attempting this procedure with different services that Facebook
    (and other) services are not lenient about test applications hosted on laptops.
    At least Twitter is keen for developers to configure a test application on their
    laptop. Passport's other OAuth-based strategies will work similarly enough to
    Twitter, so the knowledge we're gaining will transfer to those other authentication
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing to notice is the extremely sensitive nature of the authentication
    keys. It's bad form to check these into a source code repository or otherwise
    put them in a place where anybody can access the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Twitter does change the signup page from time to time, but it should look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f7bd3f21-c2c0-470f-b5df-27ac96f8ae4f.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing TwitterStrategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with many web applications, we have decided to allow our users to log in using
    Twitter credentials. The OAuth2 protocol is widely used for this purpose and is
    the basis for authenticating on one website using credentials maintained by another
    website.
  prefs: []
  type: TYPE_NORMAL
- en: The application registration process you just followed at `apps.twitter.com`
    generated for you a pair of API keys, a consumer key, and, consumer secret. These
    keys are part of the OAuth protocol, and will be supplied by any OAuth service
    you register with, and the keys should be treated with the utmost care. Think
    of them as the username and password your service uses to access the OAuth-based
    service (Twitter et al). The more people who can see these keys, the more likely
    a miscreant can see them and then cause trouble. Anybody with those secrets can
    write access the service API as if they are you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dozens of Strategy packages for various third-party services are available
    within the Passport ecosystem. Let''s install the package required to use `TwitterStrategy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'In `routes/users.mjs`, let''s start making some changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'To bring in the package we just installed, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This registers `TwitterStrategy` with `passport`, arranging to call the user
    authentication service as users register with the Notes application. This `callback`
    function is called when users successfully authenticate using Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: We defined the `usersModel.findOrCreate` function specifically to handle user
    registration from third-party services such as Twitter. Its task is to look for
    the user described in the profile object and, if that user does not exist, to
    autocreate that user account in Notes.
  prefs: []
  type: TYPE_NORMAL
- en: The `consumerKey` and `consumerSecret` values are supplied by Twitter, after
    you've registered your application. These secrets are used in the OAuth protocol
    as proof of identity to Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: The `callbackURL` setting in the `TwitterStrategy` configuration is a holdover
    from Twitter's OAuth1-based API implementation. In OAuth1, the callback URL was
    passed as part of the OAuth request. Since `TwitterStrategy` uses Twitter's OAuth1
    service, we have to supply the URL here. We'll see in a moment where that URL
    is implemented in Notes.
  prefs: []
  type: TYPE_NORMAL
- en: The `callbackURL`, `consumerKey`, and `consumerSecret` are all injected using
    environment variables. It is tempting, because of the convenience, to just put
    those keys in the source code. But, how widely distributed is your source code? 
    In the Slack API documentation ([https://api.slack.com/docs/oauth-safety](https://api.slack.com/docs/oauth-safety)),
    we're warned *Do not distribute client secrets in email, distributed native applications,
    client-side JavaScript, or public code repositories*.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml),* Deploying Node.js
    Applications*, we'll put these keys into a Dockerfile. That's not entirely secure
    because the Dockerfile will also be committed to a source repository somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'It was found while debugging that the profile object supplied by the `TwitterStrategy`
    did not match the documentation on the `passport` website. Therefore, we have
    mapped the object actually supplied by `passport` into something that Notes can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: To start the user logging in with Twitter, we'll send them to this URL. Remember
    that this URL is really `/users/auth/twitter`, and, in the templates, we'll have
    to use that URL. When this is called, the passport middleware starts the user
    authentication and registration process using `TwitterStrategy`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the user's browser visits this URL, the OAuth dance begins. It's called
    a dance because the OAuth protocol involves carefully designed redirects between
    several websites. Passport sends the browser over to the correct URL at Twitter,
    where Twitter asks the user whether they agree to authenticate using Twitter,
    and then Twitter redirects the user back to your callback URL. Along the way,
    specific tokens are passed back and forth in a very carefully designed dance between
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the OAuth dance concludes, the browser lands here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This route handles the callback URL, and it corresponds to the `callbackURL`
    setting configured earlier. Depending on whether it indicates a successful registration
    or not, passport will redirect the browser to either the home page or back to
    the `/users/login` page.
  prefs: []
  type: TYPE_NORMAL
- en: Because `router` is mounted on `/user`, this URL is actually `/user/auth/twitter/callback`.
    Therefore, the full URL to use in configuring the `TwitterStrategy`, and to supply
    to Twitter, is `http://localhost:3000/user/auth/twitter/callback`
  prefs: []
  type: TYPE_NORMAL
- en: In the process of handling the callback URL, Passport will invoke the callback
    function shown earlier. Because our callback uses the `usersModel.findOrCreate`
    function, the user will be automatically registered if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: We're almost ready, but we need to make a couple of small changes elsewhere in
    Notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `partials/header.hbs`, make the following changes to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This adds a new button that, when clicked, takes the user to `/users/auth/twitter`,
    which, of course, kicks off the Twitter authentication process.
  prefs: []
  type: TYPE_NORMAL
- en: The image being used is from the official Twitter brand assets page at [https://about.twitter.com/company/brand-assets](https://about.twitter.com/company/brand-assets).
    Twitter recommends using these branding assets for a consistent look across all
    services using Twitter. Download the whole set and then pick one you like. For
    the URL shown here, place the chosen image in a directory named `public/assets/vendor/twitter`.
    Notice that we force the size to be small enough for the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: With these changes, we're ready to try logging in with Twitter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the Notes application server as done previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use a browser to visit `http://localhost:3000`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7c4b072f-7f67-4306-91be-d8b3940a897c.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the new button. It looks about right, thanks to having used the official
    Twitter branding image. The button is a little large, so maybe you want to consult
    a designer. Obviously, a different design is required if you're going to support
    dozens of authentication services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on this button takes the browser to `/users/auth/twitter`, which starts
    Passport running the OAuth2 protocol transactions necessary to authenticate. And
    then, once you''re logged in with Twitter, you''ll see something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a13f58f3-02dd-4107-b131-241723950d75.png)'
  prefs: []
  type: TYPE_IMG
- en: We're now logged in, and notice that our Notes username is the same as our Twitter
    username. You can browse around the application and create, edit, or delete notes.
    In fact, you can do this to any note you like, even ones created by others. That's
    because we did not create any sort of access control or permissions system, and
    therefore every user has complete access to every note. That's a feature to put
    on the backlog.
  prefs: []
  type: TYPE_NORMAL
- en: By using multiple browsers or computers, you can simultaneously log in as different
    users, one user per browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run multiple instances of the Notes application by doing what we did
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in one command window, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'In another command window, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: As previously, this starts two instances of the Notes server, each with a different
    value in the `PORT` environment variable. In this case, each instance will use
    the same user authentication service. As shown here, you'll be able to visit the
    two instances at `http://localhost:3000` and `http://localhost:3002`. And, as
    previously, you'll be able to start and stop the servers as you wish, see the
    same notes in each, and see that the notes are retained after restarting the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another thing to try is to fiddle with the **session store**. Our session data
    is being stored in the `sessions` directory. These are just files in the filesystem,
    and we can take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This is after logging in using a Twitter account; you can see that the Twitter
    account name is stored here in the session data.
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to clear a session? It's just a file in the filesystem. Deleting
    the session file erases the session, and the user's browser will be forcefully
    logged out.
  prefs: []
  type: TYPE_NORMAL
- en: The session will time out if the user leaves their browser idle for long enough.
    One of the `session-file-store` options, `ttl`, controls the timeout period, which
    defaults to 3,600 seconds (an hour). With a timed-out session, the application
    reverts to a logged-out state.
  prefs: []
  type: TYPE_NORMAL
- en: Securely keeping secrets and passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve cautioned several times about the importance of safely handling user
    identification information. The intention to safely handle that data is one thing,
    but it is important to follow through and actually do so. While we''re using a
    few good practices so far, as it stands, the Notes application would not withstand
    any kind of security audit:'
  prefs: []
  type: TYPE_NORMAL
- en: User passwords are kept in clear text in the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authentication tokens for Twitter *et al*, are in the source code in clear
    text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The authentication service API key is not a cryptographically secure anything,
    it's just a cleartext UUID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don't recognize the phrase clear text, it simply means unencrypted. Anyone
    could read the text of user passwords or the authentication tokens. It's best
    to keep both encrypted to avoid information leakage.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes application stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you notice earlier when we said run the Notes application stack? It's time
    to explain to the marketing team what's meant by that phrase. They'll perhaps
    need to put an architecture diagram on marketing brochures and the like. It's
    also useful for developers like us to take a step back and draw a picture of what
    we've created, or are planning to create.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the sort of diagram that an engineer might draw to show the marketing
    team the system design. The marketing team will, of course, hire a graphics artist
    to clean it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/10d38f27-e686-4a9b-a61e-2039a23497d8.png)'
  prefs: []
  type: TYPE_IMG
- en: The box labeled Notes Application is the public-facing code implemented by the
    templates and the router modules. As currently configured, it's visible from our
    laptop on port 3000\. It can use one of several data storage services. It communicates
    with the backend **User Authentication Service** over port 3333 (as currently
    configured).
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](7542f45a-6bd9-432e-875a-c110c0d84c61.xhtml),* Deploying Node.js
    Applications,* we'll be expanding this picture a bit as we learn how to deploy
    on a real server.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've covered a lot of ground in this chapter, looking at not only user authentication
    in Express applications, but also microservice development.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, you covered session management in Express, using Passport for
    user authentication, including Twitter/OAuth, using router middleware to limit
    access, creating a REST service with Restify, and when to create a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take the *Notes* application to a new level-semi-real-time
    communication between application users. To do this, we'll write some browser-side
    JavaScript and explore how the `Socket.io` package can let us send messages between
    users.
  prefs: []
  type: TYPE_NORMAL
