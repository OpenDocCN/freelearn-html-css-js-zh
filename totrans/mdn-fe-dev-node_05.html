<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-50" lang="en-GB"><a id="_idTextAnchor049"/>5</h1>
<h1 id="_idParaDest-51" lang="en-GB"><a id="_idTextAnchor050"/>Enhancing Code Quality with Linters and Formatters</h1>
<p lang="en-GB">Up to this chapter, we’ve dealt mostly with constructs and code that has been in the hot path – that is, directly necessary to actually do something. However, in most projects, there are many parts that are not directly useful or visible. Quite often, these parts play a crucial role in keeping projects at a certain quality.</p>
<p lang="en-GB">One example in the field of software project quality enhancers is the tooling that is used to ensure certain coding standards are being followed. Those tools can appear in many categories – the most prominent categories <a id="_idIndexMarker146"/>being <strong class="bold" lang="">linters</strong> and <strong class="bold" lang="">formatters</strong>. In <a id="_idIndexMarker147"/>general, these tools can be categorized as auxiliary tooling.</p>
<p lang="en-GB">In this chapter, we’ll learn what types of auxiliary tooling exist and why we’d potentially want to use some extra tooling to enhance our project’s code quality. We’ll introduce the most important <a id="_idIndexMarker148"/>auxiliary tools<a id="_idIndexMarker149"/> such as <strong class="bold" lang="">ESLint</strong>, <strong class="bold" lang="">Stylelint</strong>, and <strong class="bold" lang="">Prettier</strong>. We<a id="_idIndexMarker150"/> will also have a look at how these tools are integrated or used with standard text editors such as VS Code.</p>
<p lang="en-GB">With the auxiliary tools presented in this chapter, you’ll be able to have an outstanding positive impact on any Node.js-based frontend project that you’ll contribute to.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Understanding auxiliary tooling</li>
<li lang="en-GB">Using ESLint and alternatives</li>
<li lang="en-GB">Introducing Stylelint</li>
<li lang="en-GB">Setting up Prettier and EditorConfig</li>
</ul>
<h1 id="_idParaDest-52" lang="en-GB"><a id="_idTextAnchor051"/>Technical requirements</h1>
<p lang="en-GB">The complete source code for this chapter can be found at <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter05">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter05</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="https://bit.ly/3fLWnyP">https://bit.ly/3fLWnyP</a>.</p>
<h1 id="_idParaDest-53" lang="en-GB"><a id="_idTextAnchor052"/>Understanding auxiliary tooling</h1>
<p lang="en-GB">When<a id="_idIndexMarker151"/> most people think about software, they’ll have applications such as Microsoft Word, games such as Minecraft, or web applications such as Facebook in mind. Thanks to popular media, the widespread opinion is that these applications are written by individual geniuses that hack some ones and zeroes into an obscure interface. The reality could not be more far off.</p>
<p lang="en-GB">As you know, to create any kind of software, lots of libraries, tooling, and – in many cases – large teams are necessary. However, what most people underestimate is the effort to just keep the ball rolling – that is, to still be able to add new features to the existing software. There are several issues that contribute to this feature slowdown.</p>
<p lang="en-GB">On the one hand, the complexity within software always rises. This is whether we want it or not – with every new feature, a project becomes more challenging. In addition, larger software tends to be written by more developers – and every developer has a slightly different preference and style. This quickly becomes a mess for new developers or even those with experience in the project but who are working in areas that they did not touch beforehand.</p>
<p lang="en-GB">One way to tame the rise of complexity is the introduction of processes. For instance, the process of conducting pull requests with reviews is already presented to spread knowledge about new features, detect issues, and discuss findings. At the end of a good pull request review, the code should be in a state where the new additions fit well into the whole project, both functionally and technically.</p>
<p lang="en-GB">Today, everything is about automation. Therefore, while having manual processes such as a code review might be good and necessary, we usually prefer automated processes. This is exactly where all the auxiliary tooling comes in. Take, for instance, a potential discussion about code formatting within a code review. Let’s say a part of the code looks as follows:</p>
<pre class="source-code" lang="en-GB">export function div(a,b){ return (
 a/ b)
}</pre>
<p lang="en-GB">The code itself is fine – the <code>div</code> function should perform a division, and of course, it does that. Nevertheless, the formatting is way off. A reviewer might complain that the parameters of the function should be properly formatted using a space after a comma. Another<a id="_idIndexMarker152"/> reviewer might not like the return statement, which would break without the use of parenthesis. A third review could remark on the missing optional semicolon and that the indentation is just a single space.</p>
<p lang="en-GB">Now, after everything is set and done, a new version of the code would be pushed:</p>
<pre class="source-code" lang="en-GB">export function div(a, b){
  return a / b;
}</pre>
<p lang="en-GB">Here, the second reviewer might bring up a discussion of why the semicolon was introduced – it is only optional in this case and the code works without it. At this point, a new reviewer joins and questions the introduction of the function at all: “Why is a function for division needed in the first place? There is nothing new or interesting here.”</p>
<p lang="en-GB">Consequently, you’ll see that much time was wasted on all sides. Instead of discussing the business need of the function in the first place, time was – and is still – spent discussing formalities that should be aligned and corrected automatically. This is where linters and formatters come into play. They can take the task of making code beautiful to read by following the standard that was set for a project. Hence, a team would need to agree only once on the tabs versus spaces debate or the use of semicolons. The tooling takes care of actually applying the decision.</p>
<p class="callout-heading" lang="en-GB">Semicolons in JavaScript</p>
<p class="callout" lang="en-GB">JavaScript is<a id="_idIndexMarker153"/> quite loose regarding syntax. While other languages have rules and constructs that always need to be followed, JavaScript has many optional constructs in its specification. For instance, semicolons are – up to some degree – optional. There are a few cases where you’d need a semicolon to avoid nasty surprises such as in the head of <code>for</code>-loops, but for the most part, you could just drop them and your code would still work.</p>
<p lang="en-GB">There are many areas in which auxiliary tooling makes sense. Sure, the alignment of code itself is nice, but even things such as commit messages when working with a project’s version <a id="_idIndexMarker154"/>control system or checking whether documentation was supplied can be useful.</p>
<p lang="en-GB">While checking the actual syntax – for example, the use of whitespace and newlines, is a common use case – an even more important one is to check the actual code constructs for some patterns. The validation of the used patterns is often referred <a id="_idIndexMarker155"/>to as <strong class="bold" lang="">linting</strong> – with a category of tools known<a id="_idIndexMarker156"/> as <strong class="bold" lang="">linters</strong>. A tool that excels in that space is <strong class="bold" lang="">ESLint</strong>.</p>
<h1 id="_idParaDest-54" lang="en-GB"><a id="_idTextAnchor053"/>Using ESLint and alternatives</h1>
<p lang="en-GB">ESLint statically<a id="_idIndexMarker157"/> analyzes code to identify common patterns and find problems. It can be used as a library from your Node.js applications, as a tool from your Node.js scripts, in your CI/CD pipelines, or implicitly within your code editor.</p>
<p lang="en-GB">The general recommendation is to install ESLint locally in your Node.js project. A local installation can be done with your favorite package manager, such as npm:</p>
<pre class="console" lang="en-GB">
$ npm install eslint --save-dev</pre>
<p lang="en-GB">In most cases, you’ll want to specify the <code>--save-dev</code> flag. This will add a dependency to the development dependencies, which are not installed in consuming applications and will be skipped for production installations. Indeed, development dependencies are only interesting during the project’s actual development.</p>
<p lang="en-GB">Alternatively, you can also make ESLint a global tool. This way, you can run ESLint even in projects and code files that do not already include it. To install ESLint globally, you need to run the following:</p>
<pre class="console" lang="en-GB">
$ npm install eslint --global</pre>
<p lang="en-GB">Potentially, you’ll need elevated shell access (e.g., using <code>sudo</code>) to install ESLint globally. The general recommendation is to avoid using elevated shell access, which implies avoiding global installations.</p>
<p class="callout-heading" lang="en-GB">Global versus local installations</p>
<p class="callout" lang="en-GB">npm is not only <a id="_idIndexMarker158"/>a great way to distribute packages but also to distribute tools. The standard installation of npm creates a special directory for such tools. This dedicated directory is added to your system’s <code>PATH</code> variable, allowing direct execution of anything that is inside the directory. By using a global installation, a tool such as ESLint is added to the dedicated directory, giving us the option of running it just by typing <code>eslint</code> in the command line.</p>
<p class="callout" lang="en-GB">On the other hand, tools in a local installation are not placed in the dedicated directory. Instead, they are available in the <code>node_modules/.bin</code> folder. To avoid running lengthy commands such as <code>./node_modules/.bin/eslint</code>, we can use the <code>npx</code> utility.</p>
<p class="callout" lang="en-GB"><code>npx</code> is a task <a id="_idIndexMarker159"/>runner installed together with Node.js and npm. It intelligently checks whether the provided script is installed locally or globally. If nothing is found, then a package is temporarily downloaded from the npm registry, executing the script from the temporary installation. Consequently, running <code>npx eslint</code> in a project where ESLint is installed will start the linting.</p>
<p lang="en-GB">Let’s initialize<a id="_idIndexMarker160"/> a new project (<code>npm init -y</code>) and install <code>eslint</code> as a development dependency. Now that you’ve installed ESLint, you can actually use it on some sample code:</p>
<ol>
<li lang="en-GB">For this, we can leverage the sample from the previous section:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          index.js</p>
<pre class="console" lang="en-GB">
export function div(a,b){ return (

 a/ b)

}</pre>
<ol>
<li lang="en-GB" value="2">Before we can run <code>eslint</code>, we also need to create a configuration. Having a configuration file is something that almost all utilities for frontend development will require. In the case of ESLint, the configuration file should be named <code>.eslintrc</code>.</li>
</ol>
<p lang="en-GB">Place the following <code>.eslintrc</code> file in the same directory as <code>package.json</code>:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          .eslintrc</p>
<pre class="console" lang="en-GB">
{

    "root": true,

    "parserOptions": {

        "sourceType": "module",

        "ecmaVersion": 2020

    },

    "rules": {

        "semi": ["error", "always"]

    }

}</pre>
<p lang="en-GB">There are different ways to write a configuration way for ESLint. In the preceding snippet, we used the JSON format, which should feel quite familiar for anyone with a JavaScript or web development background. Another common approach is to use the YAML format.</p>
<ol>
<li lang="en-GB" value="3">In the<a id="_idIndexMarker161"/> preceding configuration, we instruct ESLint to stop looking for parent configurations. As this is indeed the configuration for our project, we can stop at this level. Additionally, we configure ESLint’s parser to actually parse ESM following a very recent specification. Finally, we configure the rule for semicolons to throw an error if semicolons are missing.</li>
</ol>
<p lang="en-GB">The result of applying this ruleset can be seen in the following code snippet. Running <code>npx eslint</code> starting on all JavaScript files from the current directory (<code>.</code>) looks like this:</p>
<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx eslint .</strong>
<strong class="bold" lang="">/home/node/Chapter05/example01/index.js</strong>
<strong class="bold" lang="">  2:7  error  Missing semicolon  semi</strong>
<strong class="bold" lang=""><img alt="" src="img/012.png"/> 1 problem (1 error, 0 warnings)</strong>
<strong class="bold" lang="">  1 error and 0 warnings potentially fixable with the</strong>
<strong class="bold" lang="">  `--fix` option.</strong></pre>
<p lang="en-GB">As expected, the linter complains. However, this kind of complaint is certainly in the positive region. Rather constructively, ESLint also tells us about the option to automatically fix the issue.</p>
<ol>
<li lang="en-GB" value="4">Let’s run<a id="_idIndexMarker162"/> the same command with the suggested <code>--</code><code>fix</code> option:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx eslint . --fix</strong></pre></li>
</ol>
<p lang="en-GB">No output here. Indeed, this is a good thing. The missing semicolon has been inserted:</p>
<pre class="console" lang="en-GB">
export function div(a,b){ return (

 a/ b);

}</pre>
<ol>
<li lang="en-GB" value="5">How about other rules? What if we want to force code to use anonymous arrow functions instead of the named functions? While many things can be covered by the rules coming directly with ESLint, the system can be extended with rules from third-party packages. Third-party packages that bring in additional functionality for ESLint are called ESLint plugins.</li>
</ol>
<p lang="en-GB">To bring in a rule to enforce the usage of anonymous arrow functions, we can use an ESLint plugin. The package for this is called <code>eslint-plugin-prefer-arrow</code>. Let’s install it first:</p>
<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm install eslint-plugin-prefer-arrow --save-dev</strong></pre>
<ol>
<li lang="en-GB" value="6">Now, we can change the configuration. We need to include a reference to the plugin and also specify the rule:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          .eslintrc</p>
<pre class="console" lang="en-GB">
{

    "root": true,

    "parserOptions": {

        "sourceType": "module",

        "ecmaVersion": 2020

    },

    "plugins": [

      "prefer-arrow"

    ],

    "rules": {

        "semi": ["error", "always"],

        "prefer-arrow/prefer-arrow-functions": ["error", {}]

    }

}</pre>
<ol>
<li lang="en-GB" value="7">With this<a id="_idIndexMarker163"/> configuration, we can now test whether the function declaration is indeed qualified as an error:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx eslint .</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">/home/node/Chapter05/example01/index.js</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  1:8  error  Use const or class constructors instead</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  of named functions  prefer-arrow/prefer-arrow-</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  functions</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""><img alt="" src="img/012.png"/> 1 problem (1 error,</strong> 0 warnings)</pre></li>
</ol>
<p lang="en-GB">In contrast to the previous error, we are not seeing any hint of an automatic fix here. In such cases, the author of the code has to do all the changes to please the linter manually.</p>
<p lang="en-GB">There are<a id="_idIndexMarker164"/> plenty of alternatives to ESLint. In the past, the TypeScript-specific variant TSLint was quite popular. However, a couple of years ago, the team behind TSLint decided to actually merge their rules into ESLint – also making ESLint the de facto standard for linting TypeScript files. Today, the most popular<a id="_idIndexMarker165"/> alternatives are <strong class="bold" lang="">Rome</strong>, <strong class="bold" lang="">quick-lint-js</strong>, and <strong class="bold" lang="">JSHint</strong>.</p>
<p lang="en-GB">Rome is an <a id="_idIndexMarker166"/>all-in-one tooling that combines several utilities into one cohesive application. While Rome is not written in JavaScript using Node.js, it still integrates nicely into the standard frontend tooling. One of the aspects covered in Rome is linting. At the time of writing, Rome is, unfortunately, not yet feature-complete and still in an early alpha version, but its performance and convenience benefits are a clear advantage.</p>
<p lang="en-GB">The <strong class="bold" lang="">quick-lint-js</strong> package<a id="_idIndexMarker167"/> is a small tool that does not require configuration and is tuned to outperform ESLint in execution time. The downside of this is that quick-lint-js has fewer features and is less flexible in its design.</p>
<p lang="en-GB">Lastly, one of the golden classics in <a id="_idIndexMarker168"/>the linting field is <strong class="bold" lang="">JSHint</strong>. Originally, it was created as a more configurable version of <strong class="bold" lang="">JSLint</strong>, which can be considered the first popular linter for JavaScript. One of the issues with JSHint is that it does not support the latest and greatest features of <a id="_idIndexMarker169"/>the <strong class="bold" lang="">ECMAScript</strong> standard. If you are looking for ES2020 support, then JSHint can be discarded. Likewise, JSHint is a bit more restrictive on extensibility. In JSHint, you cannot define custom rules. However, if something is missing in JSHint, you’ll not be able to just add it.</p>
<p lang="en-GB">The <a id="_idIndexMarker170"/>biggest advantage of ESLint, however, is that it already has the ecosystem that others are potentially missing. One area where ESLint shines is editor support. <em class="italic" lang="">Figure 5</em><em class="italic" lang="">.1</em> shows the entry of the official ESLint extension on the VS Code Marketplace.</p>
<div><div><img alt="Figure 5.1 – Entry of the official ESLint extension on the VS Code Marketplace " src="img/Figure_5.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Entry of the official ESLint extension on the VS Code Marketplace</p>
<p lang="en-GB">Similar plugins exist for other editors. Some editors such as Brackets even come with an ESLint integration preinstalled.</p>
<p lang="en-GB">The editor integration will indicate <a id="_idIndexMarker171"/>ESLint issues directly in the code. This is really helpful during development. Instead of waiting for code quality inspection results after the code has been written, you can directly see issues when they appear. This way, you’ll be able to fix them immediately, instead of being required to come back to previously closed files later.</p>
<p lang="en-GB">In almost all editor integrations, you’ll not only get some squiggles or similar visual hints when ESLint finds an issue but also the possibility to run a quick fix. Running a quick fix will trigger ESLint’s repair functionality. In the preceding command line usage, we triggered this behavior by using the <code>--</code><code>fix</code> flag.</p>
<p lang="en-GB"><em class="italic" lang="">Figure 5</em><em class="italic" lang="">.2</em> shows how VS Code reports the issues found by ESLint on the given example file, <code>index.js</code>:</p>
<div><div><img alt="Figure 5.2 – ESLint integration reporting issues in VS Code " src="img/Figure_5.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – ESLint integration reporting issues in VS Code</p>
<p lang="en-GB">In general, it <a id="_idIndexMarker172"/>makes sense to define a sound basis for linting rules. The basis, however, should not be too large. Too many rules will ultimately have the opposite effect. Instead of empowering a team by finding a common style and avoiding problematic patterns, the constraints are too heavy – essentially slowing down or even blocking progress on new features. Therefore, the recommendation is to start with a few rules and add new ones when certain code issues come up more often in pull request reviews. This way, the set of linting rules will evolve with the project.</p>
<p lang="en-GB">While linting JavaScript source files is definitely one of the most important tasks, it is by far not the only kind of source file you’ll encounter in modern frontend development. Arguably, the second most important type of files are stylesheets<a id="_idIndexMarker173"/> such as <strong class="bold" lang="">CSS</strong> or <strong class="bold" lang="">SCSS</strong>. For<a id="_idIndexMarker174"/> those, we can rely on another tool for linting called Stylelint.</p>
<h1 id="_idParaDest-55" lang="en-GB"><a id="_idTextAnchor054"/>Introducing Stylelint</h1>
<p lang="en-GB">Stylelint is a<a id="_idIndexMarker175"/> linter for CSS files and can be extended to also understand CSS dialects such <a id="_idIndexMarker176"/>as <a id="_idIndexMarker177"/>SCSS, <strong class="bold" lang="">Sass</strong>, <strong class="bold" lang="">Less</strong>, or <strong class="bold" lang="">SugarCSS</strong>. It has over 170 built-in rules but, much<a id="_idIndexMarker178"/> like ESLint, provides support for custom rules.</p>
<p lang="en-GB">To install <a id="_idIndexMarker179"/>Stylelint, we can follow the same steps as with ESLint:</p>
<ol>
<li lang="en-GB" value="1">Here, it usually makes sense to rely on the standard configuration provided by Stylelint. Unlike ESLint, the standard configuration is released in a separate package and, therefore, needs to be installed as well. The command to install both packages as development dependencies looks like this:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm install stylelint stylelint-config-standard</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  --save-dev</strong></pre></li>
<li lang="en-GB">In any case, we still require a configuration file. For the moment, it is sufficient to just let <code>stylelint</code> know that we want to use the configuration from the <code>stylelint-config-standard</code> package. Here, we can write another configuration file next to the project’s <code>package.json</code>:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          .stylelintrc</p>
<pre class="console" lang="en-GB">
{

  "extends": "stylelint-config-standard"

}</pre>
<ol>
<li lang="en-GB" value="3">Next, let’s introduce some problematic CSS files to try out the <code>stylelint</code> utility:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          style.css</p>
<pre class="console" lang="en-GB">
div {

    padding-left: 20px;

    padding: 10px;

}

p {

    color: #44;

}</pre>
<p lang="en-GB">The preceding snippet has several issues. On one hand, we’ll overwrite the <code>padding-left</code> property by using the <code>padding</code> shorthand afterward. On the other hand, we’ll use an invalid color hex code. Finally, we might want to have a new line between different declaration blocks.</p>
<ol>
<li lang="en-GB" value="4">We<a id="_idIndexMarker180"/> can run the <code>stylelint</code> utility with the <code>npx</code> task runner – just like how we triggered <code>eslint</code>:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx stylelint style.css</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">style.css</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 2:5   <img alt="" src="img/012.png"/>  Expected indentation of 2 spaces</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">   indentation</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 3:5   <img alt="" src="img/012.png"/>  Unexpected shorthand "padding" after</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  "padding-left"  declaration-block-no-shorthand-</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  property-overrides</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 3:5   <img alt="" src="img/012.png"/>  Expected indentation of 2 spaces</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">   indentation</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 5:1   <img alt="" src="img/012.png"/>  Expected empty line before rule</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">   rule-empty-line-before</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 6:5   </strong><strong class="bold" lang=""><img alt="" src="img/012.png"/>  Expected indentation of 2 spaces</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">   indentation</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 6:12  <img alt="" src="img/012.png"/>  Unexpected invalid hex color "#44"</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">   color-no-invalid-hex</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 7:1   <img alt="" src="img/012.png"/>  Unexpected missing end-of-source newline</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">   no-missing-end-of-source-newline</strong></pre></li>
<li lang="en-GB">There<a id="_idIndexMarker181"/> is quite a list of issues coming out! Luckily, just like with <code>eslint</code>, we can use the <code>--fix</code> flag to automatically fix as much as possible:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx stylelint style.css --fix</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">style.css</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 3:5   <img alt="" src="img/012.png"/>  Unexpected shorthand "padding" after</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  "padding-left"  declaration-block-no-shorthand-</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  property-overrides</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang=""> 6:12  <img alt="" src="img/012.png"/>  Unexpected invalid hex color "#44"</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">   color-no-invalid-hex</strong></pre></li>
</ol>
<p lang="en-GB">While the cosmetic issues dealing with spaces and newlines can be tackled automatically by Stylelint, the remaining two issues (<code>3:5</code> and <code>6:12</code>) require a bit more brainpower to be fixed. The first issue requires a decision of whether we want to either remove the <code>padding-left</code> property or move it after the usage of the <code>padding</code> shorthand. The second issue requires us to actually think about a valid color to use. Here, Stylelint cannot possibly know which color we had in mind when writing the code.</p>
<p lang="en-GB">Stylelint is not only very useful but is also quite unique. In the world of CSS linters, there are not many options. Mostly, people tend to rely on their tooling – for example, Sass or Less, to already give them some errors and warnings. Stylelint goes a bit further. In addition to the rich set of in-built rules and its flexibility via plugins, Stylelint also offers a rich ecosystem. As with ESLint, many editors have an integration for Stylelint.</p>
<p lang="en-GB">With all the linting in place, we can now turn to an even softer part of code cosmetics – how code is structured visually. A tool to help us here is <strong class="bold" lang="">Prettier</strong>.</p>
<h1 id="_idParaDest-56" lang="en-GB"><a id="_idTextAnchor055"/>Setting up Prettier and EditorConfig</h1>
<p lang="en-GB">Prettier is a <a id="_idIndexMarker182"/>code formatter that works with a lot of different source files. Among the supported file types, we have plain JavaScript, Flow, TypeScript, HTML, CSS, SASS, Markdown, and many more. Prettier is also integrated into many different editors such as Atom, Emacs, Sublime Text, Vim, Visual Studio, or VS Code.</p>
<p lang="en-GB">Let’s dig into<a id="_idIndexMarker183"/> installing and configuring the Prettier formatter:</p>
<ol>
<li lang="en-GB" value="1">Such as the previous tools, Prettier can be installed locally or globally. Adding Prettier to an existing project can be done by installing the <code>prettier</code> package from the npm registry:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npm install prettier --save-dev</strong></pre></li>
<li lang="en-GB">Prettier can format JavaScript code even without any configuration. To run Prettier on an existing code file, you can use the <code>prettier</code> utility with <code>npx</code>. For instance, to apply formatting to your previous code file, you can run:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx prettier index.js</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">export function div(a, b) {</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">  return a / b;</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">}</strong></pre></li>
</ol>
<p lang="en-GB">In this case, Prettier just printed the result of the formatting in the command line. It also added a semicolon to the end of the statement. Let’s configure Prettier to <em class="italic" lang="">not</em> add semicolons at the end of statements.</p>
<ol>
<li lang="en-GB" value="3">To configure Prettier, a <code>.prettierrc</code> file should be added to the root of the project – right next to <code>package.json</code>. The file can be written with JSON. An example is shown here:</li>
</ol>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">          .prettierrc</p>
<pre class="console" lang="en-GB">
<strong class="bold" lang="">{</strong>
<strong class="bold" lang="">  "tabWidth": 4,</strong>
<strong class="bold" lang="">  "semi": false,</strong>
<strong class="bold" lang="">  "singleQuote": true</strong>
<strong class="bold" lang="">}</strong></pre>
<p lang="en-GB">The provided example sets the indentation to four spaces. It instructs Prettier to always use single quotes instead of double quotes for strings when possible. Most importantly, we disable the use of semicolons.</p>
<ol>
<li lang="en-GB" value="4">With<a id="_idIndexMarker184"/> the preceding configuration in place, we can run <code>prettier</code> again:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx prettier index.js</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">export function div(a, b) {</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">    return a / b</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">}</strong></pre></li>
</ol>
<p lang="en-GB">The effect is striking. Now, four spaces instead of two are being used. The semicolon is dropped. The configuration has been successfully applied. However, one thing that is still left open is to actually overwrite the existing file. After all, getting the formatting code in the command line is nice but not worth a lot if we did not really format the original file.</p>
<ol>
<li lang="en-GB" value="5">For <code>prettier</code> to apply the changes, the <code>--write</code> flag needs to be used. The command from <em class="italic" lang="">step 4</em> would therefore change to the following:<pre class="console" lang="en-GB">
<strong class="bold" lang="">$ npx prettier index.js --write</strong></pre><pre class="console" lang="en-GB">
<strong class="bold" lang="">index.js 41ms</strong></pre></li>
</ol>
<p lang="en-GB">The output now prints a summary of all the files that have and have not been changed. With the preceding command, only the <code>index.js</code> file is formatted; however, the <code>prettier</code> utility would also accept wild cards such as <code>*</code> to indicate placeholders matching multiple files.</p>
<p class="callout-heading" lang="en-GB">Globs</p>
<p class="callout" lang="en-GB">Many Node.js utilities accept a special kind of syntax to match multiple files. Very often, this syntax comes directly or is at least <a id="_idIndexMarker185"/>inspired by the <code>glob</code> package, which copied the notation from Unix. The syntax defines so-called globs – that is, patterns that allow matching files. In this regular expression-like syntax, <code>*</code> matches 0 or more characters in a single path segment, while <code>?</code> matches exactly a single character. Another useful construct is <code>**</code>, which can be used to denote 0 or more directories. A pattern such as <code>**/*.js</code> would thus match any <code>.js</code> file in the current directory and any subdirectory. More details on the <code>glob</code> package and its syntax <a id="_idIndexMarker186"/>can be found at <a href="https://www.npmjs.com/package/glob">https://www.npmjs.com/package/glob</a>.</p>
<p lang="en-GB">While <a id="_idIndexMarker187"/>Prettier is great for many kinds of source files, it surely cannot tackle text files in general. Quite often, however, we want to establish general formatting rules for anything in our project. This is where <strong class="bold" lang="">EditorConfig</strong> comes in.</p>
<p lang="en-GB">EditorConfig<a id="_idIndexMarker188"/> is a standard to help maintain consistent coding styles for a project. It is established by a file named <code>.editorconfig</code>. Pretty much every editor supports this file.</p>
<p lang="en-GB">An <code>.editorconfig</code> example<a id="_idIndexMarker189"/> looks like the following:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">.editorconfig</p>
<pre class="source-code" lang="en-GB">root = true
[*]
end_of_line = lf
insert_final_newline = true
indent_style = space
indent_size = 2</pre>
<p lang="en-GB">As with ESLint, we can use nested configuration files – that is, specialize the configuration for subdirectories by having another <code>.editorconfig</code> file in them. The <code>root = true</code> configuration tells the editor to stop traversing the file system upward for additional configuration files. Otherwise, this file has only a single section, <code>[*]</code>, matching all text files.</p>
<p lang="en-GB">The ruleset in the preceding example above would actually tell an editor to exclusively use the line feed (<code>lf</code>) character to end lines. While this is the standard on Unix-based systems, Windows users would usually get two characters to end lines: line feed (<code>lf</code>) and carriage return (<code>cr</code>) – the so-called <code>lfcr</code> convention. In addition, the ruleset would introduce an empty line at the end of each file. By definition, each text file would use two spaces as an indentation level.</p>
<p lang="en-GB">While<a id="_idIndexMarker190"/> such a configuration is nice, it can be in direct conflict with the Prettier configuration. However, another great thing about Prettier is that it can work hand in hand with EditorConfig. Let’s rewire the previous configuration to also use EditorConfig:</p>
<p class="SC---Heading" lang="en-US" xml:lang="en-US">.prettierrc</p>
<pre class="source-code" lang="en-GB">{
  "semi": false,
  "singleQuote": true
}</pre>
<p lang="en-GB">Since Prettier rules will always take precedence and overwrite the ones from the <code>.editorconfig</code> file, it makes sense to remove conflicting rules. Otherwise, we will be only left with the JavaScript-specific formatting rules – for example, for semicolons and the preferred quote style, in <code>.prettierrc</code>. The general text formatting rules are now specified via EditorConfig implicitly.</p>
<p lang="en-GB">With all this in mind, let’s recap what we’ve learned in this chapter.</p>
<h1 id="_idParaDest-57" lang="en-GB"><a id="_idTextAnchor056"/>Summary</h1>
<p lang="en-GB">In this chapter, you learned how code quality can be enhanced with the help of linters and formatters. You can now use common tools such as EditorConfig, Prettier, Stylelint, or ESLint. You are now able to add, configure, and run these tools in any project that you like.</p>
<p lang="en-GB">At this point, you can contribute to pretty much all frontend projects that are based on Node.js for their tooling. Also, you can introduce great quality enhancers such as Prettier. Once successfully introduced, these tools ensure that certain quality gates are always fulfilled. In the case of Prettier, discussions about code style are mostly a thing of the past – helping teams all around the world to actually focus on the actual problem instead of dealing with code cosmetics.</p>
<p lang="en-GB">A downside to keep in mind is that most of these tools have some assumptions about your code. So, if your code uses, for instance, one of the flavors we discussed in <a href="B18989_04.xhtml#_idTextAnchor042"><em class="italic" lang="">Chapter 4</em></a>, <em class="italic" lang="">Using Different Flavors of JavaScript</em>, then you’ll most likely need to teach some of your tools about this flavor, too. Quite often, this only requires the installation of a plugin, but in severe cases, you are left with the decision to either abandon the tool or stop using the flavor for your project.</p>
<p lang="en-GB">In the next chapter, we will take an in-depth look at perhaps the most important tooling for frontend developers: bundlers.</p>
</div>
</body></html>