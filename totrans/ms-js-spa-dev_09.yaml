- en: Chapter 9. Handling Web Requests with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express is a powerful, unopinionated web application framework built on top
    of Node.js. It provides a highly pluggable interface and a few basic objects to
    handle the HTTP request response life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: We have already begun working with Express, beginning our SPA with the Express
    generator. It's time to build things out further and learn more about the power
    of Express.
  prefs: []
  type: TYPE_NORMAL
- en: Express's true power comes from its minimal and unopinionated nature. It's highly
    flexible and extensible, making it a good tool for a number of web applications,
    single page, hybrid, even socket-based.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers Express in more detail, starting with built-in objects.
    We will build out a number of routes, organizing the code of our application into
    logical modules. We will learn about the request and response objects in Express
    in detail, and develop our own middleware functionality to handle AJAX requests.
  prefs: []
  type: TYPE_NORMAL
- en: We will conclude by stubbing out a RESTful API for our SPA, configuring it to
    respond using different data formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Express
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Express request and response objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing variables in GET and POST request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing Express middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing routes into logical modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining Express in detail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Express represents a very thin layer on top of Node's HTTP server, but it has
    a few built-in objects that are important to become familiar with. These include
    the `App`, `Request`, `Response`, and `Router` objects. These objects, and a couple
    of plugins, provide all of the core functionality of the Express framework.
  prefs: []
  type: TYPE_NORMAL
- en: App object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Express, the `app` object typically refers to the Express application. This
    is by convention and is the result of calling the `express()` function. Open up
    your `app.js` file and see the line that reads `varapp=express()`. This is where
    we create our application and assign it to the variable `app`. We could have used
    any variable name, but the convention is to use `app`. We'll stick to convention
    and refer to this object as `app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a closer look at our `app.js` file and look at how we''re already
    using the `app` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `app` API includes an important property, event, and a number of methods.
    To see a full list of functionality in the Express application API, you can view
    the documentation at [http://expressjs.com/en/api.html](http://expressjs.com/en/api.html),
    but we'll cover some of the most important features here.
  prefs: []
  type: TYPE_NORMAL
- en: app.locals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`app.locals` is a JavaScript object that persists within the application itself.
    Any properties or functions added to the object will be available throughout the
    `app`. This is useful for creating helper functions or app level values.'
  prefs: []
  type: TYPE_NORMAL
- en: The `app.locals` objects are available in middleware through the request object
    through `req.app.locals`.
  prefs: []
  type: TYPE_NORMAL
- en: Add the following line in your `app.js` file after the calls to `app.set();`:`app.locals.appName="MyGiftApp";`
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open up your `routes/users.js` file and modify it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside the route for show, we added a bit of data to the second argument to
    `res.render()`. We mapped `req.app.locals.appname` to the property `appName`.
    This makes it available to our template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open your `views/users/show.ejs` template file and modify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We've added an output tag for the `appName` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, make sure that the Mongo daemon is running and start or restart your application.
    In your browser, navigate to`:localhost:3000/users/show` and you should see something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![app.locals](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've successfully added an application level local property and displayed it
    in one of our templates.
  prefs: []
  type: TYPE_NORMAL
- en: app.set()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After we create the application by calling the express function, we see a couple
    of calls to `app.set()` setting the path to the views directory and the view engine.
    The set function takes two arguments. The first argument is a string containing
    the name of one of the application settings for Express. Some application settings
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`casesensitiverouting`: A Boolean, disabled by default. When enabled, it ignores
    the case of routes. `/route` and `/Route` would be treated as the same route.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`env`: A string setting for the environment mode. The default is `development` or
    whatever the `NODE_ENV` environment variable is set to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etag`: A setting for the `ETag` response header. It has a sensible default,
    but if you want to change it, I suggest referring to the documentation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsonpcallbackname`: A string, specifying a default callback function for JSONP
    responses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jsonspaces`: Numeric, when specified, it sends JSON responses back prettified
    and indented by the specified number of spaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`queryparser`: By default, this is set to `extended`, but you can use it to
    disable query parsing or to set a simpler or customized query parsing function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`strictrouting`: A Boolean, disabled by default treating `/route` the same
    as `/route/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`views`: A string or array telling Express where to look up display templates.
    If the value is an array, Express will look them up in the order they occur in
    the array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewcache`: A Boolean, true in production, this tells Express to cache the
    view templates. This is usually undesired in development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`viewengine`: A string - the default engine extension (such as `ejs`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`x-powered-by`: A Boolean, true by default, sends a `X-Powered-By:Express` HTTP
    header. I think it''s normally a good idea to shut this off, giving less information
    to potential hackers. Go ahead and add `app.set(''x-powered-by'',false);` to your
    `app.js` file after the line setting the view engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: app.enable()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any of the `app` settings that take Booleans can be turned on with `app.enable()`;
    for example, to enable view caching, you can use `app.enable('viewcache');`.
  prefs: []
  type: TYPE_NORMAL
- en: app.disable()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have an enable function, you should have a disable function as well,
    right? `app.disable()` sets any `app` settings that are Boolean to false, turning
    them off.
  prefs: []
  type: TYPE_NORMAL
- en: app.listen()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Under the covers, the app object returned by the call to `express()` is a JavaScript
    function. Remember that functions in JavaScript are objects and can be passed
    around like any other objects. When we call `app.listen()`, it essentially invokes
    Node's native `http.createServer()` function passing itself, the `app` function,
    as a callback.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to use HTTPS, it's a little different, and we'll cover that in a
    later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, we would use `app.listen()` passing the port we wish to listen
    to as the argument. However, the Express generator has set up our code for us
    in `bin/www`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Instead of simply calling `app.listen()`, the Express generator has set up this
    method, which is essentially doing the same thing, but adding some event listeners
    to the server object for error handling, and more.
  prefs: []
  type: TYPE_NORMAL
- en: app.METHOD()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`app.METHOD()` routes requests that come into the server using an actual method.
    There isn''t a `METHOD` function, the actual functions are the lowercase of specific
    HTTP request methods. In other words, you would use `app.get()` or `app.post()`
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: There can be small point of confusion here because `app.get('somevalue')` can
    also be used to return an `app` setting.
  prefs: []
  type: TYPE_NORMAL
- en: In general, we are going to hand off requests to the Express router and handle
    routing in a more modular manner.
  prefs: []
  type: TYPE_NORMAL
- en: app.all()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`app.all()` is similar to `app.METHOD()`, but it matches all HTTP request methods.
    It''s often used to easily add global functionality via middleware to a path or
    part of an application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want to add authentication to a part of your `app` without
    the bother of adding it to each individual route or method, you might do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This would pass all requests, regardless of method, which began with the path
    `/protected/` through the `authenticationRequired` middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Request object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The request object in Express holds data related to the HTTP request. By default,
    it will contain properties for things such as the query string, parameters, headers,
    post parameters, and more. It is the first argument in callback functions provided
    by middleware, like routing, and, by convention, is usually called `req`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In our routes`/users` file, here is our one route for a get request for the
    URI `/show`. You can see that the first argument to the callback function is `req`.
    This is the request object. We get a reference to the database from the request
    object, as well as a reference to the `app.locals.appName` property.
  prefs: []
  type: TYPE_NORMAL
- en: req.params
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `params` property of the request object gives us access to parameters passed
    to the server through the URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our `routes/users` file to add a new route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We've added a new route that matches `/show/:id`. The `:id` portion will match
    a variable part of the URL; in this case we are expecting an ID, and place that
    on the `req.params` object as a property named `id`.
  prefs: []
  type: TYPE_NORMAL
- en: We issue a `findOne` query to our database on the users collection. `findOne`
    returns a single object (the first match), where find returns an array with all
    matches. In this case, we are only interested in a single match; we are looking
    for a user with a specific `_id`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we render the `users/user` template passing our values. We don''t have
    a user template yet, so let''s create `user.ejs` in our `views/users` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The object passed into the template containing our user data is called `user`.
    Here, we can access all its properties, `firstName`, `lastName`, `email`, and
    `_id`. To make life a little easier, we've added a link to go back to the show
    route.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify `show.ejs` a little to add navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We've added a link to `show/<%=user._id%>,` which will create the URL we need
    to navigate to the individual user's show route.
  prefs: []
  type: TYPE_NORMAL
- en: Start or restart your server. A restart is required any time you change a route
    or the main application, but not for simple template changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to `localhost:3000/users/show` and click on one of your user''s first
    names. You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![req.params](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Of course, because Mongo generates the `_id` field, yours will not match mine.
    Well, they might, but it would be an astronomical coincidence.
  prefs: []
  type: TYPE_NORMAL
- en: req.body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `body` property on the request object contains name value pairs typically
    sent as part of a post request. In order to get access to this, you need to add
    `body` parsing middleware to your `app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Express generator has already set this up for us by requiring a `body`
    parser and then adding the middleware in these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These two lines allow us to parse data sent back as `application/json or application/x-www-form-urlencoded`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our routes, we would have access to parameters passed in through `req.body`.
    We''ll be doing a lot of that when we start to build resourceful routes later.
    Here''s an example (there''s no need to add it to our code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we accept a post to `users/user`. We use `monk` to do an insert (adding
    a record to our MongoDB database). The first argument to the insert function is
    an object, and we are using the `firstName`, `lastName`, and `email` fields from
    `req.body` to populate the same properties of the document to be inserted. Assuming
    there's no error, we redirect to `users/show`, which displays a list of users
    including our new user.
  prefs: []
  type: TYPE_NORMAL
- en: req.query
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another way we can get data from a request is using the query string appended
    to a URL. If you are unfamiliar with this, the query string is data that is appended
    as name value pairs after a question mark on the URL.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in `http:www.mymadeupdomain.org/foo?name=john+smith&q=foo`, the
    query string part is the `name=john+smith&q=foo`. To access this inside our `app`,
    we would use `req.query.name` and `req.query.q`. This would give us back `johnsmith` and
    `foo` respectively with no plus sign between `john` and `smith`. The plus sign
    is part of URL encoding that happens because spaces don't translate in URLs.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no query string, `req.query` will contain an empty object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**When should I use a query string instead of parameters?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no best answer for this. In general, you want to use route parameters
    when you want multiple routes to handle different types of operations. We''re
    going to take this approach most of the time. Query strings are good if you want
    a single `GET` request route that''s going to be flexible with the type of data
    it receives, and you want users to be able to bookmark it. Google uses query strings
    for searches: [https://www.google.com/search?q=things](https://www.google.com/search?q=things).'
  prefs: []
  type: TYPE_NORMAL
- en: req.cookies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`req.cookies` requires the use of the cookie parser middleware, conveniently
    already installed for us by the Express generator, and gives us access to the
    cookies in the request. If there are no cookies, the value of `req.cookies` will
    be an empty object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cookies are accessed by name: `req.cookies.userID` would give us a cookie named
    `userID`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will delve into cookies in more detail later, but the cookie parser is required
    for things such as authentication and security. It's best to leave it in place
    whether you are going to use cookies directly or not.
  prefs: []
  type: TYPE_NORMAL
- en: req.xhr
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a simple Boolean value that is `true` if the `X-Requested-With` request
    header is `XMLHttpRequest`. Most commonly, this happens with AJAX requests issued
    by libraries such as jQuery.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for SPAs because we may want to respond with an HTML page when
    the request comes from a change in location from the browser, but with data when
    subsequent requests come from client-side code issuing requests through AJAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at our `/show/:id` route from `/routes/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: So we check to see if the request has come in through `XMLHTTPRequest`, AJAX.
    If it has, we add the `appName` to the `User` object and then return it as JSON.
    If it didn't, we render and return the page as normal.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite handy, and we'll use this mechanism later.
  prefs: []
  type: TYPE_NORMAL
- en: req.accepts()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`req.accepts` is a function which checks a request''s `Accept` header and returns
    `true` if there''s a match. It can accept a string or array or extensions or MIME
    types, and returns either the best match or `false` (`undefined`, which is a falsy
    value in JavaScript), if there''s nothing matching.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say the browser sends back the header: `Accept:text/*`.
    `application/json`: `req.accepts(''html'')` would match the `text/*` part and
    return `html`. `req.accepts([''image/png'',''application/json''])` would return
    `json`.'
  prefs: []
  type: TYPE_NORMAL
- en: As with `req.xhr`, this can be very useful for responding flexibly to different
    types of requests on the same route.
  prefs: []
  type: TYPE_NORMAL
- en: req.get()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`req.get()` is a function that returns the value of an HTTP header sent in
    the request. The function takes a string which does case-insensitive matching.
    An alias of this function is `req.header()`.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, `req.get('content-type')` returns the content type header from
    the HTTP request as a string, such as `application/json` or `text/html`.
  prefs: []
  type: TYPE_NORMAL
- en: Response object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Express response object is a JavaScript object that represents the response
    that we are going to send back from the server to the client. We see it paired
    with the request object and, like using `req` for request, the convention is to
    use `res`.
  prefs: []
  type: TYPE_NORMAL
- en: res.app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `res.app` object is identical to the `req.app` property. It's a reference
    to the application, but attached to the response object in this case. This offers
    some flexibility in accessing the app properties.
  prefs: []
  type: TYPE_NORMAL
- en: res.cookie()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a response object method that allows us to set a cookie and send it
    back with the response. It takes a name, value, and an optional object containing
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This sets a `userName` cookie with a value of `Joe`. The cookie expires 900,000
    seconds from the response. The cookie is to be used with HTTPS only, and it is
    to be signed. Other options that can be set are the domain and path for the cookie,
    and an actual expiration date.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method clears the named cookie:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This would clear the cookie we set previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: res.download()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`res.download` transfers a file at a given path as an attachment. It takes
    the path, an optional filename, and an option callback function once the file
    transfer completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We initiate a download of the file at `/reports/TPS-coversheet`, but transfer
    it as `coversheet.pdf`. Once complete, we check if there was an error, doing something
    appropriate in any case.
  prefs: []
  type: TYPE_NORMAL
- en: res.json()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method sends a JSON response, it's that straightforward. It can take any
    JavaScript object. The nice thing about using a MongoDB database is that often
    we can just pass out raw database responses using `res.json():`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we respond with JSON passing an object with properties for our `Sheltie`
    named `Fido` and the commands that she knows.
  prefs: []
  type: TYPE_NORMAL
- en: res.jsonp()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This method returns JSON data wrapped in a callback function, otherwise known
    as JSONP. By default the function will be called callback. But this can be overridden
    using `app.set(''jsonpcallbackname'',''someFunction'');`. In this case, we get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the appropriate client-side code would have to be in place to handle
    the response.
  prefs: []
  type: TYPE_NORMAL
- en: res.redirect()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've already used this one. This sends a redirect back to the requester with
    an appropriate HTTP status code. If no status code is specified, a `302` is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s something we looked at earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: After an insert operation, adding a new document to our database, we send a
    redirect back to the browser to go to `/users/show`. Because no status was specified,
    a `302` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The path is quite flexible and can be anything from a fully formed URL: `res.redirect(''https://www.google.com/search?q=food'');`
    to a relative path: `res.redirect(''../dashboard/show'');`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This sends a permanently moved redirect to `whitehouse.gov`, consequently confusing
    Google and ruining your SEO. For more information about various redirect codes,
    check out the official HTTP specification, paying attention to the `3xx` status
    codes: [http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).'
  prefs: []
  type: TYPE_NORMAL
- en: res.render()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another method we've already used, which sends back rendered HTML which
    has been compiled from a `view` template. The arguments to the method are the
    template view, an optional object containing local variables, and an optional
    callback function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a peek at our `/show` route inside our routes`/users.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we've seen, this call to `res.render()` renders the template at `/views/users/show`.
    It makes the local object with users and `appName` available to the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we you add a callback method to the render method, you need to call `res.send()`
    explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we've added a callback function which has two arguments, an error, if
    any, and the rendered `html`. This allows us to add an error handler, set a cookie
    on the response object, and then send the response.
  prefs: []
  type: TYPE_NORMAL
- en: res.send()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We've seen that `res.send()` is a method that is used to send the HTTP response.
    `res.send()` is pretty flexible and can give a number of different types of arguments,
    including a `Buffer`, an object, array, or a string.
  prefs: []
  type: TYPE_NORMAL
- en: '`res.send()` will adjust the HTTP `Content-Type` header appropriately for the
    argument. When the argument is a string the `Content-Type` will be `text/html`,
    when an object or array it will be `application/json`, and when it''s a `Buffer`
    object it will be set to `application/octet-stream`. These defaults can be overridden
    by calling `res.set()` with a different `Content-Type`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also chain a call to `status()` to pass an HTTP status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By chaining the status with a `500` HTTP status, we can send a message that
    there's been an internal server error along with our message.
  prefs: []
  type: TYPE_NORMAL
- en: Router object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The router object is described in the Express documentation as a `mini-application`
    that only provides middleware and routing functionality. The router acts as middleware
    so it can be used as an argument in `app.use()` or in another router's `use()`
    method, making nesting and organizing routes easy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a router object by calling the `express.Router()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In our router files, we always export the router using `module.exports=router`.
    This allows us to load the router as a module through `require()` and then use
    it like any other middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review our `app.js` file again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We require the index route, assigning it to the variable routes, and then we
    require the users route, assigning it to the variable users. Then we add the routes
    to the `app` using the `app.use` function, matching the root path and the `/users`
    path.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Express will try to match routes in order. Since every route will
    match the root path, it will look there first, and if it finds no match to anything
    starting with `/users`, Express will then match to the next route. Inside our
    `/users` route, we know we have a route for show, so `/users/show` will be matched
    there.
  prefs: []
  type: TYPE_NORMAL
- en: router.METHOD()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This works the same exact way as `app.METHOD()`. We add lowercase HTTP verbs
    as functions, passing in a route to match and a callback function. We''ve seen
    this pattern already:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'One thing to note here is that `res.send()`, `res.render()`, and `res.end()`
    will all terminate the response. This means that whatever is in `next()` will
    not be called. Think of it as returning out of a JavaScript function. There''s
    no more you can do after that. However, you can call multiple routes in succession
    by not terminating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Both routes match `/something`, so the first one would get called, and it adds
    `foo` to the locals property on the response object. Then it makes a call to next
    which calls the next matching route, sending the value of `res.locals,foo`.
  prefs: []
  type: TYPE_NORMAL
- en: router.all()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`router.all()` works like `router.METHOD()` except that it matches all HTTP
    verbs, get, post, and so on. It''s incredibly useful for adding `global` functionality
    to a series of routes. For example, let''s say that you have an `api` route and
    want to make sure that every call to any route in `api` is authenticated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Placing this at the top of your routes file would make all calls to any URL
    starting with `/api/` to go through the `someAuthenticationMiddleware` middleware.
  prefs: []
  type: TYPE_NORMAL
- en: router.param()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`router.param()` is a powerful way to add callback functionality based on route
    parameters. Let''s say, for example, that in our `users` route file, every time
    we get an `id` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive back into our `routes/users.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use `router.param()` to look for calls to any route that has an `id` parameter.
    The callback function does a database lookup on user. If there's an error, we
    terminate by sending the error. The user, if one is found, is added to the request
    object. We then call `next()` to pass the request to the matching route.
  prefs: []
  type: TYPE_NORMAL
- en: Writing our own middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we've seen, Express is designed to rely heavily on pluggable middleware for
    adding functionality to our application. Let's roll our own piece of middleware
    that will give us an easy way to switch our responses to JSON format anywhere
    in our `app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `utils` directory to your `giftapp` project folder and create a file
    called `json.js` inside that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `isJSON` function we create takes the three arguments that all Express middleware
    accepts - the request object, the response object, and the reference to next.
    We check to see if the request object's `xhr` value is `true` or if the accepts
    header on the request is `application/json`. If either condition is true, we can
    assume that the client is requesting `JSON` rather than `HTML`.
  prefs: []
  type: TYPE_NORMAL
- en: We add an `isJSON` property to the request object, setting it to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s modify our `app.js` file to include this middleware anywhere in
    the application where we need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First, we require in our module, assigning it to the variable `isJSON`. Note
    that we need to use an explicit path here. If we simply used a module name, Node
    will try to look for it in the `node_modules` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we add our middleware to the application using `app.use(isJSON)`. Where
    we place this in the file is important as middleware is called sequentially. In
    our case, this can be anywhere as long as it appears before the routes that use
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We modify our two routes to conditionally send JSON or HTML depending on our
    new `isJSON` flag. Restarting your server and then browsing to either route should
    show no difference, since you're not actually requesting JSON.
  prefs: []
  type: TYPE_NORMAL
- en: If you'd like to test this, you can use a browser plugin such as `Postman` or
    a terminal request such as `curl` to issue an `xhr` request and see the data come
    back as `JSON`.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a RESTful API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's do a little more work setting up our SPA by building out some resourceful
    routing as part of a RESTFul API that we can connect later to our database and
    our client-side code. We're lucky that Express has such a vibrant community of
    developers building many add-ons, and we're going to use one for resourceful routing.
  prefs: []
  type: TYPE_NORMAL
- en: Installing resourceful routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is to install our module, which will provide
    us with some resourceful routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This installs the resourceful routing plugin we're going to use, and saves a
    reference to the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to do some setup in our `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We pull in the resource routing module using `require()` and assign it to the
    variable `routing`. Then we create a shortcut variable to a controllers directory,
    which we will be building next.
  prefs: []
  type: TYPE_NORMAL
- en: We add the following code, `routing.expose_routing_table(app,{at:""/my-routes""});`
    which allows us to view our routing table at the URL `my-routes`. Obviously, this
    is not something we'd leave intact in production, but it's a useful debugging
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we set up our resourceful routing for `giftlists` with `routing.resources(app,controllers,""giftlist"");`.
    This won't do anything yet because we haven't set up our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Building out giftlist controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, our resourceful router will build a number of standard restful
    routes for us, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, these routes provide use with basic CRUD (create, read, update,
    delete) functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, these routes will only be created if the controller and routes actually
    exist, so we need to build them. Create a controllers directory in your `giftapp`
    folder with a file called `giftlist_controller.js`. Our plugin will add the `_controller` part
    when it goes to load our controller, so be sure to name it correctly. For now,
    we are going to stub out our routes to make sure they are working:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, each of our route handlers is a function that receives the request
    and response objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart your server and navigate to `localhost:3000/giftlist/17`, where you
    should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Responding with different data formats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our resourceful routes can also support different data formats, so let''s stub
    those out as well, and we''ll also use our `isJSON` property in our `giftlist_controller.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Here, we added tests to each of our routes to see if the client is requesting
    `JSON` data. If they are, we return `JSON`. Otherwise, we return `HTML`.
  prefs: []
  type: TYPE_NORMAL
- en: We check to see if the client is expecting `JSON` in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: First, we look to see if the `req.params.format` is `json`. Using this resourceful
    routing middleware, appending a .:format to the URL adds that format to the `req.params`
    object as the value of the format. In other words, entering the URL `localhost:3000/giftlist.json`
    triggers the `giftlist_controller.index` route, setting the format parameter to
    `json`.
  prefs: []
  type: TYPE_NORMAL
- en: The second method is to rely on the `req.isJSON` parameter set by our middleware.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will connect these resourceful routes to CRUD operations
    on our database, and start to render data to a page as we flesh out our SPA.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at Express, a Node.js web application framework,
    in greater detail. You learned that Express is an extremely flexible and unopinionated
    web framework built on top of Node.js HTTP services.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, Express provides access to a request, response, application, and
    router objects. Using these objects, we can manipulate web requests and respond
    in a sophisticated manner.
  prefs: []
  type: TYPE_NORMAL
- en: Using Express predominantly means writing or using middleware plugins, through
    which requests flow. We learned to use these plugins, and we wrote some utility
    middleware of our own. We examined routing in detail, and used a resourceful routing
    plugin to start to build a RESTful API for our SPA. We made the API flexible,
    capable of responding with either `JSON` or `HTML` data depending on the request.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover the frontend. Specifically, you will be learning
    about view templates, as well as AngularJS.
  prefs: []
  type: TYPE_NORMAL
