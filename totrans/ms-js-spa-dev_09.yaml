- en: Chapter 9. Handling Web Requests with Express
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：使用Express处理Web请求
- en: Express is a powerful, unopinionated web application framework built on top
    of Node.js. It provides a highly pluggable interface and a few basic objects to
    handle the HTTP request response life cycle.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Express是一个基于Node.js构建的强大、无偏见的Web应用程序框架。它提供了一个高度可插拔的接口和一些基本对象来处理HTTP请求响应生命周期。
- en: We have already begun working with Express, beginning our SPA with the Express
    generator. It's time to build things out further and learn more about the power
    of Express.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经开始了与Express的合作，使用Express生成器开始了我们的单页应用（SPA）。现在是时候进一步构建事物并了解Express的强大功能了。
- en: Express's true power comes from its minimal and unopinionated nature. It's highly
    flexible and extensible, making it a good tool for a number of web applications,
    single page, hybrid, even socket-based.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Express的真正力量来自于其最小化和无偏见的特点。它非常灵活和可扩展，使其成为许多Web应用程序、单页应用、混合应用甚至基于套接字的应用程序的好工具。
- en: This chapter covers Express in more detail, starting with built-in objects.
    We will build out a number of routes, organizing the code of our application into
    logical modules. We will learn about the request and response objects in Express
    in detail, and develop our own middleware functionality to handle AJAX requests.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章更详细地介绍了Express，从内置对象开始。我们将构建许多路由，将应用程序代码组织到逻辑模块中。我们将详细学习Express中的请求和响应对象，并开发自己的中间件功能来处理AJAX请求。
- en: We will conclude by stubbing out a RESTful API for our SPA, configuring it to
    respond using different data formats.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过为我们的SPA提供一个RESTful API来结束，配置它以使用不同的数据格式进行响应。
- en: 'This chapter covers the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Configuring Express
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Express
- en: Express request and response objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express请求和响应对象
- en: Passing variables in GET and POST request
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GET和POST请求中传递变量
- en: Developing Express middleware
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发Express中间件
- en: Building RESTful services
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建RESTful服务
- en: Organizing routes into logical modules
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将路由组织到逻辑模块中
- en: Examining Express in detail
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 详细考察Express
- en: Express represents a very thin layer on top of Node's HTTP server, but it has
    a few built-in objects that are important to become familiar with. These include
    the `App`, `Request`, `Response`, and `Router` objects. These objects, and a couple
    of plugins, provide all of the core functionality of the Express framework.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Express在Node的HTTP服务器之上代表一个非常薄的层，但它有一些内置的对象，这些对象对于熟悉它们非常重要。这些包括`App`、`Request`、`Response`和`Router`对象。这些对象以及一些插件提供了Express框架的所有核心功能。
- en: App object
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用对象
- en: In Express, the `app` object typically refers to the Express application. This
    is by convention and is the result of calling the `express()` function. Open up
    your `app.js` file and see the line that reads `varapp=express()`. This is where
    we create our application and assign it to the variable `app`. We could have used
    any variable name, but the convention is to use `app`. We'll stick to convention
    and refer to this object as `app`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Express中，`app`对象通常指的是Express应用程序。这是惯例，也是调用`express()`函数的结果。打开你的`app.js`文件，看看读取`var
    app = express()`的那一行。这是我们创建应用程序并将其分配给变量`app`的地方。我们可以使用任何变量名，但惯例是使用`app`。我们将遵循惯例，并将此对象称为`app`。
- en: 'Let''s take a closer look at our `app.js` file and look at how we''re already
    using the `app` object:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们的`app.js`文件，看看我们是如何使用`app`对象的：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `app` API includes an important property, event, and a number of methods.
    To see a full list of functionality in the Express application API, you can view
    the documentation at [http://expressjs.com/en/api.html](http://expressjs.com/en/api.html),
    but we'll cover some of the most important features here.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`app` API包括一个重要的属性、事件和多个方法。要查看Express应用程序API中的完整功能列表，您可以在[http://expressjs.com/en/api.html](http://expressjs.com/en/api.html)查看文档，但在这里我们将介绍一些最重要的功能。'
- en: app.locals
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.locals
- en: '`app.locals` is a JavaScript object that persists within the application itself.
    Any properties or functions added to the object will be available throughout the
    `app`. This is useful for creating helper functions or app level values.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.locals`是一个在应用程序本身中持久存在的JavaScript对象。添加到该对象中的任何属性或函数都将在整个`app`中可用。这对于创建辅助函数或应用级别的值非常有用。'
- en: The `app.locals` objects are available in middleware through the request object
    through `req.app.locals`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.locals`对象可以通过请求对象通过`req.app.locals`在中间件中访问。'
- en: Add the following line in your `app.js` file after the calls to `app.set();`:`app.locals.appName="MyGiftApp";`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`app.js`文件中`app.set();`调用之后添加以下行：`app.locals.appName="MyGiftApp";`
- en: 'Now open up your `routes/users.js` file and modify it like so:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开你的 `routes/users.js` 文件并按如下方式修改它：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Inside the route for show, we added a bit of data to the second argument to
    `res.render()`. We mapped `req.app.locals.appname` to the property `appName`.
    This makes it available to our template.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `show` 路由内部，我们在 `res.render()` 的第二个参数中添加了一些数据。我们将 `req.app.locals.appname`
    映射到属性 `appName`。这使得它可以在我们的模板中使用。
- en: 'Now open your `views/users/show.ejs` template file and modify it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开你的 `views/users/show.ejs` 模板文件并按如下方式修改它：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've added an output tag for the `appName` property.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为 `appName` 属性添加了一个输出标签。
- en: 'Now, make sure that the Mongo daemon is running and start or restart your application.
    In your browser, navigate to`:localhost:3000/users/show` and you should see something
    like the following:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，确保 MongoDB 守护程序正在运行，并启动或重启你的应用程序。在你的浏览器中，导航到 `:localhost:3000/users/show`，你应该看到如下内容：
- en: '![app.locals](img/image_09_001.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![app.locals](img/image_09_001.jpg)'
- en: We've successfully added an application level local property and displayed it
    in one of our templates.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功添加了一个应用程序级别的本地属性，并在我们的模板中显示了它。
- en: app.set()
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.set()
- en: 'After we create the application by calling the express function, we see a couple
    of calls to `app.set()` setting the path to the views directory and the view engine.
    The set function takes two arguments. The first argument is a string containing
    the name of one of the application settings for Express. Some application settings
    include the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过调用 express 函数创建应用程序之后，我们看到几个对 `app.set()` 的调用，设置视图目录和视图引擎的路径。set 函数接受两个参数。第一个参数是一个字符串，包含
    Express 应用程序设置中的一个设置名称。一些应用程序设置包括以下内容：
- en: '`casesensitiverouting`: A Boolean, disabled by default. When enabled, it ignores
    the case of routes. `/route` and `/Route` would be treated as the same route.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`casesensitiverouting`：一个布尔值，默认禁用。当启用时，它忽略路由的大小写。`/route` 和 `/Route` 将被视为相同的路由。'
- en: '`env`: A string setting for the environment mode. The default is `development` or
    whatever the `NODE_ENV` environment variable is set to.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env`：一个用于环境模式的字符串设置。默认是 `development` 或 `NODE_ENV` 环境变量设置的值。'
- en: '`etag`: A setting for the `ETag` response header. It has a sensible default,
    but if you want to change it, I suggest referring to the documentation.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`etag`：用于 `ETag` 响应头的设置。它有一个合理的默认值，但如果你想更改它，我建议参考文档。'
- en: '`jsonpcallbackname`: A string, specifying a default callback function for JSONP
    responses.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonpcallbackname`：一个字符串，指定 JSONP 响应的默认回调函数。'
- en: '`jsonspaces`: Numeric, when specified, it sends JSON responses back prettified
    and indented by the specified number of spaces.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonspaces`：一个数值，当指定时，它将使用指定的空格数美化并缩进返回的 JSON 响应。'
- en: '`queryparser`: By default, this is set to `extended`, but you can use it to
    disable query parsing or to set a simpler or customized query parsing function.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queryparser`：默认情况下，这设置为 `extended`，但你可以用它来禁用查询解析或设置一个更简单或定制的查询解析函数。'
- en: '`strictrouting`: A Boolean, disabled by default treating `/route` the same
    as `/route/`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strictrouting`：一个布尔值，默认禁用，将 `/route` 视为 `/route/`。'
- en: '`views`: A string or array telling Express where to look up display templates.
    If the value is an array, Express will look them up in the order they occur in
    the array.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views`：一个字符串或数组，告诉 Express 在哪里查找显示模板。如果值是一个数组，Express 将按数组中出现的顺序查找它们。'
- en: '`viewcache`: A Boolean, true in production, this tells Express to cache the
    view templates. This is usually undesired in development.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewcache`：一个布尔值，在生产环境中默认为 true，这告诉 Express 缓存视图模板。在开发中这通常是不希望的。'
- en: '`viewengine`: A string - the default engine extension (such as `ejs`).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`viewengine`：一个字符串 - 默认引擎扩展（例如 `ejs`）。'
- en: '`x-powered-by`: A Boolean, true by default, sends a `X-Powered-By:Express` HTTP
    header. I think it''s normally a good idea to shut this off, giving less information
    to potential hackers. Go ahead and add `app.set(''x-powered-by'',false);` to your
    `app.js` file after the line setting the view engine.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x-powered-by`：一个布尔值，默认为 true，发送一个 `X-Powered-By:Express` HTTP 头。我认为关闭这个功能通常是个好主意，给潜在的黑客提供更少的信息。请在设置视图引擎的行之后，向你的
    `app.js` 文件中添加 `app.set(''x-powered-by'',false);`。'
- en: app.enable()
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.enable()
- en: Any of the `app` settings that take Booleans can be turned on with `app.enable()`;
    for example, to enable view caching, you can use `app.enable('viewcache');`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 任何接受布尔值的 `app` 设置都可以通过 `app.enable()` 打开；例如，要启用视图缓存，你可以使用 `app.enable('viewcache');`。
- en: app.disable()
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.disable()
- en: If you have an enable function, you should have a disable function as well,
    right? `app.disable()` sets any `app` settings that are Boolean to false, turning
    them off.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个启用函数，你应该有一个禁用函数，对吧？`app.disable()` 将任何 `app` 设置的布尔值设置为 false，将其关闭。
- en: app.listen()
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.listen()
- en: Under the covers, the app object returned by the call to `express()` is a JavaScript
    function. Remember that functions in JavaScript are objects and can be passed
    around like any other objects. When we call `app.listen()`, it essentially invokes
    Node's native `http.createServer()` function passing itself, the `app` function,
    as a callback.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，`express()` 调用返回的应用程序对象是一个 JavaScript 函数。记住，JavaScript 中的函数是对象，可以像其他任何对象一样传递。当我们调用
    `app.listen()` 时，它实际上调用了 Node 的原生 `http.createServer()` 函数，并将自身、`app` 函数作为回调传递。
- en: If we want to use HTTPS, it's a little different, and we'll cover that in a
    later chapter.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想使用 HTTPS，情况会有所不同，我们将在后面的章节中介绍。
- en: 'For our purposes, we would use `app.listen()` passing the port we wish to listen
    to as the argument. However, the Express generator has set up our code for us
    in `bin/www`, as shown in the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们会使用 `app.listen()` 并将我们希望监听的端口作为参数传递。然而，Express 生成器已经为我们设置了 `bin/www`
    中的代码，如下所示：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Instead of simply calling `app.listen()`, the Express generator has set up this
    method, which is essentially doing the same thing, but adding some event listeners
    to the server object for error handling, and more.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单地调用 `app.listen()` 不同，Express 生成器已经设置了此方法，它本质上做的是同样的事情，但为服务器对象添加了一些事件监听器以处理错误等。
- en: app.METHOD()
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.METHOD()
- en: '`app.METHOD()` routes requests that come into the server using an actual method.
    There isn''t a `METHOD` function, the actual functions are the lowercase of specific
    HTTP request methods. In other words, you would use `app.get()` or `app.post()`
    methods.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.METHOD()` 通过实际方法路由进入服务器的请求。没有 `METHOD` 函数，实际函数是特定 HTTP 请求方法的下划线形式。换句话说，你会使用
    `app.get()` 或 `app.post()` 方法。'
- en: There can be small point of confusion here because `app.get('somevalue')` can
    also be used to return an `app` setting.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能会有一些小的混淆点，因为 `app.get('somevalue')` 也可以用来返回一个 `app` 设置。
- en: In general, we are going to hand off requests to the Express router and handle
    routing in a more modular manner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们将请求传递给 Express 路由器，并以更模块化的方式处理路由。
- en: app.all()
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: app.all()
- en: '`app.all()` is similar to `app.METHOD()`, but it matches all HTTP request methods.
    It''s often used to easily add global functionality via middleware to a path or
    part of an application.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.all()` 与 `app.METHOD()` 类似，但它匹配所有 HTTP 请求方法。它通常用于通过中间件轻松地向路径或应用程序的某个部分添加全局功能。'
- en: 'For example, if you want to add authentication to a part of your `app` without
    the bother of adding it to each individual route or method, you might do something
    like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想在不添加到每个单独的路由或方法的情况下，为 `app` 的某个部分添加身份验证，你可能做些像这样的事情：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This would pass all requests, regardless of method, which began with the path
    `/protected/` through the `authenticationRequired` middleware.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使所有以 `/protected/` 路径开始的请求（无论方法如何）通过 `authenticationRequired` 中间件传递。
- en: Request object
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求对象
- en: 'The request object in Express holds data related to the HTTP request. By default,
    it will contain properties for things such as the query string, parameters, headers,
    post parameters, and more. It is the first argument in callback functions provided
    by middleware, like routing, and, by convention, is usually called `req`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Express 中的请求对象包含与 HTTP 请求相关的数据。默认情况下，它将包含查询字符串、参数、头部、POST 参数等属性。它是中间件（如路由）提供的回调函数的第一个参数，按照惯例，通常称为
    `req`：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In our routes`/users` file, here is our one route for a get request for the
    URI `/show`. You can see that the first argument to the callback function is `req`.
    This is the request object. We get a reference to the database from the request
    object, as well as a reference to the `app.locals.appName` property.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `routes/users` 文件中，这里是我们对 URI `/show` 的 GET 请求的一个路由。你可以看到回调函数的第一个参数是 `req`。这是请求对象。我们从请求对象中获取对数据库的引用，以及
    `app.locals.appName` 属性的引用。
- en: req.params
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: req.params
- en: The `params` property of the request object gives us access to parameters passed
    to the server through the URL.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象的 `params` 属性使我们能够访问通过 URL 传递给服务器的参数。
- en: 'Let''s modify our `routes/users` file to add a new route:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改 `routes/users` 文件以添加一个新的路由：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We've added a new route that matches `/show/:id`. The `:id` portion will match
    a variable part of the URL; in this case we are expecting an ID, and place that
    on the `req.params` object as a property named `id`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个新的路由，匹配`/show/:id`。`:id`部分将匹配URL的变量部分；在这种情况下，我们期望一个ID，并将其作为名为`id`的属性放置在`req.params`对象上。
- en: We issue a `findOne` query to our database on the users collection. `findOne`
    returns a single object (the first match), where find returns an array with all
    matches. In this case, we are only interested in a single match; we are looking
    for a user with a specific `_id`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对用户集合数据库发出`findOne`查询。`findOne`返回一个对象（第一个匹配项），其中`find`返回一个包含所有匹配项的数组。在这种情况下，我们只对单个匹配项感兴趣；我们正在寻找具有特定`_id`的用户。
- en: 'Then we render the `users/user` template passing our values. We don''t have
    a user template yet, so let''s create `user.ejs` in our `views/users` directory:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们渲染`users/user`模板，传递我们的值。我们还没有用户模板，所以让我们在`views/users`目录中创建`user.ejs`：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The object passed into the template containing our user data is called `user`.
    Here, we can access all its properties, `firstName`, `lastName`, `email`, and
    `_id`. To make life a little easier, we've added a link to go back to the show
    route.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 传递到模板中的包含我们的用户数据的对象被称为`user`。在这里，我们可以访问它的所有属性，`firstName`、`lastName`、`email`和`_id`。为了使生活更加简单，我们添加了一个链接回到显示路由。
- en: 'Let''s modify `show.ejs` a little to add navigation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下`show.ejs`以添加导航：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've added a link to `show/<%=user._id%>,` which will create the URL we need
    to navigate to the individual user's show route.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个链接到`show/<%=user._id%>,`，这将创建我们需要导航到单个用户显示路由的URL。
- en: Start or restart your server. A restart is required any time you change a route
    or the main application, but not for simple template changes.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 启动或重启你的服务器。每次更改路由或主应用程序时都需要重启，但对于简单的模板更改则不需要。
- en: 'Navigate to `localhost:3000/users/show` and click on one of your user''s first
    names. You should see something like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`localhost:3000/users/show`并点击你用户的一个名字。你应该会看到如下内容：
- en: '![req.params](img/image_09_002.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![req.params](img/image_09_002.jpg)'
- en: Of course, because Mongo generates the `_id` field, yours will not match mine.
    Well, they might, but it would be an astronomical coincidence.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，因为Mongo生成`_id`字段，你的不会匹配我的。嗯，它们可能匹配，但那将是一个天文巧合。
- en: req.body
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`req.body`'
- en: The `body` property on the request object contains name value pairs typically
    sent as part of a post request. In order to get access to this, you need to add
    `body` parsing middleware to your `app`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象上的`body`属性包含通常作为POST请求一部分发送的名称值对。为了访问这些，你需要向你的`app`添加`body`解析中间件。
- en: 'The Express generator has already set this up for us by requiring a `body`
    parser and then adding the middleware in these two lines:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Express生成器已经为我们设置好了，通过要求一个`body`解析器然后在两行中添加中间件：
- en: '[PRE9]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These two lines allow us to parse data sent back as `application/json or application/x-www-form-urlencoded`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行允许我们解析以`application/json`或`application/x-www-form-urlencoded`发送回的数据。
- en: 'In our routes, we would have access to parameters passed in through `req.body`.
    We''ll be doing a lot of that when we start to build resourceful routes later.
    Here''s an example (there''s no need to add it to our code):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的路由中，我们可以访问通过`req.body`传入的参数。当我们开始构建资源路由时，我们会做很多这样的事情。这里有一个例子（不需要将其添加到我们的代码中）：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we accept a post to `users/user`. We use `monk` to do an insert (adding
    a record to our MongoDB database). The first argument to the insert function is
    an object, and we are using the `firstName`, `lastName`, and `email` fields from
    `req.body` to populate the same properties of the document to be inserted. Assuming
    there's no error, we redirect to `users/show`, which displays a list of users
    including our new user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接受对`users/user`的POST请求。我们使用`monk`进行插入（将记录添加到我们的MongoDB数据库中）。插入函数的第一个参数是一个对象，我们使用`req.body`中的`firstName`、`lastName`和`email`字段来填充要插入的文档的相同属性。假设没有错误，我们将重定向到`users/show`，显示包括我们的新用户在内的用户列表。
- en: req.query
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`req.query`'
- en: Another way we can get data from a request is using the query string appended
    to a URL. If you are unfamiliar with this, the query string is data that is appended
    as name value pairs after a question mark on the URL.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种从请求中获取数据的方法是使用附加到URL的查询字符串。如果你不熟悉这个，查询字符串是在URL问号后附加的名称值对数据。
- en: For example, in `http:www.mymadeupdomain.org/foo?name=john+smith&q=foo`, the
    query string part is the `name=john+smith&q=foo`. To access this inside our `app`,
    we would use `req.query.name` and `req.query.q`. This would give us back `johnsmith` and
    `foo` respectively with no plus sign between `john` and `smith`. The plus sign
    is part of URL encoding that happens because spaces don't translate in URLs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`http:www.mymadeupdomain.org/foo?name=john+smith&q=foo`中，查询字符串部分是`name=john+smith&q=foo`。要在我们`app`内部访问它，我们会使用`req.query.name`和`req.query.q`。这将分别返回`johnsmith`和`foo`，在`john`和`smith`之间没有加号。加号是URL编码的一部分，因为空格在URL中无法翻译。
- en: If there is no query string, `req.query` will contain an empty object.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有查询字符串，`req.query`将包含一个空对象。
- en: Note
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**When should I use a query string instead of parameters?**'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**我应该何时使用查询字符串而不是参数？**'
- en: 'There''s no best answer for this. In general, you want to use route parameters
    when you want multiple routes to handle different types of operations. We''re
    going to take this approach most of the time. Query strings are good if you want
    a single `GET` request route that''s going to be flexible with the type of data
    it receives, and you want users to be able to bookmark it. Google uses query strings
    for searches: [https://www.google.com/search?q=things](https://www.google.com/search?q=things).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 没有最好的答案。一般来说，当你想要多个路由处理不同类型的操作时，你应该使用路由参数。我们大多数时候都会采取这种方法。如果你想要一个灵活地接收不同类型数据的单个`GET`请求路由，并且希望用户能够将其添加到书签中，查询字符串就很好。Google使用查询字符串进行搜索：[https://www.google.com/search?q=things](https://www.google.com/search?q=things)。
- en: req.cookies
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: req.cookies
- en: '`req.cookies` requires the use of the cookie parser middleware, conveniently
    already installed for us by the Express generator, and gives us access to the
    cookies in the request. If there are no cookies, the value of `req.cookies` will
    be an empty object.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`req.cookies`需要使用cookie解析器中间件，Express生成器已经为我们方便地安装了它，并使我们能够访问请求中的cookie。如果没有cookie，`req.cookies`的值将是一个空对象。'
- en: 'Cookies are accessed by name: `req.cookies.userID` would give us a cookie named
    `userID`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过名称访问cookie：`req.cookies.userID`将给我们一个名为`userID`的cookie。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will delve into cookies in more detail later, but the cookie parser is required
    for things such as authentication and security. It's best to leave it in place
    whether you are going to use cookies directly or not.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后更详细地探讨cookie，但cookie解析器对于诸如身份验证和安全等操作是必需的。如果你打算直接使用cookie，或者不使用cookie，最好都保留它。
- en: req.xhr
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: req.xhr
- en: This is a simple Boolean value that is `true` if the `X-Requested-With` request
    header is `XMLHttpRequest`. Most commonly, this happens with AJAX requests issued
    by libraries such as jQuery.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的布尔值，如果`X-Requested-With`请求头是`XMLHttpRequest`，则为`true`。这种情况通常发生在由jQuery等库发出的AJAX请求中。
- en: This is useful for SPAs because we may want to respond with an HTML page when
    the request comes from a change in location from the browser, but with data when
    subsequent requests come from client-side code issuing requests through AJAX.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于SPA很有用，因为我们可能希望在请求来自浏览器位置变化时响应HTML页面，但在随后的请求来自通过AJAX发出请求的客户端代码时响应数据。
- en: 'Let''s look at our `/show/:id` route from `/routes/users.js`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`/routes/users.js`中的`/show/:id`路由：
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So we check to see if the request has come in through `XMLHTTPRequest`, AJAX.
    If it has, we add the `appName` to the `User` object and then return it as JSON.
    If it didn't, we render and return the page as normal.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们检查请求是否通过`XMLHTTPRequest`，即AJAX发出。如果是，我们将`appName`添加到`User`对象中，然后将其作为JSON返回。如果不是，我们像平常一样渲染并返回页面。
- en: This is quite handy, and we'll use this mechanism later.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常方便，我们稍后会使用这个机制。
- en: req.accepts()
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: req.accepts()
- en: '`req.accepts` is a function which checks a request''s `Accept` header and returns
    `true` if there''s a match. It can accept a string or array or extensions or MIME
    types, and returns either the best match or `false` (`undefined`, which is a falsy
    value in JavaScript), if there''s nothing matching.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`req.accepts`是一个函数，它检查请求的`Accept`头，如果匹配则返回`true`。它可以接受字符串、数组、扩展名或MIME类型，如果没有匹配项，则返回最佳匹配或`false`（`undefined`，在JavaScript中为假值）。'
- en: 'For example, let''s say the browser sends back the header: `Accept:text/*`.
    `application/json`: `req.accepts(''html'')` would match the `text/*` part and
    return `html`. `req.accepts([''image/png'',''application/json''])` would return
    `json`.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设浏览器返回了以下头信息：`Accept:text/*`。`application/json`：`req.accepts('html')`将匹配`text/*`部分并返回`html`。`req.accepts(['image/png','application/json'])`将返回`json`。
- en: As with `req.xhr`, this can be very useful for responding flexibly to different
    types of requests on the same route.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与`req.xhr`类似，这对于灵活响应同一路由上的不同类型的请求非常有用。
- en: req.get()
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: req.get()
- en: '`req.get()` is a function that returns the value of an HTTP header sent in
    the request. The function takes a string which does case-insensitive matching.
    An alias of this function is `req.header()`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`req.get()`是一个函数，它返回请求中发送的HTTP头的值。该函数接受一个字符串，进行不区分大小写的匹配。此函数的别名是`req.header()`。'
- en: For example, `req.get('content-type')` returns the content type header from
    the HTTP request as a string, such as `application/json` or `text/html`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`req.get('content-type')`返回HTTP请求中的内容类型头，如字符串`application/json`或`text/html`。
- en: Response object
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应对象
- en: The Express response object is a JavaScript object that represents the response
    that we are going to send back from the server to the client. We see it paired
    with the request object and, like using `req` for request, the convention is to
    use `res`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Express响应对象是一个JavaScript对象，它代表我们将从服务器发送回客户端的响应。我们看到它与请求对象配对，并且像使用`req`进行请求一样，惯例是使用`res`。
- en: res.app
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: res.app
- en: The `res.app` object is identical to the `req.app` property. It's a reference
    to the application, but attached to the response object in this case. This offers
    some flexibility in accessing the app properties.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.app`对象与`req.app`属性相同。它是对应用的引用，但在此情况下附加到响应对象。这为访问应用属性提供了一些灵活性。'
- en: res.cookie()
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: res.cookie()
- en: This is a response object method that allows us to set a cookie and send it
    back with the response. It takes a name, value, and an optional object containing
    parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个响应对象方法，允许我们设置cookie并将其与响应一起发送。它接受一个名称、值和一个可选的包含参数的对象。
- en: 'Here''s an example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This sets a `userName` cookie with a value of `Joe`. The cookie expires 900,000
    seconds from the response. The cookie is to be used with HTTPS only, and it is
    to be signed. Other options that can be set are the domain and path for the cookie,
    and an actual expiration date.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置一个值为`Joe`的`userName`cookie。cookie在响应后的900,000秒后过期。cookie仅用于HTTPS，并且需要签名。还可以设置cookie的域和路径，以及实际的过期日期。
- en: 'This method clears the named cookie:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法清除指定的cookie：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This would clear the cookie we set previously:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将清除我们之前设置的cookie：
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: res.download()
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: res.download()
- en: '`res.download` transfers a file at a given path as an attachment. It takes
    the path, an optional filename, and an option callback function once the file
    transfer completes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.download`将给定路径的文件作为附件传输。它接受路径、可选的文件名和一个可选的回调函数，一旦文件传输完成：'
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We initiate a download of the file at `/reports/TPS-coversheet`, but transfer
    it as `coversheet.pdf`. Once complete, we check if there was an error, doing something
    appropriate in any case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始下载位于`/reports/TPS-coversheet`的文件，但将其传输为`coversheet.pdf`。一旦完成，我们检查是否有错误，并在任何情况下做适当的事情。
- en: res.json()
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: res.json()
- en: This method sends a JSON response, it's that straightforward. It can take any
    JavaScript object. The nice thing about using a MongoDB database is that often
    we can just pass out raw database responses using `res.json():`
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法发送JSON响应，非常直接。它可以接受任何JavaScript对象。使用MongoDB数据库的好处是，我们通常可以直接使用`res.json()`传递原始数据库响应：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we respond with JSON passing an object with properties for our `Sheltie`
    named `Fido` and the commands that she knows.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过传递一个包含名为`Fido`的`Sheltie`和它所知道的命令的对象来响应JSON。
- en: res.jsonp()
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: res.jsonp()
- en: 'This method returns JSON data wrapped in a callback function, otherwise known
    as JSONP. By default the function will be called callback. But this can be overridden
    using `app.set(''jsonpcallbackname'',''someFunction'');`. In this case, we get
    the following:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回被回调函数包裹的JSON数据，也称为JSONP。默认情况下，函数将被命名为callback。但可以通过使用`app.set('jsonpcallbackname','someFunction');`来覆盖它。在这种情况下，我们得到以下结果：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Of course, the appropriate client-side code would have to be in place to handle
    the response.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，必须放置适当的客户端代码来处理响应。
- en: res.redirect()
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: res.redirect()
- en: We've already used this one. This sends a redirect back to the requester with
    an appropriate HTTP status code. If no status code is specified, a `302` is used.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用过这个了。这会将带有适当HTTP状态码的重定向发送回请求者。如果没有指定状态码，则使用`302`。
- en: 'Here''s something we looked at earlier:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们之前查看的内容：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After an insert operation, adding a new document to our database, we send a
    redirect back to the browser to go to `/users/show`. Because no status was specified,
    a `302` will be returned.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入操作之后，将新文档添加到我们的数据库中，我们向浏览器发送一个重定向，使其跳转到 `/users/show`。因为没有指定状态，所以将返回一个 `302`
    状态码。
- en: 'The path is quite flexible and can be anything from a fully formed URL: `res.redirect(''https://www.google.com/search?q=food'');`
    to a relative path: `res.redirect(''../dashboard/show'');`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 路径非常灵活，可以是完整的 URL：`res.redirect('https://www.google.com/search?q=food');`，也可以是相对路径：`res.redirect('../dashboard/show');`。
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This sends a permanently moved redirect to `whitehouse.gov`, consequently confusing
    Google and ruining your SEO. For more information about various redirect codes,
    check out the official HTTP specification, paying attention to the `3xx` status
    codes: [http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发送一个永久重定向到 `whitehouse.gov`，从而混淆了 Google 并破坏了你的 SEO。有关各种重定向代码的更多信息，请查看官方 HTTP
    规范，注意 `3xx` 状态码：[http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。
- en: res.render()
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: res.render()
- en: This is another method we've already used, which sends back rendered HTML which
    has been compiled from a `view` template. The arguments to the method are the
    template view, an optional object containing local variables, and an optional
    callback function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们已经使用过的另一个方法，它发送回由 `view` 模板编译的渲染后的 HTML。该方法参数包括模板视图、包含本地变量的可选对象以及可选的回调函数。
- en: 'Let''s take a peek at our `/show` route inside our routes`/users.js` file:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下我们 `/show` 路径在 `routes/users.js` 文件中的内容：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we've seen, this call to `res.render()` renders the template at `/views/users/show`.
    It makes the local object with users and `appName` available to the template.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个对 `res.render()` 的调用渲染了 `/views/users/show` 路径下的模板。它使用户和 `appName`
    本地对象对模板可用。
- en: 'If we you add a callback method to the render method, you need to call `res.send()`
    explicitly:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在渲染方法中添加一个回调函数，则需要显式调用 `res.send()`：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we've added a callback function which has two arguments, an error, if
    any, and the rendered `html`. This allows us to add an error handler, set a cookie
    on the response object, and then send the response.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个具有两个参数的回调函数，一个错误（如果有），以及渲染后的 `html`。这允许我们添加错误处理程序，在响应对象上设置一个 cookie，然后发送响应。
- en: res.send()
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: res.send()
- en: We've seen that `res.send()` is a method that is used to send the HTTP response.
    `res.send()` is pretty flexible and can give a number of different types of arguments,
    including a `Buffer`, an object, array, or a string.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 `res.send()` 是一个用于发送 HTTP 响应的方法。`res.send()` 非常灵活，可以接受多种类型的参数，包括 `Buffer`、对象、数组或字符串。
- en: '`res.send()` will adjust the HTTP `Content-Type` header appropriately for the
    argument. When the argument is a string the `Content-Type` will be `text/html`,
    when an object or array it will be `application/json`, and when it''s a `Buffer`
    object it will be set to `application/octet-stream`. These defaults can be overridden
    by calling `res.set()` with a different `Content-Type`.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.send()` 会根据参数适当地调整 HTTP `Content-Type` 头。当参数是一个字符串时，`Content-Type` 将是
    `text/html`，当是一个对象或数组时，将是 `application/json`，而当它是一个 `Buffer` 对象时，将被设置为 `application/octet-stream`。这些默认值可以通过调用
    `res.set()` 并传入不同的 `Content-Type` 来覆盖。'
- en: 'We can also chain a call to `status()` to pass an HTTP status:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以链式调用 `status()` 来传递一个 HTTP 状态码：
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By chaining the status with a `500` HTTP status, we can send a message that
    there's been an internal server error along with our message.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将状态与 `500` HTTP 状态码链式调用，我们可以发送一条消息，表明发生了内部服务器错误，并附带我们的消息。
- en: Router object
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由对象
- en: The router object is described in the Express documentation as a `mini-application`
    that only provides middleware and routing functionality. The router acts as middleware
    so it can be used as an argument in `app.use()` or in another router's `use()`
    method, making nesting and organizing routes easy.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 路由对象在 Express 文档中被描述为一个仅提供中间件和路由功能的 `mini-application`。路由器作为中间件使用，因此可以作为 `app.use()`
    或另一个路由器的 `use()` 方法的参数，这使得嵌套和组织路由变得容易。
- en: 'We create a router object by calling the `express.Router()` function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用 `express.Router()` 函数来创建一个路由对象：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In our router files, we always export the router using `module.exports=router`.
    This allows us to load the router as a module through `require()` and then use
    it like any other middleware.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的路由文件中，我们总是使用 `module.exports=router` 来导出路由。这允许我们通过 `require()` 加载路由作为模块，然后像使用任何其他中间件一样使用它。
- en: 'Let''s review our `app.js` file again:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次审查一下 `app.js` 文件：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We require the index route, assigning it to the variable routes, and then we
    require the users route, assigning it to the variable users. Then we add the routes
    to the `app` using the `app.use` function, matching the root path and the `/users`
    path.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要索引路由，将其分配给变量`routes`，然后我们需要用户路由，将其分配给变量`users`。接着，我们使用`app.use`函数将路由添加到`app`中，匹配根路径和`/users`路径。
- en: Note that Express will try to match routes in order. Since every route will
    match the root path, it will look there first, and if it finds no match to anything
    starting with `/users`, Express will then match to the next route. Inside our
    `/users` route, we know we have a route for show, so `/users/show` will be matched
    there.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Express会按顺序尝试匹配路由。由于每个路由都会匹配根路径，它会首先查找那里，如果找不到以`/users`开头的匹配项，Express会接着匹配下一个路由。在我们的`/users`路由中，我们知道我们有一个show路由，所以`/users/show`会被匹配到那里。
- en: router.METHOD()
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`router.METHOD()`'
- en: 'This works the same exact way as `app.METHOD()`. We add lowercase HTTP verbs
    as functions, passing in a route to match and a callback function. We''ve seen
    this pattern already:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`app.METHOD()`的工作方式完全相同。我们添加小写的HTTP动词作为函数，传递一个匹配的路由和一个回调函数。我们已经看到这个模式了：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'One thing to note here is that `res.send()`, `res.render()`, and `res.end()`
    will all terminate the response. This means that whatever is in `next()` will
    not be called. Think of it as returning out of a JavaScript function. There''s
    no more you can do after that. However, you can call multiple routes in succession
    by not terminating:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，`res.send()`、`res.render()`和`res.end()`都会终止响应。这意味着`next()`中的任何内容都不会被调用。把它想象成从JavaScript函数中返回。在那之后就没有更多的事情可以做了。然而，你可以通过不终止来连续调用多个路由：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Both routes match `/something`, so the first one would get called, and it adds
    `foo` to the locals property on the response object. Then it makes a call to next
    which calls the next matching route, sending the value of `res.locals,foo`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这两条路由都匹配`/something`，所以第一条会被调用，并将`foo`添加到响应对象的`locals`属性中。然后它调用`next`，调用下一个匹配的路由，发送`res.locals,foo`的值。
- en: router.all()
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`router.all()`'
- en: '`router.all()` works like `router.METHOD()` except that it matches all HTTP
    verbs, get, post, and so on. It''s incredibly useful for adding `global` functionality
    to a series of routes. For example, let''s say that you have an `api` route and
    want to make sure that every call to any route in `api` is authenticated:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`router.all()`的工作方式类似于`router.METHOD()`，除了它匹配所有HTTP动词，如get、post等。这对于向一系列路由添加`全局`功能非常有用。例如，假设你有一个`api`路由，并确保对`api`中任何路由的每次调用都是经过认证的：'
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Placing this at the top of your routes file would make all calls to any URL
    starting with `/api/` to go through the `someAuthenticationMiddleware` middleware.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将此放在路由文件的最顶部，会使所有以`/api/`开头的URL调用都通过`someAuthenticationMiddleware`中间件。
- en: router.param()
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`router.param()`'
- en: '`router.param()` is a powerful way to add callback functionality based on route
    parameters. Let''s say, for example, that in our `users` route file, every time
    we get an `id` parameter.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`router.param()`是一种强大的方式，可以根据路由参数添加回调功能。例如，假设在我们的`users`路由文件中，每次我们获取一个`id`参数。'
- en: 'Let''s dive back into our `routes/users.js` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次深入到我们的`routes/users.js`文件：
- en: '[PRE28]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use `router.param()` to look for calls to any route that has an `id` parameter.
    The callback function does a database lookup on user. If there's an error, we
    terminate by sending the error. The user, if one is found, is added to the request
    object. We then call `next()` to pass the request to the matching route.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`router.param()`来查找任何具有`id`参数的路由调用。回调函数在用户上进行数据库查找。如果有错误，我们通过发送错误来终止。如果找到了用户，将其添加到请求对象中。然后我们调用`next()`来传递请求到匹配的路由。
- en: Writing our own middleware
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们自己的中间件
- en: As we've seen, Express is designed to rely heavily on pluggable middleware for
    adding functionality to our application. Let's roll our own piece of middleware
    that will give us an easy way to switch our responses to JSON format anywhere
    in our `app`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Express被设计为高度依赖可插拔的中间件来为我们的应用程序添加功能。让我们自己编写一段中间件，这样我们就可以轻松地在`app`的任何地方切换响应到JSON格式。
- en: 'Add a `utils` directory to your `giftapp` project folder and create a file
    called `json.js` inside that folder:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`giftapp`项目文件夹中添加一个`utils`目录，并在该目录中创建一个名为`json.js`的文件：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `isJSON` function we create takes the three arguments that all Express middleware
    accepts - the request object, the response object, and the reference to next.
    We check to see if the request object's `xhr` value is `true` or if the accepts
    header on the request is `application/json`. If either condition is true, we can
    assume that the client is requesting `JSON` rather than `HTML`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`isJSON`函数接受所有Express中间件接受的三个参数 - 请求对象、响应对象和指向下一个的引用。我们检查请求对象的`xhr`值是否为`true`，或者请求的`accepts`头是否为`application/json`。如果任一条件为真，我们可以假设客户端正在请求`JSON`而不是`HTML`。
- en: We add an `isJSON` property to the request object, setting it to `true`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在请求对象中添加一个`isJSON`属性，将其设置为`true`。
- en: 'Now, let''s modify our `app.js` file to include this middleware anywhere in
    the application where we need it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改我们的`app.js`文件，在应用程序需要的地方包含这个中间件：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, we require in our module, assigning it to the variable `isJSON`. Note
    that we need to use an explicit path here. If we simply used a module name, Node
    will try to look for it in the `node_modules` directory.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在模块中引入，将其分配给变量`isJSON`。注意，在这里我们需要使用一个明确的路径。如果我们仅仅使用一个模块名称，Node将尝试在`node_modules`目录中查找它。
- en: 'Then we add our middleware to the application using `app.use(isJSON)`. Where
    we place this in the file is important as middleware is called sequentially. In
    our case, this can be anywhere as long as it appears before the routes that use
    it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`app.use(isJSON)`将我们的中间件添加到应用程序中。我们在文件中的位置很重要，因为中间件是按顺序调用的。在我们的情况下，它可以在任何地方，只要它出现在使用它的路由之前：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We modify our two routes to conditionally send JSON or HTML depending on our
    new `isJSON` flag. Restarting your server and then browsing to either route should
    show no difference, since you're not actually requesting JSON.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了我们的两个路由，根据新的`isJSON`标志有条件地发送JSON或HTML。重启服务器然后浏览任一路由应该没有区别，因为你实际上并没有请求JSON。
- en: If you'd like to test this, you can use a browser plugin such as `Postman` or
    a terminal request such as `curl` to issue an `xhr` request and see the data come
    back as `JSON`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试这个功能，你可以使用浏览器插件如`Postman`或终端请求如`curl`来发出一个`xhr`请求，并查看数据以`JSON`格式返回。
- en: Developing a RESTful API
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发RESTful API
- en: Let's do a little more work setting up our SPA by building out some resourceful
    routing as part of a RESTFul API that we can connect later to our database and
    our client-side code. We're lucky that Express has such a vibrant community of
    developers building many add-ons, and we're going to use one for resourceful routing.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建一些资源路由作为RESTful API的一部分来进一步设置我们的SPA，这样我们就可以稍后将其连接到数据库和客户端代码。我们很幸运，Express有一个充满活力的开发者社区，他们构建了许多附加组件，我们将使用其中一个用于资源路由。
- en: Installing resourceful routing
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装资源路由
- en: 'The first thing we need to do is to install our module, which will provide
    us with some resourceful routing:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是安装我们的模块，它将为我们提供一些资源路由：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This installs the resourceful routing plugin we're going to use, and saves a
    reference to the `package.json` file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这安装了我们将要使用的资源路由插件，并保存了对`package.json`文件的引用。
- en: 'Next, we need to do some setup in our `app.js` file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的`app.js`文件中进行一些设置：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We pull in the resource routing module using `require()` and assign it to the
    variable `routing`. Then we create a shortcut variable to a controllers directory,
    which we will be building next.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`require()`引入资源路由模块，并将其分配给变量`routing`。然后我们创建一个指向控制器目录的快捷变量，这是我们接下来要构建的。
- en: We add the following code, `routing.expose_routing_table(app,{at:""/my-routes""});`
    which allows us to view our routing table at the URL `my-routes`. Obviously, this
    is not something we'd leave intact in production, but it's a useful debugging
    tool.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加以下代码，`routing.expose_routing_table(app,{at:"/my-routes"});`，这允许我们在`my-routes`
    URL查看我们的路由表。显然，这不是我们会在生产环境中保留的东西，但它是一个有用的调试工具。
- en: Finally, we set up our resourceful routing for `giftlists` with `routing.resources(app,controllers,""giftlist"");`.
    This won't do anything yet because we haven't set up our controller.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`routing.resources(app,controllers,"giftlist");`为`giftlists`设置我们的资源路由。目前这不会做任何事情，因为我们还没有设置我们的控制器。
- en: Building out giftlist controller
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建礼品清单控制器
- en: 'By default, our resourceful router will build a number of standard restful
    routes for us, including:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们的资源路由器会为我们构建一系列标准的RESTful路由，包括：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, these routes provide use with basic CRUD (create, read, update,
    delete) functionality.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些路由为我们提供了基本的CRUD（创建、读取、更新、删除）功能。
- en: 'However, these routes will only be created if the controller and routes actually
    exist, so we need to build them. Create a controllers directory in your `giftapp`
    folder with a file called `giftlist_controller.js`. Our plugin will add the `_controller` part
    when it goes to load our controller, so be sure to name it correctly. For now,
    we are going to stub out our routes to make sure they are working:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有当控制器和路由实际存在时，这些路由才会被创建，因此我们需要构建它们。在你的 `giftapp` 文件夹中创建一个名为 `giftlist_controller.js`
    的控制器目录。我们的插件在加载我们的控制器时会添加 `_controller` 部分，所以请确保命名正确。现在，我们将模拟我们的路由以确保它们正常工作：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, each of our route handlers is a function that receives the request
    and response objects.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的每个路由处理程序都是一个接收请求和响应对象的函数。
- en: 'Restart your server and navigate to `localhost:3000/giftlist/17`, where you
    should see:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动你的服务器并导航到 `localhost:3000/giftlist/17`，你应该会看到：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Responding with different data formats
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以不同的数据格式响应
- en: 'Our resourceful routes can also support different data formats, so let''s stub
    those out as well, and we''ll also use our `isJSON` property in our `giftlist_controller.js`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的资源路由也可以支持不同的数据格式，所以让我们也模拟这些，我们还会在我们的 `giftlist_controller.js` 中使用我们的 `isJSON`
    属性：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we added tests to each of our routes to see if the client is requesting
    `JSON` data. If they are, we return `JSON`. Otherwise, we return `HTML`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为每个路由添加了测试，以查看客户端是否请求 `JSON` 数据。如果是，我们返回 `JSON`。否则，我们返回 `HTML`。
- en: We check to see if the client is expecting `JSON` in two ways.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过两种方式检查客户端是否期望 `JSON` 格式。
- en: First, we look to see if the `req.params.format` is `json`. Using this resourceful
    routing middleware, appending a .:format to the URL adds that format to the `req.params`
    object as the value of the format. In other words, entering the URL `localhost:3000/giftlist.json`
    triggers the `giftlist_controller.index` route, setting the format parameter to
    `json`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们查看 `req.params.format` 是否为 `json`。使用这种资源路由中间件，在 URL 后添加 `.:format` 将该格式添加到
    `req.params` 对象中作为格式值。换句话说，输入 URL `localhost:3000/giftlist.json` 会触发 `giftlist_controller.index`
    路由，将格式参数设置为 `json`。
- en: The second method is to rely on the `req.isJSON` parameter set by our middleware.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是依赖于我们中间件设置的 `req.isJSON` 参数。
- en: In the next chapter, we will connect these resourceful routes to CRUD operations
    on our database, and start to render data to a page as we flesh out our SPA.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将将这些资源路由连接到我们数据库上的 CRUD 操作，并开始将数据渲染到页面上，以完善我们的 SPA。
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at Express, a Node.js web application framework,
    in greater detail. You learned that Express is an extremely flexible and unopinionated
    web framework built on top of Node.js HTTP services.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更详细地探讨了 Express，这是一个基于 Node.js HTTP 服务的 Node.js 网络应用程序框架。你了解到 Express
    是一个在 Node.js HTTP 服务之上构建的极其灵活且无偏见的网络框架。
- en: At its core, Express provides access to a request, response, application, and
    router objects. Using these objects, we can manipulate web requests and respond
    in a sophisticated manner.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Express 提供了对请求、响应、应用程序和路由对象的访问。使用这些对象，我们可以以复杂的方式操纵网络请求并做出响应。
- en: Using Express predominantly means writing or using middleware plugins, through
    which requests flow. We learned to use these plugins, and we wrote some utility
    middleware of our own. We examined routing in detail, and used a resourceful routing
    plugin to start to build a RESTful API for our SPA. We made the API flexible,
    capable of responding with either `JSON` or `HTML` data depending on the request.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 主要使用 Express 意味着编写或使用中间件插件，请求通过这些插件流动。我们学习了如何使用这些插件，并编写了一些我们自己的实用中间件。我们详细研究了路由，并使用了一个资源路由插件来开始为我们的
    SPA 构建RESTful API。我们使API变得灵活，能够根据请求以 `JSON` 或 `HTML` 数据格式进行响应。
- en: The next chapter will cover the frontend. Specifically, you will be learning
    about view templates, as well as AngularJS.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖前端。具体来说，你将学习关于视图模板以及 AngularJS 的内容。
