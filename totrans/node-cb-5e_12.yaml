- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The asynchronous nature of JavaScript and Node.js can make the debugging process
    non-trivial. Unlike traditional synchronous code execution, the asynchronous behavior
    of Node.js introduces complexities that can challenge even experienced developers.
    However, over the past decade, Node.js has matured significantly as a technology.
    Along with this maturation, the debugging capabilities and facilities have improved
    in tandem, providing developers with more robust tools and methodologies to troubleshoot
    their applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the various steps we can take to make our applications
    easier to debug. By implementing best practices and adopting a structured approach
    to coding, we can mitigate some of the inherent difficulties associated with asynchronous
    programming. We will also delve into the modern tools available for debugging
    Node.js applications, such as the built-in debugger, various third-party debugging
    tools, and advanced logging techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will cover how to leverage Node.js’s diagnostic reports feature,
    a powerful utility introduced in the latest versions of Node.js. This feature
    provides in-depth insights into the state of your application at the time of failure,
    making it easier to pinpoint the root causes of issues. By the end of this chapter,
    you will have a comprehensive understanding of the strategies and tools necessary
    to effectively debug Node.js applications, ensuring smoother development and more
    stable production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing issues with Chrome DevTools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging with Node.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling debug logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling Node.js core debug logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing stack trace size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating diagnostic reports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you will require Node.js 22 to be installed and available
    in your terminal path. You can test which version of Node.js is installed and
    available in your path with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You’ll also need access to an editor and browser. For the *Diagnosing issues
    with Chrome DevTools* recipe, you will need to have Google Chrome installed, which
    you can download from [https://www.google.com/chrome/](https://www.google.com/chrome/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Diagnosing issues with Chrome DevTools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js offers a powerful debugging utility through the **--inspect** process
    flag, enabling us to debug and profile our Node.js processes using the Chrome
    DevTools interface. This integration is made possible by the Chrome DevTools Protocol,
    which facilitates communication between Node.js and Chrome DevTools. The existence
    of this protocol allows for the creation of tools that seamlessly integrate with
    Chrome DevTools, providing a unified debugging experience across different environments.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to utilize Chrome DevTools to diagnose and
    resolve issues within a web application. We’ll cover how to set up the debugging
    environment, connect to a Node.js process, and navigate the various features of
    Chrome DevTools. This includes inspecting variables, setting breakpoints, and
    stepping through our code.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**node --debug** and **node --debug-brk** are legacy Node.js flags that have
    been deprecated since Node.js v6.3.0. **node --inspect** and **node --inspect-brk**
    are the modern equivalents that should be used in place of these legacy flags.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will debug a minimal web server built with Express. Let’s
    prepare this before we start the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s set up a directory and the files required for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following source code to **server.js** to create our web server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following source code to **random.js** . This will be a local module
    we interact with via our server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have an application ready to debug, we can move on to the recipe
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’re going to use Chrome DevTools ( [https://developer.chrome.com/docs/devtools](https://developer.chrome.com/docs/devtools)
    ) to debug a route in our application. We expect the application to respond with
    a random number between **0** and the number we specify in the route. For example,
    **http://localhost:3000/10** should return a random number between **1** and **10**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the program with **$ node server.js** and navigate to **http://localhost:3000/10**
    . Refresh the endpoint a few times and you should notice that the program will
    often respond with a number greater than **10** . This indicates that we have
    a bug in our program; so, let’s debug to try and understand why this error is
    occurring:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to start our program with the debugger enabled. To do this,
    we need to pass the **--inspect** argument to our Node.js process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead of going directly to the link specified in the output, navigate to
    **chrome://inspect/#devices** in Google Chrome. Expect to see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Screenshot of the Google Chrome inspector Devices interface](img/Figure_12.1_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Screenshot of the Google Chrome inspector Devices interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Observe that **server.js** is showing up as **Remote Target** . Click the **inspect**
    link and the Chrome DevTools window should open, as shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Screenshot of the Chrome DevTools interface](img/Figure_12.2_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Screenshot of the Chrome DevTools interface
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **server.js** in the bottom-right corner of the window. This should
    ensure our **server.js** file is open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Screenshot of the Chrome DevTools interface depicting the server.js
    file](img/Figure_12.3_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Screenshot of the Chrome DevTools interface depicting the server.js
    file
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add a breakpoint. Click the number **7** in the line-of-code column
    to the left of our code. A small red circle should appear next to the number.
    If you click **Show Debugger** in the top-right corner, you should see the breakpoint
    listed in the **Breakpoints** pane. The Chrome DevTools interface should look
    like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Screenshot of Chrome DevTools showing a breakpoint registered
    in the server.js file](img/Figure_12.4_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Screenshot of Chrome DevTools showing a breakpoint registered
    in the server.js file
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s open a new regular browser window and navigate to **http://localhost:3000/10**
    . The request will hang because it has hit the breakpoint we registered on *line
    7* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to Chrome DevTools. You should notice that there is a tooltip stating
    **Paused on breakpoint** in the top-right corner of the interface. Also, to the
    right of the interface, you should see a **Call Stack** panel, which details the
    call frames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Screenshot of the Chrome DevTools interface showing as Paused
    on breakpoint](img/Figure_12.5_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Screenshot of the Chrome DevTools interface showing as Paused
    on breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: 'The debugger is waiting for us to act. We can choose to step in or out of the
    next instruction. Let’s step into the function. To do this, click the icon of
    an arrow pointing down to a circle (these icons are right above the **Paused on
    breakpoint** message). When you hover over each icon, a tooltip will appear describing
    the icon’s behavior. Once you have stepped in, you will see that we have moved
    into our **random.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Screenshot of the Chrome DevTools interface showing the random.js
    file](img/Figure_12.6_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Screenshot of the Chrome DevTools interface showing the random.js
    file
  prefs: []
  type: TYPE_NORMAL
- en: While we’re in **random.js** , we can hover over the values to check whether
    they are what we expect them to be. We can see that **n = 10** , as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Step over the function (by clicking the semi-circular arrow with a dot underneath)
    and then inspect the value of **randomNumber** . In the screenshot, the random
    number generated is **11** , which is greater than **10** . This helps us determine
    that the error is in our **randomNumber** logic of the previous line. Now that
    we have identified the line the error is on, it is easier to locate the error.
    Observe that we are adding the string **''1''** rather than the number **1** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Screenshot of the Chrome DevTools interface showing variable
    values on hover](img/Figure_12.7_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Screenshot of the Chrome DevTools interface showing variable values
    on hover
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how to pause and step through code using Chrome DevTools. We
    have also learned that we can inspect variable values.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ability to debug Node.js applications is provided by the V8 JavaScript engine.
    When we pass the node process the **--inspect** argument, the Node.js process
    starts to listen for a debugging client. Specifically, it is the V8 inspector
    that opens a port that accepts WebSocket connections. The WebSocket connection
    allows the client and the V8 inspector to interact.
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the Chrome DevTools window, you will see a URI that starts with
    **devtools://** . This is a protocol that is recognized by the Google Chrome browser
    and instructs Google Chrome to open the Chrome DevTools user interface.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we set a breakpoint in the Chrome DevTools window. When the line
    of code the breakpoint is registered on is encountered, the event loop (JavaScript
    thread) will be paused. The V8 inspector will then send a message to the client
    over the WebSocket connection. The message from the V8 inspector details the position
    and state of the program. The client can update its state based on the information
    it receives.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if the user chooses to step into a function, a command is sent to
    the V8 inspector to instruct it to temporarily resume the execution of the script,
    pausing it again afterward. As before, the V8 inspector sends a message back to
    the client detailing the new position and state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Node.js also provides a flag that we can use to pause an application on start.
    This feature enables us to set up breakpoints before anything executes. It can
    also help when debugging an error that occurs during the setup phase of your application.
    This feature can be enabled with the **--inspect-brk** flag. The following is
    how we’d start **server.js** using the **--inspect-brk** flag: **$ node --** **inspect-brk
    server.js** .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js provides a command-line inspector, which can be valuable when we do
    not have access to a graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging with the command-line inspector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can run the application from the recipe using the command-line-based debugger
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will enter us into debug mode and output the first three lines
    of **server.js** :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The terminal window depicting the Node.js inspector utility](img/Figure_12.8_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – The terminal window depicting the Node.js inspector utility
  prefs: []
  type: TYPE_NORMAL
- en: When using **node inspect** , the program pauses at the first line to allow
    you to set breakpoints and configure the debugger before any code executes.
  prefs: []
  type: TYPE_NORMAL
- en: Debug mode provides a series of commands and functions that we can use to step
    through and debug our program. You can output the complete list of these commands
    by typing **help** and hitting *Enter* .
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the functions is the **list()** function, which will list a specified
    number of the following lines. For example, we can type **list(11)** to output
    all twelve lines of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the **setBreakpoint()** function to set a breakpoint. We must supply
    this function with the line number on which we wish to set the breakpoint. There’s
    also a shorthand for this function: **sb()** .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s set a breakpoint on *line 7* by typing **setBreakpoint(7)** or **sb(7)**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The caret ( **>** ) indicates that a breakpoint has been set on *line 7* .
  prefs: []
  type: TYPE_NORMAL
- en: 'The program is still paused. We can instruct the process to begin running by
    typing the continue command, **cont** . This also has a shorthand command, **c**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'After entering the **cont** command, our program will start to run. Our breakpoint
    is within our request handler function. Let’s send a request using **cURL** in
    a new terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The command will hang, as it has hit our breakpoint on *line 7* of **server.js**
    . If we go back to the debug session, we will see the debugger has detected that
    a breakpoint has been reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to step into the function, we type the **step** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This goes into the **random.js** file. Note that the command-line debug utility
    provides an interface similar to Chrome DevTools, just without a graphical user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can print out references in the current scope using the **exec** command.
    Type **exec n** to output the value of **n** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can progress to the next line using the **next** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can output the value of **randomNumber** , which will help us identify where
    the faulty logic is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, step out using the **out** command. This will take us back to our **server.js**
    file, but now paused on the **toString()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When you reach a breakpoint or pause execution in a function and wish to skip
    the remainder of the function’s execution to return to the caller, you can use
    the **out** command. To exit the debugger, you can type **.exit** or enter *Ctrl*
    + *C* twice.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now learned how to step through our code and output reference values using
    the command-line debugger.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging TypeScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With TypeScript, the code that runs in the browser is compiled JavaScript, which
    can make debugging difficult. Source maps solve this problem by mapping the compiled
    code back to your original TypeScript code, allowing you to debug more effectively
    with Chrome DevTools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Source maps are files that map your compiled JavaScript code back to the original
    TypeScript code. This allows you to debug the original TypeScript code directly
    in Chrome DevTools, making it easier to set breakpoints and understand errors.
    To enable source maps in TypeScript, you need to enable them in the **tsconfig.json**
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Setting **sourceMap** to **true** instructs the TypeScript compiler to generate
    source maps for your compiled JavaScript files.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have enabled source maps and compiled your TypeScript code, you can
    use Chrome DevTools to take advantage of them. With source maps enabled, your
    original TypeScript files will be listed, and you can open these files and set
    breakpoints directly in the TypeScript code. When you hit a breakpoint or encounter
    an error, Chrome DevTools will show the corresponding line in your original TypeScript
    code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Logging with Node.js* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling debug logs* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Logging** is a crucial tool for understanding the inner workings of an application.
    By strategically placing log statements throughout your code, you can gain valuable
    insights into the behavior and state of your application at various points in
    its execution. This is particularly useful when diagnosing issues, as logs can
    provide a retrospective view of what was happening just before a crash or failure
    – helping you identify the root cause more efficiently.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond troubleshooting, logging serves multiple purposes. For instance, you
    can use logs to collect and analyze data about your application’s usage patterns.
    By logging every access to the endpoints of your web application, you can aggregate
    these logs to identify the most frequently visited endpoints. This information
    can help you optimize performance, improve user experience, and make informed
    decisions about future development priorities.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will delve into logging with **Pino** ( [https://www.npmjs.com/package/pino](https://www.npmjs.com/package/pino)
    ), a high-performance JSON-based logger that is both fast and lightweight. Pino
    is particularly well suited for Node.js applications, offering a streamlined way
    to produce structured logs that are easy to parse and analyze. We will cover how
    to set up Pino, integrate it into your application, and use it to generate meaningful
    logs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate logging with Pino, we’ll create a server with Express.js:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new directory named **logging-with-pino** , initialize our
    project, and then install the **express** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll create a few files that we’ll use to demonstrate some basic Pino logging
    features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will look at how we can add Pino logging to our Express.js server.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will make use of the **logging-with-pino** module to demonstrate
    logging with Pino:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start by installing the **pino** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To start, we will add some basic logging to our **log.js** file to demonstrate
    the usage of Pino. In **log.js** , first import Pino and initialize the logger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With Pino initialized, we can start logging messages. Pino supports many different
    log levels, including **info** , **warn** , **error** , and **debug** . Let’s
    add one of each of these log messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run this in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that we only see three of the four messages. This is because Pino’s
    default log level is **info** . This means that messages logged with debug will
    not appear unless you change the log level to **debug** or **lower** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s adjust the configuration of our Pino logger. We’ll set the log level
    to **debug** so that we can see all messages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in your terminal, rerun the **log.js** program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s make the output look more readable. To do this, we can use **pino-pretty**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let’s learn how to log to a file with Pino. For this, we’ll work within
    **logToFile.js** . Add the following to configure Pino to use a stream to write
    to a file named **app.log** . We’ll also add a single message so we can see the
    file is being written to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Back in your terminal, run the **logToFile.js** program, and once completed,
    you should be able to see the message that has been written to the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s demonstrate Pino’s log redaction: Pino allows you to redact
    sensitive information from your logs to protect sensitive data. You can specify
    the paths of the properties to redact. Add the following to **r** **edactLog.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the **redactLog.js** file. We expect to see the password and IP values
    we specified redacted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now demonstrated some key features of Pino logging.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pino** is a highly performant and low-overhead logging library for Node.js,
    designed to be minimalistic and fast, making it suitable for high-throughput applications.
    It outputs logs in a JSON format by default, which facilitates easy parsing and
    compatibility with log processing systems. This structured format includes essential
    details, such as timestamps, log levels, and the message content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe, we began with the integration of the Pino module, which is accomplished
    by installing and then importing it into the application. Once Pino is integrated,
    a logger instance is instantiated. This instance serves as the central mechanism
    through which all logging activities are conducted. Using this logger, developers
    can generate logs at various severity levels. Each level allows the logger to
    categorize messages by their importance, aiding in the quick identification and
    troubleshooting of issues based on their severity. The possible log levels are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fatal**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**error**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**warn**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**info**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**debug**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**trace**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pino can be integrated into various web frameworks using middleware, enhancing
    logging capabilities with minimal effort. The **express-pino-logger** middleware,
    for example, adds a log object to every incoming request in an Express.js application.
    This log object is accessible via a property named **log** on the request object
    ( **req.log** ). Each log object is unique per request and contains data about
    the request, including a unique identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example demonstrates how Pino can be integrated into an Express.js
    application to provide JSON logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to Express.js, Pino can be integrated with other popular web frameworks
    through various middlewares and plugins provided by the Pino GitHub organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**express-pino-logger** : Express.js middleware for Pino, as used in the prior
    example ( [https://github.com/pinojs/express-pino-logger](https://github.com/pinojs/express-pino-logger)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**hapi-pino** : A Hapi plugin for Pino ( [https://github.com/pinojs/hapi-pino](https://github.com/pinojs/hapi-pino)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**koa-pino** : A Koa.js middleware for Pino ( [https://github.com/pinojs/koa-pino-logger](https://github.com/pinojs/koa-pino-logger)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**restify** : A Restify middleware for Pino ( [https://github.com/pinojs/restify-pino-logger](https://github.com/pinojs/restify-pino-logger)
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Furthermore, Pino’s logging capability is built into the **Fastify** web framework,
    requiring only that logging be enabled with a simple configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Consuming Node.js modules* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling debug logs* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling debug logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**debug** is a popular library, used by many popular frameworks, including
    the Express.js web framework and the Mocha test framework. **debug** is a small
    JavaScript debugging utility based on the debugging technique used in Node.js
    runtime itself. It offers a straightforward and flexible way to manage debug logs,
    allowing you to enable or disable debugging dynamically, without altering your
    application code. By using **debug** , you can selectively control logging for
    different parts of your application, making it easier to diagnose issues and understand
    application flow.'
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we’ll discover how to enable debug logs on an Express.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll create an Express.js web application that we can enable debug logs on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory and initialize our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll create a single file named **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have an application, we’re ready to enable debug logs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will be enabling debug logs on our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To turn on debug logging, start your server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following color-coded output in your terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Screenshot of a terminal window depicting debug logs for the
    web server](img/Figure_12.9_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Screenshot of a terminal window depicting debug logs for the web
    server
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **http://localhost:3000** in your browser to send a request to
    our server. You should see that the log messages describing your request have
    been output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Stop your server using *Ctrl* + *C* .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can also filter which debug logs are output. We’ll filter it to just
    see the Express.js router actions. To do this, restart your server with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following output in your terminal window. Observe that only
    Express.js router actions are output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Screenshot of a terminal window depicting filtered debug logs
    for the web server](img/Figure_12.10_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Screenshot of a terminal window depicting filtered debug logs
    for the web server
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to instrument your code with the **debug** module. We can do
    that by extending our program. Start by copying the **server.js** file used in
    the recipe to a new file and install the **debug** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change **debug-server.js** to the following. We have imported the **debug**
    module on *line 3* , and added a **debug** call on *line 6* :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start your application with the following command, and then navigate to **http://localhost:3000**
    . Expect to see our **HTTP GET request to /** log message in your terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that our log message has **my-server** prepended to it. This is the namespace
    for our log messages, which we declared when we created our debug logging function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ve now learned how to enable debug logs on our application. We’ve also learned
    how to filter the logs.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We first prepend **DEBUG=*** to our start command. This syntax passes an environment
    variable named **DEBUG** to our Node.js process, which can be accessed from within
    the application via **process.env.DEBUG** .
  prefs: []
  type: TYPE_NORMAL
- en: We set the value to ***** , which enables all logs. Later, we filter out logs
    by setting **DEBUG=express:router*** . Internally, the **debug** module converts
    the values we set to regular expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Express.js uses the **debug** module internally to instrument its code.
  prefs: []
  type: TYPE_NORMAL
- en: The default debug configuration is not suitable for logging in production. The
    default debug logs are intended to be human-readable, hence the color coding.
    When in production, you should pass your process the **DEBUG_COLORS=no** value
    to remove the ANSI codes that implement the color coding. This will make the output
    more easily machine-readable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Consuming Node.js modules* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Logging with Node.js* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling Node.js core debug logs* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling Node.js core debug logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When debugging some problems in your applications, it can be useful to have
    insight into the internals of Node.js and how it handles the execution of your
    program. Node.js provides debug logs that we can enable to help us understand
    what is happening internally in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: These core debug logs can be enabled via an environment variable named **NODE_DEBUG**
    . In the recipe, we’re going to set the **NODE_DEBUG** environment variable to
    allow us to log internal Node.js behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll need to create an application on which we can enable Node.js core debug
    logs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create a simple Express.js-based server with one route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have an application ready, we can enable the core debug logs to
    allow us to see what is happening at the Node.js runtime level.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will be enabling Node.js core debug logs on an application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We just need to set the **NODE_DEBUG** variable to the internal flag we wish
    to log. The internal flags align with specific subsystems of Node.js, such as
    timers or HTTP. To enable the “timer” core debug logs, start your server with
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Observe the additional log output from our program. We can see additional information
    about our **setInterval()** function, which is executed every 3,000 ms:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Screenshot of a terminal window depicting Node.js core timer
    debug messages](img/Figure_12.11_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Screenshot of a terminal window depicting Node.js core timer
    debug messages
  prefs: []
  type: TYPE_NORMAL
- en: The preceding **TIMER** log statements are additional debug information that
    derives from the internal implementation of timers in Node.js core, which can
    be found at [https://github.com/nodejs/node/blob/master/lib/internal/timers.js](https://github.com/nodejs/node/blob/master/lib/internal/timers.js)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now enable core debug logs for the **http** module. Restart your server
    with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to **http://localhost:3000** in a browser. You should expect to see
    internal logs about your HTTP request output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Screenshot of a terminal window depicting Node.js core HTTP
    debug messages](img/Figure_12.12_B19212.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Screenshot of a terminal window depicting Node.js core HTTP debug
    messages
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now learned how to use the **NODE_DEBUG** environment variable to enable
    the logging of Node.js internals.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the recipe, we set the **NODE_DEBUG** environment variable to both the **timer**
    and **http** subsystems. The **NODE_DEBUG** environment variable can be set to
    the following Node.js subsystems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**child_process**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**cluster**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**esm**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**https**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**http2**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**module**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**net**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**repl**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**source_map**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**stream**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**test_runner**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**timer**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tls**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**worker**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is also possible to enable debug logs on multiple subsystems via the **NODE_DEBUG**
    environment variable. To enable multiple subsystem logs, you can pass them as
    a comma-separated list. For example, to enable both the **http** and **timer**
    subsystems, you’d supply the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The output of each log message includes the subsystem/namespace, followed by
    the **process identifier** ( **PID** ), and then the log message.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we first enabled the “timer” core debug logs. In our program,
    we have a **setInterval()** function that prints the **Server listening...** message
    to **stdout** every 3,000 ms. The core debug logs provided insight into how our
    interval timer was created internally.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when we enabled the **http** core module debug logs, we could follow
    what was happening internally during HTTP requests. The **http** debug logs are
    fairly self-explanatory and human-readable in terms of how they describe the actions
    that are happening when our server receives and responds to an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Extending NODE_DEBUG
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to make use of the Node.js core **util.debuglog()** method to
    instrument your own debug logs that you can enable via the **NODE_DEBUG** environment
    variable. However, this is not generally recommended. It is preferable to use
    the third-party **debug** module, which is covered in the *Enabling debug logs*
    recipe in this chapter. The **debug** module provides additional logging features,
    including timestamps and color-coding, with minimal overhead.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Debugging Node.js with Chrome DevTools* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Logging with Node.js* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling debug logs* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing stack trace size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stack trace** , sometimes referred to as a **stack backtrace** , is defined
    as a list of stack frames. When your Node.js process hits an error, a stack trace
    is shown detailing the function that experienced the error, and the functions
    that it was called by. By default, Node.js’s V8 engine will return 10 stack frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'When debugging some errors, it can be useful to have more than 10 stack frames.
    However, increasing the number of stack frames stored can come with a performance
    cost. Keeping track of additional stack frames will result in our applications
    consuming more memory. For more details, you can refer to this link: [https://v8.dev/docs/stack-trace-api](https://v8.dev/docs/stack-trace-api)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we’re going to increase the size of the stack trace.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we should create a directory for our application. We’ll be using the
    **express** module for our program, so we’ll also need to initialize our project
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll need a few files for this recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, add the following to **routes.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The purpose of the **recursiveContent()** function is to force the creation
    of function calls, but in larger, more complex applications, it’s possible to
    exceed the stack frame limit naturally.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an application that will exceed the default call stack limit,
    we can move on to the recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we will learn how to enable additional stack frames using the
    **--stack-trace-limit** process flag:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by running the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in a browser, navigate to **http://localhost:3000** . Alternatively, you
    could use **cURL** to send a request to the endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Observe that we see the following stack trace output returned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now restart our application with the **--stack-trace-limit** flag. We’ll
    set this to **20** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, navigate or send a request to **http://localhost:3000** again. Observe
    that we have more frames from the stack trace now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By extending how many stack frames are returned, we can see that the **recursiveContent()**
    function is called in **routes.js** on *line 5* . This helps us realize that the
    reason our program is failing is because we did not define the content and pass
    it to our **recursiveContent()** function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve learned how to return additional stack traces, and how these can help
    us to debug our applications.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we make use of the **--stack-trace-limit** flag. This flag instructs
    the V8 JavaScript engine to retain more stacks. When an error occurs, the stack
    trace will show the preceding function calls up to the limit set with the flag.
    In the recipe, we extended this to 20 stack frames.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that it is also possible to set this limit from within your application
    code. The following line would set the stack trace limit to **20** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to set the stack trace limit to **Infinity** , meaning
    all preceding function calls will be retained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Storing additional stack traces comes with a performance cost in terms of CPU
    and memory usage. You should consider the impact this may have on your application.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Asynchronous stack traces were added to Node.js 12 via the V8 JavaScript engine
    update; these can help us debug our asynchronous functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Asynchronous stack traces help us to debug asynchronous functions in our programs.
    Let’s take a look at an asynchronous stack trace:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named **async-stack-trace.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **async-stack-trace.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This program contains an asynchronous function, **foo()** , that awaits a function
    named **bar()** . The **bar()** function automatically resolves **Promise** and
    then throws an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In versions of Node.js before Node.js 12, the following stack trace would be
    returned from the program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Observe that the trace just tells us the error is in the **bar()** function,
    followed by some internal function calls, such as **process._tickCallback()**
    . Prior to Node.js 12, stack traces were unable to effectively report the asynchronous
    function calls. Note that the stack frames do not show that the **bar()** function
    was called by **foo()** .
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'However, thanks to an updated V8 engine, Node.js 12 and greater enable asynchronous
    stack traces. We will now get the following stack output when we run the same
    program with Node.js 22:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The stack traces in newer versions of Node.js can show us that the **bar()**
    function was called by an asynchronous function named **foo()** .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Logging with Node.js* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Enabling Node.js core debug logs* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating diagnostic reports* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating diagnostic reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The diagnostic report utility has been available behind a process flag since
    Node.js v11.8.0. The diagnostic report utility allows you to generate a report
    containing diagnostic data on demand or when certain events occur. The situations
    where a report could be generated include when your application crashes, or when
    your application is experiencing slow performance or high CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: A diagnostic report fulfills a similar purpose to the Java Core file. The diagnostic
    report contains data and information that can aid with diagnosing problems in
    applications. The information reported includes the Node.js version, the event
    that triggered the report, stack traces, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Historically, the diagnostic report utility was available as a **npm** module
    named **node-report** . But, to improve adoption and enhance the core diagnostic
    features, it was merged into Node.js core.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to enable and configure the diagnostic report
    utility and generate a report when an uncaught exception happens in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, we need to prepare our directory and some files.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a directory named **diagnostic-report** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a file to hold our server named **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s also create a directory to store the reports:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we are ready to move on to the recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we’re going to use the diagnostic report utility to create
    a report on unhandled errors. We’ll set a custom directory and filename for the
    report. We’ll also inspect the generated report for information about the unhandled
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s import the core Node.js modules we need for the recipe into **server.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s set the directory for our diagnostic report to be captured in:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll send a request to a web server, but we’ll intentionally specify
    an invalid protocol. Add the following line to **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we run the application, we should expect to see the following uncaught
    **ERR_INVALID_PROTOCOL** error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To enable the diagnostic report feature, we need to start the Node.js process
    with the **--report-uncaught-exception** flag. Expect to see the following snippet
    included in the output, showing that a report has been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we can take a look at the report. It should have been created in the **reports**
    directory with the name **my-diagnostic-report.json** . Open the file in your
    editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Identify the **event** and **trigger** property toward the top of the file
    and observe that it provides details about the event that triggered the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Further down in the file, identify the **javascriptStack** property. It should
    provide the stack trace of the error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we’ve learned how to enable the diagnostic report utility on uncaught exceptions
    and how to inspect the report for diagnostic information.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The diagnostic report utility enables a diagnostic summary to be written in
    a file on certain conditions. The utility is built into the Node.js core and is
    enabled by passing one of the following command-line flags to the Node.js process:'
  prefs: []
  type: TYPE_NORMAL
- en: '**--report-uncaught-exception** : As used in the recipe, it triggers a crash
    on an uncaught exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--report-on-signal** : This is used to configure which signal a report is
    triggered upon, such as **SIGUSR1** , **SIGUSR2** , **SIGINT** , or **SIGTERM**
    . The default is **SIGUSR2** .'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**--report-on-fatalerror** : A report is triggered on a fatal error, such as
    an out-of-memory error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note that it is also possible to trigger the generation of the report from
    within your application using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In the recipe, we first set up a custom directory by assigning the **process.report.directory**
    and **process.report.filename** variables in the program. These can also be set
    via the **--report-directory** and **--report-filename** command-line arguments.
    Note that you may wish to append a timestamp to the filename – otherwise, the
    reports may get overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Neither the directory nor the filename are required to be set. When the directory
    is omitted, the report will be generated in the directory from which we start
    the Node.js process. When omitting a specified filename, the utility will default
    to creating one with the following naming convention: **report.20181126.091102.8480.0.001.json**
    .'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Enabling Node.js core debug logs* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Increasing stack trace output* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
