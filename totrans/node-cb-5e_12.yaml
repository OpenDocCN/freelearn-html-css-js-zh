- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Debugging Node.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 Node.js
- en: The asynchronous nature of JavaScript and Node.js can make the debugging process
    non-trivial. Unlike traditional synchronous code execution, the asynchronous behavior
    of Node.js introduces complexities that can challenge even experienced developers.
    However, over the past decade, Node.js has matured significantly as a technology.
    Along with this maturation, the debugging capabilities and facilities have improved
    in tandem, providing developers with more robust tools and methodologies to troubleshoot
    their applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 和 Node.js 的异步特性使得调试过程变得复杂。与传统的同步代码执行不同，Node.js 的异步行为引入了复杂性，即使是经验丰富的开发者也可能感到挑战。然而，在过去十年中，Node.js
    作为一项技术已经显著成熟。随着这种成熟，调试能力和设施也同步提高，为开发者提供了更强大的工具和方法来排查应用程序。
- en: In this chapter, we will explore the various steps we can take to make our applications
    easier to debug. By implementing best practices and adopting a structured approach
    to coding, we can mitigate some of the inherent difficulties associated with asynchronous
    programming. We will also delve into the modern tools available for debugging
    Node.js applications, such as the built-in debugger, various third-party debugging
    tools, and advanced logging techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨我们可以采取的各种步骤来使我们的应用程序更容易调试。通过实施最佳实践并采用结构化的编码方法，我们可以减轻与异步编程相关的固有困难。我们还将深入研究可用于调试
    Node.js 应用程序的现代工具，例如内置调试器、各种第三方调试工具和高级日志记录技术。
- en: Additionally, we will cover how to leverage Node.js’s diagnostic reports feature,
    a powerful utility introduced in the latest versions of Node.js. This feature
    provides in-depth insights into the state of your application at the time of failure,
    making it easier to pinpoint the root causes of issues. By the end of this chapter,
    you will have a comprehensive understanding of the strategies and tools necessary
    to effectively debug Node.js applications, ensuring smoother development and more
    stable production environments.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将介绍如何利用 Node.js 的诊断报告功能，这是 Node.js 最新版本中引入的一个强大工具。该功能提供了对应用程序失败时状态的深入了解，使得定位问题的根本原因变得更加容易。到本章结束时，你将全面了解有效调试
    Node.js 应用程序所需的策略和工具，确保开发过程更加顺畅，生产环境更加稳定。
- en: 'This chapter will cover the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Diagnosing issues with Chrome DevTools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Chrome DevTools 诊断问题
- en: Logging with Node.js
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Node.js 记录日志
- en: Enabling debug logs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用调试日志
- en: Enabling Node.js core debug logs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用 Node.js 内核调试日志
- en: Increasing stack trace size
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加堆栈跟踪大小
- en: Creating diagnostic reports
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建诊断报告
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will require Node.js 22 to be installed and available
    in your terminal path. You can test which version of Node.js is installed and
    available in your path with the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要确保 Node.js 22 已经安装并且可在你的终端路径中访问。你可以使用以下命令测试已安装的 Node.js 版本和路径：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’ll also need access to an editor and browser. For the *Diagnosing issues
    with Chrome DevTools* recipe, you will need to have Google Chrome installed, which
    you can download from [https://www.google.com/chrome/](https://www.google.com/chrome/)
    .
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要访问编辑器和浏览器。对于 *使用 Chrome DevTools 诊断问题* 的配方，你需要安装 Google Chrome，你可以从 [https://www.google.com/chrome/](https://www.google.com/chrome/)
    下载。
- en: Diagnosing issues with Chrome DevTools
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Chrome DevTools 诊断问题
- en: Node.js offers a powerful debugging utility through the **--inspect** process
    flag, enabling us to debug and profile our Node.js processes using the Chrome
    DevTools interface. This integration is made possible by the Chrome DevTools Protocol,
    which facilitates communication between Node.js and Chrome DevTools. The existence
    of this protocol allows for the creation of tools that seamlessly integrate with
    Chrome DevTools, providing a unified debugging experience across different environments.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 通过 **--inspect** 进程标志提供强大的调试工具，使我们能够通过 Chrome DevTools 界面调试和性能分析我们的
    Node.js 进程。这种集成是由 Chrome DevTools 协议实现的，它促进了 Node.js 和 Chrome DevTools 之间的通信。该协议的存在使得可以创建与
    Chrome DevTools 无缝集成的工具，从而在不同的环境中提供统一的调试体验。
- en: In this recipe, we will learn how to utilize Chrome DevTools to diagnose and
    resolve issues within a web application. We’ll cover how to set up the debugging
    environment, connect to a Node.js process, and navigate the various features of
    Chrome DevTools. This includes inspecting variables, setting breakpoints, and
    stepping through our code.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何利用 Chrome DevTools 诊断和解决 Web 应用程序中的问题。我们将涵盖如何设置调试环境、连接到 Node.js
    进程以及浏览 Chrome DevTools 的各种功能。这包括检查变量、设置断点和逐步执行我们的代码。
- en: Important note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '**node --debug** and **node --debug-brk** are legacy Node.js flags that have
    been deprecated since Node.js v6.3.0. **node --inspect** and **node --inspect-brk**
    are the modern equivalents that should be used in place of these legacy flags.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**node --debug** 和 **node --debug-brk** 是自 Node.js v6.3.0 以来已弃用的 Node.js 标志。**node
    --inspect** 和 **node --inspect-brk** 是这些旧标志的现代等效标志，应替换这些旧标志使用。'
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will debug a minimal web server built with Express. Let’s
    prepare this before we start the recipe:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将调试一个使用 Express 构建的简单 Web 服务器。在我们开始菜谱之前，让我们准备一下：
- en: 'First, let’s set up a directory and the files required for this recipe:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个目录和这个菜谱所需的文件：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following source code to **server.js** to create our web server:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下源代码添加到 **server.js** 中以创建我们的 Web 服务器：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following source code to **random.js** . This will be a local module
    we interact with via our server:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下源代码添加到 **random.js** 中。这将是我们通过服务器交互的本地模块：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that we have an application ready to debug, we can move on to the recipe
    steps.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个准备调试的应用程序，我们可以继续到菜谱步骤。
- en: How to do it…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: In this recipe, we’re going to use Chrome DevTools ( [https://developer.chrome.com/docs/devtools](https://developer.chrome.com/docs/devtools)
    ) to debug a route in our application. We expect the application to respond with
    a random number between **0** and the number we specify in the route. For example,
    **http://localhost:3000/10** should return a random number between **1** and **10**
    .
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Chrome DevTools ([https://developer.chrome.com/docs/devtools](https://developer.chrome.com/docs/devtools))
    来调试我们应用程序中的一个路由。我们期望应用程序会响应一个介于 **0** 和我们在路由中指定的数字之间的随机数。例如，**http://localhost:3000/10**
    应该返回一个介于 **1** 和 **10** 之间的随机数。
- en: 'Start the program with **$ node server.js** and navigate to **http://localhost:3000/10**
    . Refresh the endpoint a few times and you should notice that the program will
    often respond with a number greater than **10** . This indicates that we have
    a bug in our program; so, let’s debug to try and understand why this error is
    occurring:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **$ node server.js** 启动程序，并导航到 **http://localhost:3000/10**。刷新端点几次，你应该会注意到程序通常会响应一个大于
    **10** 的数字。这表明我们的程序中存在一个错误；因此，让我们进行调试以尝试理解为什么这个错误会发生：
- en: 'First, we need to start our program with the debugger enabled. To do this,
    we need to pass the **--inspect** argument to our Node.js process:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要启用调试器启动我们的程序。为此，我们需要将 **--inspect** 参数传递给我们的 Node.js 进程：
- en: '[PRE4]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Instead of going directly to the link specified in the output, navigate to
    **chrome://inspect/#devices** in Google Chrome. Expect to see the following output:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要直接点击输出中指定的链接，而是导航到 Google Chrome 中的 **chrome://inspect/#devices**。预期会看到以下输出：
- en: '![Figure 12.1 – Screenshot of the Google Chrome inspector Devices interface](img/Figure_12.1_B19212.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – Google Chrome 检查器设备界面截图](img/Figure_12.1_B19212.jpg)'
- en: Figure 12.1 – Screenshot of the Google Chrome inspector Devices interface
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – Google Chrome 检查器设备界面截图
- en: 'Observe that **server.js** is showing up as **Remote Target** . Click the **inspect**
    link and the Chrome DevTools window should open, as shown in the following figure:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到 **server.js** 显示为 **远程目标**。点击 **检查** 链接，Chrome DevTools 窗口应该打开，如图下所示：
- en: '![Figure 12.2 – Screenshot of the Chrome DevTools interface](img/Figure_12.2_B19212.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – Chrome DevTools 界面截图](img/Figure_12.2_B19212.jpg)'
- en: Figure 12.2 – Screenshot of the Chrome DevTools interface
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – Chrome DevTools 界面截图
- en: 'Click on **server.js** in the bottom-right corner of the window. This should
    ensure our **server.js** file is open:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口右下角的 **server.js**。这应该确保我们的 **server.js** 文件已打开：
- en: '![Figure 12.3 – Screenshot of the Chrome DevTools interface depicting the server.js
    file](img/Figure_12.3_B19212.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – Chrome DevTools 界面截图，显示 server.js 文件](img/Figure_12.3_B19212.jpg)'
- en: Figure 12.3 – Screenshot of the Chrome DevTools interface depicting the server.js
    file
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – Chrome DevTools 界面截图，显示 server.js 文件
- en: 'Now, we can add a breakpoint. Click the number **7** in the line-of-code column
    to the left of our code. A small red circle should appear next to the number.
    If you click **Show Debugger** in the top-right corner, you should see the breakpoint
    listed in the **Breakpoints** pane. The Chrome DevTools interface should look
    like the following:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个断点。点击我们代码左侧的行号列中的数字 **7**。应该会在数字旁边出现一个小红圈。如果你点击右上角的 **显示调试器**，你应该会在
    **断点** 窗格中看到断点列表。Chrome DevTools 界面应该看起来如下所示：
- en: '![Figure 12.4 – Screenshot of Chrome DevTools showing a breakpoint registered
    in the server.js file](img/Figure_12.4_B19212.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – Chrome DevTools 屏幕截图，显示在 server.js 文件中注册的断点](img/Figure_12.4_B19212.jpg)'
- en: Figure 12.4 – Screenshot of Chrome DevTools showing a breakpoint registered
    in the server.js file
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – Chrome DevTools 屏幕截图，显示在 server.js 文件中注册的断点
- en: Now, let’s open a new regular browser window and navigate to **http://localhost:3000/10**
    . The request will hang because it has hit the breakpoint we registered on *line
    7* .
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们打开一个新的常规浏览器窗口，并导航到 **http://localhost:3000/10**。请求将会挂起，因为它触发了我们在 *第 7
    行* 注册的断点。
- en: 'Go back to Chrome DevTools. You should notice that there is a tooltip stating
    **Paused on breakpoint** in the top-right corner of the interface. Also, to the
    right of the interface, you should see a **Call Stack** panel, which details the
    call frames:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Chrome DevTools。你应该注意到界面右上角有一个工具提示，显示为 **暂停在断点**。此外，在界面的右侧，你应该看到一个 **调用堆栈**
    窗格，它详细说明了调用帧：
- en: '![Figure 12.5 – Screenshot of the Chrome DevTools interface showing as Paused
    on breakpoint](img/Figure_12.5_B19212.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – Chrome DevTools 界面截图，显示在断点处暂停](img/Figure_12.5_B19212.jpg)'
- en: Figure 12.5 – Screenshot of the Chrome DevTools interface showing as Paused
    on breakpoint
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – Chrome DevTools 界面截图，显示在断点处暂停
- en: 'The debugger is waiting for us to act. We can choose to step in or out of the
    next instruction. Let’s step into the function. To do this, click the icon of
    an arrow pointing down to a circle (these icons are right above the **Paused on
    breakpoint** message). When you hover over each icon, a tooltip will appear describing
    the icon’s behavior. Once you have stepped in, you will see that we have moved
    into our **random.js** file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试器正在等待我们采取行动。我们可以选择进入或退出下一个指令。让我们进入函数。为此，点击指向圆圈的向下箭头图标（这些图标位于 **暂停在断点** 消息的上方）。当你悬停在每个图标上时，会出现一个工具提示，描述图标的操作。一旦你进入，你会看到我们已经进入了我们的
    **random.js** 文件：
- en: '![Figure 12.6 – Screenshot of the Chrome DevTools interface showing the random.js
    file](img/Figure_12.6_B19212.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.6 – Chrome DevTools 界面截图，显示 random.js 文件](img/Figure_12.6_B19212.jpg)'
- en: Figure 12.6 – Screenshot of the Chrome DevTools interface showing the random.js
    file
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.6 – Chrome DevTools 界面截图，显示 random.js 文件
- en: While we’re in **random.js** , we can hover over the values to check whether
    they are what we expect them to be. We can see that **n = 10** , as expected.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在 **random.js** 中时，我们可以悬停在值上以检查它们是否是我们预期的。我们可以看到 **n = 10**，正如预期的那样。
- en: 'Step over the function (by clicking the semi-circular arrow with a dot underneath)
    and then inspect the value of **randomNumber** . In the screenshot, the random
    number generated is **11** , which is greater than **10** . This helps us determine
    that the error is in our **randomNumber** logic of the previous line. Now that
    we have identified the line the error is on, it is easier to locate the error.
    Observe that we are adding the string **''1''** rather than the number **1** :'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跳过函数（通过点击底部有点的半圆形箭头）然后检查 **randomNumber** 的值。在屏幕截图中，生成的随机数是 **11**，大于 **10**。这有助于我们确定错误出在我们上一行的
    **randomNumber** 逻辑中。现在我们已经确定了错误的行，更容易定位错误。注意我们添加的是字符串 **'1'** 而不是数字 **1**：
- en: '![Figure 12.7 – Screenshot of the Chrome DevTools interface showing variable
    values on hover](img/Figure_12.7_B19212.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – Chrome DevTools 界面截图，显示悬停时的变量值](img/Figure_12.7_B19212.jpg)'
- en: Figure 12.7 – Screenshot of the Chrome DevTools interface showing variable values
    on hover
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – Chrome DevTools 界面截图，显示悬停时的变量值
- en: We have learned how to pause and step through code using Chrome DevTools. We
    have also learned that we can inspect variable values.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 Chrome DevTools 暂停和逐行执行代码。我们还了解到我们可以检查变量值。
- en: How it works…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The ability to debug Node.js applications is provided by the V8 JavaScript engine.
    When we pass the node process the **--inspect** argument, the Node.js process
    starts to listen for a debugging client. Specifically, it is the V8 inspector
    that opens a port that accepts WebSocket connections. The WebSocket connection
    allows the client and the V8 inspector to interact.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Node.js 应用程序的能力由 V8 JavaScript 引擎提供。当我们向 node 进程传递 **--inspect** 参数时，Node.js
    进程开始监听调试客户端。具体来说，是 V8 检查器打开一个接受 WebSocket 连接的端口。WebSocket 连接允许客户端和 V8 检查器进行交互。
- en: At the top of the Chrome DevTools window, you will see a URI that starts with
    **devtools://** . This is a protocol that is recognized by the Google Chrome browser
    and instructs Google Chrome to open the Chrome DevTools user interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Chrome DevTools 窗口的顶部，你会看到一个以 **devtools://** 开头的 URI。这是一个由 Google Chrome
    浏览器识别的协议，指示 Google Chrome 打开 Chrome DevTools 用户界面。
- en: In the recipe, we set a breakpoint in the Chrome DevTools window. When the line
    of code the breakpoint is registered on is encountered, the event loop (JavaScript
    thread) will be paused. The V8 inspector will then send a message to the client
    over the WebSocket connection. The message from the V8 inspector details the position
    and state of the program. The client can update its state based on the information
    it receives.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们在 Chrome DevTools 窗口中设置了一个断点。当遇到注册断点的代码行时，事件循环（JavaScript 线程）将暂停。然后 V8
    检查器将通过 WebSocket 连接向客户端发送一条消息。V8 检查器的消息详细说明了程序的位置和状态。客户端可以根据接收到的信息更新其状态。
- en: Similarly, if the user chooses to step into a function, a command is sent to
    the V8 inspector to instruct it to temporarily resume the execution of the script,
    pausing it again afterward. As before, the V8 inspector sends a message back to
    the client detailing the new position and state.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果用户选择进入一个函数，将向 V8 检查器发送一个命令，指示它暂时恢复脚本的执行，之后再次暂停。像之前一样，V8 检查器会向客户端发送一条消息，详细说明新的位置和状态。
- en: Note
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Node.js also provides a flag that we can use to pause an application on start.
    This feature enables us to set up breakpoints before anything executes. It can
    also help when debugging an error that occurs during the setup phase of your application.
    This feature can be enabled with the **--inspect-brk** flag. The following is
    how we’d start **server.js** using the **--inspect-brk** flag: **$ node --** **inspect-brk
    server.js** .'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 还提供了一个我们可以使用的标志，用于在启动时暂停应用程序。此功能使我们能够在任何代码执行之前设置断点。它还可以在调试应用程序设置阶段发生的错误时提供帮助。此功能可以通过
    **--inspect-brk** 标志启用。以下是如何使用 **--inspect-brk** 标志启动 **server.js** 的示例：**$ node
    --** **inspect-brk server.js** 。
- en: There’s more…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Node.js provides a command-line inspector, which can be valuable when we do
    not have access to a graphical user interface.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 提供了一个命令行检查器，当没有图形用户界面访问时，这可能非常有用。
- en: Debugging with the command-line inspector
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命令行检查器进行调试
- en: 'We can run the application from the recipe using the command-line-based debugger
    with the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用基于命令行的调试器，通过以下命令从配方中运行应用程序：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This command will enter us into debug mode and output the first three lines
    of **server.js** :'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使我们进入调试模式，并输出 **server.js** 的前三条行：
- en: '![Figure 12.8 – The terminal window depicting the Node.js inspector utility](img/Figure_12.8_B19212.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 显示 Node.js 检查器的终端窗口](img/Figure_12.8_B19212.jpg)'
- en: Figure 12.8 – The terminal window depicting the Node.js inspector utility
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 显示 Node.js 检查器的终端窗口
- en: When using **node inspect** , the program pauses at the first line to allow
    you to set breakpoints and configure the debugger before any code executes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 **node inspect** 时，程序将在第一行暂停，以便你可以在任何代码执行之前设置断点和配置调试器。
- en: Debug mode provides a series of commands and functions that we can use to step
    through and debug our program. You can output the complete list of these commands
    by typing **help** and hitting *Enter* .
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 调试模式提供了一系列命令和函数，我们可以使用它们来逐步调试我们的程序。你可以通过输入 **help** 并按 *Enter* 键来输出这些命令的完整列表。
- en: 'One of the functions is the **list()** function, which will list a specified
    number of the following lines. For example, we can type **list(11)** to output
    all twelve lines of our program:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个功能是 **list()** 函数，它将列出指定数量的后续行。例如，我们可以输入 **list(11)** 来输出我们程序的所有十二行：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can use the **setBreakpoint()** function to set a breakpoint. We must supply
    this function with the line number on which we wish to set the breakpoint. There’s
    also a shorthand for this function: **sb()** .'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **setBreakpoint()** 函数设置断点。我们必须向此函数提供我们希望设置断点的行号。此函数也有一个简写：**sb()**。
- en: 'Let’s set a breakpoint on *line 7* by typing **setBreakpoint(7)** or **sb(7)**
    :'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在第 *7* 行设置一个断点，通过输入 **setBreakpoint(7)** 或 **sb(7)**：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The caret ( **>** ) indicates that a breakpoint has been set on *line 7* .
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头 ( **>** ) 表示在第 *7* 行已设置断点。
- en: 'The program is still paused. We can instruct the process to begin running by
    typing the continue command, **cont** . This also has a shorthand command, **c**
    :'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 程序仍然处于暂停状态。我们可以通过输入继续命令，**cont**，来指示进程开始运行。这也有一个简写命令，**c**：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After entering the **cont** command, our program will start to run. Our breakpoint
    is within our request handler function. Let’s send a request using **cURL** in
    a new terminal window:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入 **cont** 命令后，我们的程序将开始运行。我们的断点位于请求处理函数内部。让我们在新终端窗口中使用 **cURL** 发送一个请求：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The command will hang, as it has hit our breakpoint on *line 7* of **server.js**
    . If we go back to the debug session, we will see the debugger has detected that
    a breakpoint has been reached:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将会挂起，因为它已经触发了位于 **server.js** 第 *7* 行的断点。如果我们回到调试会话，我们会看到调试器已经检测到已达到断点：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, to step into the function, we type the **step** command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要进入函数，我们输入 **step** 命令：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This goes into the **random.js** file. Note that the command-line debug utility
    provides an interface similar to Chrome DevTools, just without a graphical user
    interface.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及到 **random.js** 文件。请注意，命令行调试实用程序提供了一个类似于 Chrome DevTools 的接口，只是没有图形用户界面。
- en: 'We can print out references in the current scope using the **exec** command.
    Type **exec n** to output the value of **n** :'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **exec** 命令打印出当前作用域中的引用。输入 **exec n** 来输出 **n** 的值：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can progress to the next line using the **next** command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 **next** 命令进入下一行：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can output the value of **randomNumber** , which will help us identify where
    the faulty logic is:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以输出 **randomNumber** 的值，这将帮助我们识别错误的逻辑：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, step out using the **out** command. This will take us back to our **server.js**
    file, but now paused on the **toString()** method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用 **out** 命令退出。这将带我们回到 **server.js** 文件，但现在暂停在 **toString()** 方法上：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When you reach a breakpoint or pause execution in a function and wish to skip
    the remainder of the function’s execution to return to the caller, you can use
    the **out** command. To exit the debugger, you can type **.exit** or enter *Ctrl*
    + *C* twice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在函数中达到断点或暂停执行，并希望跳过函数的其余部分以返回调用者时，你可以使用 **out** 命令。要退出调试器，你可以输入 **.exit**
    或输入 *Ctrl* + *C* 两次。
- en: We’ve now learned how to step through our code and output reference values using
    the command-line debugger.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用命令行调试器逐步执行代码并输出引用值。
- en: Debugging TypeScript
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TypeScript 的调试
- en: With TypeScript, the code that runs in the browser is compiled JavaScript, which
    can make debugging difficult. Source maps solve this problem by mapping the compiled
    code back to your original TypeScript code, allowing you to debug more effectively
    with Chrome DevTools.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TypeScript，在浏览器中运行的代码是编译后的 JavaScript，这可能会使调试变得困难。源映射通过将编译后的代码映射回你的原始 TypeScript
    代码来解决此问题，使你能够更有效地使用 Chrome DevTools 进行调试。
- en: 'Source maps are files that map your compiled JavaScript code back to the original
    TypeScript code. This allows you to debug the original TypeScript code directly
    in Chrome DevTools, making it easier to set breakpoints and understand errors.
    To enable source maps in TypeScript, you need to enable them in the **tsconfig.json**
    file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 源映射文件是将编译后的 JavaScript 代码映射回原始 TypeScript 代码的文件。这允许你直接在 Chrome DevTools 中调试原始
    TypeScript 代码，使得设置断点和理解错误变得更加容易。要在 TypeScript 中启用源映射，你需要在 **tsconfig.json** 文件中启用它们：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Setting **sourceMap** to **true** instructs the TypeScript compiler to generate
    source maps for your compiled JavaScript files.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **sourceMap** 设置为 **true** 指示 TypeScript 编译器为你的编译后的 JavaScript 文件生成源映射。
- en: Once you have enabled source maps and compiled your TypeScript code, you can
    use Chrome DevTools to take advantage of them. With source maps enabled, your
    original TypeScript files will be listed, and you can open these files and set
    breakpoints directly in the TypeScript code. When you hit a breakpoint or encounter
    an error, Chrome DevTools will show the corresponding line in your original TypeScript
    code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您启用了源映射并编译了您的 TypeScript 代码，您就可以使用 Chrome DevTools 来利用它们。启用源映射后，您的原始 TypeScript
    文件将列出，您可以直接在 TypeScript 代码中打开这些文件并设置断点。当您遇到断点或错误时，Chrome DevTools 将显示您的原始 TypeScript
    代码中的对应行。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Logging with Node.js* recipe in this chapter
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *使用 Node.js 进行日志记录* 菜谱
- en: The *Enabling debug logs* recipe in this chapter
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *启用调试日志* 菜谱
- en: Logging with Node.js
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Node.js 进行日志记录
- en: '**Logging** is a crucial tool for understanding the inner workings of an application.
    By strategically placing log statements throughout your code, you can gain valuable
    insights into the behavior and state of your application at various points in
    its execution. This is particularly useful when diagnosing issues, as logs can
    provide a retrospective view of what was happening just before a crash or failure
    – helping you identify the root cause more efficiently.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志记录**是理解应用程序内部工作原理的关键工具。通过在代码中战略性地放置日志语句，您可以在应用程序执行的各个点上获得有关其行为和状态的宝贵见解。这在诊断问题时特别有用，因为日志可以提供对崩溃或失败前发生情况的回顾性视图——帮助您更有效地识别根本原因。'
- en: Beyond troubleshooting, logging serves multiple purposes. For instance, you
    can use logs to collect and analyze data about your application’s usage patterns.
    By logging every access to the endpoints of your web application, you can aggregate
    these logs to identify the most frequently visited endpoints. This information
    can help you optimize performance, improve user experience, and make informed
    decisions about future development priorities.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了故障排除之外，日志记录还有多种用途。例如，您可以使用日志收集和分析有关应用程序使用模式的数据。通过记录对您的 Web 应用程序端点的每次访问，您可以聚合这些日志以确定最常访问的端点。这些信息可以帮助您优化性能，改善用户体验，并就未来的开发优先事项做出明智的决定。
- en: In this recipe, we will delve into logging with **Pino** ( [https://www.npmjs.com/package/pino](https://www.npmjs.com/package/pino)
    ), a high-performance JSON-based logger that is both fast and lightweight. Pino
    is particularly well suited for Node.js applications, offering a streamlined way
    to produce structured logs that are easy to parse and analyze. We will cover how
    to set up Pino, integrate it into your application, and use it to generate meaningful
    logs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将深入探讨使用 **Pino** ([https://www.npmjs.com/package/pino](https://www.npmjs.com/package/pino))
    进行日志记录，这是一个基于 JSON 的高性能日志记录器，既快速又轻量。Pino特别适合 Node.js 应用程序，提供了一种简化方式来生成易于解析和分析的结构化日志。我们将介绍如何设置
    Pino，将其集成到您的应用程序中，并使用它来生成有意义的日志。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To demonstrate logging with Pino, we’ll create a server with Express.js:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示使用 Pino 进行日志记录，我们将使用 Express.js 创建一个服务器：
- en: 'First, create a new directory named **logging-with-pino** , initialize our
    project, and then install the **express** module:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 **logging-with-pino** 的新目录，初始化我们的项目，然后安装 **express** 模块：
- en: '[PRE17]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We’ll create a few files that we’ll use to demonstrate some basic Pino logging
    features:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一些文件，我们将使用它们来演示一些基本的 Pino 日志记录功能：
- en: '[PRE18]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will look at how we can add Pino logging to our Express.js server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何将 Pino 日志记录添加到我们的 Express.js 服务器中。
- en: How to do it…
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we will make use of the **logging-with-pino** module to demonstrate
    logging with Pino:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 **logging-with-pino** 模块来演示使用 Pino 进行日志记录：
- en: 'First, start by installing the **pino** module:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，开始安装 **pino** 模块：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To start, we will add some basic logging to our **log.js** file to demonstrate
    the usage of Pino. In **log.js** , first import Pino and initialize the logger:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将向我们的 **log.js** 文件添加一些基本的日志记录，以演示 Pino 的用法。在 **log.js** 中，首先导入 Pino 并初始化日志记录器：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With Pino initialized, we can start logging messages. Pino supports many different
    log levels, including **info** , **warn** , **error** , and **debug** . Let’s
    add one of each of these log messages:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 Pino 后，我们可以开始记录消息。Pino 支持许多不同的日志级别，包括 **info**、**warn**、**error** 和 **debug**。让我们添加这些日志消息中的每一个：
- en: '[PRE21]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Run this in your terminal:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中运行以下命令：
- en: '[PRE22]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Observe that we only see three of the four messages. This is because Pino’s
    default log level is **info** . This means that messages logged with debug will
    not appear unless you change the log level to **debug** or **lower** .
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们只看到了四条消息中的三条。这是因为Pino的默认日志级别是**info**。这意味着除非您将日志级别更改为**debug**或**更低**，否则使用debug记录的消息将不会显示。
- en: 'Let’s adjust the configuration of our Pino logger. We’ll set the log level
    to **debug** so that we can see all messages:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们调整Pino日志记录器的配置。我们将日志级别设置为**debug**，这样我们就可以看到所有消息：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Back in your terminal, rerun the **log.js** program:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，重新运行**log.js**程序：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s make the output look more readable. To do this, we can use **pino-pretty**
    :'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使输出看起来更易于阅读。为此，我们可以使用**pino-pretty**：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, let’s learn how to log to a file with Pino. For this, we’ll work within
    **logToFile.js** . Add the following to configure Pino to use a stream to write
    to a file named **app.log** . We’ll also add a single message so we can see the
    file is being written to:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何使用Pino将日志记录到文件。为此，我们将在**logToFile.js**中工作。将以下内容添加以配置Pino使用流将日志写入名为**app.log**的文件。我们还将添加一条消息，以便我们可以看到文件正在被写入：
- en: '[PRE26]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Back in your terminal, run the **logToFile.js** program, and once completed,
    you should be able to see the message that has been written to the file:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，运行**logToFile.js**程序，完成后，您应该能够看到已写入文件的消息：
- en: '[PRE27]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, let’s demonstrate Pino’s log redaction: Pino allows you to redact
    sensitive information from your logs to protect sensitive data. You can specify
    the paths of the properties to redact. Add the following to **r** **edactLog.js**
    :'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们演示一下Pino的日志编辑功能：Pino允许您从日志中编辑敏感信息，以保护敏感数据。您可以指定要编辑属性的路径。将以下内容添加到**redactLog.js**：
- en: '[PRE28]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the **redactLog.js** file. We expect to see the password and IP values
    we specified redacted:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行**redactLog.js**文件。我们期望看到我们指定的密码和IP值已被编辑：
- en: '[PRE29]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We’ve now demonstrated some key features of Pino logging.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经演示了Pino日志的一些关键功能。
- en: How it works…
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '**Pino** is a highly performant and low-overhead logging library for Node.js,
    designed to be minimalistic and fast, making it suitable for high-throughput applications.
    It outputs logs in a JSON format by default, which facilitates easy parsing and
    compatibility with log processing systems. This structured format includes essential
    details, such as timestamps, log levels, and the message content.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pino** 是一个高性能且开销低的Node.js日志库，旨在简洁快速，适用于高吞吐量应用程序。它默认以JSON格式输出日志，这有助于轻松解析和与日志处理系统兼容。这种结构化格式包括基本细节，如时间戳、日志级别和消息内容。'
- en: 'In the recipe, we began with the integration of the Pino module, which is accomplished
    by installing and then importing it into the application. Once Pino is integrated,
    a logger instance is instantiated. This instance serves as the central mechanism
    through which all logging activities are conducted. Using this logger, developers
    can generate logs at various severity levels. Each level allows the logger to
    categorize messages by their importance, aiding in the quick identification and
    troubleshooting of issues based on their severity. The possible log levels are
    as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们开始集成Pino模块，这是通过安装并将其导入应用程序中完成的。一旦Pino集成，就会实例化一个日志实例。该实例作为所有日志活动进行的中心机制。使用此日志记录器，开发者可以在各种严重级别上生成日志。每个级别都允许日志记录器根据其重要性对消息进行分类，有助于根据严重性快速识别和解决问题。可能的日志级别如下：
- en: '**fatal**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**致命**'
- en: '**error**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**'
- en: '**warn**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**警告**'
- en: '**info**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**'
- en: '**debug**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**'
- en: '**trace**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跟踪**'
- en: There’s more…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Pino can be integrated into various web frameworks using middleware, enhancing
    logging capabilities with minimal effort. The **express-pino-logger** middleware,
    for example, adds a log object to every incoming request in an Express.js application.
    This log object is accessible via a property named **log** on the request object
    ( **req.log** ). Each log object is unique per request and contains data about
    the request, including a unique identifier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Pino可以通过中间件集成到各种Web框架中，以最小的努力增强日志记录功能。例如，**express-pino-logger**中间件将日志对象添加到Express.js应用程序的每个传入请求中。此日志对象可通过请求对象上的**log**属性（**req.log**）访问。每个日志对象在每个请求中都是唯一的，并包含有关请求的数据，包括一个唯一标识符。
- en: 'The following example demonstrates how Pino can be integrated into an Express.js
    application to provide JSON logging:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何将Pino集成到Express.js应用程序中，以提供JSON日志记录：
- en: '[PRE30]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In addition to Express.js, Pino can be integrated with other popular web frameworks
    through various middlewares and plugins provided by the Pino GitHub organization:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Express.js 之外，Pino 还可以通过 Pino GitHub 组织提供的各种中间件和插件与其他流行的 Web 框架集成：
- en: '**express-pino-logger** : Express.js middleware for Pino, as used in the prior
    example ( [https://github.com/pinojs/express-pino-logger](https://github.com/pinojs/express-pino-logger)
    )'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**express-pino-logger**：Express.js 中间件用于 Pino，如前例所示（[https://github.com/pinojs/express-pino-logger](https://github.com/pinojs/express-pino-logger)）'
- en: '**hapi-pino** : A Hapi plugin for Pino ( [https://github.com/pinojs/hapi-pino](https://github.com/pinojs/hapi-pino)
    )'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**hapi-pino**：一个用于 Pino 的 Hapi 插件（[https://github.com/pinojs/hapi-pino](https://github.com/pinojs/hapi-pino)）'
- en: '**koa-pino** : A Koa.js middleware for Pino ( [https://github.com/pinojs/koa-pino-logger](https://github.com/pinojs/koa-pino-logger)
    )'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**koa-pino**：一个用于 Pino 的 Koa.js 中间件（[https://github.com/pinojs/koa-pino-logger](https://github.com/pinojs/koa-pino-logger)）'
- en: '**restify** : A Restify middleware for Pino ( [https://github.com/pinojs/restify-pino-logger](https://github.com/pinojs/restify-pino-logger)
    )'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**restify**：一个用于 Pino 的 Restify 中间件（[https://github.com/pinojs/restify-pino-logger](https://github.com/pinojs/restify-pino-logger)）'
- en: 'Furthermore, Pino’s logging capability is built into the **Fastify** web framework,
    requiring only that logging be enabled with a simple configuration:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Pino 的日志功能已内置到 **Fastify** Web 框架中，只需通过简单的配置启用日志即可：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Consuming Node.js modules* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B19212_05.xhtml#_idTextAnchor139) 的 *消费 Node.js 模块* 菜谱
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B19212_06.xhtml#_idTextAnchor178)'
- en: The *Enabling debug logs* recipe in this chapter
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *启用调试日志* 菜谱
- en: Enabling debug logs
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用调试日志
- en: '**debug** is a popular library, used by many popular frameworks, including
    the Express.js web framework and the Mocha test framework. **debug** is a small
    JavaScript debugging utility based on the debugging technique used in Node.js
    runtime itself. It offers a straightforward and flexible way to manage debug logs,
    allowing you to enable or disable debugging dynamically, without altering your
    application code. By using **debug** , you can selectively control logging for
    different parts of your application, making it easier to diagnose issues and understand
    application flow.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**debug** 是一个流行的库，被许多流行的框架使用，包括 Express.js Web 框架和 Mocha 测试框架。**debug** 是一个基于
    Node.js 运行时本身使用的调试技术的 JavaScript 调试实用工具。它提供了一种简单灵活的方式来管理调试日志，允许您动态地启用或禁用调试，而无需更改应用程序代码。通过使用
    **debug**，您可以选择性地控制应用程序不同部分的日志记录，使其更容易诊断问题并理解应用程序流程。'
- en: In the recipe, we’ll discover how to enable debug logs on an Express.js application.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将了解如何在 Express.js 应用程序上启用调试日志。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We’ll create an Express.js web application that we can enable debug logs on:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 Express.js Web 应用程序，我们可以在此上启用调试日志：
- en: 'Create a new directory and initialize our project:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录并初始化我们的项目：
- en: '[PRE32]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we’ll create a single file named **server.js** :'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为 **server.js** 的单个文件：
- en: '[PRE33]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following code to **server.js** :'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 **server.js**：
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now that we have an application, we’re ready to enable debug logs.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序，我们准备启用调试日志。
- en: How to do it…
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In this recipe, we will be enabling debug logs on our application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将启用我们的应用程序的调试日志：
- en: 'To turn on debug logging, start your server with the following command:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开启调试日志，使用以下命令启动您的服务器：
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Expect to see the following color-coded output in your terminal window:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该在终端窗口中看到以下颜色编码的输出：
- en: '![Figure 12.9 – Screenshot of a terminal window depicting debug logs for the
    web server](img/Figure_12.9_B19212.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – 显示 Web 服务器调试日志的终端窗口截图](img/Figure_12.9_B19212.jpg)'
- en: Figure 12.9 – Screenshot of a terminal window depicting debug logs for the web
    server
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – 显示 Web 服务器调试日志的终端窗口截图
- en: 'Navigate to **http://localhost:3000** in your browser to send a request to
    our server. You should see that the log messages describing your request have
    been output:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中导航到 **http://localhost:3000** 发送请求到我们的服务器。您应该看到描述您请求的日志消息已被输出：
- en: '[PRE36]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Stop your server using *Ctrl* + *C* .
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 *Ctrl* + *C* 停止您的服务器。
- en: 'Now, we can also filter which debug logs are output. We’ll filter it to just
    see the Express.js router actions. To do this, restart your server with the following
    command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还可以过滤要输出的调试日志。我们将过滤以仅查看 Express.js 路由操作。为此，使用以下命令重新启动您的服务器：
- en: '[PRE37]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Expect to see the following output in your terminal window. Observe that only
    Express.js router actions are output:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预期在您的终端窗口中看到以下输出。注意，只有 Express.js 路由操作被输出：
- en: '![Figure 12.10 – Screenshot of a terminal window depicting filtered debug logs
    for the web server](img/Figure_12.10_B19212.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – 显示 Web 服务器过滤后的调试日志的终端窗口截图](img/Figure_12.10_B19212.jpg)'
- en: Figure 12.10 – Screenshot of a terminal window depicting filtered debug logs
    for the web server
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – 显示 Web 服务器过滤后的调试日志的终端窗口截图
- en: 'It’s possible to instrument your code with the **debug** module. We can do
    that by extending our program. Start by copying the **server.js** file used in
    the recipe to a new file and install the **debug** module:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **debug** 模块对您的代码进行度量是可能的。我们可以通过扩展我们的程序来实现这一点。首先，将配方中使用的 **server.js** 文件复制到一个新文件，并安装
    **debug** 模块：
- en: '[PRE38]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Change **debug-server.js** to the following. We have imported the **debug**
    module on *line 3* , and added a **debug** call on *line 6* :'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **debug-server.js** 修改为以下内容。我们在 *第 3 行* 导入了 **debug** 模块，并在 *第 6 行* 添加了一个
    **debug** 调用：
- en: '[PRE39]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Start your application with the following command, and then navigate to **http://localhost:3000**
    . Expect to see our **HTTP GET request to /** log message in your terminal window:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令启动您的应用程序，然后导航到 **http://localhost:3000** 。预期在您的终端窗口中看到我们的 **HTTP GET 请求到
    /** 的日志消息：
- en: '[PRE40]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that our log message has **my-server** prepended to it. This is the namespace
    for our log messages, which we declared when we created our debug logging function.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们的日志消息前面有 **my-server** 。这是我们的日志消息的命名空间，我们在创建调试日志函数时声明了它。
- en: We’ve now learned how to enable debug logs on our application. We’ve also learned
    how to filter the logs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何在我们的应用程序中启用调试日志。我们还学会了如何过滤日志。
- en: How it works…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We first prepend **DEBUG=*** to our start command. This syntax passes an environment
    variable named **DEBUG** to our Node.js process, which can be accessed from within
    the application via **process.env.DEBUG** .
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在启动命令中添加 **DEBUG=***。此语法将名为 **DEBUG** 的环境变量传递给我们的 Node.js 进程，我们可以在应用程序内部通过
    **process.env.DEBUG** 访问它。
- en: We set the value to ***** , which enables all logs. Later, we filter out logs
    by setting **DEBUG=express:router*** . Internally, the **debug** module converts
    the values we set to regular expressions.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将值设置为 ***** ，这启用了所有日志。稍后，我们通过设置 **DEBUG=express:router*** 来过滤日志。内部，**debug**
    模块将我们设置的值转换为正则表达式。
- en: Express.js uses the **debug** module internally to instrument its code.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Express.js 内部使用 **debug** 模块来对其代码进行度量。
- en: The default debug configuration is not suitable for logging in production. The
    default debug logs are intended to be human-readable, hence the color coding.
    When in production, you should pass your process the **DEBUG_COLORS=no** value
    to remove the ANSI codes that implement the color coding. This will make the output
    more easily machine-readable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的调试配置不适合生产环境日志记录。默认的调试日志旨在可读，因此有颜色编码。在生产环境中，您应该传递给您的进程 **DEBUG_COLORS=no**
    值以移除实现颜色编码的 ANSI 代码。这将使输出更容易被机器读取。
- en: See also
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Consuming Node.js modules* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 5 章*](B19212_05.xhtml#_idTextAnchor139) 的 *消费 Node.js 模块* 配方'
- en: The *Logging with Node.js* recipe in this chapter
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *使用 Node.js 进行日志记录* 配方
- en: The *Enabling Node.js core debug logs* recipe in this chapter
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *启用 Node.js 核心调试日志* 配方
- en: Enabling Node.js core debug logs
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用 Node.js 核心调试日志
- en: When debugging some problems in your applications, it can be useful to have
    insight into the internals of Node.js and how it handles the execution of your
    program. Node.js provides debug logs that we can enable to help us understand
    what is happening internally in Node.js.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在应用程序中调试某些问题时，了解 Node.js 的内部结构和它如何处理您的程序执行可能会有所帮助。Node.js 提供了调试日志，我们可以启用它们来帮助我们理解
    Node.js 内部正在发生什么。
- en: These core debug logs can be enabled via an environment variable named **NODE_DEBUG**
    . In the recipe, we’re going to set the **NODE_DEBUG** environment variable to
    allow us to log internal Node.js behaviors.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些核心调试日志可以通过名为 **NODE_DEBUG** 的环境变量启用。在配方中，我们将设置 **NODE_DEBUG** 环境变量，以便我们可以记录
    Node.js 的内部行为。
- en: Getting ready
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We’ll need to create an application on which we can enable Node.js core debug
    logs:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个应用程序，以便我们可以启用 Node.js 核心调试日志：
- en: 'We’ll create a simple Express.js-based server with one route:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的基于 Express.js 的服务器，包含一个路由：
- en: '[PRE41]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Add the following to **server.js** :'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **server.js** 中添加以下内容：
- en: '[PRE42]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now that we have an application ready, we can enable the core debug logs to
    allow us to see what is happening at the Node.js runtime level.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个准备好的应用程序，我们可以启用核心调试日志，以便我们能够看到Node.js运行时级别发生的事情。
- en: How to do it…
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this recipe, we will be enabling Node.js core debug logs on an application:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将启用应用程序的Node.js核心调试日志：
- en: 'We just need to set the **NODE_DEBUG** variable to the internal flag we wish
    to log. The internal flags align with specific subsystems of Node.js, such as
    timers or HTTP. To enable the “timer” core debug logs, start your server with
    the following command:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需要将 **NODE_DEBUG** 变量设置为我们要记录的内部标志。内部标志与Node.js的特定子系统相对应，例如定时器或HTTP。要启用“定时器”核心调试日志，使用以下命令启动你的服务器：
- en: '[PRE43]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Observe the additional log output from our program. We can see additional information
    about our **setInterval()** function, which is executed every 3,000 ms:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察程序输出的额外日志。我们可以看到关于我们每3,000毫秒执行一次的 **setInterval()** 函数的额外信息：
- en: '![Figure 12.11 – Screenshot of a terminal window depicting Node.js core timer
    debug messages](img/Figure_12.11_B19212.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 显示Node.js核心定时器调试信息的终端窗口截图](img/Figure_12.11_B19212.jpg)'
- en: Figure 12.11 – Screenshot of a terminal window depicting Node.js core timer
    debug messages
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 显示Node.js核心定时器调试信息的终端窗口截图
- en: The preceding **TIMER** log statements are additional debug information that
    derives from the internal implementation of timers in Node.js core, which can
    be found at [https://github.com/nodejs/node/blob/master/lib/internal/timers.js](https://github.com/nodejs/node/blob/master/lib/internal/timers.js)
    .
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 **TIMER** 日志语句是从Node.js核心定时器的内部实现中派生出的额外调试信息，可以在[https://github.com/nodejs/node/blob/master/lib/internal/timers.js](https://github.com/nodejs/node/blob/master/lib/internal/timers.js)
    找到。
- en: 'We will now enable core debug logs for the **http** module. Restart your server
    with the following command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将启用 **http** 模块的内核调试日志。使用以下命令重新启动你的服务器：
- en: '[PRE44]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Navigate to **http://localhost:3000** in a browser. You should expect to see
    internal logs about your HTTP request output:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中导航到 **http://localhost:3000**。你应该会看到关于你的HTTP请求输出的内部日志：
- en: '![Figure 12.12 – Screenshot of a terminal window depicting Node.js core HTTP
    debug messages](img/Figure_12.12_B19212.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – 显示Node.js核心HTTP调试信息的终端窗口截图](img/Figure_12.12_B19212.jpg)'
- en: Figure 12.12 – Screenshot of a terminal window depicting Node.js core HTTP debug
    messages
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 显示Node.js核心HTTP调试信息的终端窗口截图
- en: We’ve now learned how to use the **NODE_DEBUG** environment variable to enable
    the logging of Node.js internals.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经学会了如何使用 **NODE_DEBUG** 环境变量来启用Node.js内部的日志记录。
- en: How it works…
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In the recipe, we set the **NODE_DEBUG** environment variable to both the **timer**
    and **http** subsystems. The **NODE_DEBUG** environment variable can be set to
    the following Node.js subsystems:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们将 **NODE_DEBUG** 环境变量设置为 **timer** 和 **http** 子系统。**NODE_DEBUG** 环境变量可以设置为以下Node.js子系统：
- en: '**child_process**'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**child_process**'
- en: '**cluster**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cluster**'
- en: '**esm**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**esm**'
- en: '**fs**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fs**'
- en: '**http**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http**'
- en: '**https**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**https**'
- en: '**http2**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**http2**'
- en: '**module**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**module**'
- en: '**net**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**net**'
- en: '**repl**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**repl**'
- en: '**source_map**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**source_map**'
- en: '**stream**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**stream**'
- en: '**test_runner**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**test_runner**'
- en: '**timer**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**timer**'
- en: '**tls**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tls**'
- en: '**worker**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**worker**'
- en: 'It is also possible to enable debug logs on multiple subsystems via the **NODE_DEBUG**
    environment variable. To enable multiple subsystem logs, you can pass them as
    a comma-separated list. For example, to enable both the **http** and **timer**
    subsystems, you’d supply the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过 **NODE_DEBUG** 环境变量启用多个子系统的调试日志。要启用多个子系统日志，可以将它们作为逗号分隔的列表传递。例如，要同时启用 **http**
    和 **timer** 子系统，你需要提供以下命令：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The output of each log message includes the subsystem/namespace, followed by
    the **process identifier** ( **PID** ), and then the log message.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志消息的输出包括子系统/命名空间，然后是 **进程标识符**（ **PID** ），然后是日志消息。
- en: In the recipe, we first enabled the “timer” core debug logs. In our program,
    we have a **setInterval()** function that prints the **Server listening...** message
    to **stdout** every 3,000 ms. The core debug logs provided insight into how our
    interval timer was created internally.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们首先启用了“定时器”核心调试日志。在我们的程序中，我们有一个 **setInterval()** 函数，它每3,000毫秒将 **Server
    listening...** 消息打印到 **stdout**。内核调试日志提供了关于我们内部创建间隔定时器的见解。
- en: Similarly, when we enabled the **http** core module debug logs, we could follow
    what was happening internally during HTTP requests. The **http** debug logs are
    fairly self-explanatory and human-readable in terms of how they describe the actions
    that are happening when our server receives and responds to an HTTP request.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当我们启用了 **http** 核心模块调试日志时，我们可以跟踪 HTTP 请求期间内部发生的情况。**http** 调试日志在描述服务器接收和响应
    HTTP 请求时发生的动作方面相当直观且易于阅读。
- en: Extending NODE_DEBUG
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 NODE_DEBUG
- en: It is possible to make use of the Node.js core **util.debuglog()** method to
    instrument your own debug logs that you can enable via the **NODE_DEBUG** environment
    variable. However, this is not generally recommended. It is preferable to use
    the third-party **debug** module, which is covered in the *Enabling debug logs*
    recipe in this chapter. The **debug** module provides additional logging features,
    including timestamps and color-coding, with minimal overhead.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Node.js 核心模块的 **util.debuglog()** 方法来记录您自己的调试日志，您可以通过 **NODE_DEBUG** 环境变量来启用这些日志。然而，这通常不推荐。更可取的是使用本章中介绍的第三方
    **debug** 模块。**debug** 模块提供了额外的日志功能，包括时间戳和彩色编码，而开销最小。
- en: See also
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Debugging Node.js with Chrome DevTools* recipe in this chapter
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *使用 Chrome DevTools 调试 Node.js* 配方
- en: The *Logging with Node.js* recipe in this chapter
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *使用 Node.js 记录日志* 配方
- en: The *Enabling debug logs* recipe in this chapter
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *启用调试日志* 配方
- en: Increasing stack trace size
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加堆栈跟踪大小
- en: A **stack trace** , sometimes referred to as a **stack backtrace** , is defined
    as a list of stack frames. When your Node.js process hits an error, a stack trace
    is shown detailing the function that experienced the error, and the functions
    that it was called by. By default, Node.js’s V8 engine will return 10 stack frames.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆栈跟踪**，有时也称为 **堆栈回溯**，定义为堆栈帧的列表。当您的 Node.js 进程遇到错误时，会显示堆栈跟踪，详细说明遇到错误的函数以及调用它的函数。默认情况下，Node.js
    的 V8 引擎将返回 10 个堆栈帧。'
- en: 'When debugging some errors, it can be useful to have more than 10 stack frames.
    However, increasing the number of stack frames stored can come with a performance
    cost. Keeping track of additional stack frames will result in our applications
    consuming more memory. For more details, you can refer to this link: [https://v8.dev/docs/stack-trace-api](https://v8.dev/docs/stack-trace-api)
    .'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试某些错误时，拥有超过 10 个堆栈帧可能很有用。然而，存储堆栈帧数量的增加可能会带来性能成本。跟踪额外的堆栈帧会导致我们的应用程序消耗更多的内存。有关更多详细信息，您可以参考此链接：[https://v8.dev/docs/stack-trace-api](https://v8.dev/docs/stack-trace-api)。
- en: In the recipe, we’re going to increase the size of the stack trace.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将增加堆栈跟踪的大小。
- en: Getting ready
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, we should create a directory for our application. We’ll be using the
    **express** module for our program, so we’ll also need to initialize our project
    directory:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该为我们的应用程序创建一个目录。我们将使用 **express** 模块来编写程序，因此我们还需要初始化我们的项目目录：
- en: '[PRE46]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We’ll need a few files for this recipe:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为这个配方准备几个文件：
- en: '[PRE47]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add the following to **server.js** :'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **server.js**：
- en: '[PRE48]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, add the following to **routes.js** :'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下内容添加到 **routes.js**：
- en: '[PRE49]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The purpose of the **recursiveContent()** function is to force the creation
    of function calls, but in larger, more complex applications, it’s possible to
    exceed the stack frame limit naturally.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '**recursiveContent()** 函数的目的是强制创建函数调用，但在更大、更复杂的应用程序中，自然可能超过堆栈帧限制。'
- en: Now that we have an application that will exceed the default call stack limit,
    we can move on to the recipe steps.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个将超过默认调用栈限制的应用程序，我们可以继续到配方步骤。
- en: How to do it…
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'In this recipe, we will learn how to enable additional stack frames using the
    **--stack-trace-limit** process flag:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用 **--stack-trace-limit** 进程标志启用额外的堆栈帧：
- en: 'Start by running the server:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，运行服务器：
- en: '[PRE50]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, in a browser, navigate to **http://localhost:3000** . Alternatively, you
    could use **cURL** to send a request to the endpoint.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中，导航到 **http://localhost:3000**。或者，您也可以使用 **cURL** 向端点发送请求。
- en: 'Observe that we see the following stack trace output returned:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们看到了以下堆栈跟踪输出：
- en: '[PRE51]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can now restart our application with the **--stack-trace-limit** flag. We’ll
    set this to **20** :'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 **--stack-trace-limit** 标志重新启动我们的应用程序。我们将将其设置为 **20**：
- en: '[PRE52]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, navigate or send a request to **http://localhost:3000** again. Observe
    that we have more frames from the stack trace now:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次导航或发送请求到 **http://localhost:3000**。观察我们现在有更多的堆栈跟踪帧：
- en: '[PRE53]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: By extending how many stack frames are returned, we can see that the **recursiveContent()**
    function is called in **routes.js** on *line 5* . This helps us realize that the
    reason our program is failing is because we did not define the content and pass
    it to our **recursiveContent()** function.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过扩展返回的堆栈帧数量，我们可以看到 **recursiveContent()** 函数在 **routes.js** 中的 *第5行* 被调用。这有助于我们意识到程序失败的原因是因为我们没有定义内容并将其传递给我们的
    **recursiveContent()** 函数。
- en: We’ve learned how to return additional stack traces, and how these can help
    us to debug our applications.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何返回额外的堆栈跟踪，以及这些如何帮助我们调试我们的应用程序。
- en: How it works…
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the recipe, we make use of the **--stack-trace-limit** flag. This flag instructs
    the V8 JavaScript engine to retain more stacks. When an error occurs, the stack
    trace will show the preceding function calls up to the limit set with the flag.
    In the recipe, we extended this to 20 stack frames.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在配方中，我们使用了 **--stack-trace-limit** 标志。此标志指示 V8 JavaScript 引擎保留更多堆栈。当发生错误时，堆栈跟踪将显示使用标志设置的限制之前的函数调用。在配方中，我们将此扩展到
    20 个堆栈帧。
- en: 'Note that it is also possible to set this limit from within your application
    code. The following line would set the stack trace limit to **20** :'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，您也可以在应用程序代码中设置此限制。以下行将堆栈跟踪限制设置为 **20** :'
- en: '[PRE54]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It is also possible to set the stack trace limit to **Infinity** , meaning
    all preceding function calls will be retained:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将堆栈跟踪限制设置为 **Infinity** ，这意味着将保留所有之前的函数调用：
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Storing additional stack traces comes with a performance cost in terms of CPU
    and memory usage. You should consider the impact this may have on your application.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 存储额外的堆栈跟踪会带来 CPU 和内存使用方面的性能成本。您应考虑这可能对您的应用程序产生的影响。
- en: There’s more…
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Asynchronous stack traces were added to Node.js 12 via the V8 JavaScript engine
    update; these can help us debug our asynchronous functions.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 异步堆栈跟踪是通过 V8 JavaScript 引擎更新添加到 Node.js 12 的；这些可以帮助我们调试我们的异步函数。
- en: 'Asynchronous stack traces help us to debug asynchronous functions in our programs.
    Let’s take a look at an asynchronous stack trace:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 异步堆栈跟踪帮助我们调试程序中的异步函数。让我们看看一个异步堆栈跟踪的例子：
- en: 'Create a file named **async-stack-trace.js** :'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **async-stack-trace.js** 的文件：
- en: '[PRE56]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the following to **async-stack-trace.js** :'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将以下内容添加到 **async-stack-trace.js** :'
- en: '[PRE57]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This program contains an asynchronous function, **foo()** , that awaits a function
    named **bar()** . The **bar()** function automatically resolves **Promise** and
    then throws an error.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该程序包含一个异步函数 **foo()** ，它等待一个名为 **bar()** 的函数。**bar()** 函数自动解析 **Promise** 并抛出错误。
- en: 'In versions of Node.js before Node.js 12, the following stack trace would be
    returned from the program:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Node.js 12 之前的 Node.js 版本中，程序将返回以下堆栈跟踪：
- en: '[PRE58]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Observe that the trace just tells us the error is in the **bar()** function,
    followed by some internal function calls, such as **process._tickCallback()**
    . Prior to Node.js 12, stack traces were unable to effectively report the asynchronous
    function calls. Note that the stack frames do not show that the **bar()** function
    was called by **foo()** .
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，跟踪只是告诉我们错误发生在 **bar()** 函数中，随后是一些内部函数调用，例如 **process._tickCallback()** 。在
    Node.js 12 之前，堆栈跟踪无法有效地报告异步函数调用。请注意，堆栈帧没有显示 **bar()** 函数是由 **foo()** 调用的。
- en: 'However, thanks to an updated V8 engine, Node.js 12 and greater enable asynchronous
    stack traces. We will now get the following stack output when we run the same
    program with Node.js 22:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，多亏了更新的 V8 引擎，Node.js 12 及更高版本允许异步堆栈跟踪。现在，当我们用 Node.js 22 运行相同的程序时，我们将得到以下堆栈输出：
- en: '[PRE59]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The stack traces in newer versions of Node.js can show us that the **bar()**
    function was called by an asynchronous function named **foo()** .
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 的新版本中，堆栈跟踪可以显示 **bar()** 函数是由一个名为 **foo()** 的异步函数调用的。
- en: See also
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Logging with Node.js* recipe in this chapter
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *使用 Node.js 记录日志* 配方
- en: The *Enabling Node.js core debug logs* recipe in this chapter
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *启用 Node.js 核心调试日志* 配方
- en: The *Creating diagnostic reports* recipe in this chapter
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的 *创建诊断报告* 配方
- en: Creating diagnostic reports
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建诊断报告
- en: The diagnostic report utility has been available behind a process flag since
    Node.js v11.8.0. The diagnostic report utility allows you to generate a report
    containing diagnostic data on demand or when certain events occur. The situations
    where a report could be generated include when your application crashes, or when
    your application is experiencing slow performance or high CPU usage.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Node.js v11.8.0 版本以来，诊断报告工具一直隐藏在进程标志之后。诊断报告工具允许您在需要时或当某些事件发生时生成包含诊断数据的报告。可能生成报告的情况包括当您的应用程序崩溃，或者当您的应用程序出现性能缓慢或CPU使用率高时。
- en: A diagnostic report fulfills a similar purpose to the Java Core file. The diagnostic
    report contains data and information that can aid with diagnosing problems in
    applications. The information reported includes the Node.js version, the event
    that triggered the report, stack traces, and more.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断报告与 Java Core 文件具有类似的作用。诊断报告包含有助于诊断应用程序问题的数据和信息。报告的信息包括 Node.js 版本、触发报告的事件、堆栈跟踪等。
- en: Historically, the diagnostic report utility was available as a **npm** module
    named **node-report** . But, to improve adoption and enhance the core diagnostic
    features, it was merged into Node.js core.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，诊断报告工具作为一个名为 **node-report** 的 **npm** 模块提供。但是，为了提高采用率并增强核心诊断功能，它已被合并到
    Node.js 核心中。
- en: In this recipe, we’ll learn how to enable and configure the diagnostic report
    utility and generate a report when an uncaught exception happens in our application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何启用和配置诊断报告工具，并在我们的应用程序中发生未捕获异常时生成报告。
- en: Getting ready
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, we need to prepare our directory and some files.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要准备我们的目录和一些文件。
- en: 'First, let’s create a directory named **diagnostic-report** :'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 **diagnostic-report** 的目录：
- en: '[PRE60]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, let’s create a file to hold our server named **server.js** :'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为 **server.js** 的文件来保存我们的服务器：
- en: '[PRE61]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Let’s also create a directory to store the reports:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再创建一个目录来存储报告：
- en: '[PRE62]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, we are ready to move on to the recipe steps.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进入菜谱步骤。
- en: How to do it…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In this recipe, we’re going to use the diagnostic report utility to create
    a report on unhandled errors. We’ll set a custom directory and filename for the
    report. We’ll also inspect the generated report for information about the unhandled
    errors:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用诊断报告工具创建关于未处理错误的报告。我们将为报告设置自定义的目录和文件名。我们还将检查生成的报告以获取有关未处理错误的信息：
- en: 'First, let’s import the core Node.js modules we need for the recipe into **server.js**
    :'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '首先，让我们将我们需要用于菜谱的核心 Node.js 模块导入到 **server.js** :'
- en: '[PRE63]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now, let’s set the directory for our diagnostic report to be captured in:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置我们的诊断报告要捕获的目录：
- en: '[PRE64]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, we’ll send a request to a web server, but we’ll intentionally specify
    an invalid protocol. Add the following line to **server.js** :'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，我们将向一个网络服务器发送请求，但我们将故意指定一个无效的协议。将以下行添加到 **server.js** :'
- en: '[PRE65]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, if we run the application, we should expect to see the following uncaught
    **ERR_INVALID_PROTOCOL** error:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们运行应用程序，我们应该期望看到以下未捕获的 **ERR_INVALID_PROTOCOL** 错误：
- en: '[PRE66]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To enable the diagnostic report feature, we need to start the Node.js process
    with the **--report-uncaught-exception** flag. Expect to see the following snippet
    included in the output, showing that a report has been created:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用诊断报告功能，我们需要使用 **--report-uncaught-exception** 标志启动 Node.js 进程。期望在输出中看到以下片段，显示已创建报告：
- en: '[PRE67]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now, we can take a look at the report. It should have been created in the **reports**
    directory with the name **my-diagnostic-report.json** . Open the file in your
    editor.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以查看报告。它应该已经在 **reports** 目录中创建，名称为 **my-diagnostic-report.json** 。在您的编辑器中打开该文件。
- en: 'Identify the **event** and **trigger** property toward the top of the file
    and observe that it provides details about the event that triggered the error:'
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部识别 **event** 和 **trigger** 属性，并观察它提供了有关触发错误的事件的详细信息：
- en: '[PRE68]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Further down in the file, identify the **javascriptStack** property. It should
    provide the stack trace of the error:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件更下方，识别 **javascriptStack** 属性。它应该提供错误的堆栈跟踪：
- en: '[PRE69]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now, we’ve learned how to enable the diagnostic report utility on uncaught exceptions
    and how to inspect the report for diagnostic information.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何在未捕获的异常上启用诊断报告工具，以及如何检查报告以获取诊断信息。
- en: How it works…
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The diagnostic report utility enables a diagnostic summary to be written in
    a file on certain conditions. The utility is built into the Node.js core and is
    enabled by passing one of the following command-line flags to the Node.js process:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 诊断报告实用程序可以在某些条件下将诊断摘要写入文件。该实用程序内置在 Node.js 核心中，可以通过向 Node.js 进程传递以下命令行标志之一来启用：
- en: '**--report-uncaught-exception** : As used in the recipe, it triggers a crash
    on an uncaught exception.'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--report-uncaught-exception**：如食谱中所述，它会在未捕获的异常上触发崩溃。'
- en: '**--report-on-signal** : This is used to configure which signal a report is
    triggered upon, such as **SIGUSR1** , **SIGUSR2** , **SIGINT** , or **SIGTERM**
    . The default is **SIGUSR2** .'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--report-on-signal**：这用于配置在哪个信号上触发报告，例如 **SIGUSR1**、**SIGUSR2**、**SIGINT**
    或 **SIGTERM**。默认为 **SIGUSR2**。'
- en: '**--report-on-fatalerror** : A report is triggered on a fatal error, such as
    an out-of-memory error.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--report-on-fatalerror**：在致命错误（如内存不足错误）上触发报告。'
- en: 'Note that it is also possible to trigger the generation of the report from
    within your application using the following line:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你也可以使用以下行在你的应用程序内部触发报告的生成：
- en: '[PRE70]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the recipe, we first set up a custom directory by assigning the **process.report.directory**
    and **process.report.filename** variables in the program. These can also be set
    via the **--report-directory** and **--report-filename** command-line arguments.
    Note that you may wish to append a timestamp to the filename – otherwise, the
    reports may get overwritten.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们首先通过在程序中分配 **process.report.directory** 和 **process.report.filename**
    变量来设置一个自定义目录。这些也可以通过 **--report-directory** 和 **--report-filename** 命令行参数来设置。请注意，你可能希望将时间戳附加到文件名上——否则，报告可能会被覆盖。
- en: 'Neither the directory nor the filename are required to be set. When the directory
    is omitted, the report will be generated in the directory from which we start
    the Node.js process. When omitting a specified filename, the utility will default
    to creating one with the following naming convention: **report.20181126.091102.8480.0.001.json**
    .'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 目录和文件名都不是必需设置的。当省略目录时，报告将在我们从其中启动 Node.js 进程的目录中生成。当省略指定的文件名时，实用程序将默认创建一个具有以下命名约定的文件：**report.20181126.091102.8480.0.001.json**。
- en: See also
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Enabling Node.js core debug logs* recipe in this chapter
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *启用 Node.js 核心调试日志* 食谱
- en: The *Increasing stack trace output* recipe in this chapter
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *增加堆栈跟踪输出* 食谱
