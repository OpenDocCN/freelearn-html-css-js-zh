<html><head></head><body>
		<div id="_idContainer022">
			<h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor027"/>2</h1>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor028"/>Diving into Microservices Internals</h1>
			<p>Microservices aren’t just about breaking down a large application into smaller, more manageable ones. They also introduce challenges, one of which is communication between services. Monolithic applications, which we discussed in the previous chapter, make communication between elements relatively straightforward. However, in microservice architecture, we have physical isolation between services. Even though we want microservices to be independent, as well as easy to reuse, maintain, and grow, getting them to talk to each other effectively becomes a <span class="No-Break">major challenge.</span></p>
			<p>Effective microservice communication is<a id="_idIndexMarker051"/> crucial for the overall success of architecture. It enables services to exchange data, coordinate actions, and trigger events. If microservices can’t communicate effectively, they become like isolated islands, stopping the application from working properly and keeping it running slowly. Well-designed communication patterns ensure that microservices can collaborate effectively to deliver the desired functionality. This communication strategy also promotes loose coupling, which means that changes in one service have minimal impact on others, thereby making the application more resilient and easier <span class="No-Break">to maintain.</span></p>
			<p>This chapter is about establishing a strong foundation for the next practical chapters, along with providing comprehensive information about microservice communication. A solid understanding of microservices communication will help you build reliable, consistent, scalable, and fault-tolerant <span class="No-Break">microservice applications.</span></p>
			<p>In this chapter, we’re going to talk more about the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Microservices <span class="No-Break">communication techniques</span></li>
				<li>Synchronous <span class="No-Break">microservice communication</span></li>
				<li>Asynchronous <span class="No-Break">microservice communication</span></li>
				<li>Essential <span class="No-Break">communication patterns</span></li>
			</ul>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor029"/>Solidifying the communication</h2>
			<p>As your<a id="_idIndexMarker052"/> application grows, managing its complexity becomes increasingly challenging. To tackle this, developers rely on best practices, design patterns, and various approaches. In traditional software design, techniques like abstraction, encapsulation, and decomposition help us deal <span class="No-Break">with complexity.</span></p>
			<p>The microservice architecture offers a<a id="_idIndexMarker053"/> provides a powerful solution to complexity through the <strong class="bold">Separation of Concerns</strong> (<strong class="bold">SOC</strong>) principle. This principle breaks down a complex system into smaller independent parts, each with a well-defined responsibility. Imagine a monolithic application as a mountain; microservices allow us to break it down into smaller, more manageable hills through bounded contexts. However, this freedom comes at the cost of somehow figuring out how to establish communication between microservices. Of course, it is not as easy as it was with the monolithic approach, because with that, everything was inside one codebase. Creating a connection between elements of a monolith was as simple as calling <span class="No-Break">any method.</span></p>
			<p>The best way to explain the relationship between monoliths and microservices is by using the first two<a id="_idIndexMarker054"/> principles of <strong class="bold">S.O.L.I.D</strong>, the <strong class="bold">Single Responsibility Principle</strong> (<strong class="bold">SRP</strong>) and <a id="_idIndexMarker055"/>the <strong class="bold">Open-Closed Principle</strong> (<strong class="bold">OCP</strong>), <span class="No-Break">as metaphors.</span></p>
			<p>The SRP’s core principle of dividing a large problem into smaller, more focused units aligns with the microservices approach. We break down the big picture into smaller, manageable modules, each with well-defined responsibilities and reasons for change. This mirrors the SRP’s aim of splitting classes and modules into <span class="No-Break">manageable pieces.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer014">
					<img alt="Figure 2.1: Applying the SRP" src="image/B09148_02_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1: Applying the SRP</p>
			<p>The main idea <a id="_idIndexMarker056"/>behind the SRP is the SoC, which is also adopted in microservice architecture. It promotes dividing a system into independent parts based on functionality. This improves maintainability, reduces complexity, and allows for independent development and deployment of <span class="No-Break">each part</span></p>
			<p>Metaphorically, the SRP’s abstract idea is to break down the big module into smaller one (see <span class="No-Break">Figure 2</span>.2) that are similar to what we get when we divide a monolith into smaller services <span class="No-Break">called microservices.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer015">
					<img alt="Figure 2.2: Monolithic architecture to microservice architecture" src="image/B09148_02_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2: Monolithic architecture to microservice architecture</p>
			<p>The final results of<a id="_idIndexMarker057"/> splitting up your monolithic application are microservices; they are software entities for us in this comparison. Making them open for <a id="_idIndexMarker058"/>an extension means that there is a team that works on them. This team can extend and modify them without depending on other teams or modules. Having loose coupling between services allows us to independently work <span class="No-Break">on services.</span></p>
			<p>However, there’s a catch: <em class="italic">communication</em>. With multiple smaller entities instead of one monolithic class, the application relies on communication to function as a whole. While the SRP creates independent subsystems, it doesn’t address the challenges of enabling communication between them. In fact, the SRP itself can contribute to this complexity. The SRP can leave you with multiple smaller subsystems without solving communication issues <span class="No-Break">between them.</span></p>
			<p>This is where the<a id="_idIndexMarker059"/> OCP comes in. The OCP states that software should be open for extension but closed for modification. From a metaphorical perspective, in the context of microservices, this means designing communication mechanisms that are flexible and adaptable to future changes without requiring modifications to <span class="No-Break">existing services.</span></p>
			<p>When one microservice (we’ll call it <em class="italic">Microservice A</em>) asks for some resource from another microservice (<em class="italic">Microservice B</em>), it doesn’t need to know the internals of Microservice B. In exchange for that, Microservice B may use a different implementation form of the same endpoint without notifying <span class="No-Break">Microservice A</span></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor030"/>Microservice communication techniques</h1>
			<p>The biggest <a id="_idIndexMarker060"/>communication challenge with microservices is establishing reliable and scalable connections between them. We use different techniques to handle microservices communication. It is worth mentioning that there are multiple techniques to achieve proper communication between microservices. However, in this chapter, we will only focus on the most popular ones, as well as the ones that we think are most important. Let’s explore these <span class="No-Break">techniques together.</span></p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor031"/>Introduction to APIs</h2>
			<p>In software<a id="_idIndexMarker061"/> development, <strong class="bold">Application Programming Interfaces</strong> (<strong class="bold">APIs</strong>) are important tools that help us avoid doing the<a id="_idIndexMarker062"/> same tasks over and over. APIs protect us from the complexities of our working environment and area of expertise, making it easier to manage complicated processes and ignore detailed domain knowledge. They encapsulate complexity, making it unnecessary to understand the underlying implementation details. APIs by themselves are black boxes that provide only the required information. This means that we don’t have to worry about the nitty-gritty technical stuff and can focus on using the provided interfaces to interact with our environment. For example, when we use a framework, we see all the DLLs (packages) as APIs that give us the functions that <span class="No-Break">we need.</span></p>
			<p>A web-based API is just a type of API. It’s used to help different programs share information over the internet using standard web rules and methods. Usually, these APIs are seen as REST APIs<a id="_idIndexMarker063"/> or <strong class="bold">Simple Object Access Protocol</strong> (<strong class="bold">SOAP</strong>) services and rely on client-server architecture. This allows for creating connections between various online resources such as websites or services, which can help in building big systems like microservices or just in <span class="No-Break">sharing data.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer016">
					<img alt="Figure 2.3: Client-server architecture" src="image/B09148_02_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3: Client-server architecture</p>
			<p>We talked about REST here, but what does it mean? Let’s discuss this in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor032"/>What exactly is REST?</h2>
			<p><strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) is a <a id="_idIndexMarker064"/>style of architecture that is used for building<a id="_idIndexMarker065"/> applications that are loosely connected over the HTTP protocol. It’s important to note that REST is primarily a design approach rather than a strict architectural pattern. When I consider the differences between architectural style and pattern, I always perceive abstraction <span class="No-Break">and implementation.</span></p>
			<p>An architectural <em class="italic">style</em> defines a set of principles and guidelines for organizing a system’s structure. It provides a high-level abstraction of how different components should interact and communicate with each other. Architectural styles are broad, conceptual approaches to designing <span class="No-Break">software systems.</span></p>
			<p>An architectural <em class="italic">pattern</em>, on the other hand, is a specific solution to a recurring architectural problem. It’s a reusable design blueprint or template that describes how to solve a particular design problem within a given architectural style. It provides a concrete blueprint for implementing a particular aspect of <span class="No-Break">the style.</span></p>
			<p>Many call REST a protocol. However, REST itself isn’t a standardized protocol, although it’s commonly implemented using web standards today. While it’s often associated with HTTP, it’s not limited to this protocol; REST can work with other <span class="No-Break">protocols too.</span></p>
			<p>To simplify, think <a id="_idIndexMarker066"/>of REST as a blueprint for how systems should communicate. It outlines how a client (such as a web browser) can request information from a server, and how the server responds, potentially changing the <span class="No-Break">client’s state.</span></p>
			<p>The core ideas behind REST are resource, representation, state, and transfer. When a client requests a resource from a server, the server sends back a representation of that resource, which is essentially a copy. If the state of the resource changes later, the client can request it again to get the latest version. The process of sending this resource from server to client is the transfer part <span class="No-Break">of REST.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer017">
					<img alt="Figure 2.4: An overview of REST" src="image/B09148_02_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4: An overview of REST</p>
			<p>So, why is<a id="_idIndexMarker067"/> <span class="No-Break">REST important?</span></p>
			<ul>
				<li>It separates the client and server, breaking their direct reliance on <span class="No-Break">each other.</span></li>
				<li>It’s <strong class="bold">platform-independent</strong>, meaning that it’s not restricted to any <span class="No-Break">particular system.</span></li>
				<li>It’s <strong class="bold">language-agnostic</strong>. Whether you’re coding in PHP, C#, Node.js, or any other language, you can implement <span class="No-Break">REST services.</span></li>
				<li>It’s flexible <a id="_idIndexMarker068"/>with data formats, supporting both XML and JSON, <span class="No-Break">among others.</span></li>
				<li>It facilitates building distributed systems, enabling components to be spread across <span class="No-Break">different locations.</span></li>
				<li>It offers discoverability, making it easy to identify and <span class="No-Break">access resources.</span></li>
				<li>It’s straightforward to use, simplifying the process of <span class="No-Break">integrating services.</span></li>
				<li>It leverages <strong class="bold">HTTP cache</strong>, improving performance by storing frequently accessed <a id="_idIndexMarker069"/><span class="No-Break">data locally.</span></li>
			</ul>
			<p>With this understanding, let’s look at some of the constraints <span class="No-Break">of REST.</span></p>
			<h3>What are some REST constraints?</h3>
			<p>The key <a id="_idIndexMarker070"/>indicator that a service follows REST principles lies in the constraints it follows. REST adheres to six constraints, five of which <span class="No-Break">are mandatory.</span></p>
			<ul>
				<li><strong class="bold">Uniform-interface constraint</strong>: This is perhaps the most critical aspect of REST. This states that devices and programs should access resources using the same URL. A URL can offer different representations, such as XML or JSON, via content negotiation. Both GET and POST requests can be made to the <span class="No-Break">same URL.</span><p class="list-inset">This brief overview doesn’t cover the entirety of the uniform-interface constraint, which consists of <span class="No-Break">four sub-parts:</span></p><ul><li><strong class="bold">Identification of resources</strong>: Resources should be identifiable via URL. For instance, if the URL is <a href="https://website.com/api/students">https://website.com/api/students</a>, <strong class="source-inline">students</strong> is <span class="No-Break">the resource.</span></li><li><strong class="bold">Manipulating resources through representation</strong>: If a client can modify a resource, metadata about how to do so should be included with the <span class="No-Break">returned representation.</span></li><li><strong class="bold">Self-descriptive messages</strong>: Each request should contain all necessary information, which is typically conveyed via <span class="No-Break">HTTP headers.</span></li><li><strong class="bold">Hypermedia As the Engine of Application State</strong> (<strong class="bold">HATEOAS</strong>): Requests<a id="_idIndexMarker071"/> should provide documentation, enabling clients to discover other <span class="No-Break">resources easily.</span></li></ul></li>
				<li><strong class="bold">Client-server constraint</strong>: This constraint separates the client and server. Here, a client and server facilitate data exchange. They evolve independently and remain ignorant of each <span class="No-Break">other’s architecture.</span></li>
				<li><strong class="bold">Stateless constraint</strong>: This ensures communication without maintaining session data. The servers don’t retain client session data, and each request is independent <span class="No-Break">of others.</span></li>
				<li><strong class="bold">Cacheable constraint</strong>: To improve speed and efficiency, responses should be cacheable, and the caching should be managed via headers. Instead of fetching data from the server every time, we should use the cached version that helps reduce load to the server and speed up <span class="No-Break">response times.</span></li>
				<li><strong class="bold">Layered system</strong>: To reduce complexity, the server architecture is organized hierarchically, and each layer only interacts with the one adjacent <span class="No-Break">to it.</span></li>
				<li><strong class="bold">Code on demand constraint</strong>: Servers can provide executable code examples to clients, though this is not mandatory due to <span class="No-Break">security concerns.</span></li>
			</ul>
			<p>The most popular implementation based on REST is<a id="_idIndexMarker072"/> called <strong class="bold">RESTful services</strong>. RESTful services heavily rely on REST principles. However, this doesn’t mean that using RESTful service creation tools will always ensure that you end up with REST-based services. You should learn and apply these principles to make your API <a id="_idIndexMarker073"/><span class="No-Break">more </span><span class="No-Break"><strong class="bold">RESTable</strong></span><span class="No-Break">.</span></p>
			<p>Think of RESTful APIs as a common language for microservices. One service can send an HTTP request (such as <strong class="source-inline">get user data</strong>) to another and get the information it needs. This keeps things simple and avoids messy situations wherein services need to understand each other’s <span class="No-Break">inner workings</span></p>
			<p>RESTful APIs act like messengers between microservices, ensuring they work together smoothly, even though they’re <span class="No-Break">separate </span><span class="No-Break">components.</span></p>
			<h3>How does a RESTful API work?</h3>
			<p>Imagine<a id="_idIndexMarker074"/> information such as pictures, text, or data stored online. This information is like a resource. When an application needs this resource, it sends a message, which is called a request, to the server to ask for it. Think of the request as a polite way to ask <span class="No-Break">for something.</span></p>
			<p>To make sure that the server understands the request, the application follows a set of instructions, like a recipe. These instructions are called documentation and are provided by the <span class="No-Break">server creator.</span></p>
			<p>Depending on how sensitive the information is, the server might check the application’s identity, similar to checking your ID before entering a secure place. This is called authentication. Once the server has received and understood the request, it processes it and finds the information. Then the server sends a response back to <span class="No-Break">the application.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor033"/>HTTP-based REST implementation</h2>
			<p>Developers<a id="_idIndexMarker075"/> often build RESTful APIs using a special language for web communication called HTTP, which is like a language for talking to websites. In this language, there <a id="_idIndexMarker076"/>are special words called <strong class="bold">HTTP methods</strong> that tell the server what to do with the information (the resource). Let’s discover the most used HTTP methods together in the next <span class="No-Break">few subsections.</span></p>
			<h3>GET</h3>
			<p>We as<a id="_idIndexMarker077"/> developers use the GET method when we want to ask for some representation of the given resource without <span class="No-Break">changing it.</span></p>
			<p>The HTTP GET method is a request for the server to retrieve a specific resource without modifying it. It’s like saying “Please give me <span class="No-Break">this information.”</span></p>
			<p>Here’s a breakdown of how <span class="No-Break">it works:</span></p>
			<ol>
				<li>You (the client, like your web browser) send a request to the server using the GET method. This request is like a message asking for the resource <span class="No-Break">you want.</span></li>
				<li>The website (server) receives the request and understands what you’re asking for because of the <span class="No-Break">GET method.</span></li>
				<li>The <a id="_idIndexMarker078"/>website (server) finds the information that you requested and sends it back to you in response. This response might include things like text, images, or <span class="No-Break">other data.</span></li>
			</ol>
			<p>Think of it like asking a friend to show you a picture on their phone. You wouldn’t just grab it; you’d politely ask to see it. Similarly, the GET method allows you to get information politely from <span class="No-Break">a website.</span></p>
			<p>It’s important to note that the GET method is used for retrieving information and shouldn’t be used for changing or modifying anything on the website. Think of it like borrowing a book from the library, not writing <span class="No-Break">in it.</span></p>
			<h3>POST</h3>
			<p>The <a id="_idIndexMarker079"/>POST method is used to create a resource on <span class="No-Break">the server.</span></p>
			<p>Think of the POST method as a secure way to send information to the website (server). It’s like filling out a form and clicking <em class="italic">submit</em> to send <span class="No-Break">your data.</span></p>
			<p>Here’s how <span class="No-Break">it works:</span></p>
			<ol>
				<li>You (the client) fill out a form with the information you want to send (such as your name <span class="No-Break">and email).</span></li>
				<li>Your tool (usually a browser) sends a request to the website (server) using the POST method. This request includes the information you entered on <span class="No-Break">the form.</span></li>
				<li>The website (server) receives the request and understands the information because of the <span class="No-Break">POST method.</span></li>
				<li>The server processes the information you send which may involve actions like creating an account, storing a comment, or sending <span class="No-Break">an email.</span></li>
				<li>The website (server) might then send a response back to you, such as a confirmation message or a new page <span class="No-Break">to see.</span></li>
			</ol>
			<p>Think of it<a id="_idIndexMarker080"/> like sending a package to a friend. You wouldn’t just leave it on their doorstep; you’d package it and send it through a reliable service. Similarly, the POST method allows you to securely send information to <span class="No-Break">a website.</span></p>
			<p>It’s crucial to remember that the POST method is primarily used for sending and processing information, not just for viewing it. Unlike GET, which retrieves information, POST typically triggers actions on <span class="No-Break">the server.</span></p>
			<h3>PUT</h3>
			<p>We use<a id="_idIndexMarker081"/> the HTTP PUT method to update the existing information on <span class="No-Break">the server.</span></p>
			<p>Think of PUT as a way to carefully update existing information on a website (server). It’s like carefully revising a document or updating your <span class="No-Break">profile details.</span></p>
			<p>Here’s a breakdown of how <span class="No-Break">it works:</span></p>
			<ol>
				<li>You (the client, like your web browser) prepare the updated information, for example, changes to your profile picture or edited text in <span class="No-Break">a document.</span></li>
				<li>Your browser sends a request to the website (server) using the PUT method. This request includes the updated information <span class="No-Break">you prepared.</span></li>
				<li>The website (server) receives the request and understands what needs to be updated because of the <span class="No-Break">PUT method.</span></li>
				<li>The server carefully replaces the existing information with the updated version that you sent. This is similar to carefully replacing a page in a book with a <span class="No-Break">revised version.</span></li>
				<li>The website (server) might then send a response back to you, such as a confirmation message or the updated <span class="No-Break">information itself.</span></li>
			</ol>
			<p>It’s important to remember that using PUT requires caution and accuracy because it directly modifies existing information. Think of it like carefully editing a document; making a mistake could result in changing or losing <span class="No-Break">important information.</span></p>
			<p>The PUT method is typically used when you know exactly what information needs to be updated and you want to replace it completely. It’s not for retrieving information like GET or creating new information <span class="No-Break">like POST.</span></p>
			<h3>DELETE</h3>
			<p>The HTTP DELETE method <a id="_idIndexMarker082"/>acts like a digital eraser, carefully removing a specific piece of information from a server. You can think of it as deleting a single item from your shopping list, leaving the <span class="No-Break">rest untouched.</span></p>
			<p>Here’s how <span class="No-Break">it works:</span></p>
			<ol>
				<li>You (the client), like your web browser, decide to remove something specific, such as an old photo or an <span class="No-Break">outdated article.</span></li>
				<li>Your browser sends a DELETE request to the server, pinpointing the exact item that you want to remove. This is like pointing your finger at the item on your <span class="No-Break">shopping list.</span></li>
				<li>The server receives the request and understands the intention because of the <span class="No-Break">DELETE method.</span></li>
				<li>The server carefully removes the specified item from its storage, similar to crossing off the item on <span class="No-Break">your list.</span></li>
			</ol>
			<p>The server might reply with a confirmation message letting you know that the deletion happened successfully, or simply <span class="No-Break">remain silent.</span></p>
			<p>You should remember that using DELETE is like using an eraser: it’s permanent. Once something is gone, it’s usually gone for good. So, be sure that you truly want to remove the item before sending the <span class="No-Break">DELETE request.</span></p>
			<p>DELETE is different from other methods. Unlike GET (used for getting information) or POST (used for creating new information), DELETE specifically <span class="No-Break">removes something.</span></p>
			<p>It’s important to be precise with DELETE requests, as they target a specific item and cannot be <span class="No-Break">undone easily.</span></p>
			<h3>PATCH</h3>
			<p>The <a id="_idIndexMarker083"/>PATCH method acts like a touch-up tool for information on a server. It’s similar to the PUT method, but PATCH lets you update certain parts of the information, like editing specific sections of a document without changing the <span class="No-Break">whole thing.</span></p>
			<p>Imagine that you have a shopping list with items like bread, milk, and eggs. You realize that you need more milk, but everything else is fine. Instead of rewriting the entire list, you can use PATCH to update just the milk quantity. This way, the rest of the list stays <span class="No-Break">the same.</span></p>
			<p>Here’s <span class="No-Break">the breakdown:</span></p>
			<ol>
				<li>You (the user) decide to change a specific part of something, such as updating the price of an <span class="No-Break">item online.</span></li>
				<li>You send a PATCH request to the server, pointing out the exact part you want to modify, such as the price in <span class="No-Break">our example.</span></li>
				<li>The server understands the request because of the <span class="No-Break">PATCH method.</span></li>
				<li>The server carefully updates only the chosen part, leaving the rest untouched, similar to editing just one section of <span class="No-Break">a document.</span></li>
				<li>The server might then send confirmation or simply show the <span class="No-Break">updated information.</span></li>
			</ol>
			<p>Take note that PATCH is a method for making targeted updates, modifying only specific parts of a resource. It’s useful when you only want to change specific parts of something, keeping the rest the same. This makes it more flexible and efficient than completely rewriting everything like with the <span class="No-Break">PUT method.</span></p>
			<p>Now that we understand the HTTP verbs, let’s move onto the HTTP <span class="No-Break">status codes.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor034"/>HTTP response status codes</h2>
			<p>HTTP<a id="_idIndexMarker084"/> uses client-server<a id="_idIndexMarker085"/> architecture. Sending requests always ends with a response. Depending on the request, you may end up with different response status codes that indicate the result of <span class="No-Break">the operation.</span></p>
			<p>HTTP status codes are responses from the server indicating the success or failure of your request.These codes are organized into five <span class="No-Break">main groups:</span></p>
			<ul>
				<li>Informational responses (<strong class="source-inline">100</strong> – <span class="No-Break"><strong class="source-inline">199</strong></span><span class="No-Break">)</span></li>
				<li>Successful responses (<strong class="source-inline">200</strong> – <span class="No-Break"><strong class="source-inline">299</strong></span><span class="No-Break">)</span></li>
				<li>Redirection messages (<strong class="source-inline">300</strong> – <span class="No-Break"><strong class="source-inline">399</strong></span><span class="No-Break">)</span></li>
				<li>Client error responses (<strong class="source-inline">400</strong> – <span class="No-Break"><strong class="source-inline">499</strong></span><span class="No-Break">)</span></li>
				<li>Server error responses (<strong class="source-inline">500</strong> – <span class="No-Break"><strong class="source-inline">599</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Let’s cover the <a id="_idIndexMarker086"/>most used HTTP response <span class="No-Break">status codes:</span></p>
			<ul>
				<li><strong class="bold">Success </strong>(codes starting <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">):</span><ul><li><strong class="bold">200 OK</strong>: This is the best message you can get! It means that the server understood your request and did what <span class="No-Break">you asked.</span></li><li><strong class="bold">201 Created</strong>: This code means that your request resulted in creating something new, such as a new document <span class="No-Break">or account.</span></li></ul></li>
				<li><strong class="bold">Redirects</strong> (codes starting <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">):</span><ul><li><strong class="bold">301 Moved Permanently</strong>: This tells you that the requested item has been moved to a new location permanently. The server usually gives you the <span class="No-Break">new address.</span></li><li><strong class="bold">302 Found</strong>: This code means that the requested item is temporarily at a new location. The server also provides the <span class="No-Break">new address.</span></li></ul></li>
				<li><strong class="bold">Client Errors</strong> (codes starting <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">):</span><ul><li><strong class="bold">404 Not Found</strong>: This is a common code indicating that the server couldn’t find the item you requested, like a missing book in <span class="No-Break">a library.</span></li><li><strong class="bold">401 Unauthorized</strong>: This code indicates that you are not allowed to access the requested item, like trying to enter a <span class="No-Break">locked room.</span></li><li><strong class="bold">403 Forbidden</strong>: This code means that you are authorized but don’t have permission to access the specific item, like having a key but not being allowed into a <span class="No-Break">specific room.</span></li><li><strong class="bold">413 Request Entity Too Large</strong>: This code indicates that the data you sent in your request is too large for the server to handle, like trying to fit too many books into a <span class="No-Break">small box.</span></li><li><strong class="bold">429 Too Many Requests</strong>: This code means you’ve made too many requests in a short period of time, like trying to borrow too many books <span class="No-Break">at once.</span></li></ul></li>
				<li><strong class="bold">Server Errors</strong> (codes starting <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">):</span><ul><li><strong class="bold">500 Internal Server Error</strong>: This code means that the computer encountered an internal <a id="_idIndexMarker087"/>problem and couldn’t fulfill your request, like a library experiencing <span class="No-Break">technical issues.</span></li><li><strong class="bold">503 Service Unavailable</strong>: This code indicates that the computer is temporarily unavailable due to maintenance or overload, like a library being closed <span class="No-Break">for renovation.</span></li></ul></li>
			</ul>
			<p>Remember, these are just a few examples but understanding them can help you decode the messages from websites and navigate the online world <span class="No-Break">more smoothly.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor035"/>Introduction to GraphQL</h2>
			<p>The two<a id="_idIndexMarker088"/> main <a id="_idIndexMarker089"/>ways in which we design and work with APIs nowadays are using REST <span class="No-Break">and </span><span class="No-Break"><strong class="bold">GraphQL</strong></span><span class="No-Break">.</span></p>
			<p>Usually, when developers begin their journey in API development, they start by making a REST API. However, as they dive deeper into the specifics, they realize that the REST approach doesn’t always work perfectly for every situation. GraphQL then steps in to help when REST isn’t the <span class="No-Break">best fit.</span></p>
			<p>Even though Facebook started using GraphQL in real projects as early as 2012, when it was still called SuperGraph, it wasn’t shared with the public <span class="No-Break">until 2016.</span></p>
			<p>Today, GraphQL has become the preferred method for designing and interacting with APIs, surpassing REST <span class="No-Break">in popularity.</span></p>
			<p>The primary reason for adopting GraphQL was to tackle the issues that arose when both the mobile and desktop versions of an application utilized the same API, specifically the REST API. Say you’re using a website on your mobile device. The desktop version can handle larger amounts of data, so it receives a more comprehensive dataset from the server. Unlike desktop versions, mobile apps have limits on data use because of slow connections and less processing power, making it impossible to handle large <span class="No-Break">data sets.</span></p>
			<p>Here’s an <a id="_idIndexMarker090"/>example of a REST response that contains excessive data for mobile needs, where we only require a portion of <span class="No-Break">the information:</span></p>
			<pre class="console">
{
  "user": {
    "id": 5,
    "name": "username",
    "surname": "surname",
    "rank": 56,
    "email": "example@gmail.com",
    "profilephoto": "....................."
  }
}</pre>			<p>So, when the user data is loaded for the first time, we only need a part of this data in the mobile version. For this reason, the resource-based distribution of the data (using REST) seems to be an ideal choice for design. Since there is no problem with internet availability for most desktop users, there is no problem with receiving data from different resources and displaying them as a single piece <span class="No-Break">of information.</span></p>
			<p>To ensure that we get only the required information, we filter the data based on its <strong class="bold">ID</strong>. In doing so, we conduct a kind of <span class="No-Break">synchronous operation.</span></p>
			<p>However, we are not suggesting an ideal solution for mobile data retrieval. Instead, we propose either developing a separate API specifically for mobile devices or implementing a more flexible and dynamic resource fetching mechanism by adopting an alternative approach to RESTGraphQL offers a more efficient approach to API interaction and design, especially when considering mobile and other resource-constrained devices. Originally intended for mobile use, GraphQL has evolved to support dynamic and effective data exchange across various platforms. Unlike traditional REST API design, GraphQL enables the synchronous retrieval of information from multiple resources in a single query, eliminating the need to fetch data resource <span class="No-Break">by resource.</span></p>
			<p>In addition to its <a id="_idIndexMarker091"/>application in mobile development, GraphQL is now extensively utilized in microservice design, further showcasing its versatility and widespread adoption in modern software <span class="No-Break">development practices.</span></p>
			<p>Understanding the <a id="_idIndexMarker092"/>differences between REST and GraphQL is important<a id="_idIndexMarker093"/> when it comes to applying them in practice. Let’s define the main differences between these two powerful <span class="No-Break">communication techniques:</span></p>
			<ul>
				<li>Mobile apps need slim and efficient data compared to desktop apps. REST APIs, which are often used for desktops, can be bulky for mobile. GraphQL solves this by letting you request only the specific data your app needs, avoiding unnecessary downloads while reducing over-fetching <span class="No-Break">and under-fetching.</span></li>
				<li>REST works by focusing on individual pieces of information such as <em class="italic">users</em> or posts. To get related details, such as information about a specific user’s posts, you need to make separate requests for each piece. This can feel slow because you have to wait for one request to finish before making the next. Long story short, REST APIs typically deliver one set of information for each access point. In contrast, GraphQL allows you to request various data combinations from a single point, making it more flexible <span class="No-Break">and adaptable.</span></li>
				<li>Gathering information from multiple sources in REST requires separate requests, which can sometimes cause delays. GraphQL, however, lets you grab data from various sources in one go, presenting it to the user as a single unit. This reduces the number of requests and makes your app <span class="No-Break">feel smoother.</span></li>
				<li>Updating a REST API often involves versioning it to avoid breaking existing apps. GraphQL avoids this complexity by allowing additions without requiring changes on the app side, making it easier to keep things up <span class="No-Break">to date.</span></li>
				<li>Unlike REST, which focuses on managing specific pieces of data, GraphQL is built with mobile and frontend experiences in mind. This means it allows you to do <span class="No-Break">the following:</span><ul><li> Get<a id="_idIndexMarker094"/> only the data your app needs, reducing the amount of information transferred (smaller <span class="No-Break">payload size)</span></li><li>Avoid unnecessary requests by fetching everything in one go, making your app faster and <span class="No-Break">more efficient</span></li></ul></li>
				<li>REST APIs<a id="_idIndexMarker095"/> struggle with frequent changes because their structure is fixed. Imagine an endpoint that can receive many different instructions or give answers in various formats. This can cause issues with REST. GraphQL, however, handles these situations <span class="No-Break">much better.</span></li>
				<li>In microservice architectures, where each service manages its own data, GraphQL shines. It allows you to combine information from multiple services in a single request, presenting it as one unified piece of data to the user. This makes building and managing complex applications <span class="No-Break">much easier.</span></li>
				<li>When developing a single-page or native mobile app, GraphQL’s principles of “give only the information that the user needs” and “focus on a single unified resource” allow us to develop <span class="No-Break">frontend-heavy applications.</span></li>
				<li>Under GraphQL, the frontend team can work on their tasks (user stories) without waiting for the backend team to create specific REST endpoints. This allows for faster progress and quicker <span class="No-Break">app updates.</span></li>
				<li>RESTful APIs employ HTTP methods like PUT, DELETE, POST, and PATCH for data modification, collectively termed mutations in GraphQL. On the other hand, GraphQL utilizes a Query operation for <span class="No-Break">retrieving data.</span></li>
			</ul>
			<p>In most scenarios, having REST and GraphQL will be enough for you. However, they are not the only communication mechanisms for your microservices. We have another interesting communication protocol called a <strong class="bold">Remote Procedure Call</strong> (<strong class="bold">RPC</strong>). Let’s <span class="No-Break">dive in.</span></p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor036"/>Remote Procedure Call</h2>
			<p>Another<a id="_idIndexMarker096"/> communication protocol that we can use when establishing communication between microservices <a id="_idIndexMarker097"/>is RPC. Using RPC, one microservice can request a service from another microservice that is located in another computer on a given network without  understanding the <span class="No-Break">network details.</span></p>
			<p>RPC is a method for these microservices to talk. It’s like one program asking another program on a different computer to do something, even though they aren’t directly connected. This makes it easier for the microservices to <span class="No-Break">work together.</span></p>
			<p>Let’s define the core <span class="No-Break">RPC flow:</span></p>
			<ol>
				<li>Imagine a <a id="_idIndexMarker098"/>microservice asking another microservice on a different computer to run a specific function (such as a task). This request is disguised as a normal function call, even though it’s happening over <span class="No-Break">a network.</span></li>
				<li>A middleman service (called a proxy) intercepts this request and takes care of the complex network communication behind <span class="No-Break">the scenes.</span></li>
				<li>The proxy sends a message containing the details of the function and any required data to the <span class="No-Break">target microservice.</span></li>
				<li>The target microservice receives the message, understands the function request, and <span class="No-Break">executes it.</span></li>
				<li>Once it is done, it sends a response message back through <span class="No-Break">the proxy.</span></li>
				<li>Finally, the proxy delivers the response to the requesting microservice, making it seem like a regular <span class="No-Break">function call.</span></li>
			</ol>
			<p>This flow sounds familiar, doesn’t it? That is because it is just a simple client-server mechanism. With the meaning and flow of RPC made clear, it’s time to understand some of its other <span class="No-Break">important aspects</span><span class="No-Break">.</span></p>
			<h3>Benefits and considerations of RPC</h3>
			<p>What about <a id="_idIndexMarker099"/>the benefits of RPC for microservices? Let’s emphasize the <span class="No-Break">main points:</span></p>
			<ul>
				<li><strong class="bold">Easier development</strong>: Using RPC is like making normal function calls, which programmers are already familiar with. This makes it simpler to build microservices because developers don’t need to worry about the technical details of <span class="No-Break">network communication.</span></li>
				<li><strong class="bold">Potentially faster</strong>: RPC can be faster than other methods because it uses pre-defined data formats specifically designed for these calls, instead of needing to interpret complex formats like JSON <span class="No-Break">or XML.</span></li>
			</ul>
			<p>What are some<a id="_idIndexMarker100"/> important things that you need to consider <span class="No-Break">with RPC?</span></p>
			<p>Let’s <span class="No-Break">see here:</span></p>
			<ul>
				<li><strong class="bold">Tight connections</strong>: RPC can make microservices more reliant on each other. If one microservice changes the way its functions work (their interface), it can affect all the other microservices that rely <span class="No-Break">on it.</span></li>
				<li><strong class="bold">Limited flexibility</strong>: Choosing a specific RPC framework might make it harder to switch to a different <span class="No-Break">one later.</span></li>
			</ul>
			<p>In conclusion, RPC is a powerful tool for microservices to talk to each other. It simplifies development and can be fast, but you should keep in mind the potential downsides of tighter connections and limited flexibility when deciding whether it’s the right choice for <span class="No-Break">your project.</span></p>
			<h3>Tools for RPC</h3>
			<p>There are<a id="_idIndexMarker101"/> special programs called RPC frameworks built specifically to make communication between microservices smoother. These frameworks act like toolkits that simplify the process. Here are a few <span class="No-Break">popular ones:</span></p>
			<ul>
				<li><strong class="bold">gRPC</strong>: This<a id="_idIndexMarker102"/> framework focuses on making things fast and efficient. It uses a special format <a id="_idIndexMarker103"/>called <strong class="bold">Protocol Buffers</strong> to package data in a way that’s compact and easy <span class="No-Break">to transmit.</span></li>
				<li><strong class="bold">Apache Thrift</strong>: Another <a id="_idIndexMarker104"/>popular option, Thrift is known for working with many different programming languages and can handle various data <span class="No-Break">packaging formats.</span></li>
				<li><strong class="bold">SOAP</strong>: Provides<a id="_idIndexMarker105"/> a standardized way to encode messages using XML and transport them using mostly HTTP and HTTPs protocols . We can use SOAP to implement RPC. This allows applications to call procedures on remote servers as if they were local procedures. But we should take into account that SOAP is not limited to RPC and can be used for more general message exchange processes <span class="No-Break">as well.</span></li>
				<li><strong class="bold">Windows Communication Foundation</strong> (<strong class="bold">WCF</strong>): WCF is a framework developed<a id="_idIndexMarker106"/> by Microsoft for building service-oriented applications. It can be used to implement <a id="_idIndexMarker107"/>various communication mechanisms, including RPCs. WCF provides a lot more functionality than just RPC. It offers features such as data contracts, service hosting, and security. So, while WCF can be used for RPC, it’s not limited to that <span class="No-Break">specific approach.</span></li>
			</ul>
			<p>RPC is a powerful way for microservices to communicate. It makes development easier and can be faster than other methods. However, remember the potential drawbacks of tighter connections and limited flexibility when deciding whether it’s the best choice for your project. Weigh the pros and cons carefully to make the right call for your <span class="No-Break">specific needs.</span></p>
			<p>After discussing the general idea behind the communication protocols, it is time to talk about communication methods for microservices. Understanding the strengths and weaknesses of each approach is essential for designing robust and scalable <span class="No-Break">microservice architectures.</span></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor037"/>Synchronous microservice communication</h1>
			<p>To <a id="_idIndexMarker108"/>exchange<a id="_idIndexMarker109"/> some information between microservices, they need to be able to talk to each other. In microservice communication, we mostly use two main patterns to establish communication between microservices. They are <strong class="bold">Synchronous Communication</strong> (<strong class="bold">sync</strong>) and <strong class="bold">Asynchronous </strong><span class="No-Break"><strong class="bold">Communication</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">async</strong></span><span class="No-Break">).</span></p>
			<p>Sync is the easiest of the two <span class="No-Break">communication patterns.</span></p>
			<p>When one <a id="_idIndexMarker110"/>microservice <a id="_idIndexMarker111"/>needs information from another, it makes a direct request and waits for an answer before moving forward. The communication by itself is simpler and more reliable. It is just a function or method call if you compare it to a <span class="No-Break">monolith application)</span></p>
			<p>Here’s a breakdown of <span class="No-Break">the steps:</span></p>
			<ol>
				<li>The calling microservice sends a message to <span class="No-Break">another microservice.</span></li>
				<li>The calling microservice pauses its work and waits for <span class="No-Break">a reply.</span></li>
				<li>The other microservice processes the request and sends a <span class="No-Break">response back.</span></li>
				<li>Once the calling microservice has received the response, it can continue <span class="No-Break">its task.</span></li>
			</ol>
			<p>We mostly use REST, GraphQL, and gRPC when implementing sync between microservices that rely <span class="No-Break">on HTTP.</span></p>
			<p>This image shows a simple synchronous communication between Order API and <span class="No-Break">Stock API.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer018">
					<img alt="Figure 2.5: Synchronous microservice communication" src="image/B09148_02_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5: Synchronous microservice communication</p>
			<p>Let’s now see some important aspects <span class="No-Break">of sync.</span></p>
			<p>Some of its <a id="_idIndexMarker112"/>advantages are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Simple and predictable</strong>: The flow of execution <span class="No-Break">is straightforward.</span></li>
				<li><strong class="bold">Immediate feedback</strong>: The requestor receives the response immediately, making it suitable<a id="_idIndexMarker113"/> for <span class="No-Break">interactive applications.</span></li>
			</ul>
			<p>Of course, as we learned before, nothing is without its downsides. This communication form also brings some <a id="_idIndexMarker114"/>disadvantages to <span class="No-Break">the table:</span></p>
			<ul>
				<li><strong class="bold">Blocking</strong>: The requestor is blocked until the response arrives, which can lead to performance issues if the receiving service takes a <span class="No-Break">long time.</span></li>
				<li><strong class="bold">Coupling</strong>: Services become tightly coupled, making them more difficult to change and <span class="No-Break">scale independently.</span></li>
				<li><strong class="bold">Single point of failure</strong>: If the responding microservice is unavailable, the entire process <span class="No-Break">gets blocked.</span></li>
			</ul>
			<p>After <a id="_idIndexMarker115"/>having understood the flow of this communication and some of its advantages and disadvantages, it’s also important to see how we might apply this to some <span class="No-Break">real-world situations.</span></p>
			<p>Here are some<a id="_idIndexMarker116"/> real-world examples of sync <span class="No-Break">in microservices:</span></p>
			<ul>
				<li><strong class="bold">Shopping cart</strong>: Imagine you fill your cart online and hit pay. The cart service (like your shopping list) talks directly to the payment service (like the cashier) to confirm payment before creating the order. This way, you know right away whether the payment <span class="No-Break">went through.</span></li>
				<li><strong class="bold">Catching cheaters</strong>: When you place an order online, the order service (like the order taker) asks the fraud checker (like security guard) to see whether it’s okay. The checker says yes or no right away, so only real orders <span class="No-Break">go through.</span></li>
				<li><strong class="bold">Live chat </strong><strong class="bold">support</strong>: When you type a message in a chat, your message goes to a service that finds an agent (like finding a helper). The agent gets your message and replies directly, so you can chat back and <span class="No-Break">forth quickly.</span></li>
				<li><strong class="bold">Online games</strong>: In online games, your actions are sent to a game server (like the game referee). The server updates the game world (like changing the score) based on your actions <a id="_idIndexMarker117"/>and sends it back to everyone playing, keeping the game smooth <span class="No-Break">for all.</span></li>
				<li><strong class="bold">Stock trading</strong>: When you buy or sell stocks on an app, it talks directly to a service at your brokerage (like your investment person). This service makes the trade right away, tells the app that it’s done, and updates your account balance. This gives you quick confirmation so you can manage <span class="No-Break">your money.</span></li>
			</ul>
			<p>These <a id="_idIndexMarker118"/>are just a few examples, and in general, you should understand that sync is ideal when you need any of <span class="No-Break">the following:</span></p>
			<ul>
				<li>Immediate feedback <span class="No-Break">and interaction</span></li>
				<li><span class="No-Break">Real-time dialogue</span></li>
				<li>Real-time decision-making <span class="No-Break">and execution</span></li>
				<li>Just-in-time analysis <span class="No-Break">and implementation</span></li>
				<li>Tightly coupled workflows with <span class="No-Break">high dependency</span></li>
			</ul>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor038"/>Asynchronous microservice communication</h1>
			<p>Sync is<a id="_idIndexMarker119"/> like having a<a id="_idIndexMarker120"/> direct conversation, but async is more like leaving a message. Microservices don’t wait for a reply, they just send the information and <span class="No-Break">move on.</span></p>
			<p>In asynchronous communication, the requesting service sends a message to the receiving service without waiting for an immediate response. The response is delivered later, either through a callback or through a <span class="No-Break">separate channel.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer019">
					<img alt="Figure 2.6: Asynchronous microservice communication" src="image/B09148_02_006.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6: Asynchronous microservice communication</p>
			<p>Here’s a breakdown<a id="_idIndexMarker121"/> of <span class="No-Break">the steps:</span></p>
			<ol>
				<li><strong class="bold">Send a message</strong>: The calling microservice sends a message with the information to <span class="No-Break">another microservice.</span></li>
				<li><strong class="bold">Move on</strong>: The calling microservice doesn’t wait for a reply. It continues its <span class="No-Break">own task.</span></li>
				<li><strong class="bold">Process later</strong>: The other microservice receives the message and works on it whenever <span class="No-Break">it’s free.</span></li>
				<li><strong class="bold">Reply</strong>: The other microservice might send a response back later, but that’s <span class="No-Break">not required.</span></li>
			</ol>
			<p>Think of it like leaving a note for someone – they can get to it when they have <span class="No-Break">a chance.</span></p>
			<p>In most cases, we use a message broker to handle async <span class="No-Break">between microservices.</span></p>
			<p>For<a id="_idIndexMarker122"/> complex communication patterns, high message volume, or critical tasks, a message broker is a good choice. For simpler scenarios where reliability is less crucial, direct queues or event sourcing can be better alternatives to a <span class="No-Break">message broker.</span></p>
			<p>Let’s cover the most important<a id="_idIndexMarker123"/> advantages of using async <span class="No-Break">between microservices:</span></p>
			<ul>
				<li><strong class="bold">Non-blocking</strong>: The requester can continue processing without waiting for the response, improving performance <span class="No-Break">and scalability.</span></li>
				<li><strong class="bold">Decoupling</strong>: Services are loosely coupled, making them easier to change and <span class="No-Break">scale independently.</span></li>
				<li><strong class="bold">Resilience</strong>: Async can handle failures and retries more gracefully <span class="No-Break">than sync.</span></li>
				<li><strong class="bold">Independent work</strong>: Microservices<a id="_idIndexMarker124"/> can focus on their own tasks without worrying about others <span class="No-Break">being busy.</span></li>
			</ul>
			<p>However, it also<a id="_idIndexMarker125"/> has <span class="No-Break">some drawbacks:</span></p>
			<ul>
				<li><strong class="bold">Delayed results</strong>: You might not know whether the message was received or processed <span class="No-Break">right away.</span></li>
				<li><strong class="bold">More complex</strong>: Setting up async can be trickier than sync. Sync doesn’t require an additional layer when establishing communication. However, as I mentioned before, for true async you mostly need to use a message broker as middleware between <span class="No-Break">communicated services.</span></li>
			</ul>
			<p>Next, let us<a id="_idIndexMarker126"/> look at <a id="_idIndexMarker127"/>some practical applications of this type <span class="No-Break">of communication:</span></p>
			<ul>
				<li><strong class="bold">Sending emails</strong>: The order service can send an order confirmation email without waiting for it to <span class="No-Break">be sent.</span></li>
				<li><strong class="bold">Updating inventory</strong>: When a sale is made, the order service can send a message to update the inventory. It can keep processing other orders in <span class="No-Break">the meantime.</span></li>
				<li><strong class="bold">Long-running tasks</strong>: A microservice can send a message to another service to do a time-consuming job, such as video encoding, without being <span class="No-Break">stuck waiting.</span></li>
				<li><strong class="bold">Social media feed updates</strong>: Post service publishes a message to the feed queue. The feed service subscribes to the queue and updates user feeds in <span class="No-Break">the background.</span></li>
			</ul>
			<p>It is better to choose to use async between microservices when any of the following <span class="No-Break">conditions apply:</span></p>
			<ul>
				<li>An immediate response is <span class="No-Break">not essential</span></li>
				<li>Background tasks or long-running processes <span class="No-Break">are needed</span></li>
				<li>Decoupling and scalability are <span class="No-Break">key considerations</span></li>
			</ul>
			<p>Async is great for tasks that don’t need immediate answers, but sync might be better for things that need a <span class="No-Break">quick response.</span></p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor039"/>Essential communication patterns</h1>
			<p>When <a id="_idIndexMarker128"/>building microservices, we mostly need a single point of entry for our clients to consume the services that we develop. You may think about it like a decorator or wrapper over your services. Clients talk to your app through a simple door (API gateway) instead of needing to know the messy inner workings (microservices). The gateway intelligently routes incoming requests to the appropriate microservices based on factors such as URL patterns, path variables, <span class="No-Break">or headers.</span></p>
			<p>An important component of microservice architecture is an API gateway. This API offers several features to help manage and expose common functionalities across multiple microservices. Often, a client request might require data from multiple microservices. The gateway acts as an orchestrator, fetching data from relevant services, aggregating it (if necessary), and returning a cohesive response to the client. In short, API gateways are essential components of microservice architecture. They provide a single point of entry for clients, enhancing security and manageability, as well as the overall effectiveness of <span class="No-Break">your microservices)</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer020">
					<img alt="Figure 2.7: An API gateway" src="image/B09148_02_007.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7: An API gateway</p>
			<p>Now, let’s try to<a id="_idIndexMarker129"/> summarize the benefits of <span class="No-Break">API gateways:</span></p>
			<ul>
				<li><strong class="bold">Single entry point</strong>: There<a id="_idIndexMarker130"/> is no need to understand the internals of microservices. Using an API gateway helps you to be isolated from <span class="No-Break">such details.</span></li>
				<li><strong class="bold">Request routing</strong>: An API gateway acts as smart middleware to route queries from the users to the <span class="No-Break">exact microservices</span></li>
				<li><strong class="bold">Aggregator</strong>: The gateway acts as an orchestrator, fetching data from relevant services, aggregating it (if necessary), and returning a cohesive response to <span class="No-Break">the client.</span></li>
				<li><strong class="bold">Security</strong>: The gateway can be a central hub for authentication, authorization, and rate limiting. It verifies client identities, enforces access controls, and prevents <span class="No-Break">potential abuse.</span></li>
				<li><strong class="bold">Transformation</strong>: The gateway can manipulate requests and responses to match the expected formats of backend services or tailor responses for clients. This includes tasks such as content negotiation, protocol translation, and <span class="No-Break">data validation.</span></li>
				<li><strong class="bold">Common tasks</strong>: The <a id="_idIndexMarker131"/>gateway can handle common tasks such as request validation, caching, and logging, reducing the burden on <span class="No-Break">individual microservices.</span></li>
				<li><strong class="bold">Load balancing</strong>: When there’s a lot of work to be done (heavy traffic), load balancing acts like a traffic director. It cleverly distributes incoming requests across multiple copies (instances) of the same microservice. No single microservice gets overwhelmed, making the best use of all <span class="No-Break">available resources.</span></li>
				<li><strong class="bold">Circuit breaker</strong>: An API gateway often contains a circuit breaker for resiliency, cascading failure, and protecting system’s stability. A circuit breaker in microservices is like a switch that automatically stops sending requests to a service if it’s not responding well, helping prevent <span class="No-Break">system-wide failures.</span></li>
			</ul>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor040"/>Message brokers</h1>
			<p>In a<a id="_idIndexMarker132"/> direct communication model, microservices would have to be aware of each other’s locations and availabilities. This creates a tightly coupled system that’s difficult to maintain <span class="No-Break">and update.</span></p>
			<p>By introducing a <a id="_idIndexMarker133"/>message broker, microservices become loosely coupled. They simply send messages to the broker, which handles the routing and delivery. This allows microservices to operate independently without needing to know the specifics of <span class="No-Break">other services.</span></p>
			<p>With message brokers, communication becomes asynchronous. A producer (microservice) can send a message without waiting for a response from the consumer (another microservice). This improves performance and scalability as microservices don’t have to wait on <span class="No-Break">each other.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer021">
					<img alt="Figure 2.8: Message brokers" src="image/B09148_02_008.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8: Message brokers</p>
			<p>Message brokers <a id="_idIndexMarker134"/>use different <a id="_idIndexMarker135"/>message storage models. The most popular ones are <strong class="bold">Message Queues</strong> (<strong class="bold">MQs</strong>) and <a id="_idIndexMarker136"/><strong class="bold">Topic.</strong> Message brokers store messages in an MQ until they are received by consumers. MQs are a crucial part of message brokers that act as storage for the data. Unlike Topic, they delete data after the <span class="No-Break">consuming process.</span></p>
			<p>Let’s try to understand<a id="_idIndexMarker137"/> the components of a typical <span class="No-Break">message broker:</span></p>
			<ul>
				<li><strong class="bold">Producer (Publisher)</strong>: This is the one that sends <span class="No-Break">a message.</span></li>
				<li><strong class="bold">Consumer (Subscriber)</strong>: This is the one that reads <span class="No-Break">a message.</span></li>
				<li><strong class="bold">MQ (or Topic)</strong>: This is the one that stores the message. Topic allows for a publish-subscribe model, whereby multiple consumers can receive the same message. On the other hand, MQ queue follows a <strong class="bold">First-In, First-Out</strong> (<strong class="bold">FIFO</strong>) approach, ensuring<a id="_idIndexMarker138"/> messages are processed in the order in which they <span class="No-Break">are received.</span></li>
			</ul>
			<p>There are a lot of popular<a id="_idIndexMarker139"/> message broker implementations out there. In practice, we will use Apache Kafka, one of the most popular message brokers. Let’s <a id="_idIndexMarker140"/>talk about the most popular message <span class="No-Break">broker implementations:</span></p>
			<ul>
				<li><strong class="bold">RabbitMQ</strong>: This<a id="_idIndexMarker141"/> is an open source message broker that is widely known for its flexibility and ease of use. It supports different messaging patterns, including point-to-point (only one specific application receives a message) and <strong class="bold">Publisher and Subscriber</strong> (<strong class="bold">pub/sub</strong>). It acts as a central post office for your<a id="_idIndexMarker142"/> applications. Apps can send and receive messages without needing to know each other’s exact addresses. It helps us to have tightly coupled communication. It is flexible, easy to use, and has a <span class="No-Break">large community.</span></li>
				<li><strong class="bold">Apache Kafka</strong>: It is a<a id="_idIndexMarker143"/> powerful option to implement a message broker. It has crucial attributes such as high throughput, durability, scalability, fault tolerance, real-time processing, and many others. Apache Kafka is more than a message broker with data storage and stream processing integration. We will talk more about the internals of Kafka in the <span class="No-Break">next chapters.</span></li>
				<li><strong class="bold">Amazon Simple Queue Service</strong> (<strong class="bold">SQS</strong>): Like other message broker implementations, it provides decouple and scale microservices. SQS acts as a queue<a id="_idIndexMarker144"/> where you can send messages (data), store them securely, and then retrieve them via other applications or services. SQS decouples applications by enabling them to communicate asynchronously. The sender doesn’t need to wait for the receiver to be available, improving overall application responsiveness <span class="No-Break">and scalability.</span></li>
			</ul>
			<p>If you need real-time stream processing, Apache Kafka might be a better option for you rather than RabbitMQ and SQS. On the other hand, if you like to have advanced features such as message filtering or priority queues, use RabbitMQ <span class="No-Break">over SQS.</span></p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor041"/>Summary</h1>
			<p>This chapter was about microservice communication. We talked about different communication techniques such as REST, GraphQL, <span class="No-Break">and RPC.</span></p>
			<p>We discussed the fact that we mostly use two types of communication forms between microservices: synchronous and asynchronous. Sync is simple and has immediate feedback, but it is a blocking operation with attributes such as a single point of failure and coupling. We talked about the advantages and disadvantages of sync and discussed when to and when not to use it <span class="No-Break">in practice.</span></p>
			<p>On the other hand, we learned that async is non-blocking and comes with delayed responses. It is mostly preferable (depending on the task) but brings additional complexity. To make async happen, we learned that we mostly need additional layers like <span class="No-Break">message brokers.</span></p>
			<p>The last part of the discussion was centered around the most used patterns such as API gateway and <span class="No-Break">message broker.</span></p>
			<p>API gateway, as an orchestrator, provides a single point of entry with additional functionalities such as security, transformation, load balancing, and so on. It is an essential part of <span class="No-Break">microservice communication.</span></p>
			<p>We further learned about establishing async. Using message broker, we mostly establish async between microservices. It is an additional layer between services that handles common tasks (depending on message broker implementation). It has multiple implementations such as RabbitMQ, Apache Kafka, Amazon SQS, and <span class="No-Break">so on.</span></p>
			<p>Starting from the next chapter, we will cover JavaScript and NodeJS essential you need to know before diving into details of microservice development. <span class="No-Break">Stay tuned!</span></p>
		</div>
	</body></html>