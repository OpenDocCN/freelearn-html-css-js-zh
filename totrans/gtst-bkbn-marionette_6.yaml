- en: Chapter 6. Messaging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 消息传递
- en: The previous chapter suggested an architecture that allows your entire application
    to be divided into subapplications and modules. Subapplications are just separate
    parts of your application with functionality that is entirely separate from each
    other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章提出了一种架构，允许将整个应用程序划分为子应用程序和模块。子应用程序只是应用程序的独立部分，它们的功能完全独立。
- en: 'The goal when designing your modules and subapplications is to produce an entire
    system that is integrated but also loosely coupled, and this is where a very well-known
    technique enters the scene: messaging. The concept of messaging, like the divide
    and conquer method, has been around for a long time and developers use these types
    of tools and patterns every day. This pattern tries to provide a way for the components
    to talk to each other through messages, thus allowing modules to subscribe and
    publish events on a common message bus.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模块和子应用程序的目标是创建一个既集成又松散耦合的整个系统，这正是非常著名的技术出现的地方：消息传递。消息传递的概念，就像分而治之的方法一样，已经存在很长时间了，开发者每天都在使用这些类型的工具和模式。这个模式试图提供一个组件通过消息相互交流的方式，从而允许模块在公共消息总线上订阅和发布事件。
- en: 'The topics that will be covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the event aggregator
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解事件聚合器
- en: Using the event aggregator of `Marionette.js`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Marionette.js`的事件聚合器
- en: Making applications more extensive with the event aggregator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件聚合器扩展应用程序
- en: Getting started with `Commands`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用`Commands`
- en: Setting up the `RequestResponse` object
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`RequestResponse`对象
- en: Understanding the event aggregator
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件聚合器
- en: 'According to *Martin Fowler*, an Event Aggregator does the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*Martin Fowler*的说法，事件聚合器执行以下操作：
- en: '"Channels events from multiple objects into a single object to simplify registration
    for clients."'
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “将多个对象的事件通道到一个单一对象中，以简化客户端的注册。”
- en: One of the most useful patterns of modular, scalable, and complex JavaScript
    applications is the event aggregation. The event aggregator functionality is in
    a container for events that allow publishers and subscribers of these events to
    have a channel of communication; however, at the same time, it allows them to
    work independently without the need for code references between them, so they
    can be updated or removed without affecting the others. Having said that, note
    how this decoupling is useful in your modularized applications because new subapps
    and modules can be added to just make use of your current architecture. In our
    composite application design, the event aggregator is a powerful way to implement
    communication among `Marionette.js` objects and we will see how we can integrate
    that in our current code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化、可扩展和复杂JavaScript应用程序中最有用的模式之一是事件聚合。事件聚合器功能位于事件容器中，允许这些事件的发布者和订阅者有一个通信渠道；然而，同时，它还允许它们独立工作，无需它们之间的代码引用，因此它们可以更新或删除而不会影响其他组件。话虽如此，请注意这种解耦在模块化应用程序中的有用性，因为可以添加新的子应用程序和模块，只需利用当前的架构。在我们的复合应用程序设计中，事件聚合器是实现`Marionette.js`对象之间通信的一种强大方式，我们将看到如何在当前代码中集成它。
- en: 'The following is a graphical explanation of the event aggregator:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对事件聚合器的图形解释：
- en: '![Understanding the event aggregator](img/4252OS_06_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![理解事件聚合器](img/4252OS_06_01.jpg)'
- en: Using the event aggregator of Marionette.js
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Marionette.js的事件聚合器
- en: 'The Marionette implementation of the event aggregator pattern made its way
    out of the Marionette core build as it can be found now in a separate distributable
    file called `backbone.wreqr.js`. This implementation extends from the `backbone.events`
    object. The following is an example of how to instantiate an event aggregator:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 事件聚合器模式的Marionette实现已经从Marionette核心构建中分离出来，现在可以在名为`backbone.wreqr.js`的独立可分发文件中找到。这个实现扩展自`backbone.events`对象。以下是如何实例化事件聚合器的一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can start adding listeners that will react to the events triggered:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以开始添加监听器，它们将对触发的事件做出反应：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, you have a listener that will be expecting an event to be triggered.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个监听器，它将等待一个事件的触发。
- en: 'Let''s trigger the `do something` method:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们触发`do something`方法：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: And that's all you need to log the message. Ok, but how can we do this at the
    application level, the `Marionette. An application` object comes with an instance
    of the `Backbone.Wreqr.EventAggregator`. So by instantiating a Marionette application
    object, you can start registering listeners to events without the need of instantiating
    the `EventAggregator` object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有需要记录消息的内容。好吧，但我们在应用级别如何做到这一点呢？`Marionette. An application`对象附带了一个`Backbone.Wreqr.EventAggregator`的实例。因此，通过实例化Marionette应用程序对象，您可以在不需要实例化`EventAggregator`对象的情况下开始注册事件监听器。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following is an example of how to register a listener to an event at the
    application level:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何在应用级别注册事件监听器的示例：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The event publisher can now raise the event anywhere inside the application
    with the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 事件发布者现在可以在应用程序的任何地方使用以下代码触发事件：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we don't have to ask the application to do some work. In this
    case, to show an alert, we should tell the application object that we need to
    be notified when work will execute `MyApp.vent.trigger("helloWorld ")`, which
    will display the message.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们不需要请求应用程序执行某些工作。在这种情况下，为了显示一个警告，我们应该告诉应用程序对象，当工作将要执行时我们需要被通知`MyApp.vent.trigger("helloWorld
    ")`，这将显示消息。
- en: Making applications more extensive with an event aggregator
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件聚合器扩展应用程序
- en: To make this pattern easy to understand, we can use the metaphor of the shopping
    cart app. The user selects an item to be purchased from the book view. The order
    view needs to be notified when a new product is added in order to display it and
    calculate the total.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个模式更容易理解，我们可以使用购物车应用的隐喻。用户从书籍视图中选择要购买的商品。当新商品添加到订单视图中时，需要通知订单视图以显示它并计算总价。
- en: For example, we have multiple ways to complete this functionality and the obvious
    one is to have the order view reference in the book view, so we can either call
    methods or raise events. But then, we will have, for example, a much coupled design
    where you cannot delete the order view without affecting the book view. So now,
    it is time to bring the event aggregator to our application and solve this problem.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们有多种方法来完成这个功能，最明显的方法是在书籍视图中引用订单视图，这样我们就可以调用方法或触发事件。但这样，我们将有一个高度耦合的设计，您不能删除订单视图而不影响书籍视图。因此，现在是时候将事件聚合器引入我们的应用程序并解决这个问题了。
- en: We need a central object that manages the events and the subscribers for those
    events. For this example, we will use a controller. With this controller and the
    event aggregator in place, the views will be decoupled from each other. This means
    that the book view will not contain a reference to the order's view and can be
    changed without design problems.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个中央对象来管理事件及其订阅者。在这个例子中，我们将使用控制器。有了这个控制器和事件聚合器，视图之间将解耦。这意味着书籍视图不会包含订单视图的引用，并且可以修改而不会出现设计问题。
- en: 'The following is the code for adding the controller:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为添加控制器编写的代码：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the controller is initialized, we register the listener for the item added.
    It's expecting to receive parameters from the publisher event and then call the
    local function. The next step is to create the view that is raising the event.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当控制器初始化时，我们注册了添加项目的监听器。它期望从发布者事件接收参数，然后调用本地函数。下一步是创建触发事件的视图。
- en: 'The following is the code for adding the view:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为添加视图编写的代码：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This contains a view with a declared event ; this event is to be called from
    a button located in the view when the `addItem` function is executed. It also
    raised the `App.vent.trigger("itemAdded", this.model)` event; this event is going
    to be handled by the central object, that is, the controller, and call the order
    view. Pretty easy right? In this way, we do not have the order view reference
    here that allows both the views to evolve independently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含一个声明了事件的视图；当执行`addItem`函数时，此事件将由视图中的按钮调用。它还触发了`App.vent.trigger("itemAdded",
    this.model)`事件；此事件将由中央对象，即控制器，处理并调用订单视图。很简单，对吧？这样，我们这里没有订单视图的引用，允许两个视图独立发展。
- en: The following is a graphical explanation of the code that we just explained.
    As you can see, we have the central object, that is, the controller; it contains
    listeners that will raise the event to refresh the order view after the button
    is clicked in the book view. You can also update multiple modules according to
    your business flow.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对我们刚才解释的代码的图形说明。如你所见，我们有一个中心对象，即控制器；它包含监听器，在图书视图中的按钮被点击后，将事件提升以刷新订单视图。你也可以根据你的业务流程更新多个模块。
- en: '![Making applications more extensive with an event aggregator](img/4252OS_06_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用事件聚合器使应用程序更广泛](img/4252OS_06_02.jpg)'
- en: This design also allows the controller to have multiple views or modules that
    listens to the event and responds accordingly. The event aggregator is a powerful
    pattern with the ability to send messages between modules, allowing applications
    to be much more decoupled from each other.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计还允许控制器拥有多个视图或模块，它们监听事件并相应地做出反应。事件聚合器是一个强大的模式，它能够在模块之间发送消息，使应用程序彼此之间更加解耦。
- en: Getting started with Commands
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用命令
- en: 'While building an application using the plain Backbone, you will just have
    four components: the model, collection, view, and router. By now, we have reviewed
    some of the objects that Marionette adds, such as the controller and the application,
    and of course the different kinds of views. Each of these objects aim to reduce
    the boilerplate and facilitate the process of structuring your application to
    accomplish the concerned separation in the code, as not everything belongs to
    the views or the router. We now know that the controller is a perfect place to
    orchestrate our views, but what about the code snippets that does not belong to
    a view? It definitely does not make sense to put that code in the router or in
    the model as it is meant to be used across all applications; for those scenarios,
    Marionette has the `Commands` component.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用纯 Backbone 构建应用程序时，你将只有四个组件：模型、集合、视图和路由器。到目前为止，我们已经回顾了 Marionette 添加的一些对象，例如控制器和应用程序，当然还有不同类型的视图。这些对象中的每一个都旨在减少样板代码并简化将应用程序结构化的过程，以在代码中实现相关的分离，因为并非所有内容都属于视图或路由器。我们现在知道控制器是协调我们的视图的完美地方，但那些不属于视图的代码片段怎么办？显然，将这些代码放入路由器或模型中是没有意义的，因为它们旨在跨所有应用程序使用；对于这些场景，Marionette
    有 `Commands` 组件。
- en: 'In order to instantiate it, we just need the following line:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实例化它，我们只需要以下这一行：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see, it is also part of the `Wreqr` object, so you can use it by
    itself. Now, we need to set handlers that will perform the actions once you call
    them through the execute keyword.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它也是 `Wreqr` 对象的一部分，所以你可以单独使用它。现在，我们需要设置处理程序，一旦你通过 `execute` 关键字调用它们，它们就会执行动作。
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `setHandler` function takes the name of the command and the function that
    it will execute.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`setHandler` 函数接受命令名称和它将执行的函数。'
- en: 'The following line of code exemplifies the execution of a command using the
    name of the command as the parameter for the `execute` function:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码行展示了使用命令名称作为 `execute` 函数参数来执行命令的示例：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And that's all you need to do in order to set a command and execute it. It's
    good to know that you can pass parameters to these commands in the same way as
    in the event aggregator.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置命令并执行它，你只需要做这些。了解你可以像在事件聚合器中一样将这些命令传递参数是很好的。
- en: 'In the following example, we will pass the message to be logged:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将传递要记录的消息：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the functions receive the message passed on the execute call.
    This parameter, of course, can be whatever object you need to pass to the handler.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数接收执行调用传递的消息。当然，这个参数可以是你要传递给处理程序的你需要的任何对象。
- en: Let's now use a command in the BookStore application that we are building, but
    we are not going to instantiate the `Wrerq` component because the Marionette application
    object already has an instance of it. So, you can set the handlers of the commands
    to the application object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的 BookStore 应用程序中使用一个命令，但我们不会实例化 `Wrerq` 组件，因为 Marionette 应用程序对象已经有一个实例。所以，你可以将命令的处理程序设置到应用程序对象中。
- en: 'The following code demonstrates how to set a handler to the application object:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何将处理程序设置到应用程序对象中：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that you can call `App.command.execute` or just `App.execute` plus the
    name of the command and the result will be the same.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以调用 `App.command.execute` 或只是 `App.execute` 加上命令名称，结果将是相同的。
- en: The handler created in the previous code is to delete the stored values in the
    local storage of the browser to remove old entries from previous visits to the
    site. This code does not belong to any view or controller because the responsibility
    of those objects differs from what this code is doing. We consider cleaning the
    local storage of the browser to prevent old and invalid entries in the code that
    belong to the application level, and having a command for that is very handy.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个代码中创建的处理程序是用来删除浏览器本地存储中存储的值，以从网站之前的访问中删除旧条目。这段代码不属于任何视图或控制器，因为那些对象的责任与这段代码所做的不一样。我们认为清理浏览器本地存储以防止代码中的旧和无效条目是很有用的，并且为此有一个命令是非常方便的。
- en: We can execute it from any part of the application, but the code is well placed
    in order to keep your concerns separate. We are sure you will find scenarios in
    which it makes sense to use commands while using Backbone and Marionette.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从应用程序的任何部分执行它，但代码放置得很好，以便保持您的关注点分离。我们确信您会发现使用 Backbone 和 Marionette 时使用命令的场景是有意义的。
- en: 'Finally, if you want to remove a handler, you can do it using the following
    code line:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您想删除处理程序，可以使用以下代码行：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For removing all the registered handlers at once, use the instruction `App.commands.removeAllHandlers()`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性删除所有已注册的处理程序，使用指令 `App.commands.removeAllHandlers()`。
- en: Setting up the RequestResponse object
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 RequestResponse 对象
- en: Finally, the last part of the `Wreqr` object is the `RequestResponse`, which
    in our opinion is definitely a nice addition to the Backbone development. We just
    saw how we can make different components work together with the help of events
    in order to communicate each other. We also learned that not all the code belongs
    to a view or router of the controller, and for those cases, the Marionette commands
    are definitely a good option in order to keep our concerns separate. Similar to
    `Commands`, the `RequestResponse` object can help us split more responsibilities
    of the code in an application.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Wreqr` 对象的最后一部分是 `RequestResponse`，在我们看来，这绝对是 Backbone 开发中的一个很好的补充。我们刚刚看到，我们可以如何通过事件的帮助使不同的组件协同工作以相互通信。我们还了解到，并非所有代码都属于视图或控制器的路由器，对于这些情况，Marionette
    命令无疑是保持我们关注点分离的一个很好的选择。类似于 `Commands`，`RequestResponse` 对象可以帮助我们在应用程序中分割更多的代码责任。
- en: The `RequestResponse` object conceptually works in the same way as events and
    `Commands`, where an object fires a call and the other object responds to it.
    The difference with `Commands` is that, in this case, a response is returned to
    the caller.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，`RequestResponse` 对象与事件和 `Commands` 的工作方式相同，其中一个对象发出调用，另一个对象响应它。与 `Commands`
    的区别在于，在这种情况下，会返回一个响应给调用者。
- en: 'To set up a `RequestResponse` object, we need the following line of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 `RequestResponse` 对象，我们需要以下代码行：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The setup of a handler is also similar to the commands handler as we can see
    in the following code snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序的设置与命令处理程序类似，正如我们可以在以下代码片段中看到的那样：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In order to get that response value, we need to put in a request as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取那个响应值，我们需要按照以下方式发出请求：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous example, we requested a username and the handler, with the name
    `getUserName`, is just a function that will return that value for us. Also, note
    that you can pass parameters to this request.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们请求了一个用户名和处理程序，名为 `getUserName` 的处理程序仅仅是一个函数，它将为我们返回该值。此外，请注意，您可以为此请求传递参数。
- en: We consider the `RequestResponse` object very useful to separate concerns, get
    the value from the server, filter those values, and perform a data manipulation
    task again; these are not responsibilities of the other components of Backbone
    or of Marionette reviewed so far. Think of `RequestRepsonse` as a service layer
    that will call the server and return a collection or models in a single place.
    Instead of doing this at the view level, your views should display the data passed
    to them. But they will be doing too much by also being in charge of retrieving
    this data from the server, and what if your API changes? You would need to change
    that server call in all the views or controllers where you made the calls.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为 `RequestResponse` 对象对于分离关注点、从服务器获取值、过滤这些值并再次执行数据操作任务非常有用；这些不是迄今为止审查的 Backbone
    或 Marionette 的其他组件的责任。将 `RequestRepsonse` 视为一个服务层，它将在一个地方调用服务器并返回一个集合或模型。而不是在视图级别执行此操作，您的视图应该显示传递给它们的
    数据。但它们将承担太多责任，因为它们还负责从服务器检索这些数据，如果您的 API 发生变化怎么办？您将需要更改所有已进行调用的视图或控制器中的服务器调用。
- en: Using the `RequestResponse` object will give you the ability to perform this
    synchronization with the server in one place and call it from different places,
    always getting the same return. But above everything, it allows you to decouple
    your application and keep the responsibility and duties of the other components
    short and meaningful.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RequestResponse`对象将使您能够在同一位置执行与服务器的同步，并从不同的地方调用它，始终获得相同的返回值。但最重要的是，它允许您解耦应用程序，并保持其他组件的责任和职责简短且有意义。
- en: 'Let''s see an example of this, but again, we will use the default instance
    of `Wreqr`, which is in the application object of Marionette:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个例子，但同样，我们将使用Marionette应用程序对象中的默认`Wreqr`实例：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside the method of a controller, we can call the handler by performing a
    request and passing the collection to the view, as demonstrated in the following
    code snippet:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器的方法内部，我们可以通过执行请求并将集合传递给视图来调用处理器，如下面的代码片段所示：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The benefit of this is that the controller acted as a mediator between the view
    and the `RequestResponse` object, while the view is responsible for getting the
    data removed because the controller passes the collection to it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点在于控制器充当了视图和`RequestResponse`对象之间的调解者，而视图负责获取要删除的数据，因为控制器将集合传递给它。
- en: Summary
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to decouple our application with the help of
    the `Wreqr` object while splitting the responsibilities between the different
    subcomponents such as the `event aggregator`, `Commands`, and `RequestRespone`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何借助`Wreqr`对象解耦我们的应用程序，同时在不同的子组件如`事件聚合器`、`命令`和`RequestRespone`之间分配责任。
- en: In the next chapter, we will learn how to make these components work in single
    files and keep our file structure organized with the help of `Require.js`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用`Require.js`帮助我们在单个文件中使这些组件工作，并保持我们的文件结构有序。
