- en: Chapter 6. Messaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter suggested an architecture that allows your entire application
    to be divided into subapplications and modules. Subapplications are just separate
    parts of your application with functionality that is entirely separate from each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal when designing your modules and subapplications is to produce an entire
    system that is integrated but also loosely coupled, and this is where a very well-known
    technique enters the scene: messaging. The concept of messaging, like the divide
    and conquer method, has been around for a long time and developers use these types
    of tools and patterns every day. This pattern tries to provide a way for the components
    to talk to each other through messages, thus allowing modules to subscribe and
    publish events on a common message bus.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics that will be covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the event aggregator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the event aggregator of `Marionette.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making applications more extensive with the event aggregator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with `Commands`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the `RequestResponse` object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the event aggregator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to *Martin Fowler*, an Event Aggregator does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Channels events from multiple objects into a single object to simplify registration
    for clients."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: One of the most useful patterns of modular, scalable, and complex JavaScript
    applications is the event aggregation. The event aggregator functionality is in
    a container for events that allow publishers and subscribers of these events to
    have a channel of communication; however, at the same time, it allows them to
    work independently without the need for code references between them, so they
    can be updated or removed without affecting the others. Having said that, note
    how this decoupling is useful in your modularized applications because new subapps
    and modules can be added to just make use of your current architecture. In our
    composite application design, the event aggregator is a powerful way to implement
    communication among `Marionette.js` objects and we will see how we can integrate
    that in our current code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a graphical explanation of the event aggregator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the event aggregator](img/4252OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using the event aggregator of Marionette.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Marionette implementation of the event aggregator pattern made its way
    out of the Marionette core build as it can be found now in a separate distributable
    file called `backbone.wreqr.js`. This implementation extends from the `backbone.events`
    object. The following is an example of how to instantiate an event aggregator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can start adding listeners that will react to the events triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, you have a listener that will be expecting an event to be triggered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s trigger the `do something` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: And that's all you need to log the message. Ok, but how can we do this at the
    application level, the `Marionette. An application` object comes with an instance
    of the `Backbone.Wreqr.EventAggregator`. So by instantiating a Marionette application
    object, you can start registering listeners to events without the need of instantiating
    the `EventAggregator` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of how to register a listener to an event at the
    application level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The event publisher can now raise the event anywhere inside the application
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we don't have to ask the application to do some work. In this
    case, to show an alert, we should tell the application object that we need to
    be notified when work will execute `MyApp.vent.trigger("helloWorld ")`, which
    will display the message.
  prefs: []
  type: TYPE_NORMAL
- en: Making applications more extensive with an event aggregator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To make this pattern easy to understand, we can use the metaphor of the shopping
    cart app. The user selects an item to be purchased from the book view. The order
    view needs to be notified when a new product is added in order to display it and
    calculate the total.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we have multiple ways to complete this functionality and the obvious
    one is to have the order view reference in the book view, so we can either call
    methods or raise events. But then, we will have, for example, a much coupled design
    where you cannot delete the order view without affecting the book view. So now,
    it is time to bring the event aggregator to our application and solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: We need a central object that manages the events and the subscribers for those
    events. For this example, we will use a controller. With this controller and the
    event aggregator in place, the views will be decoupled from each other. This means
    that the book view will not contain a reference to the order's view and can be
    changed without design problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for adding the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the controller is initialized, we register the listener for the item added.
    It's expecting to receive parameters from the publisher event and then call the
    local function. The next step is to create the view that is raising the event.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for adding the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This contains a view with a declared event ; this event is to be called from
    a button located in the view when the `addItem` function is executed. It also
    raised the `App.vent.trigger("itemAdded", this.model)` event; this event is going
    to be handled by the central object, that is, the controller, and call the order
    view. Pretty easy right? In this way, we do not have the order view reference
    here that allows both the views to evolve independently.
  prefs: []
  type: TYPE_NORMAL
- en: The following is a graphical explanation of the code that we just explained.
    As you can see, we have the central object, that is, the controller; it contains
    listeners that will raise the event to refresh the order view after the button
    is clicked in the book view. You can also update multiple modules according to
    your business flow.
  prefs: []
  type: TYPE_NORMAL
- en: '![Making applications more extensive with an event aggregator](img/4252OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This design also allows the controller to have multiple views or modules that
    listens to the event and responds accordingly. The event aggregator is a powerful
    pattern with the ability to send messages between modules, allowing applications
    to be much more decoupled from each other.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While building an application using the plain Backbone, you will just have
    four components: the model, collection, view, and router. By now, we have reviewed
    some of the objects that Marionette adds, such as the controller and the application,
    and of course the different kinds of views. Each of these objects aim to reduce
    the boilerplate and facilitate the process of structuring your application to
    accomplish the concerned separation in the code, as not everything belongs to
    the views or the router. We now know that the controller is a perfect place to
    orchestrate our views, but what about the code snippets that does not belong to
    a view? It definitely does not make sense to put that code in the router or in
    the model as it is meant to be used across all applications; for those scenarios,
    Marionette has the `Commands` component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to instantiate it, we just need the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it is also part of the `Wreqr` object, so you can use it by
    itself. Now, we need to set handlers that will perform the actions once you call
    them through the execute keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `setHandler` function takes the name of the command and the function that
    it will execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following line of code exemplifies the execution of a command using the
    name of the command as the parameter for the `execute` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: And that's all you need to do in order to set a command and execute it. It's
    good to know that you can pass parameters to these commands in the same way as
    in the event aggregator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we will pass the message to be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the functions receive the message passed on the execute call.
    This parameter, of course, can be whatever object you need to pass to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now use a command in the BookStore application that we are building, but
    we are not going to instantiate the `Wrerq` component because the Marionette application
    object already has an instance of it. So, you can set the handlers of the commands
    to the application object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to set a handler to the application object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can call `App.command.execute` or just `App.execute` plus the
    name of the command and the result will be the same.
  prefs: []
  type: TYPE_NORMAL
- en: The handler created in the previous code is to delete the stored values in the
    local storage of the browser to remove old entries from previous visits to the
    site. This code does not belong to any view or controller because the responsibility
    of those objects differs from what this code is doing. We consider cleaning the
    local storage of the browser to prevent old and invalid entries in the code that
    belong to the application level, and having a command for that is very handy.
  prefs: []
  type: TYPE_NORMAL
- en: We can execute it from any part of the application, but the code is well placed
    in order to keep your concerns separate. We are sure you will find scenarios in
    which it makes sense to use commands while using Backbone and Marionette.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you want to remove a handler, you can do it using the following
    code line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For removing all the registered handlers at once, use the instruction `App.commands.removeAllHandlers()`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the RequestResponse object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, the last part of the `Wreqr` object is the `RequestResponse`, which
    in our opinion is definitely a nice addition to the Backbone development. We just
    saw how we can make different components work together with the help of events
    in order to communicate each other. We also learned that not all the code belongs
    to a view or router of the controller, and for those cases, the Marionette commands
    are definitely a good option in order to keep our concerns separate. Similar to
    `Commands`, the `RequestResponse` object can help us split more responsibilities
    of the code in an application.
  prefs: []
  type: TYPE_NORMAL
- en: The `RequestResponse` object conceptually works in the same way as events and
    `Commands`, where an object fires a call and the other object responds to it.
    The difference with `Commands` is that, in this case, a response is returned to
    the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a `RequestResponse` object, we need the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The setup of a handler is also similar to the commands handler as we can see
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to get that response value, we need to put in a request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, we requested a username and the handler, with the name
    `getUserName`, is just a function that will return that value for us. Also, note
    that you can pass parameters to this request.
  prefs: []
  type: TYPE_NORMAL
- en: We consider the `RequestResponse` object very useful to separate concerns, get
    the value from the server, filter those values, and perform a data manipulation
    task again; these are not responsibilities of the other components of Backbone
    or of Marionette reviewed so far. Think of `RequestRepsonse` as a service layer
    that will call the server and return a collection or models in a single place.
    Instead of doing this at the view level, your views should display the data passed
    to them. But they will be doing too much by also being in charge of retrieving
    this data from the server, and what if your API changes? You would need to change
    that server call in all the views or controllers where you made the calls.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `RequestResponse` object will give you the ability to perform this
    synchronization with the server in one place and call it from different places,
    always getting the same return. But above everything, it allows you to decouple
    your application and keep the responsibility and duties of the other components
    short and meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example of this, but again, we will use the default instance
    of `Wreqr`, which is in the application object of Marionette:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the method of a controller, we can call the handler by performing a
    request and passing the collection to the view, as demonstrated in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of this is that the controller acted as a mediator between the view
    and the `RequestResponse` object, while the view is responsible for getting the
    data removed because the controller passes the collection to it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to decouple our application with the help of
    the `Wreqr` object while splitting the responsibilities between the different
    subcomponents such as the `event aggregator`, `Commands`, and `RequestRespone`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to make these components work in single
    files and keep our file structure organized with the help of `Require.js`.
  prefs: []
  type: TYPE_NORMAL
