<html><head></head><body>


<h1 class="chap2"><a id="page153" class="calibre6"/><a href="toc.xhtml#c05" class="calibre6">C<small class="calibre8">HAPTER</small> 5</a></h1>
<h1 class="subchap"><a href="toc.xhtml#c05" class="calibre6">REST API for User Module</a></h1>

<h1 class="sec" id="s142"><a href="toc.xhtml#s142a" class="calibre6">Introduction</a></h1>
<p class="nonindent">At the heart of any application lies the User module, a foundational component that orchestrates the management of user-centric features. This module allows users to administer the user accounts, enables authentication and authorization, and various user-specific operations, such as adding or registering users, updating user profiles, deleting users, password management, role-based permission, logging, and many more. The User module enhances the user experience and promotes the seamless operation of the application.</p>
<h1 class="sec" id="s143"><a href="toc.xhtml#s143a" class="calibre6">Structure</a></h1>
<p class="nonindent">In this chapter, we will discuss the following topics:</p>
<ul class="bull">
<li class="calibre9">Base Controller and Base Service for REST API development</li>
<li class="calibre9">Role Management with Input Validation</li>
<li class="calibre9">User Management with Input Validation
<ul class="bull1">
<li class="calibre9">User Onboarding</li>
<li class="calibre9">User Sign-In</li>
<li class="calibre9">Authentication and Authorization Mechanism</li>
<li class="calibre9">Update User Data</li>
<li class="calibre9">Delete User Account</li>
<li class="calibre9">Password Management and Recovery with Email Notification</li></ul></li>
</ul>
<h1 class="sec" id="s144"><a href="toc.xhtml#s144a" class="calibre6">Base Controller</a></h1>
<p class="nonindent">We have seen in the previous chapter how we constructed individual controllers for each module. For each controller, there were some common methods, such as handlers for add, get all, get one, update, and so on. Since there is one controller for <a id="page154"/>each entity, this set of common functions must be implemented by each controller. We could write an abstract class for the controllers to extend and force them to provide an implementation. Therefore, adhering to established norms, we are now introducing a foundational concept known as <strong class="calibre3">Base Controller</strong>. It is an abstract class that serves as a blueprint for other classes to inherit its predefined methods that facilitate operations like creating, updating, retrieving all, retrieving one, and deleting data.</p>
<p class="nonindent">Let's create the <code class="calibre7"><strong class="calibre3">base_controller.ts</strong></code> in the utils directory using the following code:</p>
<p class="code"><code class="calibre7">// base_controller.ts</code></p>
<p class="code1"><code class="calibre7">import { Request, Response } from 'express';</code></p>
<p class="code"><code class="calibre7">export abstract class BaseController {</code></p>
<p class="code2"><code class="calibre7">public abstract addHandler(req: Request, res: Response): void;</code></p>
<p class="code2"><code class="calibre7">public abstract getAllHandler(req: Request, res: Response): void;</code></p>
<p class="code2"><code class="calibre7">public abstract getOneHandler(req: Request, res: Response): void;</code></p>
<p class="code2"><code class="calibre7">public abstract updateHandler(req: Request, res: Response): void;</code></p>
<p class="code2"><code class="calibre7">public abstract deleteHandler(req: Request, res: Response): void;</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The purpose of this abstract class is to furnish a uniform framework that other classes (controllers) can adhere to while implementing these methods. When a class extends the <code class="calibre7"><strong class="calibre3">BaseController</strong></code>, it becomes obligatory to furnish implementations for these abstract methods. This practice guarantees that controllers across various routes maintain consistent method names and parameters, even though the specific execution details might vary.</p>
<p class="nonindent">Please note that an individual controller can still write their own additional methods.</p>
<p class="nonindent">The code for this chapter can be downloaded from <a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/tree/main/ch-05-code-files">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/tree/main/ch-05-code-files</a></p>
<h1 class="sec" id="s145"><a href="toc.xhtml#s145a" class="calibre6">Base Service</a></h1>
<p class="nonindent">Base Service is a foundational structure that provides common functionalities for managing data operations in an application. It serves as a blueprint that other services can inherit to avoid repetitive code and ensure consistent patterns for data manipulation. The primary purpose of a base service is to encapsulate commonly used data operations, such as create, read, update, and delete, and make them available to other services. This reduces code duplication and enforces consistent practices across different modules of an application. Other services requiring data operations <a id="page155"/>can inherit from the base service. By extending the base service, these child services gain access to the common methods defined in the base service.</p>
<p class="nonindent">Let's create the <code class="calibre7"><strong class="calibre3">base_service.ts</strong></code> using the following code:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/base_service.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/base_service.ts</a></code></p>
<p class="nonindent">If you had downloaded the source code for this chapter, then you can find the <code class="calibre7"><strong class="calibre3">base_service.ts</strong></code> inside. We have added comments for each method to explain what it does and how it works. This base service class provides common CRUD operations, <code class="calibre7"><strong class="calibre3">findbyIds</strong></code>, and a custom query runner along with handling API responses and error cases. This service class can be inherited by other services.</p>
<p class="nonindent">It is important to manage database connections efficiently. If we make separate database connections for each operation, the application would likely crash during high loads. Using a database pool is the best practice to limit and reuse the connections from a pool.</p>
<p class="nonindent">Let's change the <code class="calibre7"><strong class="calibre3">db.ts</strong></code> file using the following code for adding a database pool and to use a single connection in the whole app:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/db.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/db.ts</a></code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">connectDatabase</strong></code> function is responsible for establishing a database connection or returning an existing connection if available. It first checks if a valid connection already exists, and if not, it initializes a new connection and stores it for future use.</p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">getInstance</strong></code> function retrieves a database instance, ensuring it is connected before providing access. Unlike the <code class="calibre7"><strong class="calibre3">connectDatabase</strong></code> function, <code class="calibre7"><strong class="calibre3">getInstance</strong></code> waits until the connection is established before returning, ensuring that it can only be used once the connection is ready.</p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">getRepository</strong></code> function is designed to retrieve a repository instance for a given entity. It checks if a valid database connection exists and creates the repository instance if it doesn't already exist. If there's no valid connection, it returns null.</p>
<h1 class="sec" id="s146"><a href="toc.xhtml#s146a" class="calibre6">Role Management</a></h1>
<p class="nonindent">Role management is a critical aspect of application security that involves controlling and defining the access and permissions of users within a system. It ensures that users have the appropriate rights to perform specific actions based on their roles or responsibilities. Role management is essential in preventing unauthorized access and data breaches and maintaining the overall integrity of an application.</p>
<p class="nonindent">Different users have different levels of access and privileges. For example, an application might have different user roles such as <code class="calibre7"><strong class="calibre3">Super Admin</strong></code>, <code class="calibre7"><strong class="calibre3">Project Manager</strong></code>, and <code class="calibre7"><strong class="calibre3">Guest</strong></code>, <a id="page156"/>each with distinct sets of permissions. Admins typically have access to all features and functionalities, project managers have limited access, and guests might have very restricted access.</p>
<h1 class="sec" id="s147"><a href="toc.xhtml#s147a" class="calibre6">Role Service</a></h1>
<p class="nonindent">Role Service will be used to perform role-based operations in a database that extends from the base service. So, let's create the <code class="calibre7"><strong class="calibre3">roles_service.ts</strong></code> file in the roles component using the following code:</p>
<p class="code"><code class="calibre7">// role_service.ts</code></p>
<p class="code1"><code class="calibre7">import { Repository } from 'typeorm';</code></p>
<p class="code1"><code class="calibre7">import { BaseService } from '../../utils/base_service';</code></p>
<p class="code1"><code class="calibre7">import { DatabaseUtil } from '../../utils/db';</code></p>
<p class="code1"><code class="calibre7">import { Roles } from './roles_entity';</code></p>
<p class="code"><code class="calibre7">export class RolesService extends BaseService&lt;Roles&gt; {</code></p>
<p class="code2a"><code class="calibre7">constructor() {</code></p>
<p class="code3"><code class="calibre7">// Create an instance of DatabaseUtil</code></p>
<p class="code3"><code class="calibre7">const databaseUtil = new DatabaseUtil();</code></p>
<p class="code3a"><code class="calibre7">// Get the repository for the Roles entity</code></p>
<p class="code3"><code class="calibre7">const roleRepository: Repository&lt;Roles&gt; = databaseUtil.getRepository(Roles);</code></p>
<p class="code3"><code class="calibre7">// Call the constructor of the BaseService class with the</code></p>
<p class="code4"><code class="calibre7">repository as a parameter</code></p>
<p class="code3"><code class="calibre7">super(roleRepository);</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">RolesService</strong></code> class is designed to extend the functionality provided by the <code class="calibre7"><strong class="calibre3">BaseService</strong></code> class. It uses the <code class="calibre7"><strong class="calibre3">DatabaseUtil</strong></code> class to get the repository for the <code class="calibre7"><strong class="calibre3">Roles</strong></code> entity and then passes that repository to the constructor of the <code class="calibre7"><strong class="calibre3">BaseService</strong></code> class. This allows the <code class="calibre7"><strong class="calibre3">RolesService</strong></code> class to inherit and use the CRUD methods defined in the <code class="calibre7"><strong class="calibre3">BaseService</strong></code> class for working with the <code class="calibre7"><strong class="calibre3">Roles</strong></code> entity.</p>
<p class="nonindent">We will develop the REST API for roles as follows:</p>
<ul class="bull">
<li class="calibre9">Add Roles</li>
<li class="calibre9">Get All Roles</li>
<li class="calibre9"><a id="page157"/>GetOne Role</li>
<li class="calibre9">Update Role</li>
<li class="calibre9">Delete Role</li>
</ul>
<p class="nonindent">Before developing the actual <strong class="calibre3">Add Role</strong> API, we need to define input validation for roles while adding them to the database. So, let's use an Express Validator to validate input requests.</p>
<h1 class="sec" id="s148"><a href="toc.xhtml#s148a" class="calibre6">Input Validation</a></h1>
<p class="nonindent">First, install the Express Validator module so paste the following command in <code class="calibre7"><strong class="calibre3">cmd</strong></code>:</p>
<p class="code"><code class="calibre7">npm i express-validator --save</code></p>
<p class="nonindent">Now create the <code class="calibre7"><strong class="calibre3">validator.ts</strong></code> file in the utils directory using the following code:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/validator.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/validator.ts</a></code></p>
<p class="nonindent">The provided code exports a function named <code class="calibre7"><strong class="calibre3">validate</strong></code> that generates <code class="calibre7"><strong class="calibre3">middleware</strong></code> for validating request data using the express-validator package. This middleware function runs the provided validation functions, checks for validation errors using <code class="calibre7"><strong class="calibre3">validationResult</strong></code>, and sends a response with a 400 status and error messages if validation fails. The structure of the error messages aligns with the <code class="calibre7"><strong class="calibre3">IValidationError</strong></code> interface. This approach is commonly used to handle request validation in Express applications.</p>
<p class="nonindent">Next, create the <code class="calibre7"><strong class="calibre3">validRoleInput</strong></code> in the <code class="calibre7"><strong class="calibre3">roles_routers.ts</strong></code> file using the following code:</p>
<p class="code"><code class="calibre7">// roles_routers.ts</code></p>
<p class="code1"><code class="calibre7">import { Express } from 'express';</code></p>
<p class="code1"><code class="calibre7">import { RoleController, RolesUtil } from './roles_controller';</code></p>
<p class="code1"><code class="calibre7">import { validate } from '../../utils/validator';</code></p>
<p class="code1"><code class="calibre7">import { body } from 'express-validator';</code></p>
<p class="code"><code class="calibre7">const validRoleInput = [</code></p>
<p class="code2"><code class="calibre7">body('name').trim().notEmpty().withMessage('It should be required'),</code></p>
<p class="code2"><code class="calibre7">body('description').isLength({ max: 200 }).withMessage('It has</code></p>
<p class="code1"><code class="calibre7">maximum limit of 200 characters'),</code></p>
<p class="code2"><code class="calibre7">];</code></p>
<p class="code"><code class="calibre7">export class RoleRoutes {</code></p>
<p class="code2"><code class="calibre7">private baseEndPoint = '/api/roles';</code></p>
<p class="code2a"><code class="calibre7">constructor(app: Express) {</code></p>
<p class="code3a"><code class="calibre7">const controller = new RoleController();</code></p>
<p class="code3a"><code class="calibre7">app.route(this.baseEndPoint)</code></p>
<p class="code4"><code class="calibre7"> .get(controller.getAllHandler)</code></p>
<p class="code4"><code class="calibre7"> .post(validate(validRoleInput), controller.addHandler);</code></p>
<p class="code3a"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code4"><code class="calibre7"> .get(controller.getOneHandler)</code></p>
<p class="code4"><code class="calibre7"> .put(validate(validRoleInput), controller.updateHandler)</code></p>
<p class="code4"><code class="calibre7"> .delete(controller.deleteHandler);</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page158"/>In the preceding class, the <code class="calibre7"><strong class="calibre3">baseEndPoint</strong></code> variable is used. This is part of the API endpoints, which is going to be the same for all of the role APIs.</p>
<p class="nonindent">Notice the <code class="calibre7"><strong class="calibre3">validRoleInput</strong></code> variable, which is an array. This array contains a series of validation checks for each input field expected in a role. Each element of this array is a validator function that checks a specific aspect of the data.</p>
<p class="nonindent">The validator for the <code class="calibre7"><strong class="calibre3">name</strong></code> field in request body would be processed as follows:</p>
<p class="code"><code class="calibre7">body('name').trim().notEmpty().withMessage('It should be required')</code></p>
<p class="nonindent">This validator is applied to the <code class="calibre7"><strong class="calibre3">name</strong></code> field in the request body and performs the following functions:</p>
<ul class="bull">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">trim()</strong></code>: Removes any leading and trailing whitespace from the input.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">notEmpty()</strong></code>: Checks that the input is not empty.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">withMessage('It should be required')</strong></code>: If the validation fails, this message will be included in the error response.</li>
</ul>
<p class="nonindent">Similarly, the validator for the <code class="calibre7"><strong class="calibre3">description</strong></code> field would be as follows:</p>
<p class="code"><code class="calibre7">body('description').isLength({ max: 200 }).withMessage('It has a maximum limit of 200 characters')</code></p>
<p class="nonindent">This validator is applied to the <code class="calibre7"><strong class="calibre3">description</strong></code> field in the request body. It checks that the length of the input does not exceed <code class="calibre7"><strong class="calibre3">200</strong></code> characters.</p>
<p class="nonindent">Overall, this code defines a set of validation rules for different fields of role data, <a id="page159"/>including checking for the presence, length, and validity of access rights. If any of the validations fail, the corresponding error message will be included in the error response with status code <code class="calibre7"><strong class="calibre3">400: bad</strong></code> request.</p>
<p class="nonindent">Each role consists of a set of rights. These rights are nothing but string keys, which can help us to understand whether a logged-in user has a particular right assigned to let them do a corresponding task. A right for adding a task could be as simple as <code class="calibre7"><strong class="calibre3">add_task</strong></code>, which could be added to the role assigned to the user.</p>
<p class="nonindent">Let's define all of the necessary application rights in <code class="calibre7"><strong class="calibre3">common.ts</strong></code> file as follows:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/common.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/common.ts</a></code></p>
<p class="nonindent">These rights are application rights, which are used to check permission during user login based on the assigned Role. When a role is created, it has a rights value that is saved as comma-separated from these application rights.</p>
<p class="nonindent">Let's create a <code class="calibre7"><strong class="calibre3">RolesUtil</strong></code> class with <code class="calibre7"><strong class="calibre3">getAllPermissionsFromRights</strong></code> function in the <code class="calibre7"><strong class="calibre3">role_controller.ts</strong></code> file using the following code:</p>
<p class="code"><code class="calibre7">// role_controller.ts</code></p>
<p class="code1"><code class="calibre7">export class RolesUtil {</code></p>
<p class="code2a"><code class="calibre7">/**</code></p>
<p class="code3"><code class="calibre7">* Retrieves all possible permissions from the defined rights in the Rights object.</code></p>
<p class="code3"><code class="calibre7">* @returns {string[]} An array of permissions</code></p>
<p class="code3"><code class="calibre7">*/</code></p>
<p class="code2"><code class="calibre7">public static getAllPermissionsFromRights(): string[] {</code></p>
<p class="code3a"><code class="calibre7">// Initialize an empty array to collect values;</code></p>
<p class="code3"><code class="calibre7">let permissions = [];</code></p>
<p class="code3a"><code class="calibre7">// Iterate through each section of the Rights object</code></p>
<p class="code3"><code class="calibre7">for (const module in Rights) {</code></p>
<p class="code4a"><code class="calibre7"> // Check if rights for ALL are defined for the current module</code></p>
<p class="code4"><code class="calibre7"> if (Rights[module]['ALL']) {</code></p>
<p class="code5"><code class="calibre7">let sectionValues = Rights[module]['ALL'];</code></p>
<p class="code5"><code class="calibre7">sectionValues = sectionValues.split(',');</code></p>
<p class="code5"><code class="calibre7">permissions = […permissions, …sectionValues];</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">// Return the collected permissions</code></p>
<p class="code3"><code class="calibre7">return permissions;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page160"/>This function effectively compiles all the available permissions from the defined Rights object, which can then be used for validation and other purposes in the application.</p>
<p class="nonindent">Now add validation for the <code class="calibre7"><strong class="calibre3">rights</strong></code> field in <code class="calibre7"><strong class="calibre3">validRoleInput</strong></code> using the following code:</p>
<p class="code"><code class="calibre7">const validRoleInput = [</code></p>
<p class="code2"><code class="calibre7">body('name').trim().notEmpty().withMessage('It should be required'),</code></p>
<p class="code2"><code class="calibre7">body('description').isLength({ max: 200 }).withMessage('It has maximum limit of 200 characters'),</code></p>
<p class="code2"><code class="calibre7">body('rights').custom((value: string) =&gt; {</code></p>
<p class="code3"><code class="calibre7">const accessRights = value?.split(',');</code></p>
<p class="code3"><code class="calibre7">if (accessRights?.length &gt; 0) {</code></p>
<p class="code4"><code class="calibre7">const validRights = RolesUtil.getAllPermissionsFromRights();</code></p>
<p class="code4"><code class="calibre7">const areAllRightsValid = accessRights.every(right =&gt;</code></p>
<p class="code1"><code class="calibre7">validRights.includes(right));</code></p>
<p class="code4"><code class="calibre7">if (!areAllRightsValid) {</code></p>
<p class="code5"><code class="calibre7">throw new Error('Invalid permission');</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">return true; // Validation passed</code></p>
<p class="code2"><code class="calibre7">})</code></p>
<p class="code1"><code class="calibre7">];</code></p>
<p class="nonindent">Based on the provided code, the custom validation function ensures the validity of rights during the process of adding or updating a role. It evaluates the rights received in the request and verifies whether they are valid or not. If any of the rights are found to be invalid, an error is generated.</p>
<h1 class="sec" id="s149"><a href="toc.xhtml#s149a" class="calibre6">Add Role</a></h1>
<p class="nonindent">When using the REST API to add a role, you typically provide the necessary data in the request body, such as the role's name, description, and the rights it should have. The API endpoint responsible for this action is designed to receive this data, validate it according to predefined rules, and create a new role based on the provided information.</p>
<p class="nonindent"><a id="page161"/>We have already created <code class="calibre7"><strong class="calibre3">roles_controller.ts</strong></code> as a skeleton class. Now, let's change it with an extended Base Controller and use the base service to perform database operations using the following code:</p>
<p class="code"><code class="calibre7">// roles_controller.ts</code></p>
<p class="code1"><code class="calibre7">import { Response, Request } from 'express';</code></p>
<p class="code1"><code class="calibre7">import { RolesService } from './roles_service';</code></p>
<p class="code1"><code class="calibre7">import { BaseController } from '../../utils/base_controller';</code></p>
<p class="code1"><code class="calibre7">import { Rights } from '../../utils/common';</code></p>
<p class="code"><code class="calibre7">export class RoleController extends BaseController {</code></p>
<p class="code2a"><code class="calibre7">public async addHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">const role = req.body;</code></p>
<p class="code3"><code class="calibre7">const service = new RolesService();</code></p>
<p class="code3"><code class="calibre7">const result = await service.create(role);</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code1"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code2a"><code class="calibre7">public async getAllHandler(req: Request, res: Response) {}</code></p>
<p class="code2"><code class="calibre7">public async getOneHandler(req: Request, res: Response) {}</code></p>
<p class="code2"><code class="calibre7">public async updateHandler(req: Request, res: Response) {}</code></p>
<p class="code2"><code class="calibre7">public async deleteHandler(req: Request, res: Response) {}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In this context, the `<code class="calibre7"><strong class="calibre3">addHandler</strong></code><strong class="calibre3">`</strong> method captures the data provided within the incoming request body. Subsequently, it forwards this data to the Base service by invoking the create method, which is responsible for adding the information to the database. The Base service then returns a response to this handler, signifying either a successful or unsuccessful outcome. This response is effectively transmitted as the ultimate outcome for the associated REST API operation.</p>
<p class="nonindent">Now call <code class="calibre7"><strong class="calibre3">addHandler</strong></code> in role routes with change in <code class="calibre7"><strong class="calibre3">roles_router.ts</strong></code> file as follows:</p>
<p class="code"><code class="calibre7">//roles_router.ts</code></p>
<p class="code1"><code class="calibre7">export class RoleRoutes {</code></p>
<p class="code2a"><code class="calibre7">private baseEndPoint = '/api/roles';</code></p>
<p class="code2a"><code class="calibre7">constructor(app: Express) {</code></p>
<p class="code3a"><code class="calibre7">const controller = new RoleController();</code></p>
<p class="code4"><code class="calibre7">app.route(this.baseEndPoint)</code></p>
<p class="code5"><code class="calibre7">.post(validate(validRoleInput), controller.addHandler);</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page162"/>We have established routes for adding roles and incorporated middleware to validate requests before inserting data into the database.</p>
<p class="nonindent">You can test the REST APIs in Postman, cURL, or .http file with the following request and get their responses. The easiest method is to simply use VSCode, install REST Client extension, and create a new file with the .http extension and put the request as shown in <em class="calibre4"><a href="#fig5_1">Figure 5.1</a></em>:</p>
<figure class="img">
<img alt="" src="img/5.1.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig5_1"><strong class="calibre3">Figure 5.1:</strong> Making a request using VSCode REST Client Extension</p>
<p class="nonindent">For testing the API for adding a role, we need to make a <code class="calibre7"><strong class="calibre3">POST</strong></code> call to <code class="calibre7"><strong class="calibre3">/api/roles</strong></code>. The preceding figure shows the way it can be called with the request body.</p>
<p class="nonindent"><strong class="calibre3">REST API Add Role</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL : http://127.0.0.1:3000/api/roles</code></p>
<p class="code1"><code class="calibre7">Method: POST</code></p>
<p class="code1"><code class="calibre7">body :</code></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"name":"Super Admin",</code></p>
<p class="code2"><code class="calibre7">"description":"Having All Rights",</code></p>
<p class="code2"><code class="calibre7">"rights": "add_role,edit_role,get_all_roles,get_details_role,</code></p>
<p class="code1"><code class="calibre7">delete_role,</code></p>
<p class="code1"><code class="calibre7">add_user,edit_user,get_all_users,get_details_user,delete_user,</code></p>
<p class="code1"><code class="calibre7">add_project,edit_project,get_all_projects,get_details_project,</code></p>
<p class="code1"><code class="calibre7">delete_project,add_task,edit_task,get_all_tasks,get_details_task,</code></p>
<p class="code1"><code class="calibre7">delete_task,add_comment,edit_comment,get_all_comments,</code></p>
<p class="code1"><code class="calibre7">get_details_comment,delete_comment"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3"><a id="page163"/>Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 201,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": {</code></p>
<p class="code3"><code class="calibre7">"role_id": "b88cc70d-ab0a-4464-9562-f6320df519f6",</code></p>
<p class="code3"><code class="calibre7">"name": "Super Admin",</code></p>
<p class="code3"><code class="calibre7">"description": "Having All Rights",</code></p>
<p class="code3"><code class="calibre7">"rights": "add_role,edit_role,get_all_roles,get_details_role,</code></p>
<p class="code1"><code class="calibre7">delete_role,add_user,edit_user,get_all_users,get_details_user,</code></p>
<p class="code1"><code class="calibre7">delete_user,add_project,edit_project,get_all_projects,</code></p>
<p class="code1"><code class="calibre7">get_details_project,delete_project,add_task,edit_task,get_all_tasks,</code></p>
<p class="code1"><code class="calibre7">get_details_task,delete_task,add_comment,edit_comment,</code></p>
<p class="code1"><code class="calibre7">get_all_comments,get_details_comment,delete_comment",</code></p>
<p class="code3"><code class="calibre7">"created_at": "2023-08-16T16:39:14.047Z",</code></p>
<p class="code3"><code class="calibre7">"updated_at": "2023-08-16T16:39:14.047Z"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In case of a unique role name, trying again with the same request gives an error as 409 conflict code:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 409,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Key (name)=(Super Admin) already exists."</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In another case, if you change the rights as "<code class="calibre7"><strong class="calibre3">rights</strong></code>"<code class="calibre7"><strong class="calibre3">:</strong></code>"<code class="calibre7"><strong class="calibre3">no_rights</strong></code>", it gives an error for Bad Request with 400 status as follows:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 400,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"errors": [</code></p>
<p class="code3"><code class="calibre7">{</code></p>
<p class="code4"><code class="calibre7"> "rights": "Invalid permission"</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">]</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<h1 class="sec" id="s150"><a id="page164" class="calibre6"/><a href="toc.xhtml#s150a" class="calibre6">GetAll Roles</a></h1>
<p class="nonindent">Once a role has been successfully added to the database, we can proceed to retrieve the newly inserted roles from the database. So, let's change the <code class="calibre7"><strong class="calibre3">getAllHandler</strong></code> method in the <code class="calibre7"><strong class="calibre3">roles_controller.ts</strong></code> file using the following code:</p>
<p class="code"><code class="calibre7">// roles_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async getAllHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">const service = new RolesService();</code></p>
<p class="code3"><code class="calibre7">const result = await service.findAll(req.query);</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The `<code class="calibre7"><strong class="calibre3">getAllHandler</strong></code><strong class="calibre3">`</strong> method uses the <code class="calibre7"><strong class="calibre3">RolesService</strong></code> class to retrieve all roles from the database based on the query parameters in the request. The resulting data is then sent back to the client with an appropriate HTTP status code and formatted as JSON.</p>
<p class="nonindent">This <code class="calibre7"><strong class="calibre3">controller</strong></code> method call in routes with change in <code class="calibre7"><strong class="calibre3">roles_routes.ts</strong></code> as follows:</p>
<p class="code"><code class="calibre7">// roles_routes.ts</code></p>
<p class="code1"><code class="calibre7">app.route(this.baseEndPoint)</code></p>
<p class="code5"><code class="calibre7">.post(validate(validRoleInput), controller.addHandler)</code></p>
<p class="code5"><code class="calibre7">.get(controller.getAllHandler);</code></p>
<p class="nonindent">By employing this approach, we establish a <code class="calibre7"><strong class="calibre3">GET</strong></code> route that fetches all roles stored in the database, effectively functioning as a REST API endpoint for retrieving role data.</p>
<p class="nonindent"><strong class="calibre3">REST API GetAll Roles</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL : http://127.0.0.1:3000/api/roles</code></p>
<p class="code1"><code class="calibre7">Method: GET</code></p>
<p class="code1"><code class="calibre7">Query Params: {}</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": [</code></p>
<p class="code5"><code class="calibre7"> {</code></p>
<p class="code4"><code class="calibre7"> "role_id": "b88cc70d-ab0a-4464-9562-f6320df519f6",</code></p>
<p class="code4"><code class="calibre7"> "name": "Super Admin",</code></p>
<p class="code4"><code class="calibre7"> "description": "Having All Rights",</code></p>
<p class="code4"><code class="calibre7"> "rights": "add_role,edit_role,get_all_roles,get_details_role,delete_role,add_user,edit_user,get_all_users,get_details_user,</code></p>
<p class="code1"><code class="calibre7">delete_user,add_project,edit_project,get_all_projects,</code></p>
<p class="code1"><code class="calibre7">get_details_project,delete_project,add_task,edit_task,</code></p>
<p class="code1"><code class="calibre7">get_all_tasks,get_details_task,delete_task,add_comment,</code></p>
<p class="code1"><code class="calibre7">edit_comment,get_all_comments,get_details_comment,delete_comment",</code></p>
<p class="code4"><code class="calibre7"> "created_at": "2023-08-16T16:39:14.047Z",</code></p>
<p class="code4"><code class="calibre7"> "updated_at": "2023-08-16T16:39:14.047Z"</code></p>
<p class="code3"><code class="calibre7">}, {</code></p>
<p class="code4"><code class="calibre7"> "role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",</code></p>
<p class="code4"><code class="calibre7"> "name": "visitor",</code></p>
<p class="code4"><code class="calibre7"> "description": null,</code></p>
<p class="code4"><code class="calibre7"> "rights": null,</code></p>
<p class="code4"><code class="calibre7"> "created_at": "2023-08-15T13:04:50.314Z",</code></p>
<p class="code4"><code class="calibre7"> "updated_at": "2023-08-15T13:04:50.314Z"</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">]</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page165"/>If you want to filter or search by exact name, you can change query params as follows:</p>
<p class="code"><code class="calibre7">URL : http://127.0.0.1:5000/api/roles?name=visitor</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code1"><code class="calibre7">It gives only matched data as a response, as follows</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": [</code></p>
<p class="code3"><code class="calibre7">{</code></p>
<p class="code4"><code class="calibre7">"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",</code></p>
<p class="code4"><code class="calibre7">"name": "visitor",</code></p>
<p class="code4"><code class="calibre7">"description": null,</code></p>
<p class="code4"><code class="calibre7">"rights": null,</code></p>
<p class="code4"><code class="calibre7">"created_at": "2023-08-15T13:04:50.314Z",</code></p>
<p class="code4"><code class="calibre7">"updated_at": "2023-08-15T13:04:50.314Z"</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">]</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3">Note</strong>: In base service, query params will now be applicable for only exact matches. We will explore search functionality later on.</p>
<h1 class="sec" id="s151"><a id="page166" class="calibre6"/><a href="toc.xhtml#s151a" class="calibre6">GetOne Role</a></h1>
<p class="nonindent">GetOne role endpoint is a fundamental part of role management systems, allowing users to view specific role information without having to retrieve the entire list of roles. It's essential for providing targeted insights into each role's attributes and permissions.</p>
<p class="nonindent">To implement the GetOne Role API, make the following changes in the <code class="calibre7"><strong class="calibre3">getOneHandler</strong></code> code in the role controller:</p>
<p class="code"><code class="calibre7">// roles_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async getOneHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">const service = new RolesService();</code></p>
<p class="code3"><code class="calibre7">const result = await service.findOne(req.params.id);</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">getOneHandler</strong></code> function serves as the bridge between the incoming client request, the service layer that interacts with the database, and the outgoing HTTP response. It retrieves a single role's details from the database based on the provided role ID and sends the role information back to the client.</p>
<p class="nonindent">This method called from the routes file with making a new route for it as follows:</p>
<p class="code"><code class="calibre7">// roles_routes.ts</code></p>
<p class="code1"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code5"><code class="calibre7">.get(controller.getOneHandler);</code></p>
<p class="nonindent">Here<strong class="calibre3">,</strong> <code class="calibre7"><strong class="calibre3">/:id</strong></code> will be a request parameter meant to capture the ID of the role that the user wants to retrieve.</p>
<p class="nonindent"><strong class="calibre3">REST API</strong> <code class="calibre7"><strong class="calibre3">GetOne</strong></code> <strong class="calibre3">Role</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238</code></p>
<p class="code1"><code class="calibre7">Method: GET</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": {</code></p>
<p class="code3"><code class="calibre7">"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",</code></p>
<p class="code3"><code class="calibre7">"name": "visitor",</code></p>
<p class="code3"><code class="calibre7">"description": null,</code></p>
<p class="code3"><code class="calibre7">"rights": null,</code></p>
<p class="code3"><code class="calibre7">"created_at": "2023-08-15T13:04:50.314Z",</code></p>
<p class="code3"><code class="calibre7">"updated_at": "2023-08-15T13:04:50.314Z"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page167"/>Providing a valid role ID will yield a successful response, while inputting an ID that doesn't correspond to an existing database entry will result in a <code class="calibre7"><strong class="calibre3">404 error</strong></code>, signifying that the requested entity was not found.</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 404,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Not Found"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<h1 class="sec" id="s152"><a href="toc.xhtml#s152a" class="calibre6">Update Role</a></h1>
<p class="nonindent">Updating a role involves modifying the existing data of a specific role stored in the database. This process allows you to adjust the attributes of a role, such as its name, description, and associated rights. By performing an update, you can ensure that the role's information remains accurate and up-to-date. This operation is particularly useful when there are changes in a role's permissions, and you need to reflect those changes in the database.</p>
<p class="nonindent">To implement the Update Role API, make the following changes in the <code class="calibre7"><strong class="calibre3">updateHandler</strong></code> code in the role controller:</p>
<p class="code"><code class="calibre7">// roles_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async updateHandler(req: Request, res: Response) : Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">const role = req.body;</code></p>
<p class="code3"><code class="calibre7">const service = new RolesService();</code></p>
<p class="code3"><code class="calibre7">const result = await service.update(req.params.id, role);</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code1"><code class="calibre7"> }</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">updateHandler</strong></code> function is intended to handle the updating of a role in the database.</p>
<p class="nonindent">It operates by retrieving data from the incoming HTTP request body, which is then utilized to update the corresponding role data in the database based on the role's <a id="page168"/>unique identifier (<code class="calibre7"><strong class="calibre3">role_id</strong></code>) as request parameter ID. The function subsequently generates a response indicating whether the update operation was successful or unsuccessful, providing details about the updated data or an appropriate error message if needed.</p>
<p class="nonindent">This method called from the routes file with making a new route for it as follows:</p>
<p class="code"><code class="calibre7">// roles_routes.ts</code></p>
<p class="code1"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code4"><code class="calibre7"> .get(controller.getOneHandler)</code></p>
<p class="code4"><code class="calibre7"> .put(validate(validRoleInput), controller.updateHandler);</code></p>
<p class="nonindent">Here, <code class="calibre7"><strong class="calibre3">/:id</strong></code> will be a request parameter meant to capture the ID of the role that the user wants to retrieve, and it also validates data before updating in the database.</p>
<p class="nonindent"><strong class="calibre3">REST API Update Role</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238</code></p>
<p class="code1"><code class="calibre7">Method: PUT</code></p>
<p class="code1"><code class="calibre7">body :</code></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"name":"visitor",</code></p>
<p class="code2"><code class="calibre7">"Description":"Allow read projects",</code></p>
<p class="code2"><code class="calibre7">"rights": "get_all_projects,get_details_project"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": {</code></p>
<p class="code3"><code class="calibre7">"role_id": "5f11a06b-e9a7-438d-9f49-757e8239e238",</code></p>
<p class="code3"><code class="calibre7">"name": "visitor",</code></p>
<p class="code3"><code class="calibre7">"description": null,</code></p>
<p class="code3"><code class="calibre7">"created_at": "2023-08-15T13:04:50.314Z",</code></p>
<p class="code3"><code class="calibre7">"updated_at": "2023-08-18T07:35:06.238Z",</code></p>
<p class="code3"><code class="calibre7">"rights": "get_all_projects,get_details_project"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Providing a valid role ID will yield a successful response, while inputting an ID that <a id="page169"/>doesn't correspond to an existing database entry will result in a <code class="calibre7"><strong class="calibre3">404 error</strong></code>, signifying that the requested entity was not found.</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 404,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Not Found"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<h1 class="sec" id="s153"><a href="toc.xhtml#s153a" class="calibre6">Delete Role</a></h1>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">delete</strong></code> functionality for roles in a REST API involves the removal of a specific role from the database. This process is managed through an endpoint dedicated to role deletion. When a request is made to this endpoint, it triggers a function that handles the deletion process. The incoming request typically contains the unique identifier (<code class="calibre7"><strong class="calibre3">role_id</strong></code>) of the role that needs to be deleted.</p>
<p class="nonindent">To implement <code class="calibre7"><strong class="calibre3">Delete</strong></code> Role API, make the following changes in the <code class="calibre7"><strong class="calibre3">deleteHandler</strong></code> code in the role controller:</p>
<p class="code"><code class="calibre7">// roles_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async deleteHandler(req: Request, res: Response) : Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">const service = new RolesService();</code></p>
<p class="code3"><code class="calibre7">const result = await service.delete(req.params.id);</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">deleteHandler</strong></code> processes the request by utilizing a service that interacts with the database. This service is responsible for executing the deletion operation. If the requested role exists in the database and the deletion is successful, the function responds with a success message and an appropriate status code, such as <code class="calibre7"><strong class="calibre3">200 OK</strong></code>. If the role does not exist, the function returns an error response with a status code of 404 Not Found, indicating that the role was not located in the database.</p>
<p class="nonindent">This method called from the routes file with making a new route for it as follows:</p>
<p class="code"><code class="calibre7">// roles_routes.ts</code></p>
<p class="code1"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code5"><code class="calibre7">.get(controller.getOneHandler)</code></p>
<p class="code5"><code class="calibre7">.put(validate(validRoleInput), controller.updateHandler)</code></p>
<p class="code5"><code class="calibre7">.delete(controller.deleteHandler);</code></p>
<p class="nonindent">Here, <code class="calibre7"><strong class="calibre3">/:id</strong></code> will be a request parameter meant to capture the ID of the role that the user wants to delete.</p>
<p class="nonindent"><strong class="calibre3"><a id="page170"/>REST API Delete Role</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/roles/5f11a06b-e9a7-438d-9f49-757e8239e238</code></p>
<p class="code1"><code class="calibre7">Method: DELETE</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In case of already deleted or not exist in database:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 404,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Not Found"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<h1 class="sec" id="s154"><a href="toc.xhtml#s154a" class="calibre6">Add Default Role from System</a></h1>
<p class="nonindent">After implementing APIs related to roles, let's add a feature to create a default role for <code class="calibre7"><strong class="calibre3">SuperAdmin</strong></code> who has all rights in the system during project initialization. This additional functionality can be utilized later for authorization purposes.</p>
<p class="nonindent">Create one file in utils directory with name <code class="calibre7"><strong class="calibre3">ddl_util.ts</strong></code> with the following code:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/ddl_util.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/ddl_util.ts</a></code></p>
<p class="nonindent">This DDLUtil class contains a static method addDefaultRole() responsible for adding a default role to the system.</p>
<p class="nonindent">Now do following changes in main.ts file:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/main.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/main.ts</a></code></p>
<p class="nonindent">As per code, it checks if command-line arguments are provided and if the first argument is <code class="calibre7"><strong class="calibre3">--init</strong></code>. If these conditions are met, an asynchronous function is immediately invoked using an async function. It awaits the execution of <code class="calibre7"><strong class="calibre3">DDLUtil.addDefaultRole()</strong></code>, which presumably initializes a default role in the system. Once <code class="calibre7"><strong class="calibre3">addDefaultRole()</strong></code> completes, <code class="calibre7"><strong class="calibre3">process.exit()</strong></code> is called to terminate the Node.js process. In summary, this code <a id="page171"/>block is responsible for initializing a default role in the system when the program is run with the <code class="calibre7"><strong class="calibre3">--init</strong></code> flag, and then exiting the process afterward.</p>
<figure class="img">
<img alt="" src="img/5.2.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig5_2"><strong class="calibre3">Figure 5.2:</strong> Invoke Add Default Role Script</p>
<p class="nonindent"><strong class="calibre3">Output:</strong></p>
<figure class="img">
<img alt="" src="img/5.3.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig5_3"><strong class="calibre3">Figure 5.3:</strong> Postgres Added Role Output</p>
<p class="nonindent">In summary, role management plays a critical role in ensuring the security and controlled access of users within a system. It allows organizations to define and assign specific permissions and rights to different user roles, ensuring that each user can only perform actions that are relevant to their role and responsibilities.</p>
<h1 class="sec" id="s155"><a href="toc.xhtml#s155a" class="calibre6">User Management</a></h1>
<p class="nonindent">User management refers to the process of handling user-related functionalities in an application. This includes creating, updating, retrieving, and deleting user accounts, as well as managing user roles, permissions, and authentication. User management is a crucial aspect of many applications, especially those that require user registration, authentication, and authorization.</p>
<h1 class="sec" id="s156"><a id="page172" class="calibre6"/><a href="toc.xhtml#s156a" class="calibre6">User Service</a></h1>
<p class="nonindent">Let's create the first user service to perform user table operations. Create <code class="calibre7"><strong class="calibre3">users_service.ts</strong></code> using the following code:</p>
<p class="code"><code class="calibre7">// users_service.ts</code></p>
<p class="code1"><code class="calibre7">import { Repository } from 'typeorm';</code></p>
<p class="code1"><code class="calibre7">import { BaseService } from '../../utils/base_service';</code></p>
<p class="code1"><code class="calibre7">import { DatabaseUtil } from '../../utils/db';</code></p>
<p class="code1"><code class="calibre7">import { Users } from './users_entity';</code></p>
<p class="code"><code class="calibre7">export class UsersService extends BaseService&lt;Users&gt; {</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code2"><code class="calibre7">constructor() {</code></p>
<p class="code3"><code class="calibre7">let userRepository: Repository&lt;Users&gt; | null = null;</code></p>
<p class="code3"><code class="calibre7">userRepository = new DatabaseUtil().getRepository(Users);</code></p>
<p class="code3"><code class="calibre7">super(userRepository);</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">UsersService</strong></code> class is designed to extend the functionality provided by the <code class="calibre7"><strong class="calibre3">BaseService</strong></code> class. It uses the <code class="calibre7"><strong class="calibre3">DatabaseUtil</strong></code> class to get the repository for the User entity and then passes that repository to the constructor of the <code class="calibre7"><strong class="calibre3">BaseService</strong></code> class. This allows the <code class="calibre7"><strong class="calibre3">UsersService</strong></code> class to inherit and use the CRUD methods defined in the <code class="calibre7"><strong class="calibre3">BaseService</strong></code> class for working with the Users entity.</p>
<h1 class="sec" id="s157"><a href="toc.xhtml#s157a" class="calibre6">Input Validation</a></h1>
<p class="nonindent">User input validation is a crucial aspect of developing web applications to ensure data integrity, security, and a smooth user experience. It involves checking and sanitizing the data submitted by users through various input fields, such as <code class="calibre7"><strong class="calibre3">email</strong></code>, <code class="calibre7"><strong class="calibre3">username</strong></code>, <code class="calibre7"><strong class="calibre3">password</strong></code>, <code class="calibre7"><strong class="calibre3">role</strong></code>, and so on.</p>
<p class="nonindent">Now add <code class="calibre7"><strong class="calibre3">validUserInput</strong></code> in the <code class="calibre7"><strong class="calibre3">users_routes.ts</strong></code> file using the following code:</p>
<p class="code"><code class="calibre7">// user_routes.ts</code></p>
<p class="code1"><code class="calibre7">import { body } from 'express-validator';</code></p>
<p class="code1"><code class="calibre7">import { validate } from '../../utils/validator';</code></p>
<p class="code"><code class="calibre7">const validUserInput = [</code></p>
<p class="code2"><code class="calibre7">body('username').trim().notEmpty().withMessage('It should be required'),</code></p>
<p class="code2"><a id="page173"/><code class="calibre7">body('email').isEmail().withMessage('It should be valid emailId'),</code></p>
<p class="code2"><code class="calibre7">body('password')</code></p>
<p class="code3"><code class="calibre7">.isLength({ min: 6, max: 12 }).withMessage('It must be between 6 and 12 characters in length')</code></p>
<p class="code3"><code class="calibre7">.isStrongPassword({ minLowercase: 1, minUppercase: 1,</code></p>
<p class="code1"><code class="calibre7">minSymbols: 1, minNumbers: 1 })</code></p>
<p class="code3"><code class="calibre7">.withMessage('It should include at least one uppercase letter, one lowercase letter, one special symbol, and one numerical digit.'),</code></p>
<p class="code2"><code class="calibre7">body('role_ids').isArray().withMessage('It must be an array of uuids of roles')</code></p>
<p class="code3"><code class="calibre7">.custom((value: string[]) =&gt; {</code></p>
<p class="code4"><code class="calibre7"> if (value?.length &gt; 0 &amp;&amp; value instanceof Array) {</code></p>
<p class="code5"><code class="calibre7">const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;</code></p>
<p class="code5"><code class="calibre7">const isValid = value?.every(uuid =&gt; uuidPattern.test(uuid.trim()));</code></p>
<p class="code5"><code class="calibre7">if (!isValid) {</code></p>
<p class="code6"><code class="calibre7">throw new Error('It has invalid uuids for role');</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code4"><code class="calibre7"> return true; // Validation passed</code></p>
<p class="code3"><code class="calibre7">})</code></p>
<p class="code1"><code class="calibre7">];</code></p>
<ul class="bull">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">validUserInput</strong></code> array: This array contains a series of validation checks for each input field expected in a user. Each element of this array is a validator function that checks a specific aspect of the data.</li>
<li class="calibre9"><a id="page174"/><code class="calibre7"><strong class="calibre3">body('username').trim().notEmpty().withMessage('It should be required')</strong></code>: This validator is applied to the username field in the request body. It removes any leading and trailing whitespace from the input and checks that the input is not empty. If the validation fails, this message will be included in the error response.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">body('email').isEmail().withMessage('It should be valid emailId')</strong></code>: This validator is applied to the email field in the request body. It checks if a valid email ID is provided or not. If the validation fails, it displays a message as given in <code class="calibre7"><strong class="calibre3">withMessage</strong></code>.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">body('password').isLength({ min: 6, max: 12 }).withMessage('It must be between 6 and 12 characters in length').isStrongPassword({ minLowercase: 1, minUppercase: 1, minSymbols: 1, minNumbers: 1 }).withMessage('It should include at least one uppercase letter, one lowercase letter, one special symbol, and one numerical digit.')</strong></code>: This validator is applied to the password field. It checks that the password should be between 6 and 12 characters long and have strong passwords as specified in the given option. If the validation fails, it gives a defined error message.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">body('role_ids')…</strong></code> : It validates the given <code class="calibre7"><strong class="calibre3">role_ids</strong></code> array of UUIDs or not. If any of them are not matched in the db, it gives an error.</li>
</ul>
<h1 class="sec" id="s158"><a href="toc.xhtml#s158a" class="calibre6">User Onboarding</a></h1>
<p class="nonindent">In PMS, a user onboarding facility is provided by a super admin or someone who has permission to add users to the system. First, we create one master or super admin user who has all rights, meaning we assign a role that has each and every right. We have already created a super admin role, so we will assign that <code class="calibre7"><strong class="calibre3">role_id</strong></code> to the user and create a super admin user.</p>
<p class="nonindent">We will store the user's password in the database in an encrypted form instead of plain text for security reasons. So, we will install an npm package and encryption function, and then compare encrypted password validation during login.</p>
<p class="nonindent">To begin, open the terminal with the root directory of the project and paste the following command:</p>
<p class="code"><code class="calibre7">npm install bcrypt --save</code></p>
<p class="nonindent">Next, open the <code class="calibre7"><strong class="calibre3">common.ts</strong></code> file and add the following functions:</p>
<p class="code"><code class="calibre7">// common.ts</code></p>
<p class="code1"><code class="calibre7">/**</code></p>
<p class="code2"><code class="calibre7">* Encrypts a string using bcrypt hashing.</code></p>
<p class="code2"><code class="calibre7">*</code></p>
<p class="code2"><code class="calibre7">* @param {string} s - The string to be encrypted.</code></p>
<p class="code2"><code class="calibre7">* @returns {Promise&lt;string&gt;} - The encrypted string.</code></p>
<p class="code2"><code class="calibre7">*/</code></p>
<p class="code1"><code class="calibre7">export const encryptString = async (s: string) =&gt; {</code></p>
<p class="code2"><code class="calibre7">const encryptedString = await bcrypt.hash(s, 8);</code></p>
<p class="code2"><code class="calibre7">return encryptedString;</code></p>
<p class="code1"><code class="calibre7">};</code></p>
<p class="code"><code class="calibre7">/**</code></p>
<p class="code2"><code class="calibre7">* Compares a plain string with a bcrypt hash to determine if they match.</code></p>
<p class="code2"><code class="calibre7">*</code></p>
<p class="code2"><code class="calibre7">* @param {string} s - The plain string to be compared.</code></p>
<p class="code2"><code class="calibre7">* @param {string} hash - The bcrypt hash to compare against.</code></p>
<p class="code2"><code class="calibre7">* @returns {Promise&lt;boolean&gt;} - A promise that resolves to true if the comparison is successful, otherwise false.</code></p>
<p class="code2"><code class="calibre7">*/</code></p>
<p class="code1"><code class="calibre7">export const bcryptCompare = async (s, hash) =&gt; {</code></p>
<p class="code2"><code class="calibre7">return await bcrypt.compare(s, hash);</code></p>
<p class="code1"><code class="calibre7">};</code></p>
<p class="nonindent"><a id="page175"/>The <code class="calibre7"><strong class="calibre3">encryptString</strong></code> function takes a string as input and uses the <code class="calibre7"><strong class="calibre3">bcrypt.hash</strong></code> function to perform a one-way hashing with a cost factor of 8. The result is an encrypted string that can be stored securely, The async keyword indicates that the function is asynchronous, meaning it returns a promise that resolves to the encrypted string once the hashing is complete.</p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">bcryptCompare</strong></code> function takes a plain string and a <code class="calibre7"><strong class="calibre3">bcrypt</strong></code> hash as input. It uses the <code class="calibre7"><strong class="calibre3">bcrypt.compare</strong></code> function to compare the plain string with the provided hash. The function returns a promise that resolves to true if the comparison is successful (that is, the plain string matches the hash), and false otherwise. This comparison is used for verifying passwords during authentication processes. The async keyword indicates that the function is asynchronous, meaning it returns a promise that holds the comparison result.</p>
<p class="nonindent">In <code class="calibre7"><strong class="calibre3">validUserInput</strong></code>, we have seen that we just check if the <code class="calibre7"><strong class="calibre3">role_ids</strong></code> field has a value in array form. However, it is necessary to check whether these role IDs exist in the db or not before user insertion in the db. So, we will create the <code class="calibre7"><strong class="calibre3">checkValidRoleIds</strong></code> function in <code class="calibre7"><strong class="calibre3">RolesUtil</strong></code> class.</p>
<p class="code"><code class="calibre7">public static async checkValidRoleIds(role_ids: string[]) {</code></p>
<p class="code3"><code class="calibre7">const roleService = new RolesService();</code></p>
<p class="code3a"><code class="calibre7">// Query the database to check if all role_ids are valid</code></p>
<p class="code3"><code class="calibre7">const roles = await roleService.findByIds(role_ids);</code></p>
<p class="code3a"><code class="calibre7">// Check if all role_ids are found in the database</code></p>
<p class="code3"><code class="calibre7">return roles.data.length === role_ids.length;</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">It queries the database using the <code class="calibre7"><strong class="calibre3">findByIds</strong></code> method from the <code class="calibre7"><strong class="calibre3">roleService</strong></code> instance to retrieve roles based on the provided role IDs, and then it checks whether the number of roles retrieved from the database matches the number of input role IDs. If they match, it indicates that all the provided role IDs are valid; otherwise, it implies that it is not valid <code class="calibre7"><strong class="calibre3">role_ids</strong></code>.</p>
<p class="nonindent"><a id="page176"/>Let's update the <code class="calibre7"><strong class="calibre3">users_controller.ts</strong></code> file using the following code:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/components/users/users_controller.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/components/users/users_controller.ts</a></code></p>
<p class="nonindent">This function appears to handle the addition of a new user by processing the user data, encrypting the password, and checking the validity of role IDs before creating the user using a service class. It also handles errors gracefully by providing appropriate error responses.</p>
<p class="nonindent">Now call <code class="calibre7"><strong class="calibre3">addHandler</strong></code> in user routes with change in the <code class="calibre7"><strong class="calibre3">users_router.ts</strong></code> file as follows:</p>
<p class="code"><code class="calibre7">// users_routes.ts</code></p>
<p class="code1"><code class="calibre7">export class UserRoutes {</code></p>
<p class="code2a"><code class="calibre7">private baseEndPoint = '/api/users';</code></p>
<p class="code2a"><code class="calibre7">constructor(app: Express) {</code></p>
<p class="code3a"><code class="calibre7">const controller = new UserController();</code></p>
<p class="code4a"><code class="calibre7">app.route(this.baseEndPoint)</code></p>
<p class="code5"><code class="calibre7">.post(validate(validUserInput), controller.addHandler);</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">This way we created an add user router with input validation for user onboarding through middleware of validation. If validation happens successfully, then the user is inserted in the database.</p>
<p class="nonindent"><strong class="calibre3">REST API Add User</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:</code></p>
<p class="code1"><code class="calibre7">Method: POST</code></p>
<p class="code1"><code class="calibre7">body :</code></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"fullname":"Super Admin",</code></p>
<p class="code2"><code class="calibre7">"username":"pms-admin",</code></p>
<p class="code2"><code class="calibre7">"email":"admin@pms.com",</code></p>
<p class="code2"><code class="calibre7">"password":"Admin@pms1",</code></p>
<p class="code2"><code class="calibre7">"role_ids":["b88cc70d-ab0a-4464-9562-f6320df519f6"]</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3"><a id="page177"/>Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 201,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": {</code></p>
<p class="code3"><code class="calibre7">"user_id": "f249e681-57d8-4f91-addd-a8c615b43a37",</code></p>
<p class="code3"><code class="calibre7">"fullname": "Super Admin",</code></p>
<p class="code3"><code class="calibre7">"username": "pms-admin",</code></p>
<p class="code3"><code class="calibre7">"email": "admin@pms.com",</code></p>
<p class="code3"><code class="calibre7">"password": "$2b$08$pSsEBELbLrXjDfqBJY/7EuyygVuqDzLyBA0JO8pPnWDYJYp5.O15G",</code></p>
<p class="code3"><code class="calibre7">"role_ids": [</code></p>
<p class="code4"><code class="calibre7"> "b88cc70d-ab0a-4464-9562-f6320df519f6"</code></p>
<p class="code3"><code class="calibre7">],</code></p>
<p class="code3"><code class="calibre7">"created_at": "2023-08-19T18:12:55.315Z",</code></p>
<p class="code3"><code class="calibre7">"updated_at": "2023-08-19T18:12:55.315Z"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In case, if the <code class="calibre7"><strong class="calibre3">role_id</strong></code> has the wrong UUID or does not exist in the role table, then it gives an error with status <code class="calibre7"><strong class="calibre3">400</strong></code> as follows:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 400,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Invalid role_ids"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Here, we onboarded super admin. This admin similarly adds other users and shares their credentials manually with them. Afterward, users can change their own password, which we will cover later on.</p>
<h1 class="sec1" id="s159"><a href="toc.xhtml#s159a" class="calibre6">Add Default User from System</a></h1>
<p class="nonindent">After establishing the default role, let's proceed to create a default user with super admin privileges, granting access to all APIs associated with the default role.</p>
<p class="nonindent">Create one <code class="calibre7"><strong class="calibre3">addDefaultUser</strong></code> method in <code class="calibre7"><strong class="calibre3">ddl_util.ts</strong></code> file with the following code:</p>
<p class="code2a"><code class="calibre7">public static async addDefaultUser(): Promise&lt;boolean&gt; {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7"> await DatabaseUtil.getInstance();</code></p>
<p class="code4"><code class="calibre7"> <a id="page178"/>const service = new UsersService();</code></p>
<p class="code4a"><code class="calibre7"> const user: Users = {</code></p>
<p class="code5"><code class="calibre7">user_id: v4(),</code></p>
<p class="code5"><code class="calibre7">fullname: 'Super Admin',</code></p>
<p class="code5"><code class="calibre7">username: 'superadmin',</code></p>
<p class="code5"><code class="calibre7">email: config.default_user.email,</code></p>
<p class="code5"><code class="calibre7">password: await encryptString(config.default_user.password),</code></p>
<p class="code5"><code class="calibre7">role_id: this.superAdminRoleId,</code></p>
<p class="code5"><code class="calibre7">created_at: new Date(),</code></p>
<p class="code5"><code class="calibre7">updated_at: new Date()</code></p>
<p class="code4"><code class="calibre7"> };</code></p>
<p class="code4"><code class="calibre7"> const result = await service.create(user);</code></p>
<p class="code4"><code class="calibre7"> console.log('Add Default User Result', result);</code></p>
<p class="code4"><code class="calibre7"> if (result.statusCode === 201) {</code></p>
<p class="code5"><code class="calibre7">return true;</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code4"><code class="calibre7"> return false;</code></p>
<p class="code3"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><code class="calibre7"> console.error(`Error while addDefaultRole() =&gt;</code></p>
<p class="code1"><code class="calibre7">${error.message}`);</code></p>
<p class="code4"><code class="calibre7"> return false;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">Here, we added the default user's email and password in <code class="calibre7"><strong class="calibre3">server_config.json</strong></code> file and used it from there, so you can add it in a similar manner as per your convenience.</p>
<p class="nonindent">This function is invoked from the <code class="calibre7"><strong class="calibre3">main.ts</strong></code> file, after creating the default role, as follows:</p>
<p class="code"><code class="calibre7">if (args.length &gt; 0 &amp;&amp; args[0] === '--init') {</code></p>
<p class="code3"><code class="calibre7">(async () =&gt; {</code></p>
<p class="code4"><code class="calibre7"> await DatabaseUtil.getInstance();</code></p>
<p class="code4"><code class="calibre7"> await DDLUtil.addDefaultRole();</code></p>
<p class="code4"><code class="calibre7"> await DDLUtil.addDefaultUser();</code></p>
<p class="code4"><code class="calibre7"> process.exit();</code></p>
<p class="code3"><code class="calibre7">})();</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page179"/>Now run the script and see the following output:</p>
<figure class="img">
<img alt="" src="img/5.4.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig5_4"><strong class="calibre3">Figure 5.4:</strong> Add Default User from Script</p>
<p class="nonindent">Output:</p>
<figure class="img">
<img alt="" src="img/5.5.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig5_5"><strong class="calibre3">Figure 5.5:</strong> Postgres Database Added User Output</p>
<h1 class="sec" id="s160"><a href="toc.xhtml#s160a" class="calibre6">User Sign-In</a></h1>
<p class="nonindent">Once the user registration process is completed, users should have the capability to log into the application. As a component of the user sign-in procedure, an API will be established to enable users to request the server using their email and password. The server's role is to verify whether the user exists and if the provided password is valid. If the validation fails, an error response is generated. However, if the validation is successful, the server responds with both an access token and a refresh token. This entire process is known as <strong class="calibre3">authentication</strong>.</p>
<p class="nonindent">Upon successful login, each subsequent API request must incorporate the access token in the request header. The server's task at this point is to verify the validity of the token. If the token is invalid, an error response is generated, preventing further actions. Conversely, if the token is valid, the server grants permission for the requested <a id="page180"/>actions to be executed. This aspect of validating the access token and permitting or denying actions is referred to as <strong class="calibre3">authorization</strong>.</p>
<p class="nonindent">To create <code class="calibre7"><strong class="calibre3">AccessToken</strong></code>, we will use the <code class="calibre7"><strong class="calibre3">jsonwebtoken</strong></code>, also known as JWT token. First, you will need to install the npm package. For more information, please visit <a href="https://www.npmjs.com/package/jsonwebtoken">https://www.npmjs.com/package/jsonwebtoken</a></p>
<p class="nonindent">Open the terminal with the root directory and paste the following command:</p>
<p class="code"><code class="calibre7">npm install jsonwebtoken -- save</code></p>
<p class="code1"><code class="calibre7">npm install @types/jsonwebtoken -D</code></p>
<p class="nonindent">Here is a general overview of how JWT works:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Token Structure</strong>: A JWT consists of three parts: header, payload, and signature. These parts are base64-encoded and combined with periods.
<ul class="bull1">
<li class="calibre9"><strong class="calibre3">Header</strong>: Contains info about the signing algorithm and token type.</li>
<li class="calibre9"><strong class="calibre3">Payload</strong>: Contains claims (user info, expiration time, and so on).</li>
<li class="calibre9"><strong class="calibre3">Signature</strong>: Used for verification and to ensure data integrity.</li></ul></li>
<li class="calibre9"><strong class="calibre3">Token Creation</strong>: When a user logs in, the server constructs the header and payload, including user details and other info. The server signs the JWT using a secret key or private key.</li>
<li class="calibre9"><strong class="calibre3">Token Issuance</strong>: The server sends the JWT to the client after successful login. The client stores it, often in cookies or local storage.</li>
<li class="calibre9"><strong class="calibre3">Token Usage</strong>: In subsequent requests, the client sends the JWT in the Authorization header or as a parameter. This helps the server verify the request's authenticity and identify the user by decoding the payload.</li>
<li class="calibre9"><strong class="calibre3">Token Verification:</strong> The server verifies the JWT by recalculating the signature using the same key. If the recalculated signature matches the JWT's signature, the token is valid.</li>
<li class="calibre9"><strong class="calibre3">Token Expiration</strong>: JWTs usually have an expiration time (exp claim) to prevent indefinite validity. Servers can reject expired tokens by checking the expiration time in the payload.</li>
<li class="calibre9"><strong class="calibre3">Token Revocation (Optional)</strong>: JWTs are stateless, meaning the server doesn't keep track of them after issuing. If you need to revoke a JWT before it expires, extra measures like maintaining a list of revoked tokens are required.</li>
</ul>
<p class="nonindent">Remember, the security of JWTs relies on protecting the secret key (or private key) and ensuring proper token verification on the server side.</p>
<p class="nonindent"><a id="page181"/>Let's define constants for JWT secret and expiration times in the <code class="calibre7"><strong class="calibre3">common.ts</strong></code> file as follows:</p>
<p class="code"><code class="calibre7">// common.ts</code></p>
<p class="code1"><code class="calibre7">export const SERVER_CONST = {</code></p>
<p class="code2"><code class="calibre7">JWTSECRET: 'SecretKeyOfPMS-SECRET',</code></p>
<p class="code2"><code class="calibre7">ACCESS_TOKEN_EXPIRY_TIME_SECONDS: 1 * 8 * 60 * 60, // 8 hours</code></p>
<p class="code2"><code class="calibre7">REFRESH_TOKEN_EXPIRY_TIME_SECONDS: 5 * 7 * 24 * 60 * 60, // one week</code></p>
<p class="code1"><code class="calibre7">};</code></p>
<p class="nonindent">The mentioned parameters are flexible and adaptable according to your needs.</p>
<h1 class="sec1" id="s161"><a href="toc.xhtml#s161a" class="calibre6">Authentication</a></h1>
<p class="nonindent">In the standard login process, two tokens are usually created: an access token and a refresh token, each having distinct expiration times. The access token has a shorter lifespan, while the refresh token has a longer one. If the access token expires, the refresh token can be used to generate a new access token, facilitating seamless reauthentication without requiring manual login. This approach ensures continuous access without interruption.</p>
<p class="nonindent">This process is called <strong class="calibre3">Authentication</strong> in terms of generation of tokens.</p>
<p class="nonindent">Let's create login function in the <code class="calibre7"><strong class="calibre3">users_controller.ts</strong></code> file as follows:</p>
<p class="code"><code class="calibre7">// user_controller.ts</code></p>
<p class="code1"><code class="calibre7">import * as jwt from 'jsonwebtoken';</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code3a"><code class="calibre7">/**</code></p>
<p class="code3"><code class="calibre7">* Handles user login by checking credentials, generating tokens, and responding with tokens.</code></p>
<p class="code3"><code class="calibre7">*</code></p>
<p class="code3"><code class="calibre7">* @param {Request} req - The request object.</code></p>
<p class="code3"><code class="calibre7">* @param {Response} res - The response object.</code></p>
<p class="code3"><code class="calibre7">*/</code></p>
<p class="code2"><code class="calibre7">public async login(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">const { email, password } = req.body;</code></p>
<p class="code3a"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code3a"><code class="calibre7">// Find user by email</code></p>
<p class="code3"><code class="calibre7">const result = await service.findAll({ email: email });</code></p>
<p class="code3"><a id="page182"/><code class="calibre7">if (result.data.length &lt; 1) {</code></p>
<p class="code4"><code class="calibre7"> res.status(404).json({ statusCode: 404, status: 'error', message: 'Email</code></p>
<p class="code4"><code class="calibre7"> not found' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">} else {</code></p>
<p class="code4"><code class="calibre7"> const user = result.data[0];</code></p>
<p class="code4a"><code class="calibre7"> // Compare provided password with stored hashed password</code></p>
<p class="code4"><code class="calibre7"> const comparePasswords = await bcryptCompare(password, user.password);</code></p>
<p class="code4"><code class="calibre7"> if (!comparePasswords) {</code></p>
<p class="code5"><code class="calibre7">res.status(400).json({ statusCode: 400, status: 'error', message: 'Password is not valid' });</code></p>
<p class="code5"><code class="calibre7">return;</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code4a"><code class="calibre7"> // Generate access and refresh tokens</code></p>
<p class="code4"><code class="calibre7"> const accessToken: string = jwt.sign({</code></p>
<p class="code5"><code class="calibre7">email: user.email,</code></p>
<p class="code5"><code class="calibre7">username: user.username</code></p>
<p class="code5"><code class="calibre7">}, SERVER_CONST.JWTSECRET, { expiresIn:</code></p>
<p class="code4"><code class="calibre7"> SERVER_CONST.ACCESS_TOKEN_EXPIRY_TIME_SECONDS });</code></p>
<p class="code4a"><code class="calibre7"> const refreshToken: string = jwt.sign({</code></p>
<p class="code5"><code class="calibre7">email: user.email,</code></p>
<p class="code5"><code class="calibre7">username: user.username</code></p>
<p class="code4"><code class="calibre7"> }, SERVER_CONST.JWTSECRET, { expiresIn:</code></p>
<p class="code5"><code class="calibre7">SERVER_CONST.REFRESH_TOKEN_EXPIRY_TIME_SECONDS });</code></p>
<p class="code4a"><code class="calibre7"> // Respond with tokens</code></p>
<p class="code4"><code class="calibre7"> res.status(200).json({ statusCode: 200, status: 'success', data: {</code></p>
<p class="code4"><code class="calibre7"> accessToken, refreshToken } });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page183"/>In this code, the login function handles user login functionality using the following steps:</p>
<ul class="bull">
<li class="calibre9">It receives the email and password from the request body.</li>
<li class="calibre9">It creates an instance of the <code class="calibre7"><strong class="calibre3">UsersService</strong></code> class to interact with user data.</li>
<li class="calibre9">It queries the database to find a user based on the provided email.</li>
<li class="calibre9">If no user is found with the provided email, it sends a 404 error response.</li>
<li class="calibre9">If a user is found, it compares the provided password with the hashed password stored in the user's data. If the passwords don't match, it sends a 400 error response.</li>
<li class="calibre9">If the passwords match, it generates an access token and a refresh token using the <code class="calibre7"><strong class="calibre3">jwt.sign</strong></code> function. The access token contains user information and has a short expiration time, while the refresh token has a longer expiration time.</li>
<li class="calibre9">It sends a success response (status <code class="calibre7"><strong class="calibre3">200</strong></code>) containing the generated access and refresh tokens.</li>
</ul>
<p class="nonindent">Now add another function <code class="calibre7"><strong class="calibre3">getAccessTokenFromRefreshToken</strong></code> in the same file using the following code:</p>
<p class="code2a"><code class="calibre7">/**</code></p>
<p class="code2"><code class="calibre7"> * Generates a new access token using a valid refresh token.</code></p>
<p class="code2"><code class="calibre7"> *</code></p>
<p class="code2"><code class="calibre7"> * @param {Request} req - The request object.</code></p>
<p class="code2"><code class="calibre7"> * @param {Response} res - The response object.</code></p>
<p class="code2"><code class="calibre7"> */</code></p>
<p class="code2"><code class="calibre7"> public async getAccessTokenFromRefreshToken(req: Request, res:</code></p>
<p class="code1"><code class="calibre7">Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">// Get the refresh token from the request body</code></p>
<p class="code3"><code class="calibre7">const refreshToken = req.body.refreshToken;</code></p>
<p class="code3a"><code class="calibre7">// Verify the refresh token</code></p>
<p class="code3"><code class="calibre7">jwt.verify(refreshToken, SERVER_CONST.JWTSECRET, (err, user) =&gt; {</code></p>
<p class="code4a"><code class="calibre7">if (err) {</code></p>
<p class="code5"><code class="calibre7">// If refresh token is invalid, send a 403 error response</code></p>
<p class="code5"><code class="calibre7">res.status(403).json({ statusCode: 403, status:</code></p>
<p class="code1"><code class="calibre7">'error', message: 'Invalid Refresh Token' });</code></p>
<p class="code5"><code class="calibre7">return;</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code4"><a id="page184"/><code class="calibre7">// Generate a new access token using user information from the refresh token</code></p>
<p class="code4"><code class="calibre7">const accessToken = jwt.sign(user, SERVER_CONST.JWTSECRET, { expiresIn: SERVER_CONST.ACCESS_TOKEN_EXPIRY_TIME_SECONDS });</code></p>
<p class="code4a"><code class="calibre7">// Respond with the new access token</code></p>
<p class="code4"><code class="calibre7">res.status(200).json({ statusCode: 200, status: 'success', data: { accessToken } });</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">getAccessTokenFromRefreshToken</strong></code> function handles the generation of a new access token using a valid refresh token. It retrieves the refresh token from the request body. It uses the <code class="calibre7"><strong class="calibre3">jwt.verify</strong></code> function to verify the refresh token. If the refresh token is invalid or has expired, an error will be caught in the <code class="calibre7"><strong class="calibre3">err</strong></code> parameter. If the refresh token is invalid, it sends a 403 error response indicating an invalid refresh token. If the refresh token is valid, it uses the user information decoded from the refresh token to generate a new access token using the same <code class="calibre7"><strong class="calibre3">jwt.sign</strong></code> function. The new access token is signed with the same secret key and has a shorter expiration time. It sends a success response (status <code class="calibre7"><strong class="calibre3">200</strong></code>) containing the newly generated access token.</p>
<p class="nonindent">These two functions are called from routes for HTTP requests, so let's add two routes in the <code class="calibre7"><strong class="calibre3">users_router.ts</strong></code> file as follows:</p>
<p class="code"><code class="calibre7">// users_router.ts</code></p>
<p class="code1"><code class="calibre7">app.route('/api/login')</code></p>
<p class="code4"><code class="calibre7"> .post(controller.login);</code></p>
<p class="code"><code class="calibre7">app.route('/api/refresh_token')</code></p>
<p class="code4"><code class="calibre7"> .post(controller.getAccessTokenFromRefreshToken);</code></p>
<p class="nonindent"><strong class="calibre3">Sign In API</strong></p>
<p class="nonindent"><strong class="calibre3">REST API Login</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:</code></p>
<p class="code1"><code class="calibre7">Method: POST</code></p>
<p class="code1"><code class="calibre7">body :</code></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"email":"admin@pms.com",</code></p>
<p class="code2"><code class="calibre7">"password":"Admin@pms1"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3"><a id="page185"/>Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": {</code></p>
<p class="code3"><code class="calibre7">"accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJ1c2VybmFtZSI6InlhbWluaSIsInR5cCI6IkJlYXJlciIsImlhdCI6MTY5MjY0MjgwNywiZXhwIjoxNjkyNjcxNjA3fQ.LzYu6ZZT501MvRbuiZGNCv-kMD9UdWMG_iNYCuI3ta4",</code></p>
<p class="code3"><code class="calibre7">"refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJ1c2VybmFtZSI6InlhbWluaSIsInR5cCI6IlJlZnJlc2giLCJpYXQiOjE2OTI2NDI4MDcsImV4cCI6MTY5NTY2NjgwN30.bbbVs_7AUTpwqDxOhyx66A59uV-CIrkPvEdJsDWD-OM"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In case of a wrong email ID passed in a request, the server will respond with the following error message:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 404,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Email not found"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Similarly, if a wrong password is sent in the request, then it will result in a <code class="calibre7"><strong class="calibre3">400 error</strong></code> code, as follows:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 400,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Password is not valid"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In this manner, users can effortlessly and securely log into the application.</p>
<h1 class="sec" id="s162"><a href="toc.xhtml#s162a" class="calibre6">Authorization</a></h1>
<p class="nonindent">Authorization is the process of determining whether a user or entity has the right permissions to access certain resources or perform specific actions within an application. It is a critical component of security that ensures that users can only access the data and functionality they are allowed to while protecting sensitive information and preventing unauthorized actions.</p>
<p class="nonindent"><a id="page186"/>We are going to create a middleware function responsible for authorizing whether the JWT token is valid or not. If it is valid, then only pass it to the next function or the actual API; otherwise, we will restrict and give an error as 401 unauthorized.</p>
<p class="nonindent">Create <code class="calibre7"><strong class="calibre3">custom.d.ts</strong></code> file in the <code class="calibre7"><strong class="calibre3">src</strong></code> directory with the following code:</p>
<p class="code"><code class="calibre7">// custom.d.ts</code></p>
<p class="code1"><code class="calibre7">declare namespace Express {</code></p>
<p class="code2"><code class="calibre7">interface Request {</code></p>
<p class="code3"><code class="calibre7">user?: {</code></p>
<p class="code4"><code class="calibre7"> username?: string;</code></p>
<p class="code4"><code class="calibre7"> email?: string;</code></p>
<p class="code4"><code class="calibre7"> rights?: string[];</code></p>
<p class="code4"><code class="calibre7"> user_id?: string;</code></p>
<p class="code3"><code class="calibre7">};</code></p>
<p class="code3"><code class="calibre7">// Add any other custom properties you need</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In this part of the code, a <code class="calibre7"><strong class="calibre3">TypeScript</strong></code> namespace declaration is used to extend the Request interface provided by the <code class="calibre7"><strong class="calibre3">Express.js</strong></code> framework. It adds a custom property called user to the Request object. This user property is an optional object that can contain properties such as username, email, and rights. The comment suggests that you can add any other custom properties you might need here.</p>
<p class="nonindent">Now, let's make <code class="calibre7"><strong class="calibre3">UsersUtils</strong></code> in the <code class="calibre7"><strong class="calibre3">users_controller.ts</strong></code> file with the following code:</p>
<p class="code"><code class="calibre7">// users_controller.ts</code></p>
<p class="code1"><code class="calibre7">export class UsersUtil {</code></p>
<p class="code2"><code class="calibre7">public static async getUserFromUsername(username: string) {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7"> if (username) {</code></p>
<p class="code5"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code5"><code class="calibre7">const users = await service.customQuery(`username = '${username}'`);</code></p>
<p class="code5"><code class="calibre7">if (users &amp;&amp; users.length &gt; 0) {</code></p>
<p class="code6"><code class="calibre7">return users[0];</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code3"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><code class="calibre7"> console.error(`Error while getUserFromToken() =&gt; ${error.message}`);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">return null;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page187"/>The <code class="calibre7"><strong class="calibre3">getUserFromUsername</strong></code> function accepts a username as its input parameter and retrieves the corresponding user from the database. If the provided username does not have a match in the database, the function returns a null response.</p>
<p class="nonindent">After that, add one method in <code class="calibre7"><strong class="calibre3">RolesUtil</strong></code> to get rights from roles:</p>
<p class="code"><code class="calibre7">public static async getAllRightsFromRoles(role_ids: string[]):</code></p>
<p class="code1"><code class="calibre7">Promise&lt;string[]&gt; {</code></p>
<p class="code3a"><code class="calibre7">// Create an instance of RolesService to interact with the roles</code></p>
<p class="code3"><code class="calibre7">const roleService = new RolesService();</code></p>
<p class="code3a"><code class="calibre7">// Initialize an array to store the collected rights</code></p>
<p class="code3"><code class="calibre7">let rights: string[] = [];</code></p>
<p class="code3a"><code class="calibre7">// Query the database to validate the provided role_ids</code></p>
<p class="code3"><code class="calibre7">const queryData = await roleService.findByIds(role_ids);</code></p>
<p class="code3"><code class="calibre7">const roles: Roles[] = queryData.data ? queryData.data : [];</code></p>
<p class="code3a"><code class="calibre7">// Extract rights from each role and add them to the rights array</code></p>
<p class="code3"><code class="calibre7">roles.forEach((role) =&gt; {</code></p>
<p class="code4"><code class="calibre7"> const rightFromRole: string[] = role.rights.split(',');</code></p>
<p class="code4"><code class="calibre7"> rights = […new Set(rights.concat(rightFromRole))];</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code3a"><code class="calibre7">// Return the accumulated rights</code></p>
<p class="code3"><code class="calibre7">return rights;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">getAllRightsFromRoles</strong></code> is designed to retrieve and consolidate rights associated with a collection of role IDs. The function queries the database using the provided role IDs to fetch corresponding role data. For each retrieved role, the associated rights are <a id="page188"/>extracted by splitting the rights string. These rights are then added to the rights array while avoiding duplicates using a set-based approach. Finally, the function returns an array containing the accumulated and unique rights gathered from all the roles.</p>
<p class="nonindent">Let's create <code class="calibre7"><strong class="calibre3">auth_util.ts</strong></code> in the utils directory using the following code:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/auth_util.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/auth_util.ts</a></code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">authorize</strong></code> middleware function is responsible for verifying the authorization token, decoding it, and attaching user-related information to the <code class="calibre7"><strong class="calibre3">req.user</strong></code> object. It first checks if the authorization token exists in the request headers. If not, it returns a 401 Unauthorized response indicating a missing token. The token is split to extract the actual token value after the “Bearer” prefix. The token is then verified using the provided JWT secret. If the token is successfully decoded, it extracts the username and email from the decoded token and assigns them to <code class="calibre7"><strong class="calibre3">req.user.username</strong></code> and <code class="calibre7"><strong class="calibre3">req.user.email</strong></code>, respectively. If a valid username exists, it fetches the user's information and assigned it to <code class="calibre7"><strong class="calibre3">req.user</strong></code>. Finally, if everything is successful, the middleware proceeds to the next middleware using the <code class="calibre7"><strong class="calibre3">next()</strong></code> function.</p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">hasPermission</strong></code> function takes an array of user rights and a desired right as parameters. It checks if the array of user rights includes the desired right. If the desired right is found in the user rights, the function returns true; otherwise, it returns false.</p>
<p class="nonindent">We created raw functions of authorization, and now change call the <code class="calibre7"><strong class="calibre3">authorize</strong></code> function in the routes file for each API, as follows:</p>
<p class="code"><code class="calibre7">// users_routes.ts</code></p>
<p class="code1"><code class="calibre7">export class UserRoutes {</code></p>
<p class="code2a"><code class="calibre7">private baseEndPoint = '/api/users';</code></p>
<p class="code2a"><code class="calibre7">constructor(app: Express) {</code></p>
<p class="code3a"><code class="calibre7">const controller = new UserController();</code></p>
<p class="code3a"><code class="calibre7">app.route(this.baseEndPoint)</code></p>
<p class="code4"><a id="page189"/><code class="calibre7"> .all(authorize) // Apply authorization middleware to all routes under this endpoint</code></p>
<p class="code4"><code class="calibre7"> .get(controller.getAllHandler)</code></p>
<p class="code4"><code class="calibre7"> .post(validate(validUserInput), controller.addHandler);</code></p>
<p class="code3a"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code4"><code class="calibre7">.all(authorize) // Apply authorization middleware to all routes under this endpoint</code></p>
<p class="code4"><code class="calibre7">.get(controller.getOneHandler)</code></p>
<p class="code4"><code class="calibre7">.put(controller.updateHandler)</code></p>
<p class="code4"><code class="calibre7">.delete(controller.deleteHandler);</code></p>
<p class="code3a"><code class="calibre7">app.route('/api/login')</code></p>
<p class="code4"><code class="calibre7">.post(controller.login);</code></p>
<p class="code3a"><code class="calibre7">app.route('/api/refresh_token')</code></p>
<p class="code4"><code class="calibre7">.post(controller.getAccessTokenFromRefreshToken);</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Authorization is not required for the login and refresh token API since it falls under the category of authentication APIs:</p>
<p class="code"><code class="calibre7">// roles_routes.ts</code></p>
<p class="code1"><code class="calibre7">export class RoleRoutes {</code></p>
<p class="code2a"><code class="calibre7">private baseEndPoint = '/api/roles';</code></p>
<p class="code2a"><code class="calibre7">constructor(app: Express) {</code></p>
<p class="code3a"><code class="calibre7">const controller = new RoleController();</code></p>
<p class="code3"><code class="calibre7">app.route(this.baseEndPoint)</code></p>
<p class="code4"><code class="calibre7">.all(authorize)</code></p>
<p class="code4"><code class="calibre7">.post(validate(validRoleInput), controller.addHandler)</code></p>
<p class="code4"><code class="calibre7">.get(controller.getAllHandler);</code></p>
<p class="code3a"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code4"><code class="calibre7">.all(authorize)</code></p>
<p class="code4"><code class="calibre7">.get(controller.getOneHandler)</code></p>
<p class="code4"><code class="calibre7">.put(validate(validRoleInput), controller.updateHandler)</code></p>
<p class="code4"><code class="calibre7">.delete(controller.deleteHandler);</code></p>
<p class="code2"><code class="calibre7"/></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page190"/>From now onwards, make sure, except for the login and refresh token APIs, you have to pass the access token with bearer type in the header as Authorization in the request; otherwise, it gives an error:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 401,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Missing Authorization Token"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Checking for valid rights of permission is also a part of Authorization. We have already created a <code class="calibre7"><strong class="calibre3">hasPermission</strong></code> method that will be the first call in each API controller with respective rights.</p>
<p class="nonindent">In the User Controller, add the following checks with their respective methods:</p>
<p class="code"><code class="calibre7">// addHandler</code></p>
<p class="code2"><code class="calibre7"> public async addHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7"> if (!hasPermission(req.user.rights, 'add_user')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code3"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7"> …</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">// getAllHandler</code></p>
<p class="code2"><code class="calibre7">public async getAllHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">if (!hasPermission(req.user.rights, 'get_all_users')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code3"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"> …</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">// getOneHandler</code></p>
<p class="code1"><code class="calibre7">public async getOneHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">if (!hasPermission(req.user.rights, 'get_details_user')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code3"><code class="calibre7">return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"> …</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code"><a id="page191"/><code class="calibre7">// updateHandler</code></p>
<p class="code1"><code class="calibre7">public async updateHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">if (!hasPermission(req.user.rights, 'edit_user')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code3"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"> …</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">// deleteHandler</code></p>
<p class="code1"><code class="calibre7">public async deleteHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">if (!hasPermission(req.user.rights, 'delete_user')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code3"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"> …</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">Similarly, add in the Role controller to check permission for roles API:</p>
<p class="code"><code class="calibre7">// addHandler</code></p>
<p class="code2"><code class="calibre7"> public async addHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7"> if (!hasPermission(req.user.rights, 'add_role')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code3"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7"> …</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><a id="page192"/><code class="calibre7">// getAllHandler</code></p>
<p class="code2"><code class="calibre7">public async getAllHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">if (!hasPermission(req.user.rights, 'get_all_roles')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"> …</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">// getOneHandler</code></p>
<p class="code1"><code class="calibre7">public async getOneHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">if (!hasPermission(req.user.rights, 'get_details_role')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"> …</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">// updateHandler</code></p>
<p class="code1"><code class="calibre7">public async updateHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">if (!hasPermission(req.user.rights, 'edit_role')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"> …</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><a id="page193"/><code class="calibre7">// deleteHandler</code></p>
<p class="code1"><code class="calibre7">public async deleteHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code2"><code class="calibre7">if (!hasPermission(req.user.rights, 'delete_role')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error',</code></p>
<p class="code4"><code class="calibre7">message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7"> …</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">This is how middleware functions for authorization and permissions work in an <code class="calibre7"><strong class="calibre3">Express.js</strong></code> application. It extends the Request interface to include a user object with properties such as username, email, and rights. The <code class="calibre7"><strong class="calibre3">authorize</strong></code> middleware verifies JSON Web Tokens (JWTs) from the request header, extracts user information, and checks permissions. The <code class="calibre7"><strong class="calibre3">hasPermission</strong></code> function checks if a user's rights include the desired permission. Moving forward, except for the login and refresh token APIs, the access token should be passed in the header as a bearer type using the <strong class="calibre3">Authorization</strong> field.</p>
<h1 class="sec" id="s163"><a href="toc.xhtml#s163a" class="calibre6">GetAll Users</a></h1>
<p class="nonindent">After successfully onboarding users, we can proceed to retrieve the newly inserted users from the database. So, update the <code class="calibre7"><strong class="calibre3">getAllHandler</strong></code> method in the <code class="calibre7"><strong class="calibre3">users_controller.ts</strong></code> file using the following code:</p>
<p class="code"><code class="calibre7">public async getAllHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">if (!hasPermission(req.user.rights, 'get_all_users')) {</code></p>
<p class="code4"><code class="calibre7">res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7">return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code3"><code class="calibre7">const result = await service.findAll(req.query);</code></p>
<p class="code3"><code class="calibre7">if (result.statusCode === 200) {</code></p>
<p class="code4"><code class="calibre7">// Remove password field to send in response</code></p>
<p class="code4"><code class="calibre7">result.data.forEach(i =&gt; delete i.password);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code3"><code class="calibre7">return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page194"/>The <code class="calibre7"><strong class="calibre3">getAllHandler</strong></code> method uses the <code class="calibre7"><strong class="calibre3">UsersService</strong></code> class to retrieve all users from the database based on the query parameters in the request. The resulting data is then sent back to the client with an appropriate HTTP status code and formatted as JSON.</p>
<p class="nonindent">This controller method call in routes with a change in <code class="calibre7"><strong class="calibre3">roles_routes.ts</strong></code> as follows:</p>
<p class="code"><code class="calibre7">app.route(this.baseEndPoint)</code></p>
<p class="code4"><code class="calibre7"> .all(authorize) // Apply authorization middleware to all routes under this endpoint</code></p>
<p class="code4"><code class="calibre7">.get(controller.getAllHandler)</code></p>
<p class="code4"><code class="calibre7"> .post(validate(validUserInput), controller.addHandler);</code></p>
<p class="nonindent">By employing this approach, we establish a GET route that fetches all roles stored in the database, effectively functioning as a REST API endpoint for retrieving role data.</p>
<p class="nonindent"><strong class="calibre3">REST API GetAll Roles</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/users</code></p>
<p class="code1"><code class="calibre7">Method: GET</code></p>
<p class="code1"><code class="calibre7">Query Params: {}</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": [</code></p>
<p class="code5"><code class="calibre7"> {</code></p>
<p class="code4"><code class="calibre7"> "user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",</code></p>
<p class="code4"><code class="calibre7"> "fullname": "Super Admin",</code></p>
<p class="code4"><code class="calibre7"> "username": "pms-admin",</code></p>
<p class="code4"><code class="calibre7"> "email": "admin@pms.com",</code></p>
<p class="code4"><code class="calibre7"> "role_ids": [</code></p>
<p class="code5"><code class="calibre7">"dbda47e4-f843-4263-a4d6-69ef80156f81"</code></p>
<p class="code4"><code class="calibre7"> ],</code></p>
<p class="code4"><code class="calibre7"> "created_at": "2023-08-22T17:08:24.722Z",</code></p>
<p class="code4"><code class="calibre7"> "updated_at": "2023-08-22T17:08:24.722Z"</code></p>
<p class="code3"><code class="calibre7">}, {</code></p>
<p class="code4"><code class="calibre7"> "user_id": "d166945a-f85d-485c-bdac-0c8056b3188a",</code></p>
<p class="code4"><code class="calibre7"> "fullname": "Yami Panchal",</code></p>
<p class="code4"><code class="calibre7"> "username": "yamini",</code></p>
<p class="code4"><code class="calibre7"> "email": "yami@gmail.com",</code></p>
<p class="code4"><code class="calibre7"> "role_ids": [</code></p>
<p class="code5"><code class="calibre7">"b88cc70d-ab0a-4464-9562-f6320df519f6"</code></p>
<p class="code4"><code class="calibre7"> ],</code></p>
<p class="code4"><code class="calibre7"> "created_at": "2023-08-18T17:57:38.744Z",</code></p>
<p class="code4"><code class="calibre7"> "updated_at": "2023-08-24T16:57:19.110Z"</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">]</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page195"/>If you want to filter or search by exact name, you can change query params as follows:</p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/users?username=pms-admin</code></p>
<p class="nonindent">It gives only matched data as a response, as follows</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": [</code></p>
<p class="code3"><code class="calibre7">{</code></p>
<p class="code4"><code class="calibre7"> "user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",</code></p>
<p class="code4"><code class="calibre7"> "fullname": "Super Admin",</code></p>
<p class="code4"><code class="calibre7"> "username": "pms-admin",</code></p>
<p class="code4"><code class="calibre7"> "email": "admin@pms.com",</code></p>
<p class="code4"><code class="calibre7"> "role_ids": [</code></p>
<p class="code5"><code class="calibre7">"dbda47e4-f843-4263-a4d6-69ef80156f81"</code></p>
<p class="code4"><code class="calibre7"> ],</code></p>
<p class="code4"><code class="calibre7"> "created_at": "2023-08-22T17:08:24.722Z",</code></p>
<p class="code4"><code class="calibre7"> "updated_at": "2023-08-22T17:08:24.722Z"</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">]</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<h1 class="sec" id="s164"><a href="toc.xhtml#s164a" class="calibre6">GetOne User</a></h1>
<p class="nonindent">This endpoint offers a valuable function by providing specific user information. It serves as a crucial tool for users to access their own details and also enables administrators to retrieve specific user information whenever necessary.</p>
<p class="nonindent"><a id="page196"/>To implement the <code class="calibre7"><strong class="calibre3">GetOne</strong></code> User API, make the following changes in the <code class="calibre7"><strong class="calibre3">getOneHandler</strong></code> code in the user controller:</p>
<p class="code"><code class="calibre7">// users_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async getOneHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">if (!hasPermission(req.user.rights, 'get_details_user')) {</code></p>
<p class="code4"><code class="calibre7"> res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code3"><code class="calibre7">const result = await service.findOne(req.params.id);</code></p>
<p class="code3"><code class="calibre7">if (result.statusCode === 200) {</code></p>
<p class="code4"><code class="calibre7"> delete result.data.password;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code3"><code class="calibre7">return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">getOneHandler</strong></code> function serves as the bridge between the incoming client request, the service layer that interacts with the database, and the outgoing HTTP response. It retrieves a single user's details from the database based on the provided user ID and sends the user information back to the client, except password data for security reasons.</p>
<p class="nonindent">This method is called from the routes file by creating a new route for it as follows:</p>
<p class="code"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code4"><code class="calibre7"> .all(authorize) // Apply authorization middleware to all routes under this endpoint</code></p>
<p class="code4"><code class="calibre7"> .get(controller.getOneHandler)</code></p>
<p class="nonindent">Here<strong class="calibre3">,</strong> <code class="calibre7"><strong class="calibre3">/:id</strong></code> will be a request parameter meant to capture the ID of the user that wants to retrieve.</p>
<p class="nonindent"><strong class="calibre3">REST API GetOne Role</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:5000/api/users/b930d02c-43af-4875-b7e9-546c9f4c23dd</code></p>
<p class="code1"><code class="calibre7">Method: GET</code></p>
<p class="nonindent"><strong class="calibre3"><a id="page197"/>Response</strong></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": {</code></p>
<p class="code3"><code class="calibre7">"user_id": "b930d02c-43af-4875-b7e9-546c9f4c23dd",</code></p>
<p class="code3"><code class="calibre7">"fullname": "Super Admin",</code></p>
<p class="code3"><code class="calibre7">"username": "pms-admin",</code></p>
<p class="code3"><code class="calibre7">"email": "admin@pms.com",</code></p>
<p class="code3"><code class="calibre7">"role_ids": [</code></p>
<p class="code4"><code class="calibre7"> "dbda47e4-f843-4263-a4d6-69ef80156f81"</code></p>
<p class="code3"><code class="calibre7">],</code></p>
<p class="code3"><code class="calibre7">"created_at": "2023-08-22T17:08:24.722Z",</code></p>
<p class="code3"><code class="calibre7">"updated_at": "2023-08-22T17:08:24.722Z"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Providing a valid role ID will yield a successful response, while inputting an ID that doesn't correspond to an existing database entry will result in a <code class="calibre7"><strong class="calibre3">404</strong></code> <code class="calibre7"><strong class="calibre3">error</strong></code>, signifying that the requested entity was <code class="calibre7"><strong class="calibre3">Not found</strong></code>.</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 404,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Not Found"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<h1 class="sec" id="s165"><a href="toc.xhtml#s165a" class="calibre6">Update User</a></h1>
<p class="nonindent">In updating user information, it's important to note that the username and email fields won't be modified. These fields are unique identifiers and will retain their initial values as set during creation. Additionally, to change the password, a separate API will be implemented specifically for that purpose, known as the <code class="calibre7"><strong class="calibre3">change password</strong></code> API.</p>
<p class="nonindent">Let's develop <code class="calibre7"><strong class="calibre3">updateHandler</strong></code> in the <code class="calibre7"><strong class="calibre3">users_controller.ts</strong></code> using the following code:</p>
<p class="code"><code class="calibre7">public async updateHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3a"><code class="calibre7">if (!hasPermission(req.user.rights, 'edit_user')) {</code></p>
<p class="code4"><code class="calibre7"> res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3a"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code3"><code class="calibre7">const user = req.body;</code></p>
<p class="code3a"><code class="calibre7"><a id="page198"/>// we will not update email and username once inserted so remove it from body</code></p>
<p class="code3"><code class="calibre7">delete user?.email;</code></p>
<p class="code3"><code class="calibre7">delete user?.username;</code></p>
<p class="code3a"><code class="calibre7">// we will also not update password from here it will be from changePassword function separate</code></p>
<p class="code3"><code class="calibre7">delete user?.password;</code></p>
<p class="code3"><code class="calibre7"/></p>
<p class="code3"><code class="calibre7">const result = await service.update(req.params.id, user);</code></p>
<p class="code3"><code class="calibre7">if (result.statusCode === 200) {</code></p>
<p class="code4"><code class="calibre7"> delete result.data.password;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code3"><code class="calibre7">return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">updateHandler</strong></code> function is intended to handle the updating of a user in the database.</p>
<p class="nonindent">It operates by retrieving data from the incoming HTTP request body, which is then utilized to update the corresponding role data in the database based on the user's unique identifier (<code class="calibre7"><strong class="calibre3">user_id</strong></code>) as request parameter ID. The function subsequently generates a response indicating whether the update operation was successful or unsuccessful, providing details about the updated data or an appropriate error message if needed. We will never send a password data response, so delete that field from the response.</p>
<p class="nonindent">To update a user's time, we just need to validate that the <code class="calibre7"><strong class="calibre3">role_ids</strong></code> are proper. So, perform the validation as follows:</p>
<p class="code"><code class="calibre7">const updateValidUserInput = [</code></p>
<p class="code2"><code class="calibre7">body('role_ids').isArray().withMessage('It must be an array of uuids of roles')</code></p>
<p class="code3"><code class="calibre7">.custom((value: string[]) =&gt; {</code></p>
<p class="code4"><code class="calibre7"> if (value?.length &gt; 0 &amp;&amp; value instanceof Array) {</code></p>
<p class="code5"><code class="calibre7">const uuidPattern = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/;</code></p>
<p class="code5"><code class="calibre7">const isValid = value?.every(uuid =&gt; uuidPattern.test(uuid.trim()));</code></p>
<p class="code5"><code class="calibre7">if (!isValid) {</code></p>
<p class="code6"><code class="calibre7">throw new Error('It has invalid uuids for role');</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code4"><code class="calibre7"> return true; // Validation passed</code></p>
<p class="code3"><code class="calibre7">})</code></p>
<p class="code1"><code class="calibre7">];</code></p>
<p class="nonindent"><a id="page199"/>This method is called from the routes file by creating a new route for it as follows:</p>
<p class="code"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code2"><code class="calibre7"> .all(authorize) // Apply authorization middleware to all routes under this endpoint</code></p>
<p class="code2"><code class="calibre7"> .get(controller.getOneHandler)</code></p>
<p class="code2"><code class="calibre7"> .put(validate(updateValidUserInput), controller.updateHandler);</code></p>
<p class="nonindent"><strong class="calibre3">REST API Update User</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/users/d166945a-f85d-485c-bdac-0c8056b3188a</code></p>
<p class="code1"><code class="calibre7">Method: PUT</code></p>
<p class="code1"><code class="calibre7">body :</code></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"fullname":"Yami Panchal",</code></p>
<p class="code2"><code class="calibre7">"role_ids":["b88cc70d-ab0a-4464-9562-f6320df519f6"]</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"data": {</code></p>
<p class="code3"><code class="calibre7">"fullname": "Yami Panchal",</code></p>
<p class="code3"><code class="calibre7">"username": "yamini",</code></p>
<p class="code3"><code class="calibre7">"email": "yamipanchal1993@gmail.com",</code></p>
<p class="code3"><code class="calibre7">"created_at": "2023-08-18T17:57:38.744Z",</code></p>
<p class="code3"><code class="calibre7">"updated_at": "2023-08-24T16:57:19.110Z",</code></p>
<p class="code3"><code class="calibre7">"role_ids": [</code></p>
<p class="code4"><code class="calibre7"> "b88cc70d-ab0a-4464-9562-f6320df519f6"</code></p>
<p class="code3"><code class="calibre7">],</code></p>
<p class="code3"><code class="calibre7">"user_id": "d166945a-f85d-485c-bdac-0c8056b3188a"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page200"/>Providing a valid role ID will yield a successful response, while inputting an ID that doesn't correspond to an existing database entry will result in a <code class="calibre7"><strong class="calibre3">404 error</strong></code>, signifying that the requested entity was <code class="calibre7"><strong class="calibre3">Not found</strong></code>.</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 404,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Not Found"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<h1 class="sec" id="s166"><a href="toc.xhtml#s166a" class="calibre6">Delete User</a></h1>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">delete</strong></code> functionality for users in a REST API involves the removal of a specific user from the database. This process is managed through an endpoint dedicated to user deletion. When a request is made to this endpoint, it triggers a function that handles the deletion process. The incoming request typically contains the unique identifier (<code class="calibre7"><strong class="calibre3">user_id</strong></code>) of the user that needs to be deleted.</p>
<p class="nonindent">To implement the <code class="calibre7"><strong class="calibre3">Delete User</strong></code> API, make the following changes in the <code class="calibre7"><strong class="calibre3">deleteHandler</strong></code> code in the user controller:</p>
<p class="code"><code class="calibre7">public async deleteHandler(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">if (!hasPermission(req.user.rights, 'delete_user')) {</code></p>
<p class="code4"><code class="calibre7"> res.status(403).json({ statusCode: 403, status: 'error', message: 'Unauthorised' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code3"><code class="calibre7">const result = await service.delete(req.params.id);</code></p>
<p class="code3"><code class="calibre7">res.status(result.statusCode).json(result);</code></p>
<p class="code3"><code class="calibre7">return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page201"/>The <code class="calibre7"><strong class="calibre3">deleteHandler</strong></code> processes the request by utilizing a service that interacts with the database. This service is responsible for executing the deletion operation. If the requested user exists in the database and the deletion is successful, the function responds with a success message and an appropriate status code, such as <code class="calibre7"><strong class="calibre3">200 OK</strong></code>. If the role does not exist, the function returns an error response with a status code of <code class="calibre7"><strong class="calibre3">404 Not Found</strong></code>, indicating that the user was not located in the database.</p>
<p class="nonindent">This method is called from the routes file by creating a new route for it as follows:</p>
<p class="code"><code class="calibre7">app.route(this.baseEndPoint + '/:id')</code></p>
<p class="code4"><code class="calibre7"> .all(authorize)</code></p>
<p class="code4"><code class="calibre7"> .get(controller.getOneHandler)</code></p>
<p class="code5"><code class="calibre7">.put(validate(updateValidUserInput), controller.updateHandler)</code></p>
<p class="code4"><code class="calibre7"> .delete(controller.deleteHandler);</code></p>
<p class="nonindent">Here, <code class="calibre7"><strong class="calibre3">/:id</strong></code> will be a request parameter meant to capture the ID of the role that the user wants to delete.</p>
<p class="nonindent"><strong class="calibre3">REST API Delete Role</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/users/5f11a06b-e9a7-438d-9f49-757e8239e238</code></p>
<p class="code1"><code class="calibre7">Method: DELETE</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In case of already deleted or not exist in database:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 404,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Not Found"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<h1 class="sec" id="s167"><a href="toc.xhtml#s167a" class="calibre6">Password Management</a></h1>
<p class="nonindent">Password Management involves implementing strategies and practices to secure <a id="page202"/>and effectively manage user passwords within digital systems. This encompasses various methods to ensure the confidentiality and integrity of user passwords, as well as enabling users to securely create, update, and recover their passwords. Effective password management is vital for safeguarding sensitive data, preventing unauthorized access, and maintaining the overall security posture of an application or system.</p>
<h1 class="sec" id="s168"><a href="toc.xhtml#s168a" class="calibre6">Change Own Password</a></h1>
<p class="nonindent">During the user information update process, it's been observed that for security reasons, password modifications are not carried out within the same API. Therefore, a distinct API will be developed to address this security concern.</p>
<p class="nonindent">Now, create one method in the <code class="calibre7"><strong class="calibre3">users_controller.ts</strong></code> file for <code class="calibre7"><strong class="calibre3">changePassword</strong></code> as follows:</p>
<p class="code"><code class="calibre7">// users_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async changePassword(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">const { oldPassword, newPassword } = req.body;</code></p>
<p class="code3"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code3"><code class="calibre7">const findUserResult = await service.findOne(req.params.id);</code></p>
<p class="code3"><code class="calibre7">if (findUserResult.statusCode !== 200) {</code></p>
<p class="code4"><code class="calibre7"> res.status(404).send({ statusCode: 404, status: 'error', message: 'User Not Found' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">const user = findUserResult.data;</code></p>
<p class="code3a"><code class="calibre7">// check requested user_id and session user_id is same</code></p>
<p class="code3"><code class="calibre7">if (user?.username !== req.user.username) {</code></p>
<p class="code4"><code class="calibre7"> res.status(400).send({ statusCode: 400, status: 'error', message: 'User can change only own password' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3a"><code class="calibre7">// verify old password is valid</code></p>
<p class="code3"><code class="calibre7">const comparePasswords = await bcryptCompare(oldPassword, user.password);</code></p>
<p class="code3"><code class="calibre7">if (!comparePasswords) {</code></p>
<p class="code4"><code class="calibre7"> res.status(400).json({ statusCode: 400, status: 'error', message: 'oldPassword is not matched' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3a"><a id="page203"/><code class="calibre7">// Encrypt the user's new password</code></p>
<p class="code3"><code class="calibre7">user.password = await encryptString(newPassword);</code></p>
<p class="code3"><code class="calibre7">const result = await service.update(req.params.id, user);</code></p>
<p class="code3"><code class="calibre7">if (result.statusCode === 200) {</code></p>
<p class="code4"><code class="calibre7"> res.status(200).json({ statusCode: 200, status: 'success', message: 'Password is updated successfully' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">} else {</code></p>
<p class="code4"><code class="calibre7"> res.status(result.statusCode).json(result);</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">changePassword</strong></code> function ensures that the user requesting the password change is authorized to do so, verifies the old password, securely encrypts the new password, and updates the user's password in the database.</p>
<p class="nonindent">This method is called from the <code class="calibre7"><strong class="calibre3">users_routes.ts</strong></code> file, so add the following code to the route file:</p>
<p class="code"><code class="calibre7">// users_routes.ts</code></p>
<p class="code1"><code class="calibre7">const validChangePassword = [</code></p>
<p class="code2"><code class="calibre7">body('oldPassword').trim().notEmpty().withMessage('It should be</code></p>
<p class="code1"><code class="calibre7">required'),</code></p>
<p class="code2"><code class="calibre7">body('newPassword')</code></p>
<p class="code3"><code class="calibre7">.isLength({ min: 6, max: 12 }).withMessage('It must be between 6 and 12 characters in length')</code></p>
<p class="code3"><code class="calibre7">.isStrongPassword({ minLowercase: 1, minUppercase: 1,</code></p>
<p class="code1"><code class="calibre7">minSymbols: 1, minNumbers: 1 })</code></p>
<p class="code3"><code class="calibre7">.withMessage('It should include at least one uppercase letter, one lowercase letter, one special symbol, and one numerical digit.'), body('role_ids'),</code></p>
<p class="code1"><code class="calibre7">];</code></p>
<p class="code2a"><code class="calibre7">app.route(this.baseEndPoint + '/changePassword/:id')</code></p>
<p class="code4"><code class="calibre7"> .all(authorize)</code></p>
<p class="code4"><code class="calibre7"> .post(validate(validChangePassword), controller.</code></p>
<p class="code1"><code class="calibre7">changePassword);</code></p>
<p class="nonindent"><a id="page204"/>It will validate old and new Passwords with authorization.</p>
<p class="nonindent"><strong class="calibre3">REST API Change Own Password</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:5000/api/users/changePassword/b930d02c-43af-4875-b7e9-546c9f4c23dd</code></p>
<p class="code1"><code class="calibre7">Method: POST</code></p>
<p class="code1"><code class="calibre7">body :</code></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"oldPassword":"Admin@pms1",</code></p>
<p class="code2"><code class="calibre7">"newPassword":"Admin@pms123"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"message": "Password is updated successfully"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In case of a wrong <code class="calibre7"><strong class="calibre3">oldPassword</strong></code> sent in a request, the server will respond with the following error message:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 400,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "oldPassword is not matched"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Similarly, if a wrong <code class="calibre7"><strong class="calibre3">newPassword</strong></code> is sent in the request then it will result in a 400 error code, as follows:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 400,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"errors": [</code></p>
<p class="code3"><code class="calibre7">{</code></p>
<p class="code4"><code class="calibre7"> "newPassword": "It should include at least one uppercase</code></p>
<p class="code1"><code class="calibre7">letter, one lowercase letter, one special symbol, and one numerical digit."</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">]</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page205"/>In another case, if the <code class="calibre7"><strong class="calibre3">user_id</strong></code> in the request URL does not match the access token passed in the Authorization, then it gives the following response:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 400,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "User can change only own password"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In this manner, users can effortlessly change their password successfully.</p>
<h1 class="sec" id="s169"><a href="toc.xhtml#s169a" class="calibre6">Recover Password</a></h1>
<p class="nonindent">The password recovery process provides a crucial safety net for users who have forgotten their account credentials or need to reset their passwords. By offering a reliable and secure way to regain access to their accounts, this feature enhances user experience and maintains the integrity of your application's security.</p>
<p class="nonindent">The password recovery process will be divided into two distinct steps. The first step involves the <code class="calibre7"><strong class="calibre3">Forgot Password</strong></code> functionality, which triggers the sending of a reset link to the user's email address. In the second step, users will be able to reset their password by validating the reset link's token, thereby granting them access to set a new password.</p>
<p class="nonindent"><strong class="calibre3">Forgot Password</strong></p>
<p class="nonindent">For sending mail to the user on forgot password, we need to install the <code class="calibre7"><strong class="calibre3">nodemailer</strong></code> package. So, open the terminal with the root directory and paste the following command:</p>
<p class="code"><code class="calibre7">npm install nodemailer --save</code></p>
<p class="code1"><code class="calibre7">npm install @types/nodemailer -D</code></p>
<p class="nonindent">For sending mail, you need to set up a Gmail account. If you don't have one, then create an account and afterward follow these steps:</p>
<ol class="num">
<li class="calibre9"><strong class="calibre3">Sign in to your Google Account</strong>:
<p class="nonindent"> Start by signing in to the Gmail account from which you want to send emails using Nodemailer.</p></li>
<li class="calibre9"><strong class="calibre3">Access Security Settings</strong>:
<p class="nonindent"> Click your profile picture or initials in the top-right corner of the Gmail interface. From the drop-down menu, select <code class="calibre7"><strong class="calibre3">Manage your Google Account</strong></code>.</p></li>
<li class="calibre9"><strong class="calibre3">Navigate to Security</strong>:
<p class="nonindent"> In the Google Account settings, navigate to the left sidebar and click <code class="calibre7"><strong class="calibre3">Security</strong></code>.</p></li>
<li class="calibre9"><strong class="calibre3"><a id="page206"/>App Passwords</strong>:
<p class="nonindent"> Scroll down to the <code class="calibre7"><strong class="calibre3">Signing in to Google</strong></code> section and find the <code class="calibre7"><strong class="calibre3">App passwords</strong></code> option. Click <code class="calibre7"><strong class="calibre3">App passwords</strong></code>.</p></li>
<li class="calibre9"><strong class="calibre3">Generate App Password</strong>:
<p class="nonindent"> You may need to verify your identity using your Google Account password. Once verified, you'll be able to generate an app-specific password.</p>
<ol class="num">
<li class="calibre9">Choose the app for which you want to generate the password. Select <code class="calibre7"><strong class="calibre3">Mail</strong></code> if it's not listed and choose <code class="calibre7"><strong class="calibre3">Other (Custom Name)</strong></code>.</li>
<li class="calibre9">Enter a custom name for your app-specific password (for example, <code class="calibre7"><strong class="calibre3">Nodemailer App</strong></code>). Click <code class="calibre7"><strong class="calibre3">Generate</strong></code>.</li>
<li class="calibre9">Copy the App Password:
<p class="nonindent">Google will generate a unique app-specific password for your application. Copy this password and keep it secure.</p></li></ol></li>
<li class="calibre9"><strong class="calibre3">Use App Password in Your Code:</strong>
<p class="nonindent"> Replace the regular password in your code with the app-specific password you generated. This app-specific password will be used to authenticate your application with Gmail's SMTP server.</p></li>
</ol>
<p class="nonindent">Keep in mind that app-specific passwords are only shown once when generated. If you lose the password or need to generate a new one, you'll need to repeat the process.</p>
<p class="nonindent">Now add <code class="calibre7"><strong class="calibre3">email_configs</strong></code> and front URL in <code class="calibre7"><strong class="calibre3">config.ts</strong></code>:</p>
<p class="code"><code class="calibre7">// config.ts</code></p>
<p class="code1"><code class="calibre7">export interface IServerConfig {</code></p>
<p class="code2"><code class="calibre7">port: number;</code></p>
<p class="code2"><code class="calibre7">db_config: {</code></p>
<p class="code3"><code class="calibre7">'db': string;</code></p>
<p class="code3"><code class="calibre7">'username': string;</code></p>
<p class="code3"><code class="calibre7">'password': string;</code></p>
<p class="code3"><code class="calibre7">'host': string;</code></p>
<p class="code3"><code class="calibre7">'port': number;</code></p>
<p class="code3"><code class="calibre7">'dbname': string;</code></p>
<p class="code2"><code class="calibre7">};</code></p>
<p class="code2"><code class="calibre7">email_config: {</code></p>
<p class="code3"><code class="calibre7">'from': string;</code></p>
<p class="code3"><code class="calibre7">'user': string;</code></p>
<p class="code3"><code class="calibre7">'password': string;</code></p>
<p class="code2"><code class="calibre7">};</code></p>
<p class="code2"><code class="calibre7">front_app_url: string;</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page207"/>Also, provide actual values in <code class="calibre7"><strong class="calibre3">server_config.json</strong></code> file:</p>
<p class="nonindent">For example:</p>
<p class="code"><code class="calibre7">"email_config": {</code></p>
<p class="code3"><code class="calibre7">"from": "pms-support@pms.com",</code></p>
<p class="code3"><code class="calibre7">"user": "pmsbook2023@gmail.com",</code></p>
<p class="code3"><code class="calibre7">"password": "*************"</code></p>
<p class="code2"><code class="calibre7">},</code></p>
<p class="code1"><code class="calibre7">"front_app_url": "http://127.0.0.1:5000"</code></p>
<p class="nonindent">After that, create <code class="calibre7"><strong class="calibre3">email_util.ts</strong></code> in the utils directory using the following code:</p>
<p class="code"><code class="calibre7"><a href="https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/email_util.ts">https://github.com/ava-orange-education/Hands-on-Rest-APIs-with-Node.js-and-Express/blob/main/ch-05-code-files/pms-be/src/utils/email_util.ts</a></code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">sendMail</strong></code> function provides a way to send emails using Gmail's SMTP server through Nodemailer. Make sure to replace the Gmail email, password, and other configurations with your actual values and customize the email content as needed.</p>
<p class="nonindent">For the <code class="calibre7"><strong class="calibre3">Forgot Password</strong></code> feature, users will initiate the process by submitting their email address. To facilitate this, we will enhance the <code class="calibre7"><strong class="calibre3">UsersUtil</strong></code> with a function named <code class="calibre7"><strong class="calibre3">getUserByEmail</strong></code>, responsible for retrieving user information based on their email. Here's the modified <code class="calibre7"><strong class="calibre3">UsersUtil</strong></code> with the added function:</p>
<p class="code"><code class="calibre7">export class UsersUtil {</code></p>
<p class="code2"><code class="calibre7">// … Existing methods and functionalities …</code></p>
<p class="code1"><code class="calibre7">public static async getUserByEmail(email: string) {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7"> if (email) {</code></p>
<p class="code5"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code5"><code class="calibre7">const users = await service.customQuery(`email = '${email}'`);</code></p>
<p class="code5"><code class="calibre7">if (users &amp;&amp; users.length &gt; 0) {</code></p>
<p class="code6"><code class="calibre7">return users[0];</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code3"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><code class="calibre7"> console.error(`Error while getUserFromToken() =&gt; ${error.message}`);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">return null;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">// … Other methods …</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page208"/>Now create forgot password function in the <code class="calibre7"><strong class="calibre3">users_controller.ts</strong></code> file as follows:</p>
<p class="code"><code class="calibre7">// users_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async forgotPassword(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7"> const { email } = req.body;</code></p>
<p class="code3"><code class="calibre7">const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;</code></p>
<p class="code3"><code class="calibre7">if (!emailPattern.test(email)) {</code></p>
<p class="code4"><code class="calibre7"> res.status(400).send({ statusCode: 400, status: 'error', message: 'Invalid email' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">const user: Users = await UsersUtil.getUserByEmail(email);</code></p>
<p class="code3"><code class="calibre7">if (!user) {</code></p>
<p class="code4"><code class="calibre7"> res.status(404).send({ statusCode: 404, status: 'error', message: 'User Not Found' });</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">// Generate a reset token for the user</code></p>
<p class="code3"><code class="calibre7">const resetToken: string = jwt.sign({ email: user.email },</code></p>
<p class="code1"><code class="calibre7">SERVER_CONST.JWTSECRET, {</code></p>
<p class="code4"><code class="calibre7"> expiresIn: '1h',</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code3"><code class="calibre7">// Generate the reset link</code></p>
<p class="code3"><code class="calibre7">const resetLink = `${config.front_app_url}/reset-password?</code></p>
<p class="code1"><code class="calibre7">token=${resetToken}`;</code></p>
<p class="code3"><code class="calibre7">const mailOptions = {</code></p>
<p class="code4"><code class="calibre7"> to: email,</code></p>
<p class="code4"><code class="calibre7"> subject: 'Password Reset',</code></p>
<p class="code4"><code class="calibre7"> html: ` Hello ${user.username},&lt;p&gt;We received a request to reset your password. <a id="page209"/>If you didn't initiate this request, please ignore this email.&lt;/p&gt;</code></p>
<p class="code4"><code class="calibre7"> &lt;p&gt;To reset your password, please click the link below:&lt;/p&gt;</code></p>
<p class="code4"><code class="calibre7"> &lt;p&gt;&lt;a href="${resetLink}" style="background-color: #007bff; color: #ffffff; text-decoration: none; padding: 10px 20px; border-radius: 5px; display: inline-block;"&gt;Reset Password&lt;/a&gt;&lt;/p&gt;</code></p>
<p class="code4"><code class="calibre7"> &lt;p&gt;If the link doesn't work, you can copy and paste the</code></p>
<p class="code1"><code class="calibre7">following URL into your browser:&lt;/p&gt;</code></p>
<p class="code4"><code class="calibre7"> &lt;p&gt;${resetLink}&lt;/p&gt;</code></p>
<p class="code4"><code class="calibre7"> &lt;p&gt;This link will expire in 1 hour for security reasons.&lt;/p&gt;</code></p>
<p class="code4"><code class="calibre7"> &lt;p&gt;If you didn't request a password reset, you can safely ignore this email.&lt;/p&gt;</code></p>
<p class="code4"><code class="calibre7"> &lt;p&gt;Best regards,&lt;br&gt;PMS Team&lt;/p&gt;`,</code></p>
<p class="code3"><code class="calibre7">};</code></p>
<p class="code3"><code class="calibre7">const emailStatus = await sendMail(mailOptions.to, mailOptions.subject, mailOptions.html);</code></p>
<p class="code3"><code class="calibre7">if (emailStatus) {</code></p>
<p class="code4"><code class="calibre7"> res.status(200).json({ statusCode: 200, status: 'success', message: 'Reset Link sent on your mailId', data: { 'resetToken':</code></p>
<p class="code1"><code class="calibre7">resetToken } });</code></p>
<p class="code3"><code class="calibre7">} else {</code></p>
<p class="code4"><code class="calibre7"> res.status(400).json({ statusCode: 400, status: 'error', message: 'something went wrong try again' });</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">return;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">forgotPassword</strong></code> function takes the user's email from the request body. It attempts to retrieve a user using the <code class="calibre7"><strong class="calibre3">getUserByEmail</strong></code> function from <code class="calibre7"><strong class="calibre3">UsersUtil</strong></code>. If no user is found, a <code class="calibre7"><strong class="calibre3">404</strong></code> response is sent, indicating "<code class="calibre7"><strong class="calibre3">User Not Found</strong></code>." If a user is found, a reset token is generated using JWT with the user's email and a one-hour expiration. A reset link is composed using the front-end application URL and the generated reset token. An email template is constructed with the reset link and instructions for the user. The <code class="calibre7"><strong class="calibre3">sendMail</strong></code> function is called to send the email, including recipient, subject, and HTML content. If the email is successfully sent, a <code class="calibre7"><strong class="calibre3">200</strong></code> response is sent with a success message and the reset token. If sending the email fails, a <code class="calibre7"><strong class="calibre3">400</strong></code> response is sent with an error message.</p>
<p class="nonindent">This function is called from <code class="calibre7"><strong class="calibre3">users_routes.ts</strong></code>, let's create a route for it:</p>
<p class="code"><code class="calibre7">// users_routes.ts</code></p>
<p class="code1"><code class="calibre7">export class UserRoutes {</code></p>
<p class="code1"><code class="calibre7"><a id="page210"/>//Other routes</code></p>
<p class="code1"><code class="calibre7">…</code></p>
<p class="code1"><code class="calibre7">app.route('/api/forgot_password')</code></p>
<p class="code4"><code class="calibre7">.post(controller.forgotPassword);</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3">REST API Forgot Password</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/forgot_password</code></p>
<p class="code1"><code class="calibre7">Method: POST</code></p>
<p class="code1"><code class="calibre7">body: {</code></p>
<p class="code2"><code class="calibre7">"email":"yamipanchal1993@gmail.com"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3">Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 200,</code></p>
<p class="code2"><code class="calibre7">"status": "success",</code></p>
<p class="code2"><code class="calibre7">"message": "Reset Link sent on your mailId",</code></p>
<p class="code2"><code class="calibre7">"data": {</code></p>
<p class="code3"><code class="calibre7">"resetToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJpYXQiOjE2OTMxNTU0MDIsImV4cCI6MTY5MzE1OTAwMn0.dM10tE43CSt8nArHjgHxRElk3IRBmdd_NHqpL5f1viU"</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">In case, if email is not passed or the requested email has no user, the server will respond with a <code class="calibre7"><strong class="calibre3">400</strong></code> and <code class="calibre7"><strong class="calibre3">404</strong></code> status code, respectively.</p>
<p class="nonindent">For example:</p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 404,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "User Not Found"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">When successfully sent, the mail will look like the following:</p>
<a id="page211"/>
<figure class="img">
<img alt="" src="img/5.6.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig5_6"><strong class="calibre3">Figure 5.6:</strong> Forgot Mail Sent Output</p>
<p class="nonindent"><strong class="calibre3">Note:</strong> In the context of the <code class="calibre7"><strong class="calibre3">Forgot Password</strong></code> functionality, please note that the inclusion of the <code class="calibre7"><strong class="calibre3">resetToken</strong></code> in the API response is solely for explanatory purposes. In actual practice, it is not recommended to provide the <code class="calibre7"><strong class="calibre3">resetToken</strong></code> in the API response for security reasons.</p>
<h1 class="sec" id="s170"><a href="toc.xhtml#s170a" class="calibre6">Reset Password</a></h1>
<p class="nonindent">Reset password is based on the rest token given in the forgotten password. Upon clicking the reset link, users are directed to a secure web page where they can enter their new password. This page confirms the validity of the token and prompts them to create a strong password that adheres to the platform's security requirements. On the backend side, the API first validates the request token and password. If it is valid, then only the password will be reset.</p>
<p class="nonindent">Create method for <code class="calibre7"><strong class="calibre3">resetPassword</strong></code> in the <code class="calibre7"><strong class="calibre3">users_controller.ts</strong></code> file as follows:</p>
<p class="code"><code class="calibre7">// users_controller.ts</code></p>
<p class="code1"><code class="calibre7">public async resetPassword(req: Request, res: Response): Promise&lt;void&gt; {</code></p>
<p class="code3"><code class="calibre7">const { newPassword, token } = req.body;</code></p>
<p class="code3"><code class="calibre7">const service = new UsersService();</code></p>
<p class="code3"><code class="calibre7">let email;</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7"> const decoded = jwt.verify(token, SERVER_CONST.JWTSECRET);</code></p>
<p class="code4"><code class="calibre7"> if (!decoded) {</code></p>
<p class="code5"><code class="calibre7">throw new Error('Invalid Reset Token');</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code4"><a id="page212"/><code class="calibre7"> email = decoded['email'];</code></p>
<p class="code3"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><code class="calibre7"> res.status(400).json({ statusCode: 400, status: 'error', message: 'Reset Token is invalid or expired' }).end();</code></p>
<p class="code4"><code class="calibre7"> return;</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7"> const user = await UsersUtil.getUserByEmail(email);</code></p>
<p class="code4"><code class="calibre7"> if (!user) {</code></p>
<p class="code5"><code class="calibre7">res.status(404).json({ statusCode: 404, status: 'error', message: 'User not found' }).end();</code></p>
<p class="code5"><code class="calibre7">return;</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code4"><code class="calibre7"> // Encrypt the user's new password</code></p>
<p class="code4"><code class="calibre7"> user.password = await encryptString(newPassword);</code></p>
<p class="code4"><code class="calibre7"> const result = await service.update(user.user_id, user);</code></p>
<p class="code4"><code class="calibre7"> if (result.statusCode === 200) {</code></p>
<p class="code5"><code class="calibre7">res.status(200).json({ statusCode: 200, status:</code></p>
<p class="code1"><code class="calibre7">'success', message: 'Password updated successfully' });</code></p>
<p class="code4"><code class="calibre7"> } else {</code></p>
<p class="code5"><code class="calibre7">res.status(result.statusCode).json(result).end();</code></p>
<p class="code4"><code class="calibre7"> }</code></p>
<p class="code3"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><code class="calibre7"> console.error(`Error while resetPassword =&gt;</code></p>
<p class="code1"><code class="calibre7">${error.message}`);</code></p>
<p class="code4"><code class="calibre7"> res.status(500).json({ statusCode: 500, status: 'error', message: 'Internal Server error' }).end();</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="nonindent">The <code class="calibre7"><strong class="calibre3">resetPassword</strong></code> extracts the <code class="calibre7"><strong class="calibre3">newPassword</strong></code> and token from the request body. It attempts to decode the token using JWT. If decoding the token fails, a <code class="calibre7"><strong class="calibre3">400</strong></code> response is sent with an <code class="calibre7"><strong class="calibre3">Invalid Reset Token</strong></code> error. If decoding the token succeeds, the function attempts to retrieve the user using the decoded email from the token. If no user is <a id="page213"/>found, a <code class="calibre7"><strong class="calibre3">404</strong></code> response is sent with a “User not found” error. If a user is found, the new password is encrypted and assigned to the user's password property. The update method of <code class="calibre7"><strong class="calibre3">UsersService</strong></code> is called to update the user's information in the database. If the update is successful (status code <code class="calibre7"><strong class="calibre3">200</strong></code>), a <code class="calibre7"><strong class="calibre3">200</strong></code> response is sent with a success message. If the update fails, the response status and result are based on the result of the update operation. In case of any error during the process, a <code class="calibre7"><strong class="calibre3">500</strong></code> response is sent with an “Internal Server Error” message.</p>
<p class="nonindent">This function is initiated from <code class="calibre7"><strong class="calibre3">users_routes.ts</strong></code> as follows:</p>
<p class="code"><code class="calibre7">const validResetPassword = [</code></p>
<p class="code2"><code class="calibre7">body('token').trim().notEmpty().withMessage('It should be required'),</code></p>
<p class="code2"><code class="calibre7">body('newPassword')</code></p>
<p class="code3"><code class="calibre7">.isLength({ min: 6, max: 12 }).withMessage('It must be between 6 and 12 characters in length')</code></p>
<p class="code3"><code class="calibre7">.isStrongPassword({ minLowercase: 1, minUppercase: 1,</code></p>
<p class="code1"><code class="calibre7">minSymbols: 1, minNumbers: 1 })</code></p>
<p class="code3"><code class="calibre7">.withMessage('It should include at least one uppercase letter, one lowercase letter, one special symbol, and one numerical digit.'), body('role_ids'),</code></p>
<p class="code1"><code class="calibre7">];</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code1"><code class="calibre7">export class UserRoutes {</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code1"><code class="calibre7">//Other routes</code></p>
<p class="code1"><code class="calibre7">…</code></p>
<p class="code2"><code class="calibre7">app.route('/api/reset_password')</code></p>
<p class="code4"><code class="calibre7"> .post(validate(validResetPassword),</code></p>
<p class="code1"><code class="calibre7">controller.resetPassword);</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3">REST API Reset Password</strong></p>
<p class="nonindent"><strong class="calibre3">Request</strong></p>
<p class="code"><code class="calibre7">URL: http://127.0.0.1:3000/api/reset_password</code></p>
<p class="code1"><code class="calibre7">Method: POST</code></p>
<p class="code1"><code class="calibre7">body: {</code></p>
<p class="code2"><code class="calibre7">"newPassword":"Pmsbook@123",</code></p>
<p class="code2"><code class="calibre7">"token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9. eyJlbWFpbCI6InlhbWlwYW5jaGFsMTk5M0BnbWFpbC5jb20iLCJpYXQiOjE2OTMwNzc1MTYsImV4cCI6MTY5MzA4MTExNn0.tAJgxypxNm5-xVgQtusLFiYomzax2-HQSGYPBNQUtk4"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><strong class="calibre3"><a id="page214"/>Response</strong></p>
<p class="code"><code class="calibre7">{</code></p>
<p class="code3"><code class="calibre7">statusCode: 200, status: 'success', message: 'Password updated successfully'</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">In case of token is not valid or expired, it gives 400 error as follows:</code></p>
<p class="code1"><code class="calibre7"/></p>
<p class="code1"><code class="calibre7">{</code></p>
<p class="code2"><code class="calibre7">"statusCode": 400,</code></p>
<p class="code2"><code class="calibre7">"status": "error",</code></p>
<p class="code2"><code class="calibre7">"message": "Reset Token is invalid or expired"</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Effective password management is paramount for user security. Implementing strong encryption, token-based resets, and clear policies fortifies protection and enhances user trust. We follow that standard kind of flow for password management.</p>
<h1 class="sec" id="s171"><a href="toc.xhtml#s171a" class="calibre6">Conclusion</a></h1>
<p class="nonindent">In this chapter, we covered a common base service for database operation and a base controller to perform REST API CRUD operations and other utility functions. We implemented the whole Role and User management with input validations for the PMS application. In addition, we also learned to send email functionality. In the next chapter, we will learn about the project and task core functionality of the PMS application.</p>

</body></html>