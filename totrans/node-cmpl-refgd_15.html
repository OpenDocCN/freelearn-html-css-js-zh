<html><head></head><body><div><h1 class="header-title">Restful API Design Guidelines</h1>
                
            
            
                
<p class="mce-root">In the previous chapter, we implemented a catalog module that exposed functions for data manipulation for the items in the catalog application. These functions made use of the <kbd>express.js</kbd> <strong>request</strong> object to parse the incoming data in the body and then to carry out the appropriate database operation. Each function populated the <strong>response</strong> object with a relevant status code and response body payload, if needed. Finally, we bound each function to a route, accepting HTTP requests.</p>
<p class="mce-root">Now, it's time to look closer into the URLs of the routes and into the returned HTTP status codes per operation.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul>
<li>Endpoint URLs and HTTP status codes best practices</li>
<li>Extensibility and versioning</li>
<li>Linked data</li>
</ul>


            

            
        
    </div>



  
<div><h1 class="header-title">Endpoint URLs and HTTP status codes best practices</h1>
                
            
            
                
<p>Each RESTful API operation is a combination of an HTTP request against a URL and an appropriate HTTP method.</p>
<p>When executed, each operation will return a status code, indicating whether the invocation has been successful or not. Successful invocation is indicated by a HTTP 2XX status code, while operations that are not executed correctly indicate this with erroneous status code—4XX if the error is at client side, or 5xx when the server fails to process a valid request.</p>
<p>Having a well-specified API is vital for its adoption. Such specification should not only completely enumerate the status codes of each operation, but should also specify the expected data format, that is, its supported media types.</p>
<p>The following table defines how the Express.js Router will expose the API operations, and it should serve as a reference specification for it:</p>
<table style="border-collapse: collapse" border="1">
<tbody>
<tr>
<td>Method</td>
<td>URI</td>
<td>Media type</td>
<td>Description</td>
<td>Status Code</td>
</tr>
<tr>
<td>GET</td>
<td>/catalog</td>
<td>application/json</td>
<td>
<p class="mce-root">Returns all the items in the catalog.</p>
<p> </p>
</td>
<td>
<p class="mce-root">200 OK</p>
<p>500 Internal Server Error</p>
</td>
</tr>
<tr>
<td>GET</td>
<td>/catalog/{categoryId}</td>
<td>application/json</td>
<td>Returns all items for the selected category.<br/>
If the category does not exist, it returns 404.</td>
<td>
<p class="mce-root">200 OK,</p>
<p>404 NOT FOUND</p>
<p>500 Internal Server Error</p>
</td>
</tr>
<tr>
<td>GET</td>
<td>/item/{itemId}</td>
<td>application/json</td>
<td>Returns a single item for the selected itemId.<br/>
If there is no such item, it returns 404.</td>
<td>
<p class="mce-root">200 OK,</p>
<p>404 NOT FOUND</p>
<p>500 Internal Server Error</p>
</td>
</tr>
<tr>
<td>POST</td>
<td>/item/</td>
<td>application/json</td>
<td>Creates a new item; if an item with the same identifier exists, it will be updated. When an item is created, a <strong>Location</strong> header is returned. It provides the URL where the newly created item can be accessed.</td>
<td>
<p class="mce-root">201 Created</p>
<p>200 OK</p>
<p>500 Internal Server Error</p>
</td>
</tr>
<tr>
<td>PUT</td>
<td>/item/{itemId}</td>
<td>application/json</td>
<td>Updates an existing item; if an item with the provided identifier does not exist, it creates it. When an item is created, a <strong>Location</strong> header is returned. It provides the URL where the newly created item can be accessed.</td>
<td>
<p class="mce-root">201 Created</p>
<p>200 OK</p>
<p>500 Internal Server Error</p>
</td>
</tr>
<tr>
<td>DELETE</td>
<td>/item/{itemId}</td>
<td>application/json</td>
<td>Deletes an existing item; if an item with the provided identifier does not exist, it returns 404.</td>
<td>
<p class="mce-root">200 OK,</p>
<p>404 NOT FOUND</p>
<p>500 Internal Server Error</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>The catalog application handles two types of entities: items and categories. Each item entity contains a collection of categories where it belongs. As you can see, the category is just a logical entity in our application; it will exist as long as there is at least one item referencing it, and will cease to exist when no items refer it. This is why the application exposes routes for exposing data manipulation functions only for resources of type items, while the operations for categories are more or less read only. Looking more carefully into the URLs exposing the data manipulation operations for the items, we can see a clear pattern aligning the URL to the REST fundamental principles—a resource is exposed by a single URL, and it supports resource manipulation actions that are determined by the HTTP method of the request. To sum up, listed here are the generally accepted rules that a well-defined API should follow. They are semantically related to each resource manipulation operation:</p>
<ul>
<li>When a <strong>new</strong> resource is created, the service makes use of the <strong>201 Created</strong> status code, followed by a location header that specifies the URL where the newly created resource can be accessed.</li>
<li>Operation that creates resources may be implemented to gracefully reject creation of resources, which unique identifiers already use; in such cases, the operation should indicate a non-successful invocation with an appropriate status code <strong>409 Conflict</strong>, or a more general <strong>400 BAD REQUEST</strong>. However, a general status code should always be followed by a meaningful explanation of what has gone wrong. In our implementation, we choose a different approach—we update the resource from the create operation, if it exists, and notify the caller that the resource was updated by returning the <strong>200 OK</strong> status code instead of <strong>201 Created</strong>.</li>
<li>The <strong>Update</strong> operation resembles the create operation; however, it always expects a resource identifier as a parameter, if a resource with this identifier exists—it gets updated with a new state provided in the body of the HTTP PUT request. The <strong>200 OK</strong> status code indicates successful invocation. The implementation may decide to reject handling of non-existent resources with the <strong>404 Not Found</strong> status code or creating a new resource with the passed identifier. In that case, it would return the <strong>201 Created</strong> status code, followed by a location header that specifies the URL where the newly created resource can be accessed. Our API makes use of the second option.</li>
<li>While successful <strong>deletion </strong>can be indicated with the <strong>204 No Content</strong> status and further payload, most user agents would expect the <strong>2xx</strong> HTTP status to be followed by a body. Thus, to stay compatible with most of the agents, our API will indicate successful deletion with the <strong>200 OK</strong> status code, followed by a JSON payload:<kbd>{'Status': 'Successfully deleted'}</kbd>. Status code <strong>404 Not found</strong> will indicate that a resource with the provided identifier does not exist.</li>
<li>As a general rule, <strong>5XX</strong> should not indicate application state errors but more severe errors, such as application server or database failures.</li>
<li>It is best practice that <kbd>update</kbd> and <kbd>create</kbd> operations should return as a payload to the entire state of the resource. For instance, if a resource is created with a minimum set of attributes, all non specified attribute will get default values; the response body should contain the full state of the object. The same is valid for updates; even if an update operation updates the resource restate partially, the response should return the complete state. This may save the user-agent an additional GET request if they needed to check the new state.</li>
</ul>
<p>Now that we have defined some general recommendations on how operations should behave, it's time to implement them in a new version of the API.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Discovering and exploring RESTful services</h1>
                
            
            
                
<p>The topic of discovering RESTful services has a long and complicated history. The HTTP specification states that a resource should be self-descriptive and that it should be identified uniquely by a URI. Dependent resources should be linked by the dependency using their own unique URIs. Discovering a RESTful service means navigating from one service to another, following the links it provides.</p>
<p>In the year 2009, a specification called <strong>Web Application Discovery Language</strong> (<strong>WADL</strong>) was invented. It aims to document every URI exposed from a web application, along with the HTTP methods it supports and the parameter it expects. The response media type of the URI is also described. This is very useful for documenting purposes, and it's all that a WADL file can provide us in terms of RESTful service provisioning.</p>
<p>Unfortunately, there is currently no Node.js module that can automatically generate a WADL file for a given express route. We will have to manually create a WADL file to demonstrate how it is used by other clients for discovery.</p>
<p>The following listing shows a sample WADL file describing the resources available at <kbd>/catalog, /catalog/v2/{categoryId}</kbd>:</p>
<pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/>&lt;application   &gt;<br/>   &lt;grammer&gt;<br/>      &lt;include href="items.xsd" /&gt;<br/>      &lt;include href="error.xsd" /&gt;<br/>   &lt;/grammer&gt;<br/>   &lt;resources base="http://localhost:8080/catalog/"&gt;<br/>      &lt;resource path="{categoryId}"&gt;<br/>         &lt;method name="GET"&gt;<br/>            &lt;request&gt;<br/>               &lt;param name="category" type="xsd:string" style="template" /&gt;<br/>            &lt;/request&gt;<br/>            &lt;response status="200"&gt;<br/>               &lt;representation mediaType="application/xml" element="service:item" /&gt;<br/>               &lt;representation mediaType="application/json" /&gt;<br/>            &lt;/response&gt;<br/>            &lt;response status="404"&gt;<br/>               &lt;representation mediaType="text/plain" element="service:item" /&gt;<br/>            &lt;/response&gt;<br/>         &lt;/method&gt;<br/>      &lt;/resource&gt;<br/>      &lt;resource path="/v2/{categoryId}"&gt;<br/>         &lt;method name="GET"&gt;<br/>            &lt;request&gt;<br/>               &lt;param name="category" type="xsd:string" style="template" /&gt;<br/>            &lt;/request&gt;<br/>            &lt;response status="200"&gt;<br/>               &lt;representation mediaType="application/xml" element="service:item" /&gt;<br/>               &lt;representation mediaType="application/json" /&gt;<br/>            &lt;/response&gt;<br/>            &lt;response status="404"&gt;<br/>               &lt;representation mediaType="text/plain" element="service:item" /&gt;<br/>            &lt;/response&gt;<br/>         &lt;/method&gt;<br/>      &lt;/resource&gt;<br/>   &lt;/resources&gt;<br/>&lt;/application&gt;</pre>
<p>As you can see, the WADL format is very straightforward. It basically describes the URI of each resource, providing information about the media types it uses and the status codes that are expected at that URI. Many third-party RESTful clients understand the WADL language and can generate request messages out of a given WADL file.</p>
<p>Let's import the WADL file in Postman. Click on the Import button and select your WADL file:</p>
<div><img src="img/6d8accb0-6e40-4112-ac97-769cdac28d1d.png" width="1527" height="877"/></div>
<p>Import a WADL in Postman to get a stub of the service. This is a screenshot for Postman. The individual settings are not important here. The purpose of the image is just to show how the window looks.</p>
<p>As you can see, the result of importing the WADL file is that we have a project ready to test each aspect of a REST service in the nick of time. All the routes defined in the WADL file are now conveniently available as separate request entities on the right menu. That's not all; apart from the WADL standard, currently the swagger documentation format is heavily adopted and has become an informal standard for describing RESTful services, so we can also use it to ease the adoption and discovery of our service. In the next chapter, we will bind these description files to our service. This is an important step in the phase of production preparation.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Extensibility and versioning</h1>
                
            
            
                
<p class="mce-root">We've already defined a few basic versioning rules in <a href="8e04f868-a684-41a0-aed1-bbff8b9c5c2e.xhtml" target="_blank">Chapter 13</a>, <em>Building a Typical Web API</em>. Let's apply them to the MongoDB database-aware module we implemented in the previous chapter. Our starting point would be to enable the current consumers of the API to continue using the same version on a different URL. This will keep them backward-compatible until they adopt and successfully test the new version.</p>
<p class="mce-root">Keeping a REST API stable is not a question of only moving one endpoint from one URI to another. It makes no sense to perform redirection and afterward have an API that behaves differently. Thus, we need to ensure that the behavior of the moved endpoint stays the same. To ensure that we don't change the previously implemented behavior, let's move the current behavior from the <kbd>catalog.js</kbd> module to a new module by renaming the file to <kbd>catalogV1.js</kbd>. Then, make a copy of it to the  <kbd>catalogV2.js</kbd> module, where we will introduce all new functionality; but before doing that, we have to reroute Version 1 from <kbd>/, /{categoryId}, /{itemId}</kbd> to <kbd>/v1, /v1/{categoryId}, /v1/{itemId}</kbd>:</p>
<pre>const express = require('express');<br/>const router = express.Router();<br/><br/>const catalogV1 = require('../modules/catalogV1');<br/>const model = require('../model/item.js');<br/><br/>router.get('/v1/', function(request, response, next) {<br/>  catalogV1.findAllItems(response);<br/>});<br/><br/>router.get('/v1/item/:itemId', function(request, response, next) {<br/>  console.log(request.url + ' : querying for ' + request.params.itemId);<br/>  catalogV1.findItemById(request.params.itemId, response);<br/>});<br/><br/>router.get('/v1/:categoryId', function(request, response, next) {<br/>  console.log(request.url + ' : querying for ' + request.params.categoryId);<br/>  catalogV1.findItemsByCategory(request.params.categoryId, response);<br/>});<br/><br/>router.post('/v1/', function(request, response, next) {<br/>  catalogV1.saveItem(request, response);<br/>});<br/><br/>router.put('/v1/', function(request, response, next) {<br/>  catalogV1.saveItem(request, response);<br/>});<br/><br/>router.delete('/v1/item/:itemId', function(request, response, next) {<br/>  catalogV1.remove(request, response);<br/>});<br/><br/>router.get('/', function(request, response) {<br/>  console.log('Redirecting to v1');<br/>  response.writeHead(301, {'Location' : '/catalog/v1/'});<br/>  response.end('Version 1 is moved to /catalog/v1/: ');<br/>});<br/><br/>module.exports = router;</pre>
<p>Since Version 2 of our API is not yet implemented, executing a <kbd>GET</kbd> request against <kbd>/</kbd> will result in receiving a <kbd>301 Moved Permanently</kbd> HTTP status, which will then redirect to <kbd>/v1/</kbd>. This will notify our consumers that the API is evolving and that they will soon need to decide whether to continue using Version 1 by explicitly requesting its new URI or prepare for adopting Version 2.</p>
<p>Go ahead and give it a try! Start the modified node application and, from Postman, make a GET request to <kbd>http://localhost:3000/catalog</kbd>:</p>
<div><img src="img/d5c50d84-3651-4d71-a52a-95d01d81602c.png" width="1500" height="979"/></div>
<p>You will see that your request is redirected to the newly routed location at <kbd>http://localhost:3000/catalog/v1</kbd>.</p>
<p>Now that we have finalized Version 1 of the catalog, it's time to think of further extensions that we can add in Version 2. Currently, the catalog service supports listing of all items in a category and fetching an item by its ID. It's about time to take full advantage of MongoDB, being a document-oriented database, and implement a function that will enable our API consumer to query for items based on any of their attributes. For instance, list all items for a specific category with an attribute that matches a query parameter, such as price or color, or search by item name. RESTful services usually expose document-oriented data. However, their usage is not limited to documents only. In the next chapter, we will extend the catalog in a way that it also stores binary data—an image that can be linked to each item. For that purpose, we will use a MongoDB binary format called <strong>Binary JSON</strong> (<strong>BSON</strong>) in the <em>Working with arbitrary data</em> section in <a href="92c4bc26-7983-4f36-b220-055f81dca007.xhtml">Chapter 16</a>, <em>Implementing a Full Fledged RESTful Service</em>.</p>
<p>Getting back to the searching extension, we've already used the <kbd>Mongoose.js</kbd> model's <kbd>find()</kbd> and <kbd>findOne()</kbd> functions. So far, we used them to provide the name of the document attribute to be searched with, statically, in our JavaScript code. However, this filtering parameter of <kbd>find()</kbd> is just a JSON object where the key is the document attribute and the value is the attribute's value to be used in the query. Here is the first new function we will add to Version 2. It queries MongoDB by an arbitrary attribute and its value:</p>
<pre>exports.findItemsByAttribute = function (key, value, response) {<br/>      var filter = {};<br/>      filter[key] = value;<br/>      CatalogItem.find(filter, function(error, result) {<br/>          if (error) {<br/>              console.error(error);<br/>              response.writeHead(500, contentTypePlainText);<br/>              response.end('Internal server error');<br/>              return;<br/>          } else {<br/>              if (!result) {<br/>                  if (response != null) {<br/>                     response.writeHead(200, contentTypeJson);<br/>                     response.end({});<br/>                  }<br/>                  return;<br/>              }<br/>              if (response != null){<br/>                  response.setHeader('Content-Type', 'application/json');<br/>                  response.send(result);<br/>              }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<pre>          }<br/>      });<br/>    }</pre>
<p>This function calls find on the model with the provided attribute and value as parameters. We will bind this function to the router's <kbd>/v2/item/</kbd> GET handler.</p>
<p>At the end, our aim is to have <kbd>/v2/item/?currency=USD</kbd> that returns only records for items that are sold in USD currency, as indicated by the value of the passed GET parameter. That way, if we modify the model with additional attributes, such as color and size, we can query for all items having the same color or any other attribute that an item can have.</p>
<p>We will keep the old behavior of returning a list of all available items when no parameters are provided within the query string, but we will also parse the query string for the first provided <kbd>GET</kbd> parameter and use it as a filter in the <kbd>findItemsByAttribute()</kbd> function:</p>
<pre>router.get('/v2/items', function(request, response) {<br/>    var getParams = url.parse(request.url, true).query;<br/>    if (Object.keys(getParams).length == 0) {<br/>      catalogV2.findAllItems(response);<br/>    } else {<br/>      var key = Object.keys(getParams)[0];<br/>      var value = getParams[key];<br/>      catalogV2.findItemsByAttribute(key, value, response);<br/>    }<br/>});</pre>
<p>Perhaps the most interesting part in this function is the URL parsing. As you can see, we keep using the same old strategy to check whether any <kbd>GET</kbd> parameters are supplied. We parse the URL in order to get the query string, and then we use the built-in <kbd>Object.keys</kbd> function to check whether the parsed key/value list contains elements. If it does, we take the first element and extract its value. Both the key and the value are passed to the <kbd>findByAttribute</kbd> function.</p>
<p>You may want to improve Version 2 further by providing search support by multiple arguments that are provided by more than one <kbd>GET</kbd> parameters. I will leave that to you as an exercise.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Linked data</h1>
                
            
            
                
<p>Every catalog application supports an image or set of images bound to this item. For that purpose, in the next chapter, we will see how to work with binary objects in MongoDB. However, now is the time to decide how to semantically link the binary data to an item document. Extending the model schema in such a way that it contains binary base64 representation of binary data in the document is anything but a good idea, as mixing literally encoded and binary data in one format is never a good idea. It increases the complexity of the application and makes it error-prone:</p>
<pre>{
  "_id": "5a4c004b0eed73835833cc9a",
  "itemId": "1",
  "itemName": "Sports Watch",
  "price": 100,
  "currency": "EUR",
  "categories": [
    "Watches",
    "Sports Watches"
  ],
  "image":" 
iVBORw0KGgoAAAANSUhEUgAAAJEAAACRCAMAAAD0BqoRAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNuzjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MjMwNjQ1NDdFNjJCMTFERkI5QzU4OTFCMjJCQzEzM0EiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MjMwNjQ1NDhFNjJCMTFERkI5QzU4OTFCMjJCQzEzM0EiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDoyMzA2NDU0NUU2MkIxMURGQjlDNTg5MUIyMkJDMTMzQSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDoyMzA2NDU0NkU2MkIxMURGQjlDNTg5MUIyMkJDMTMzQSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Px5Xq1XXhWFY1+v151/b3ij5tI/GPEVP0e8U/SPAABPLjHnaJ6XvAAAAAElFTkSuQmCC 
"} </pre>
<p>Imagine how large a result for a non-filtered query can become just for a few hundred items, if all of them had an image binary representation as a value of a JSON attribute. To avoid that, we will return the image for each item at a URL that is logically linked to the resource's URL—<kbd>/catalog/v2/item/{itemId}/image</kbd>.</p>
<p>That way, if there is an image assigned to an item, it will be served at a known location. This approach, however, does not semantically link the binary item to its corresponding resource, as when accessing the item at <kbd>/catalog/v2/item/{itemId}</kbd>, there would be no indication of whether it has an image assigned or not. To solve this, let's use a custom HTTP header in response of the item route:</p>
<pre>GET http://localhost:3000/catalog/v2/item/1 HTTP/1.1 <br/>Host: localhost:3000 <br/>Connection: Keep-Alive <br/>User-Agent: Apache-HttpClient/4.1.1 (java 1.5) <br/><br/>HTTP/1.1 200 OK <br/>X-Powered-By: Express <br/>Content-Type: application/json; charset=utf-8 <br/>Content-Length: 152 <br/>Image-Url: http://localhost:3000/catalog/v2/item/1/image<br/>ETag: W/"98-2nJj2mZdLV2YDME3WYCyEwIXfuA" <br/>Date: Thu, 01 Feb 2018 13:50:43 GMT <br/>Connection: keep-alive <br/><br/>{<br/>  "_id": "5a4c004b0eed73835833cc9a",<br/>  "itemId": "1",<br/>  "itemName": "Sports Watch",<br/>  "price": 100,<br/>  "currency": "EUR",<br/>  "__v": 0,<br/>  "categories": [<br/>    "Watches",<br/>    "Sports Watches"<br/>  ]<br/>}</pre>
<p>When present in the response, the <kbd>Image-Url</kbd> header indicates that the item has an additional resource bound to it, and the header value provides the address where it is available. Using this approach, we linked a binary resource semantically to our document.</p>
<p>In the next chapter, we will implement the routes that will handle the manipulation of arbitrary items bound to the items in the catalog.</p>


            

            
        
    </div>



  
<div><h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we discussed in detail how resources should be exposed via a RESTful API; we paid close attention to URL best practices and looked into appropriate usage of the HTTP status codes indicating each state of our operations.</p>
<p>We covered the topics of versioning and extensibility, where we used the <kbd>301 Moved Permanently</kbd> status code to automatically redirect API calls to different URLs.</p>
<p>Finally, we figured out how to semantically link our resource items to arbitrary binary represented data.</p>


            

            
        
    </div>



  </body></html>